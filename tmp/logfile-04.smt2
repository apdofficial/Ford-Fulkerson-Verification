(get-info :version)
; (:version "4.8.6")
; Started: 2022-06-16 09:19:35
; Silicon.version: 1.1-SNAPSHOT (cd20cf02@(detached))
; Input file: -
; Verifier id: 00
; ------------------------------------------------------------
; Begin preamble
; ////////// Static preamble
; 
; ; /z3config.smt2
(set-option :print-success true) ; Boogie: false
(set-option :global-decls true) ; Boogie: default
(set-option :auto_config false) ; Usually a good idea
(set-option :smt.restart_strategy 0)
(set-option :smt.restart_factor |1.5|)
(set-option :smt.case_split 3)
(set-option :smt.delay_units true)
(set-option :smt.delay_units_threshold 16)
(set-option :nnf.sk_hack true)
(set-option :type_check true)
(set-option :smt.bv.reflect true)
(set-option :smt.mbqi false)
(set-option :smt.qi.eager_threshold 100)
(set-option :smt.qi.cost "(+ weight generation)")
(set-option :smt.qi.max_multi_patterns 1000)
(set-option :smt.phase_selection 0) ; default: 3, Boogie: 0
(set-option :sat.phase caching)
(set-option :sat.random_seed 0)
(set-option :nlsat.randomize true)
(set-option :nlsat.seed 0)
(set-option :nlsat.shuffle_vars false)
(set-option :fp.spacer.order_children 0) ; Not available with Z3 4.5
(set-option :fp.spacer.random_seed 0) ; Not available with Z3 4.5
(set-option :smt.arith.random_initial_value true) ; Boogie: true
(set-option :smt.random_seed 0)
(set-option :sls.random_offset true)
(set-option :sls.random_seed 0)
(set-option :sls.restart_init false)
(set-option :sls.walksat_ucb true)
(set-option :model.v2 true)
; 
; ; /preamble.smt2
(declare-datatypes () ((
    $Snap ($Snap.unit)
    ($Snap.combine ($Snap.first $Snap) ($Snap.second $Snap)))))
(declare-sort $Ref 0)
(declare-const $Ref.null $Ref)
(declare-sort $FPM)
(declare-sort $PPM)
(define-sort $Perm () Real)
(define-const $Perm.Write $Perm 1.0)
(define-const $Perm.No $Perm 0.0)
(define-fun $Perm.isValidVar ((p $Perm)) Bool
	(<= $Perm.No p))
(define-fun $Perm.isReadVar ((p $Perm) (ub $Perm)) Bool
    (and ($Perm.isValidVar p)
         (not (= p $Perm.No))
         (< p $Perm.Write)))
(define-fun $Perm.min ((p1 $Perm) (p2 $Perm)) Real
    (ite (<= p1 p2) p1 p2))
(define-fun $Math.min ((a Int) (b Int)) Int
    (ite (<= a b) a b))
(define-fun $Math.clip ((a Int)) Int
    (ite (< a 0) 0 a))
; ////////// Sorts
(declare-sort Seq<Seq<Int>>)
(declare-sort Seq<Int>)
(declare-sort Set<Int>)
(declare-sort Set<Bool>)
(declare-sort Set<option<array>>)
(declare-sort Set<$Ref>)
(declare-sort Set<$Snap>)
(declare-sort t_null)
(declare-sort any)
(declare-sort void)
(declare-sort option<any>)
(declare-sort option<array>)
(declare-sort array)
(declare-sort $FVF<Int>)
(declare-sort $FVF<option<array>>)
(declare-sort $FVF<Bool>)
(declare-sort $FVF<$Ref>)
; ////////// Sort wrappers
; Declaring additional sort wrappers
(declare-fun $SortWrappers.IntTo$Snap (Int) $Snap)
(declare-fun $SortWrappers.$SnapToInt ($Snap) Int)
(assert (forall ((x Int)) (!
    (= x ($SortWrappers.$SnapToInt($SortWrappers.IntTo$Snap x)))
    :pattern (($SortWrappers.IntTo$Snap x))
    :qid |$Snap.$SnapToIntTo$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.IntTo$Snap($SortWrappers.$SnapToInt x)))
    :pattern (($SortWrappers.$SnapToInt x))
    :qid |$Snap.IntTo$SnapToInt|
    )))
(declare-fun $SortWrappers.BoolTo$Snap (Bool) $Snap)
(declare-fun $SortWrappers.$SnapToBool ($Snap) Bool)
(assert (forall ((x Bool)) (!
    (= x ($SortWrappers.$SnapToBool($SortWrappers.BoolTo$Snap x)))
    :pattern (($SortWrappers.BoolTo$Snap x))
    :qid |$Snap.$SnapToBoolTo$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.BoolTo$Snap($SortWrappers.$SnapToBool x)))
    :pattern (($SortWrappers.$SnapToBool x))
    :qid |$Snap.BoolTo$SnapToBool|
    )))
(declare-fun $SortWrappers.$RefTo$Snap ($Ref) $Snap)
(declare-fun $SortWrappers.$SnapTo$Ref ($Snap) $Ref)
(assert (forall ((x $Ref)) (!
    (= x ($SortWrappers.$SnapTo$Ref($SortWrappers.$RefTo$Snap x)))
    :pattern (($SortWrappers.$RefTo$Snap x))
    :qid |$Snap.$SnapTo$RefTo$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.$RefTo$Snap($SortWrappers.$SnapTo$Ref x)))
    :pattern (($SortWrappers.$SnapTo$Ref x))
    :qid |$Snap.$RefTo$SnapTo$Ref|
    )))
(declare-fun $SortWrappers.$PermTo$Snap ($Perm) $Snap)
(declare-fun $SortWrappers.$SnapTo$Perm ($Snap) $Perm)
(assert (forall ((x $Perm)) (!
    (= x ($SortWrappers.$SnapTo$Perm($SortWrappers.$PermTo$Snap x)))
    :pattern (($SortWrappers.$PermTo$Snap x))
    :qid |$Snap.$SnapTo$PermTo$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.$PermTo$Snap($SortWrappers.$SnapTo$Perm x)))
    :pattern (($SortWrappers.$SnapTo$Perm x))
    :qid |$Snap.$PermTo$SnapTo$Perm|
    )))
; Declaring additional sort wrappers
(declare-fun $SortWrappers.Seq<Seq<Int>>To$Snap (Seq<Seq<Int>>) $Snap)
(declare-fun $SortWrappers.$SnapToSeq<Seq<Int>> ($Snap) Seq<Seq<Int>>)
(assert (forall ((x Seq<Seq<Int>>)) (!
    (= x ($SortWrappers.$SnapToSeq<Seq<Int>>($SortWrappers.Seq<Seq<Int>>To$Snap x)))
    :pattern (($SortWrappers.Seq<Seq<Int>>To$Snap x))
    :qid |$Snap.$SnapToSeq<Seq<Int>>To$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.Seq<Seq<Int>>To$Snap($SortWrappers.$SnapToSeq<Seq<Int>> x)))
    :pattern (($SortWrappers.$SnapToSeq<Seq<Int>> x))
    :qid |$Snap.Seq<Seq<Int>>To$SnapToSeq<Seq<Int>>|
    )))
(declare-fun $SortWrappers.Seq<Int>To$Snap (Seq<Int>) $Snap)
(declare-fun $SortWrappers.$SnapToSeq<Int> ($Snap) Seq<Int>)
(assert (forall ((x Seq<Int>)) (!
    (= x ($SortWrappers.$SnapToSeq<Int>($SortWrappers.Seq<Int>To$Snap x)))
    :pattern (($SortWrappers.Seq<Int>To$Snap x))
    :qid |$Snap.$SnapToSeq<Int>To$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.Seq<Int>To$Snap($SortWrappers.$SnapToSeq<Int> x)))
    :pattern (($SortWrappers.$SnapToSeq<Int> x))
    :qid |$Snap.Seq<Int>To$SnapToSeq<Int>|
    )))
; Declaring additional sort wrappers
(declare-fun $SortWrappers.Set<Int>To$Snap (Set<Int>) $Snap)
(declare-fun $SortWrappers.$SnapToSet<Int> ($Snap) Set<Int>)
(assert (forall ((x Set<Int>)) (!
    (= x ($SortWrappers.$SnapToSet<Int>($SortWrappers.Set<Int>To$Snap x)))
    :pattern (($SortWrappers.Set<Int>To$Snap x))
    :qid |$Snap.$SnapToSet<Int>To$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.Set<Int>To$Snap($SortWrappers.$SnapToSet<Int> x)))
    :pattern (($SortWrappers.$SnapToSet<Int> x))
    :qid |$Snap.Set<Int>To$SnapToSet<Int>|
    )))
(declare-fun $SortWrappers.Set<Bool>To$Snap (Set<Bool>) $Snap)
(declare-fun $SortWrappers.$SnapToSet<Bool> ($Snap) Set<Bool>)
(assert (forall ((x Set<Bool>)) (!
    (= x ($SortWrappers.$SnapToSet<Bool>($SortWrappers.Set<Bool>To$Snap x)))
    :pattern (($SortWrappers.Set<Bool>To$Snap x))
    :qid |$Snap.$SnapToSet<Bool>To$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.Set<Bool>To$Snap($SortWrappers.$SnapToSet<Bool> x)))
    :pattern (($SortWrappers.$SnapToSet<Bool> x))
    :qid |$Snap.Set<Bool>To$SnapToSet<Bool>|
    )))
(declare-fun $SortWrappers.Set<option<array>>To$Snap (Set<option<array>>) $Snap)
(declare-fun $SortWrappers.$SnapToSet<option<array>> ($Snap) Set<option<array>>)
(assert (forall ((x Set<option<array>>)) (!
    (= x ($SortWrappers.$SnapToSet<option<array>>($SortWrappers.Set<option<array>>To$Snap x)))
    :pattern (($SortWrappers.Set<option<array>>To$Snap x))
    :qid |$Snap.$SnapToSet<option<array>>To$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.Set<option<array>>To$Snap($SortWrappers.$SnapToSet<option<array>> x)))
    :pattern (($SortWrappers.$SnapToSet<option<array>> x))
    :qid |$Snap.Set<option<array>>To$SnapToSet<option<array>>|
    )))
(declare-fun $SortWrappers.Set<$Ref>To$Snap (Set<$Ref>) $Snap)
(declare-fun $SortWrappers.$SnapToSet<$Ref> ($Snap) Set<$Ref>)
(assert (forall ((x Set<$Ref>)) (!
    (= x ($SortWrappers.$SnapToSet<$Ref>($SortWrappers.Set<$Ref>To$Snap x)))
    :pattern (($SortWrappers.Set<$Ref>To$Snap x))
    :qid |$Snap.$SnapToSet<$Ref>To$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.Set<$Ref>To$Snap($SortWrappers.$SnapToSet<$Ref> x)))
    :pattern (($SortWrappers.$SnapToSet<$Ref> x))
    :qid |$Snap.Set<$Ref>To$SnapToSet<$Ref>|
    )))
(declare-fun $SortWrappers.Set<$Snap>To$Snap (Set<$Snap>) $Snap)
(declare-fun $SortWrappers.$SnapToSet<$Snap> ($Snap) Set<$Snap>)
(assert (forall ((x Set<$Snap>)) (!
    (= x ($SortWrappers.$SnapToSet<$Snap>($SortWrappers.Set<$Snap>To$Snap x)))
    :pattern (($SortWrappers.Set<$Snap>To$Snap x))
    :qid |$Snap.$SnapToSet<$Snap>To$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.Set<$Snap>To$Snap($SortWrappers.$SnapToSet<$Snap> x)))
    :pattern (($SortWrappers.$SnapToSet<$Snap> x))
    :qid |$Snap.Set<$Snap>To$SnapToSet<$Snap>|
    )))
; Declaring additional sort wrappers
(declare-fun $SortWrappers.t_nullTo$Snap (t_null) $Snap)
(declare-fun $SortWrappers.$SnapTot_null ($Snap) t_null)
(assert (forall ((x t_null)) (!
    (= x ($SortWrappers.$SnapTot_null($SortWrappers.t_nullTo$Snap x)))
    :pattern (($SortWrappers.t_nullTo$Snap x))
    :qid |$Snap.$SnapTot_nullTo$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.t_nullTo$Snap($SortWrappers.$SnapTot_null x)))
    :pattern (($SortWrappers.$SnapTot_null x))
    :qid |$Snap.t_nullTo$SnapTot_null|
    )))
(declare-fun $SortWrappers.anyTo$Snap (any) $Snap)
(declare-fun $SortWrappers.$SnapToany ($Snap) any)
(assert (forall ((x any)) (!
    (= x ($SortWrappers.$SnapToany($SortWrappers.anyTo$Snap x)))
    :pattern (($SortWrappers.anyTo$Snap x))
    :qid |$Snap.$SnapToanyTo$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.anyTo$Snap($SortWrappers.$SnapToany x)))
    :pattern (($SortWrappers.$SnapToany x))
    :qid |$Snap.anyTo$SnapToany|
    )))
(declare-fun $SortWrappers.voidTo$Snap (void) $Snap)
(declare-fun $SortWrappers.$SnapTovoid ($Snap) void)
(assert (forall ((x void)) (!
    (= x ($SortWrappers.$SnapTovoid($SortWrappers.voidTo$Snap x)))
    :pattern (($SortWrappers.voidTo$Snap x))
    :qid |$Snap.$SnapTovoidTo$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.voidTo$Snap($SortWrappers.$SnapTovoid x)))
    :pattern (($SortWrappers.$SnapTovoid x))
    :qid |$Snap.voidTo$SnapTovoid|
    )))
(declare-fun $SortWrappers.option<any>To$Snap (option<any>) $Snap)
(declare-fun $SortWrappers.$SnapTooption<any> ($Snap) option<any>)
(assert (forall ((x option<any>)) (!
    (= x ($SortWrappers.$SnapTooption<any>($SortWrappers.option<any>To$Snap x)))
    :pattern (($SortWrappers.option<any>To$Snap x))
    :qid |$Snap.$SnapTooption<any>To$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.option<any>To$Snap($SortWrappers.$SnapTooption<any> x)))
    :pattern (($SortWrappers.$SnapTooption<any> x))
    :qid |$Snap.option<any>To$SnapTooption<any>|
    )))
(declare-fun $SortWrappers.option<array>To$Snap (option<array>) $Snap)
(declare-fun $SortWrappers.$SnapTooption<array> ($Snap) option<array>)
(assert (forall ((x option<array>)) (!
    (= x ($SortWrappers.$SnapTooption<array>($SortWrappers.option<array>To$Snap x)))
    :pattern (($SortWrappers.option<array>To$Snap x))
    :qid |$Snap.$SnapTooption<array>To$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.option<array>To$Snap($SortWrappers.$SnapTooption<array> x)))
    :pattern (($SortWrappers.$SnapTooption<array> x))
    :qid |$Snap.option<array>To$SnapTooption<array>|
    )))
(declare-fun $SortWrappers.arrayTo$Snap (array) $Snap)
(declare-fun $SortWrappers.$SnapToarray ($Snap) array)
(assert (forall ((x array)) (!
    (= x ($SortWrappers.$SnapToarray($SortWrappers.arrayTo$Snap x)))
    :pattern (($SortWrappers.arrayTo$Snap x))
    :qid |$Snap.$SnapToarrayTo$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.arrayTo$Snap($SortWrappers.$SnapToarray x)))
    :pattern (($SortWrappers.$SnapToarray x))
    :qid |$Snap.arrayTo$SnapToarray|
    )))
; Declaring additional sort wrappers
(declare-fun $SortWrappers.$FVF<Int>To$Snap ($FVF<Int>) $Snap)
(declare-fun $SortWrappers.$SnapTo$FVF<Int> ($Snap) $FVF<Int>)
(assert (forall ((x $FVF<Int>)) (!
    (= x ($SortWrappers.$SnapTo$FVF<Int>($SortWrappers.$FVF<Int>To$Snap x)))
    :pattern (($SortWrappers.$FVF<Int>To$Snap x))
    :qid |$Snap.$SnapTo$FVF<Int>To$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.$FVF<Int>To$Snap($SortWrappers.$SnapTo$FVF<Int> x)))
    :pattern (($SortWrappers.$SnapTo$FVF<Int> x))
    :qid |$Snap.$FVF<Int>To$SnapTo$FVF<Int>|
    )))
(declare-fun $SortWrappers.$FVF<option<array>>To$Snap ($FVF<option<array>>) $Snap)
(declare-fun $SortWrappers.$SnapTo$FVF<option<array>> ($Snap) $FVF<option<array>>)
(assert (forall ((x $FVF<option<array>>)) (!
    (= x ($SortWrappers.$SnapTo$FVF<option<array>>($SortWrappers.$FVF<option<array>>To$Snap x)))
    :pattern (($SortWrappers.$FVF<option<array>>To$Snap x))
    :qid |$Snap.$SnapTo$FVF<option<array>>To$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.$FVF<option<array>>To$Snap($SortWrappers.$SnapTo$FVF<option<array>> x)))
    :pattern (($SortWrappers.$SnapTo$FVF<option<array>> x))
    :qid |$Snap.$FVF<option<array>>To$SnapTo$FVF<option<array>>|
    )))
(declare-fun $SortWrappers.$FVF<Bool>To$Snap ($FVF<Bool>) $Snap)
(declare-fun $SortWrappers.$SnapTo$FVF<Bool> ($Snap) $FVF<Bool>)
(assert (forall ((x $FVF<Bool>)) (!
    (= x ($SortWrappers.$SnapTo$FVF<Bool>($SortWrappers.$FVF<Bool>To$Snap x)))
    :pattern (($SortWrappers.$FVF<Bool>To$Snap x))
    :qid |$Snap.$SnapTo$FVF<Bool>To$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.$FVF<Bool>To$Snap($SortWrappers.$SnapTo$FVF<Bool> x)))
    :pattern (($SortWrappers.$SnapTo$FVF<Bool> x))
    :qid |$Snap.$FVF<Bool>To$SnapTo$FVF<Bool>|
    )))
(declare-fun $SortWrappers.$FVF<$Ref>To$Snap ($FVF<$Ref>) $Snap)
(declare-fun $SortWrappers.$SnapTo$FVF<$Ref> ($Snap) $FVF<$Ref>)
(assert (forall ((x $FVF<$Ref>)) (!
    (= x ($SortWrappers.$SnapTo$FVF<$Ref>($SortWrappers.$FVF<$Ref>To$Snap x)))
    :pattern (($SortWrappers.$FVF<$Ref>To$Snap x))
    :qid |$Snap.$SnapTo$FVF<$Ref>To$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.$FVF<$Ref>To$Snap($SortWrappers.$SnapTo$FVF<$Ref> x)))
    :pattern (($SortWrappers.$SnapTo$FVF<$Ref> x))
    :qid |$Snap.$FVF<$Ref>To$SnapTo$FVF<$Ref>|
    )))
; ////////// Symbols
(declare-fun Set_in (Int Set<Int>) Bool)
(declare-fun Set_card (Set<Int>) Int)
(declare-const Set_empty Set<Int>)
(declare-fun Set_singleton (Int) Set<Int>)
(declare-fun Set_unionone (Set<Int> Int) Set<Int>)
(declare-fun Set_union (Set<Int> Set<Int>) Set<Int>)
(declare-fun Set_disjoint (Set<Int> Set<Int>) Bool)
(declare-fun Set_difference (Set<Int> Set<Int>) Set<Int>)
(declare-fun Set_intersection (Set<Int> Set<Int>) Set<Int>)
(declare-fun Set_subset (Set<Int> Set<Int>) Bool)
(declare-fun Set_equal (Set<Int> Set<Int>) Bool)
(declare-fun Set_in (Bool Set<Bool>) Bool)
(declare-fun Set_card (Set<Bool>) Int)
(declare-const Set_empty Set<Bool>)
(declare-fun Set_singleton (Bool) Set<Bool>)
(declare-fun Set_unionone (Set<Bool> Bool) Set<Bool>)
(declare-fun Set_union (Set<Bool> Set<Bool>) Set<Bool>)
(declare-fun Set_disjoint (Set<Bool> Set<Bool>) Bool)
(declare-fun Set_difference (Set<Bool> Set<Bool>) Set<Bool>)
(declare-fun Set_intersection (Set<Bool> Set<Bool>) Set<Bool>)
(declare-fun Set_subset (Set<Bool> Set<Bool>) Bool)
(declare-fun Set_equal (Set<Bool> Set<Bool>) Bool)
(declare-fun Set_in (option<array> Set<option<array>>) Bool)
(declare-fun Set_card (Set<option<array>>) Int)
(declare-const Set_empty Set<option<array>>)
(declare-fun Set_singleton (option<array>) Set<option<array>>)
(declare-fun Set_unionone (Set<option<array>> option<array>) Set<option<array>>)
(declare-fun Set_union (Set<option<array>> Set<option<array>>) Set<option<array>>)
(declare-fun Set_disjoint (Set<option<array>> Set<option<array>>) Bool)
(declare-fun Set_difference (Set<option<array>> Set<option<array>>) Set<option<array>>)
(declare-fun Set_intersection (Set<option<array>> Set<option<array>>) Set<option<array>>)
(declare-fun Set_subset (Set<option<array>> Set<option<array>>) Bool)
(declare-fun Set_equal (Set<option<array>> Set<option<array>>) Bool)
(declare-fun Set_in ($Ref Set<$Ref>) Bool)
(declare-fun Set_card (Set<$Ref>) Int)
(declare-const Set_empty Set<$Ref>)
(declare-fun Set_singleton ($Ref) Set<$Ref>)
(declare-fun Set_unionone (Set<$Ref> $Ref) Set<$Ref>)
(declare-fun Set_union (Set<$Ref> Set<$Ref>) Set<$Ref>)
(declare-fun Set_disjoint (Set<$Ref> Set<$Ref>) Bool)
(declare-fun Set_difference (Set<$Ref> Set<$Ref>) Set<$Ref>)
(declare-fun Set_intersection (Set<$Ref> Set<$Ref>) Set<$Ref>)
(declare-fun Set_subset (Set<$Ref> Set<$Ref>) Bool)
(declare-fun Set_equal (Set<$Ref> Set<$Ref>) Bool)
(declare-fun Set_in ($Snap Set<$Snap>) Bool)
(declare-fun Set_card (Set<$Snap>) Int)
(declare-const Set_empty Set<$Snap>)
(declare-fun Set_singleton ($Snap) Set<$Snap>)
(declare-fun Set_unionone (Set<$Snap> $Snap) Set<$Snap>)
(declare-fun Set_union (Set<$Snap> Set<$Snap>) Set<$Snap>)
(declare-fun Set_disjoint (Set<$Snap> Set<$Snap>) Bool)
(declare-fun Set_difference (Set<$Snap> Set<$Snap>) Set<$Snap>)
(declare-fun Set_intersection (Set<$Snap> Set<$Snap>) Set<$Snap>)
(declare-fun Set_subset (Set<$Snap> Set<$Snap>) Bool)
(declare-fun Set_equal (Set<$Snap> Set<$Snap>) Bool)
(declare-fun Seq_length (Seq<Seq<Int>>) Int)
(declare-const Seq_empty Seq<Seq<Int>>)
(declare-fun Seq_singleton (Seq<Int>) Seq<Seq<Int>>)
(declare-fun Seq_build (Seq<Seq<Int>> Seq<Int>) Seq<Seq<Int>>)
(declare-fun Seq_index (Seq<Seq<Int>> Int) Seq<Int>)
(declare-fun Seq_append (Seq<Seq<Int>> Seq<Seq<Int>>) Seq<Seq<Int>>)
(declare-fun Seq_update (Seq<Seq<Int>> Int Seq<Int>) Seq<Seq<Int>>)
(declare-fun Seq_contains (Seq<Seq<Int>> Seq<Int>) Bool)
(declare-fun Seq_take (Seq<Seq<Int>> Int) Seq<Seq<Int>>)
(declare-fun Seq_drop (Seq<Seq<Int>> Int) Seq<Seq<Int>>)
(declare-fun Seq_equal (Seq<Seq<Int>> Seq<Seq<Int>>) Bool)
(declare-fun Seq_sameuntil (Seq<Seq<Int>> Seq<Seq<Int>> Int) Bool)
(declare-fun Seq_length (Seq<Int>) Int)
(declare-const Seq_empty Seq<Int>)
(declare-fun Seq_singleton (Int) Seq<Int>)
(declare-fun Seq_build (Seq<Int> Int) Seq<Int>)
(declare-fun Seq_index (Seq<Int> Int) Int)
(declare-fun Seq_append (Seq<Int> Seq<Int>) Seq<Int>)
(declare-fun Seq_update (Seq<Int> Int Int) Seq<Int>)
(declare-fun Seq_contains (Seq<Int> Int) Bool)
(declare-fun Seq_take (Seq<Int> Int) Seq<Int>)
(declare-fun Seq_drop (Seq<Int> Int) Seq<Int>)
(declare-fun Seq_equal (Seq<Int> Seq<Int>) Bool)
(declare-fun Seq_sameuntil (Seq<Int> Seq<Int> Int) Bool)
(declare-fun Seq_range (Int Int) Seq<Int>)
(declare-fun array_loc<Ref> (array Int) $Ref)
(declare-fun alen<Int> (array) Int)
(declare-fun loc_inv_1<array> ($Ref) array)
(declare-fun loc_inv_2<Int> ($Ref) Int)
(declare-const None<option<array>> option<array>)
(declare-fun some<option<array>> (array) option<array>)
(declare-fun option_get<array> (option<array>) array)
(declare-const v_null<t_null> t_null)
(declare-const None<option<any>> option<any>)
(declare-fun some<option<any>> (any) option<any>)
(declare-fun option_get<any> (option<any>) any)
(declare-const unit<void> void)
; /field_value_functions_declarations.smt2 [int: Int]
(declare-fun $FVF.domain_int ($FVF<Int>) Set<$Ref>)
(declare-fun $FVF.lookup_int ($FVF<Int> $Ref) Int)
(declare-fun $FVF.after_int ($FVF<Int> $FVF<Int>) Bool)
(declare-fun $FVF.loc_int (Int $Ref) Bool)
(declare-fun $FVF.perm_int ($FPM $Ref) $Perm)
(declare-const $fvfTOP_int $FVF<Int>)
; /field_value_functions_declarations.smt2 [option$array$: option[array]]
(declare-fun $FVF.domain_option$array$ ($FVF<option<array>>) Set<$Ref>)
(declare-fun $FVF.lookup_option$array$ ($FVF<option<array>> $Ref) option<array>)
(declare-fun $FVF.after_option$array$ ($FVF<option<array>> $FVF<option<array>>) Bool)
(declare-fun $FVF.loc_option$array$ (option<array> $Ref) Bool)
(declare-fun $FVF.perm_option$array$ ($FPM $Ref) $Perm)
(declare-const $fvfTOP_option$array$ $FVF<option<array>>)
; /field_value_functions_declarations.smt2 [bool: Bool]
(declare-fun $FVF.domain_bool ($FVF<Bool>) Set<$Ref>)
(declare-fun $FVF.lookup_bool ($FVF<Bool> $Ref) Bool)
(declare-fun $FVF.after_bool ($FVF<Bool> $FVF<Bool>) Bool)
(declare-fun $FVF.loc_bool (Bool $Ref) Bool)
(declare-fun $FVF.perm_bool ($FPM $Ref) $Perm)
(declare-const $fvfTOP_bool $FVF<Bool>)
; Declaring symbols related to program functions (from program analysis)
(declare-fun SquareIntMatrix ($Snap $Ref Seq<Seq<Int>> Int) Bool)
(declare-fun SquareIntMatrix%limited ($Snap $Ref Seq<Seq<Int>> Int) Bool)
(declare-fun SquareIntMatrix%stateless ($Ref Seq<Seq<Int>> Int) Bool)
(declare-fun NonNegativeCapacities ($Snap $Ref Seq<Seq<Int>> Int) Bool)
(declare-fun NonNegativeCapacities%limited ($Snap $Ref Seq<Seq<Int>> Int) Bool)
(declare-fun NonNegativeCapacities%stateless ($Ref Seq<Seq<Int>> Int) Bool)
(declare-fun FlowNetwork ($Snap $Ref Seq<Seq<Int>> Int Int Int) Bool)
(declare-fun FlowNetwork%limited ($Snap $Ref Seq<Seq<Int>> Int Int Int) Bool)
(declare-fun FlowNetwork%stateless ($Ref Seq<Seq<Int>> Int Int Int) Bool)
(declare-fun SumOutgoingFlow ($Snap $Ref Seq<Seq<Int>> Int Int Int) Int)
(declare-fun SumOutgoingFlow%limited ($Snap $Ref Seq<Seq<Int>> Int Int Int) Int)
(declare-fun SumOutgoingFlow%stateless ($Ref Seq<Seq<Int>> Int Int Int) Bool)
(declare-fun SumIncomingFlow ($Snap $Ref Seq<Seq<Int>> Int Int Int) Int)
(declare-fun SumIncomingFlow%limited ($Snap $Ref Seq<Seq<Int>> Int Int Int) Int)
(declare-fun SumIncomingFlow%stateless ($Ref Seq<Seq<Int>> Int Int Int) Bool)
(declare-fun CapacityConstraint ($Snap $Ref Seq<Seq<Int>> Seq<Seq<Int>> Int) Bool)
(declare-fun CapacityConstraint%limited ($Snap $Ref Seq<Seq<Int>> Seq<Seq<Int>> Int) Bool)
(declare-fun CapacityConstraint%stateless ($Ref Seq<Seq<Int>> Seq<Seq<Int>> Int) Bool)
(declare-fun FlowConservation ($Snap $Ref Seq<Seq<Int>> Int Int Int) Bool)
(declare-fun FlowConservation%limited ($Snap $Ref Seq<Seq<Int>> Int Int Int) Bool)
(declare-fun FlowConservation%stateless ($Ref Seq<Seq<Int>> Int Int Int) Bool)
(declare-fun aloc ($Snap array Int) $Ref)
(declare-fun aloc%limited ($Snap array Int) $Ref)
(declare-fun aloc%stateless (array Int) Bool)
(declare-fun opt_get1 ($Snap option<array>) array)
(declare-fun opt_get1%limited ($Snap option<array>) array)
(declare-fun opt_get1%stateless (option<array>) Bool)
(declare-fun valid_graph_vertices1 ($Snap $Ref Seq<Int> Int) Bool)
(declare-fun valid_graph_vertices1%limited ($Snap $Ref Seq<Int> Int) Bool)
(declare-fun valid_graph_vertices1%stateless ($Ref Seq<Int> Int) Bool)
(declare-fun ValidFlow ($Snap $Ref Seq<Seq<Int>> Seq<Seq<Int>> Int Int Int) Bool)
(declare-fun ValidFlow%limited ($Snap $Ref Seq<Seq<Int>> Seq<Seq<Int>> Int Int Int) Bool)
(declare-fun ValidFlow%stateless ($Ref Seq<Seq<Int>> Seq<Seq<Int>> Int Int Int) Bool)
(declare-fun SquareIntMatrix1 ($Snap $Ref option<array> Int) Bool)
(declare-fun SquareIntMatrix1%limited ($Snap $Ref option<array> Int) Bool)
(declare-fun SquareIntMatrix1%stateless ($Ref option<array> Int) Bool)
(declare-fun any_as ($Snap any) any)
(declare-fun any_as%limited ($Snap any) any)
(declare-fun any_as%stateless (any) Bool)
(declare-fun unknown_ ($Snap option<array> Int Int) Seq<Int>)
(declare-fun unknown%limited ($Snap option<array> Int Int) Seq<Int>)
(declare-fun unknown%stateless (option<array> Int Int) Bool)
(declare-fun AugPath ($Snap $Ref Seq<Seq<Int>> Seq<Seq<Int>> Int Int Int Seq<Int>) Bool)
(declare-fun AugPath%limited ($Snap $Ref Seq<Seq<Int>> Seq<Seq<Int>> Int Int Int Seq<Int>) Bool)
(declare-fun AugPath%stateless ($Ref Seq<Seq<Int>> Seq<Seq<Int>> Int Int Int Seq<Int>) Bool)
(declare-fun opt_get ($Snap option<any>) any)
(declare-fun opt_get%limited ($Snap option<any>) any)
(declare-fun opt_get%stateless (option<any>) Bool)
(declare-fun NonNegativeCapacities1 ($Snap $Ref option<array> Int) Bool)
(declare-fun NonNegativeCapacities1%limited ($Snap $Ref option<array> Int) Bool)
(declare-fun NonNegativeCapacities1%stateless ($Ref option<array> Int) Bool)
(declare-fun as_any ($Snap any) any)
(declare-fun as_any%limited ($Snap any) any)
(declare-fun as_any%stateless (any) Bool)
(declare-fun valid_graph_vertices ($Snap $Ref option<array> Int) Bool)
(declare-fun valid_graph_vertices%limited ($Snap $Ref option<array> Int) Bool)
(declare-fun valid_graph_vertices%stateless ($Ref option<array> Int) Bool)
(declare-fun type ($Snap $Ref) Int)
(declare-fun type%limited ($Snap $Ref) Int)
(declare-fun type%stateless ($Ref) Bool)
(declare-fun subtype ($Snap Int Int) Bool)
(declare-fun subtype%limited ($Snap Int Int) Bool)
(declare-fun subtype%stateless (Int Int) Bool)
(declare-fun matrixValues ($Snap $Ref option<array> Int) Seq<Seq<Int>>)
(declare-fun matrixValues%limited ($Snap $Ref option<array> Int) Seq<Seq<Int>>)
(declare-fun matrixValues%stateless ($Ref option<array> Int) Bool)
(declare-fun ExAugPath ($Snap $Ref Seq<Seq<Int>> Seq<Seq<Int>> Int Int Int) Bool)
(declare-fun ExAugPath%limited ($Snap $Ref Seq<Seq<Int>> Seq<Seq<Int>> Int Int Int) Bool)
(declare-fun ExAugPath%stateless ($Ref Seq<Seq<Int>> Seq<Seq<Int>> Int Int Int) Bool)
(declare-fun opt_or_else ($Snap option<any> any) any)
(declare-fun opt_or_else%limited ($Snap option<any> any) any)
(declare-fun opt_or_else%stateless (option<any> any) Bool)
(declare-fun FlowNetwork1 ($Snap $Ref option<array> Int Int Int) Bool)
(declare-fun FlowNetwork1%limited ($Snap $Ref option<array> Int Int Int) Bool)
(declare-fun FlowNetwork1%stateless ($Ref option<array> Int Int Int) Bool)
; Snapshot variable to be used during function verification
(declare-fun s@$ () $Snap)
; Declaring predicate trigger functions
(declare-fun lock_inv_FordFulkerson%trigger ($Snap $Ref) Bool)
(declare-fun lock_held_FordFulkerson%trigger ($Snap $Ref) Bool)
(declare-fun lock_inv_Object%trigger ($Snap $Ref) Bool)
(declare-fun lock_held_Object%trigger ($Snap $Ref) Bool)
; ////////// Uniqueness assumptions from domains
; ////////// Axioms
(assert (forall ((s Seq<Seq<Int>>)) (!
  (<= 0 (Seq_length s))
  :pattern ((Seq_length s))
  :qid |$Seq[Seq[Int]]_prog.seq_length_non_negative|)))
(assert (= (Seq_length (as Seq_empty  Seq<Seq<Int>>)) 0))
(assert (forall ((s Seq<Seq<Int>>)) (!
  (implies (= (Seq_length s) 0) (= s (as Seq_empty  Seq<Seq<Int>>)))
  :pattern ((Seq_length s))
  :qid |$Seq[Seq[Int]]_prog.only_empty_seq_length_zero|)))
(assert (forall ((e Seq<Int>)) (!
  (= (Seq_length (Seq_singleton e)) 1)
  :pattern ((Seq_length (Seq_singleton e)))
  :qid |$Seq[Seq[Int]]_prog.length_singleton_seq|)))
(assert (forall ((s Seq<Seq<Int>>) (e Seq<Int>)) (!
  (= (Seq_length (Seq_build s e)) (+ 1 (Seq_length s)))
  :pattern ((Seq_length (Seq_build s e)))
  :qid |$Seq[Seq[Int]]_prog.length_seq_build_inc_by_one|)))
(assert (forall ((s Seq<Seq<Int>>) (i Int) (e Seq<Int>)) (!
  (ite
    (= i (Seq_length s))
    (= (Seq_index (Seq_build s e) i) e)
    (= (Seq_index (Seq_build s e) i) (Seq_index s i)))
  :pattern ((Seq_index (Seq_build s e) i))
  :qid |$Seq[Seq[Int]]_prog.seq_index_over_build|)))
(assert (forall ((s1 Seq<Seq<Int>>) (s2 Seq<Seq<Int>>)) (!
  (implies
    (and
      (not (= s1 (as Seq_empty  Seq<Seq<Int>>)))
      (not (= s2 (as Seq_empty  Seq<Seq<Int>>))))
    (= (Seq_length (Seq_append s1 s2)) (+ (Seq_length s1) (Seq_length s2))))
  :pattern ((Seq_length (Seq_append s1 s2)))
  :qid |$Seq[Seq[Int]]_prog.seq_length_over_append|)))
(assert (forall ((e Seq<Int>)) (!
  (= (Seq_index (Seq_singleton e) 0) e)
  :pattern ((Seq_index (Seq_singleton e) 0))
  :qid |$Seq[Seq[Int]]_prog.seq_index_over_singleton|)))
(assert (forall ((e1 Seq<Int>) (e2 Seq<Int>)) (!
  (= (Seq_contains (Seq_singleton e1) e2) (= e1 e2))
  :pattern ((Seq_contains (Seq_singleton e1) e2))
  :qid |$Seq[Seq[Int]]_prog.seq_contains_over_singleton|)))
(assert (forall ((s Seq<Seq<Int>>)) (!
  (= (Seq_append (as Seq_empty  Seq<Seq<Int>>) s) s)
  :pattern ((Seq_append (as Seq_empty  Seq<Seq<Int>>) s))
  :qid |$Seq[Seq[Int]]_prog.seq_append_empty_left|)))
(assert (forall ((s Seq<Seq<Int>>)) (!
  (= (Seq_append s (as Seq_empty  Seq<Seq<Int>>)) s)
  :pattern ((Seq_append s (as Seq_empty  Seq<Seq<Int>>)))
  :qid |$Seq[Seq[Int]]_prog.seq_append_empty_right|)))
(assert (forall ((s1 Seq<Seq<Int>>) (s2 Seq<Seq<Int>>) (i Int)) (!
  (implies
    (and
      (not (= s1 (as Seq_empty  Seq<Seq<Int>>)))
      (not (= s2 (as Seq_empty  Seq<Seq<Int>>))))
    (ite
      (< i (Seq_length s1))
      (= (Seq_index (Seq_append s1 s2) i) (Seq_index s1 i))
      (= (Seq_index (Seq_append s1 s2) i) (Seq_index s2 (- i (Seq_length s1))))))
  :pattern ((Seq_index (Seq_append s1 s2) i))
  :pattern ((Seq_index s1 i) (Seq_append s1 s2))
  :qid |$Seq[Seq[Int]]_prog.seq_index_over_append|)))
(assert (forall ((s Seq<Seq<Int>>) (i Int) (e Seq<Int>)) (!
  (implies
    (and (<= 0 i) (< i (Seq_length s)))
    (= (Seq_length (Seq_update s i e)) (Seq_length s)))
  :pattern ((Seq_length (Seq_update s i e)))
  :qid |$Seq[Seq[Int]]_prog.seq_length_invariant_over_update|)))
(assert (forall ((s Seq<Seq<Int>>) (i Int) (e Seq<Int>) (j Int)) (!
  (ite
    (implies (and (<= 0 i) (< i (Seq_length s))) (= i j))
    (= (Seq_index (Seq_update s i e) j) e)
    (= (Seq_index (Seq_update s i e) j) (Seq_index s j)))
  :pattern ((Seq_index (Seq_update s i e) j))
  :qid |$Seq[Seq[Int]]_prog.seq_index_over_update|)))
(assert (forall ((s Seq<Seq<Int>>) (e Seq<Int>)) (!
  (=
    (Seq_contains s e)
    (exists ((i Int)) (!
      (and (<= 0 i) (and (< i (Seq_length s)) (= (Seq_index s i) e)))
      :pattern ((Seq_index s i))
      )))
  :pattern ((Seq_contains s e))
  :qid |$Seq[Seq[Int]]_prog.seq_element_contains_index_exists|)))
(assert (forall ((e Seq<Int>)) (!
  (not (Seq_contains (as Seq_empty  Seq<Seq<Int>>) e))
  :pattern ((Seq_contains (as Seq_empty  Seq<Seq<Int>>) e))
  :qid |$Seq[Seq[Int]]_prog.empty_seq_contains_nothing|)))
(assert (forall ((s1 Seq<Seq<Int>>) (s2 Seq<Seq<Int>>) (e Seq<Int>)) (!
  (=
    (Seq_contains (Seq_append s1 s2) e)
    (or (Seq_contains s1 e) (Seq_contains s2 e)))
  :pattern ((Seq_contains (Seq_append s1 s2) e))
  :qid |$Seq[Seq[Int]]_prog.seq_contains_over_append|)))
(assert (forall ((s Seq<Seq<Int>>) (e1 Seq<Int>) (e2 Seq<Int>)) (!
  (= (Seq_contains (Seq_build s e1) e2) (or (= e1 e2) (Seq_contains s e2)))
  :pattern ((Seq_contains (Seq_build s e1) e2))
  :qid |$Seq[Seq[Int]]_prog.seq_contains_over_build|)))
(assert (forall ((s Seq<Seq<Int>>) (n Int)) (!
  (implies (<= n 0) (= (Seq_take s n) (as Seq_empty  Seq<Seq<Int>>)))
  :pattern ((Seq_take s n))
  :qid |$Seq[Seq[Int]]_prog.seq_take_negative_length|)))
(assert (forall ((s Seq<Seq<Int>>) (n Int) (e Seq<Int>)) (!
  (=
    (Seq_contains (Seq_take s n) e)
    (exists ((i Int)) (!
      (and
        (<= 0 i)
        (and (< i n) (and (< i (Seq_length s)) (= (Seq_index s i) e))))
      :pattern ((Seq_index s i))
      )))
  :pattern ((Seq_contains (Seq_take s n) e))
  :qid |$Seq[Seq[Int]]_prog.seq_contains_over_take_index_exists|)))
(assert (forall ((s Seq<Seq<Int>>) (n Int)) (!
  (implies (<= n 0) (= (Seq_drop s n) s))
  :pattern ((Seq_drop s n))
  :qid |$Seq[Seq[Int]]_prog.seq_drop_negative_length|)))
(assert (forall ((s Seq<Seq<Int>>) (n Int) (e Seq<Int>)) (!
  (=
    (Seq_contains (Seq_drop s n) e)
    (exists ((i Int)) (!
      (and
        (<= 0 i)
        (and (<= n i) (and (< i (Seq_length s)) (= (Seq_index s i) e))))
      :pattern ((Seq_index s i))
      )))
  :pattern ((Seq_contains (Seq_drop s n) e))
  :qid |$Seq[Seq[Int]]_prog.seq_contains_over_drop_index_exists|)))
(assert (forall ((s1 Seq<Seq<Int>>) (s2 Seq<Seq<Int>>)) (!
  (=
    (Seq_equal s1 s2)
    (and
      (= (Seq_length s1) (Seq_length s2))
      (forall ((i Int)) (!
        (implies
          (and (<= 0 i) (< i (Seq_length s1)))
          (= (Seq_index s1 i) (Seq_index s2 i)))
        :pattern ((Seq_index s1 i))
        :pattern ((Seq_index s2 i))
        ))))
  :pattern ((Seq_equal s1 s2))
  :qid |$Seq[Seq[Int]]_prog.extensional_seq_equality|)))
(assert (forall ((s1 Seq<Seq<Int>>) (s2 Seq<Seq<Int>>)) (!
  (implies (Seq_equal s1 s2) (= s1 s2))
  :pattern ((Seq_equal s1 s2))
  :qid |$Seq[Seq[Int]]_prog.seq_equality_identity|)))
(assert (forall ((s1 Seq<Seq<Int>>) (s2 Seq<Seq<Int>>) (n Int)) (!
  (=
    (Seq_sameuntil s1 s2 n)
    (forall ((i Int)) (!
      (implies (and (<= 0 i) (< i n)) (= (Seq_index s1 i) (Seq_index s2 i)))
      :pattern ((Seq_index s1 i))
      :pattern ((Seq_index s2 i))
      )))
  :pattern ((Seq_sameuntil s1 s2 n))
  :qid |$Seq[Seq[Int]]_prog.extensional_seq_equality_prefix|)))
(assert (forall ((s Seq<Seq<Int>>) (n Int)) (!
  (implies
    (<= 0 n)
    (ite
      (<= n (Seq_length s))
      (= (Seq_length (Seq_take s n)) n)
      (= (Seq_length (Seq_take s n)) (Seq_length s))))
  :pattern ((Seq_length (Seq_take s n)))
  :qid |$Seq[Seq[Int]]_prog.seq_length_over_take|)))
(assert (forall ((s Seq<Seq<Int>>) (n Int) (i Int)) (!
  (implies
    (and (<= 0 i) (and (< i n) (< i (Seq_length s))))
    (= (Seq_index (Seq_take s n) i) (Seq_index s i)))
  :pattern ((Seq_index (Seq_take s n) i))
  :pattern ((Seq_index s i) (Seq_take s n))
  :qid |$Seq[Seq[Int]]_prog.seq_index_over_take|)))
(assert (forall ((s Seq<Seq<Int>>) (n Int)) (!
  (implies
    (<= 0 n)
    (ite
      (<= n (Seq_length s))
      (= (Seq_length (Seq_drop s n)) (- (Seq_length s) n))
      (= (Seq_length (Seq_drop s n)) 0)))
  :pattern ((Seq_length (Seq_drop s n)))
  :qid |$Seq[Seq[Int]]_prog.seq_length_over_drop|)))
(assert (forall ((s Seq<Seq<Int>>) (n Int) (i Int)) (!
  (implies
    (and (<= 0 n) (and (<= 0 i) (< i (- (Seq_length s) n))))
    (= (Seq_index (Seq_drop s n) i) (Seq_index s (+ i n))))
  :pattern ((Seq_index (Seq_drop s n) i))
  :qid |$Seq[Seq[Int]]_prog.seq_index_over_drop_1|)))
(assert (forall ((s Seq<Seq<Int>>) (n Int) (i Int)) (!
  (implies
    (and (<= 0 n) (and (<= n i) (< i (Seq_length s))))
    (= (Seq_index (Seq_drop s n) (- i n)) (Seq_index s i)))
  :pattern ((Seq_index s i) (Seq_drop s n))
  :qid |$Seq[Seq[Int]]_prog.seq_index_over_drop_2|)))
(assert (forall ((s Seq<Seq<Int>>) (i Int) (e Seq<Int>) (n Int)) (!
  (implies
    (and (<= 0 i) (and (< i n) (< n (Seq_length s))))
    (= (Seq_take (Seq_update s i e) n) (Seq_update (Seq_take s n) i e)))
  :pattern ((Seq_take (Seq_update s i e) n))
  :qid |$Seq[Seq[Int]]_prog.seq_take_over_update_1|)))
(assert (forall ((s Seq<Seq<Int>>) (i Int) (e Seq<Int>) (n Int)) (!
  (implies
    (and (<= n i) (< i (Seq_length s)))
    (= (Seq_take (Seq_update s i e) n) (Seq_take s n)))
  :pattern ((Seq_take (Seq_update s i e) n))
  :qid |$Seq[Seq[Int]]_prog.seq_take_over_update_2|)))
(assert (forall ((s Seq<Seq<Int>>) (i Int) (e Seq<Int>) (n Int)) (!
  (implies
    (and (<= 0 n) (and (<= n i) (< i (Seq_length s))))
    (= (Seq_drop (Seq_update s i e) n) (Seq_update (Seq_drop s n) (- i n) e)))
  :pattern ((Seq_drop (Seq_update s i e) n))
  :qid |$Seq[Seq[Int]]_prog.seq_drop_over_update_1|)))
(assert (forall ((s Seq<Seq<Int>>) (i Int) (e Seq<Int>) (n Int)) (!
  (implies
    (and (<= 0 i) (and (< i n) (< n (Seq_length s))))
    (= (Seq_drop (Seq_update s i e) n) (Seq_drop s n)))
  :pattern ((Seq_drop (Seq_update s i e) n))
  :qid |$Seq[Seq[Int]]_prog.seq_drop_over_update_2|)))
(assert (forall ((s Seq<Seq<Int>>) (e Seq<Int>) (n Int)) (!
  (implies
    (and (<= 0 n) (<= n (Seq_length s)))
    (= (Seq_drop (Seq_build s e) n) (Seq_build (Seq_drop s n) e)))
  :pattern ((Seq_drop (Seq_build s e) n))
  :qid |$Seq[Seq[Int]]_prog.seq_drop_over_build|)))
(assert (forall ((s Seq<Int>)) (!
  (<= 0 (Seq_length s))
  :pattern ((Seq_length s))
  :qid |$Seq[Int]_prog.seq_length_non_negative|)))
(assert (= (Seq_length (as Seq_empty  Seq<Int>)) 0))
(assert (forall ((s Seq<Int>)) (!
  (implies (= (Seq_length s) 0) (= s (as Seq_empty  Seq<Int>)))
  :pattern ((Seq_length s))
  :qid |$Seq[Int]_prog.only_empty_seq_length_zero|)))
(assert (forall ((e Int)) (!
  (= (Seq_length (Seq_singleton e)) 1)
  :pattern ((Seq_length (Seq_singleton e)))
  :qid |$Seq[Int]_prog.length_singleton_seq|)))
(assert (forall ((s Seq<Int>) (e Int)) (!
  (= (Seq_length (Seq_build s e)) (+ 1 (Seq_length s)))
  :pattern ((Seq_length (Seq_build s e)))
  :qid |$Seq[Int]_prog.length_seq_build_inc_by_one|)))
(assert (forall ((s Seq<Int>) (i Int) (e Int)) (!
  (ite
    (= i (Seq_length s))
    (= (Seq_index (Seq_build s e) i) e)
    (= (Seq_index (Seq_build s e) i) (Seq_index s i)))
  :pattern ((Seq_index (Seq_build s e) i))
  :qid |$Seq[Int]_prog.seq_index_over_build|)))
(assert (forall ((s1 Seq<Int>) (s2 Seq<Int>)) (!
  (implies
    (and
      (not (= s1 (as Seq_empty  Seq<Int>)))
      (not (= s2 (as Seq_empty  Seq<Int>))))
    (= (Seq_length (Seq_append s1 s2)) (+ (Seq_length s1) (Seq_length s2))))
  :pattern ((Seq_length (Seq_append s1 s2)))
  :qid |$Seq[Int]_prog.seq_length_over_append|)))
(assert (forall ((e Int)) (!
  (= (Seq_index (Seq_singleton e) 0) e)
  :pattern ((Seq_index (Seq_singleton e) 0))
  :qid |$Seq[Int]_prog.seq_index_over_singleton|)))
(assert (forall ((e1 Int) (e2 Int)) (!
  (= (Seq_contains (Seq_singleton e1) e2) (= e1 e2))
  :pattern ((Seq_contains (Seq_singleton e1) e2))
  :qid |$Seq[Int]_prog.seq_contains_over_singleton|)))
(assert (forall ((s Seq<Int>)) (!
  (= (Seq_append (as Seq_empty  Seq<Int>) s) s)
  :pattern ((Seq_append (as Seq_empty  Seq<Int>) s))
  :qid |$Seq[Int]_prog.seq_append_empty_left|)))
(assert (forall ((s Seq<Int>)) (!
  (= (Seq_append s (as Seq_empty  Seq<Int>)) s)
  :pattern ((Seq_append s (as Seq_empty  Seq<Int>)))
  :qid |$Seq[Int]_prog.seq_append_empty_right|)))
(assert (forall ((s1 Seq<Int>) (s2 Seq<Int>) (i Int)) (!
  (implies
    (and
      (not (= s1 (as Seq_empty  Seq<Int>)))
      (not (= s2 (as Seq_empty  Seq<Int>))))
    (ite
      (< i (Seq_length s1))
      (= (Seq_index (Seq_append s1 s2) i) (Seq_index s1 i))
      (= (Seq_index (Seq_append s1 s2) i) (Seq_index s2 (- i (Seq_length s1))))))
  :pattern ((Seq_index (Seq_append s1 s2) i))
  :pattern ((Seq_index s1 i) (Seq_append s1 s2))
  :qid |$Seq[Int]_prog.seq_index_over_append|)))
(assert (forall ((s Seq<Int>) (i Int) (e Int)) (!
  (implies
    (and (<= 0 i) (< i (Seq_length s)))
    (= (Seq_length (Seq_update s i e)) (Seq_length s)))
  :pattern ((Seq_length (Seq_update s i e)))
  :qid |$Seq[Int]_prog.seq_length_invariant_over_update|)))
(assert (forall ((s Seq<Int>) (i Int) (e Int) (j Int)) (!
  (ite
    (implies (and (<= 0 i) (< i (Seq_length s))) (= i j))
    (= (Seq_index (Seq_update s i e) j) e)
    (= (Seq_index (Seq_update s i e) j) (Seq_index s j)))
  :pattern ((Seq_index (Seq_update s i e) j))
  :qid |$Seq[Int]_prog.seq_index_over_update|)))
(assert (forall ((s Seq<Int>) (e Int)) (!
  (=
    (Seq_contains s e)
    (exists ((i Int)) (!
      (and (<= 0 i) (and (< i (Seq_length s)) (= (Seq_index s i) e)))
      :pattern ((Seq_index s i))
      )))
  :pattern ((Seq_contains s e))
  :qid |$Seq[Int]_prog.seq_element_contains_index_exists|)))
(assert (forall ((e Int)) (!
  (not (Seq_contains (as Seq_empty  Seq<Int>) e))
  :pattern ((Seq_contains (as Seq_empty  Seq<Int>) e))
  :qid |$Seq[Int]_prog.empty_seq_contains_nothing|)))
(assert (forall ((s1 Seq<Int>) (s2 Seq<Int>) (e Int)) (!
  (=
    (Seq_contains (Seq_append s1 s2) e)
    (or (Seq_contains s1 e) (Seq_contains s2 e)))
  :pattern ((Seq_contains (Seq_append s1 s2) e))
  :qid |$Seq[Int]_prog.seq_contains_over_append|)))
(assert (forall ((s Seq<Int>) (e1 Int) (e2 Int)) (!
  (= (Seq_contains (Seq_build s e1) e2) (or (= e1 e2) (Seq_contains s e2)))
  :pattern ((Seq_contains (Seq_build s e1) e2))
  :qid |$Seq[Int]_prog.seq_contains_over_build|)))
(assert (forall ((s Seq<Int>) (n Int)) (!
  (implies (<= n 0) (= (Seq_take s n) (as Seq_empty  Seq<Int>)))
  :pattern ((Seq_take s n))
  :qid |$Seq[Int]_prog.seq_take_negative_length|)))
(assert (forall ((s Seq<Int>) (n Int) (e Int)) (!
  (=
    (Seq_contains (Seq_take s n) e)
    (exists ((i Int)) (!
      (and
        (<= 0 i)
        (and (< i n) (and (< i (Seq_length s)) (= (Seq_index s i) e))))
      :pattern ((Seq_index s i))
      )))
  :pattern ((Seq_contains (Seq_take s n) e))
  :qid |$Seq[Int]_prog.seq_contains_over_take_index_exists|)))
(assert (forall ((s Seq<Int>) (n Int)) (!
  (implies (<= n 0) (= (Seq_drop s n) s))
  :pattern ((Seq_drop s n))
  :qid |$Seq[Int]_prog.seq_drop_negative_length|)))
(assert (forall ((s Seq<Int>) (n Int) (e Int)) (!
  (=
    (Seq_contains (Seq_drop s n) e)
    (exists ((i Int)) (!
      (and
        (<= 0 i)
        (and (<= n i) (and (< i (Seq_length s)) (= (Seq_index s i) e))))
      :pattern ((Seq_index s i))
      )))
  :pattern ((Seq_contains (Seq_drop s n) e))
  :qid |$Seq[Int]_prog.seq_contains_over_drop_index_exists|)))
(assert (forall ((s1 Seq<Int>) (s2 Seq<Int>)) (!
  (=
    (Seq_equal s1 s2)
    (and
      (= (Seq_length s1) (Seq_length s2))
      (forall ((i Int)) (!
        (implies
          (and (<= 0 i) (< i (Seq_length s1)))
          (= (Seq_index s1 i) (Seq_index s2 i)))
        :pattern ((Seq_index s1 i))
        :pattern ((Seq_index s2 i))
        ))))
  :pattern ((Seq_equal s1 s2))
  :qid |$Seq[Int]_prog.extensional_seq_equality|)))
(assert (forall ((s1 Seq<Int>) (s2 Seq<Int>)) (!
  (implies (Seq_equal s1 s2) (= s1 s2))
  :pattern ((Seq_equal s1 s2))
  :qid |$Seq[Int]_prog.seq_equality_identity|)))
(assert (forall ((s1 Seq<Int>) (s2 Seq<Int>) (n Int)) (!
  (=
    (Seq_sameuntil s1 s2 n)
    (forall ((i Int)) (!
      (implies (and (<= 0 i) (< i n)) (= (Seq_index s1 i) (Seq_index s2 i)))
      :pattern ((Seq_index s1 i))
      :pattern ((Seq_index s2 i))
      )))
  :pattern ((Seq_sameuntil s1 s2 n))
  :qid |$Seq[Int]_prog.extensional_seq_equality_prefix|)))
(assert (forall ((s Seq<Int>) (n Int)) (!
  (implies
    (<= 0 n)
    (ite
      (<= n (Seq_length s))
      (= (Seq_length (Seq_take s n)) n)
      (= (Seq_length (Seq_take s n)) (Seq_length s))))
  :pattern ((Seq_length (Seq_take s n)))
  :qid |$Seq[Int]_prog.seq_length_over_take|)))
(assert (forall ((s Seq<Int>) (n Int) (i Int)) (!
  (implies
    (and (<= 0 i) (and (< i n) (< i (Seq_length s))))
    (= (Seq_index (Seq_take s n) i) (Seq_index s i)))
  :pattern ((Seq_index (Seq_take s n) i))
  :pattern ((Seq_index s i) (Seq_take s n))
  :qid |$Seq[Int]_prog.seq_index_over_take|)))
(assert (forall ((s Seq<Int>) (n Int)) (!
  (implies
    (<= 0 n)
    (ite
      (<= n (Seq_length s))
      (= (Seq_length (Seq_drop s n)) (- (Seq_length s) n))
      (= (Seq_length (Seq_drop s n)) 0)))
  :pattern ((Seq_length (Seq_drop s n)))
  :qid |$Seq[Int]_prog.seq_length_over_drop|)))
(assert (forall ((s Seq<Int>) (n Int) (i Int)) (!
  (implies
    (and (<= 0 n) (and (<= 0 i) (< i (- (Seq_length s) n))))
    (= (Seq_index (Seq_drop s n) i) (Seq_index s (+ i n))))
  :pattern ((Seq_index (Seq_drop s n) i))
  :qid |$Seq[Int]_prog.seq_index_over_drop_1|)))
(assert (forall ((s Seq<Int>) (n Int) (i Int)) (!
  (implies
    (and (<= 0 n) (and (<= n i) (< i (Seq_length s))))
    (= (Seq_index (Seq_drop s n) (- i n)) (Seq_index s i)))
  :pattern ((Seq_index s i) (Seq_drop s n))
  :qid |$Seq[Int]_prog.seq_index_over_drop_2|)))
(assert (forall ((s Seq<Int>) (i Int) (e Int) (n Int)) (!
  (implies
    (and (<= 0 i) (and (< i n) (< n (Seq_length s))))
    (= (Seq_take (Seq_update s i e) n) (Seq_update (Seq_take s n) i e)))
  :pattern ((Seq_take (Seq_update s i e) n))
  :qid |$Seq[Int]_prog.seq_take_over_update_1|)))
(assert (forall ((s Seq<Int>) (i Int) (e Int) (n Int)) (!
  (implies
    (and (<= n i) (< i (Seq_length s)))
    (= (Seq_take (Seq_update s i e) n) (Seq_take s n)))
  :pattern ((Seq_take (Seq_update s i e) n))
  :qid |$Seq[Int]_prog.seq_take_over_update_2|)))
(assert (forall ((s Seq<Int>) (i Int) (e Int) (n Int)) (!
  (implies
    (and (<= 0 n) (and (<= n i) (< i (Seq_length s))))
    (= (Seq_drop (Seq_update s i e) n) (Seq_update (Seq_drop s n) (- i n) e)))
  :pattern ((Seq_drop (Seq_update s i e) n))
  :qid |$Seq[Int]_prog.seq_drop_over_update_1|)))
(assert (forall ((s Seq<Int>) (i Int) (e Int) (n Int)) (!
  (implies
    (and (<= 0 i) (and (< i n) (< n (Seq_length s))))
    (= (Seq_drop (Seq_update s i e) n) (Seq_drop s n)))
  :pattern ((Seq_drop (Seq_update s i e) n))
  :qid |$Seq[Int]_prog.seq_drop_over_update_2|)))
(assert (forall ((s Seq<Int>) (e Int) (n Int)) (!
  (implies
    (and (<= 0 n) (<= n (Seq_length s)))
    (= (Seq_drop (Seq_build s e) n) (Seq_build (Seq_drop s n) e)))
  :pattern ((Seq_drop (Seq_build s e) n))
  :qid |$Seq[Int]_prog.seq_drop_over_build|)))
(assert (forall ((min_ Int) (max Int)) (!
  (ite
    (< min_ max)
    (= (Seq_length (Seq_range min_ max)) (- max min_))
    (= (Seq_length (Seq_range min_ max)) 0))
  :pattern ((Seq_length (Seq_range min_ max)))
  :qid |$Seq[Int]_prog.ranged_seq_length|)))
(assert (forall ((min_ Int) (max Int) (i Int)) (!
  (implies
    (and (<= 0 i) (< i (- max min_)))
    (= (Seq_index (Seq_range min_ max) i) (+ min_ i)))
  :pattern ((Seq_index (Seq_range min_ max) i))
  :qid |$Seq[Int]_prog.ranged_seq_index|)))
(assert (forall ((min_ Int) (max Int) (e Int)) (!
  (= (Seq_contains (Seq_range min_ max) e) (and (<= min_ e) (< e max)))
  :pattern ((Seq_contains (Seq_range min_ max) e))
  :qid |$Seq[Int]_prog.ranged_seq_contains|)))
(assert (forall ((s Set<Int>)) (!
  (<= 0 (Set_card s))
  :pattern ((Set_card s))
  :qid |$Set[Int]_prog.card_non_negative|)))
(assert (forall ((e Int)) (!
  (not (Set_in e (as Set_empty  Set<Int>)))
  :pattern ((Set_in e (as Set_empty  Set<Int>)))
  :qid |$Set[Int]_prog.in_empty_set|)))
(assert (forall ((s Set<Int>)) (!
  (and
    (= (= (Set_card s) 0) (= s (as Set_empty  Set<Int>)))
    (implies
      (not (= (Set_card s) 0))
      (exists ((e Int)) (!
        (Set_in e s)
        :pattern ((Set_in e s))
        ))))
  :pattern ((Set_card s))
  :qid |$Set[Int]_prog.empty_set_cardinality|)))
(assert (forall ((e Int)) (!
  (Set_in e (Set_singleton e))
  :pattern ((Set_singleton e))
  :qid |$Set[Int]_prog.in_singleton_set|)))
(assert (forall ((e1 Int) (e2 Int)) (!
  (= (Set_in e1 (Set_singleton e2)) (= e1 e2))
  :pattern ((Set_in e1 (Set_singleton e2)))
  :qid |$Set[Int]_prog.in_singleton_set_equality|)))
(assert (forall ((e Int)) (!
  (= (Set_card (Set_singleton e)) 1)
  :pattern ((Set_card (Set_singleton e)))
  :qid |$Set[Int]_prog.singleton_set_cardinality|)))
(assert (forall ((s Set<Int>) (e Int)) (!
  (Set_in e (Set_unionone s e))
  :pattern ((Set_unionone s e))
  :qid |$Set[Int]_prog.in_unionone_same|)))
(assert (forall ((s Set<Int>) (e1 Int) (e2 Int)) (!
  (= (Set_in e1 (Set_unionone s e2)) (or (= e1 e2) (Set_in e1 s)))
  :pattern ((Set_in e1 (Set_unionone s e2)))
  :qid |$Set[Int]_prog.in_unionone_other|)))
(assert (forall ((s Set<Int>) (e1 Int) (e2 Int)) (!
  (implies (Set_in e1 s) (Set_in e1 (Set_unionone s e2)))
  :pattern ((Set_in e1 s) (Set_unionone s e2))
  :qid |$Set[Int]_prog.invariance_in_unionone|)))
(assert (forall ((s Set<Int>) (e Int)) (!
  (implies (Set_in e s) (= (Set_card (Set_unionone s e)) (Set_card s)))
  :pattern ((Set_card (Set_unionone s e)))
  :qid |$Set[Int]_prog.unionone_cardinality_invariant|)))
(assert (forall ((s Set<Int>) (e Int)) (!
  (implies
    (not (Set_in e s))
    (= (Set_card (Set_unionone s e)) (+ (Set_card s) 1)))
  :pattern ((Set_card (Set_unionone s e)))
  :qid |$Set[Int]_prog.unionone_cardinality_changed|)))
(assert (forall ((s1 Set<Int>) (s2 Set<Int>) (e Int)) (!
  (= (Set_in e (Set_union s1 s2)) (or (Set_in e s1) (Set_in e s2)))
  :pattern ((Set_in e (Set_union s1 s2)))
  :qid |$Set[Int]_prog.in_union_in_one|)))
(assert (forall ((s1 Set<Int>) (s2 Set<Int>) (e Int)) (!
  (implies (Set_in e s1) (Set_in e (Set_union s1 s2)))
  :pattern ((Set_in e s1) (Set_union s1 s2))
  :qid |$Set[Int]_prog.in_left_in_union|)))
(assert (forall ((s1 Set<Int>) (s2 Set<Int>) (e Int)) (!
  (implies (Set_in e s2) (Set_in e (Set_union s1 s2)))
  :pattern ((Set_in e s2) (Set_union s1 s2))
  :qid |$Set[Int]_prog.in_right_in_union|)))
(assert (forall ((s1 Set<Int>) (s2 Set<Int>) (e Int)) (!
  (= (Set_in e (Set_intersection s1 s2)) (and (Set_in e s1) (Set_in e s2)))
  :pattern ((Set_in e (Set_intersection s1 s2)))
  :pattern ((Set_intersection s1 s2) (Set_in e s1))
  :pattern ((Set_intersection s1 s2) (Set_in e s2))
  :qid |$Set[Int]_prog.in_intersection_in_both|)))
(assert (forall ((s1 Set<Int>) (s2 Set<Int>)) (!
  (= (Set_union s1 (Set_union s1 s2)) (Set_union s1 s2))
  :pattern ((Set_union s1 (Set_union s1 s2)))
  :qid |$Set[Int]_prog.union_left_idempotency|)))
(assert (forall ((s1 Set<Int>) (s2 Set<Int>)) (!
  (= (Set_union (Set_union s1 s2) s2) (Set_union s1 s2))
  :pattern ((Set_union (Set_union s1 s2) s2))
  :qid |$Set[Int]_prog.union_right_idempotency|)))
(assert (forall ((s1 Set<Int>) (s2 Set<Int>)) (!
  (= (Set_intersection s1 (Set_intersection s1 s2)) (Set_intersection s1 s2))
  :pattern ((Set_intersection s1 (Set_intersection s1 s2)))
  :qid |$Set[Int]_prog.intersection_left_idempotency|)))
(assert (forall ((s1 Set<Int>) (s2 Set<Int>)) (!
  (= (Set_intersection (Set_intersection s1 s2) s2) (Set_intersection s1 s2))
  :pattern ((Set_intersection (Set_intersection s1 s2) s2))
  :qid |$Set[Int]_prog.intersection_right_idempotency|)))
(assert (forall ((s1 Set<Int>) (s2 Set<Int>)) (!
  (=
    (+ (Set_card (Set_union s1 s2)) (Set_card (Set_intersection s1 s2)))
    (+ (Set_card s1) (Set_card s2)))
  :pattern ((Set_card (Set_union s1 s2)))
  :pattern ((Set_card (Set_intersection s1 s2)))
  :qid |$Set[Int]_prog.cardinality_sums|)))
(assert (forall ((s1 Set<Int>) (s2 Set<Int>) (e Int)) (!
  (= (Set_in e (Set_difference s1 s2)) (and (Set_in e s1) (not (Set_in e s2))))
  :pattern ((Set_in e (Set_difference s1 s2)))
  :qid |$Set[Int]_prog.in_difference|)))
(assert (forall ((s1 Set<Int>) (s2 Set<Int>) (e Int)) (!
  (implies (Set_in e s2) (not (Set_in e (Set_difference s1 s2))))
  :pattern ((Set_difference s1 s2) (Set_in e s2))
  :qid |$Set[Int]_prog.not_in_difference|)))
(assert (forall ((s1 Set<Int>) (s2 Set<Int>)) (!
  (=
    (Set_subset s1 s2)
    (forall ((e Int)) (!
      (implies (Set_in e s1) (Set_in e s2))
      :pattern ((Set_in e s1))
      :pattern ((Set_in e s2))
      )))
  :pattern ((Set_subset s1 s2))
  :qid |$Set[Int]_prog.subset_definition|)))
(assert (forall ((s1 Set<Int>) (s2 Set<Int>)) (!
  (=
    (Set_equal s1 s2)
    (forall ((e Int)) (!
      (= (Set_in e s1) (Set_in e s2))
      :pattern ((Set_in e s1))
      :pattern ((Set_in e s2))
      )))
  :pattern ((Set_equal s1 s2))
  :qid |$Set[Int]_prog.equality_definition|)))
(assert (forall ((s1 Set<Int>) (s2 Set<Int>)) (!
  (implies (Set_equal s1 s2) (= s1 s2))
  :pattern ((Set_equal s1 s2))
  :qid |$Set[Int]_prog.native_equality|)))
(assert (forall ((s1 Set<Int>) (s2 Set<Int>)) (!
  (=
    (Set_disjoint s1 s2)
    (forall ((e Int)) (!
      (or (not (Set_in e s1)) (not (Set_in e s2)))
      :pattern ((Set_in e s1))
      :pattern ((Set_in e s2))
      )))
  :pattern ((Set_disjoint s1 s2))
  :qid |$Set[Int]_prog.disjointness_definition|)))
(assert (forall ((s1 Set<Int>) (s2 Set<Int>)) (!
  (and
    (=
      (+
        (+ (Set_card (Set_difference s1 s2)) (Set_card (Set_difference s2 s1)))
        (Set_card (Set_intersection s1 s2)))
      (Set_card (Set_union s1 s2)))
    (=
      (Set_card (Set_difference s1 s2))
      (- (Set_card s1) (Set_card (Set_intersection s1 s2)))))
  :pattern ((Set_card (Set_difference s1 s2)))
  :qid |$Set[Int]_prog.cardinality_difference|)))
(assert (forall ((s Set<Bool>)) (!
  (<= 0 (Set_card s))
  :pattern ((Set_card s))
  :qid |$Set[Bool]_prog.card_non_negative|)))
(assert (forall ((e Bool)) (!
  (not (Set_in e (as Set_empty  Set<Bool>)))
  :pattern ((Set_in e (as Set_empty  Set<Bool>)))
  :qid |$Set[Bool]_prog.in_empty_set|)))
(assert (forall ((s Set<Bool>)) (!
  (and
    (= (= (Set_card s) 0) (= s (as Set_empty  Set<Bool>)))
    (implies
      (not (= (Set_card s) 0))
      (exists ((e Bool)) (!
        (Set_in e s)
        :pattern ((Set_in e s))
        ))))
  :pattern ((Set_card s))
  :qid |$Set[Bool]_prog.empty_set_cardinality|)))
(assert (forall ((e Bool)) (!
  (Set_in e (Set_singleton e))
  :pattern ((Set_singleton e))
  :qid |$Set[Bool]_prog.in_singleton_set|)))
(assert (forall ((e1 Bool) (e2 Bool)) (!
  (= (Set_in e1 (Set_singleton e2)) (= e1 e2))
  :pattern ((Set_in e1 (Set_singleton e2)))
  :qid |$Set[Bool]_prog.in_singleton_set_equality|)))
(assert (forall ((e Bool)) (!
  (= (Set_card (Set_singleton e)) 1)
  :pattern ((Set_card (Set_singleton e)))
  :qid |$Set[Bool]_prog.singleton_set_cardinality|)))
(assert (forall ((s Set<Bool>) (e Bool)) (!
  (Set_in e (Set_unionone s e))
  :pattern ((Set_unionone s e))
  :qid |$Set[Bool]_prog.in_unionone_same|)))
(assert (forall ((s Set<Bool>) (e1 Bool) (e2 Bool)) (!
  (= (Set_in e1 (Set_unionone s e2)) (or (= e1 e2) (Set_in e1 s)))
  :pattern ((Set_in e1 (Set_unionone s e2)))
  :qid |$Set[Bool]_prog.in_unionone_other|)))
(assert (forall ((s Set<Bool>) (e1 Bool) (e2 Bool)) (!
  (implies (Set_in e1 s) (Set_in e1 (Set_unionone s e2)))
  :pattern ((Set_in e1 s) (Set_unionone s e2))
  :qid |$Set[Bool]_prog.invariance_in_unionone|)))
(assert (forall ((s Set<Bool>) (e Bool)) (!
  (implies (Set_in e s) (= (Set_card (Set_unionone s e)) (Set_card s)))
  :pattern ((Set_card (Set_unionone s e)))
  :qid |$Set[Bool]_prog.unionone_cardinality_invariant|)))
(assert (forall ((s Set<Bool>) (e Bool)) (!
  (implies
    (not (Set_in e s))
    (= (Set_card (Set_unionone s e)) (+ (Set_card s) 1)))
  :pattern ((Set_card (Set_unionone s e)))
  :qid |$Set[Bool]_prog.unionone_cardinality_changed|)))
(assert (forall ((s1 Set<Bool>) (s2 Set<Bool>) (e Bool)) (!
  (= (Set_in e (Set_union s1 s2)) (or (Set_in e s1) (Set_in e s2)))
  :pattern ((Set_in e (Set_union s1 s2)))
  :qid |$Set[Bool]_prog.in_union_in_one|)))
(assert (forall ((s1 Set<Bool>) (s2 Set<Bool>) (e Bool)) (!
  (implies (Set_in e s1) (Set_in e (Set_union s1 s2)))
  :pattern ((Set_in e s1) (Set_union s1 s2))
  :qid |$Set[Bool]_prog.in_left_in_union|)))
(assert (forall ((s1 Set<Bool>) (s2 Set<Bool>) (e Bool)) (!
  (implies (Set_in e s2) (Set_in e (Set_union s1 s2)))
  :pattern ((Set_in e s2) (Set_union s1 s2))
  :qid |$Set[Bool]_prog.in_right_in_union|)))
(assert (forall ((s1 Set<Bool>) (s2 Set<Bool>) (e Bool)) (!
  (= (Set_in e (Set_intersection s1 s2)) (and (Set_in e s1) (Set_in e s2)))
  :pattern ((Set_in e (Set_intersection s1 s2)))
  :pattern ((Set_intersection s1 s2) (Set_in e s1))
  :pattern ((Set_intersection s1 s2) (Set_in e s2))
  :qid |$Set[Bool]_prog.in_intersection_in_both|)))
(assert (forall ((s1 Set<Bool>) (s2 Set<Bool>)) (!
  (= (Set_union s1 (Set_union s1 s2)) (Set_union s1 s2))
  :pattern ((Set_union s1 (Set_union s1 s2)))
  :qid |$Set[Bool]_prog.union_left_idempotency|)))
(assert (forall ((s1 Set<Bool>) (s2 Set<Bool>)) (!
  (= (Set_union (Set_union s1 s2) s2) (Set_union s1 s2))
  :pattern ((Set_union (Set_union s1 s2) s2))
  :qid |$Set[Bool]_prog.union_right_idempotency|)))
(assert (forall ((s1 Set<Bool>) (s2 Set<Bool>)) (!
  (= (Set_intersection s1 (Set_intersection s1 s2)) (Set_intersection s1 s2))
  :pattern ((Set_intersection s1 (Set_intersection s1 s2)))
  :qid |$Set[Bool]_prog.intersection_left_idempotency|)))
(assert (forall ((s1 Set<Bool>) (s2 Set<Bool>)) (!
  (= (Set_intersection (Set_intersection s1 s2) s2) (Set_intersection s1 s2))
  :pattern ((Set_intersection (Set_intersection s1 s2) s2))
  :qid |$Set[Bool]_prog.intersection_right_idempotency|)))
(assert (forall ((s1 Set<Bool>) (s2 Set<Bool>)) (!
  (=
    (+ (Set_card (Set_union s1 s2)) (Set_card (Set_intersection s1 s2)))
    (+ (Set_card s1) (Set_card s2)))
  :pattern ((Set_card (Set_union s1 s2)))
  :pattern ((Set_card (Set_intersection s1 s2)))
  :qid |$Set[Bool]_prog.cardinality_sums|)))
(assert (forall ((s1 Set<Bool>) (s2 Set<Bool>) (e Bool)) (!
  (= (Set_in e (Set_difference s1 s2)) (and (Set_in e s1) (not (Set_in e s2))))
  :pattern ((Set_in e (Set_difference s1 s2)))
  :qid |$Set[Bool]_prog.in_difference|)))
(assert (forall ((s1 Set<Bool>) (s2 Set<Bool>) (e Bool)) (!
  (implies (Set_in e s2) (not (Set_in e (Set_difference s1 s2))))
  :pattern ((Set_difference s1 s2) (Set_in e s2))
  :qid |$Set[Bool]_prog.not_in_difference|)))
(assert (forall ((s1 Set<Bool>) (s2 Set<Bool>)) (!
  (=
    (Set_subset s1 s2)
    (forall ((e Bool)) (!
      (implies (Set_in e s1) (Set_in e s2))
      :pattern ((Set_in e s1))
      :pattern ((Set_in e s2))
      )))
  :pattern ((Set_subset s1 s2))
  :qid |$Set[Bool]_prog.subset_definition|)))
(assert (forall ((s1 Set<Bool>) (s2 Set<Bool>)) (!
  (=
    (Set_equal s1 s2)
    (forall ((e Bool)) (!
      (= (Set_in e s1) (Set_in e s2))
      :pattern ((Set_in e s1))
      :pattern ((Set_in e s2))
      )))
  :pattern ((Set_equal s1 s2))
  :qid |$Set[Bool]_prog.equality_definition|)))
(assert (forall ((s1 Set<Bool>) (s2 Set<Bool>)) (!
  (implies (Set_equal s1 s2) (= s1 s2))
  :pattern ((Set_equal s1 s2))
  :qid |$Set[Bool]_prog.native_equality|)))
(assert (forall ((s1 Set<Bool>) (s2 Set<Bool>)) (!
  (=
    (Set_disjoint s1 s2)
    (forall ((e Bool)) (!
      (or (not (Set_in e s1)) (not (Set_in e s2)))
      :pattern ((Set_in e s1))
      :pattern ((Set_in e s2))
      )))
  :pattern ((Set_disjoint s1 s2))
  :qid |$Set[Bool]_prog.disjointness_definition|)))
(assert (forall ((s1 Set<Bool>) (s2 Set<Bool>)) (!
  (and
    (=
      (+
        (+ (Set_card (Set_difference s1 s2)) (Set_card (Set_difference s2 s1)))
        (Set_card (Set_intersection s1 s2)))
      (Set_card (Set_union s1 s2)))
    (=
      (Set_card (Set_difference s1 s2))
      (- (Set_card s1) (Set_card (Set_intersection s1 s2)))))
  :pattern ((Set_card (Set_difference s1 s2)))
  :qid |$Set[Bool]_prog.cardinality_difference|)))
(assert (forall ((s Set<option<array>>)) (!
  (<= 0 (Set_card s))
  :pattern ((Set_card s))
  :qid |$Set[option[array]]_prog.card_non_negative|)))
(assert (forall ((e option<array>)) (!
  (not (Set_in e (as Set_empty  Set<option<array>>)))
  :pattern ((Set_in e (as Set_empty  Set<option<array>>)))
  :qid |$Set[option[array]]_prog.in_empty_set|)))
(assert (forall ((s Set<option<array>>)) (!
  (and
    (= (= (Set_card s) 0) (= s (as Set_empty  Set<option<array>>)))
    (implies
      (not (= (Set_card s) 0))
      (exists ((e option<array>)) (!
        (Set_in e s)
        :pattern ((Set_in e s))
        ))))
  :pattern ((Set_card s))
  :qid |$Set[option[array]]_prog.empty_set_cardinality|)))
(assert (forall ((e option<array>)) (!
  (Set_in e (Set_singleton e))
  :pattern ((Set_singleton e))
  :qid |$Set[option[array]]_prog.in_singleton_set|)))
(assert (forall ((e1 option<array>) (e2 option<array>)) (!
  (= (Set_in e1 (Set_singleton e2)) (= e1 e2))
  :pattern ((Set_in e1 (Set_singleton e2)))
  :qid |$Set[option[array]]_prog.in_singleton_set_equality|)))
(assert (forall ((e option<array>)) (!
  (= (Set_card (Set_singleton e)) 1)
  :pattern ((Set_card (Set_singleton e)))
  :qid |$Set[option[array]]_prog.singleton_set_cardinality|)))
(assert (forall ((s Set<option<array>>) (e option<array>)) (!
  (Set_in e (Set_unionone s e))
  :pattern ((Set_unionone s e))
  :qid |$Set[option[array]]_prog.in_unionone_same|)))
(assert (forall ((s Set<option<array>>) (e1 option<array>) (e2 option<array>)) (!
  (= (Set_in e1 (Set_unionone s e2)) (or (= e1 e2) (Set_in e1 s)))
  :pattern ((Set_in e1 (Set_unionone s e2)))
  :qid |$Set[option[array]]_prog.in_unionone_other|)))
(assert (forall ((s Set<option<array>>) (e1 option<array>) (e2 option<array>)) (!
  (implies (Set_in e1 s) (Set_in e1 (Set_unionone s e2)))
  :pattern ((Set_in e1 s) (Set_unionone s e2))
  :qid |$Set[option[array]]_prog.invariance_in_unionone|)))
(assert (forall ((s Set<option<array>>) (e option<array>)) (!
  (implies (Set_in e s) (= (Set_card (Set_unionone s e)) (Set_card s)))
  :pattern ((Set_card (Set_unionone s e)))
  :qid |$Set[option[array]]_prog.unionone_cardinality_invariant|)))
(assert (forall ((s Set<option<array>>) (e option<array>)) (!
  (implies
    (not (Set_in e s))
    (= (Set_card (Set_unionone s e)) (+ (Set_card s) 1)))
  :pattern ((Set_card (Set_unionone s e)))
  :qid |$Set[option[array]]_prog.unionone_cardinality_changed|)))
(assert (forall ((s1 Set<option<array>>) (s2 Set<option<array>>) (e option<array>)) (!
  (= (Set_in e (Set_union s1 s2)) (or (Set_in e s1) (Set_in e s2)))
  :pattern ((Set_in e (Set_union s1 s2)))
  :qid |$Set[option[array]]_prog.in_union_in_one|)))
(assert (forall ((s1 Set<option<array>>) (s2 Set<option<array>>) (e option<array>)) (!
  (implies (Set_in e s1) (Set_in e (Set_union s1 s2)))
  :pattern ((Set_in e s1) (Set_union s1 s2))
  :qid |$Set[option[array]]_prog.in_left_in_union|)))
(assert (forall ((s1 Set<option<array>>) (s2 Set<option<array>>) (e option<array>)) (!
  (implies (Set_in e s2) (Set_in e (Set_union s1 s2)))
  :pattern ((Set_in e s2) (Set_union s1 s2))
  :qid |$Set[option[array]]_prog.in_right_in_union|)))
(assert (forall ((s1 Set<option<array>>) (s2 Set<option<array>>) (e option<array>)) (!
  (= (Set_in e (Set_intersection s1 s2)) (and (Set_in e s1) (Set_in e s2)))
  :pattern ((Set_in e (Set_intersection s1 s2)))
  :pattern ((Set_intersection s1 s2) (Set_in e s1))
  :pattern ((Set_intersection s1 s2) (Set_in e s2))
  :qid |$Set[option[array]]_prog.in_intersection_in_both|)))
(assert (forall ((s1 Set<option<array>>) (s2 Set<option<array>>)) (!
  (= (Set_union s1 (Set_union s1 s2)) (Set_union s1 s2))
  :pattern ((Set_union s1 (Set_union s1 s2)))
  :qid |$Set[option[array]]_prog.union_left_idempotency|)))
(assert (forall ((s1 Set<option<array>>) (s2 Set<option<array>>)) (!
  (= (Set_union (Set_union s1 s2) s2) (Set_union s1 s2))
  :pattern ((Set_union (Set_union s1 s2) s2))
  :qid |$Set[option[array]]_prog.union_right_idempotency|)))
(assert (forall ((s1 Set<option<array>>) (s2 Set<option<array>>)) (!
  (= (Set_intersection s1 (Set_intersection s1 s2)) (Set_intersection s1 s2))
  :pattern ((Set_intersection s1 (Set_intersection s1 s2)))
  :qid |$Set[option[array]]_prog.intersection_left_idempotency|)))
(assert (forall ((s1 Set<option<array>>) (s2 Set<option<array>>)) (!
  (= (Set_intersection (Set_intersection s1 s2) s2) (Set_intersection s1 s2))
  :pattern ((Set_intersection (Set_intersection s1 s2) s2))
  :qid |$Set[option[array]]_prog.intersection_right_idempotency|)))
(assert (forall ((s1 Set<option<array>>) (s2 Set<option<array>>)) (!
  (=
    (+ (Set_card (Set_union s1 s2)) (Set_card (Set_intersection s1 s2)))
    (+ (Set_card s1) (Set_card s2)))
  :pattern ((Set_card (Set_union s1 s2)))
  :pattern ((Set_card (Set_intersection s1 s2)))
  :qid |$Set[option[array]]_prog.cardinality_sums|)))
(assert (forall ((s1 Set<option<array>>) (s2 Set<option<array>>) (e option<array>)) (!
  (= (Set_in e (Set_difference s1 s2)) (and (Set_in e s1) (not (Set_in e s2))))
  :pattern ((Set_in e (Set_difference s1 s2)))
  :qid |$Set[option[array]]_prog.in_difference|)))
(assert (forall ((s1 Set<option<array>>) (s2 Set<option<array>>) (e option<array>)) (!
  (implies (Set_in e s2) (not (Set_in e (Set_difference s1 s2))))
  :pattern ((Set_difference s1 s2) (Set_in e s2))
  :qid |$Set[option[array]]_prog.not_in_difference|)))
(assert (forall ((s1 Set<option<array>>) (s2 Set<option<array>>)) (!
  (=
    (Set_subset s1 s2)
    (forall ((e option<array>)) (!
      (implies (Set_in e s1) (Set_in e s2))
      :pattern ((Set_in e s1))
      :pattern ((Set_in e s2))
      )))
  :pattern ((Set_subset s1 s2))
  :qid |$Set[option[array]]_prog.subset_definition|)))
(assert (forall ((s1 Set<option<array>>) (s2 Set<option<array>>)) (!
  (=
    (Set_equal s1 s2)
    (forall ((e option<array>)) (!
      (= (Set_in e s1) (Set_in e s2))
      :pattern ((Set_in e s1))
      :pattern ((Set_in e s2))
      )))
  :pattern ((Set_equal s1 s2))
  :qid |$Set[option[array]]_prog.equality_definition|)))
(assert (forall ((s1 Set<option<array>>) (s2 Set<option<array>>)) (!
  (implies (Set_equal s1 s2) (= s1 s2))
  :pattern ((Set_equal s1 s2))
  :qid |$Set[option[array]]_prog.native_equality|)))
(assert (forall ((s1 Set<option<array>>) (s2 Set<option<array>>)) (!
  (=
    (Set_disjoint s1 s2)
    (forall ((e option<array>)) (!
      (or (not (Set_in e s1)) (not (Set_in e s2)))
      :pattern ((Set_in e s1))
      :pattern ((Set_in e s2))
      )))
  :pattern ((Set_disjoint s1 s2))
  :qid |$Set[option[array]]_prog.disjointness_definition|)))
(assert (forall ((s1 Set<option<array>>) (s2 Set<option<array>>)) (!
  (and
    (=
      (+
        (+ (Set_card (Set_difference s1 s2)) (Set_card (Set_difference s2 s1)))
        (Set_card (Set_intersection s1 s2)))
      (Set_card (Set_union s1 s2)))
    (=
      (Set_card (Set_difference s1 s2))
      (- (Set_card s1) (Set_card (Set_intersection s1 s2)))))
  :pattern ((Set_card (Set_difference s1 s2)))
  :qid |$Set[option[array]]_prog.cardinality_difference|)))
(assert (forall ((s Set<$Ref>)) (!
  (<= 0 (Set_card s))
  :pattern ((Set_card s))
  :qid |$Set[Ref]_prog.card_non_negative|)))
(assert (forall ((e $Ref)) (!
  (not (Set_in e (as Set_empty  Set<$Ref>)))
  :pattern ((Set_in e (as Set_empty  Set<$Ref>)))
  :qid |$Set[Ref]_prog.in_empty_set|)))
(assert (forall ((s Set<$Ref>)) (!
  (and
    (= (= (Set_card s) 0) (= s (as Set_empty  Set<$Ref>)))
    (implies
      (not (= (Set_card s) 0))
      (exists ((e $Ref)) (!
        (Set_in e s)
        :pattern ((Set_in e s))
        ))))
  :pattern ((Set_card s))
  :qid |$Set[Ref]_prog.empty_set_cardinality|)))
(assert (forall ((e $Ref)) (!
  (Set_in e (Set_singleton e))
  :pattern ((Set_singleton e))
  :qid |$Set[Ref]_prog.in_singleton_set|)))
(assert (forall ((e1 $Ref) (e2 $Ref)) (!
  (= (Set_in e1 (Set_singleton e2)) (= e1 e2))
  :pattern ((Set_in e1 (Set_singleton e2)))
  :qid |$Set[Ref]_prog.in_singleton_set_equality|)))
(assert (forall ((e $Ref)) (!
  (= (Set_card (Set_singleton e)) 1)
  :pattern ((Set_card (Set_singleton e)))
  :qid |$Set[Ref]_prog.singleton_set_cardinality|)))
(assert (forall ((s Set<$Ref>) (e $Ref)) (!
  (Set_in e (Set_unionone s e))
  :pattern ((Set_unionone s e))
  :qid |$Set[Ref]_prog.in_unionone_same|)))
(assert (forall ((s Set<$Ref>) (e1 $Ref) (e2 $Ref)) (!
  (= (Set_in e1 (Set_unionone s e2)) (or (= e1 e2) (Set_in e1 s)))
  :pattern ((Set_in e1 (Set_unionone s e2)))
  :qid |$Set[Ref]_prog.in_unionone_other|)))
(assert (forall ((s Set<$Ref>) (e1 $Ref) (e2 $Ref)) (!
  (implies (Set_in e1 s) (Set_in e1 (Set_unionone s e2)))
  :pattern ((Set_in e1 s) (Set_unionone s e2))
  :qid |$Set[Ref]_prog.invariance_in_unionone|)))
(assert (forall ((s Set<$Ref>) (e $Ref)) (!
  (implies (Set_in e s) (= (Set_card (Set_unionone s e)) (Set_card s)))
  :pattern ((Set_card (Set_unionone s e)))
  :qid |$Set[Ref]_prog.unionone_cardinality_invariant|)))
(assert (forall ((s Set<$Ref>) (e $Ref)) (!
  (implies
    (not (Set_in e s))
    (= (Set_card (Set_unionone s e)) (+ (Set_card s) 1)))
  :pattern ((Set_card (Set_unionone s e)))
  :qid |$Set[Ref]_prog.unionone_cardinality_changed|)))
(assert (forall ((s1 Set<$Ref>) (s2 Set<$Ref>) (e $Ref)) (!
  (= (Set_in e (Set_union s1 s2)) (or (Set_in e s1) (Set_in e s2)))
  :pattern ((Set_in e (Set_union s1 s2)))
  :qid |$Set[Ref]_prog.in_union_in_one|)))
(assert (forall ((s1 Set<$Ref>) (s2 Set<$Ref>) (e $Ref)) (!
  (implies (Set_in e s1) (Set_in e (Set_union s1 s2)))
  :pattern ((Set_in e s1) (Set_union s1 s2))
  :qid |$Set[Ref]_prog.in_left_in_union|)))
(assert (forall ((s1 Set<$Ref>) (s2 Set<$Ref>) (e $Ref)) (!
  (implies (Set_in e s2) (Set_in e (Set_union s1 s2)))
  :pattern ((Set_in e s2) (Set_union s1 s2))
  :qid |$Set[Ref]_prog.in_right_in_union|)))
(assert (forall ((s1 Set<$Ref>) (s2 Set<$Ref>) (e $Ref)) (!
  (= (Set_in e (Set_intersection s1 s2)) (and (Set_in e s1) (Set_in e s2)))
  :pattern ((Set_in e (Set_intersection s1 s2)))
  :pattern ((Set_intersection s1 s2) (Set_in e s1))
  :pattern ((Set_intersection s1 s2) (Set_in e s2))
  :qid |$Set[Ref]_prog.in_intersection_in_both|)))
(assert (forall ((s1 Set<$Ref>) (s2 Set<$Ref>)) (!
  (= (Set_union s1 (Set_union s1 s2)) (Set_union s1 s2))
  :pattern ((Set_union s1 (Set_union s1 s2)))
  :qid |$Set[Ref]_prog.union_left_idempotency|)))
(assert (forall ((s1 Set<$Ref>) (s2 Set<$Ref>)) (!
  (= (Set_union (Set_union s1 s2) s2) (Set_union s1 s2))
  :pattern ((Set_union (Set_union s1 s2) s2))
  :qid |$Set[Ref]_prog.union_right_idempotency|)))
(assert (forall ((s1 Set<$Ref>) (s2 Set<$Ref>)) (!
  (= (Set_intersection s1 (Set_intersection s1 s2)) (Set_intersection s1 s2))
  :pattern ((Set_intersection s1 (Set_intersection s1 s2)))
  :qid |$Set[Ref]_prog.intersection_left_idempotency|)))
(assert (forall ((s1 Set<$Ref>) (s2 Set<$Ref>)) (!
  (= (Set_intersection (Set_intersection s1 s2) s2) (Set_intersection s1 s2))
  :pattern ((Set_intersection (Set_intersection s1 s2) s2))
  :qid |$Set[Ref]_prog.intersection_right_idempotency|)))
(assert (forall ((s1 Set<$Ref>) (s2 Set<$Ref>)) (!
  (=
    (+ (Set_card (Set_union s1 s2)) (Set_card (Set_intersection s1 s2)))
    (+ (Set_card s1) (Set_card s2)))
  :pattern ((Set_card (Set_union s1 s2)))
  :pattern ((Set_card (Set_intersection s1 s2)))
  :qid |$Set[Ref]_prog.cardinality_sums|)))
(assert (forall ((s1 Set<$Ref>) (s2 Set<$Ref>) (e $Ref)) (!
  (= (Set_in e (Set_difference s1 s2)) (and (Set_in e s1) (not (Set_in e s2))))
  :pattern ((Set_in e (Set_difference s1 s2)))
  :qid |$Set[Ref]_prog.in_difference|)))
(assert (forall ((s1 Set<$Ref>) (s2 Set<$Ref>) (e $Ref)) (!
  (implies (Set_in e s2) (not (Set_in e (Set_difference s1 s2))))
  :pattern ((Set_difference s1 s2) (Set_in e s2))
  :qid |$Set[Ref]_prog.not_in_difference|)))
(assert (forall ((s1 Set<$Ref>) (s2 Set<$Ref>)) (!
  (=
    (Set_subset s1 s2)
    (forall ((e $Ref)) (!
      (implies (Set_in e s1) (Set_in e s2))
      :pattern ((Set_in e s1))
      :pattern ((Set_in e s2))
      )))
  :pattern ((Set_subset s1 s2))
  :qid |$Set[Ref]_prog.subset_definition|)))
(assert (forall ((s1 Set<$Ref>) (s2 Set<$Ref>)) (!
  (=
    (Set_equal s1 s2)
    (forall ((e $Ref)) (!
      (= (Set_in e s1) (Set_in e s2))
      :pattern ((Set_in e s1))
      :pattern ((Set_in e s2))
      )))
  :pattern ((Set_equal s1 s2))
  :qid |$Set[Ref]_prog.equality_definition|)))
(assert (forall ((s1 Set<$Ref>) (s2 Set<$Ref>)) (!
  (implies (Set_equal s1 s2) (= s1 s2))
  :pattern ((Set_equal s1 s2))
  :qid |$Set[Ref]_prog.native_equality|)))
(assert (forall ((s1 Set<$Ref>) (s2 Set<$Ref>)) (!
  (=
    (Set_disjoint s1 s2)
    (forall ((e $Ref)) (!
      (or (not (Set_in e s1)) (not (Set_in e s2)))
      :pattern ((Set_in e s1))
      :pattern ((Set_in e s2))
      )))
  :pattern ((Set_disjoint s1 s2))
  :qid |$Set[Ref]_prog.disjointness_definition|)))
(assert (forall ((s1 Set<$Ref>) (s2 Set<$Ref>)) (!
  (and
    (=
      (+
        (+ (Set_card (Set_difference s1 s2)) (Set_card (Set_difference s2 s1)))
        (Set_card (Set_intersection s1 s2)))
      (Set_card (Set_union s1 s2)))
    (=
      (Set_card (Set_difference s1 s2))
      (- (Set_card s1) (Set_card (Set_intersection s1 s2)))))
  :pattern ((Set_card (Set_difference s1 s2)))
  :qid |$Set[Ref]_prog.cardinality_difference|)))
(assert (forall ((s Set<$Snap>)) (!
  (<= 0 (Set_card s))
  :pattern ((Set_card s))
  :qid |$Set[Snap]_prog.card_non_negative|)))
(assert (forall ((e $Snap)) (!
  (not (Set_in e (as Set_empty  Set<$Snap>)))
  :pattern ((Set_in e (as Set_empty  Set<$Snap>)))
  :qid |$Set[Snap]_prog.in_empty_set|)))
(assert (forall ((s Set<$Snap>)) (!
  (and
    (= (= (Set_card s) 0) (= s (as Set_empty  Set<$Snap>)))
    (implies
      (not (= (Set_card s) 0))
      (exists ((e $Snap)) (!
        (Set_in e s)
        :pattern ((Set_in e s))
        ))))
  :pattern ((Set_card s))
  :qid |$Set[Snap]_prog.empty_set_cardinality|)))
(assert (forall ((e $Snap)) (!
  (Set_in e (Set_singleton e))
  :pattern ((Set_singleton e))
  :qid |$Set[Snap]_prog.in_singleton_set|)))
(assert (forall ((e1 $Snap) (e2 $Snap)) (!
  (= (Set_in e1 (Set_singleton e2)) (= e1 e2))
  :pattern ((Set_in e1 (Set_singleton e2)))
  :qid |$Set[Snap]_prog.in_singleton_set_equality|)))
(assert (forall ((e $Snap)) (!
  (= (Set_card (Set_singleton e)) 1)
  :pattern ((Set_card (Set_singleton e)))
  :qid |$Set[Snap]_prog.singleton_set_cardinality|)))
(assert (forall ((s Set<$Snap>) (e $Snap)) (!
  (Set_in e (Set_unionone s e))
  :pattern ((Set_unionone s e))
  :qid |$Set[Snap]_prog.in_unionone_same|)))
(assert (forall ((s Set<$Snap>) (e1 $Snap) (e2 $Snap)) (!
  (= (Set_in e1 (Set_unionone s e2)) (or (= e1 e2) (Set_in e1 s)))
  :pattern ((Set_in e1 (Set_unionone s e2)))
  :qid |$Set[Snap]_prog.in_unionone_other|)))
(assert (forall ((s Set<$Snap>) (e1 $Snap) (e2 $Snap)) (!
  (implies (Set_in e1 s) (Set_in e1 (Set_unionone s e2)))
  :pattern ((Set_in e1 s) (Set_unionone s e2))
  :qid |$Set[Snap]_prog.invariance_in_unionone|)))
(assert (forall ((s Set<$Snap>) (e $Snap)) (!
  (implies (Set_in e s) (= (Set_card (Set_unionone s e)) (Set_card s)))
  :pattern ((Set_card (Set_unionone s e)))
  :qid |$Set[Snap]_prog.unionone_cardinality_invariant|)))
(assert (forall ((s Set<$Snap>) (e $Snap)) (!
  (implies
    (not (Set_in e s))
    (= (Set_card (Set_unionone s e)) (+ (Set_card s) 1)))
  :pattern ((Set_card (Set_unionone s e)))
  :qid |$Set[Snap]_prog.unionone_cardinality_changed|)))
(assert (forall ((s1 Set<$Snap>) (s2 Set<$Snap>) (e $Snap)) (!
  (= (Set_in e (Set_union s1 s2)) (or (Set_in e s1) (Set_in e s2)))
  :pattern ((Set_in e (Set_union s1 s2)))
  :qid |$Set[Snap]_prog.in_union_in_one|)))
(assert (forall ((s1 Set<$Snap>) (s2 Set<$Snap>) (e $Snap)) (!
  (implies (Set_in e s1) (Set_in e (Set_union s1 s2)))
  :pattern ((Set_in e s1) (Set_union s1 s2))
  :qid |$Set[Snap]_prog.in_left_in_union|)))
(assert (forall ((s1 Set<$Snap>) (s2 Set<$Snap>) (e $Snap)) (!
  (implies (Set_in e s2) (Set_in e (Set_union s1 s2)))
  :pattern ((Set_in e s2) (Set_union s1 s2))
  :qid |$Set[Snap]_prog.in_right_in_union|)))
(assert (forall ((s1 Set<$Snap>) (s2 Set<$Snap>) (e $Snap)) (!
  (= (Set_in e (Set_intersection s1 s2)) (and (Set_in e s1) (Set_in e s2)))
  :pattern ((Set_in e (Set_intersection s1 s2)))
  :pattern ((Set_intersection s1 s2) (Set_in e s1))
  :pattern ((Set_intersection s1 s2) (Set_in e s2))
  :qid |$Set[Snap]_prog.in_intersection_in_both|)))
(assert (forall ((s1 Set<$Snap>) (s2 Set<$Snap>)) (!
  (= (Set_union s1 (Set_union s1 s2)) (Set_union s1 s2))
  :pattern ((Set_union s1 (Set_union s1 s2)))
  :qid |$Set[Snap]_prog.union_left_idempotency|)))
(assert (forall ((s1 Set<$Snap>) (s2 Set<$Snap>)) (!
  (= (Set_union (Set_union s1 s2) s2) (Set_union s1 s2))
  :pattern ((Set_union (Set_union s1 s2) s2))
  :qid |$Set[Snap]_prog.union_right_idempotency|)))
(assert (forall ((s1 Set<$Snap>) (s2 Set<$Snap>)) (!
  (= (Set_intersection s1 (Set_intersection s1 s2)) (Set_intersection s1 s2))
  :pattern ((Set_intersection s1 (Set_intersection s1 s2)))
  :qid |$Set[Snap]_prog.intersection_left_idempotency|)))
(assert (forall ((s1 Set<$Snap>) (s2 Set<$Snap>)) (!
  (= (Set_intersection (Set_intersection s1 s2) s2) (Set_intersection s1 s2))
  :pattern ((Set_intersection (Set_intersection s1 s2) s2))
  :qid |$Set[Snap]_prog.intersection_right_idempotency|)))
(assert (forall ((s1 Set<$Snap>) (s2 Set<$Snap>)) (!
  (=
    (+ (Set_card (Set_union s1 s2)) (Set_card (Set_intersection s1 s2)))
    (+ (Set_card s1) (Set_card s2)))
  :pattern ((Set_card (Set_union s1 s2)))
  :pattern ((Set_card (Set_intersection s1 s2)))
  :qid |$Set[Snap]_prog.cardinality_sums|)))
(assert (forall ((s1 Set<$Snap>) (s2 Set<$Snap>) (e $Snap)) (!
  (= (Set_in e (Set_difference s1 s2)) (and (Set_in e s1) (not (Set_in e s2))))
  :pattern ((Set_in e (Set_difference s1 s2)))
  :qid |$Set[Snap]_prog.in_difference|)))
(assert (forall ((s1 Set<$Snap>) (s2 Set<$Snap>) (e $Snap)) (!
  (implies (Set_in e s2) (not (Set_in e (Set_difference s1 s2))))
  :pattern ((Set_difference s1 s2) (Set_in e s2))
  :qid |$Set[Snap]_prog.not_in_difference|)))
(assert (forall ((s1 Set<$Snap>) (s2 Set<$Snap>)) (!
  (=
    (Set_subset s1 s2)
    (forall ((e $Snap)) (!
      (implies (Set_in e s1) (Set_in e s2))
      :pattern ((Set_in e s1))
      :pattern ((Set_in e s2))
      )))
  :pattern ((Set_subset s1 s2))
  :qid |$Set[Snap]_prog.subset_definition|)))
(assert (forall ((s1 Set<$Snap>) (s2 Set<$Snap>)) (!
  (=
    (Set_equal s1 s2)
    (forall ((e $Snap)) (!
      (= (Set_in e s1) (Set_in e s2))
      :pattern ((Set_in e s1))
      :pattern ((Set_in e s2))
      )))
  :pattern ((Set_equal s1 s2))
  :qid |$Set[Snap]_prog.equality_definition|)))
(assert (forall ((s1 Set<$Snap>) (s2 Set<$Snap>)) (!
  (implies (Set_equal s1 s2) (= s1 s2))
  :pattern ((Set_equal s1 s2))
  :qid |$Set[Snap]_prog.native_equality|)))
(assert (forall ((s1 Set<$Snap>) (s2 Set<$Snap>)) (!
  (=
    (Set_disjoint s1 s2)
    (forall ((e $Snap)) (!
      (or (not (Set_in e s1)) (not (Set_in e s2)))
      :pattern ((Set_in e s1))
      :pattern ((Set_in e s2))
      )))
  :pattern ((Set_disjoint s1 s2))
  :qid |$Set[Snap]_prog.disjointness_definition|)))
(assert (forall ((s1 Set<$Snap>) (s2 Set<$Snap>)) (!
  (and
    (=
      (+
        (+ (Set_card (Set_difference s1 s2)) (Set_card (Set_difference s2 s1)))
        (Set_card (Set_intersection s1 s2)))
      (Set_card (Set_union s1 s2)))
    (=
      (Set_card (Set_difference s1 s2))
      (- (Set_card s1) (Set_card (Set_intersection s1 s2)))))
  :pattern ((Set_card (Set_difference s1 s2)))
  :qid |$Set[Snap]_prog.cardinality_difference|)))
(assert (forall ((a2 array)) (!
  (forall ((i1 Int)) (!
    (and
      (= (loc_inv_1<array> (array_loc<Ref> a2 i1)) a2)
      (= (loc_inv_2<Int> (array_loc<Ref> a2 i1)) i1))
    :pattern ((loc_inv_1<array> (array_loc<Ref> a2 i1)))
    :pattern ((loc_inv_2<Int> (array_loc<Ref> a2 i1)))
    ))
  
  )))
(assert (forall ((a2 array)) (!
  (>= (alen<Int> a2) 0)
  :pattern ((alen<Int> a2))
  )))
(assert (forall ((x1 array)) (!
  (not (= (as None<option<array>>  option<array>) (some<option<array>> x1)))
  :pattern ((some<option<array>> x1))
  )))
(assert (forall ((x1 array)) (!
  (= (option_get<array> (some<option<array>> x1)) x1)
  :pattern ((option_get<array> (some<option<array>> x1)))
  )))
(assert (forall ((opt1 option<array>)) (!
  (= (some<option<array>> (option_get<array> opt1)) opt1)
  :pattern ((some<option<array>> (option_get<array> opt1)))
  )))
(assert (forall ((v t_null)) (!
  (= (as v_null<t_null>  t_null) v)
  
  )))
(assert (forall ((x1 any)) (!
  (not (= (as None<option<any>>  option<any>) (some<option<any>> x1)))
  :pattern ((some<option<any>> x1))
  )))
(assert (forall ((x1 any)) (!
  (= (option_get<any> (some<option<any>> x1)) x1)
  :pattern ((option_get<any> (some<option<any>> x1)))
  )))
(assert (forall ((opt1 option<any>)) (!
  (= (some<option<any>> (option_get<any> opt1)) opt1)
  :pattern ((some<option<any>> (option_get<any> opt1)))
  )))
(assert (forall ((v void)) (!
  (= (as unit<void>  void) v)
  
  )))
; /field_value_functions_axioms.smt2 [int: Int]
(assert (forall ((vs $FVF<Int>) (ws $FVF<Int>)) (!
    (implies
      (and
        (Set_equal ($FVF.domain_int vs) ($FVF.domain_int ws))
        (forall ((x $Ref)) (!
          (implies
            (Set_in x ($FVF.domain_int vs))
            (= ($FVF.lookup_int vs x) ($FVF.lookup_int ws x)))
          :pattern (($FVF.lookup_int vs x) ($FVF.lookup_int ws x))
          :qid |qp.$FVF<Int>-eq-inner|
          )))
      (= vs ws))
    :pattern (($SortWrappers.$FVF<Int>To$Snap vs)
              ($SortWrappers.$FVF<Int>To$Snap ws)
              )
    :qid |qp.$FVF<Int>-eq-outer|
    )))
(assert (forall ((r $Ref) (pm $FPM)) (!
    ($Perm.isValidVar ($FVF.perm_int pm r))
    :pattern ($FVF.perm_int pm r))))
(assert (forall ((r $Ref) (f Int)) (!
    (= ($FVF.loc_int f r) true)
    :pattern ($FVF.loc_int f r))))
; /field_value_functions_axioms.smt2 [option$array$: option[array]]
(assert (forall ((vs $FVF<option<array>>) (ws $FVF<option<array>>)) (!
    (implies
      (and
        (Set_equal ($FVF.domain_option$array$ vs) ($FVF.domain_option$array$ ws))
        (forall ((x $Ref)) (!
          (implies
            (Set_in x ($FVF.domain_option$array$ vs))
            (= ($FVF.lookup_option$array$ vs x) ($FVF.lookup_option$array$ ws x)))
          :pattern (($FVF.lookup_option$array$ vs x) ($FVF.lookup_option$array$ ws x))
          :qid |qp.$FVF<option<array>>-eq-inner|
          )))
      (= vs ws))
    :pattern (($SortWrappers.$FVF<option<array>>To$Snap vs)
              ($SortWrappers.$FVF<option<array>>To$Snap ws)
              )
    :qid |qp.$FVF<option<array>>-eq-outer|
    )))
(assert (forall ((r $Ref) (pm $FPM)) (!
    ($Perm.isValidVar ($FVF.perm_option$array$ pm r))
    :pattern ($FVF.perm_option$array$ pm r))))
(assert (forall ((r $Ref) (f option<array>)) (!
    (= ($FVF.loc_option$array$ f r) true)
    :pattern ($FVF.loc_option$array$ f r))))
; /field_value_functions_axioms.smt2 [bool: Bool]
(assert (forall ((vs $FVF<Bool>) (ws $FVF<Bool>)) (!
    (implies
      (and
        (Set_equal ($FVF.domain_bool vs) ($FVF.domain_bool ws))
        (forall ((x $Ref)) (!
          (implies
            (Set_in x ($FVF.domain_bool vs))
            (= ($FVF.lookup_bool vs x) ($FVF.lookup_bool ws x)))
          :pattern (($FVF.lookup_bool vs x) ($FVF.lookup_bool ws x))
          :qid |qp.$FVF<Bool>-eq-inner|
          )))
      (= vs ws))
    :pattern (($SortWrappers.$FVF<Bool>To$Snap vs)
              ($SortWrappers.$FVF<Bool>To$Snap ws)
              )
    :qid |qp.$FVF<Bool>-eq-outer|
    )))
(assert (forall ((r $Ref) (pm $FPM)) (!
    ($Perm.isValidVar ($FVF.perm_bool pm r))
    :pattern ($FVF.perm_bool pm r))))
(assert (forall ((r $Ref) (f Bool)) (!
    (= ($FVF.loc_bool f r) true)
    :pattern ($FVF.loc_bool f r))))
; End preamble
; ------------------------------------------------------------
; State saturation: after preamble
(set-option :timeout 100)
(check-sat)
; unknown
; ------------------------------------------------------------
; Begin function- and predicate-related preamble
; Declaring symbols related to program functions (from verification)
(declare-fun $k@121@00 () $Perm)
(declare-fun $k@130@00 () $Perm)
(declare-fun inv@122@00 ($Snap $Ref option<array> Int $Ref) Int)
(declare-fun inv@131@00 ($Snap $Ref option<array> Int $Ref) Int)
(declare-fun inv@132@00 ($Snap $Ref option<array> Int $Ref) Int)
(declare-fun sm@123@00 ($Snap $Ref option<array> Int) $FVF<option<array>>)
(declare-fun $k@136@00 () $Perm)
(declare-fun inv@138@00 ($Snap option<array> Int Int $Ref) Int)
(declare-fun sm@139@00 ($Snap option<array> Int Int) $FVF<Int>)
(declare-fun $k@147@00 () $Perm)
(declare-fun inv@148@00 ($Snap $Ref option<array> Int $Ref) Int)
(declare-fun sm@149@00 ($Snap $Ref option<array> Int) $FVF<Int>)
(declare-fun $k@154@00 () $Perm)
(declare-fun $k@163@00 () $Perm)
(declare-fun $k@170@00 () $Perm)
(declare-fun inv@155@00 ($Snap $Ref option<array> Int $Ref) Int)
(declare-fun inv@164@00 ($Snap $Ref option<array> Int $Ref) Int)
(declare-fun inv@165@00 ($Snap $Ref option<array> Int $Ref) Int)
(declare-fun inv@171@00 ($Snap $Ref option<array> Int Int $Ref) Int)
(declare-fun sm@156@00 ($Snap $Ref option<array> Int) $FVF<option<array>>)
(declare-fun sm@173@00 ($Snap $Ref option<array> Int) $FVF<Int>)
(declare-fun $k@177@00 () $Perm)
(declare-fun $k@186@00 () $Perm)
(declare-fun inv@178@00 ($Snap $Ref option<array> Int Int Int $Ref) Int)
(declare-fun inv@187@00 ($Snap $Ref option<array> Int Int Int $Ref) Int)
(declare-fun inv@188@00 ($Snap $Ref option<array> Int Int Int $Ref) Int)
(declare-fun sm@179@00 ($Snap $Ref option<array> Int Int Int) $FVF<option<array>>)
(declare-fun $k@191@00 () $Perm)
(declare-fun $k@209@00 () $Perm)
(declare-fun inv@192@00 ($Snap $Ref option<array> Int Int Int $Ref) Int)
(declare-fun inv@212@00 ($Snap $Ref option<array> Int Int Int $Ref) Int)
(declare-fun inv@213@00 ($Snap $Ref option<array> Int Int Int $Ref) Int)
(declare-fun sm@194@00 ($Snap $Ref option<array> Int Int Int) $FVF<option<array>>)
(declare-fun sm@196@00 ($Snap $Ref option<array> Int Int Int) $FVF<option<array>>)
(declare-fun sm@199@00 ($Snap $Ref option<array> Int Int Int) $FVF<option<array>>)
(declare-fun sm@203@00 ($Snap $Ref option<array> Int Int Int) $FVF<option<array>>)
(declare-fun sm@205@00 ($Snap $Ref option<array> Int Int Int) $FVF<option<array>>)
(declare-fun sm@210@00 ($Snap $Ref option<array> Int Int Int) $FVF<option<array>>)
(declare-fun sm@215@00 ($Snap $Ref option<array> Int Int Int) $FVF<Int>)
(define-fun pTaken@172@00 ((r $Ref) (s@$ $Snap) (this@88@00 $Ref) (a2@89@00 option<array>) (V@90@00 Int) (i1@168@00 Int)) $Perm
  (ite
    (and
      (<
        (inv@171@00 s@$ this@88@00 a2@89@00 V@90@00 i1@168@00 r)
        (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@156@00 s@$ this@88@00 a2@89@00 V@90@00) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1@168@00)))))
      (<= 0 (inv@171@00 s@$ this@88@00 a2@89@00 V@90@00 i1@168@00 r)))
    ($Perm.min
      (ite
        (and
          (and
            (and
              (< (inv@165@00 s@$ this@88@00 a2@89@00 V@90@00 r) V@90@00)
              (<= 0 (inv@165@00 s@$ this@88@00 a2@89@00 V@90@00 r)))
            (< (inv@164@00 s@$ this@88@00 a2@89@00 V@90@00 r) V@90@00))
          (<= 0 (inv@164@00 s@$ this@88@00 a2@89@00 V@90@00 r)))
        $k@163@00
        $Perm.No)
      $k@170@00)
    $Perm.No))
(define-fun pTaken@193@00 ((r $Ref) (s@$ $Snap) (this@102@00 $Ref) (G@103@00 option<array>) (V@104@00 Int) (s@105@00 Int) (t@106@00 Int)) $Perm
  (ite
    (and
      (<
        (inv@192@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
        V@104@00)
      (<= 0 (inv@192@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
    ($Perm.min
      (ite
        (and
          (<
            (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
            V@104@00)
          (<=
            0
            (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
        $k@177@00
        $Perm.No)
      $k@191@00)
    $Perm.No))
(define-fun pTaken@214@00 ((r $Ref) (s@$ $Snap) (this@102@00 $Ref) (G@103@00 option<array>) (V@104@00 Int) (s@105@00 Int) (t@106@00 Int)) $Perm
  (ite
    (and
      (and
        (and
          (<
            (inv@213@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
            V@104@00)
          (<=
            0
            (inv@213@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
        (<
          (inv@212@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00))
      (<= 0 (inv@212@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
    ($Perm.min
      (ite
        (and
          (and
            (and
              (<
                (inv@188@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                V@104@00)
              (<=
                0
                (inv@188@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
            (<
              (inv@187@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
              V@104@00))
          (<=
            0
            (inv@187@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
        $k@186@00
        $Perm.No)
      $k@209@00)
    $Perm.No))
(declare-fun $unresolved@115@00 () $Snap)
(assert (forall ((s@$ $Snap) (this@0@00 $Ref) (G@1@00 Seq<Seq<Int>>) (V@2@00 Int)) (!
  (=
    (SquareIntMatrix%limited s@$ this@0@00 G@1@00 V@2@00)
    (SquareIntMatrix s@$ this@0@00 G@1@00 V@2@00))
  :pattern ((SquareIntMatrix s@$ this@0@00 G@1@00 V@2@00))
  )))
(assert (forall ((s@$ $Snap) (this@0@00 $Ref) (G@1@00 Seq<Seq<Int>>) (V@2@00 Int)) (!
  (SquareIntMatrix%stateless this@0@00 G@1@00 V@2@00)
  :pattern ((SquareIntMatrix%limited s@$ this@0@00 G@1@00 V@2@00))
  )))
(assert (forall ((s@$ $Snap) (this@0@00 $Ref) (G@1@00 Seq<Seq<Int>>) (V@2@00 Int)) (!
  (implies
    (not (= this@0@00 $Ref.null))
    (=
      (SquareIntMatrix s@$ this@0@00 G@1@00 V@2@00)
      (and
        (= (Seq_length G@1@00) V@2@00)
        (forall ((e Seq<Int>)) (!
          (implies (Seq_contains G@1@00 e) (= (Seq_length e) V@2@00))
          :pattern ((Seq_contains G@1@00 e))
          :pattern ((Seq_length e))
          )))))
  :pattern ((SquareIntMatrix s@$ this@0@00 G@1@00 V@2@00))
  )))
(assert (forall ((s@$ $Snap) (this@4@00 $Ref) (G@5@00 Seq<Seq<Int>>) (V@6@00 Int)) (!
  (=
    (NonNegativeCapacities%limited s@$ this@4@00 G@5@00 V@6@00)
    (NonNegativeCapacities s@$ this@4@00 G@5@00 V@6@00))
  :pattern ((NonNegativeCapacities s@$ this@4@00 G@5@00 V@6@00))
  )))
(assert (forall ((s@$ $Snap) (this@4@00 $Ref) (G@5@00 Seq<Seq<Int>>) (V@6@00 Int)) (!
  (NonNegativeCapacities%stateless this@4@00 G@5@00 V@6@00)
  :pattern ((NonNegativeCapacities%limited s@$ this@4@00 G@5@00 V@6@00))
  )))
(assert (forall ((s@$ $Snap) (this@4@00 $Ref) (G@5@00 Seq<Seq<Int>>) (V@6@00 Int)) (!
  (implies
    (and
      (not (= this@4@00 $Ref.null))
      (SquareIntMatrix $Snap.unit this@4@00 G@5@00 V@6@00))
    (=
      (NonNegativeCapacities s@$ this@4@00 G@5@00 V@6@00)
      (forall ((i1 Int)) (!
        (implies
          (and (<= 0 i1) (< i1 V@6@00))
          (forall ((j Int)) (!
            (implies
              (and (<= 0 j) (< j V@6@00))
              (< 0 (Seq_index (Seq_index G@5@00 i1) j)))
            :pattern ((Seq_index (Seq_index G@5@00 i1) j))
            )))
        :pattern ((Seq_index G@5@00 i1))
        ))))
  :pattern ((NonNegativeCapacities s@$ this@4@00 G@5@00 V@6@00))
  )))
(assert (forall ((s@$ $Snap) (this@8@00 $Ref) (G@9@00 Seq<Seq<Int>>) (V@10@00 Int) (s@11@00 Int) (t@12@00 Int)) (!
  (=
    (FlowNetwork%limited s@$ this@8@00 G@9@00 V@10@00 s@11@00 t@12@00)
    (FlowNetwork s@$ this@8@00 G@9@00 V@10@00 s@11@00 t@12@00))
  :pattern ((FlowNetwork s@$ this@8@00 G@9@00 V@10@00 s@11@00 t@12@00))
  )))
(assert (forall ((s@$ $Snap) (this@8@00 $Ref) (G@9@00 Seq<Seq<Int>>) (V@10@00 Int) (s@11@00 Int) (t@12@00 Int)) (!
  (FlowNetwork%stateless this@8@00 G@9@00 V@10@00 s@11@00 t@12@00)
  :pattern ((FlowNetwork%limited s@$ this@8@00 G@9@00 V@10@00 s@11@00 t@12@00))
  )))
(assert (forall ((s@$ $Snap) (this@8@00 $Ref) (G@9@00 Seq<Seq<Int>>) (V@10@00 Int) (s@11@00 Int) (t@12@00 Int)) (!
  (implies
    (not (= this@8@00 $Ref.null))
    (=
      (FlowNetwork s@$ this@8@00 G@9@00 V@10@00 s@11@00 t@12@00)
      (and
        (and
          (and
            (and (and (<= 0 s@11@00) (< s@11@00 V@10@00)) (<= 0 t@12@00))
            (< t@12@00 V@10@00))
          (SquareIntMatrix $Snap.unit this@8@00 G@9@00 V@10@00))
        (NonNegativeCapacities ($Snap.combine $Snap.unit $Snap.unit) this@8@00 G@9@00 V@10@00))))
  :pattern ((FlowNetwork s@$ this@8@00 G@9@00 V@10@00 s@11@00 t@12@00))
  )))
(assert (forall ((s@$ $Snap) (this@14@00 $Ref) (G@15@00 Seq<Seq<Int>>) (n@16@00 Int) (v@17@00 Int) (V@18@00 Int)) (!
  (=
    (SumOutgoingFlow%limited s@$ this@14@00 G@15@00 n@16@00 v@17@00 V@18@00)
    (SumOutgoingFlow s@$ this@14@00 G@15@00 n@16@00 v@17@00 V@18@00))
  :pattern ((SumOutgoingFlow s@$ this@14@00 G@15@00 n@16@00 v@17@00 V@18@00))
  )))
(assert (forall ((s@$ $Snap) (this@14@00 $Ref) (G@15@00 Seq<Seq<Int>>) (n@16@00 Int) (v@17@00 Int) (V@18@00 Int)) (!
  (SumOutgoingFlow%stateless this@14@00 G@15@00 n@16@00 v@17@00 V@18@00)
  :pattern ((SumOutgoingFlow%limited s@$ this@14@00 G@15@00 n@16@00 v@17@00 V@18@00))
  )))
(assert (forall ((s@$ $Snap) (this@14@00 $Ref) (G@15@00 Seq<Seq<Int>>) (n@16@00 Int) (v@17@00 Int) (V@18@00 Int)) (!
  (implies
    (and
      (not (= this@14@00 $Ref.null))
      (FlowNetwork $Snap.unit this@14@00 G@15@00 V@18@00 n@16@00 v@17@00))
    (=
      (SumOutgoingFlow s@$ this@14@00 G@15@00 n@16@00 v@17@00 V@18@00)
      (ite
        (< 0 n@16@00)
        (+
          (Seq_index (Seq_index G@15@00 v@17@00) n@16@00)
          (SumOutgoingFlow%limited ($Snap.combine $Snap.unit $Snap.unit) this@14@00 G@15@00 (-
            n@16@00
            1) v@17@00 V@18@00))
        0)))
  :pattern ((SumOutgoingFlow s@$ this@14@00 G@15@00 n@16@00 v@17@00 V@18@00))
  )))
(assert (forall ((s@$ $Snap) (this@20@00 $Ref) (G@21@00 Seq<Seq<Int>>) (n@22@00 Int) (v@23@00 Int) (V@24@00 Int)) (!
  (=
    (SumIncomingFlow%limited s@$ this@20@00 G@21@00 n@22@00 v@23@00 V@24@00)
    (SumIncomingFlow s@$ this@20@00 G@21@00 n@22@00 v@23@00 V@24@00))
  :pattern ((SumIncomingFlow s@$ this@20@00 G@21@00 n@22@00 v@23@00 V@24@00))
  )))
(assert (forall ((s@$ $Snap) (this@20@00 $Ref) (G@21@00 Seq<Seq<Int>>) (n@22@00 Int) (v@23@00 Int) (V@24@00 Int)) (!
  (SumIncomingFlow%stateless this@20@00 G@21@00 n@22@00 v@23@00 V@24@00)
  :pattern ((SumIncomingFlow%limited s@$ this@20@00 G@21@00 n@22@00 v@23@00 V@24@00))
  )))
(assert (forall ((s@$ $Snap) (this@20@00 $Ref) (G@21@00 Seq<Seq<Int>>) (n@22@00 Int) (v@23@00 Int) (V@24@00 Int)) (!
  (implies
    (and
      (not (= this@20@00 $Ref.null))
      (FlowNetwork $Snap.unit this@20@00 G@21@00 V@24@00 n@22@00 v@23@00))
    (=
      (SumIncomingFlow s@$ this@20@00 G@21@00 n@22@00 v@23@00 V@24@00)
      (ite
        (< 0 n@22@00)
        (+
          (Seq_index (Seq_index G@21@00 n@22@00) v@23@00)
          (SumIncomingFlow%limited ($Snap.combine $Snap.unit $Snap.unit) this@20@00 G@21@00 (-
            n@22@00
            1) v@23@00 V@24@00))
        0)))
  :pattern ((SumIncomingFlow s@$ this@20@00 G@21@00 n@22@00 v@23@00 V@24@00))
  )))
(assert (forall ((s@$ $Snap) (this@26@00 $Ref) (G@27@00 Seq<Seq<Int>>) (Gf@28@00 Seq<Seq<Int>>) (V@29@00 Int)) (!
  (=
    (CapacityConstraint%limited s@$ this@26@00 G@27@00 Gf@28@00 V@29@00)
    (CapacityConstraint s@$ this@26@00 G@27@00 Gf@28@00 V@29@00))
  :pattern ((CapacityConstraint s@$ this@26@00 G@27@00 Gf@28@00 V@29@00))
  )))
(assert (forall ((s@$ $Snap) (this@26@00 $Ref) (G@27@00 Seq<Seq<Int>>) (Gf@28@00 Seq<Seq<Int>>) (V@29@00 Int)) (!
  (CapacityConstraint%stateless this@26@00 G@27@00 Gf@28@00 V@29@00)
  :pattern ((CapacityConstraint%limited s@$ this@26@00 G@27@00 Gf@28@00 V@29@00))
  )))
(assert (forall ((s@$ $Snap) (this@26@00 $Ref) (G@27@00 Seq<Seq<Int>>) (Gf@28@00 Seq<Seq<Int>>) (V@29@00 Int)) (!
  (implies
    (and
      (not (= this@26@00 $Ref.null))
      (SquareIntMatrix $Snap.unit this@26@00 G@27@00 V@29@00)
      (SquareIntMatrix $Snap.unit this@26@00 Gf@28@00 V@29@00))
    (=
      (CapacityConstraint s@$ this@26@00 G@27@00 Gf@28@00 V@29@00)
      (forall ((i1 Int)) (!
        (implies
          (and (<= 0 i1) (< i1 V@29@00))
          (forall ((j Int)) (!
            (implies
              (and (<= 0 j) (< j V@29@00))
              (<=
                (Seq_index (Seq_index Gf@28@00 i1) j)
                (Seq_index (Seq_index G@27@00 i1) j)))
            :pattern ((Seq_index (Seq_index Gf@28@00 i1) j))
            :pattern ((Seq_index (Seq_index G@27@00 i1) j))
            )))
        :pattern ((Seq_index Gf@28@00 i1))
        :pattern ((Seq_index G@27@00 i1))
        ))))
  :pattern ((CapacityConstraint s@$ this@26@00 G@27@00 Gf@28@00 V@29@00))
  )))
(assert (forall ((s@$ $Snap) (this@31@00 $Ref) (G@32@00 Seq<Seq<Int>>) (V@33@00 Int) (s@34@00 Int) (t@35@00 Int)) (!
  (=
    (FlowConservation%limited s@$ this@31@00 G@32@00 V@33@00 s@34@00 t@35@00)
    (FlowConservation s@$ this@31@00 G@32@00 V@33@00 s@34@00 t@35@00))
  :pattern ((FlowConservation s@$ this@31@00 G@32@00 V@33@00 s@34@00 t@35@00))
  )))
(assert (forall ((s@$ $Snap) (this@31@00 $Ref) (G@32@00 Seq<Seq<Int>>) (V@33@00 Int) (s@34@00 Int) (t@35@00 Int)) (!
  (FlowConservation%stateless this@31@00 G@32@00 V@33@00 s@34@00 t@35@00)
  :pattern ((FlowConservation%limited s@$ this@31@00 G@32@00 V@33@00 s@34@00 t@35@00))
  )))
(assert (forall ((s@$ $Snap) (this@31@00 $Ref) (G@32@00 Seq<Seq<Int>>) (V@33@00 Int) (s@34@00 Int) (t@35@00 Int)) (!
  (implies
    (and
      (not (= this@31@00 $Ref.null))
      (FlowNetwork $Snap.unit this@31@00 G@32@00 V@33@00 s@34@00 t@35@00))
    (=
      (FlowConservation s@$ this@31@00 G@32@00 V@33@00 s@34@00 t@35@00)
      (and
        (and
          (<=
            (SumIncomingFlow ($Snap.combine $Snap.unit $Snap.unit) this@31@00 G@32@00 (-
              V@33@00
              1) s@34@00 V@33@00)
            (SumOutgoingFlow ($Snap.combine $Snap.unit $Snap.unit) this@31@00 G@32@00 (-
              V@33@00
              1) s@34@00 V@33@00))
          (<=
            (SumOutgoingFlow ($Snap.combine $Snap.unit $Snap.unit) this@31@00 G@32@00 (-
              V@33@00
              1) t@35@00 V@33@00)
            (SumIncomingFlow ($Snap.combine $Snap.unit $Snap.unit) this@31@00 G@32@00 (-
              V@33@00
              1) t@35@00 V@33@00)))
        (forall ((v Int) (fresh__1 Int)) (!
          (implies
            (and
              (and (and (<= 0 v) (< v V@33@00)) (not (= v s@34@00)))
              (not (= v t@35@00)))
            (=
              (SumIncomingFlow ($Snap.combine $Snap.unit $Snap.unit) this@31@00 G@32@00 (-
                V@33@00
                1) v V@33@00)
              (SumOutgoingFlow ($Snap.combine $Snap.unit $Snap.unit) this@31@00 G@32@00 (-
                V@33@00
                1) v V@33@00)))
          :pattern ((SumOutgoingFlow%limited $unresolved@115@00 this@31@00 G@32@00 fresh__1 v V@33@00))
          )))))
  :pattern ((FlowConservation s@$ this@31@00 G@32@00 V@33@00 s@34@00 t@35@00))
  )))
(assert (forall ((s@$ $Snap) (a2@37@00 array) (i1@38@00 Int)) (!
  (= (aloc%limited s@$ a2@37@00 i1@38@00) (aloc s@$ a2@37@00 i1@38@00))
  :pattern ((aloc s@$ a2@37@00 i1@38@00))
  )))
(assert (forall ((s@$ $Snap) (a2@37@00 array) (i1@38@00 Int)) (!
  (aloc%stateless a2@37@00 i1@38@00)
  :pattern ((aloc%limited s@$ a2@37@00 i1@38@00))
  )))
(assert (forall ((s@$ $Snap) (a2@37@00 array) (i1@38@00 Int)) (!
  (let ((result@39@00 (aloc%limited s@$ a2@37@00 i1@38@00))) (implies
    (and (<= 0 i1@38@00) (< i1@38@00 (alen<Int> a2@37@00)))
    (and
      (= (loc_inv_1<array> result@39@00) a2@37@00)
      (= (loc_inv_2<Int> result@39@00) i1@38@00))))
  :pattern ((aloc%limited s@$ a2@37@00 i1@38@00))
  )))
(assert (forall ((s@$ $Snap) (a2@37@00 array) (i1@38@00 Int)) (!
  (implies
    (and (<= 0 i1@38@00) (< i1@38@00 (alen<Int> a2@37@00)))
    (= (aloc s@$ a2@37@00 i1@38@00) (array_loc<Ref> a2@37@00 i1@38@00)))
  :pattern ((aloc s@$ a2@37@00 i1@38@00))
  )))
(assert (forall ((s@$ $Snap) (opt1@40@00 option<array>)) (!
  (= (opt_get1%limited s@$ opt1@40@00) (opt_get1 s@$ opt1@40@00))
  :pattern ((opt_get1 s@$ opt1@40@00))
  )))
(assert (forall ((s@$ $Snap) (opt1@40@00 option<array>)) (!
  (opt_get1%stateless opt1@40@00)
  :pattern ((opt_get1%limited s@$ opt1@40@00))
  )))
(assert (forall ((s@$ $Snap) (opt1@40@00 option<array>)) (!
  (let ((result@41@00 (opt_get1%limited s@$ opt1@40@00))) (implies
    (not (= opt1@40@00 (as None<option<array>>  option<array>)))
    (= (some<option<array>> result@41@00) opt1@40@00)))
  :pattern ((opt_get1%limited s@$ opt1@40@00))
  )))
(assert (forall ((s@$ $Snap) (opt1@40@00 option<array>)) (!
  (implies
    (not (= opt1@40@00 (as None<option<array>>  option<array>)))
    (= (opt_get1 s@$ opt1@40@00) (option_get<array> opt1@40@00)))
  :pattern ((opt_get1 s@$ opt1@40@00))
  )))
(assert (forall ((s@$ $Snap) (this@42@00 $Ref) (p@43@00 Seq<Int>) (V@44@00 Int)) (!
  (=
    (valid_graph_vertices1%limited s@$ this@42@00 p@43@00 V@44@00)
    (valid_graph_vertices1 s@$ this@42@00 p@43@00 V@44@00))
  :pattern ((valid_graph_vertices1 s@$ this@42@00 p@43@00 V@44@00))
  )))
(assert (forall ((s@$ $Snap) (this@42@00 $Ref) (p@43@00 Seq<Int>) (V@44@00 Int)) (!
  (valid_graph_vertices1%stateless this@42@00 p@43@00 V@44@00)
  :pattern ((valid_graph_vertices1%limited s@$ this@42@00 p@43@00 V@44@00))
  )))
(assert (forall ((s@$ $Snap) (this@42@00 $Ref) (p@43@00 Seq<Int>) (V@44@00 Int)) (!
  (implies
    (not (= this@42@00 $Ref.null))
    (=
      (valid_graph_vertices1 s@$ this@42@00 p@43@00 V@44@00)
      (and
        (forall ((unknown1 Int)) (!
          (implies
            (and (<= 0 unknown1) (< unknown1 (Seq_length p@43@00)))
            (<= 0 (Seq_index p@43@00 unknown1)))
          :pattern ((Seq_index p@43@00 unknown1))
          ))
        (forall ((unknown1 Int)) (!
          (implies
            (and (<= 0 unknown1) (< unknown1 (Seq_length p@43@00)))
            (< (Seq_index p@43@00 unknown1) V@44@00))
          :pattern ((Seq_index p@43@00 unknown1))
          )))))
  :pattern ((valid_graph_vertices1 s@$ this@42@00 p@43@00 V@44@00))
  )))
(assert (forall ((s@$ $Snap) (this@46@00 $Ref) (G@47@00 Seq<Seq<Int>>) (Gf@48@00 Seq<Seq<Int>>) (V@49@00 Int) (s@50@00 Int) (t@51@00 Int)) (!
  (=
    (ValidFlow%limited s@$ this@46@00 G@47@00 Gf@48@00 V@49@00 s@50@00 t@51@00)
    (ValidFlow s@$ this@46@00 G@47@00 Gf@48@00 V@49@00 s@50@00 t@51@00))
  :pattern ((ValidFlow s@$ this@46@00 G@47@00 Gf@48@00 V@49@00 s@50@00 t@51@00))
  )))
(assert (forall ((s@$ $Snap) (this@46@00 $Ref) (G@47@00 Seq<Seq<Int>>) (Gf@48@00 Seq<Seq<Int>>) (V@49@00 Int) (s@50@00 Int) (t@51@00 Int)) (!
  (ValidFlow%stateless this@46@00 G@47@00 Gf@48@00 V@49@00 s@50@00 t@51@00)
  :pattern ((ValidFlow%limited s@$ this@46@00 G@47@00 Gf@48@00 V@49@00 s@50@00 t@51@00))
  )))
(assert (forall ((s@$ $Snap) (this@46@00 $Ref) (G@47@00 Seq<Seq<Int>>) (Gf@48@00 Seq<Seq<Int>>) (V@49@00 Int) (s@50@00 Int) (t@51@00 Int)) (!
  (implies
    (and
      (not (= this@46@00 $Ref.null))
      (SquareIntMatrix $Snap.unit this@46@00 Gf@48@00 V@49@00)
      (FlowNetwork $Snap.unit this@46@00 G@47@00 V@49@00 s@50@00 t@51@00)
      (FlowNetwork $Snap.unit this@46@00 Gf@48@00 V@49@00 s@50@00 t@51@00))
    (=
      (ValidFlow s@$ this@46@00 G@47@00 Gf@48@00 V@49@00 s@50@00 t@51@00)
      (and
        (FlowConservation ($Snap.combine $Snap.unit $Snap.unit) this@46@00 G@47@00 V@49@00 s@50@00 t@51@00)
        (CapacityConstraint ($Snap.combine
          $Snap.unit
          ($Snap.combine $Snap.unit $Snap.unit)) this@46@00 G@47@00 Gf@48@00 V@49@00))))
  :pattern ((ValidFlow s@$ this@46@00 G@47@00 Gf@48@00 V@49@00 s@50@00 t@51@00))
  )))
(assert (forall ((s@$ $Snap) (this@53@00 $Ref) (G@54@00 option<array>) (V@55@00 Int)) (!
  (=
    (SquareIntMatrix1%limited s@$ this@53@00 G@54@00 V@55@00)
    (SquareIntMatrix1 s@$ this@53@00 G@54@00 V@55@00))
  :pattern ((SquareIntMatrix1 s@$ this@53@00 G@54@00 V@55@00))
  )))
(assert (forall ((s@$ $Snap) (this@53@00 $Ref) (G@54@00 option<array>) (V@55@00 Int)) (!
  (SquareIntMatrix1%stateless this@53@00 G@54@00 V@55@00)
  :pattern ((SquareIntMatrix1%limited s@$ this@53@00 G@54@00 V@55@00))
  )))
(assert (forall ((s@$ $Snap) (this@53@00 $Ref) (G@54@00 option<array>) (V@55@00 Int)) (!
  (and
    (forall ((i1@120@00 Int)) (!
      (implies
        (and (and (< i1@120@00 V@55@00) (<= 0 i1@120@00)) (< $Perm.No $k@121@00))
        (=
          (inv@122@00 s@$ this@53@00 G@54@00 V@55@00 (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@54@00) i1@120@00))
          i1@120@00))
      :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@54@00) i1@120@00))
      ))
    (forall ((r $Ref)) (!
      (implies
        (and
          (and
            (< (inv@122@00 s@$ this@53@00 G@54@00 V@55@00 r) V@55@00)
            (<= 0 (inv@122@00 s@$ this@53@00 G@54@00 V@55@00 r)))
          (< $Perm.No $k@121@00))
        (=
          (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@54@00) (inv@122@00 s@$ this@53@00 G@54@00 V@55@00 r))
          r))
      :pattern ((inv@122@00 s@$ this@53@00 G@54@00 V@55@00 r))
      :qid |option$array$-fctOfInv|))
    (forall ((i1@128@00 Int) (j@129@00 Int)) (!
      (implies
        (and
          (and
            (and
              (and (< j@129@00 V@55@00) (<= 0 j@129@00))
              (< i1@128@00 V@55@00))
            (<= 0 i1@128@00))
          (< $Perm.No $k@130@00))
        (and
          (=
            (inv@131@00 s@$ this@53@00 G@54@00 V@55@00 (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@123@00 s@$ this@53@00 G@54@00 V@55@00) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@54@00) i1@128@00))) j@129@00))
            i1@128@00)
          (=
            (inv@132@00 s@$ this@53@00 G@54@00 V@55@00 (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@123@00 s@$ this@53@00 G@54@00 V@55@00) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@54@00) i1@128@00))) j@129@00))
            j@129@00)))
      :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@123@00 s@$ this@53@00 G@54@00 V@55@00) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@54@00) i1@128@00))) j@129@00))
      ))
    (forall ((r $Ref)) (!
      (implies
        (and
          (and
            (and
              (and
                (< (inv@132@00 s@$ this@53@00 G@54@00 V@55@00 r) V@55@00)
                (<= 0 (inv@132@00 s@$ this@53@00 G@54@00 V@55@00 r)))
              (< (inv@131@00 s@$ this@53@00 G@54@00 V@55@00 r) V@55@00))
            (<= 0 (inv@131@00 s@$ this@53@00 G@54@00 V@55@00 r)))
          (< $Perm.No $k@130@00))
        (=
          (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@123@00 s@$ this@53@00 G@54@00 V@55@00) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@54@00) (inv@131@00 s@$ this@53@00 G@54@00 V@55@00 r)))) (inv@132@00 s@$ this@53@00 G@54@00 V@55@00 r))
          r))
      :pattern ((inv@131@00 s@$ this@53@00 G@54@00 V@55@00 r))
      :pattern ((inv@132@00 s@$ this@53@00 G@54@00 V@55@00 r))
      :qid |int-fctOfInv|))
    (forall ((r $Ref)) (!
      (implies
        (ite
          (and
            (< (inv@122@00 s@$ this@53@00 G@54@00 V@55@00 r) V@55@00)
            (<= 0 (inv@122@00 s@$ this@53@00 G@54@00 V@55@00 r)))
          (< $Perm.No $k@121@00)
          false)
        (=
          ($FVF.lookup_option$array$ (sm@123@00 s@$ this@53@00 G@54@00 V@55@00) r)
          ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r)))
      :pattern (($FVF.lookup_option$array$ (sm@123@00 s@$ this@53@00 G@54@00 V@55@00) r))
      :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r))
      :qid |qp.fvfValDef0|))
    (forall ((r $Ref)) (!
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r)
      :pattern (($FVF.lookup_option$array$ (sm@123@00 s@$ this@53@00 G@54@00 V@55@00) r))
      :qid |qp.fvfResTrgDef1|))
    ($Perm.isReadVar $k@121@00 $Perm.Write)
    ($Perm.isReadVar $k@130@00 $Perm.Write)
    (implies
      (and
        (not (= this@53@00 $Ref.null))
        (not (= G@54@00 (as None<option<array>>  option<array>)))
        (= (alen<Int> (opt_get1 $Snap.unit G@54@00)) V@55@00)
        (forall ((i1 Int)) (!
          (implies
            (and (<= 0 i1) (< i1 V@55@00))
            (not
              (=
                ($FVF.lookup_option$array$ (sm@123@00 s@$ this@53@00 G@54@00 V@55@00) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@54@00) i1))
                (as None<option<array>>  option<array>))))
          :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@54@00) i1))
          ))
        (forall ((i1 Int)) (!
          (implies
            (and (<= 0 i1) (< i1 V@55@00))
            (=
              (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@123@00 s@$ this@53@00 G@54@00 V@55@00) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit G@54@00) i1))))
              V@55@00))
          :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@123@00 s@$ this@53@00 G@54@00 V@55@00) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@54@00) i1)))))
          ))
        (forall ((i1 Int)) (!
          (forall ((i2 Int)) (!
            (implies
              (and
                (and
                  (and (and (<= 0 i1) (< i1 V@55@00)) (<= 0 i2))
                  (< i2 V@55@00))
                (=
                  ($FVF.lookup_option$array$ (sm@123@00 s@$ this@53@00 G@54@00 V@55@00) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit G@54@00) i1))
                  ($FVF.lookup_option$array$ (sm@123@00 s@$ this@53@00 G@54@00 V@55@00) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit G@54@00) i2))))
              (= i1 i2))
            :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@54@00) i2))
            ))
          :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@54@00) i1))
          )))
      (=
        (SquareIntMatrix1 s@$ this@53@00 G@54@00 V@55@00)
        (and
          (= (alen<Int> (opt_get1 $Snap.unit G@54@00)) V@55@00)
          (forall ((i1 Int)) (!
            (implies
              (and (<= 0 i1) (< i1 V@55@00))
              (=
                (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@123@00 s@$ this@53@00 G@54@00 V@55@00) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@54@00) i1))))
                V@55@00))
            :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@123@00 s@$ this@53@00 G@54@00 V@55@00) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@54@00) i1)))))
            ))))))
  :pattern ((SquareIntMatrix1 s@$ this@53@00 G@54@00 V@55@00))
  )))
(assert (forall ((s@$ $Snap) (t@57@00 any)) (!
  (= (any_as%limited s@$ t@57@00) (any_as s@$ t@57@00))
  :pattern ((any_as s@$ t@57@00))
  )))
(assert (forall ((s@$ $Snap) (t@57@00 any)) (!
  (any_as%stateless t@57@00)
  :pattern ((any_as%limited s@$ t@57@00))
  )))
(assert (forall ((s@$ $Snap) (a2@59@00 option<array>) (from@60@00 Int) (to@61@00 Int)) (!
  (Seq_equal
    (unknown%limited s@$ a2@59@00 from@60@00 to@61@00)
    (unknown_ s@$ a2@59@00 from@60@00 to@61@00))
  :pattern ((unknown_ s@$ a2@59@00 from@60@00 to@61@00))
  )))
(assert (forall ((s@$ $Snap) (a2@59@00 option<array>) (from@60@00 Int) (to@61@00 Int)) (!
  (unknown%stateless a2@59@00 from@60@00 to@61@00)
  :pattern ((unknown%limited s@$ a2@59@00 from@60@00 to@61@00))
  )))
(assert (forall ((s@$ $Snap) (a2@59@00 option<array>) (from@60@00 Int) (to@61@00 Int)) (!
  (let ((result@62@00 (unknown%limited s@$ a2@59@00 from@60@00 to@61@00))) (and
    (forall ((i1@135@00 Int)) (!
      (implies
        (and
          (and (< i1@135@00 to@61@00) (<= from@60@00 i1@135@00))
          (< $Perm.No $k@136@00))
        (=
          (inv@138@00 s@$ a2@59@00 from@60@00 to@61@00 (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit a2@59@00) i1@135@00))
          i1@135@00))
      :pattern (($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$))))) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit a2@59@00) i1@135@00)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit a2@59@00) i1@135@00)))
      ))
    (forall ((r $Ref)) (!
      (implies
        (and
          (and
            (< (inv@138@00 s@$ a2@59@00 from@60@00 to@61@00 r) to@61@00)
            (<= from@60@00 (inv@138@00 s@$ a2@59@00 from@60@00 to@61@00 r)))
          (< $Perm.No $k@136@00))
        (=
          (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit a2@59@00) (inv@138@00 s@$ a2@59@00 from@60@00 to@61@00 r))
          r))
      :pattern ((inv@138@00 s@$ a2@59@00 from@60@00 to@61@00 r))
      :qid |int-fctOfInv|))
    (forall ((r $Ref)) (!
      (implies
        (ite
          (and
            (< (inv@138@00 s@$ a2@59@00 from@60@00 to@61@00 r) to@61@00)
            (<= from@60@00 (inv@138@00 s@$ a2@59@00 from@60@00 to@61@00 r)))
          (< $Perm.No $k@136@00)
          false)
        (=
          ($FVF.lookup_int (sm@139@00 s@$ a2@59@00 from@60@00 to@61@00) r)
          ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$))))) r)))
      :pattern (($FVF.lookup_int (sm@139@00 s@$ a2@59@00 from@60@00 to@61@00) r))
      :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$))))) r))
      :qid |qp.fvfValDef5|))
    (forall ((r $Ref)) (!
      ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r)
      :pattern (($FVF.lookup_int (sm@139@00 s@$ a2@59@00 from@60@00 to@61@00) r))
      :qid |qp.fvfResTrgDef6|))
    ($Perm.isReadVar $k@136@00 $Perm.Write)
    (implies
      (and
        (not (= a2@59@00 (as None<option<array>>  option<array>)))
        (<= 0 from@60@00)
        (<= from@60@00 to@61@00)
        (<= to@61@00 (alen<Int> (opt_get1 $Snap.unit a2@59@00))))
      (and
        (= (Seq_length result@62@00) (- to@61@00 from@60@00))
        (forall ((i1 Int)) (!
          (implies
            (and (<= 0 i1) (< i1 (- to@61@00 from@60@00)))
            (=
              (Seq_index result@62@00 i1)
              ($FVF.lookup_int (sm@139@00 s@$ a2@59@00 from@60@00 to@61@00) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit a2@59@00) (+ i1 from@60@00)))))
          :pattern ((Seq_index result@62@00 i1))
          ))
        (forall ((i1 Int)) (!
          (implies
            (and (<= from@60@00 i1) (< i1 to@61@00))
            (=
              ($FVF.lookup_int (sm@139@00 s@$ a2@59@00 from@60@00 to@61@00) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit a2@59@00) i1))
              (Seq_index result@62@00 (- i1 from@60@00))))
          :pattern (($FVF.lookup_int (sm@139@00 s@$ a2@59@00 from@60@00 to@61@00) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit a2@59@00) i1)))
          ))))))
  :pattern ((unknown%limited s@$ a2@59@00 from@60@00 to@61@00))
  )))
(assert (forall ((s@$ $Snap) (this@63@00 $Ref) (G@64@00 Seq<Seq<Int>>) (Gf@65@00 Seq<Seq<Int>>) (V@66@00 Int) (s@67@00 Int) (t@68@00 Int) (P@69@00 Seq<Int>)) (!
  (=
    (AugPath%limited s@$ this@63@00 G@64@00 Gf@65@00 V@66@00 s@67@00 t@68@00 P@69@00)
    (AugPath s@$ this@63@00 G@64@00 Gf@65@00 V@66@00 s@67@00 t@68@00 P@69@00))
  :pattern ((AugPath s@$ this@63@00 G@64@00 Gf@65@00 V@66@00 s@67@00 t@68@00 P@69@00))
  )))
(assert (forall ((s@$ $Snap) (this@63@00 $Ref) (G@64@00 Seq<Seq<Int>>) (Gf@65@00 Seq<Seq<Int>>) (V@66@00 Int) (s@67@00 Int) (t@68@00 Int) (P@69@00 Seq<Int>)) (!
  (AugPath%stateless this@63@00 G@64@00 Gf@65@00 V@66@00 s@67@00 t@68@00 P@69@00)
  :pattern ((AugPath%limited s@$ this@63@00 G@64@00 Gf@65@00 V@66@00 s@67@00 t@68@00 P@69@00))
  )))
(assert (forall ((s@$ $Snap) (this@63@00 $Ref) (G@64@00 Seq<Seq<Int>>) (Gf@65@00 Seq<Seq<Int>>) (V@66@00 Int) (s@67@00 Int) (t@68@00 Int) (P@69@00 Seq<Int>)) (!
  (implies
    (and
      (not (= this@63@00 $Ref.null))
      (SquareIntMatrix $Snap.unit this@63@00 G@64@00 V@66@00)
      (SquareIntMatrix $Snap.unit this@63@00 Gf@65@00 V@66@00)
      (FlowNetwork $Snap.unit this@63@00 G@64@00 V@66@00 s@67@00 t@68@00)
      (FlowNetwork $Snap.unit this@63@00 Gf@65@00 V@66@00 s@67@00 t@68@00)
      (ValidFlow ($Snap.combine
        $Snap.unit
        ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) this@63@00 G@64@00 Gf@65@00 V@66@00 s@67@00 t@68@00))
    (=
      (AugPath s@$ this@63@00 G@64@00 Gf@65@00 V@66@00 s@67@00 t@68@00 P@69@00)
      (and
        (and
          (implies
            (and
              (and
                (and (and (<= 0 s@67@00) (< s@67@00 V@66@00)) (<= 0 t@68@00))
                (< t@68@00 V@66@00))
              (< 1 (Seq_length P@69@00)))
            (not
              (=
                (Seq_index P@69@00 0)
                (Seq_index P@69@00 (- (Seq_length P@69@00) 1)))))
          (implies
            (and
              (and
                (and (and (<= 0 s@67@00) (< s@67@00 V@66@00)) (<= 0 t@68@00))
                (< t@68@00 V@66@00))
              (< 1 (Seq_length P@69@00)))
            (valid_graph_vertices1 $Snap.unit this@63@00 P@69@00 V@66@00)))
        (implies
          (and
            (and
              (and (and (<= 0 s@67@00) (< s@67@00 V@66@00)) (<= 0 t@68@00))
              (< t@68@00 V@66@00))
            (< 1 (Seq_length P@69@00)))
          (forall ((j Int)) (!
            (implies
              (and (<= 0 j) (< j (- (Seq_length P@69@00) 1)))
              (<
                0
                (Seq_index
                  (Seq_index Gf@65@00 (Seq_index P@69@00 j))
                  (Seq_index P@69@00 (+ j 1)))))
            :pattern ((Seq_index Gf@65@00 (Seq_index P@69@00 j)))
            ))))))
  :pattern ((AugPath s@$ this@63@00 G@64@00 Gf@65@00 V@66@00 s@67@00 t@68@00 P@69@00))
  )))
(assert (forall ((s@$ $Snap) (opt1@71@00 option<any>)) (!
  (= (opt_get%limited s@$ opt1@71@00) (opt_get s@$ opt1@71@00))
  :pattern ((opt_get s@$ opt1@71@00))
  )))
(assert (forall ((s@$ $Snap) (opt1@71@00 option<any>)) (!
  (opt_get%stateless opt1@71@00)
  :pattern ((opt_get%limited s@$ opt1@71@00))
  )))
(assert (forall ((s@$ $Snap) (opt1@71@00 option<any>)) (!
  (let ((result@72@00 (opt_get%limited s@$ opt1@71@00))) (implies
    (not (= opt1@71@00 (as None<option<any>>  option<any>)))
    (= (some<option<any>> result@72@00) opt1@71@00)))
  :pattern ((opt_get%limited s@$ opt1@71@00))
  )))
(assert (forall ((s@$ $Snap) (opt1@71@00 option<any>)) (!
  (implies
    (not (= opt1@71@00 (as None<option<any>>  option<any>)))
    (= (opt_get s@$ opt1@71@00) (option_get<any> opt1@71@00)))
  :pattern ((opt_get s@$ opt1@71@00))
  )))
(assert (forall ((s@$ $Snap) (t@77@00 any)) (!
  (= (as_any%limited s@$ t@77@00) (as_any s@$ t@77@00))
  :pattern ((as_any s@$ t@77@00))
  )))
(assert (forall ((s@$ $Snap) (t@77@00 any)) (!
  (as_any%stateless t@77@00)
  :pattern ((as_any%limited s@$ t@77@00))
  )))
(assert (forall ((s@$ $Snap) (t@77@00 any)) (!
  (let ((result@78@00 (as_any%limited s@$ t@77@00))) (=
    (any_as $Snap.unit result@78@00)
    t@77@00))
  :pattern ((as_any%limited s@$ t@77@00))
  )))
(assert (forall ((s@$ $Snap) (this@79@00 $Ref) (p@80@00 option<array>) (V@81@00 Int)) (!
  (=
    (valid_graph_vertices%limited s@$ this@79@00 p@80@00 V@81@00)
    (valid_graph_vertices s@$ this@79@00 p@80@00 V@81@00))
  :pattern ((valid_graph_vertices s@$ this@79@00 p@80@00 V@81@00))
  )))
(assert (forall ((s@$ $Snap) (this@79@00 $Ref) (p@80@00 option<array>) (V@81@00 Int)) (!
  (valid_graph_vertices%stateless this@79@00 p@80@00 V@81@00)
  :pattern ((valid_graph_vertices%limited s@$ this@79@00 p@80@00 V@81@00))
  )))
(assert (forall ((s@$ $Snap) (this@79@00 $Ref) (p@80@00 option<array>) (V@81@00 Int)) (!
  (and
    (forall ((i1@146@00 Int)) (!
      (implies
        (and (and (< i1@146@00 V@81@00) (<= 0 i1@146@00)) (< $Perm.No $k@147@00))
        (=
          (inv@148@00 s@$ this@79@00 p@80@00 V@81@00 (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit p@80@00) i1@146@00))
          i1@146@00))
      :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@80@00) i1@146@00))
      ))
    (forall ((r $Ref)) (!
      (implies
        (and
          (and
            (< (inv@148@00 s@$ this@79@00 p@80@00 V@81@00 r) V@81@00)
            (<= 0 (inv@148@00 s@$ this@79@00 p@80@00 V@81@00 r)))
          (< $Perm.No $k@147@00))
        (=
          (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@80@00) (inv@148@00 s@$ this@79@00 p@80@00 V@81@00 r))
          r))
      :pattern ((inv@148@00 s@$ this@79@00 p@80@00 V@81@00 r))
      :qid |int-fctOfInv|))
    (forall ((r $Ref)) (!
      (implies
        (ite
          (and
            (< (inv@148@00 s@$ this@79@00 p@80@00 V@81@00 r) V@81@00)
            (<= 0 (inv@148@00 s@$ this@79@00 p@80@00 V@81@00 r)))
          (< $Perm.No $k@147@00)
          false)
        (=
          ($FVF.lookup_int (sm@149@00 s@$ this@79@00 p@80@00 V@81@00) r)
          ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second s@$)))) r)))
      :pattern (($FVF.lookup_int (sm@149@00 s@$ this@79@00 p@80@00 V@81@00) r))
      :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second s@$)))) r))
      :qid |qp.fvfValDef7|))
    (forall ((r $Ref)) (!
      ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second s@$)))) r) r)
      :pattern (($FVF.lookup_int (sm@149@00 s@$ this@79@00 p@80@00 V@81@00) r))
      :qid |qp.fvfResTrgDef8|))
    ($Perm.isReadVar $k@147@00 $Perm.Write)
    (implies
      (and
        (not (= this@79@00 $Ref.null))
        (not (= p@80@00 (as None<option<array>>  option<array>)))
        (= (alen<Int> (opt_get1 $Snap.unit p@80@00)) V@81@00))
      (=
        (valid_graph_vertices s@$ this@79@00 p@80@00 V@81@00)
        (and
          (forall ((unknown1 Int)) (!
            (implies
              (and
                (<= 0 unknown1)
                (< unknown1 (alen<Int> (opt_get1 $Snap.unit p@80@00))))
              (<=
                0
                ($FVF.lookup_int (sm@149@00 s@$ this@79@00 p@80@00 V@81@00) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit p@80@00) unknown1))))
            :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@80@00) unknown1))
            ))
          (forall ((unknown1 Int)) (!
            (implies
              (and
                (<= 0 unknown1)
                (< unknown1 (alen<Int> (opt_get1 $Snap.unit p@80@00))))
              (<
                ($FVF.lookup_int (sm@149@00 s@$ this@79@00 p@80@00 V@81@00) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit p@80@00) unknown1))
                V@81@00))
            :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@80@00) unknown1))
            ))))))
  :pattern ((valid_graph_vertices s@$ this@79@00 p@80@00 V@81@00))
  )))
(assert (forall ((s@$ $Snap) (type1@83@00 $Ref)) (!
  (= (type%limited s@$ type1@83@00) (type s@$ type1@83@00))
  :pattern ((type s@$ type1@83@00))
  )))
(assert (forall ((s@$ $Snap) (type1@83@00 $Ref)) (!
  (type%stateless type1@83@00)
  :pattern ((type%limited s@$ type1@83@00))
  )))
(assert (forall ((s@$ $Snap) (type1@83@00 $Ref)) (!
  (let ((result@84@00 (type%limited s@$ type1@83@00))) (and
    (<= 0 result@84@00)
    (< result@84@00 3)
    (implies (= type1@83@00 $Ref.null) (= result@84@00 0))
    (implies (not (= type1@83@00 $Ref.null)) (not (= result@84@00 0)))))
  :pattern ((type%limited s@$ type1@83@00))
  )))
(assert (forall ((s@$ $Snap) (subtype1@85@00 Int) (subtype2@86@00 Int)) (!
  (=
    (subtype%limited s@$ subtype1@85@00 subtype2@86@00)
    (subtype s@$ subtype1@85@00 subtype2@86@00))
  :pattern ((subtype s@$ subtype1@85@00 subtype2@86@00))
  )))
(assert (forall ((s@$ $Snap) (subtype1@85@00 Int) (subtype2@86@00 Int)) (!
  (subtype%stateless subtype1@85@00 subtype2@86@00)
  :pattern ((subtype%limited s@$ subtype1@85@00 subtype2@86@00))
  )))
(assert (forall ((s@$ $Snap) (subtype1@85@00 Int) (subtype2@86@00 Int)) (!
  (implies
    (and
      (<= 0 subtype1@85@00)
      (< subtype1@85@00 3)
      (<= 0 subtype2@86@00)
      (<= subtype2@86@00 2))
    (=
      (subtype s@$ subtype1@85@00 subtype2@86@00)
      (and
        (implies (= subtype1@85@00 2) (= subtype2@86@00 2))
        (implies (= subtype1@85@00 1) (= subtype2@86@00 1)))))
  :pattern ((subtype s@$ subtype1@85@00 subtype2@86@00))
  )))
(assert (forall ((s@$ $Snap) (this@88@00 $Ref) (a2@89@00 option<array>) (V@90@00 Int)) (!
  (Seq_equal
    (matrixValues%limited s@$ this@88@00 a2@89@00 V@90@00)
    (matrixValues s@$ this@88@00 a2@89@00 V@90@00))
  :pattern ((matrixValues s@$ this@88@00 a2@89@00 V@90@00))
  )))
(assert (forall ((s@$ $Snap) (this@88@00 $Ref) (a2@89@00 option<array>) (V@90@00 Int)) (!
  (matrixValues%stateless this@88@00 a2@89@00 V@90@00)
  :pattern ((matrixValues%limited s@$ this@88@00 a2@89@00 V@90@00))
  )))
(assert (forall ((s@$ $Snap) (this@88@00 $Ref) (a2@89@00 option<array>) (V@90@00 Int)) (!
  (let ((result@91@00 (matrixValues%limited s@$ this@88@00 a2@89@00 V@90@00))) (and
    (forall ((i1@153@00 Int)) (!
      (implies
        (and (and (< i1@153@00 V@90@00) (<= 0 i1@153@00)) (< $Perm.No $k@154@00))
        (=
          (inv@155@00 s@$ this@88@00 a2@89@00 V@90@00 (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1@153@00))
          i1@153@00))
      :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1@153@00))
      ))
    (forall ((r $Ref)) (!
      (implies
        (and
          (and
            (< (inv@155@00 s@$ this@88@00 a2@89@00 V@90@00 r) V@90@00)
            (<= 0 (inv@155@00 s@$ this@88@00 a2@89@00 V@90@00 r)))
          (< $Perm.No $k@154@00))
        (=
          (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit a2@89@00) (inv@155@00 s@$ this@88@00 a2@89@00 V@90@00 r))
          r))
      :pattern ((inv@155@00 s@$ this@88@00 a2@89@00 V@90@00 r))
      :qid |option$array$-fctOfInv|))
    (forall ((i1@161@00 Int) (j@162@00 Int)) (!
      (implies
        (and
          (and
            (and
              (and (< j@162@00 V@90@00) (<= 0 j@162@00))
              (< i1@161@00 V@90@00))
            (<= 0 i1@161@00))
          (< $Perm.No $k@163@00))
        (and
          (=
            (inv@164@00 s@$ this@88@00 a2@89@00 V@90@00 (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@156@00 s@$ this@88@00 a2@89@00 V@90@00) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1@161@00))) j@162@00))
            i1@161@00)
          (=
            (inv@165@00 s@$ this@88@00 a2@89@00 V@90@00 (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@156@00 s@$ this@88@00 a2@89@00 V@90@00) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1@161@00))) j@162@00))
            j@162@00)))
      :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@156@00 s@$ this@88@00 a2@89@00 V@90@00) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1@161@00))) j@162@00))
      ))
    (forall ((r $Ref)) (!
      (implies
        (and
          (and
            (and
              (and
                (< (inv@165@00 s@$ this@88@00 a2@89@00 V@90@00 r) V@90@00)
                (<= 0 (inv@165@00 s@$ this@88@00 a2@89@00 V@90@00 r)))
              (< (inv@164@00 s@$ this@88@00 a2@89@00 V@90@00 r) V@90@00))
            (<= 0 (inv@164@00 s@$ this@88@00 a2@89@00 V@90@00 r)))
          (< $Perm.No $k@163@00))
        (=
          (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@156@00 s@$ this@88@00 a2@89@00 V@90@00) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit a2@89@00) (inv@164@00 s@$ this@88@00 a2@89@00 V@90@00 r)))) (inv@165@00 s@$ this@88@00 a2@89@00 V@90@00 r))
          r))
      :pattern ((inv@164@00 s@$ this@88@00 a2@89@00 V@90@00 r))
      :pattern ((inv@165@00 s@$ this@88@00 a2@89@00 V@90@00 r))
      :qid |int-fctOfInv|))
    (forall ((r $Ref)) (!
      (implies
        (ite
          (and
            (< (inv@155@00 s@$ this@88@00 a2@89@00 V@90@00 r) V@90@00)
            (<= 0 (inv@155@00 s@$ this@88@00 a2@89@00 V@90@00 r)))
          (< $Perm.No $k@154@00)
          false)
        (=
          ($FVF.lookup_option$array$ (sm@156@00 s@$ this@88@00 a2@89@00 V@90@00) r)
          ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r)))
      :pattern (($FVF.lookup_option$array$ (sm@156@00 s@$ this@88@00 a2@89@00 V@90@00) r))
      :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r))
      :qid |qp.fvfValDef9|))
    (forall ((r $Ref)) (!
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r)
      :pattern (($FVF.lookup_option$array$ (sm@156@00 s@$ this@88@00 a2@89@00 V@90@00) r))
      :qid |qp.fvfResTrgDef10|))
    (forall ((r $Ref)) (!
      ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$)))))))) r) r)
      :pattern (($FVF.lookup_int (sm@173@00 s@$ this@88@00 a2@89@00 V@90@00) r))
      :qid |qp.fvfResTrgDef15|))
    ($Perm.isReadVar $k@154@00 $Perm.Write)
    ($Perm.isReadVar $k@163@00 $Perm.Write)
    ($Perm.isReadVar $k@170@00 $Perm.Write)
    (implies
      (and
        (not (= this@88@00 $Ref.null))
        (not (= a2@89@00 (as None<option<array>>  option<array>)))
        (= (alen<Int> (opt_get1 $Snap.unit a2@89@00)) V@90@00)
        (forall ((i1 Int)) (!
          (implies
            (and (<= 0 i1) (< i1 V@90@00))
            (not
              (=
                ($FVF.lookup_option$array$ (sm@156@00 s@$ this@88@00 a2@89@00 V@90@00) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1))
                (as None<option<array>>  option<array>))))
          :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1))
          ))
        (forall ((i1 Int)) (!
          (implies
            (and (<= 0 i1) (< i1 V@90@00))
            (=
              (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@156@00 s@$ this@88@00 a2@89@00 V@90@00) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1))))
              V@90@00))
          :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@156@00 s@$ this@88@00 a2@89@00 V@90@00) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1)))))
          ))
        (forall ((i1 Int)) (!
          (forall ((i2 Int)) (!
            (implies
              (and
                (and
                  (and (and (<= 0 i1) (< i1 V@90@00)) (<= 0 i2))
                  (< i2 V@90@00))
                (=
                  ($FVF.lookup_option$array$ (sm@156@00 s@$ this@88@00 a2@89@00 V@90@00) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1))
                  ($FVF.lookup_option$array$ (sm@156@00 s@$ this@88@00 a2@89@00 V@90@00) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i2))))
              (= i1 i2))
            :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i2))
            ))
          :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1))
          )))
      (and
        (SquareIntMatrix $Snap.unit this@88@00 result@91@00 V@90@00)
        (forall ((i1 Int)) (!
          (implies
            (and (<= 0 i1) (< i1 V@90@00))
            (Seq_equal
              (Seq_index result@91@00 i1)
              (unknown_ ($Snap.combine
                $Snap.unit
                ($Snap.combine
                  $Snap.unit
                  ($Snap.combine
                    $Snap.unit
                    ($Snap.combine
                      $Snap.unit
                      ($SortWrappers.$FVF<Int>To$Snap (sm@173@00 s@$ this@88@00 a2@89@00 V@90@00)))))) ($FVF.lookup_option$array$ (sm@156@00 s@$ this@88@00 a2@89@00 V@90@00) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1)) 0 (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@156@00 s@$ this@88@00 a2@89@00 V@90@00) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1)))))))
          :pattern ((Seq_index result@91@00 i1))
          :pattern ((unknown%limited ($Snap.combine
            $Snap.unit
            ($Snap.combine
              $Snap.unit
              ($Snap.combine
                $Snap.unit
                ($Snap.combine
                  $Snap.unit
                  ($SortWrappers.$FVF<Int>To$Snap (sm@173@00 s@$ this@88@00 a2@89@00 V@90@00)))))) ($FVF.lookup_option$array$ (sm@156@00 s@$ this@88@00 a2@89@00 V@90@00) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1)) 0 (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@156@00 s@$ this@88@00 a2@89@00 V@90@00) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1))))))
          ))))))
  :pattern ((matrixValues%limited s@$ this@88@00 a2@89@00 V@90@00))
  )))
(assert (forall ((s@$ $Snap) (this@92@00 $Ref) (G@93@00 Seq<Seq<Int>>) (Gf@94@00 Seq<Seq<Int>>) (V@95@00 Int) (s@96@00 Int) (t@97@00 Int)) (!
  (=
    (ExAugPath%limited s@$ this@92@00 G@93@00 Gf@94@00 V@95@00 s@96@00 t@97@00)
    (ExAugPath s@$ this@92@00 G@93@00 Gf@94@00 V@95@00 s@96@00 t@97@00))
  :pattern ((ExAugPath s@$ this@92@00 G@93@00 Gf@94@00 V@95@00 s@96@00 t@97@00))
  )))
(assert (forall ((s@$ $Snap) (this@92@00 $Ref) (G@93@00 Seq<Seq<Int>>) (Gf@94@00 Seq<Seq<Int>>) (V@95@00 Int) (s@96@00 Int) (t@97@00 Int)) (!
  (ExAugPath%stateless this@92@00 G@93@00 Gf@94@00 V@95@00 s@96@00 t@97@00)
  :pattern ((ExAugPath%limited s@$ this@92@00 G@93@00 Gf@94@00 V@95@00 s@96@00 t@97@00))
  )))
(assert (forall ((s@$ $Snap) (this@92@00 $Ref) (G@93@00 Seq<Seq<Int>>) (Gf@94@00 Seq<Seq<Int>>) (V@95@00 Int) (s@96@00 Int) (t@97@00 Int)) (!
  (implies
    (and
      (not (= this@92@00 $Ref.null))
      (SquareIntMatrix $Snap.unit this@92@00 G@93@00 V@95@00)
      (SquareIntMatrix $Snap.unit this@92@00 Gf@94@00 V@95@00)
      (FlowNetwork $Snap.unit this@92@00 G@93@00 V@95@00 s@96@00 t@97@00)
      (FlowNetwork $Snap.unit this@92@00 Gf@94@00 V@95@00 s@96@00 t@97@00)
      (ValidFlow ($Snap.combine
        $Snap.unit
        ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) this@92@00 G@93@00 Gf@94@00 V@95@00 s@96@00 t@97@00))
    (=
      (ExAugPath s@$ this@92@00 G@93@00 Gf@94@00 V@95@00 s@96@00 t@97@00)
      (exists ((P Seq<Int>)) (!
        (and
          (AugPath ($Snap.combine
            $Snap.unit
            ($Snap.combine
              $Snap.unit
              ($Snap.combine
                $Snap.unit
                ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))))) this@92@00 G@93@00 Gf@94@00 V@95@00 s@96@00 t@97@00 P)
          (<= (Seq_length P) V@95@00))
        :pattern ((AugPath%limited ($Snap.combine
          $Snap.unit
          ($Snap.combine
            $Snap.unit
            ($Snap.combine
              $Snap.unit
              ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))))) this@92@00 G@93@00 Gf@94@00 V@95@00 s@96@00 t@97@00 P))
        :pattern ((Seq_length P))
        ))))
  :pattern ((ExAugPath s@$ this@92@00 G@93@00 Gf@94@00 V@95@00 s@96@00 t@97@00))
  )))
(assert (forall ((s@$ $Snap) (opt1@99@00 option<any>) (alt@100@00 any)) (!
  (=
    (opt_or_else%limited s@$ opt1@99@00 alt@100@00)
    (opt_or_else s@$ opt1@99@00 alt@100@00))
  :pattern ((opt_or_else s@$ opt1@99@00 alt@100@00))
  )))
(assert (forall ((s@$ $Snap) (opt1@99@00 option<any>) (alt@100@00 any)) (!
  (opt_or_else%stateless opt1@99@00 alt@100@00)
  :pattern ((opt_or_else%limited s@$ opt1@99@00 alt@100@00))
  )))
(assert (forall ((s@$ $Snap) (opt1@99@00 option<any>) (alt@100@00 any)) (!
  (let ((result@101@00 (opt_or_else%limited s@$ opt1@99@00 alt@100@00))) (and
    (implies
      (= opt1@99@00 (as None<option<any>>  option<any>))
      (= result@101@00 alt@100@00))
    (implies
      (not (= opt1@99@00 (as None<option<any>>  option<any>)))
      (= result@101@00 (opt_get $Snap.unit opt1@99@00)))))
  :pattern ((opt_or_else%limited s@$ opt1@99@00 alt@100@00))
  )))
(assert (forall ((s@$ $Snap) (opt1@99@00 option<any>) (alt@100@00 any)) (!
  (=
    (opt_or_else s@$ opt1@99@00 alt@100@00)
    (ite
      (= opt1@99@00 (as None<option<any>>  option<any>))
      alt@100@00
      (opt_get $Snap.unit opt1@99@00)))
  :pattern ((opt_or_else s@$ opt1@99@00 alt@100@00))
  )))
(assert (forall ((s@$ $Snap) (this@102@00 $Ref) (G@103@00 option<array>) (V@104@00 Int) (s@105@00 Int) (t@106@00 Int)) (!
  (=
    (FlowNetwork1%limited s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00)
    (FlowNetwork1 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00))
  :pattern ((FlowNetwork1 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00))
  )))
(assert (forall ((s@$ $Snap) (this@102@00 $Ref) (G@103@00 option<array>) (V@104@00 Int) (s@105@00 Int) (t@106@00 Int)) (!
  (FlowNetwork1%stateless this@102@00 G@103@00 V@104@00 s@105@00 t@106@00)
  :pattern ((FlowNetwork1%limited s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00))
  )))
(assert (forall ((s@$ $Snap) (this@102@00 $Ref) (G@103@00 option<array>) (V@104@00 Int) (s@105@00 Int) (t@106@00 Int)) (!
  (and
    (forall ((i1@176@00 Int)) (!
      (implies
        (and
          (and (< i1@176@00 V@104@00) (<= 0 i1@176@00))
          (< $Perm.No $k@177@00))
        (=
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@176@00))
          i1@176@00))
      :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@176@00))
      ))
    (forall ((r $Ref)) (!
      (implies
        (and
          (and
            (<
              (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
              V@104@00)
            (<=
              0
              (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
          (< $Perm.No $k@177@00))
        (=
          (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@103@00) (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
          r))
      :pattern ((inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
      :qid |option$array$-fctOfInv|))
    (forall ((i1@184@00 Int) (j@185@00 Int)) (!
      (implies
        (and
          (and
            (and
              (and (< j@185@00 V@104@00) (<= 0 j@185@00))
              (< i1@184@00 V@104@00))
            (<= 0 i1@184@00))
          (< $Perm.No $k@186@00))
        (and
          (=
            (inv@187@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@179@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@184@00))) j@185@00))
            i1@184@00)
          (=
            (inv@188@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@179@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@184@00))) j@185@00))
            j@185@00)))
      :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@179@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@184@00))) j@185@00))
      ))
    (forall ((r $Ref)) (!
      (implies
        (and
          (and
            (and
              (and
                (<
                  (inv@188@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                  V@104@00)
                (<=
                  0
                  (inv@188@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
              (<
                (inv@187@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                V@104@00))
            (<=
              0
              (inv@187@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
          (< $Perm.No $k@186@00))
        (=
          (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@179@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@103@00) (inv@187@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))) (inv@188@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
          r))
      :pattern ((inv@187@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
      :pattern ((inv@188@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
      :qid |int-fctOfInv|))
    (forall ((i1@190@00 Int)) (!
      (implies
        (and
          (and (< i1@190@00 V@104@00) (<= 0 i1@190@00))
          (< $Perm.No $k@191@00))
        (=
          (inv@192@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@190@00))
          i1@190@00))
      :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@190@00))
      :qid |option$array$-invOfFct|))
    (forall ((r $Ref)) (!
      (implies
        (and
          (and
            (<
              (inv@192@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
              V@104@00)
            (<=
              0
              (inv@192@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
          (< $Perm.No $k@191@00))
        (=
          (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@103@00) (inv@192@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
          r))
      :pattern ((inv@192@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
      :qid |option$array$-fctOfInv|))
    (forall ((i1@207@00 Int) (j@208@00 Int)) (!
      (implies
        (and
          (and
            (and
              (and (< j@208@00 V@104@00) (<= 0 j@208@00))
              (< i1@207@00 V@104@00))
            (<= 0 i1@207@00))
          (< $Perm.No $k@209@00))
        (and
          (=
            (inv@212@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@210@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@207@00))) j@208@00))
            i1@207@00)
          (=
            (inv@213@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@210@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@207@00))) j@208@00))
            j@208@00)))
      :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@210@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@207@00))) j@208@00))
      :qid |int-invOfFct|))
    (forall ((r $Ref)) (!
      (implies
        (and
          (and
            (and
              (and
                (<
                  (inv@213@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                  V@104@00)
                (<=
                  0
                  (inv@213@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
              (<
                (inv@212@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                V@104@00))
            (<=
              0
              (inv@212@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
          (< $Perm.No $k@209@00))
        (=
          (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@210@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@103@00) (inv@212@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))) (inv@213@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
          r))
      :pattern ((inv@212@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
      :pattern ((inv@213@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
      :qid |int-fctOfInv|))
    (forall ((r $Ref)) (!
      (implies
        (ite
          (and
            (<
              (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
              V@104@00)
            (<=
              0
              (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
          (< $Perm.No $k@177@00)
          false)
        (=
          ($FVF.lookup_option$array$ (sm@179@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r)
          ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r)))
      :pattern (($FVF.lookup_option$array$ (sm@179@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
      :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r))
      :qid |qp.fvfValDef17|))
    (forall ((r $Ref)) (!
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r)
      :pattern (($FVF.lookup_option$array$ (sm@179@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
      :qid |qp.fvfResTrgDef18|))
    (forall ((r $Ref)) (!
      (iff
        (Set_in r ($FVF.domain_option$array$ (sm@194@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00)))
        (and
          (and
            (<
              (inv@192@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
              V@104@00)
            (<=
              0
              (inv@192@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
          (< $Perm.No $k@191@00)))
      :pattern ((Set_in r ($FVF.domain_option$array$ (sm@194@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00))))
      :qid |qp.fvfDomDef24|))
    (forall ((r $Ref)) (!
      (implies
        (and
          (and
            (and
              (<
                (inv@192@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                V@104@00)
              (<=
                0
                (inv@192@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
            (< $Perm.No $k@191@00))
          (ite
            (and
              (<
                (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                V@104@00)
              (<=
                0
                (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
            (< $Perm.No $k@177@00)
            false))
        (=
          ($FVF.lookup_option$array$ (sm@194@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r)
          ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r)))
      :pattern (($FVF.lookup_option$array$ (sm@194@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
      :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r))
      :qid |qp.fvfValDef22|))
    (forall ((r $Ref)) (!
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r)
      :pattern (($FVF.lookup_option$array$ (sm@194@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
      :qid |qp.fvfResTrgDef23|))
    (forall ((r $Ref)) (!
      (implies
        (ite
          (and
            (<
              (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
              V@104@00)
            (<=
              0
              (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
          (< $Perm.No $k@177@00)
          false)
        (=
          ($FVF.lookup_option$array$ (sm@196@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r)
          ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r)))
      :pattern (($FVF.lookup_option$array$ (sm@196@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
      :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r))
      :qid |qp.fvfValDef25|))
    (forall ((r $Ref)) (!
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r)
      :pattern (($FVF.lookup_option$array$ (sm@196@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
      :qid |qp.fvfResTrgDef26|))
    (forall ((r $Ref)) (!
      (implies
        (ite
          (and
            (<
              (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
              V@104@00)
            (<=
              0
              (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
          (< $Perm.No $k@177@00)
          false)
        (=
          ($FVF.lookup_option$array$ (sm@199@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r)
          ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r)))
      :pattern (($FVF.lookup_option$array$ (sm@199@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
      :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r))
      :qid |qp.fvfValDef29|))
    (forall ((r $Ref)) (!
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r)
      :pattern (($FVF.lookup_option$array$ (sm@199@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
      :qid |qp.fvfResTrgDef30|))
    (forall ((r $Ref)) (!
      (implies
        (ite
          (and
            (<
              (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
              V@104@00)
            (<=
              0
              (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
          (< $Perm.No $k@177@00)
          false)
        (=
          ($FVF.lookup_option$array$ (sm@203@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r)
          ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r)))
      :pattern (($FVF.lookup_option$array$ (sm@203@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
      :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r))
      :qid |qp.fvfValDef33|))
    (forall ((r $Ref)) (!
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r)
      :pattern (($FVF.lookup_option$array$ (sm@203@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
      :qid |qp.fvfResTrgDef34|))
    (forall ((r $Ref)) (!
      (implies
        (ite
          (and
            (<
              (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
              V@104@00)
            (<=
              0
              (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
          (< $Perm.No $k@177@00)
          false)
        (=
          ($FVF.lookup_option$array$ (sm@205@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r)
          ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r)))
      :pattern (($FVF.lookup_option$array$ (sm@205@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
      :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r))
      :qid |qp.fvfValDef37|))
    (forall ((r $Ref)) (!
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r)
      :pattern (($FVF.lookup_option$array$ (sm@205@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
      :qid |qp.fvfResTrgDef38|))
    (forall ((r $Ref)) (!
      (implies
        (ite
          (and
            (<
              (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
              V@104@00)
            (<=
              0
              (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
          (< $Perm.No $k@177@00)
          false)
        (=
          ($FVF.lookup_option$array$ (sm@210@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r)
          ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r)))
      :pattern (($FVF.lookup_option$array$ (sm@210@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
      :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r))
      :qid |qp.fvfValDef41|))
    (forall ((r $Ref)) (!
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r)
      :pattern (($FVF.lookup_option$array$ (sm@210@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
      :qid |qp.fvfResTrgDef42|))
    (forall ((r $Ref)) (!
      (iff
        (Set_in r ($FVF.domain_int (sm@215@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00)))
        (and
          (and
            (and
              (and
                (<
                  (inv@213@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                  V@104@00)
                (<=
                  0
                  (inv@213@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
              (<
                (inv@212@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                V@104@00))
            (<=
              0
              (inv@212@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
          (< $Perm.No $k@209@00)))
      :pattern ((Set_in r ($FVF.domain_int (sm@215@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00))))
      :qid |qp.fvfDomDef48|))
    (forall ((r $Ref)) (!
      (implies
        (and
          (and
            (and
              (and
                (and
                  (<
                    (inv@213@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                    V@104@00)
                  (<=
                    0
                    (inv@213@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
                (<
                  (inv@212@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                  V@104@00))
              (<=
                0
                (inv@212@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
            (< $Perm.No $k@209@00))
          (ite
            (and
              (and
                (and
                  (<
                    (inv@188@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                    V@104@00)
                  (<=
                    0
                    (inv@188@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
                (<
                  (inv@187@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                  V@104@00))
              (<=
                0
                (inv@187@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
            (< $Perm.No $k@186@00)
            false))
        (=
          ($FVF.lookup_int (sm@215@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r)
          ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$)))))))) r)))
      :pattern (($FVF.lookup_int (sm@215@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
      :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$)))))))) r))
      :qid |qp.fvfValDef46|))
    (forall ((r $Ref)) (!
      ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$)))))))) r) r)
      :pattern (($FVF.lookup_int (sm@215@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
      :qid |qp.fvfResTrgDef47|))
    ($Perm.isReadVar $k@177@00 $Perm.Write)
    ($Perm.isReadVar $k@186@00 $Perm.Write)
    ($Perm.isReadVar $k@191@00 $Perm.Write)
    ($Perm.isReadVar $k@209@00 $Perm.Write)
    (implies
      (and
        (not (= this@102@00 $Ref.null))
        (not (= G@103@00 (as None<option<array>>  option<array>)))
        (= (alen<Int> (opt_get1 $Snap.unit G@103@00)) V@104@00)
        (forall ((i1 Int)) (!
          (implies
            (and (<= 0 i1) (< i1 V@104@00))
            (not
              (=
                ($FVF.lookup_option$array$ (sm@179@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1))
                (as None<option<array>>  option<array>))))
          :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1))
          ))
        (forall ((i1 Int)) (!
          (implies
            (and (<= 0 i1) (< i1 V@104@00))
            (=
              (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@179@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1))))
              V@104@00))
          :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@179@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1)))))
          ))
        (forall ((i1 Int)) (!
          (forall ((i2 Int)) (!
            (implies
              (and
                (and
                  (and (and (<= 0 i1) (< i1 V@104@00)) (<= 0 i2))
                  (< i2 V@104@00))
                (=
                  ($FVF.lookup_option$array$ (sm@179@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1))
                  ($FVF.lookup_option$array$ (sm@179@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit G@103@00) i2))))
              (= i1 i2))
            :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@103@00) i2))
            ))
          :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1))
          )))
      (=
        (FlowNetwork1 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00)
        (and
          (and
            (and
              (and (and (<= 0 s@105@00) (< s@105@00 V@104@00)) (<= 0 t@106@00))
              (< t@106@00 V@104@00))
            (SquareIntMatrix1 ($Snap.combine
              $Snap.unit
              ($Snap.combine
                $Snap.unit
                ($Snap.combine
                  $Snap.unit
                  ($Snap.combine
                    ($SortWrappers.$FVF<option<array>>To$Snap (sm@194@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00))
                    ($Snap.combine
                      $Snap.unit
                      ($Snap.combine
                        $Snap.unit
                        ($Snap.combine
                          $Snap.unit
                          ($SortWrappers.$FVF<Int>To$Snap (sm@215@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00))))))))) this@102@00 G@103@00 V@104@00))
          (NonNegativeCapacities1 ($Snap.combine $Snap.unit $Snap.unit) this@102@00 G@103@00 V@104@00)))))
  :pattern ((FlowNetwork1 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00))
  )))
; End function- and predicate-related preamble
; ------------------------------------------------------------
; ---------- max_flow ----------
(declare-const this@0@04 $Ref)
(declare-const tid@1@04 Int)
(declare-const G@2@04 option<array>)
(declare-const s@3@04 Int)
(declare-const t@4@04 Int)
(declare-const P@5@04 option<array>)
(declare-const V@6@04 Int)
(declare-const exc@7@04 $Ref)
(declare-const res@8@04 Int)
(declare-const this@9@04 $Ref)
(declare-const tid@10@04 Int)
(declare-const G@11@04 option<array>)
(declare-const s@12@04 Int)
(declare-const t@13@04 Int)
(declare-const P@14@04 option<array>)
(declare-const V@15@04 Int)
(declare-const exc@16@04 $Ref)
(declare-const res@17@04 Int)
(push) ; 1
(declare-const $t@18@04 $Snap)
(assert (= $t@18@04 ($Snap.combine ($Snap.first $t@18@04) ($Snap.second $t@18@04))))
(assert (= ($Snap.first $t@18@04) $Snap.unit))
; [eval] this != null
(assert (not (= this@9@04 $Ref.null)))
(assert (=
  ($Snap.second $t@18@04)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@18@04))
    ($Snap.second ($Snap.second $t@18@04)))))
(assert (= ($Snap.first ($Snap.second $t@18@04)) $Snap.unit))
; [eval] 0 <= s
(assert (<= 0 s@12@04))
(assert (=
  ($Snap.second ($Snap.second $t@18@04))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second $t@18@04)))
    ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))
(assert (= ($Snap.first ($Snap.second ($Snap.second $t@18@04))) $Snap.unit))
; [eval] s < V
(assert (< s@12@04 V@15@04))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second $t@18@04)))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@18@04))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04)))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@18@04))))
  $Snap.unit))
; [eval] 0 <= t
(assert (<= 0 t@13@04))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04)))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04)))))
  $Snap.unit))
; [eval] t < V
(assert (< t@13@04 V@15@04))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04)))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04)))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))
  $Snap.unit))
; [eval] G != (None(): option[array])
; [eval] (None(): option[array])
(assert (not (= G@11@04 (as None<option<array>>  option<array>))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04)))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04)))))))
  $Snap.unit))
; [eval] alen(opt_get1(G)) == V
; [eval] alen(opt_get1(G))
; [eval] opt_get1(G)
(push) ; 2
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 2
; Joined path conditions
(assert (= (alen<Int> (opt_get1 $Snap.unit G@11@04)) V@15@04))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04)))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04)))))))))))
(declare-const i1@19@04 Int)
(push) ; 2
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 3
; [then-branch: 0 | 0 <= i1@19@04 | live]
; [else-branch: 0 | !(0 <= i1@19@04) | live]
(push) ; 4
; [then-branch: 0 | 0 <= i1@19@04]
(assert (<= 0 i1@19@04))
; [eval] i1 < V
(pop) ; 4
(push) ; 4
; [else-branch: 0 | !(0 <= i1@19@04)]
(assert (not (<= 0 i1@19@04)))
(pop) ; 4
(pop) ; 3
; Joined path conditions
; Joined path conditions
(assert (and (< i1@19@04 V@15@04) (<= 0 i1@19@04)))
; [eval] aloc(opt_get1(G), i1)
; [eval] opt_get1(G)
(push) ; 3
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 3
; Joined path conditions
(push) ; 3
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 4
(assert (not (< i1@19@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs            54
;  :arith-add-rows       3
;  :arith-assert-lower   8
;  :arith-assert-upper   5
;  :arith-eq-adapter     3
;  :arith-fixed-eqs      1
;  :arith-pivots         2
;  :datatype-accessor-ax 9
;  :max-generation       2
;  :max-memory           4.25
;  :memory               4.20
;  :mk-bool-var          380
;  :num-allocs           147547
;  :num-checks           1
;  :quant-instantiations 7
;  :rlimit-count         176560)
(assert (< i1@19@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(pop) ; 3
; Joined path conditions
(assert (< i1@19@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(declare-const $k@20@04 $Perm)
(assert ($Perm.isReadVar $k@20@04 $Perm.Write))
(pop) ; 2
(declare-fun inv@21@04 ($Ref) Int)
; Nested auxiliary terms: globals
(assert ($Perm.isReadVar $k@20@04 $Perm.Write))
; Nested auxiliary terms: non-globals
(assert (forall ((i1@19@04 Int)) (!
  (< i1@19@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@19@04))
  :qid |option$array$-aux|)))
(push) ; 2
(assert (not (forall ((i1@19@04 Int)) (!
  (implies
    (and (< i1@19@04 V@15@04) (<= 0 i1@19@04))
    (or (= $k@20@04 $Perm.No) (< $Perm.No $k@20@04)))
  
  ))))
(check-sat)
; unsat
(pop) ; 2
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs            56
;  :arith-add-rows       4
;  :arith-assert-diseq   1
;  :arith-assert-lower   10
;  :arith-assert-upper   6
;  :arith-eq-adapter     4
;  :arith-fixed-eqs      1
;  :arith-pivots         2
;  :conflicts            1
;  :datatype-accessor-ax 10
;  :max-generation       2
;  :max-memory           4.25
;  :memory               4.22
;  :mk-bool-var          387
;  :mk-clause            2
;  :num-allocs           148030
;  :num-checks           2
;  :propagations         1
;  :quant-instantiations 7
;  :rlimit-count         177126)
; Check receiver injectivity
(push) ; 2
(assert (not (forall ((i11@19@04 Int) (i12@19@04 Int)) (!
  (implies
    (and
      (and (and (< i11@19@04 V@15@04) (<= 0 i11@19@04)) (< $Perm.No $k@20@04))
      (and (and (< i12@19@04 V@15@04) (<= 0 i12@19@04)) (< $Perm.No $k@20@04))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i11@19@04)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i12@19@04)))
    (= i11@19@04 i12@19@04))
  
  :qid |option$array$-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 2
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs            75
;  :arith-add-rows       33
;  :arith-assert-diseq   2
;  :arith-assert-lower   14
;  :arith-assert-upper   10
;  :arith-bound-prop     3
;  :arith-eq-adapter     5
;  :arith-fixed-eqs      1
;  :arith-offset-eqs     2
;  :arith-pivots         9
;  :conflicts            3
;  :datatype-accessor-ax 10
;  :decisions            1
;  :del-clause           17
;  :max-generation       2
;  :max-memory           4.25
;  :memory               4.24
;  :mk-bool-var          409
;  :mk-clause            19
;  :num-allocs           148544
;  :num-checks           3
;  :propagations         17
;  :quant-instantiations 17
;  :rlimit-count         178424)
; Definitional axioms for inverse functions
(assert (forall ((i1@19@04 Int)) (!
  (implies
    (and (and (< i1@19@04 V@15@04) (<= 0 i1@19@04)) (< $Perm.No $k@20@04))
    (=
      (inv@21@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@19@04))
      i1@19@04))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@19@04))
  )))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
      (< $Perm.No $k@20@04))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) (inv@21@04 r))
      r))
  :pattern ((inv@21@04 r))
  :qid |option$array$-fctOfInv|)))
; Permissions are non-negative
(assert (forall ((i1@19@04 Int)) (!
  (<= $Perm.No $k@20@04)
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@19@04))
  :qid |option$array$-permAtLeastZero|)))
; Field permissions are at most one
(assert (forall ((i1@19@04 Int)) (!
  (<= $k@20@04 $Perm.Write)
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@19@04))
  :qid |option$array$-permAtMostOne|)))
; Permission implies non-null receiver
(assert (forall ((i1@19@04 Int)) (!
  (implies
    (and (and (< i1@19@04 V@15@04) (<= 0 i1@19@04)) (< $Perm.No $k@20@04))
    (not
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@19@04)
        $Ref.null)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@19@04))
  :qid |option$array$-permImpliesNonNull|)))
(declare-const sm@22@04 $FVF<option<array>>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
      (< $Perm.No $k@20@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@22@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@22@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r))
  :qid |qp.fvfValDef0|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r)
  :pattern (($FVF.lookup_option$array$ (as sm@22@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef1|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@22@04  $FVF<option<array>>) r) r))
  :pattern ((inv@21@04 r))
  )))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04)))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04)))))))))
  $Snap.unit))
; [eval] (forall i1: Int :: { aloc(opt_get1(G), i1) } 0 <= i1 && i1 < V ==> aloc(opt_get1(G), i1).option$array$ != (None(): option[array]))
(declare-const i1@23@04 Int)
(push) ; 2
; [eval] 0 <= i1 && i1 < V ==> aloc(opt_get1(G), i1).option$array$ != (None(): option[array])
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 3
; [then-branch: 1 | 0 <= i1@23@04 | live]
; [else-branch: 1 | !(0 <= i1@23@04) | live]
(push) ; 4
; [then-branch: 1 | 0 <= i1@23@04]
(assert (<= 0 i1@23@04))
; [eval] i1 < V
(pop) ; 4
(push) ; 4
; [else-branch: 1 | !(0 <= i1@23@04)]
(assert (not (<= 0 i1@23@04)))
(pop) ; 4
(pop) ; 3
; Joined path conditions
; Joined path conditions
(push) ; 3
; [then-branch: 2 | i1@23@04 < V@15@04 && 0 <= i1@23@04 | live]
; [else-branch: 2 | !(i1@23@04 < V@15@04 && 0 <= i1@23@04) | live]
(push) ; 4
; [then-branch: 2 | i1@23@04 < V@15@04 && 0 <= i1@23@04]
(assert (and (< i1@23@04 V@15@04) (<= 0 i1@23@04)))
; [eval] aloc(opt_get1(G), i1).option$array$ != (None(): option[array])
; [eval] aloc(opt_get1(G), i1)
; [eval] opt_get1(G)
(push) ; 5
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 5
; Joined path conditions
(push) ; 5
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 6
(assert (not (< i1@23@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs            81
;  :arith-add-rows       34
;  :arith-assert-diseq   2
;  :arith-assert-lower   15
;  :arith-assert-upper   12
;  :arith-bound-prop     3
;  :arith-eq-adapter     5
;  :arith-fixed-eqs      1
;  :arith-offset-eqs     2
;  :arith-pivots         9
;  :conflicts            3
;  :datatype-accessor-ax 11
;  :decisions            1
;  :del-clause           17
;  :max-generation       2
;  :max-memory           4.26
;  :memory               4.26
;  :mk-bool-var          420
;  :mk-clause            19
;  :num-allocs           149856
;  :num-checks           4
;  :propagations         17
;  :quant-instantiations 17
;  :rlimit-count         180954)
(assert (< i1@23@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(pop) ; 5
; Joined path conditions
(assert (< i1@23@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@22@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@23@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@23@04)))
(push) ; 5
(assert (not (ite
  (and
    (<
      (inv@21@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@23@04))
      V@15@04)
    (<=
      0
      (inv@21@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@23@04))))
  (< $Perm.No $k@20@04)
  false)))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs            86
;  :arith-add-rows       39
;  :arith-assert-diseq   2
;  :arith-assert-lower   16
;  :arith-assert-upper   14
;  :arith-bound-prop     4
;  :arith-conflicts      1
;  :arith-eq-adapter     6
;  :arith-fixed-eqs      2
;  :arith-offset-eqs     2
;  :arith-pivots         11
;  :conflicts            4
;  :datatype-accessor-ax 11
;  :decisions            1
;  :del-clause           17
;  :max-generation       2
;  :max-memory           4.27
;  :memory               4.27
;  :mk-bool-var          438
;  :mk-clause            26
;  :num-allocs           150192
;  :num-checks           5
;  :propagations         17
;  :quant-instantiations 27
;  :rlimit-count         181643)
; [eval] (None(): option[array])
(pop) ; 4
(push) ; 4
; [else-branch: 2 | !(i1@23@04 < V@15@04 && 0 <= i1@23@04)]
(assert (not (and (< i1@23@04 V@15@04) (<= 0 i1@23@04))))
(pop) ; 4
(pop) ; 3
; Joined path conditions
(assert (implies
  (and (< i1@23@04 V@15@04) (<= 0 i1@23@04))
  (and
    (< i1@23@04 V@15@04)
    (<= 0 i1@23@04)
    (< i1@23@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@22@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@23@04)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@23@04)))))
; Joined path conditions
(pop) ; 2
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@23@04 Int)) (!
  (implies
    (and (< i1@23@04 V@15@04) (<= 0 i1@23@04))
    (and
      (< i1@23@04 V@15@04)
      (<= 0 i1@23@04)
      (< i1@23@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@22@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@23@04)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@23@04))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@23@04))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(assert (forall ((i1@23@04 Int)) (!
  (implies
    (and (< i1@23@04 V@15@04) (<= 0 i1@23@04))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@22@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@23@04))
        (as None<option<array>>  option<array>))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@23@04))
  :qid |prog.l<no position>|)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04)))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04)))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))))
  $Snap.unit))
; [eval] (forall i1: Int :: { alen(opt_get1(aloc(opt_get1(G), i1).option$array$)) } 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(G), i1).option$array$)) == V)
(declare-const i1@24@04 Int)
(push) ; 2
; [eval] 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(G), i1).option$array$)) == V
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 3
; [then-branch: 3 | 0 <= i1@24@04 | live]
; [else-branch: 3 | !(0 <= i1@24@04) | live]
(push) ; 4
; [then-branch: 3 | 0 <= i1@24@04]
(assert (<= 0 i1@24@04))
; [eval] i1 < V
(pop) ; 4
(push) ; 4
; [else-branch: 3 | !(0 <= i1@24@04)]
(assert (not (<= 0 i1@24@04)))
(pop) ; 4
(pop) ; 3
; Joined path conditions
; Joined path conditions
(push) ; 3
; [then-branch: 4 | i1@24@04 < V@15@04 && 0 <= i1@24@04 | live]
; [else-branch: 4 | !(i1@24@04 < V@15@04 && 0 <= i1@24@04) | live]
(push) ; 4
; [then-branch: 4 | i1@24@04 < V@15@04 && 0 <= i1@24@04]
(assert (and (< i1@24@04 V@15@04) (<= 0 i1@24@04)))
; [eval] alen(opt_get1(aloc(opt_get1(G), i1).option$array$)) == V
; [eval] alen(opt_get1(aloc(opt_get1(G), i1).option$array$))
; [eval] opt_get1(aloc(opt_get1(G), i1).option$array$)
; [eval] aloc(opt_get1(G), i1)
; [eval] opt_get1(G)
(push) ; 5
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 5
; Joined path conditions
(push) ; 5
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 6
(assert (not (< i1@24@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs            92
;  :arith-add-rows       42
;  :arith-assert-diseq   2
;  :arith-assert-lower   17
;  :arith-assert-upper   15
;  :arith-bound-prop     4
;  :arith-conflicts      1
;  :arith-eq-adapter     6
;  :arith-fixed-eqs      2
;  :arith-offset-eqs     2
;  :arith-pivots         13
;  :conflicts            4
;  :datatype-accessor-ax 12
;  :decisions            1
;  :del-clause           24
;  :max-generation       2
;  :max-memory           4.27
;  :memory               4.27
;  :mk-bool-var          444
;  :mk-clause            26
;  :num-allocs           150775
;  :num-checks           6
;  :propagations         17
;  :quant-instantiations 27
;  :rlimit-count         182825)
(assert (< i1@24@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(pop) ; 5
; Joined path conditions
(assert (< i1@24@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@22@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@24@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@24@04)))
(push) ; 5
(assert (not (ite
  (and
    (<
      (inv@21@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@24@04))
      V@15@04)
    (<=
      0
      (inv@21@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@24@04))))
  (< $Perm.No $k@20@04)
  false)))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs            96
;  :arith-add-rows       47
;  :arith-assert-diseq   2
;  :arith-assert-lower   19
;  :arith-assert-upper   16
;  :arith-bound-prop     5
;  :arith-conflicts      2
;  :arith-eq-adapter     7
;  :arith-fixed-eqs      3
;  :arith-offset-eqs     2
;  :arith-pivots         15
;  :conflicts            5
;  :datatype-accessor-ax 12
;  :decisions            1
;  :del-clause           24
;  :max-generation       2
;  :max-memory           4.29
;  :memory               4.28
;  :mk-bool-var          463
;  :mk-clause            33
;  :num-allocs           151059
;  :num-checks           7
;  :propagations         17
;  :quant-instantiations 39
;  :rlimit-count         183541)
(push) ; 5
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 6
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@22@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@24@04))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs            96
;  :arith-add-rows       47
;  :arith-assert-diseq   2
;  :arith-assert-lower   19
;  :arith-assert-upper   16
;  :arith-bound-prop     5
;  :arith-conflicts      2
;  :arith-eq-adapter     7
;  :arith-fixed-eqs      3
;  :arith-offset-eqs     2
;  :arith-pivots         15
;  :conflicts            6
;  :datatype-accessor-ax 12
;  :decisions            1
;  :del-clause           24
;  :max-generation       2
;  :max-memory           4.29
;  :memory               4.28
;  :mk-bool-var          463
;  :mk-clause            33
;  :num-allocs           151147
;  :num-checks           8
;  :propagations         17
;  :quant-instantiations 39
;  :rlimit-count         183636)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@22@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@24@04))
    (as None<option<array>>  option<array>))))
(pop) ; 5
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@22@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@24@04))
    (as None<option<array>>  option<array>))))
(pop) ; 4
(push) ; 4
; [else-branch: 4 | !(i1@24@04 < V@15@04 && 0 <= i1@24@04)]
(assert (not (and (< i1@24@04 V@15@04) (<= 0 i1@24@04))))
(pop) ; 4
(pop) ; 3
; Joined path conditions
(assert (implies
  (and (< i1@24@04 V@15@04) (<= 0 i1@24@04))
  (and
    (< i1@24@04 V@15@04)
    (<= 0 i1@24@04)
    (< i1@24@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@22@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@24@04)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@24@04))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@22@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@24@04))
        (as None<option<array>>  option<array>))))))
; Joined path conditions
(pop) ; 2
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@24@04 Int)) (!
  (implies
    (and (< i1@24@04 V@15@04) (<= 0 i1@24@04))
    (and
      (< i1@24@04 V@15@04)
      (<= 0 i1@24@04)
      (< i1@24@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@22@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@24@04)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@24@04))
      (not
        (=
          ($FVF.lookup_option$array$ (as sm@22@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@24@04))
          (as None<option<array>>  option<array>)))))
  :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@22@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@24@04)))))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(assert (forall ((i1@24@04 Int)) (!
  (implies
    (and (< i1@24@04 V@15@04) (<= 0 i1@24@04))
    (=
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@22@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@24@04))))
      V@15@04))
  :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@22@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@24@04)))))
  :qid |prog.l<no position>|)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04)))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04)))))))))))
  $Snap.unit))
; [eval] (forall i1: Int :: { aloc(opt_get1(G), i1) } (forall i2: Int :: { aloc(opt_get1(G), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(G), i1).option$array$ == aloc(opt_get1(G), i2).option$array$ ==> i1 == i2))
(declare-const i1@25@04 Int)
(push) ; 2
; [eval] (forall i2: Int :: { aloc(opt_get1(G), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(G), i1).option$array$ == aloc(opt_get1(G), i2).option$array$ ==> i1 == i2)
(declare-const i2@26@04 Int)
(push) ; 3
; [eval] 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(G), i1).option$array$ == aloc(opt_get1(G), i2).option$array$ ==> i1 == i2
; [eval] 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(G), i1).option$array$ == aloc(opt_get1(G), i2).option$array$
; [eval] 0 <= i1
(push) ; 4
; [then-branch: 5 | 0 <= i1@25@04 | live]
; [else-branch: 5 | !(0 <= i1@25@04) | live]
(push) ; 5
; [then-branch: 5 | 0 <= i1@25@04]
(assert (<= 0 i1@25@04))
; [eval] i1 < V
(push) ; 6
; [then-branch: 6 | i1@25@04 < V@15@04 | live]
; [else-branch: 6 | !(i1@25@04 < V@15@04) | live]
(push) ; 7
; [then-branch: 6 | i1@25@04 < V@15@04]
(assert (< i1@25@04 V@15@04))
; [eval] 0 <= i2
(push) ; 8
; [then-branch: 7 | 0 <= i2@26@04 | live]
; [else-branch: 7 | !(0 <= i2@26@04) | live]
(push) ; 9
; [then-branch: 7 | 0 <= i2@26@04]
(assert (<= 0 i2@26@04))
; [eval] i2 < V
(push) ; 10
; [then-branch: 8 | i2@26@04 < V@15@04 | live]
; [else-branch: 8 | !(i2@26@04 < V@15@04) | live]
(push) ; 11
; [then-branch: 8 | i2@26@04 < V@15@04]
(assert (< i2@26@04 V@15@04))
; [eval] aloc(opt_get1(G), i1).option$array$ == aloc(opt_get1(G), i2).option$array$
; [eval] aloc(opt_get1(G), i1)
; [eval] opt_get1(G)
(push) ; 12
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 12
; Joined path conditions
(push) ; 12
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 13
(assert (not (< i1@25@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))))
(check-sat)
; unsat
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs            102
;  :arith-add-rows       51
;  :arith-assert-diseq   2
;  :arith-assert-lower   22
;  :arith-assert-upper   17
;  :arith-bound-prop     5
;  :arith-conflicts      2
;  :arith-eq-adapter     7
;  :arith-fixed-eqs      3
;  :arith-offset-eqs     2
;  :arith-pivots         18
;  :conflicts            6
;  :datatype-accessor-ax 13
;  :decisions            1
;  :del-clause           31
;  :max-generation       2
;  :max-memory           4.29
;  :memory               4.29
;  :mk-bool-var          471
;  :mk-clause            33
;  :num-allocs           152034
;  :num-checks           9
;  :propagations         17
;  :quant-instantiations 39
;  :rlimit-count         185063)
(assert (< i1@25@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(pop) ; 12
; Joined path conditions
(assert (< i1@25@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@22@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@25@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@25@04)))
(push) ; 12
(assert (not (ite
  (and
    (<
      (inv@21@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@25@04))
      V@15@04)
    (<=
      0
      (inv@21@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@25@04))))
  (< $Perm.No $k@20@04)
  false)))
(check-sat)
; unsat
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs            107
;  :arith-add-rows       56
;  :arith-assert-diseq   2
;  :arith-assert-lower   24
;  :arith-assert-upper   18
;  :arith-bound-prop     6
;  :arith-conflicts      3
;  :arith-eq-adapter     8
;  :arith-fixed-eqs      4
;  :arith-offset-eqs     2
;  :arith-pivots         20
;  :conflicts            7
;  :datatype-accessor-ax 13
;  :decisions            1
;  :del-clause           31
;  :max-generation       2
;  :max-memory           4.31
;  :memory               4.30
;  :mk-bool-var          491
;  :mk-clause            40
;  :num-allocs           152319
;  :num-checks           10
;  :propagations         17
;  :quant-instantiations 51
;  :rlimit-count         185781)
; [eval] aloc(opt_get1(G), i2)
; [eval] opt_get1(G)
(push) ; 12
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 12
; Joined path conditions
(push) ; 12
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 13
(assert (not (< i2@26@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))))
(check-sat)
; unsat
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs            107
;  :arith-add-rows       56
;  :arith-assert-diseq   2
;  :arith-assert-lower   24
;  :arith-assert-upper   18
;  :arith-bound-prop     6
;  :arith-conflicts      3
;  :arith-eq-adapter     8
;  :arith-fixed-eqs      4
;  :arith-offset-eqs     2
;  :arith-pivots         20
;  :conflicts            7
;  :datatype-accessor-ax 13
;  :decisions            1
;  :del-clause           31
;  :max-generation       2
;  :max-memory           4.31
;  :memory               4.30
;  :mk-bool-var          491
;  :mk-clause            40
;  :num-allocs           152343
;  :num-checks           11
;  :propagations         17
;  :quant-instantiations 51
;  :rlimit-count         185811)
(assert (< i2@26@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(pop) ; 12
; Joined path conditions
(assert (< i2@26@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@22@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@26@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@26@04)))
(push) ; 12
(assert (not (ite
  (and
    (<
      (inv@21@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@26@04))
      V@15@04)
    (<=
      0
      (inv@21@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@26@04))))
  (< $Perm.No $k@20@04)
  false)))
(check-sat)
; unsat
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs            116
;  :arith-add-rows       63
;  :arith-assert-diseq   2
;  :arith-assert-lower   25
;  :arith-assert-upper   20
;  :arith-bound-prop     8
;  :arith-conflicts      4
;  :arith-eq-adapter     9
;  :arith-fixed-eqs      5
;  :arith-offset-eqs     5
;  :arith-pivots         22
;  :conflicts            8
;  :datatype-accessor-ax 13
;  :decisions            1
;  :del-clause           31
;  :max-generation       2
;  :max-memory           4.32
;  :memory               4.31
;  :mk-bool-var          509
;  :mk-clause            47
;  :num-allocs           152659
;  :num-checks           12
;  :propagations         20
;  :quant-instantiations 62
;  :rlimit-count         186530)
(pop) ; 11
(push) ; 11
; [else-branch: 8 | !(i2@26@04 < V@15@04)]
(assert (not (< i2@26@04 V@15@04)))
(pop) ; 11
(pop) ; 10
; Joined path conditions
(assert (implies
  (< i2@26@04 V@15@04)
  (and
    (< i2@26@04 V@15@04)
    (< i1@25@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@22@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@25@04)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@25@04))
    (< i2@26@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@22@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@26@04)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@26@04)))))
; Joined path conditions
(pop) ; 9
(push) ; 9
; [else-branch: 7 | !(0 <= i2@26@04)]
(assert (not (<= 0 i2@26@04)))
(pop) ; 9
(pop) ; 8
; Joined path conditions
(assert (implies
  (<= 0 i2@26@04)
  (and
    (<= 0 i2@26@04)
    (implies
      (< i2@26@04 V@15@04)
      (and
        (< i2@26@04 V@15@04)
        (< i1@25@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@22@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@25@04)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@25@04))
        (< i2@26@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@22@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@26@04)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@26@04)))))))
; Joined path conditions
(pop) ; 7
(push) ; 7
; [else-branch: 6 | !(i1@25@04 < V@15@04)]
(assert (not (< i1@25@04 V@15@04)))
(pop) ; 7
(pop) ; 6
; Joined path conditions
(assert (implies
  (< i1@25@04 V@15@04)
  (and
    (< i1@25@04 V@15@04)
    (implies
      (<= 0 i2@26@04)
      (and
        (<= 0 i2@26@04)
        (implies
          (< i2@26@04 V@15@04)
          (and
            (< i2@26@04 V@15@04)
            (< i1@25@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@22@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@25@04)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@25@04))
            (< i2@26@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@22@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@26@04)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@26@04)))))))))
; Joined path conditions
(pop) ; 5
(push) ; 5
; [else-branch: 5 | !(0 <= i1@25@04)]
(assert (not (<= 0 i1@25@04)))
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (implies
  (<= 0 i1@25@04)
  (and
    (<= 0 i1@25@04)
    (implies
      (< i1@25@04 V@15@04)
      (and
        (< i1@25@04 V@15@04)
        (implies
          (<= 0 i2@26@04)
          (and
            (<= 0 i2@26@04)
            (implies
              (< i2@26@04 V@15@04)
              (and
                (< i2@26@04 V@15@04)
                (< i1@25@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@22@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@25@04)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@25@04))
                (< i2@26@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@22@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@26@04)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@26@04)))))))))))
; Joined path conditions
(push) ; 4
; [then-branch: 9 | Lookup(option$array$,sm@22@04,aloc((_, _), opt_get1(_, G@11@04), i1@25@04)) == Lookup(option$array$,sm@22@04,aloc((_, _), opt_get1(_, G@11@04), i2@26@04)) && i2@26@04 < V@15@04 && 0 <= i2@26@04 && i1@25@04 < V@15@04 && 0 <= i1@25@04 | live]
; [else-branch: 9 | !(Lookup(option$array$,sm@22@04,aloc((_, _), opt_get1(_, G@11@04), i1@25@04)) == Lookup(option$array$,sm@22@04,aloc((_, _), opt_get1(_, G@11@04), i2@26@04)) && i2@26@04 < V@15@04 && 0 <= i2@26@04 && i1@25@04 < V@15@04 && 0 <= i1@25@04) | live]
(push) ; 5
; [then-branch: 9 | Lookup(option$array$,sm@22@04,aloc((_, _), opt_get1(_, G@11@04), i1@25@04)) == Lookup(option$array$,sm@22@04,aloc((_, _), opt_get1(_, G@11@04), i2@26@04)) && i2@26@04 < V@15@04 && 0 <= i2@26@04 && i1@25@04 < V@15@04 && 0 <= i1@25@04]
(assert (and
  (and
    (and
      (and
        (=
          ($FVF.lookup_option$array$ (as sm@22@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@25@04))
          ($FVF.lookup_option$array$ (as sm@22@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@26@04)))
        (< i2@26@04 V@15@04))
      (<= 0 i2@26@04))
    (< i1@25@04 V@15@04))
  (<= 0 i1@25@04)))
; [eval] i1 == i2
(pop) ; 5
(push) ; 5
; [else-branch: 9 | !(Lookup(option$array$,sm@22@04,aloc((_, _), opt_get1(_, G@11@04), i1@25@04)) == Lookup(option$array$,sm@22@04,aloc((_, _), opt_get1(_, G@11@04), i2@26@04)) && i2@26@04 < V@15@04 && 0 <= i2@26@04 && i1@25@04 < V@15@04 && 0 <= i1@25@04)]
(assert (not
  (and
    (and
      (and
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@22@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@25@04))
            ($FVF.lookup_option$array$ (as sm@22@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@26@04)))
          (< i2@26@04 V@15@04))
        (<= 0 i2@26@04))
      (< i1@25@04 V@15@04))
    (<= 0 i1@25@04))))
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (implies
  (and
    (and
      (and
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@22@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@25@04))
            ($FVF.lookup_option$array$ (as sm@22@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@26@04)))
          (< i2@26@04 V@15@04))
        (<= 0 i2@26@04))
      (< i1@25@04 V@15@04))
    (<= 0 i1@25@04))
  (and
    (=
      ($FVF.lookup_option$array$ (as sm@22@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@25@04))
      ($FVF.lookup_option$array$ (as sm@22@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@26@04)))
    (< i2@26@04 V@15@04)
    (<= 0 i2@26@04)
    (< i1@25@04 V@15@04)
    (<= 0 i1@25@04))))
; Joined path conditions
(pop) ; 3
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i2@26@04 Int)) (!
  (and
    (implies
      (<= 0 i1@25@04)
      (and
        (<= 0 i1@25@04)
        (implies
          (< i1@25@04 V@15@04)
          (and
            (< i1@25@04 V@15@04)
            (implies
              (<= 0 i2@26@04)
              (and
                (<= 0 i2@26@04)
                (implies
                  (< i2@26@04 V@15@04)
                  (and
                    (< i2@26@04 V@15@04)
                    (< i1@25@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
                    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@22@04  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@25@04)) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@25@04))
                    (< i2@26@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
                    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@22@04  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@26@04)) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@26@04))))))))))
    (implies
      (and
        (and
          (and
            (and
              (=
                ($FVF.lookup_option$array$ (as sm@22@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@25@04))
                ($FVF.lookup_option$array$ (as sm@22@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@26@04)))
              (< i2@26@04 V@15@04))
            (<= 0 i2@26@04))
          (< i1@25@04 V@15@04))
        (<= 0 i1@25@04))
      (and
        (=
          ($FVF.lookup_option$array$ (as sm@22@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@25@04))
          ($FVF.lookup_option$array$ (as sm@22@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@26@04)))
        (< i2@26@04 V@15@04)
        (<= 0 i2@26@04)
        (< i1@25@04 V@15@04)
        (<= 0 i1@25@04))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@26@04))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 2
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@25@04 Int)) (!
  (forall ((i2@26@04 Int)) (!
    (and
      (implies
        (<= 0 i1@25@04)
        (and
          (<= 0 i1@25@04)
          (implies
            (< i1@25@04 V@15@04)
            (and
              (< i1@25@04 V@15@04)
              (implies
                (<= 0 i2@26@04)
                (and
                  (<= 0 i2@26@04)
                  (implies
                    (< i2@26@04 V@15@04)
                    (and
                      (< i2@26@04 V@15@04)
                      (< i1@25@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
                      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@22@04  $FVF<option<array>>) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@25@04)) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@25@04))
                      (< i2@26@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
                      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@22@04  $FVF<option<array>>) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@26@04)) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@26@04))))))))))
      (implies
        (and
          (and
            (and
              (and
                (=
                  ($FVF.lookup_option$array$ (as sm@22@04  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@25@04))
                  ($FVF.lookup_option$array$ (as sm@22@04  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@26@04)))
                (< i2@26@04 V@15@04))
              (<= 0 i2@26@04))
            (< i1@25@04 V@15@04))
          (<= 0 i1@25@04))
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@22@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@25@04))
            ($FVF.lookup_option$array$ (as sm@22@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@26@04)))
          (< i2@26@04 V@15@04)
          (<= 0 i2@26@04)
          (< i1@25@04 V@15@04)
          (<= 0 i1@25@04))))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@26@04))
    :qid |prog.l<no position>-aux|))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@25@04))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(assert (forall ((i1@25@04 Int)) (!
  (forall ((i2@26@04 Int)) (!
    (implies
      (and
        (and
          (and
            (and
              (=
                ($FVF.lookup_option$array$ (as sm@22@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@25@04))
                ($FVF.lookup_option$array$ (as sm@22@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@26@04)))
              (< i2@26@04 V@15@04))
            (<= 0 i2@26@04))
          (< i1@25@04 V@15@04))
        (<= 0 i1@25@04))
      (= i1@25@04 i2@26@04))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@26@04))
    :qid |prog.l<no position>|))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@25@04))
  :qid |prog.l<no position>|)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04)))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04)))))))))))))))
(declare-const i1@27@04 Int)
(declare-const j@28@04 Int)
(push) ; 2
; [eval] 0 <= i1 && i1 < V && (0 <= j && j < V)
; [eval] 0 <= i1
(push) ; 3
; [then-branch: 10 | 0 <= i1@27@04 | live]
; [else-branch: 10 | !(0 <= i1@27@04) | live]
(push) ; 4
; [then-branch: 10 | 0 <= i1@27@04]
(assert (<= 0 i1@27@04))
; [eval] i1 < V
(push) ; 5
; [then-branch: 11 | i1@27@04 < V@15@04 | live]
; [else-branch: 11 | !(i1@27@04 < V@15@04) | live]
(push) ; 6
; [then-branch: 11 | i1@27@04 < V@15@04]
(assert (< i1@27@04 V@15@04))
; [eval] 0 <= j
(push) ; 7
; [then-branch: 12 | 0 <= j@28@04 | live]
; [else-branch: 12 | !(0 <= j@28@04) | live]
(push) ; 8
; [then-branch: 12 | 0 <= j@28@04]
(assert (<= 0 j@28@04))
; [eval] j < V
(pop) ; 8
(push) ; 8
; [else-branch: 12 | !(0 <= j@28@04)]
(assert (not (<= 0 j@28@04)))
(pop) ; 8
(pop) ; 7
; Joined path conditions
; Joined path conditions
(pop) ; 6
(push) ; 6
; [else-branch: 11 | !(i1@27@04 < V@15@04)]
(assert (not (< i1@27@04 V@15@04)))
(pop) ; 6
(pop) ; 5
; Joined path conditions
; Joined path conditions
(pop) ; 4
(push) ; 4
; [else-branch: 10 | !(0 <= i1@27@04)]
(assert (not (<= 0 i1@27@04)))
(pop) ; 4
(pop) ; 3
; Joined path conditions
; Joined path conditions
(assert (and
  (and (and (< j@28@04 V@15@04) (<= 0 j@28@04)) (< i1@27@04 V@15@04))
  (<= 0 i1@27@04)))
; [eval] aloc(opt_get1(aloc(opt_get1(G), i1).option$array$), j)
; [eval] opt_get1(aloc(opt_get1(G), i1).option$array$)
; [eval] aloc(opt_get1(G), i1)
; [eval] opt_get1(G)
(push) ; 3
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 3
; Joined path conditions
(push) ; 3
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 4
(assert (not (< i1@27@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs            121
;  :arith-add-rows       72
;  :arith-assert-diseq   2
;  :arith-assert-lower   30
;  :arith-assert-upper   21
;  :arith-bound-prop     8
;  :arith-conflicts      4
;  :arith-eq-adapter     9
;  :arith-fixed-eqs      5
;  :arith-offset-eqs     5
;  :arith-pivots         26
;  :conflicts            8
;  :datatype-accessor-ax 14
;  :decisions            1
;  :del-clause           69
;  :max-generation       2
;  :max-memory           4.32
;  :memory               4.32
;  :mk-bool-var          531
;  :mk-clause            71
;  :num-allocs           153928
;  :num-checks           13
;  :propagations         20
;  :quant-instantiations 62
;  :rlimit-count         189392)
(assert (< i1@27@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(pop) ; 3
; Joined path conditions
(assert (< i1@27@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@22@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@27@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@27@04)))
(push) ; 3
(assert (not (ite
  (and
    (<
      (inv@21@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@27@04))
      V@15@04)
    (<=
      0
      (inv@21@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@27@04))))
  (< $Perm.No $k@20@04)
  false)))
(check-sat)
; unsat
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs            126
;  :arith-add-rows       77
;  :arith-assert-diseq   2
;  :arith-assert-lower   31
;  :arith-assert-upper   23
;  :arith-bound-prop     9
;  :arith-conflicts      5
;  :arith-eq-adapter     10
;  :arith-fixed-eqs      6
;  :arith-offset-eqs     5
;  :arith-pivots         28
;  :conflicts            9
;  :datatype-accessor-ax 14
;  :decisions            1
;  :del-clause           69
;  :max-generation       3
;  :max-memory           4.33
;  :memory               4.32
;  :mk-bool-var          560
;  :mk-clause            78
;  :num-allocs           154291
;  :num-checks           14
;  :propagations         20
;  :quant-instantiations 77
;  :rlimit-count         190431)
(push) ; 3
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 4
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@22@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@27@04))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs            126
;  :arith-add-rows       77
;  :arith-assert-diseq   2
;  :arith-assert-lower   31
;  :arith-assert-upper   23
;  :arith-bound-prop     9
;  :arith-conflicts      5
;  :arith-eq-adapter     10
;  :arith-fixed-eqs      6
;  :arith-offset-eqs     5
;  :arith-pivots         28
;  :conflicts            10
;  :datatype-accessor-ax 14
;  :decisions            1
;  :del-clause           69
;  :max-generation       3
;  :max-memory           4.33
;  :memory               4.32
;  :mk-bool-var          560
;  :mk-clause            78
;  :num-allocs           154379
;  :num-checks           15
;  :propagations         20
;  :quant-instantiations 77
;  :rlimit-count         190526)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@22@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@27@04))
    (as None<option<array>>  option<array>))))
(pop) ; 3
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@22@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@27@04))
    (as None<option<array>>  option<array>))))
(push) ; 3
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 4
(assert (not (<
  j@28@04
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@22@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@27@04)))))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs            132
;  :arith-add-rows       83
;  :arith-assert-diseq   2
;  :arith-assert-lower   34
;  :arith-assert-upper   24
;  :arith-bound-prop     9
;  :arith-conflicts      6
;  :arith-eq-adapter     11
;  :arith-fixed-eqs      7
;  :arith-offset-eqs     5
;  :arith-pivots         32
;  :conflicts            11
;  :datatype-accessor-ax 14
;  :decisions            1
;  :del-clause           73
;  :max-generation       3
;  :max-memory           4.35
;  :memory               4.34
;  :mk-bool-var          571
;  :mk-clause            82
;  :num-allocs           154573
;  :num-checks           16
;  :propagations         22
;  :quant-instantiations 84
;  :rlimit-count         191033)
(assert (<
  j@28@04
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@22@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@27@04))))))
(pop) ; 3
; Joined path conditions
(assert (<
  j@28@04
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@22@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@27@04))))))
(pop) ; 2
(declare-fun inv@29@04 ($Ref) Int)
(declare-fun inv@30@04 ($Ref) Int)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(assert (forall ((i1@27@04 Int) (j@28@04 Int)) (!
  (and
    (< i1@27@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@22@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@27@04)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@27@04))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@22@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@27@04))
        (as None<option<array>>  option<array>)))
    (<
      j@28@04
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@22@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@27@04))))))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@22@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@27@04))) j@28@04))
  :qid |int-aux|)))
; Check receiver injectivity
(push) ; 2
(assert (not (forall ((i11@27@04 Int) (j1@28@04 Int) (i12@27@04 Int) (j2@28@04 Int)) (!
  (implies
    (and
      (and
        (and (and (< j1@28@04 V@15@04) (<= 0 j1@28@04)) (< i11@27@04 V@15@04))
        (<= 0 i11@27@04))
      (and
        (and (and (< j2@28@04 V@15@04) (<= 0 j2@28@04)) (< i12@27@04 V@15@04))
        (<= 0 i12@27@04))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@22@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i11@27@04))) j1@28@04)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@22@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i12@27@04))) j2@28@04)))
    (and (= i11@27@04 i12@27@04) (= j1@28@04 j2@28@04)))
  
  :qid |int-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 2
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs            170
;  :arith-add-rows       106
;  :arith-assert-diseq   2
;  :arith-assert-lower   49
;  :arith-assert-upper   29
;  :arith-bound-prop     11
;  :arith-conflicts      6
;  :arith-eq-adapter     17
;  :arith-fixed-eqs      11
;  :arith-offset-eqs     6
;  :arith-pivots         46
;  :conflicts            12
;  :datatype-accessor-ax 14
;  :decisions            1
;  :del-clause           139
;  :max-generation       3
;  :max-memory           4.68
;  :memory               4.61
;  :mk-bool-var          702
;  :mk-clause            141
;  :num-allocs           155887
;  :num-checks           17
;  :propagations         46
;  :quant-instantiations 142
;  :rlimit-count         194748
;  :time                 0.00)
; Definitional axioms for inverse functions
(assert (forall ((i1@27@04 Int) (j@28@04 Int)) (!
  (implies
    (and
      (and (and (< j@28@04 V@15@04) (<= 0 j@28@04)) (< i1@27@04 V@15@04))
      (<= 0 i1@27@04))
    (and
      (=
        (inv@29@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@22@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@27@04))) j@28@04))
        i1@27@04)
      (=
        (inv@30@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@22@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@27@04))) j@28@04))
        j@28@04)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@22@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@27@04))) j@28@04))
  )))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@30@04 r) V@15@04) (<= 0 (inv@30@04 r)))
        (< (inv@29@04 r) V@15@04))
      (<= 0 (inv@29@04 r)))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@22@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) (inv@29@04 r)))) (inv@30@04 r))
      r))
  :pattern ((inv@29@04 r))
  :pattern ((inv@30@04 r))
  :qid |int-fctOfInv|)))
; Permissions are non-negative
; Field permissions are at most one
; Permission implies non-null receiver
(assert (forall ((i1@27@04 Int) (j@28@04 Int)) (!
  (implies
    (and
      (and (and (< j@28@04 V@15@04) (<= 0 j@28@04)) (< i1@27@04 V@15@04))
      (<= 0 i1@27@04))
    (not
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@22@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@27@04))) j@28@04)
        $Ref.null)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@22@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@27@04))) j@28@04))
  :qid |int-permImpliesNonNull|)))
(declare-const sm@31@04 $FVF<Int>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@30@04 r) V@15@04) (<= 0 (inv@30@04 r)))
        (< (inv@29@04 r) V@15@04))
      (<= 0 (inv@29@04 r)))
    (=
      ($FVF.lookup_int (as sm@31@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@31@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))))))) r))
  :qid |qp.fvfValDef2|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))))))) r) r)
  :pattern (($FVF.lookup_int (as sm@31@04  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef3|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@30@04 r) V@15@04) (<= 0 (inv@30@04 r)))
        (< (inv@29@04 r) V@15@04))
      (<= 0 (inv@29@04 r)))
    ($FVF.loc_int ($FVF.lookup_int (as sm@31@04  $FVF<Int>) r) r))
  :pattern ((inv@29@04 r) (inv@30@04 r))
  )))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04)))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04)))))))))))))
  $Snap.unit))
; [eval] P != (None(): option[array])
; [eval] (None(): option[array])
(assert (not (= P@14@04 (as None<option<array>>  option<array>))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04)))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04)))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))))))))
  $Snap.unit))
; [eval] alen(opt_get1(P)) == V
; [eval] alen(opt_get1(P))
; [eval] opt_get1(P)
(push) ; 2
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 2
; Joined path conditions
(assert (= (alen<Int> (opt_get1 $Snap.unit P@14@04)) V@15@04))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04)))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))))))))))))
(declare-const i1@32@04 Int)
(push) ; 2
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 3
; [then-branch: 13 | 0 <= i1@32@04 | live]
; [else-branch: 13 | !(0 <= i1@32@04) | live]
(push) ; 4
; [then-branch: 13 | 0 <= i1@32@04]
(assert (<= 0 i1@32@04))
; [eval] i1 < V
(pop) ; 4
(push) ; 4
; [else-branch: 13 | !(0 <= i1@32@04)]
(assert (not (<= 0 i1@32@04)))
(pop) ; 4
(pop) ; 3
; Joined path conditions
; Joined path conditions
(assert (and (< i1@32@04 V@15@04) (<= 0 i1@32@04)))
; [eval] aloc(opt_get1(P), i1)
; [eval] opt_get1(P)
(push) ; 3
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 3
; Joined path conditions
(push) ; 3
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 4
(assert (not (< i1@32@04 (alen<Int> (opt_get1 $Snap.unit P@14@04)))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs            193
;  :arith-add-rows       108
;  :arith-assert-diseq   2
;  :arith-assert-lower   53
;  :arith-assert-upper   30
;  :arith-bound-prop     11
;  :arith-conflicts      6
;  :arith-eq-adapter     18
;  :arith-fixed-eqs      12
;  :arith-offset-eqs     6
;  :arith-pivots         48
;  :conflicts            12
;  :datatype-accessor-ax 17
;  :decisions            1
;  :del-clause           139
;  :max-generation       3
;  :max-memory           4.68
;  :memory               4.62
;  :mk-bool-var          725
;  :mk-clause            141
;  :num-allocs           157309
;  :num-checks           18
;  :propagations         46
;  :quant-instantiations 147
;  :rlimit-count         198643)
(assert (< i1@32@04 (alen<Int> (opt_get1 $Snap.unit P@14@04))))
(pop) ; 3
; Joined path conditions
(assert (< i1@32@04 (alen<Int> (opt_get1 $Snap.unit P@14@04))))
(pop) ; 2
(declare-fun inv@33@04 ($Ref) Int)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(assert (forall ((i1@32@04 Int)) (!
  (< i1@32@04 (alen<Int> (opt_get1 $Snap.unit P@14@04)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i1@32@04))
  :qid |int-aux|)))
; Check receiver injectivity
(push) ; 2
(assert (not (forall ((i11@32@04 Int) (i12@32@04 Int)) (!
  (implies
    (and
      (and (< i11@32@04 V@15@04) (<= 0 i11@32@04))
      (and (< i12@32@04 V@15@04) (<= 0 i12@32@04))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i11@32@04)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i12@32@04)))
    (= i11@32@04 i12@32@04))
  
  :qid |int-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 2
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs            204
;  :arith-add-rows       118
;  :arith-assert-diseq   5
;  :arith-assert-lower   57
;  :arith-assert-upper   31
;  :arith-bound-prop     12
;  :arith-conflicts      7
;  :arith-eq-adapter     19
;  :arith-fixed-eqs      12
;  :arith-offset-eqs     7
;  :arith-pivots         53
;  :conflicts            13
;  :datatype-accessor-ax 17
;  :decisions            1
;  :del-clause           153
;  :max-generation       3
;  :max-memory           4.68
;  :memory               4.62
;  :mk-bool-var          749
;  :mk-clause            155
;  :num-allocs           157823
;  :num-checks           19
;  :propagations         51
;  :quant-instantiations 157
;  :rlimit-count         199675)
; Definitional axioms for inverse functions
(assert (forall ((i1@32@04 Int)) (!
  (implies
    (and (< i1@32@04 V@15@04) (<= 0 i1@32@04))
    (=
      (inv@33@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i1@32@04))
      i1@32@04))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i1@32@04))
  )))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@33@04 r) V@15@04) (<= 0 (inv@33@04 r)))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) (inv@33@04 r))
      r))
  :pattern ((inv@33@04 r))
  :qid |int-fctOfInv|)))
; Permissions are non-negative
; Field permissions are at most one
; Permission implies non-null receiver
(assert (forall ((i1@32@04 Int)) (!
  (implies
    (and (< i1@32@04 V@15@04) (<= 0 i1@32@04))
    (not
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i1@32@04)
        $Ref.null)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i1@32@04))
  :qid |int-permImpliesNonNull|)))
(declare-const sm@34@04 $FVF<Int>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@33@04 r) V@15@04) (<= 0 (inv@33@04 r)))
    (=
      ($FVF.lookup_int (as sm@34@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04)))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@34@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04)))))))))))))))) r))
  :qid |qp.fvfValDef4|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@30@04 r) V@15@04) (<= 0 (inv@30@04 r)))
        (< (inv@29@04 r) V@15@04))
      (<= 0 (inv@29@04 r)))
    (=
      ($FVF.lookup_int (as sm@34@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@34@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))))))) r))
  :qid |qp.fvfValDef5|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04)))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@34@04  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef6|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@33@04 r) V@15@04) (<= 0 (inv@33@04 r)))
    ($FVF.loc_int ($FVF.lookup_int (as sm@34@04  $FVF<Int>) r) r))
  :pattern ((inv@33@04 r))
  )))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04)))))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04)))))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))))))))))
  $Snap.unit))
; [eval] valid_graph_vertices(this, P, V)
(push) ; 2
; [eval] this != null
; [eval] p != (None(): option[array])
; [eval] (None(): option[array])
; [eval] alen(opt_get1(p)) == V
; [eval] alen(opt_get1(p))
; [eval] opt_get1(p)
(push) ; 3
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 3
; Joined path conditions
(declare-const i1@35@04 Int)
(push) ; 3
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 4
; [then-branch: 14 | 0 <= i1@35@04 | live]
; [else-branch: 14 | !(0 <= i1@35@04) | live]
(push) ; 5
; [then-branch: 14 | 0 <= i1@35@04]
(assert (<= 0 i1@35@04))
; [eval] i1 < V
(pop) ; 5
(push) ; 5
; [else-branch: 14 | !(0 <= i1@35@04)]
(assert (not (<= 0 i1@35@04)))
(pop) ; 5
(pop) ; 4
; Joined path conditions
; Joined path conditions
(assert (and (< i1@35@04 V@15@04) (<= 0 i1@35@04)))
(declare-const $k@36@04 $Perm)
(assert ($Perm.isReadVar $k@36@04 $Perm.Write))
; [eval] aloc(opt_get1(p), i1)
; [eval] opt_get1(p)
(push) ; 4
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 4
; Joined path conditions
(push) ; 4
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 5
(assert (not (< i1@35@04 (alen<Int> (opt_get1 $Snap.unit P@14@04)))))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs            210
;  :arith-add-rows       119
;  :arith-assert-diseq   6
;  :arith-assert-lower   61
;  :arith-assert-upper   32
;  :arith-bound-prop     12
;  :arith-conflicts      7
;  :arith-eq-adapter     20
;  :arith-fixed-eqs      12
;  :arith-offset-eqs     7
;  :arith-pivots         54
;  :conflicts            13
;  :datatype-accessor-ax 18
;  :decisions            1
;  :del-clause           153
;  :max-generation       3
;  :max-memory           4.68
;  :memory               4.62
;  :mk-bool-var          764
;  :mk-clause            157
;  :num-allocs           159191
;  :num-checks           20
;  :propagations         52
;  :quant-instantiations 157
;  :rlimit-count         203284)
(assert (< i1@35@04 (alen<Int> (opt_get1 $Snap.unit P@14@04))))
(pop) ; 4
; Joined path conditions
(assert (< i1@35@04 (alen<Int> (opt_get1 $Snap.unit P@14@04))))
(pop) ; 3
(declare-fun inv@37@04 ($Ref) Int)
; Nested auxiliary terms: globals
(assert ($Perm.isReadVar $k@36@04 $Perm.Write))
; Nested auxiliary terms: non-globals
(assert (forall ((i1@35@04 Int)) (!
  (< i1@35@04 (alen<Int> (opt_get1 $Snap.unit P@14@04)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i1@35@04))
  :qid |int-aux|)))
(push) ; 3
(assert (not (forall ((i1@35@04 Int)) (!
  (implies
    (and (< i1@35@04 V@15@04) (<= 0 i1@35@04))
    (or (= $k@36@04 $Perm.No) (< $Perm.No $k@36@04)))
  
  ))))
(check-sat)
; unsat
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs            210
;  :arith-add-rows       120
;  :arith-assert-diseq   7
;  :arith-assert-lower   63
;  :arith-assert-upper   33
;  :arith-bound-prop     12
;  :arith-conflicts      7
;  :arith-eq-adapter     21
;  :arith-fixed-eqs      12
;  :arith-offset-eqs     7
;  :arith-pivots         55
;  :conflicts            14
;  :datatype-accessor-ax 18
;  :decisions            1
;  :del-clause           155
;  :max-generation       3
;  :max-memory           4.68
;  :memory               4.62
;  :mk-bool-var          771
;  :mk-clause            159
;  :num-allocs           159618
;  :num-checks           21
;  :propagations         53
;  :quant-instantiations 157
;  :rlimit-count         203835)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 3
(assert (not (forall ((i11@35@04 Int) (i12@35@04 Int)) (!
  (implies
    (and
      (and
        (and
          (and (< i11@35@04 V@15@04) (<= 0 i11@35@04))
          ($FVF.loc_int ($FVF.lookup_int (as sm@34@04  $FVF<Int>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit P@14@04) i11@35@04)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit P@14@04) i11@35@04)))
        (< $Perm.No $k@36@04))
      (and
        (and
          (and (< i12@35@04 V@15@04) (<= 0 i12@35@04))
          ($FVF.loc_int ($FVF.lookup_int (as sm@34@04  $FVF<Int>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit P@14@04) i12@35@04)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit P@14@04) i12@35@04)))
        (< $Perm.No $k@36@04))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i11@35@04)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i12@35@04)))
    (= i11@35@04 i12@35@04))
  
  :qid |int-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs            219
;  :arith-add-rows       127
;  :arith-assert-diseq   8
;  :arith-assert-lower   67
;  :arith-assert-upper   33
;  :arith-bound-prop     12
;  :arith-conflicts      7
;  :arith-eq-adapter     22
;  :arith-fixed-eqs      12
;  :arith-offset-eqs     7
;  :arith-pivots         55
;  :conflicts            15
;  :datatype-accessor-ax 18
;  :decisions            1
;  :del-clause           166
;  :max-generation       3
;  :max-memory           4.68
;  :memory               4.62
;  :mk-bool-var          802
;  :mk-clause            170
;  :num-allocs           160076
;  :num-checks           22
;  :propagations         55
;  :quant-instantiations 171
;  :rlimit-count         204797)
; Definitional axioms for inverse functions
(assert (forall ((i1@35@04 Int)) (!
  (implies
    (and (and (< i1@35@04 V@15@04) (<= 0 i1@35@04)) (< $Perm.No $k@36@04))
    (=
      (inv@37@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i1@35@04))
      i1@35@04))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i1@35@04))
  :qid |int-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and (< (inv@37@04 r) V@15@04) (<= 0 (inv@37@04 r)))
      (< $Perm.No $k@36@04))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) (inv@37@04 r))
      r))
  :pattern ((inv@37@04 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@37@04 r) V@15@04) (<= 0 (inv@37@04 r)))
    ($FVF.loc_int ($FVF.lookup_int (as sm@34@04  $FVF<Int>) r) r))
  :pattern ((inv@37@04 r))
  )))
; Precomputing data for removing quantified permissions
(define-fun pTaken@38@04 ((r $Ref)) $Perm
  (ite
    (and (< (inv@37@04 r) V@15@04) (<= 0 (inv@37@04 r)))
    ($Perm.min
      (ite
        (and (< (inv@33@04 r) V@15@04) (<= 0 (inv@33@04 r)))
        $Perm.Write
        $Perm.No)
      $k@36@04)
    $Perm.No))
(define-fun pTaken@39@04 ((r $Ref)) $Perm
  (ite
    (and (< (inv@37@04 r) V@15@04) (<= 0 (inv@37@04 r)))
    ($Perm.min
      (ite
        (and
          (and
            (and (< (inv@30@04 r) V@15@04) (<= 0 (inv@30@04 r)))
            (< (inv@29@04 r) V@15@04))
          (<= 0 (inv@29@04 r)))
        $Perm.Write
        $Perm.No)
      (- $k@36@04 (pTaken@38@04 r)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Constrain original permissions $k@36@04
(assert (forall ((r $Ref)) (!
  (implies
    (not
      (=
        (ite
          (and (< (inv@33@04 r) V@15@04) (<= 0 (inv@33@04 r)))
          $Perm.Write
          $Perm.No)
        $Perm.No))
    (ite
      (and (< (inv@33@04 r) V@15@04) (<= 0 (inv@33@04 r)))
      (<
        (ite
          (and (< (inv@37@04 r) V@15@04) (<= 0 (inv@37@04 r)))
          $k@36@04
          $Perm.No)
        $Perm.Write)
      (<
        (ite
          (and (< (inv@37@04 r) V@15@04) (<= 0 (inv@37@04 r)))
          $k@36@04
          $Perm.No)
        $Perm.No)))
  :pattern ((inv@33@04 r))
  :pattern ((inv@37@04 r))
  :qid |qp.srp7|)))
; Intermediate check if already taken enough permissions
(set-option :timeout 500)
(push) ; 3
(assert (not (forall ((r $Ref)) (!
  (implies
    (and (< (inv@37@04 r) V@15@04) (<= 0 (inv@37@04 r)))
    (= (- $k@36@04 (pTaken@38@04 r)) $Perm.No))
  
  ))))
(check-sat)
; unsat
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               297
;  :arith-add-rows          145
;  :arith-assert-diseq      12
;  :arith-assert-lower      79
;  :arith-assert-upper      39
;  :arith-bound-prop        14
;  :arith-conflicts         9
;  :arith-eq-adapter        37
;  :arith-fixed-eqs         14
;  :arith-offset-eqs        8
;  :arith-pivots            67
;  :conflicts               24
;  :datatype-accessor-ax    18
;  :datatype-constructor-ax 8
;  :datatype-occurs-check   3
;  :datatype-splits         4
;  :decisions               13
;  :del-clause              232
;  :final-checks            2
;  :max-generation          3
;  :max-memory              4.72
;  :memory                  4.71
;  :mk-bool-var             893
;  :mk-clause               234
;  :num-allocs              162210
;  :num-checks              24
;  :propagations            99
;  :quant-instantiations    190
;  :rlimit-count            208445)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@40@04 $FVF<Int>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (iff
    (Set_in r ($FVF.domain_int (as sm@40@04  $FVF<Int>)))
    (and
      (and (< (inv@37@04 r) V@15@04) (<= 0 (inv@37@04 r)))
      (< $Perm.No $k@36@04)))
  :pattern ((Set_in r ($FVF.domain_int (as sm@40@04  $FVF<Int>))))
  :qid |qp.fvfDomDef11|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@37@04 r) V@15@04) (<= 0 (inv@37@04 r)))
        (< $Perm.No $k@36@04))
      (and (< (inv@33@04 r) V@15@04) (<= 0 (inv@33@04 r))))
    (=
      ($FVF.lookup_int (as sm@40@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04)))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@40@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04)))))))))))))))) r))
  :qid |qp.fvfValDef8|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@37@04 r) V@15@04) (<= 0 (inv@37@04 r)))
        (< $Perm.No $k@36@04))
      (and
        (and
          (and (< (inv@30@04 r) V@15@04) (<= 0 (inv@30@04 r)))
          (< (inv@29@04 r) V@15@04))
        (<= 0 (inv@29@04 r))))
    (=
      ($FVF.lookup_int (as sm@40@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@40@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))))))) r))
  :qid |qp.fvfValDef9|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04)))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@40@04  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef10|)))
(pop) ; 2
; Joined path conditions
(assert ($Perm.isReadVar $k@36@04 $Perm.Write))
(assert (forall ((i1@35@04 Int)) (!
  (implies
    (and (and (< i1@35@04 V@15@04) (<= 0 i1@35@04)) (< $Perm.No $k@36@04))
    (=
      (inv@37@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i1@35@04))
      i1@35@04))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i1@35@04))
  :qid |int-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and (< (inv@37@04 r) V@15@04) (<= 0 (inv@37@04 r)))
      (< $Perm.No $k@36@04))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) (inv@37@04 r))
      r))
  :pattern ((inv@37@04 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (iff
    (Set_in r ($FVF.domain_int (as sm@40@04  $FVF<Int>)))
    (and
      (and (< (inv@37@04 r) V@15@04) (<= 0 (inv@37@04 r)))
      (< $Perm.No $k@36@04)))
  :pattern ((Set_in r ($FVF.domain_int (as sm@40@04  $FVF<Int>))))
  :qid |qp.fvfDomDef11|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@37@04 r) V@15@04) (<= 0 (inv@37@04 r)))
        (< $Perm.No $k@36@04))
      (and (< (inv@33@04 r) V@15@04) (<= 0 (inv@33@04 r))))
    (=
      ($FVF.lookup_int (as sm@40@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04)))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@40@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04)))))))))))))))) r))
  :qid |qp.fvfValDef8|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@37@04 r) V@15@04) (<= 0 (inv@37@04 r)))
        (< $Perm.No $k@36@04))
      (and
        (and
          (and (< (inv@30@04 r) V@15@04) (<= 0 (inv@30@04 r)))
          (< (inv@29@04 r) V@15@04))
        (<= 0 (inv@29@04 r))))
    (=
      ($FVF.lookup_int (as sm@40@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@40@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))))))) r))
  :qid |qp.fvfValDef9|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04)))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@40@04  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef10|)))
(assert (and
  (forall ((i1@35@04 Int)) (!
    (< i1@35@04 (alen<Int> (opt_get1 $Snap.unit P@14@04)))
    :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i1@35@04))
    :qid |int-aux|))
  (forall ((r $Ref)) (!
    (implies
      (and (< (inv@37@04 r) V@15@04) (<= 0 (inv@37@04 r)))
      ($FVF.loc_int ($FVF.lookup_int (as sm@34@04  $FVF<Int>) r) r))
    :pattern ((inv@37@04 r))
    ))
  (forall ((r $Ref)) (!
    (implies
      (not
        (=
          (ite
            (and (< (inv@33@04 r) V@15@04) (<= 0 (inv@33@04 r)))
            $Perm.Write
            $Perm.No)
          $Perm.No))
      (ite
        (and (< (inv@33@04 r) V@15@04) (<= 0 (inv@33@04 r)))
        (<
          (ite
            (and (< (inv@37@04 r) V@15@04) (<= 0 (inv@37@04 r)))
            $k@36@04
            $Perm.No)
          $Perm.Write)
        (<
          (ite
            (and (< (inv@37@04 r) V@15@04) (<= 0 (inv@37@04 r)))
            $k@36@04
            $Perm.No)
          $Perm.No)))
    :pattern ((inv@33@04 r))
    :pattern ((inv@37@04 r))
    :qid |qp.srp7|))))
(assert (valid_graph_vertices ($Snap.combine
  $Snap.unit
  ($Snap.combine
    $Snap.unit
    ($Snap.combine
      $Snap.unit
      ($SortWrappers.$FVF<Int>To$Snap (as sm@40@04  $FVF<Int>))))) this@9@04 P@14@04 V@15@04))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))))))))))
  $Snap.unit))
; [eval] FlowNetwork1(this, G, V, s, t)
(push) ; 2
; [eval] this != null
; [eval] G != (None(): option[array])
; [eval] (None(): option[array])
; [eval] alen(opt_get1(G)) == V
; [eval] alen(opt_get1(G))
; [eval] opt_get1(G)
(push) ; 3
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 3
; Joined path conditions
(declare-const i1@41@04 Int)
(push) ; 3
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 4
; [then-branch: 15 | 0 <= i1@41@04 | live]
; [else-branch: 15 | !(0 <= i1@41@04) | live]
(push) ; 5
; [then-branch: 15 | 0 <= i1@41@04]
(assert (<= 0 i1@41@04))
; [eval] i1 < V
(pop) ; 5
(push) ; 5
; [else-branch: 15 | !(0 <= i1@41@04)]
(assert (not (<= 0 i1@41@04)))
(pop) ; 5
(pop) ; 4
; Joined path conditions
; Joined path conditions
(assert (and (< i1@41@04 V@15@04) (<= 0 i1@41@04)))
(declare-const $k@42@04 $Perm)
(assert ($Perm.isReadVar $k@42@04 $Perm.Write))
; [eval] aloc(opt_get1(G), i1)
; [eval] opt_get1(G)
(push) ; 4
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 4
; Joined path conditions
(push) ; 4
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 5
(assert (not (< i1@41@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               306
;  :arith-add-rows          149
;  :arith-assert-diseq      15
;  :arith-assert-lower      87
;  :arith-assert-upper      42
;  :arith-bound-prop        14
;  :arith-conflicts         9
;  :arith-eq-adapter        40
;  :arith-fixed-eqs         14
;  :arith-offset-eqs        8
;  :arith-pivots            67
;  :conflicts               24
;  :datatype-accessor-ax    21
;  :datatype-constructor-ax 8
;  :datatype-occurs-check   3
;  :datatype-splits         4
;  :decisions               13
;  :del-clause              232
;  :final-checks            2
;  :max-generation          3
;  :max-memory              4.73
;  :memory                  4.73
;  :mk-bool-var             942
;  :mk-clause               266
;  :num-allocs              164377
;  :num-checks              25
;  :propagations            115
;  :quant-instantiations    194
;  :rlimit-count            213901)
(assert (< i1@41@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(pop) ; 4
; Joined path conditions
(assert (< i1@41@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(pop) ; 3
(declare-fun inv@43@04 ($Ref) Int)
; Nested auxiliary terms: globals
(assert ($Perm.isReadVar $k@42@04 $Perm.Write))
; Nested auxiliary terms: non-globals
(assert (forall ((i1@41@04 Int)) (!
  (< i1@41@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@41@04))
  :qid |option$array$-aux|)))
(push) ; 3
(assert (not (forall ((i1@41@04 Int)) (!
  (implies
    (and (< i1@41@04 V@15@04) (<= 0 i1@41@04))
    (or (= $k@42@04 $Perm.No) (< $Perm.No $k@42@04)))
  
  ))))
(check-sat)
; unsat
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               306
;  :arith-add-rows          150
;  :arith-assert-diseq      16
;  :arith-assert-lower      89
;  :arith-assert-upper      43
;  :arith-bound-prop        14
;  :arith-conflicts         9
;  :arith-eq-adapter        41
;  :arith-fixed-eqs         14
;  :arith-offset-eqs        8
;  :arith-pivots            67
;  :conflicts               25
;  :datatype-accessor-ax    21
;  :datatype-constructor-ax 8
;  :datatype-occurs-check   3
;  :datatype-splits         4
;  :decisions               13
;  :del-clause              234
;  :final-checks            2
;  :max-generation          3
;  :max-memory              4.74
;  :memory                  4.73
;  :mk-bool-var             949
;  :mk-clause               268
;  :num-allocs              164805
;  :num-checks              26
;  :propagations            116
;  :quant-instantiations    194
;  :rlimit-count            214447)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 3
(assert (not (forall ((i11@41@04 Int) (i12@41@04 Int)) (!
  (implies
    (and
      (and
        (and
          (and (< i11@41@04 V@15@04) (<= 0 i11@41@04))
          ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@22@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i11@41@04)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i11@41@04)))
        (< $Perm.No $k@42@04))
      (and
        (and
          (and (< i12@41@04 V@15@04) (<= 0 i12@41@04))
          ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@22@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i12@41@04)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i12@41@04)))
        (< $Perm.No $k@42@04))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i11@41@04)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i12@41@04)))
    (= i11@41@04 i12@41@04))
  
  :qid |option$array$-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               315
;  :arith-add-rows          155
;  :arith-assert-diseq      17
;  :arith-assert-lower      93
;  :arith-assert-upper      43
;  :arith-bound-prop        14
;  :arith-conflicts         9
;  :arith-eq-adapter        42
;  :arith-fixed-eqs         14
;  :arith-offset-eqs        8
;  :arith-pivots            69
;  :conflicts               26
;  :datatype-accessor-ax    21
;  :datatype-constructor-ax 8
;  :datatype-occurs-check   3
;  :datatype-splits         4
;  :decisions               13
;  :del-clause              241
;  :final-checks            2
;  :max-generation          3
;  :max-memory              4.75
;  :memory                  4.75
;  :mk-bool-var             972
;  :mk-clause               275
;  :num-allocs              165210
;  :num-checks              27
;  :propagations            116
;  :quant-instantiations    207
;  :rlimit-count            215334)
; Definitional axioms for inverse functions
(assert (forall ((i1@41@04 Int)) (!
  (implies
    (and (and (< i1@41@04 V@15@04) (<= 0 i1@41@04)) (< $Perm.No $k@42@04))
    (=
      (inv@43@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@41@04))
      i1@41@04))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@41@04))
  :qid |option$array$-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and (< (inv@43@04 r) V@15@04) (<= 0 (inv@43@04 r)))
      (< $Perm.No $k@42@04))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) (inv@43@04 r))
      r))
  :pattern ((inv@43@04 r))
  :qid |option$array$-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@43@04 r) V@15@04) (<= 0 (inv@43@04 r)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@22@04  $FVF<option<array>>) r) r))
  :pattern ((inv@43@04 r))
  )))
; Precomputing data for removing quantified permissions
(define-fun pTaken@44@04 ((r $Ref)) $Perm
  (ite
    (and (< (inv@43@04 r) V@15@04) (<= 0 (inv@43@04 r)))
    ($Perm.min
      (ite
        (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
        $k@20@04
        $Perm.No)
      $k@42@04)
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Constrain original permissions $k@42@04
(assert (forall ((r $Ref)) (!
  (implies
    (not
      (=
        (ite
          (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
          $k@20@04
          $Perm.No)
        $Perm.No))
    (ite
      (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
      (<
        (ite
          (and (< (inv@43@04 r) V@15@04) (<= 0 (inv@43@04 r)))
          $k@42@04
          $Perm.No)
        $k@20@04)
      (<
        (ite
          (and (< (inv@43@04 r) V@15@04) (<= 0 (inv@43@04 r)))
          $k@42@04
          $Perm.No)
        $Perm.No)))
  :pattern ((inv@21@04 r))
  :pattern ((inv@43@04 r))
  :qid |qp.srp12|)))
; Intermediate check if already taken enough permissions
(set-option :timeout 500)
(push) ; 3
(assert (not (forall ((r $Ref)) (!
  (implies
    (and (< (inv@43@04 r) V@15@04) (<= 0 (inv@43@04 r)))
    (= (- $k@42@04 (pTaken@44@04 r)) $Perm.No))
  
  ))))
(check-sat)
; unsat
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               405
;  :arith-add-rows          207
;  :arith-assert-diseq      27
;  :arith-assert-lower      122
;  :arith-assert-upper      52
;  :arith-bound-prop        23
;  :arith-conflicts         11
;  :arith-eq-adapter        67
;  :arith-fixed-eqs         20
;  :arith-offset-eqs        12
;  :arith-pivots            90
;  :conflicts               34
;  :datatype-accessor-ax    21
;  :datatype-constructor-ax 16
;  :datatype-occurs-check   9
;  :datatype-splits         8
;  :decisions               24
;  :del-clause              325
;  :final-checks            4
;  :max-generation          4
;  :max-memory              4.80
;  :memory                  4.79
;  :minimized-lits          1
;  :mk-bool-var             1103
;  :mk-clause               357
;  :num-allocs              167415
;  :num-checks              29
;  :propagations            164
;  :quant-instantiations    226
;  :rlimit-count            219534
;  :time                    0.00)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@45@04 $FVF<option<array>>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (iff
    (Set_in r ($FVF.domain_option$array$ (as sm@45@04  $FVF<option<array>>)))
    (and
      (and (< (inv@43@04 r) V@15@04) (<= 0 (inv@43@04 r)))
      (< $Perm.No $k@42@04)))
  :pattern ((Set_in r ($FVF.domain_option$array$ (as sm@45@04  $FVF<option<array>>))))
  :qid |qp.fvfDomDef15|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@43@04 r) V@15@04) (<= 0 (inv@43@04 r)))
        (< $Perm.No $k@42@04))
      (ite
        (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
        (< $Perm.No $k@20@04)
        false))
    (=
      ($FVF.lookup_option$array$ (as sm@45@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@45@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r))
  :qid |qp.fvfValDef13|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r)
  :pattern (($FVF.lookup_option$array$ (as sm@45@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef14|)))
; [eval] (forall i1: Int :: 0 <= i1 && i1 < V ==> aloc(opt_get1(G), i1).option$array$ != (None(): option[array]))
(declare-const i1@46@04 Int)
(push) ; 3
; [eval] 0 <= i1 && i1 < V ==> aloc(opt_get1(G), i1).option$array$ != (None(): option[array])
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 4
; [then-branch: 16 | 0 <= i1@46@04 | live]
; [else-branch: 16 | !(0 <= i1@46@04) | live]
(push) ; 5
; [then-branch: 16 | 0 <= i1@46@04]
(assert (<= 0 i1@46@04))
; [eval] i1 < V
(pop) ; 5
(push) ; 5
; [else-branch: 16 | !(0 <= i1@46@04)]
(assert (not (<= 0 i1@46@04)))
(pop) ; 5
(pop) ; 4
; Joined path conditions
; Joined path conditions
(push) ; 4
; [then-branch: 17 | i1@46@04 < V@15@04 && 0 <= i1@46@04 | live]
; [else-branch: 17 | !(i1@46@04 < V@15@04 && 0 <= i1@46@04) | live]
(push) ; 5
; [then-branch: 17 | i1@46@04 < V@15@04 && 0 <= i1@46@04]
(assert (and (< i1@46@04 V@15@04) (<= 0 i1@46@04)))
; [eval] aloc(opt_get1(G), i1).option$array$ != (None(): option[array])
; [eval] aloc(opt_get1(G), i1)
; [eval] opt_get1(G)
(push) ; 6
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 6
; Joined path conditions
(push) ; 6
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 7
(assert (not (< i1@46@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               405
;  :arith-add-rows          208
;  :arith-assert-diseq      27
;  :arith-assert-lower      124
;  :arith-assert-upper      52
;  :arith-bound-prop        23
;  :arith-conflicts         11
;  :arith-eq-adapter        67
;  :arith-fixed-eqs         20
;  :arith-offset-eqs        12
;  :arith-pivots            91
;  :conflicts               34
;  :datatype-accessor-ax    21
;  :datatype-constructor-ax 16
;  :datatype-occurs-check   9
;  :datatype-splits         8
;  :decisions               24
;  :del-clause              325
;  :final-checks            4
;  :max-generation          4
;  :max-memory              4.80
;  :memory                  4.79
;  :minimized-lits          1
;  :mk-bool-var             1108
;  :mk-clause               357
;  :num-allocs              168010
;  :num-checks              30
;  :propagations            164
;  :quant-instantiations    226
;  :rlimit-count            220884)
(assert (< i1@46@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(pop) ; 6
; Joined path conditions
(assert (< i1@46@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(declare-const sm@47@04 $FVF<option<array>>)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
      (< $Perm.No $k@20@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@47@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@47@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r))
  :qid |qp.fvfValDef16|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r)
  :pattern (($FVF.lookup_option$array$ (as sm@47@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef17|)))
(declare-const pm@48@04 $FPM)
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@48@04  $FPM) r)
    (ite (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r))) $k@20@04 $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@48@04  $FPM) r))
  :qid |qp.resPrmSumDef18|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@47@04  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@48@04  $FPM) r))
  :qid |qp.resTrgDef19|)))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@47@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@46@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@46@04)))
(push) ; 6
(assert (not (<
  $Perm.No
  ($FVF.perm_option$array$ (as pm@48@04  $FPM) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@46@04)))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               447
;  :arith-add-rows          229
;  :arith-assert-diseq      30
;  :arith-assert-lower      135
;  :arith-assert-upper      59
;  :arith-bound-prop        27
;  :arith-conflicts         13
;  :arith-eq-adapter        76
;  :arith-fixed-eqs         25
;  :arith-offset-eqs        19
;  :arith-pivots            101
;  :conflicts               37
;  :datatype-accessor-ax    21
;  :datatype-constructor-ax 16
;  :datatype-occurs-check   9
;  :datatype-splits         8
;  :decisions               26
;  :del-clause              329
;  :final-checks            4
;  :max-generation          4
;  :max-memory              4.82
;  :memory                  4.82
;  :minimized-lits          1
;  :mk-bool-var             1183
;  :mk-clause               391
;  :num-allocs              169199
;  :num-checks              31
;  :propagations            179
;  :quant-instantiations    250
;  :rlimit-count            223975)
; [eval] (None(): option[array])
(pop) ; 5
(push) ; 5
; [else-branch: 17 | !(i1@46@04 < V@15@04 && 0 <= i1@46@04)]
(assert (not (and (< i1@46@04 V@15@04) (<= 0 i1@46@04))))
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
      (< $Perm.No $k@20@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@47@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@47@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r))
  :qid |qp.fvfValDef16|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r)
  :pattern (($FVF.lookup_option$array$ (as sm@47@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef17|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@48@04  $FPM) r)
    (ite (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r))) $k@20@04 $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@48@04  $FPM) r))
  :qid |qp.resPrmSumDef18|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@47@04  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@48@04  $FPM) r))
  :qid |qp.resTrgDef19|)))
(assert (implies
  (and (< i1@46@04 V@15@04) (<= 0 i1@46@04))
  (and
    (< i1@46@04 V@15@04)
    (<= 0 i1@46@04)
    (< i1@46@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@47@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@46@04)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@46@04)))))
; Joined path conditions
(pop) ; 3
; Nested auxiliary terms: globals (aux)
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
      (< $Perm.No $k@20@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@47@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@47@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r))
  :qid |qp.fvfValDef16|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r)
  :pattern (($FVF.lookup_option$array$ (as sm@47@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef17|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@48@04  $FPM) r)
    (ite (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r))) $k@20@04 $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@48@04  $FPM) r))
  :qid |qp.resPrmSumDef18|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@47@04  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@48@04  $FPM) r))
  :qid |qp.resTrgDef19|)))
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
; Nested auxiliary terms: non-globals (tlq)
(push) ; 3
(assert (not (forall ((i1@46@04 Int)) (!
  (implies
    (and (< i1@46@04 V@15@04) (<= 0 i1@46@04))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@47@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@46@04))
        (as None<option<array>>  option<array>))))
  
  :qid |prog.l<no position>|))))
(check-sat)
; unsat
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               480
;  :arith-add-rows          253
;  :arith-assert-diseq      30
;  :arith-assert-lower      141
;  :arith-assert-upper      63
;  :arith-bound-prop        33
;  :arith-conflicts         14
;  :arith-eq-adapter        79
;  :arith-fixed-eqs         28
;  :arith-offset-eqs        26
;  :arith-pivots            115
;  :conflicts               43
;  :datatype-accessor-ax    21
;  :datatype-constructor-ax 20
;  :datatype-occurs-check   9
;  :datatype-splits         8
;  :decisions               31
;  :del-clause              398
;  :final-checks            4
;  :max-generation          4
;  :max-memory              4.82
;  :memory                  4.81
;  :minimized-lits          1
;  :mk-bool-var             1242
;  :mk-clause               430
;  :num-allocs              170419
;  :num-checks              32
;  :propagations            183
;  :quant-instantiations    272
;  :rlimit-count            227212
;  :time                    0.00)
(assert (forall ((i1@46@04 Int)) (!
  (implies
    (and (< i1@46@04 V@15@04) (<= 0 i1@46@04))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@47@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@46@04))
        (as None<option<array>>  option<array>))))
  
  :qid |prog.l<no position>|)))
; [eval] (forall i1: Int :: 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(G), i1).option$array$)) == V)
(declare-const i1@49@04 Int)
(push) ; 3
; [eval] 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(G), i1).option$array$)) == V
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 4
; [then-branch: 18 | 0 <= i1@49@04 | live]
; [else-branch: 18 | !(0 <= i1@49@04) | live]
(push) ; 5
; [then-branch: 18 | 0 <= i1@49@04]
(assert (<= 0 i1@49@04))
; [eval] i1 < V
(pop) ; 5
(push) ; 5
; [else-branch: 18 | !(0 <= i1@49@04)]
(assert (not (<= 0 i1@49@04)))
(pop) ; 5
(pop) ; 4
; Joined path conditions
; Joined path conditions
(push) ; 4
; [then-branch: 19 | i1@49@04 < V@15@04 && 0 <= i1@49@04 | live]
; [else-branch: 19 | !(i1@49@04 < V@15@04 && 0 <= i1@49@04) | live]
(push) ; 5
; [then-branch: 19 | i1@49@04 < V@15@04 && 0 <= i1@49@04]
(assert (and (< i1@49@04 V@15@04) (<= 0 i1@49@04)))
; [eval] alen(opt_get1(aloc(opt_get1(G), i1).option$array$)) == V
; [eval] alen(opt_get1(aloc(opt_get1(G), i1).option$array$))
; [eval] opt_get1(aloc(opt_get1(G), i1).option$array$)
; [eval] aloc(opt_get1(G), i1)
; [eval] opt_get1(G)
(push) ; 6
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 6
; Joined path conditions
(push) ; 6
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 7
(assert (not (< i1@49@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               480
;  :arith-add-rows          254
;  :arith-assert-diseq      30
;  :arith-assert-lower      143
;  :arith-assert-upper      63
;  :arith-bound-prop        33
;  :arith-conflicts         14
;  :arith-eq-adapter        79
;  :arith-fixed-eqs         28
;  :arith-offset-eqs        26
;  :arith-pivots            115
;  :conflicts               43
;  :datatype-accessor-ax    21
;  :datatype-constructor-ax 20
;  :datatype-occurs-check   9
;  :datatype-splits         8
;  :decisions               31
;  :del-clause              398
;  :final-checks            4
;  :max-generation          4
;  :max-memory              4.84
;  :memory                  4.84
;  :minimized-lits          1
;  :mk-bool-var             1245
;  :mk-clause               430
;  :num-allocs              170748
;  :num-checks              33
;  :propagations            183
;  :quant-instantiations    272
;  :rlimit-count            227682)
(assert (< i1@49@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(pop) ; 6
; Joined path conditions
(assert (< i1@49@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(declare-const sm@50@04 $FVF<option<array>>)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
      (< $Perm.No $k@20@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@50@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@50@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r))
  :qid |qp.fvfValDef20|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r)
  :pattern (($FVF.lookup_option$array$ (as sm@50@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef21|)))
(declare-const pm@51@04 $FPM)
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@51@04  $FPM) r)
    (ite (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r))) $k@20@04 $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@51@04  $FPM) r))
  :qid |qp.resPrmSumDef22|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@50@04  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@51@04  $FPM) r))
  :qid |qp.resTrgDef23|)))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@50@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@49@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@49@04)))
(push) ; 6
(assert (not (<
  $Perm.No
  ($FVF.perm_option$array$ (as pm@51@04  $FPM) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@49@04)))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               517
;  :arith-add-rows          274
;  :arith-assert-diseq      33
;  :arith-assert-lower      154
;  :arith-assert-upper      70
;  :arith-bound-prop        36
;  :arith-conflicts         16
;  :arith-eq-adapter        88
;  :arith-fixed-eqs         33
;  :arith-offset-eqs        26
;  :arith-pivots            124
;  :conflicts               46
;  :datatype-accessor-ax    21
;  :datatype-constructor-ax 20
;  :datatype-occurs-check   9
;  :datatype-splits         8
;  :decisions               33
;  :del-clause              402
;  :final-checks            4
;  :max-generation          4
;  :max-memory              4.86
;  :memory                  4.86
;  :minimized-lits          1
;  :mk-bool-var             1322
;  :mk-clause               465
;  :num-allocs              171901
;  :num-checks              34
;  :propagations            197
;  :quant-instantiations    298
;  :rlimit-count            230812)
(push) ; 6
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 7
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@50@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@49@04))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               547
;  :arith-add-rows          281
;  :arith-assert-diseq      33
;  :arith-assert-lower      155
;  :arith-assert-upper      71
;  :arith-bound-prop        39
;  :arith-conflicts         17
;  :arith-eq-adapter        88
;  :arith-fixed-eqs         33
;  :arith-offset-eqs        33
;  :arith-pivots            125
;  :conflicts               52
;  :datatype-accessor-ax    21
;  :datatype-constructor-ax 24
;  :datatype-occurs-check   9
;  :datatype-splits         8
;  :decisions               38
;  :del-clause              405
;  :final-checks            4
;  :max-generation          4
;  :max-memory              4.86
;  :memory                  4.86
;  :minimized-lits          1
;  :mk-bool-var             1323
;  :mk-clause               468
;  :num-allocs              172001
;  :num-checks              35
;  :propagations            209
;  :quant-instantiations    298
;  :rlimit-count            231158)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@50@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@49@04))
    (as None<option<array>>  option<array>))))
(pop) ; 6
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@50@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@49@04))
    (as None<option<array>>  option<array>))))
(pop) ; 5
(push) ; 5
; [else-branch: 19 | !(i1@49@04 < V@15@04 && 0 <= i1@49@04)]
(assert (not (and (< i1@49@04 V@15@04) (<= 0 i1@49@04))))
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
      (< $Perm.No $k@20@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@50@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@50@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r))
  :qid |qp.fvfValDef20|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r)
  :pattern (($FVF.lookup_option$array$ (as sm@50@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef21|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@51@04  $FPM) r)
    (ite (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r))) $k@20@04 $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@51@04  $FPM) r))
  :qid |qp.resPrmSumDef22|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@50@04  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@51@04  $FPM) r))
  :qid |qp.resTrgDef23|)))
(assert (implies
  (and (< i1@49@04 V@15@04) (<= 0 i1@49@04))
  (and
    (< i1@49@04 V@15@04)
    (<= 0 i1@49@04)
    (< i1@49@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@50@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@49@04)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@49@04))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@50@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@49@04))
        (as None<option<array>>  option<array>))))))
; Joined path conditions
(pop) ; 3
; Nested auxiliary terms: globals (aux)
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
      (< $Perm.No $k@20@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@50@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@50@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r))
  :qid |qp.fvfValDef20|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r)
  :pattern (($FVF.lookup_option$array$ (as sm@50@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef21|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@51@04  $FPM) r)
    (ite (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r))) $k@20@04 $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@51@04  $FPM) r))
  :qid |qp.resPrmSumDef22|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@50@04  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@51@04  $FPM) r))
  :qid |qp.resTrgDef23|)))
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
; Nested auxiliary terms: non-globals (tlq)
(push) ; 3
(assert (not (forall ((i1@49@04 Int)) (!
  (implies
    (and (< i1@49@04 V@15@04) (<= 0 i1@49@04))
    (=
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@50@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@49@04))))
      V@15@04))
  
  :qid |prog.l<no position>|))))
(check-sat)
; unsat
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               599
;  :arith-add-rows          304
;  :arith-assert-diseq      35
;  :arith-assert-lower      162
;  :arith-assert-upper      75
;  :arith-bound-prop        45
;  :arith-conflicts         18
;  :arith-eq-adapter        92
;  :arith-fixed-eqs         36
;  :arith-offset-eqs        40
;  :arith-pivots            140
;  :conflicts               59
;  :datatype-accessor-ax    21
;  :datatype-constructor-ax 28
;  :datatype-occurs-check   9
;  :datatype-splits         8
;  :decisions               44
;  :del-clause              482
;  :final-checks            4
;  :max-generation          4
;  :max-memory              4.86
;  :memory                  4.85
;  :minimized-lits          1
;  :mk-bool-var             1395
;  :mk-clause               514
;  :num-allocs              173284
;  :num-checks              36
;  :propagations            230
;  :quant-instantiations    329
;  :rlimit-count            234718)
(assert (forall ((i1@49@04 Int)) (!
  (implies
    (and (< i1@49@04 V@15@04) (<= 0 i1@49@04))
    (=
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@50@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@49@04))))
      V@15@04))
  
  :qid |prog.l<no position>|)))
; [eval] (forall i1: Int :: (forall i2: Int :: { aloc(opt_get1(G), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(G), i1).option$array$ == aloc(opt_get1(G), i2).option$array$ ==> i1 == i2))
(declare-const i1@52@04 Int)
(push) ; 3
; [eval] (forall i2: Int :: { aloc(opt_get1(G), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(G), i1).option$array$ == aloc(opt_get1(G), i2).option$array$ ==> i1 == i2)
(declare-const i2@53@04 Int)
(push) ; 4
; [eval] 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(G), i1).option$array$ == aloc(opt_get1(G), i2).option$array$ ==> i1 == i2
; [eval] 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(G), i1).option$array$ == aloc(opt_get1(G), i2).option$array$
; [eval] 0 <= i1
(push) ; 5
; [then-branch: 20 | 0 <= i1@52@04 | live]
; [else-branch: 20 | !(0 <= i1@52@04) | live]
(push) ; 6
; [then-branch: 20 | 0 <= i1@52@04]
(assert (<= 0 i1@52@04))
; [eval] i1 < V
(push) ; 7
; [then-branch: 21 | i1@52@04 < V@15@04 | live]
; [else-branch: 21 | !(i1@52@04 < V@15@04) | live]
(push) ; 8
; [then-branch: 21 | i1@52@04 < V@15@04]
(assert (< i1@52@04 V@15@04))
; [eval] 0 <= i2
(push) ; 9
; [then-branch: 22 | 0 <= i2@53@04 | live]
; [else-branch: 22 | !(0 <= i2@53@04) | live]
(push) ; 10
; [then-branch: 22 | 0 <= i2@53@04]
(assert (<= 0 i2@53@04))
; [eval] i2 < V
(push) ; 11
; [then-branch: 23 | i2@53@04 < V@15@04 | live]
; [else-branch: 23 | !(i2@53@04 < V@15@04) | live]
(push) ; 12
; [then-branch: 23 | i2@53@04 < V@15@04]
(assert (< i2@53@04 V@15@04))
; [eval] aloc(opt_get1(G), i1).option$array$ == aloc(opt_get1(G), i2).option$array$
; [eval] aloc(opt_get1(G), i1)
; [eval] opt_get1(G)
(push) ; 13
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 13
; Joined path conditions
(push) ; 13
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 14
(assert (not (< i1@52@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))))
(check-sat)
; unsat
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               599
;  :arith-add-rows          306
;  :arith-assert-diseq      35
;  :arith-assert-lower      166
;  :arith-assert-upper      75
;  :arith-bound-prop        45
;  :arith-conflicts         18
;  :arith-eq-adapter        92
;  :arith-fixed-eqs         36
;  :arith-offset-eqs        40
;  :arith-pivots            140
;  :conflicts               59
;  :datatype-accessor-ax    21
;  :datatype-constructor-ax 28
;  :datatype-occurs-check   9
;  :datatype-splits         8
;  :decisions               44
;  :del-clause              482
;  :final-checks            4
;  :max-generation          4
;  :max-memory              4.86
;  :memory                  4.86
;  :minimized-lits          1
;  :mk-bool-var             1400
;  :mk-clause               514
;  :num-allocs              173806
;  :num-checks              37
;  :propagations            230
;  :quant-instantiations    329
;  :rlimit-count            235351)
(assert (< i1@52@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(pop) ; 13
; Joined path conditions
(assert (< i1@52@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(declare-const sm@54@04 $FVF<option<array>>)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
      (< $Perm.No $k@20@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@54@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@54@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r))
  :qid |qp.fvfValDef24|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r)
  :pattern (($FVF.lookup_option$array$ (as sm@54@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef25|)))
(declare-const pm@55@04 $FPM)
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@55@04  $FPM) r)
    (ite (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r))) $k@20@04 $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@55@04  $FPM) r))
  :qid |qp.resPrmSumDef26|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@54@04  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@55@04  $FPM) r))
  :qid |qp.resTrgDef27|)))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@54@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@52@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@52@04)))
(push) ; 13
(assert (not (<
  $Perm.No
  ($FVF.perm_option$array$ (as pm@55@04  $FPM) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@52@04)))))
(check-sat)
; unsat
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               646
;  :arith-add-rows          325
;  :arith-assert-diseq      38
;  :arith-assert-lower      179
;  :arith-assert-upper      83
;  :arith-bound-prop        48
;  :arith-conflicts         20
;  :arith-eq-adapter        102
;  :arith-fixed-eqs         42
;  :arith-offset-eqs        40
;  :arith-pivots            149
;  :conflicts               62
;  :datatype-accessor-ax    21
;  :datatype-constructor-ax 28
;  :datatype-occurs-check   9
;  :datatype-splits         8
;  :decisions               46
;  :del-clause              486
;  :final-checks            4
;  :max-generation          4
;  :max-memory              4.89
;  :memory                  4.89
;  :minimized-lits          1
;  :mk-bool-var             1488
;  :mk-clause               552
;  :num-allocs              175020
;  :num-checks              38
;  :propagations            248
;  :quant-instantiations    363
;  :rlimit-count            238645)
; [eval] aloc(opt_get1(G), i2)
; [eval] opt_get1(G)
(push) ; 13
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 13
; Joined path conditions
(push) ; 13
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 14
(assert (not (< i2@53@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))))
(check-sat)
; unsat
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               646
;  :arith-add-rows          325
;  :arith-assert-diseq      38
;  :arith-assert-lower      179
;  :arith-assert-upper      83
;  :arith-bound-prop        48
;  :arith-conflicts         20
;  :arith-eq-adapter        102
;  :arith-fixed-eqs         42
;  :arith-offset-eqs        40
;  :arith-pivots            149
;  :conflicts               62
;  :datatype-accessor-ax    21
;  :datatype-constructor-ax 28
;  :datatype-occurs-check   9
;  :datatype-splits         8
;  :decisions               46
;  :del-clause              486
;  :final-checks            4
;  :max-generation          4
;  :max-memory              4.89
;  :memory                  4.89
;  :minimized-lits          1
;  :mk-bool-var             1488
;  :mk-clause               552
;  :num-allocs              175046
;  :num-checks              39
;  :propagations            248
;  :quant-instantiations    363
;  :rlimit-count            238675)
(assert (< i2@53@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(pop) ; 13
; Joined path conditions
(assert (< i2@53@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(declare-const sm@56@04 $FVF<option<array>>)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
      (< $Perm.No $k@20@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@56@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@56@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r))
  :qid |qp.fvfValDef28|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r)
  :pattern (($FVF.lookup_option$array$ (as sm@56@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef29|)))
(declare-const pm@57@04 $FPM)
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@57@04  $FPM) r)
    (ite (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r))) $k@20@04 $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@57@04  $FPM) r))
  :qid |qp.resPrmSumDef30|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@56@04  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@57@04  $FPM) r))
  :qid |qp.resTrgDef31|)))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@56@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@53@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@53@04)))
(push) ; 13
(assert (not (<
  $Perm.No
  ($FVF.perm_option$array$ (as pm@57@04  $FPM) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@53@04)))))
(check-sat)
; unsat
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               696
;  :arith-add-rows          348
;  :arith-assert-diseq      41
;  :arith-assert-lower      192
;  :arith-assert-upper      91
;  :arith-bound-prop        51
;  :arith-conflicts         22
;  :arith-eq-adapter        113
;  :arith-fixed-eqs         48
;  :arith-offset-eqs        40
;  :arith-pivots            158
;  :conflicts               65
;  :datatype-accessor-ax    21
;  :datatype-constructor-ax 28
;  :datatype-occurs-check   9
;  :datatype-splits         8
;  :decisions               48
;  :del-clause              490
;  :final-checks            4
;  :max-generation          4
;  :max-memory              4.99
;  :memory                  4.99
;  :minimized-lits          1
;  :mk-bool-var             1596
;  :mk-clause               612
;  :num-allocs              176466
;  :num-checks              40
;  :propagations            274
;  :quant-instantiations    402
;  :rlimit-count            242330)
(pop) ; 12
(push) ; 12
; [else-branch: 23 | !(i2@53@04 < V@15@04)]
(assert (not (< i2@53@04 V@15@04)))
(pop) ; 12
(pop) ; 11
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
      (< $Perm.No $k@20@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@54@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@54@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r))
  :qid |qp.fvfValDef24|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r)
  :pattern (($FVF.lookup_option$array$ (as sm@54@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef25|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@55@04  $FPM) r)
    (ite (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r))) $k@20@04 $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@55@04  $FPM) r))
  :qid |qp.resPrmSumDef26|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@54@04  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@55@04  $FPM) r))
  :qid |qp.resTrgDef27|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
      (< $Perm.No $k@20@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@56@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@56@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r))
  :qid |qp.fvfValDef28|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r)
  :pattern (($FVF.lookup_option$array$ (as sm@56@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef29|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@57@04  $FPM) r)
    (ite (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r))) $k@20@04 $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@57@04  $FPM) r))
  :qid |qp.resPrmSumDef30|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@56@04  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@57@04  $FPM) r))
  :qid |qp.resTrgDef31|)))
(assert (implies
  (< i2@53@04 V@15@04)
  (and
    (< i2@53@04 V@15@04)
    (< i1@52@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@54@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@52@04)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@52@04))
    (< i2@53@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@56@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@53@04)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@53@04)))))
; Joined path conditions
(pop) ; 10
(push) ; 10
; [else-branch: 22 | !(0 <= i2@53@04)]
(assert (not (<= 0 i2@53@04)))
(pop) ; 10
(pop) ; 9
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
      (< $Perm.No $k@20@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@54@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@54@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r))
  :qid |qp.fvfValDef24|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r)
  :pattern (($FVF.lookup_option$array$ (as sm@54@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef25|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@55@04  $FPM) r)
    (ite (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r))) $k@20@04 $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@55@04  $FPM) r))
  :qid |qp.resPrmSumDef26|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@54@04  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@55@04  $FPM) r))
  :qid |qp.resTrgDef27|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
      (< $Perm.No $k@20@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@56@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@56@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r))
  :qid |qp.fvfValDef28|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r)
  :pattern (($FVF.lookup_option$array$ (as sm@56@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef29|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@57@04  $FPM) r)
    (ite (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r))) $k@20@04 $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@57@04  $FPM) r))
  :qid |qp.resPrmSumDef30|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@56@04  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@57@04  $FPM) r))
  :qid |qp.resTrgDef31|)))
(assert (implies
  (<= 0 i2@53@04)
  (and
    (<= 0 i2@53@04)
    (implies
      (< i2@53@04 V@15@04)
      (and
        (< i2@53@04 V@15@04)
        (< i1@52@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@54@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@52@04)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@52@04))
        (< i2@53@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@56@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@53@04)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@53@04)))))))
; Joined path conditions
(pop) ; 8
(push) ; 8
; [else-branch: 21 | !(i1@52@04 < V@15@04)]
(assert (not (< i1@52@04 V@15@04)))
(pop) ; 8
(pop) ; 7
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
      (< $Perm.No $k@20@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@54@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@54@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r))
  :qid |qp.fvfValDef24|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r)
  :pattern (($FVF.lookup_option$array$ (as sm@54@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef25|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@55@04  $FPM) r)
    (ite (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r))) $k@20@04 $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@55@04  $FPM) r))
  :qid |qp.resPrmSumDef26|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@54@04  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@55@04  $FPM) r))
  :qid |qp.resTrgDef27|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
      (< $Perm.No $k@20@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@56@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@56@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r))
  :qid |qp.fvfValDef28|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r)
  :pattern (($FVF.lookup_option$array$ (as sm@56@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef29|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@57@04  $FPM) r)
    (ite (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r))) $k@20@04 $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@57@04  $FPM) r))
  :qid |qp.resPrmSumDef30|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@56@04  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@57@04  $FPM) r))
  :qid |qp.resTrgDef31|)))
(assert (implies
  (< i1@52@04 V@15@04)
  (and
    (< i1@52@04 V@15@04)
    (implies
      (<= 0 i2@53@04)
      (and
        (<= 0 i2@53@04)
        (implies
          (< i2@53@04 V@15@04)
          (and
            (< i2@53@04 V@15@04)
            (< i1@52@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@54@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@52@04)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@52@04))
            (< i2@53@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@56@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@53@04)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@53@04)))))))))
; Joined path conditions
(pop) ; 6
(push) ; 6
; [else-branch: 20 | !(0 <= i1@52@04)]
(assert (not (<= 0 i1@52@04)))
(pop) ; 6
(pop) ; 5
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
      (< $Perm.No $k@20@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@54@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@54@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r))
  :qid |qp.fvfValDef24|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r)
  :pattern (($FVF.lookup_option$array$ (as sm@54@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef25|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@55@04  $FPM) r)
    (ite (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r))) $k@20@04 $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@55@04  $FPM) r))
  :qid |qp.resPrmSumDef26|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@54@04  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@55@04  $FPM) r))
  :qid |qp.resTrgDef27|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
      (< $Perm.No $k@20@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@56@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@56@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r))
  :qid |qp.fvfValDef28|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r)
  :pattern (($FVF.lookup_option$array$ (as sm@56@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef29|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@57@04  $FPM) r)
    (ite (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r))) $k@20@04 $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@57@04  $FPM) r))
  :qid |qp.resPrmSumDef30|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@56@04  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@57@04  $FPM) r))
  :qid |qp.resTrgDef31|)))
(assert (implies
  (<= 0 i1@52@04)
  (and
    (<= 0 i1@52@04)
    (implies
      (< i1@52@04 V@15@04)
      (and
        (< i1@52@04 V@15@04)
        (implies
          (<= 0 i2@53@04)
          (and
            (<= 0 i2@53@04)
            (implies
              (< i2@53@04 V@15@04)
              (and
                (< i2@53@04 V@15@04)
                (< i1@52@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@54@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@52@04)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@52@04))
                (< i2@53@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@56@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@53@04)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@53@04)))))))))))
; Joined path conditions
(push) ; 5
; [then-branch: 24 | Lookup(option$array$,sm@54@04,aloc((_, _), opt_get1(_, G@11@04), i1@52@04)) == Lookup(option$array$,sm@56@04,aloc((_, _), opt_get1(_, G@11@04), i2@53@04)) && i2@53@04 < V@15@04 && 0 <= i2@53@04 && i1@52@04 < V@15@04 && 0 <= i1@52@04 | live]
; [else-branch: 24 | !(Lookup(option$array$,sm@54@04,aloc((_, _), opt_get1(_, G@11@04), i1@52@04)) == Lookup(option$array$,sm@56@04,aloc((_, _), opt_get1(_, G@11@04), i2@53@04)) && i2@53@04 < V@15@04 && 0 <= i2@53@04 && i1@52@04 < V@15@04 && 0 <= i1@52@04) | live]
(push) ; 6
; [then-branch: 24 | Lookup(option$array$,sm@54@04,aloc((_, _), opt_get1(_, G@11@04), i1@52@04)) == Lookup(option$array$,sm@56@04,aloc((_, _), opt_get1(_, G@11@04), i2@53@04)) && i2@53@04 < V@15@04 && 0 <= i2@53@04 && i1@52@04 < V@15@04 && 0 <= i1@52@04]
(assert (and
  (and
    (and
      (and
        (=
          ($FVF.lookup_option$array$ (as sm@54@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@52@04))
          ($FVF.lookup_option$array$ (as sm@56@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@53@04)))
        (< i2@53@04 V@15@04))
      (<= 0 i2@53@04))
    (< i1@52@04 V@15@04))
  (<= 0 i1@52@04)))
; [eval] i1 == i2
(pop) ; 6
(push) ; 6
; [else-branch: 24 | !(Lookup(option$array$,sm@54@04,aloc((_, _), opt_get1(_, G@11@04), i1@52@04)) == Lookup(option$array$,sm@56@04,aloc((_, _), opt_get1(_, G@11@04), i2@53@04)) && i2@53@04 < V@15@04 && 0 <= i2@53@04 && i1@52@04 < V@15@04 && 0 <= i1@52@04)]
(assert (not
  (and
    (and
      (and
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@54@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@52@04))
            ($FVF.lookup_option$array$ (as sm@56@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@53@04)))
          (< i2@53@04 V@15@04))
        (<= 0 i2@53@04))
      (< i1@52@04 V@15@04))
    (<= 0 i1@52@04))))
(pop) ; 6
(pop) ; 5
; Joined path conditions
(assert (implies
  (and
    (and
      (and
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@54@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@52@04))
            ($FVF.lookup_option$array$ (as sm@56@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@53@04)))
          (< i2@53@04 V@15@04))
        (<= 0 i2@53@04))
      (< i1@52@04 V@15@04))
    (<= 0 i1@52@04))
  (and
    (=
      ($FVF.lookup_option$array$ (as sm@54@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@52@04))
      ($FVF.lookup_option$array$ (as sm@56@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@53@04)))
    (< i2@53@04 V@15@04)
    (<= 0 i2@53@04)
    (< i1@52@04 V@15@04)
    (<= 0 i1@52@04))))
; Joined path conditions
(pop) ; 4
; Nested auxiliary terms: globals (aux)
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
      (< $Perm.No $k@20@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@54@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@54@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r))
  :qid |qp.fvfValDef24|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r)
  :pattern (($FVF.lookup_option$array$ (as sm@54@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef25|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@55@04  $FPM) r)
    (ite (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r))) $k@20@04 $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@55@04  $FPM) r))
  :qid |qp.resPrmSumDef26|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@54@04  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@55@04  $FPM) r))
  :qid |qp.resTrgDef27|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
      (< $Perm.No $k@20@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@56@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@56@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r))
  :qid |qp.fvfValDef28|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r)
  :pattern (($FVF.lookup_option$array$ (as sm@56@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef29|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@57@04  $FPM) r)
    (ite (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r))) $k@20@04 $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@57@04  $FPM) r))
  :qid |qp.resPrmSumDef30|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@56@04  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@57@04  $FPM) r))
  :qid |qp.resTrgDef31|)))
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i2@53@04 Int)) (!
  (and
    (implies
      (<= 0 i1@52@04)
      (and
        (<= 0 i1@52@04)
        (implies
          (< i1@52@04 V@15@04)
          (and
            (< i1@52@04 V@15@04)
            (implies
              (<= 0 i2@53@04)
              (and
                (<= 0 i2@53@04)
                (implies
                  (< i2@53@04 V@15@04)
                  (and
                    (< i2@53@04 V@15@04)
                    (< i1@52@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
                    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@54@04  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@52@04)) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@52@04))
                    (< i2@53@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
                    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@56@04  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@53@04)) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@53@04))))))))))
    (implies
      (and
        (and
          (and
            (and
              (=
                ($FVF.lookup_option$array$ (as sm@54@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@52@04))
                ($FVF.lookup_option$array$ (as sm@56@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@53@04)))
              (< i2@53@04 V@15@04))
            (<= 0 i2@53@04))
          (< i1@52@04 V@15@04))
        (<= 0 i1@52@04))
      (and
        (=
          ($FVF.lookup_option$array$ (as sm@54@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@52@04))
          ($FVF.lookup_option$array$ (as sm@56@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@53@04)))
        (< i2@53@04 V@15@04)
        (<= 0 i2@53@04)
        (< i1@52@04 V@15@04)
        (<= 0 i1@52@04))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@53@04))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 3
; Nested auxiliary terms: globals (aux)
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
      (< $Perm.No $k@20@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@54@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@54@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r))
  :qid |qp.fvfValDef24|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r)
  :pattern (($FVF.lookup_option$array$ (as sm@54@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef25|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@55@04  $FPM) r)
    (ite (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r))) $k@20@04 $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@55@04  $FPM) r))
  :qid |qp.resPrmSumDef26|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@54@04  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@55@04  $FPM) r))
  :qid |qp.resTrgDef27|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
      (< $Perm.No $k@20@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@56@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@56@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r))
  :qid |qp.fvfValDef28|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r)
  :pattern (($FVF.lookup_option$array$ (as sm@56@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef29|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@57@04  $FPM) r)
    (ite (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r))) $k@20@04 $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@57@04  $FPM) r))
  :qid |qp.resPrmSumDef30|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@56@04  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@57@04  $FPM) r))
  :qid |qp.resTrgDef31|)))
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
; Nested auxiliary terms: non-globals (tlq)
(push) ; 3
(assert (not (forall ((i1@52@04 Int)) (!
  (forall ((i2@53@04 Int)) (!
    (implies
      (and
        (and
          (and
            (and
              (=
                ($FVF.lookup_option$array$ (as sm@54@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@52@04))
                ($FVF.lookup_option$array$ (as sm@56@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@53@04)))
              (< i2@53@04 V@15@04))
            (<= 0 i2@53@04))
          (< i1@52@04 V@15@04))
        (<= 0 i1@52@04))
      (= i1@52@04 i2@53@04))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@53@04))
    :qid |prog.l<no position>|))
  
  :qid |prog.l<no position>|))))
(check-sat)
; unsat
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               787
;  :arith-add-rows          425
;  :arith-assert-diseq      43
;  :arith-assert-lower      209
;  :arith-assert-upper      100
;  :arith-bound-prop        64
;  :arith-conflicts         23
;  :arith-eq-adapter        122
;  :arith-fixed-eqs         56
;  :arith-offset-eqs        54
;  :arith-pivots            194
;  :conflicts               72
;  :datatype-accessor-ax    21
;  :datatype-constructor-ax 32
;  :datatype-occurs-check   9
;  :datatype-splits         8
;  :decisions               54
;  :del-clause              698
;  :final-checks            4
;  :max-generation          4
;  :max-memory              5.02
;  :memory                  5.01
;  :minimized-lits          1
;  :mk-bool-var             1779
;  :mk-clause               730
;  :num-allocs              181116
;  :num-checks              41
;  :propagations            301
;  :quant-instantiations    469
;  :rlimit-count            254147
;  :time                    0.00)
(assert (forall ((i1@52@04 Int)) (!
  (forall ((i2@53@04 Int)) (!
    (implies
      (and
        (and
          (and
            (and
              (=
                ($FVF.lookup_option$array$ (as sm@54@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@52@04))
                ($FVF.lookup_option$array$ (as sm@56@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@53@04)))
              (< i2@53@04 V@15@04))
            (<= 0 i2@53@04))
          (< i1@52@04 V@15@04))
        (<= 0 i1@52@04))
      (= i1@52@04 i2@53@04))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@53@04))
    :qid |prog.l<no position>|))
  
  :qid |prog.l<no position>|)))
(declare-const i1@58@04 Int)
(declare-const j@59@04 Int)
(push) ; 3
; [eval] 0 <= i1 && i1 < V && (0 <= j && j < V)
; [eval] 0 <= i1
(push) ; 4
; [then-branch: 25 | 0 <= i1@58@04 | live]
; [else-branch: 25 | !(0 <= i1@58@04) | live]
(push) ; 5
; [then-branch: 25 | 0 <= i1@58@04]
(assert (<= 0 i1@58@04))
; [eval] i1 < V
(push) ; 6
; [then-branch: 26 | i1@58@04 < V@15@04 | live]
; [else-branch: 26 | !(i1@58@04 < V@15@04) | live]
(push) ; 7
; [then-branch: 26 | i1@58@04 < V@15@04]
(assert (< i1@58@04 V@15@04))
; [eval] 0 <= j
(push) ; 8
; [then-branch: 27 | 0 <= j@59@04 | live]
; [else-branch: 27 | !(0 <= j@59@04) | live]
(push) ; 9
; [then-branch: 27 | 0 <= j@59@04]
(assert (<= 0 j@59@04))
; [eval] j < V
(pop) ; 9
(push) ; 9
; [else-branch: 27 | !(0 <= j@59@04)]
(assert (not (<= 0 j@59@04)))
(pop) ; 9
(pop) ; 8
; Joined path conditions
; Joined path conditions
(pop) ; 7
(push) ; 7
; [else-branch: 26 | !(i1@58@04 < V@15@04)]
(assert (not (< i1@58@04 V@15@04)))
(pop) ; 7
(pop) ; 6
; Joined path conditions
; Joined path conditions
(pop) ; 5
(push) ; 5
; [else-branch: 25 | !(0 <= i1@58@04)]
(assert (not (<= 0 i1@58@04)))
(pop) ; 5
(pop) ; 4
; Joined path conditions
; Joined path conditions
(assert (and
  (and (and (< j@59@04 V@15@04) (<= 0 j@59@04)) (< i1@58@04 V@15@04))
  (<= 0 i1@58@04)))
(declare-const $k@60@04 $Perm)
(assert ($Perm.isReadVar $k@60@04 $Perm.Write))
; [eval] aloc(opt_get1(aloc(opt_get1(G), i1).option$array$), j)
; [eval] opt_get1(aloc(opt_get1(G), i1).option$array$)
; [eval] aloc(opt_get1(G), i1)
; [eval] opt_get1(G)
(push) ; 4
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 4
; Joined path conditions
(push) ; 4
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 5
(assert (not (< i1@58@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               787
;  :arith-add-rows          428
;  :arith-assert-diseq      44
;  :arith-assert-lower      217
;  :arith-assert-upper      101
;  :arith-bound-prop        64
;  :arith-conflicts         23
;  :arith-eq-adapter        123
;  :arith-fixed-eqs         56
;  :arith-offset-eqs        54
;  :arith-pivots            198
;  :conflicts               72
;  :datatype-accessor-ax    21
;  :datatype-constructor-ax 32
;  :datatype-occurs-check   9
;  :datatype-splits         8
;  :decisions               54
;  :del-clause              698
;  :final-checks            4
;  :max-generation          4
;  :max-memory              5.02
;  :memory                  5.01
;  :minimized-lits          1
;  :mk-bool-var             1790
;  :mk-clause               732
;  :num-allocs              181792
;  :num-checks              42
;  :propagations            302
;  :quant-instantiations    469
;  :rlimit-count            255259)
(assert (< i1@58@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(pop) ; 4
; Joined path conditions
(assert (< i1@58@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(declare-const sm@61@04 $FVF<option<array>>)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
      (< $Perm.No $k@20@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@61@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@61@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r))
  :qid |qp.fvfValDef32|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r)
  :pattern (($FVF.lookup_option$array$ (as sm@61@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef33|)))
(declare-const pm@62@04 $FPM)
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@62@04  $FPM) r)
    (ite (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r))) $k@20@04 $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@62@04  $FPM) r))
  :qid |qp.resPrmSumDef34|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@61@04  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@62@04  $FPM) r))
  :qid |qp.resTrgDef35|)))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@61@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@58@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@58@04)))
(push) ; 4
(assert (not (<
  $Perm.No
  ($FVF.perm_option$array$ (as pm@62@04  $FPM) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@58@04)))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               849
;  :arith-add-rows          450
;  :arith-assert-diseq      47
;  :arith-assert-lower      230
;  :arith-assert-upper      109
;  :arith-bound-prop        68
;  :arith-conflicts         25
;  :arith-eq-adapter        133
;  :arith-fixed-eqs         62
;  :arith-offset-eqs        61
;  :arith-pivots            206
;  :conflicts               75
;  :datatype-accessor-ax    21
;  :datatype-constructor-ax 32
;  :datatype-occurs-check   9
;  :datatype-splits         8
;  :decisions               56
;  :del-clause              702
;  :final-checks            4
;  :max-generation          4
;  :max-memory              5.03
;  :memory                  5.02
;  :minimized-lits          1
;  :mk-bool-var             1882
;  :mk-clause               772
;  :num-allocs              183047
;  :num-checks              43
;  :propagations            327
;  :quant-instantiations    506
;  :rlimit-count            258768)
(push) ; 4
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 5
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@61@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@58@04))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               868
;  :arith-add-rows          457
;  :arith-assert-diseq      47
;  :arith-assert-lower      231
;  :arith-assert-upper      110
;  :arith-bound-prop        70
;  :arith-conflicts         26
;  :arith-eq-adapter        133
;  :arith-fixed-eqs         62
;  :arith-offset-eqs        61
;  :arith-pivots            207
;  :conflicts               81
;  :datatype-accessor-ax    21
;  :datatype-constructor-ax 36
;  :datatype-occurs-check   9
;  :datatype-splits         8
;  :decisions               61
;  :del-clause              704
;  :final-checks            4
;  :max-generation          4
;  :max-memory              5.03
;  :memory                  5.02
;  :minimized-lits          1
;  :mk-bool-var             1883
;  :mk-clause               774
;  :num-allocs              183142
;  :num-checks              44
;  :propagations            328
;  :quant-instantiations    506
;  :rlimit-count            259065)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@61@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@58@04))
    (as None<option<array>>  option<array>))))
(pop) ; 4
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@61@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@58@04))
    (as None<option<array>>  option<array>))))
(push) ; 4
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 5
(assert (not (<
  j@59@04
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@61@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@58@04)))))))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               923
;  :arith-add-rows          468
;  :arith-assert-diseq      47
;  :arith-assert-lower      235
;  :arith-assert-upper      112
;  :arith-bound-prop        72
;  :arith-conflicts         28
;  :arith-eq-adapter        135
;  :arith-fixed-eqs         63
;  :arith-offset-eqs        61
;  :arith-pivots            209
;  :conflicts               87
;  :datatype-accessor-ax    21
;  :datatype-constructor-ax 40
;  :datatype-occurs-check   9
;  :datatype-splits         8
;  :decisions               66
;  :del-clause              707
;  :final-checks            4
;  :max-generation          4
;  :max-memory              5.03
;  :memory                  5.02
;  :minimized-lits          1
;  :mk-bool-var             1900
;  :mk-clause               777
;  :num-allocs              183347
;  :num-checks              45
;  :propagations            352
;  :quant-instantiations    512
;  :rlimit-count            259727)
(assert (<
  j@59@04
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@61@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@58@04))))))
(pop) ; 4
; Joined path conditions
(assert (<
  j@59@04
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@61@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@58@04))))))
(pop) ; 3
(declare-fun inv@63@04 ($Ref) Int)
(declare-fun inv@64@04 ($Ref) Int)
; Nested auxiliary terms: globals
(assert ($Perm.isReadVar $k@60@04 $Perm.Write))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
      (< $Perm.No $k@20@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@61@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@61@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r))
  :qid |qp.fvfValDef32|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r)
  :pattern (($FVF.lookup_option$array$ (as sm@61@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef33|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@62@04  $FPM) r)
    (ite (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r))) $k@20@04 $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@62@04  $FPM) r))
  :qid |qp.resPrmSumDef34|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@61@04  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@62@04  $FPM) r))
  :qid |qp.resTrgDef35|)))
; Nested auxiliary terms: non-globals
(assert (forall ((i1@58@04 Int) (j@59@04 Int)) (!
  (and
    (< i1@58@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@61@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@58@04)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@58@04))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@61@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@58@04))
        (as None<option<array>>  option<array>)))
    (<
      j@59@04
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@61@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@58@04))))))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@61@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@58@04))) j@59@04))
  :qid |int-aux|)))
(push) ; 3
(assert (not (forall ((i1@58@04 Int) (j@59@04 Int)) (!
  (implies
    (and
      (and (and (< j@59@04 V@15@04) (<= 0 j@59@04)) (< i1@58@04 V@15@04))
      (<= 0 i1@58@04))
    (or (= $k@60@04 $Perm.No) (< $Perm.No $k@60@04)))
  
  ))))
(check-sat)
; unsat
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               923
;  :arith-add-rows          474
;  :arith-assert-diseq      48
;  :arith-assert-lower      237
;  :arith-assert-upper      113
;  :arith-bound-prop        72
;  :arith-conflicts         28
;  :arith-eq-adapter        136
;  :arith-fixed-eqs         63
;  :arith-offset-eqs        61
;  :arith-pivots            215
;  :conflicts               88
;  :datatype-accessor-ax    21
;  :datatype-constructor-ax 40
;  :datatype-occurs-check   9
;  :datatype-splits         8
;  :decisions               66
;  :del-clause              745
;  :final-checks            4
;  :max-generation          4
;  :max-memory              5.03
;  :memory                  5.01
;  :minimized-lits          1
;  :mk-bool-var             1913
;  :mk-clause               779
;  :num-allocs              184404
;  :num-checks              46
;  :propagations            353
;  :quant-instantiations    512
;  :rlimit-count            262006)
(declare-const sm@65@04 $FVF<Int>)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@30@04 r) V@15@04) (<= 0 (inv@30@04 r)))
        (< (inv@29@04 r) V@15@04))
      (<= 0 (inv@29@04 r)))
    (=
      ($FVF.lookup_int (as sm@65@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@65@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))))))) r))
  :qid |qp.fvfValDef36|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@33@04 r) V@15@04) (<= 0 (inv@33@04 r)))
    (=
      ($FVF.lookup_int (as sm@65@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04)))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@65@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04)))))))))))))))) r))
  :qid |qp.fvfValDef37|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04)))))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@65@04  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef38|)))
; Check receiver injectivity
(push) ; 3
(assert (not (forall ((i11@58@04 Int) (j1@59@04 Int) (i12@58@04 Int) (j2@59@04 Int)) (!
  (implies
    (and
      (and
        (and
          (and
            (and
              (and (< j1@59@04 V@15@04) (<= 0 j1@59@04))
              (< i11@58@04 V@15@04))
            (<= 0 i11@58@04))
          ($FVF.loc_int ($FVF.lookup_int (as sm@65@04  $FVF<Int>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@61@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i11@58@04))) j1@59@04)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@61@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i11@58@04))) j1@59@04)))
        (< $Perm.No $k@60@04))
      (and
        (and
          (and
            (and
              (and (< j2@59@04 V@15@04) (<= 0 j2@59@04))
              (< i12@58@04 V@15@04))
            (<= 0 i12@58@04))
          ($FVF.loc_int ($FVF.lookup_int (as sm@65@04  $FVF<Int>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@61@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i12@58@04))) j2@59@04)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@61@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i12@58@04))) j2@59@04)))
        (< $Perm.No $k@60@04))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@61@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i11@58@04))) j1@59@04)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@61@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i12@58@04))) j2@59@04)))
    (and (= i11@58@04 i12@58@04) (= j1@59@04 j2@59@04)))
  
  :qid |int-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1149
;  :arith-add-rows          612
;  :arith-assert-diseq      50
;  :arith-assert-lower      272
;  :arith-assert-upper      132
;  :arith-bound-prop        90
;  :arith-conflicts         30
;  :arith-eq-adapter        154
;  :arith-fixed-eqs         79
;  :arith-offset-eqs        79
;  :arith-pivots            256
;  :conflicts               97
;  :datatype-accessor-ax    21
;  :datatype-constructor-ax 44
;  :datatype-occurs-check   9
;  :datatype-splits         8
;  :decisions               74
;  :del-clause              925
;  :final-checks            4
;  :max-generation          4
;  :max-memory              5.31
;  :memory                  5.28
;  :minimized-lits          4
;  :mk-bool-var             2223
;  :mk-clause               959
;  :num-allocs              187112
;  :num-checks              47
;  :propagations            409
;  :quant-instantiations    630
;  :rlimit-count            271937
;  :time                    0.00)
; Definitional axioms for inverse functions
(assert (forall ((i1@58@04 Int) (j@59@04 Int)) (!
  (implies
    (and
      (and
        (and (and (< j@59@04 V@15@04) (<= 0 j@59@04)) (< i1@58@04 V@15@04))
        (<= 0 i1@58@04))
      (< $Perm.No $k@60@04))
    (and
      (=
        (inv@63@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@61@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@58@04))) j@59@04))
        i1@58@04)
      (=
        (inv@64@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@61@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@58@04))) j@59@04))
        j@59@04)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@61@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@58@04))) j@59@04))
  :qid |int-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and
          (and (< (inv@64@04 r) V@15@04) (<= 0 (inv@64@04 r)))
          (< (inv@63@04 r) V@15@04))
        (<= 0 (inv@63@04 r)))
      (< $Perm.No $k@60@04))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@61@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) (inv@63@04 r)))) (inv@64@04 r))
      r))
  :pattern ((inv@63@04 r))
  :pattern ((inv@64@04 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@64@04 r) V@15@04) (<= 0 (inv@64@04 r)))
        (< (inv@63@04 r) V@15@04))
      (<= 0 (inv@63@04 r)))
    ($FVF.loc_int ($FVF.lookup_int (as sm@65@04  $FVF<Int>) r) r))
  :pattern ((inv@63@04 r) (inv@64@04 r))
  )))
; Precomputing data for removing quantified permissions
(define-fun pTaken@66@04 ((r $Ref)) $Perm
  (ite
    (and
      (and
        (and (< (inv@64@04 r) V@15@04) (<= 0 (inv@64@04 r)))
        (< (inv@63@04 r) V@15@04))
      (<= 0 (inv@63@04 r)))
    ($Perm.min
      (ite
        (and
          (and
            (and (< (inv@30@04 r) V@15@04) (<= 0 (inv@30@04 r)))
            (< (inv@29@04 r) V@15@04))
          (<= 0 (inv@29@04 r)))
        $Perm.Write
        $Perm.No)
      $k@60@04)
    $Perm.No))
(define-fun pTaken@67@04 ((r $Ref)) $Perm
  (ite
    (and
      (and
        (and (< (inv@64@04 r) V@15@04) (<= 0 (inv@64@04 r)))
        (< (inv@63@04 r) V@15@04))
      (<= 0 (inv@63@04 r)))
    ($Perm.min
      (ite
        (and (< (inv@33@04 r) V@15@04) (<= 0 (inv@33@04 r)))
        $Perm.Write
        $Perm.No)
      (- $k@60@04 (pTaken@66@04 r)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Constrain original permissions $k@60@04
(assert (forall ((r $Ref)) (!
  (implies
    (not
      (=
        (ite
          (and
            (and
              (and (< (inv@30@04 r) V@15@04) (<= 0 (inv@30@04 r)))
              (< (inv@29@04 r) V@15@04))
            (<= 0 (inv@29@04 r)))
          $Perm.Write
          $Perm.No)
        $Perm.No))
    (ite
      (and
        (and
          (and (< (inv@30@04 r) V@15@04) (<= 0 (inv@30@04 r)))
          (< (inv@29@04 r) V@15@04))
        (<= 0 (inv@29@04 r)))
      (<
        (ite
          (and
            (and
              (and (< (inv@64@04 r) V@15@04) (<= 0 (inv@64@04 r)))
              (< (inv@63@04 r) V@15@04))
            (<= 0 (inv@63@04 r)))
          $k@60@04
          $Perm.No)
        $Perm.Write)
      (<
        (ite
          (and
            (and
              (and (< (inv@64@04 r) V@15@04) (<= 0 (inv@64@04 r)))
              (< (inv@63@04 r) V@15@04))
            (<= 0 (inv@63@04 r)))
          $k@60@04
          $Perm.No)
        $Perm.No)))
  :pattern ((inv@30@04 r))
  :pattern ((inv@29@04 r))
  :pattern ((inv@64@04 r))
  :pattern ((inv@63@04 r))
  :qid |qp.srp39|)))
; Intermediate check if already taken enough permissions
(set-option :timeout 500)
(push) ; 3
(assert (not (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@64@04 r) V@15@04) (<= 0 (inv@64@04 r)))
        (< (inv@63@04 r) V@15@04))
      (<= 0 (inv@63@04 r)))
    (= (- $k@60@04 (pTaken@66@04 r)) $Perm.No))
  
  ))))
(check-sat)
; unsat
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1432
;  :arith-add-rows          736
;  :arith-assert-diseq      54
;  :arith-assert-lower      315
;  :arith-assert-upper      166
;  :arith-bound-prop        104
;  :arith-conflicts         35
;  :arith-eq-adapter        184
;  :arith-fixed-eqs         100
;  :arith-offset-eqs        93
;  :arith-pivots            296
;  :conflicts               109
;  :datatype-accessor-ax    21
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               89
;  :del-clause              1096
;  :final-checks            5
;  :max-generation          4
;  :max-memory              5.32
;  :memory                  5.30
;  :minimized-lits          4
;  :mk-bool-var             2492
;  :mk-clause               1130
;  :num-allocs              190258
;  :num-checks              49
;  :propagations            533
;  :quant-instantiations    715
;  :rlimit-count            281261
;  :time                    0.00)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@68@04 $FVF<Int>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (iff
    (Set_in r ($FVF.domain_int (as sm@68@04  $FVF<Int>)))
    (and
      (and
        (and
          (and (< (inv@64@04 r) V@15@04) (<= 0 (inv@64@04 r)))
          (< (inv@63@04 r) V@15@04))
        (<= 0 (inv@63@04 r)))
      (< $Perm.No $k@60@04)))
  :pattern ((Set_in r ($FVF.domain_int (as sm@68@04  $FVF<Int>))))
  :qid |qp.fvfDomDef43|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and
          (and
            (and (< (inv@64@04 r) V@15@04) (<= 0 (inv@64@04 r)))
            (< (inv@63@04 r) V@15@04))
          (<= 0 (inv@63@04 r)))
        (< $Perm.No $k@60@04))
      (and
        (and
          (and (< (inv@30@04 r) V@15@04) (<= 0 (inv@30@04 r)))
          (< (inv@29@04 r) V@15@04))
        (<= 0 (inv@29@04 r))))
    (=
      ($FVF.lookup_int (as sm@68@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@68@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))))))) r))
  :qid |qp.fvfValDef40|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and
          (and
            (and (< (inv@64@04 r) V@15@04) (<= 0 (inv@64@04 r)))
            (< (inv@63@04 r) V@15@04))
          (<= 0 (inv@63@04 r)))
        (< $Perm.No $k@60@04))
      (and (< (inv@33@04 r) V@15@04) (<= 0 (inv@33@04 r))))
    (=
      ($FVF.lookup_int (as sm@68@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04)))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@68@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04)))))))))))))))) r))
  :qid |qp.fvfValDef41|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04)))))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@68@04  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef42|)))
(pop) ; 2
; Joined path conditions
(assert ($Perm.isReadVar $k@42@04 $Perm.Write))
(assert (forall ((i1@41@04 Int)) (!
  (implies
    (and (and (< i1@41@04 V@15@04) (<= 0 i1@41@04)) (< $Perm.No $k@42@04))
    (=
      (inv@43@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@41@04))
      i1@41@04))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@41@04))
  :qid |option$array$-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and (< (inv@43@04 r) V@15@04) (<= 0 (inv@43@04 r)))
      (< $Perm.No $k@42@04))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) (inv@43@04 r))
      r))
  :pattern ((inv@43@04 r))
  :qid |option$array$-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (iff
    (Set_in r ($FVF.domain_option$array$ (as sm@45@04  $FVF<option<array>>)))
    (and
      (and (< (inv@43@04 r) V@15@04) (<= 0 (inv@43@04 r)))
      (< $Perm.No $k@42@04)))
  :pattern ((Set_in r ($FVF.domain_option$array$ (as sm@45@04  $FVF<option<array>>))))
  :qid |qp.fvfDomDef15|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@43@04 r) V@15@04) (<= 0 (inv@43@04 r)))
        (< $Perm.No $k@42@04))
      (ite
        (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
        (< $Perm.No $k@20@04)
        false))
    (=
      ($FVF.lookup_option$array$ (as sm@45@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@45@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r))
  :qid |qp.fvfValDef13|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r)
  :pattern (($FVF.lookup_option$array$ (as sm@45@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef14|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
      (< $Perm.No $k@20@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@47@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@47@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r))
  :qid |qp.fvfValDef16|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r)
  :pattern (($FVF.lookup_option$array$ (as sm@47@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef17|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@48@04  $FPM) r)
    (ite (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r))) $k@20@04 $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@48@04  $FPM) r))
  :qid |qp.resPrmSumDef18|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@47@04  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@48@04  $FPM) r))
  :qid |qp.resTrgDef19|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
      (< $Perm.No $k@20@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@50@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@50@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r))
  :qid |qp.fvfValDef20|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r)
  :pattern (($FVF.lookup_option$array$ (as sm@50@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef21|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@51@04  $FPM) r)
    (ite (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r))) $k@20@04 $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@51@04  $FPM) r))
  :qid |qp.resPrmSumDef22|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@50@04  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@51@04  $FPM) r))
  :qid |qp.resTrgDef23|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
      (< $Perm.No $k@20@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@54@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@54@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r))
  :qid |qp.fvfValDef24|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r)
  :pattern (($FVF.lookup_option$array$ (as sm@54@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef25|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@55@04  $FPM) r)
    (ite (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r))) $k@20@04 $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@55@04  $FPM) r))
  :qid |qp.resPrmSumDef26|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@54@04  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@55@04  $FPM) r))
  :qid |qp.resTrgDef27|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
      (< $Perm.No $k@20@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@56@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@56@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r))
  :qid |qp.fvfValDef28|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r)
  :pattern (($FVF.lookup_option$array$ (as sm@56@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef29|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@57@04  $FPM) r)
    (ite (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r))) $k@20@04 $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@57@04  $FPM) r))
  :qid |qp.resPrmSumDef30|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@56@04  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@57@04  $FPM) r))
  :qid |qp.resTrgDef31|)))
(assert ($Perm.isReadVar $k@60@04 $Perm.Write))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
      (< $Perm.No $k@20@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@61@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@61@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r))
  :qid |qp.fvfValDef32|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r)
  :pattern (($FVF.lookup_option$array$ (as sm@61@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef33|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@62@04  $FPM) r)
    (ite (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r))) $k@20@04 $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@62@04  $FPM) r))
  :qid |qp.resPrmSumDef34|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@61@04  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@62@04  $FPM) r))
  :qid |qp.resTrgDef35|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@30@04 r) V@15@04) (<= 0 (inv@30@04 r)))
        (< (inv@29@04 r) V@15@04))
      (<= 0 (inv@29@04 r)))
    (=
      ($FVF.lookup_int (as sm@65@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@65@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))))))) r))
  :qid |qp.fvfValDef36|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@33@04 r) V@15@04) (<= 0 (inv@33@04 r)))
    (=
      ($FVF.lookup_int (as sm@65@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04)))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@65@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04)))))))))))))))) r))
  :qid |qp.fvfValDef37|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04)))))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@65@04  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef38|)))
(assert (forall ((i1@58@04 Int) (j@59@04 Int)) (!
  (implies
    (and
      (and
        (and (and (< j@59@04 V@15@04) (<= 0 j@59@04)) (< i1@58@04 V@15@04))
        (<= 0 i1@58@04))
      (< $Perm.No $k@60@04))
    (and
      (=
        (inv@63@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@61@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@58@04))) j@59@04))
        i1@58@04)
      (=
        (inv@64@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@61@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@58@04))) j@59@04))
        j@59@04)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@61@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@58@04))) j@59@04))
  :qid |int-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and
          (and (< (inv@64@04 r) V@15@04) (<= 0 (inv@64@04 r)))
          (< (inv@63@04 r) V@15@04))
        (<= 0 (inv@63@04 r)))
      (< $Perm.No $k@60@04))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@61@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) (inv@63@04 r)))) (inv@64@04 r))
      r))
  :pattern ((inv@63@04 r))
  :pattern ((inv@64@04 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (iff
    (Set_in r ($FVF.domain_int (as sm@68@04  $FVF<Int>)))
    (and
      (and
        (and
          (and (< (inv@64@04 r) V@15@04) (<= 0 (inv@64@04 r)))
          (< (inv@63@04 r) V@15@04))
        (<= 0 (inv@63@04 r)))
      (< $Perm.No $k@60@04)))
  :pattern ((Set_in r ($FVF.domain_int (as sm@68@04  $FVF<Int>))))
  :qid |qp.fvfDomDef43|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and
          (and
            (and (< (inv@64@04 r) V@15@04) (<= 0 (inv@64@04 r)))
            (< (inv@63@04 r) V@15@04))
          (<= 0 (inv@63@04 r)))
        (< $Perm.No $k@60@04))
      (and
        (and
          (and (< (inv@30@04 r) V@15@04) (<= 0 (inv@30@04 r)))
          (< (inv@29@04 r) V@15@04))
        (<= 0 (inv@29@04 r))))
    (=
      ($FVF.lookup_int (as sm@68@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@68@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))))))) r))
  :qid |qp.fvfValDef40|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and
          (and
            (and (< (inv@64@04 r) V@15@04) (<= 0 (inv@64@04 r)))
            (< (inv@63@04 r) V@15@04))
          (<= 0 (inv@63@04 r)))
        (< $Perm.No $k@60@04))
      (and (< (inv@33@04 r) V@15@04) (<= 0 (inv@33@04 r))))
    (=
      ($FVF.lookup_int (as sm@68@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04)))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@68@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04)))))))))))))))) r))
  :qid |qp.fvfValDef41|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04)))))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@68@04  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef42|)))
(assert (and
  (forall ((i1@41@04 Int)) (!
    (< i1@41@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
    :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@41@04))
    :qid |option$array$-aux|))
  (forall ((r $Ref)) (!
    (implies
      (and (< (inv@43@04 r) V@15@04) (<= 0 (inv@43@04 r)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@22@04  $FVF<option<array>>) r) r))
    :pattern ((inv@43@04 r))
    ))
  (forall ((r $Ref)) (!
    (implies
      (not
        (=
          (ite
            (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
            $k@20@04
            $Perm.No)
          $Perm.No))
      (ite
        (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
        (<
          (ite
            (and (< (inv@43@04 r) V@15@04) (<= 0 (inv@43@04 r)))
            $k@42@04
            $Perm.No)
          $k@20@04)
        (<
          (ite
            (and (< (inv@43@04 r) V@15@04) (<= 0 (inv@43@04 r)))
            $k@42@04
            $Perm.No)
          $Perm.No)))
    :pattern ((inv@21@04 r))
    :pattern ((inv@43@04 r))
    :qid |qp.srp12|))
  (forall ((i1@46@04 Int)) (!
    (implies
      (and (< i1@46@04 V@15@04) (<= 0 i1@46@04))
      (not
        (=
          ($FVF.lookup_option$array$ (as sm@47@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@46@04))
          (as None<option<array>>  option<array>))))
    
    :qid |prog.l<no position>|))
  (forall ((i1@49@04 Int)) (!
    (implies
      (and (< i1@49@04 V@15@04) (<= 0 i1@49@04))
      (=
        (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@50@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@49@04))))
        V@15@04))
    
    :qid |prog.l<no position>|))
  (forall ((i1@52@04 Int)) (!
    (forall ((i2@53@04 Int)) (!
      (implies
        (and
          (and
            (and
              (and
                (=
                  ($FVF.lookup_option$array$ (as sm@54@04  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@52@04))
                  ($FVF.lookup_option$array$ (as sm@56@04  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@53@04)))
                (< i2@53@04 V@15@04))
              (<= 0 i2@53@04))
            (< i1@52@04 V@15@04))
          (<= 0 i1@52@04))
        (= i1@52@04 i2@53@04))
      :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@53@04))
      :qid |prog.l<no position>|))
    
    :qid |prog.l<no position>|))
  (forall ((i1@58@04 Int) (j@59@04 Int)) (!
    (and
      (< i1@58@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@61@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@58@04)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@58@04))
      (not
        (=
          ($FVF.lookup_option$array$ (as sm@61@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@58@04))
          (as None<option<array>>  option<array>)))
      (<
        j@59@04
        (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@61@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@58@04))))))
    :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@61@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@58@04))) j@59@04))
    :qid |int-aux|))
  (forall ((r $Ref)) (!
    (implies
      (and
        (and
          (and (< (inv@64@04 r) V@15@04) (<= 0 (inv@64@04 r)))
          (< (inv@63@04 r) V@15@04))
        (<= 0 (inv@63@04 r)))
      ($FVF.loc_int ($FVF.lookup_int (as sm@65@04  $FVF<Int>) r) r))
    :pattern ((inv@63@04 r) (inv@64@04 r))
    ))
  (forall ((r $Ref)) (!
    (implies
      (not
        (=
          (ite
            (and
              (and
                (and (< (inv@30@04 r) V@15@04) (<= 0 (inv@30@04 r)))
                (< (inv@29@04 r) V@15@04))
              (<= 0 (inv@29@04 r)))
            $Perm.Write
            $Perm.No)
          $Perm.No))
      (ite
        (and
          (and
            (and (< (inv@30@04 r) V@15@04) (<= 0 (inv@30@04 r)))
            (< (inv@29@04 r) V@15@04))
          (<= 0 (inv@29@04 r)))
        (<
          (ite
            (and
              (and
                (and (< (inv@64@04 r) V@15@04) (<= 0 (inv@64@04 r)))
                (< (inv@63@04 r) V@15@04))
              (<= 0 (inv@63@04 r)))
            $k@60@04
            $Perm.No)
          $Perm.Write)
        (<
          (ite
            (and
              (and
                (and (< (inv@64@04 r) V@15@04) (<= 0 (inv@64@04 r)))
                (< (inv@63@04 r) V@15@04))
              (<= 0 (inv@63@04 r)))
            $k@60@04
            $Perm.No)
          $Perm.No)))
    :pattern ((inv@30@04 r))
    :pattern ((inv@29@04 r))
    :pattern ((inv@64@04 r))
    :pattern ((inv@63@04 r))
    :qid |qp.srp39|))))
(assert (FlowNetwork1 ($Snap.combine
  $Snap.unit
  ($Snap.combine
    $Snap.unit
    ($Snap.combine
      $Snap.unit
      ($Snap.combine
        ($SortWrappers.$FVF<option<array>>To$Snap (as sm@45@04  $FVF<option<array>>))
        ($Snap.combine
          $Snap.unit
          ($Snap.combine
            $Snap.unit
            ($Snap.combine
              $Snap.unit
              ($SortWrappers.$FVF<Int>To$Snap (as sm@68@04  $FVF<Int>))))))))) this@9@04 G@11@04 V@15@04 s@12@04 t@13@04))
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
(push) ; 2
(declare-const $t@69@04 $Snap)
(assert (= $t@69@04 ($Snap.combine ($Snap.first $t@69@04) ($Snap.second $t@69@04))))
(assert (= ($Snap.first $t@69@04) $Snap.unit))
; [eval] exc == null
(assert (= exc@16@04 $Ref.null))
(assert (=
  ($Snap.second $t@69@04)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@69@04))
    ($Snap.second ($Snap.second $t@69@04)))))
(assert (= ($Snap.first ($Snap.second $t@69@04)) $Snap.unit))
; [eval] exc == null ==> 0 <= s
; [eval] exc == null
(push) ; 3
(set-option :timeout 10)
(push) ; 4
(assert (not (not (= exc@16@04 $Ref.null))))
(check-sat)
; unknown
(pop) ; 4
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               5781
;  :arith-add-rows          2377
;  :arith-assert-diseq      79
;  :arith-assert-lower      1241
;  :arith-assert-upper      864
;  :arith-bound-prop        270
;  :arith-conflicts         47
;  :arith-eq-adapter        825
;  :arith-fixed-eqs         721
;  :arith-offset-eqs        693
;  :arith-pivots            906
;  :conflicts               126
;  :datatype-accessor-ax    37
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               404
;  :del-clause              10500
;  :final-checks            5
;  :max-generation          9
;  :max-memory              7.60
;  :memory                  7.51
;  :minimized-lits          20
;  :mk-bool-var             14468
;  :mk-clause               10771
;  :num-allocs              242191
;  :num-checks              51
;  :propagations            3520
;  :quant-instantiations    5305
;  :rlimit-count            438694
;  :time                    0.01)
; [then-branch: 28 | exc@16@04 == Null | live]
; [else-branch: 28 | exc@16@04 != Null | dead]
(push) ; 4
; [then-branch: 28 | exc@16@04 == Null]
; [eval] 0 <= s
(pop) ; 4
(pop) ; 3
; Joined path conditions
(assert (implies (= exc@16@04 $Ref.null) (<= 0 s@12@04)))
(assert (=
  ($Snap.second ($Snap.second $t@69@04))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second $t@69@04)))
    ($Snap.second ($Snap.second ($Snap.second $t@69@04))))))
(assert (= ($Snap.first ($Snap.second ($Snap.second $t@69@04))) $Snap.unit))
; [eval] exc == null ==> s < V
; [eval] exc == null
(push) ; 3
(push) ; 4
(assert (not (not (= exc@16@04 $Ref.null))))
(check-sat)
; unknown
(pop) ; 4
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               6514
;  :arith-add-rows          2514
;  :arith-assert-diseq      87
;  :arith-assert-lower      1420
;  :arith-assert-upper      986
;  :arith-bound-prop        290
;  :arith-conflicts         48
;  :arith-eq-adapter        943
;  :arith-fixed-eqs         838
;  :arith-offset-eqs        724
;  :arith-pivots            959
;  :conflicts               127
;  :datatype-accessor-ax    38
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               436
;  :del-clause              12146
;  :final-checks            5
;  :max-generation          9
;  :max-memory              7.60
;  :memory                  7.51
;  :minimized-lits          20
;  :mk-bool-var             16377
;  :mk-clause               12417
;  :num-allocs              248539
;  :num-checks              52
;  :propagations            4119
;  :quant-instantiations    6063
;  :rlimit-count            464761
;  :time                    0.01)
; [then-branch: 29 | exc@16@04 == Null | live]
; [else-branch: 29 | exc@16@04 != Null | dead]
(push) ; 4
; [then-branch: 29 | exc@16@04 == Null]
; [eval] s < V
(pop) ; 4
(pop) ; 3
; Joined path conditions
(assert (implies (= exc@16@04 $Ref.null) (< s@12@04 V@15@04)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second $t@69@04)))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@69@04))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04)))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@69@04))))
  $Snap.unit))
; [eval] exc == null ==> 0 <= t
; [eval] exc == null
(push) ; 3
(push) ; 4
(assert (not (not (= exc@16@04 $Ref.null))))
(check-sat)
; unknown
(pop) ; 4
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               7285
;  :arith-add-rows          2671
;  :arith-assert-diseq      93
;  :arith-assert-lower      1606
;  :arith-assert-upper      1116
;  :arith-bound-prop        303
;  :arith-conflicts         50
;  :arith-eq-adapter        1065
;  :arith-fixed-eqs         960
;  :arith-offset-eqs        759
;  :arith-pivots            1013
;  :conflicts               129
;  :datatype-accessor-ax    39
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               469
;  :del-clause              13822
;  :final-checks            5
;  :max-generation          9
;  :max-memory              7.60
;  :memory                  7.44
;  :minimized-lits          20
;  :mk-bool-var             18370
;  :mk-clause               14093
;  :num-allocs              255208
;  :num-checks              53
;  :propagations            4727
;  :quant-instantiations    6877
;  :rlimit-count            491818
;  :time                    0.01)
; [then-branch: 30 | exc@16@04 == Null | live]
; [else-branch: 30 | exc@16@04 != Null | dead]
(push) ; 4
; [then-branch: 30 | exc@16@04 == Null]
; [eval] 0 <= t
(pop) ; 4
(pop) ; 3
; Joined path conditions
(assert (implies (= exc@16@04 $Ref.null) (<= 0 t@13@04)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04)))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04)))))
  $Snap.unit))
; [eval] exc == null ==> t < V
; [eval] exc == null
(push) ; 3
(push) ; 4
(assert (not (not (= exc@16@04 $Ref.null))))
(check-sat)
; unknown
(pop) ; 4
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               7954
;  :arith-add-rows          2878
;  :arith-assert-diseq      98
;  :arith-assert-lower      1744
;  :arith-assert-upper      1217
;  :arith-bound-prop        329
;  :arith-conflicts         50
;  :arith-eq-adapter        1162
;  :arith-fixed-eqs         1059
;  :arith-offset-eqs        834
;  :arith-pivots            1068
;  :conflicts               130
;  :datatype-accessor-ax    40
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               494
;  :del-clause              15265
;  :final-checks            5
;  :max-generation          9
;  :max-memory              7.78
;  :memory                  7.68
;  :minimized-lits          23
;  :mk-bool-var             20027
;  :mk-clause               15536
;  :num-allocs              261827
;  :num-checks              54
;  :propagations            5250
;  :quant-instantiations    7545
;  :rlimit-count            524587
;  :time                    0.01)
; [then-branch: 31 | exc@16@04 == Null | live]
; [else-branch: 31 | exc@16@04 != Null | dead]
(push) ; 4
; [then-branch: 31 | exc@16@04 == Null]
; [eval] t < V
(pop) ; 4
(pop) ; 3
; Joined path conditions
(assert (implies (= exc@16@04 $Ref.null) (< t@13@04 V@15@04)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04)))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04)))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04))))))
  $Snap.unit))
; [eval] exc == null ==> G != (None(): option[array])
; [eval] exc == null
(push) ; 3
(push) ; 4
(assert (not (not (= exc@16@04 $Ref.null))))
(check-sat)
; unknown
(pop) ; 4
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               8830
;  :arith-add-rows          3142
;  :arith-assert-diseq      106
;  :arith-assert-lower      1945
;  :arith-assert-upper      1361
;  :arith-bound-prop        361
;  :arith-conflicts         51
;  :arith-eq-adapter        1305
;  :arith-fixed-eqs         1197
;  :arith-offset-eqs        903
;  :arith-pivots            1156
;  :conflicts               131
;  :datatype-accessor-ax    41
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               529
;  :del-clause              17186
;  :final-checks            5
;  :max-generation          9
;  :max-memory              7.79
;  :memory                  7.61
;  :minimized-lits          23
;  :mk-bool-var             22298
;  :mk-clause               17457
;  :num-allocs              269296
;  :num-checks              55
;  :propagations            5941
;  :quant-instantiations    8442
;  :rlimit-count            556304
;  :time                    0.01)
; [then-branch: 32 | exc@16@04 == Null | live]
; [else-branch: 32 | exc@16@04 != Null | dead]
(push) ; 4
; [then-branch: 32 | exc@16@04 == Null]
; [eval] G != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 4
(pop) ; 3
; Joined path conditions
(assert (implies
  (= exc@16@04 $Ref.null)
  (not (= G@11@04 (as None<option<array>>  option<array>)))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04)))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04)))))))
  $Snap.unit))
; [eval] exc == null ==> alen(opt_get1(G)) == V
; [eval] exc == null
(push) ; 3
(push) ; 4
(assert (not (not (= exc@16@04 $Ref.null))))
(check-sat)
; unknown
(pop) ; 4
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               9549
;  :arith-add-rows          3297
;  :arith-assert-diseq      114
;  :arith-assert-lower      2116
;  :arith-assert-upper      1482
;  :arith-bound-prop        380
;  :arith-conflicts         52
;  :arith-eq-adapter        1420
;  :arith-fixed-eqs         1311
;  :arith-offset-eqs        934
;  :arith-pivots            1212
;  :conflicts               132
;  :datatype-accessor-ax    42
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               562
;  :del-clause              18815
;  :final-checks            5
;  :max-generation          9
;  :max-memory              7.79
;  :memory                  7.69
;  :minimized-lits          23
;  :mk-bool-var             24186
;  :mk-clause               19086
;  :num-allocs              275931
;  :num-checks              56
;  :propagations            6531
;  :quant-instantiations    9197
;  :rlimit-count            585704
;  :time                    0.01)
; [then-branch: 33 | exc@16@04 == Null | live]
; [else-branch: 33 | exc@16@04 != Null | dead]
(push) ; 4
; [then-branch: 33 | exc@16@04 == Null]
; [eval] alen(opt_get1(G)) == V
; [eval] alen(opt_get1(G))
; [eval] opt_get1(G)
(push) ; 5
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 5
; Joined path conditions
(pop) ; 4
(pop) ; 3
; Joined path conditions
(assert (implies
  (= exc@16@04 $Ref.null)
  (= (alen<Int> (opt_get1 $Snap.unit G@11@04)) V@15@04)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04)))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04)))))))))))
; [eval] exc == null
(push) ; 3
(assert (not (not (= exc@16@04 $Ref.null))))
(check-sat)
; unknown
(pop) ; 3
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               10297
;  :arith-add-rows          3551
;  :arith-assert-diseq      121
;  :arith-assert-lower      2278
;  :arith-assert-upper      1603
;  :arith-bound-prop        416
;  :arith-conflicts         53
;  :arith-eq-adapter        1538
;  :arith-fixed-eqs         1432
;  :arith-offset-eqs        1016
;  :arith-pivots            1288
;  :conflicts               134
;  :datatype-accessor-ax    43
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               593
;  :del-clause              20478
;  :final-checks            5
;  :max-generation          9
;  :max-memory              7.80
;  :memory                  7.62
;  :minimized-lits          26
;  :mk-bool-var             26136
;  :mk-clause               20749
;  :num-allocs              282713
;  :num-checks              57
;  :propagations            7119
;  :quant-instantiations    9980
;  :rlimit-count            617567
;  :time                    0.01)
; [then-branch: 34 | exc@16@04 == Null | live]
; [else-branch: 34 | exc@16@04 != Null | dead]
(push) ; 3
; [then-branch: 34 | exc@16@04 == Null]
(declare-const i1@70@04 Int)
(push) ; 4
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 5
; [then-branch: 35 | 0 <= i1@70@04 | live]
; [else-branch: 35 | !(0 <= i1@70@04) | live]
(push) ; 6
; [then-branch: 35 | 0 <= i1@70@04]
(assert (<= 0 i1@70@04))
; [eval] i1 < V
(pop) ; 6
(push) ; 6
; [else-branch: 35 | !(0 <= i1@70@04)]
(assert (not (<= 0 i1@70@04)))
(pop) ; 6
(pop) ; 5
; Joined path conditions
; Joined path conditions
(assert (and (< i1@70@04 V@15@04) (<= 0 i1@70@04)))
; [eval] aloc(opt_get1(G), i1)
; [eval] opt_get1(G)
(push) ; 5
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 5
; Joined path conditions
(push) ; 5
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 6
(assert (not (< i1@70@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               10297
;  :arith-add-rows          3552
;  :arith-assert-diseq      121
;  :arith-assert-lower      2280
;  :arith-assert-upper      1603
;  :arith-bound-prop        416
;  :arith-conflicts         53
;  :arith-eq-adapter        1538
;  :arith-fixed-eqs         1432
;  :arith-offset-eqs        1016
;  :arith-pivots            1288
;  :conflicts               134
;  :datatype-accessor-ax    43
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               593
;  :del-clause              20478
;  :final-checks            5
;  :max-generation          9
;  :max-memory              7.80
;  :memory                  7.62
;  :minimized-lits          26
;  :mk-bool-var             26138
;  :mk-clause               20749
;  :num-allocs              282817
;  :num-checks              58
;  :propagations            7119
;  :quant-instantiations    9980
;  :rlimit-count            617753)
(assert (< i1@70@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(pop) ; 5
; Joined path conditions
(assert (< i1@70@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(declare-const $k@71@04 $Perm)
(assert ($Perm.isReadVar $k@71@04 $Perm.Write))
(pop) ; 4
(declare-fun inv@72@04 ($Ref) Int)
; Nested auxiliary terms: globals
(assert ($Perm.isReadVar $k@71@04 $Perm.Write))
; Nested auxiliary terms: non-globals
(assert (forall ((i1@70@04 Int)) (!
  (< i1@70@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@70@04))
  :qid |option$array$-aux|)))
(push) ; 4
(assert (not (forall ((i1@70@04 Int)) (!
  (implies
    (and (< i1@70@04 V@15@04) (<= 0 i1@70@04))
    (or (= $k@71@04 $Perm.No) (< $Perm.No $k@71@04)))
  
  ))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               10297
;  :arith-add-rows          3553
;  :arith-assert-diseq      122
;  :arith-assert-lower      2282
;  :arith-assert-upper      1604
;  :arith-bound-prop        416
;  :arith-conflicts         53
;  :arith-eq-adapter        1539
;  :arith-fixed-eqs         1432
;  :arith-offset-eqs        1016
;  :arith-pivots            1288
;  :conflicts               135
;  :datatype-accessor-ax    43
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               593
;  :del-clause              20478
;  :final-checks            5
;  :max-generation          9
;  :max-memory              7.80
;  :memory                  7.62
;  :minimized-lits          26
;  :mk-bool-var             26145
;  :mk-clause               20751
;  :num-allocs              283283
;  :num-checks              59
;  :propagations            7120
;  :quant-instantiations    9980
;  :rlimit-count            618325)
; Check receiver injectivity
(push) ; 4
(assert (not (forall ((i11@70@04 Int) (i12@70@04 Int)) (!
  (implies
    (and
      (and (and (< i11@70@04 V@15@04) (<= 0 i11@70@04)) (< $Perm.No $k@71@04))
      (and (and (< i12@70@04 V@15@04) (<= 0 i12@70@04)) (< $Perm.No $k@71@04))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i11@70@04)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i12@70@04)))
    (= i11@70@04 i12@70@04))
  
  :qid |option$array$-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               10312
;  :arith-add-rows          3557
;  :arith-assert-diseq      123
;  :arith-assert-lower      2286
;  :arith-assert-upper      1604
;  :arith-bound-prop        416
;  :arith-conflicts         53
;  :arith-eq-adapter        1540
;  :arith-fixed-eqs         1432
;  :arith-offset-eqs        1016
;  :arith-pivots            1290
;  :conflicts               136
;  :datatype-accessor-ax    43
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               593
;  :del-clause              20484
;  :final-checks            5
;  :max-generation          9
;  :max-memory              7.80
;  :memory                  7.63
;  :minimized-lits          26
;  :mk-bool-var             26173
;  :mk-clause               20757
;  :num-allocs              283769
;  :num-checks              60
;  :propagations            7120
;  :quant-instantiations    10004
;  :rlimit-count            619569)
; Definitional axioms for inverse functions
(assert (forall ((i1@70@04 Int)) (!
  (implies
    (and (and (< i1@70@04 V@15@04) (<= 0 i1@70@04)) (< $Perm.No $k@71@04))
    (=
      (inv@72@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@70@04))
      i1@70@04))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@70@04))
  )))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and (< (inv@72@04 r) V@15@04) (<= 0 (inv@72@04 r)))
      (< $Perm.No $k@71@04))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) (inv@72@04 r))
      r))
  :pattern ((inv@72@04 r))
  :qid |option$array$-fctOfInv|)))
; Permissions are non-negative
(assert (forall ((i1@70@04 Int)) (!
  (<= $Perm.No $k@71@04)
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@70@04))
  :qid |option$array$-permAtLeastZero|)))
; Field permissions are at most one
(assert (forall ((i1@70@04 Int)) (!
  (<= $k@71@04 $Perm.Write)
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@70@04))
  :qid |option$array$-permAtMostOne|)))
; Permission implies non-null receiver
(assert (forall ((i1@70@04 Int)) (!
  (implies
    (and (and (< i1@70@04 V@15@04) (<= 0 i1@70@04)) (< $Perm.No $k@71@04))
    (not
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@70@04)
        $Ref.null)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@70@04))
  :qid |option$array$-permImpliesNonNull|)))
(declare-const sm@73@04 $FVF<option<array>>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@72@04 r) V@15@04) (<= 0 (inv@72@04 r)))
      (< $Perm.No $k@71@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@73@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@73@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04))))))))) r))
  :qid |qp.fvfValDef44|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04))))))))) r) r)
  :pattern (($FVF.lookup_option$array$ (as sm@73@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef45|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@72@04 r) V@15@04) (<= 0 (inv@72@04 r)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@73@04  $FVF<option<array>>) r) r))
  :pattern ((inv@72@04 r))
  )))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04)))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04)))))))))
  $Snap.unit))
; [eval] exc == null ==> (forall i1: Int :: { aloc(opt_get1(G), i1) } 0 <= i1 && i1 < V ==> aloc(opt_get1(G), i1).option$array$ != (None(): option[array]))
; [eval] exc == null
(push) ; 4
(set-option :timeout 10)
(push) ; 5
(assert (not (not (= exc@16@04 $Ref.null))))
(check-sat)
; unknown
(pop) ; 5
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               10884
;  :arith-add-rows          3771
;  :arith-assert-diseq      129
;  :arith-assert-lower      2421
;  :arith-assert-upper      1703
;  :arith-bound-prop        441
;  :arith-conflicts         54
;  :arith-eq-adapter        1648
;  :arith-fixed-eqs         1523
;  :arith-offset-eqs        1062
;  :arith-pivots            1350
;  :conflicts               137
;  :datatype-accessor-ax    44
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               619
;  :del-clause              21927
;  :final-checks            5
;  :max-generation          9
;  :max-memory              7.86
;  :memory                  7.67
;  :minimized-lits          26
;  :mk-bool-var             27886
;  :mk-clause               22200
;  :num-allocs              291303
;  :num-checks              61
;  :propagations            7580
;  :quant-instantiations    10655
;  :rlimit-count            652310
;  :time                    0.01)
; [then-branch: 36 | exc@16@04 == Null | live]
; [else-branch: 36 | exc@16@04 != Null | dead]
(push) ; 5
; [then-branch: 36 | exc@16@04 == Null]
; [eval] (forall i1: Int :: { aloc(opt_get1(G), i1) } 0 <= i1 && i1 < V ==> aloc(opt_get1(G), i1).option$array$ != (None(): option[array]))
(declare-const i1@74@04 Int)
(push) ; 6
; [eval] 0 <= i1 && i1 < V ==> aloc(opt_get1(G), i1).option$array$ != (None(): option[array])
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 7
; [then-branch: 37 | 0 <= i1@74@04 | live]
; [else-branch: 37 | !(0 <= i1@74@04) | live]
(push) ; 8
; [then-branch: 37 | 0 <= i1@74@04]
(assert (<= 0 i1@74@04))
; [eval] i1 < V
(pop) ; 8
(push) ; 8
; [else-branch: 37 | !(0 <= i1@74@04)]
(assert (not (<= 0 i1@74@04)))
(pop) ; 8
(pop) ; 7
; Joined path conditions
; Joined path conditions
(push) ; 7
; [then-branch: 38 | i1@74@04 < V@15@04 && 0 <= i1@74@04 | live]
; [else-branch: 38 | !(i1@74@04 < V@15@04 && 0 <= i1@74@04) | live]
(push) ; 8
; [then-branch: 38 | i1@74@04 < V@15@04 && 0 <= i1@74@04]
(assert (and (< i1@74@04 V@15@04) (<= 0 i1@74@04)))
; [eval] aloc(opt_get1(G), i1).option$array$ != (None(): option[array])
; [eval] aloc(opt_get1(G), i1)
; [eval] opt_get1(G)
(push) ; 9
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 9
; Joined path conditions
(push) ; 9
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 10
(assert (not (< i1@74@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               10884
;  :arith-add-rows          3772
;  :arith-assert-diseq      129
;  :arith-assert-lower      2423
;  :arith-assert-upper      1703
;  :arith-bound-prop        441
;  :arith-conflicts         54
;  :arith-eq-adapter        1648
;  :arith-fixed-eqs         1523
;  :arith-offset-eqs        1062
;  :arith-pivots            1351
;  :conflicts               137
;  :datatype-accessor-ax    44
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               619
;  :del-clause              21927
;  :final-checks            5
;  :max-generation          9
;  :max-memory              7.86
;  :memory                  7.68
;  :minimized-lits          26
;  :mk-bool-var             27888
;  :mk-clause               22200
;  :num-allocs              291406
;  :num-checks              62
;  :propagations            7580
;  :quant-instantiations    10655
;  :rlimit-count            652511)
(assert (< i1@74@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(pop) ; 9
; Joined path conditions
(assert (< i1@74@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@73@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@74@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@74@04)))
(push) ; 9
(assert (not (ite
  (and
    (<
      (inv@72@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@74@04))
      V@15@04)
    (<=
      0
      (inv@72@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@74@04))))
  (< $Perm.No $k@71@04)
  false)))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               10924
;  :arith-add-rows          3790
;  :arith-assert-diseq      129
;  :arith-assert-lower      2428
;  :arith-assert-upper      1708
;  :arith-bound-prop        445
;  :arith-conflicts         55
;  :arith-eq-adapter        1652
;  :arith-fixed-eqs         1527
;  :arith-offset-eqs        1069
;  :arith-pivots            1356
;  :conflicts               138
;  :datatype-accessor-ax    44
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               619
;  :del-clause              21927
;  :final-checks            5
;  :max-generation          9
;  :max-memory              7.86
;  :memory                  7.69
;  :minimized-lits          26
;  :mk-bool-var             28012
;  :mk-clause               22277
;  :num-allocs              292098
;  :num-checks              63
;  :propagations            7584
;  :quant-instantiations    10706
;  :rlimit-count            655041)
; [eval] (None(): option[array])
(pop) ; 8
(push) ; 8
; [else-branch: 38 | !(i1@74@04 < V@15@04 && 0 <= i1@74@04)]
(assert (not (and (< i1@74@04 V@15@04) (<= 0 i1@74@04))))
(pop) ; 8
(pop) ; 7
; Joined path conditions
(assert (implies
  (and (< i1@74@04 V@15@04) (<= 0 i1@74@04))
  (and
    (< i1@74@04 V@15@04)
    (<= 0 i1@74@04)
    (< i1@74@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@73@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@74@04)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@74@04)))))
; Joined path conditions
(pop) ; 6
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@74@04 Int)) (!
  (implies
    (and (< i1@74@04 V@15@04) (<= 0 i1@74@04))
    (and
      (< i1@74@04 V@15@04)
      (<= 0 i1@74@04)
      (< i1@74@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@73@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@74@04)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@74@04))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@74@04))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (implies
  (= exc@16@04 $Ref.null)
  (forall ((i1@74@04 Int)) (!
    (implies
      (and (< i1@74@04 V@15@04) (<= 0 i1@74@04))
      (and
        (< i1@74@04 V@15@04)
        (<= 0 i1@74@04)
        (< i1@74@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@73@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@74@04)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@74@04))))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@74@04))
    :qid |prog.l<no position>-aux|))))
(assert (implies
  (= exc@16@04 $Ref.null)
  (forall ((i1@74@04 Int)) (!
    (implies
      (and (< i1@74@04 V@15@04) (<= 0 i1@74@04))
      (not
        (=
          ($FVF.lookup_option$array$ (as sm@73@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@74@04))
          (as None<option<array>>  option<array>))))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@74@04))
    :qid |prog.l<no position>|))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04)))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04)))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04))))))))))
  $Snap.unit))
; [eval] exc == null ==> (forall i1: Int :: { alen(opt_get1(aloc(opt_get1(G), i1).option$array$)) } 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(G), i1).option$array$)) == V)
; [eval] exc == null
(push) ; 4
(set-option :timeout 10)
(push) ; 5
(assert (not (not (= exc@16@04 $Ref.null))))
(check-sat)
; unknown
(pop) ; 5
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               11581
;  :arith-add-rows          4053
;  :arith-assert-diseq      135
;  :arith-assert-lower      2583
;  :arith-assert-upper      1824
;  :arith-bound-prop        485
;  :arith-conflicts         56
;  :arith-eq-adapter        1772
;  :arith-fixed-eqs         1642
;  :arith-offset-eqs        1130
;  :arith-pivots            1442
;  :conflicts               139
;  :datatype-accessor-ax    45
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               645
;  :del-clause              23662
;  :final-checks            5
;  :max-generation          9
;  :max-memory              7.91
;  :memory                  7.72
;  :minimized-lits          26
;  :mk-bool-var             29963
;  :mk-clause               23935
;  :num-allocs              299726
;  :num-checks              64
;  :propagations            8105
;  :quant-instantiations    11484
;  :rlimit-count            689719
;  :time                    0.01)
; [then-branch: 39 | exc@16@04 == Null | live]
; [else-branch: 39 | exc@16@04 != Null | dead]
(push) ; 5
; [then-branch: 39 | exc@16@04 == Null]
; [eval] (forall i1: Int :: { alen(opt_get1(aloc(opt_get1(G), i1).option$array$)) } 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(G), i1).option$array$)) == V)
(declare-const i1@75@04 Int)
(push) ; 6
; [eval] 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(G), i1).option$array$)) == V
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 7
; [then-branch: 40 | 0 <= i1@75@04 | live]
; [else-branch: 40 | !(0 <= i1@75@04) | live]
(push) ; 8
; [then-branch: 40 | 0 <= i1@75@04]
(assert (<= 0 i1@75@04))
; [eval] i1 < V
(pop) ; 8
(push) ; 8
; [else-branch: 40 | !(0 <= i1@75@04)]
(assert (not (<= 0 i1@75@04)))
(pop) ; 8
(pop) ; 7
; Joined path conditions
; Joined path conditions
(push) ; 7
; [then-branch: 41 | i1@75@04 < V@15@04 && 0 <= i1@75@04 | live]
; [else-branch: 41 | !(i1@75@04 < V@15@04 && 0 <= i1@75@04) | live]
(push) ; 8
; [then-branch: 41 | i1@75@04 < V@15@04 && 0 <= i1@75@04]
(assert (and (< i1@75@04 V@15@04) (<= 0 i1@75@04)))
; [eval] alen(opt_get1(aloc(opt_get1(G), i1).option$array$)) == V
; [eval] alen(opt_get1(aloc(opt_get1(G), i1).option$array$))
; [eval] opt_get1(aloc(opt_get1(G), i1).option$array$)
; [eval] aloc(opt_get1(G), i1)
; [eval] opt_get1(G)
(push) ; 9
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 9
; Joined path conditions
(push) ; 9
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 10
(assert (not (< i1@75@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               11581
;  :arith-add-rows          4054
;  :arith-assert-diseq      135
;  :arith-assert-lower      2585
;  :arith-assert-upper      1824
;  :arith-bound-prop        485
;  :arith-conflicts         56
;  :arith-eq-adapter        1772
;  :arith-fixed-eqs         1642
;  :arith-offset-eqs        1130
;  :arith-pivots            1442
;  :conflicts               139
;  :datatype-accessor-ax    45
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               645
;  :del-clause              23662
;  :final-checks            5
;  :max-generation          9
;  :max-memory              7.91
;  :memory                  7.72
;  :minimized-lits          26
;  :mk-bool-var             29965
;  :mk-clause               23935
;  :num-allocs              299830
;  :num-checks              65
;  :propagations            8105
;  :quant-instantiations    11484
;  :rlimit-count            689915)
(assert (< i1@75@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(pop) ; 9
; Joined path conditions
(assert (< i1@75@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@73@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@75@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@75@04)))
(push) ; 9
(assert (not (ite
  (and
    (<
      (inv@72@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@75@04))
      V@15@04)
    (<=
      0
      (inv@72@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@75@04))))
  (< $Perm.No $k@71@04)
  false)))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               11611
;  :arith-add-rows          4068
;  :arith-assert-diseq      135
;  :arith-assert-lower      2590
;  :arith-assert-upper      1829
;  :arith-bound-prop        488
;  :arith-conflicts         57
;  :arith-eq-adapter        1776
;  :arith-fixed-eqs         1646
;  :arith-offset-eqs        1130
;  :arith-pivots            1447
;  :conflicts               140
;  :datatype-accessor-ax    45
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               645
;  :del-clause              23662
;  :final-checks            5
;  :max-generation          9
;  :max-memory              7.91
;  :memory                  7.74
;  :minimized-lits          26
;  :mk-bool-var             30091
;  :mk-clause               24012
;  :num-allocs              300515
;  :num-checks              66
;  :propagations            8106
;  :quant-instantiations    11537
;  :rlimit-count            692303)
(push) ; 9
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 10
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@73@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@75@04))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               11611
;  :arith-add-rows          4068
;  :arith-assert-diseq      135
;  :arith-assert-lower      2590
;  :arith-assert-upper      1829
;  :arith-bound-prop        488
;  :arith-conflicts         57
;  :arith-eq-adapter        1776
;  :arith-fixed-eqs         1646
;  :arith-offset-eqs        1130
;  :arith-pivots            1447
;  :conflicts               141
;  :datatype-accessor-ax    45
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               645
;  :del-clause              23662
;  :final-checks            5
;  :max-generation          9
;  :max-memory              7.91
;  :memory                  7.74
;  :minimized-lits          26
;  :mk-bool-var             30091
;  :mk-clause               24012
;  :num-allocs              300605
;  :num-checks              67
;  :propagations            8106
;  :quant-instantiations    11537
;  :rlimit-count            692398)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@73@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@75@04))
    (as None<option<array>>  option<array>))))
(pop) ; 9
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@73@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@75@04))
    (as None<option<array>>  option<array>))))
(pop) ; 8
(push) ; 8
; [else-branch: 41 | !(i1@75@04 < V@15@04 && 0 <= i1@75@04)]
(assert (not (and (< i1@75@04 V@15@04) (<= 0 i1@75@04))))
(pop) ; 8
(pop) ; 7
; Joined path conditions
(assert (implies
  (and (< i1@75@04 V@15@04) (<= 0 i1@75@04))
  (and
    (< i1@75@04 V@15@04)
    (<= 0 i1@75@04)
    (< i1@75@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@73@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@75@04)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@75@04))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@73@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@75@04))
        (as None<option<array>>  option<array>))))))
; Joined path conditions
(pop) ; 6
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@75@04 Int)) (!
  (implies
    (and (< i1@75@04 V@15@04) (<= 0 i1@75@04))
    (and
      (< i1@75@04 V@15@04)
      (<= 0 i1@75@04)
      (< i1@75@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@73@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@75@04)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@75@04))
      (not
        (=
          ($FVF.lookup_option$array$ (as sm@73@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@75@04))
          (as None<option<array>>  option<array>)))))
  :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@73@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@75@04)))))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (implies
  (= exc@16@04 $Ref.null)
  (forall ((i1@75@04 Int)) (!
    (implies
      (and (< i1@75@04 V@15@04) (<= 0 i1@75@04))
      (and
        (< i1@75@04 V@15@04)
        (<= 0 i1@75@04)
        (< i1@75@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@73@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@75@04)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@75@04))
        (not
          (=
            ($FVF.lookup_option$array$ (as sm@73@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@75@04))
            (as None<option<array>>  option<array>)))))
    :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@73@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@75@04)))))
    :qid |prog.l<no position>-aux|))))
(assert (implies
  (= exc@16@04 $Ref.null)
  (forall ((i1@75@04 Int)) (!
    (implies
      (and (< i1@75@04 V@15@04) (<= 0 i1@75@04))
      (=
        (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@73@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@75@04))))
        V@15@04))
    :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@73@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@75@04)))))
    :qid |prog.l<no position>|))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04)))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04)))))))))))
  $Snap.unit))
; [eval] exc == null ==> (forall i1: Int :: { aloc(opt_get1(G), i1) } (forall i2: Int :: { aloc(opt_get1(G), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(G), i1).option$array$ == aloc(opt_get1(G), i2).option$array$ ==> i1 == i2))
; [eval] exc == null
(push) ; 4
(set-option :timeout 10)
(push) ; 5
(assert (not (not (= exc@16@04 $Ref.null))))
(check-sat)
; unknown
(pop) ; 5
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               12217
;  :arith-add-rows          4230
;  :arith-assert-diseq      140
;  :arith-assert-lower      2721
;  :arith-assert-upper      1925
;  :arith-bound-prop        512
;  :arith-conflicts         57
;  :arith-eq-adapter        1871
;  :arith-fixed-eqs         1737
;  :arith-offset-eqs        1189
;  :arith-pivots            1506
;  :conflicts               142
;  :datatype-accessor-ax    46
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               669
;  :del-clause              25040
;  :final-checks            5
;  :max-generation          9
;  :max-memory              7.91
;  :memory                  7.81
;  :minimized-lits          29
;  :mk-bool-var             31649
;  :mk-clause               25313
;  :num-allocs              306972
;  :num-checks              68
;  :propagations            8557
;  :quant-instantiations    12180
;  :rlimit-count            723216
;  :time                    0.01)
; [then-branch: 42 | exc@16@04 == Null | live]
; [else-branch: 42 | exc@16@04 != Null | dead]
(push) ; 5
; [then-branch: 42 | exc@16@04 == Null]
; [eval] (forall i1: Int :: { aloc(opt_get1(G), i1) } (forall i2: Int :: { aloc(opt_get1(G), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(G), i1).option$array$ == aloc(opt_get1(G), i2).option$array$ ==> i1 == i2))
(declare-const i1@76@04 Int)
(push) ; 6
; [eval] (forall i2: Int :: { aloc(opt_get1(G), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(G), i1).option$array$ == aloc(opt_get1(G), i2).option$array$ ==> i1 == i2)
(declare-const i2@77@04 Int)
(push) ; 7
; [eval] 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(G), i1).option$array$ == aloc(opt_get1(G), i2).option$array$ ==> i1 == i2
; [eval] 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(G), i1).option$array$ == aloc(opt_get1(G), i2).option$array$
; [eval] 0 <= i1
(push) ; 8
; [then-branch: 43 | 0 <= i1@76@04 | live]
; [else-branch: 43 | !(0 <= i1@76@04) | live]
(push) ; 9
; [then-branch: 43 | 0 <= i1@76@04]
(assert (<= 0 i1@76@04))
; [eval] i1 < V
(push) ; 10
; [then-branch: 44 | i1@76@04 < V@15@04 | live]
; [else-branch: 44 | !(i1@76@04 < V@15@04) | live]
(push) ; 11
; [then-branch: 44 | i1@76@04 < V@15@04]
(assert (< i1@76@04 V@15@04))
; [eval] 0 <= i2
(push) ; 12
; [then-branch: 45 | 0 <= i2@77@04 | live]
; [else-branch: 45 | !(0 <= i2@77@04) | live]
(push) ; 13
; [then-branch: 45 | 0 <= i2@77@04]
(assert (<= 0 i2@77@04))
; [eval] i2 < V
(push) ; 14
; [then-branch: 46 | i2@77@04 < V@15@04 | live]
; [else-branch: 46 | !(i2@77@04 < V@15@04) | live]
(push) ; 15
; [then-branch: 46 | i2@77@04 < V@15@04]
(assert (< i2@77@04 V@15@04))
; [eval] aloc(opt_get1(G), i1).option$array$ == aloc(opt_get1(G), i2).option$array$
; [eval] aloc(opt_get1(G), i1)
; [eval] opt_get1(G)
(push) ; 16
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 16
; Joined path conditions
(push) ; 16
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 17
(assert (not (< i1@76@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))))
(check-sat)
; unsat
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               12217
;  :arith-add-rows          4232
;  :arith-assert-diseq      140
;  :arith-assert-lower      2725
;  :arith-assert-upper      1925
;  :arith-bound-prop        512
;  :arith-conflicts         57
;  :arith-eq-adapter        1871
;  :arith-fixed-eqs         1737
;  :arith-offset-eqs        1189
;  :arith-pivots            1506
;  :conflicts               142
;  :datatype-accessor-ax    46
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               669
;  :del-clause              25040
;  :final-checks            5
;  :max-generation          9
;  :max-memory              7.91
;  :memory                  7.81
;  :minimized-lits          29
;  :mk-bool-var             31653
;  :mk-clause               25313
;  :num-allocs              307252
;  :num-checks              69
;  :propagations            8557
;  :quant-instantiations    12180
;  :rlimit-count            723557)
(assert (< i1@76@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(pop) ; 16
; Joined path conditions
(assert (< i1@76@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@73@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@76@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@76@04)))
(push) ; 16
(assert (not (ite
  (and
    (<
      (inv@72@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@76@04))
      V@15@04)
    (<=
      0
      (inv@72@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@76@04))))
  (< $Perm.No $k@71@04)
  false)))
(check-sat)
; unsat
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               12248
;  :arith-add-rows          4246
;  :arith-assert-diseq      140
;  :arith-assert-lower      2730
;  :arith-assert-upper      1930
;  :arith-bound-prop        515
;  :arith-conflicts         58
;  :arith-eq-adapter        1875
;  :arith-fixed-eqs         1741
;  :arith-offset-eqs        1189
;  :arith-pivots            1511
;  :conflicts               143
;  :datatype-accessor-ax    46
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               669
;  :del-clause              25040
;  :final-checks            5
;  :max-generation          9
;  :max-memory              7.97
;  :memory                  7.91
;  :minimized-lits          29
;  :mk-bool-var             31780
;  :mk-clause               25390
;  :num-allocs              307936
;  :num-checks              70
;  :propagations            8558
;  :quant-instantiations    12233
;  :rlimit-count            725759)
; [eval] aloc(opt_get1(G), i2)
; [eval] opt_get1(G)
(push) ; 16
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 16
; Joined path conditions
(push) ; 16
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 17
(assert (not (< i2@77@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))))
(check-sat)
; unsat
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               12248
;  :arith-add-rows          4246
;  :arith-assert-diseq      140
;  :arith-assert-lower      2730
;  :arith-assert-upper      1930
;  :arith-bound-prop        515
;  :arith-conflicts         58
;  :arith-eq-adapter        1875
;  :arith-fixed-eqs         1741
;  :arith-offset-eqs        1189
;  :arith-pivots            1511
;  :conflicts               143
;  :datatype-accessor-ax    46
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               669
;  :del-clause              25040
;  :final-checks            5
;  :max-generation          9
;  :max-memory              7.97
;  :memory                  7.91
;  :minimized-lits          29
;  :mk-bool-var             31780
;  :mk-clause               25390
;  :num-allocs              307962
;  :num-checks              71
;  :propagations            8558
;  :quant-instantiations    12233
;  :rlimit-count            725789)
(assert (< i2@77@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(pop) ; 16
; Joined path conditions
(assert (< i2@77@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@73@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@77@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@77@04)))
(push) ; 16
(assert (not (ite
  (and
    (<
      (inv@72@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@77@04))
      V@15@04)
    (<=
      0
      (inv@72@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@77@04))))
  (< $Perm.No $k@71@04)
  false)))
(check-sat)
; unsat
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               12276
;  :arith-add-rows          4262
;  :arith-assert-diseq      140
;  :arith-assert-lower      2735
;  :arith-assert-upper      1935
;  :arith-bound-prop        518
;  :arith-conflicts         59
;  :arith-eq-adapter        1880
;  :arith-fixed-eqs         1745
;  :arith-offset-eqs        1189
;  :arith-pivots            1516
;  :conflicts               144
;  :datatype-accessor-ax    46
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               669
;  :del-clause              25040
;  :final-checks            5
;  :max-generation          9
;  :max-memory              7.97
;  :memory                  7.91
;  :minimized-lits          29
;  :mk-bool-var             31875
;  :mk-clause               25449
;  :num-allocs              308615
;  :num-checks              72
;  :propagations            8565
;  :quant-instantiations    12280
;  :rlimit-count            728084)
(pop) ; 15
(push) ; 15
; [else-branch: 46 | !(i2@77@04 < V@15@04)]
(assert (not (< i2@77@04 V@15@04)))
(pop) ; 15
(pop) ; 14
; Joined path conditions
(assert (implies
  (< i2@77@04 V@15@04)
  (and
    (< i2@77@04 V@15@04)
    (< i1@76@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@73@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@76@04)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@76@04))
    (< i2@77@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@73@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@77@04)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@77@04)))))
; Joined path conditions
(pop) ; 13
(push) ; 13
; [else-branch: 45 | !(0 <= i2@77@04)]
(assert (not (<= 0 i2@77@04)))
(pop) ; 13
(pop) ; 12
; Joined path conditions
(assert (implies
  (<= 0 i2@77@04)
  (and
    (<= 0 i2@77@04)
    (implies
      (< i2@77@04 V@15@04)
      (and
        (< i2@77@04 V@15@04)
        (< i1@76@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@73@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@76@04)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@76@04))
        (< i2@77@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@73@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@77@04)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@77@04)))))))
; Joined path conditions
(pop) ; 11
(push) ; 11
; [else-branch: 44 | !(i1@76@04 < V@15@04)]
(assert (not (< i1@76@04 V@15@04)))
(pop) ; 11
(pop) ; 10
; Joined path conditions
(assert (implies
  (< i1@76@04 V@15@04)
  (and
    (< i1@76@04 V@15@04)
    (implies
      (<= 0 i2@77@04)
      (and
        (<= 0 i2@77@04)
        (implies
          (< i2@77@04 V@15@04)
          (and
            (< i2@77@04 V@15@04)
            (< i1@76@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@73@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@76@04)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@76@04))
            (< i2@77@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@73@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@77@04)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@77@04)))))))))
; Joined path conditions
(pop) ; 9
(push) ; 9
; [else-branch: 43 | !(0 <= i1@76@04)]
(assert (not (<= 0 i1@76@04)))
(pop) ; 9
(pop) ; 8
; Joined path conditions
(assert (implies
  (<= 0 i1@76@04)
  (and
    (<= 0 i1@76@04)
    (implies
      (< i1@76@04 V@15@04)
      (and
        (< i1@76@04 V@15@04)
        (implies
          (<= 0 i2@77@04)
          (and
            (<= 0 i2@77@04)
            (implies
              (< i2@77@04 V@15@04)
              (and
                (< i2@77@04 V@15@04)
                (< i1@76@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@73@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@76@04)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@76@04))
                (< i2@77@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@73@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@77@04)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@77@04)))))))))))
; Joined path conditions
(push) ; 8
; [then-branch: 47 | Lookup(option$array$,sm@73@04,aloc((_, _), opt_get1(_, G@11@04), i1@76@04)) == Lookup(option$array$,sm@73@04,aloc((_, _), opt_get1(_, G@11@04), i2@77@04)) && i2@77@04 < V@15@04 && 0 <= i2@77@04 && i1@76@04 < V@15@04 && 0 <= i1@76@04 | live]
; [else-branch: 47 | !(Lookup(option$array$,sm@73@04,aloc((_, _), opt_get1(_, G@11@04), i1@76@04)) == Lookup(option$array$,sm@73@04,aloc((_, _), opt_get1(_, G@11@04), i2@77@04)) && i2@77@04 < V@15@04 && 0 <= i2@77@04 && i1@76@04 < V@15@04 && 0 <= i1@76@04) | live]
(push) ; 9
; [then-branch: 47 | Lookup(option$array$,sm@73@04,aloc((_, _), opt_get1(_, G@11@04), i1@76@04)) == Lookup(option$array$,sm@73@04,aloc((_, _), opt_get1(_, G@11@04), i2@77@04)) && i2@77@04 < V@15@04 && 0 <= i2@77@04 && i1@76@04 < V@15@04 && 0 <= i1@76@04]
(assert (and
  (and
    (and
      (and
        (=
          ($FVF.lookup_option$array$ (as sm@73@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@76@04))
          ($FVF.lookup_option$array$ (as sm@73@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@77@04)))
        (< i2@77@04 V@15@04))
      (<= 0 i2@77@04))
    (< i1@76@04 V@15@04))
  (<= 0 i1@76@04)))
; [eval] i1 == i2
(pop) ; 9
(push) ; 9
; [else-branch: 47 | !(Lookup(option$array$,sm@73@04,aloc((_, _), opt_get1(_, G@11@04), i1@76@04)) == Lookup(option$array$,sm@73@04,aloc((_, _), opt_get1(_, G@11@04), i2@77@04)) && i2@77@04 < V@15@04 && 0 <= i2@77@04 && i1@76@04 < V@15@04 && 0 <= i1@76@04)]
(assert (not
  (and
    (and
      (and
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@73@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@76@04))
            ($FVF.lookup_option$array$ (as sm@73@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@77@04)))
          (< i2@77@04 V@15@04))
        (<= 0 i2@77@04))
      (< i1@76@04 V@15@04))
    (<= 0 i1@76@04))))
(pop) ; 9
(pop) ; 8
; Joined path conditions
(assert (implies
  (and
    (and
      (and
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@73@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@76@04))
            ($FVF.lookup_option$array$ (as sm@73@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@77@04)))
          (< i2@77@04 V@15@04))
        (<= 0 i2@77@04))
      (< i1@76@04 V@15@04))
    (<= 0 i1@76@04))
  (and
    (=
      ($FVF.lookup_option$array$ (as sm@73@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@76@04))
      ($FVF.lookup_option$array$ (as sm@73@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@77@04)))
    (< i2@77@04 V@15@04)
    (<= 0 i2@77@04)
    (< i1@76@04 V@15@04)
    (<= 0 i1@76@04))))
; Joined path conditions
(pop) ; 7
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i2@77@04 Int)) (!
  (and
    (implies
      (<= 0 i1@76@04)
      (and
        (<= 0 i1@76@04)
        (implies
          (< i1@76@04 V@15@04)
          (and
            (< i1@76@04 V@15@04)
            (implies
              (<= 0 i2@77@04)
              (and
                (<= 0 i2@77@04)
                (implies
                  (< i2@77@04 V@15@04)
                  (and
                    (< i2@77@04 V@15@04)
                    (< i1@76@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
                    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@73@04  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@76@04)) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@76@04))
                    (< i2@77@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
                    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@73@04  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@77@04)) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@77@04))))))))))
    (implies
      (and
        (and
          (and
            (and
              (=
                ($FVF.lookup_option$array$ (as sm@73@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@76@04))
                ($FVF.lookup_option$array$ (as sm@73@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@77@04)))
              (< i2@77@04 V@15@04))
            (<= 0 i2@77@04))
          (< i1@76@04 V@15@04))
        (<= 0 i1@76@04))
      (and
        (=
          ($FVF.lookup_option$array$ (as sm@73@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@76@04))
          ($FVF.lookup_option$array$ (as sm@73@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@77@04)))
        (< i2@77@04 V@15@04)
        (<= 0 i2@77@04)
        (< i1@76@04 V@15@04)
        (<= 0 i1@76@04))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@77@04))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 6
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@76@04 Int)) (!
  (forall ((i2@77@04 Int)) (!
    (and
      (implies
        (<= 0 i1@76@04)
        (and
          (<= 0 i1@76@04)
          (implies
            (< i1@76@04 V@15@04)
            (and
              (< i1@76@04 V@15@04)
              (implies
                (<= 0 i2@77@04)
                (and
                  (<= 0 i2@77@04)
                  (implies
                    (< i2@77@04 V@15@04)
                    (and
                      (< i2@77@04 V@15@04)
                      (< i1@76@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
                      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@73@04  $FVF<option<array>>) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@76@04)) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@76@04))
                      (< i2@77@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
                      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@73@04  $FVF<option<array>>) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@77@04)) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@77@04))))))))))
      (implies
        (and
          (and
            (and
              (and
                (=
                  ($FVF.lookup_option$array$ (as sm@73@04  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@76@04))
                  ($FVF.lookup_option$array$ (as sm@73@04  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@77@04)))
                (< i2@77@04 V@15@04))
              (<= 0 i2@77@04))
            (< i1@76@04 V@15@04))
          (<= 0 i1@76@04))
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@73@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@76@04))
            ($FVF.lookup_option$array$ (as sm@73@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@77@04)))
          (< i2@77@04 V@15@04)
          (<= 0 i2@77@04)
          (< i1@76@04 V@15@04)
          (<= 0 i1@76@04))))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@77@04))
    :qid |prog.l<no position>-aux|))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@76@04))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (implies
  (= exc@16@04 $Ref.null)
  (forall ((i1@76@04 Int)) (!
    (forall ((i2@77@04 Int)) (!
      (and
        (implies
          (<= 0 i1@76@04)
          (and
            (<= 0 i1@76@04)
            (implies
              (< i1@76@04 V@15@04)
              (and
                (< i1@76@04 V@15@04)
                (implies
                  (<= 0 i2@77@04)
                  (and
                    (<= 0 i2@77@04)
                    (implies
                      (< i2@77@04 V@15@04)
                      (and
                        (< i2@77@04 V@15@04)
                        (< i1@76@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
                        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@73@04  $FVF<option<array>>) (aloc ($Snap.combine
                          $Snap.unit
                          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@76@04)) (aloc ($Snap.combine
                          $Snap.unit
                          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@76@04))
                        (< i2@77@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
                        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@73@04  $FVF<option<array>>) (aloc ($Snap.combine
                          $Snap.unit
                          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@77@04)) (aloc ($Snap.combine
                          $Snap.unit
                          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@77@04))))))))))
        (implies
          (and
            (and
              (and
                (and
                  (=
                    ($FVF.lookup_option$array$ (as sm@73@04  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@76@04))
                    ($FVF.lookup_option$array$ (as sm@73@04  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@77@04)))
                  (< i2@77@04 V@15@04))
                (<= 0 i2@77@04))
              (< i1@76@04 V@15@04))
            (<= 0 i1@76@04))
          (and
            (=
              ($FVF.lookup_option$array$ (as sm@73@04  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@76@04))
              ($FVF.lookup_option$array$ (as sm@73@04  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@77@04)))
            (< i2@77@04 V@15@04)
            (<= 0 i2@77@04)
            (< i1@76@04 V@15@04)
            (<= 0 i1@76@04))))
      :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@77@04))
      :qid |prog.l<no position>-aux|))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@76@04))
    :qid |prog.l<no position>-aux|))))
(assert (implies
  (= exc@16@04 $Ref.null)
  (forall ((i1@76@04 Int)) (!
    (forall ((i2@77@04 Int)) (!
      (implies
        (and
          (and
            (and
              (and
                (=
                  ($FVF.lookup_option$array$ (as sm@73@04  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@76@04))
                  ($FVF.lookup_option$array$ (as sm@73@04  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@77@04)))
                (< i2@77@04 V@15@04))
              (<= 0 i2@77@04))
            (< i1@76@04 V@15@04))
          (<= 0 i1@76@04))
        (= i1@76@04 i2@77@04))
      :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@77@04))
      :qid |prog.l<no position>|))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@76@04))
    :qid |prog.l<no position>|))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04)))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04)))))))))))))))
; [eval] exc == null
(set-option :timeout 10)
(push) ; 4
(assert (not (not (= exc@16@04 $Ref.null))))
(check-sat)
; unknown
(pop) ; 4
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               12867
;  :arith-add-rows          4471
;  :arith-assert-diseq      145
;  :arith-assert-lower      2866
;  :arith-assert-upper      2034
;  :arith-bound-prop        541
;  :arith-conflicts         60
;  :arith-eq-adapter        1977
;  :arith-fixed-eqs         1837
;  :arith-offset-eqs        1233
;  :arith-pivots            1580
;  :conflicts               145
;  :datatype-accessor-ax    47
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               693
;  :del-clause              26955
;  :final-checks            5
;  :max-generation          9
;  :max-memory              8.21
;  :memory                  8.10
;  :minimized-lits          29
;  :mk-bool-var             33980
;  :mk-clause               27228
;  :num-allocs              316864
;  :num-checks              73
;  :propagations            9144
;  :quant-instantiations    13055
;  :rlimit-count            765607
;  :time                    0.01)
; [then-branch: 48 | exc@16@04 == Null | live]
; [else-branch: 48 | exc@16@04 != Null | dead]
(push) ; 4
; [then-branch: 48 | exc@16@04 == Null]
(declare-const i1@78@04 Int)
(declare-const j@79@04 Int)
(push) ; 5
; [eval] 0 <= i1 && i1 < V && (0 <= j && j < V)
; [eval] 0 <= i1
(push) ; 6
; [then-branch: 49 | 0 <= i1@78@04 | live]
; [else-branch: 49 | !(0 <= i1@78@04) | live]
(push) ; 7
; [then-branch: 49 | 0 <= i1@78@04]
(assert (<= 0 i1@78@04))
; [eval] i1 < V
(push) ; 8
; [then-branch: 50 | i1@78@04 < V@15@04 | live]
; [else-branch: 50 | !(i1@78@04 < V@15@04) | live]
(push) ; 9
; [then-branch: 50 | i1@78@04 < V@15@04]
(assert (< i1@78@04 V@15@04))
; [eval] 0 <= j
(push) ; 10
; [then-branch: 51 | 0 <= j@79@04 | live]
; [else-branch: 51 | !(0 <= j@79@04) | live]
(push) ; 11
; [then-branch: 51 | 0 <= j@79@04]
(assert (<= 0 j@79@04))
; [eval] j < V
(pop) ; 11
(push) ; 11
; [else-branch: 51 | !(0 <= j@79@04)]
(assert (not (<= 0 j@79@04)))
(pop) ; 11
(pop) ; 10
; Joined path conditions
; Joined path conditions
(pop) ; 9
(push) ; 9
; [else-branch: 50 | !(i1@78@04 < V@15@04)]
(assert (not (< i1@78@04 V@15@04)))
(pop) ; 9
(pop) ; 8
; Joined path conditions
; Joined path conditions
(pop) ; 7
(push) ; 7
; [else-branch: 49 | !(0 <= i1@78@04)]
(assert (not (<= 0 i1@78@04)))
(pop) ; 7
(pop) ; 6
; Joined path conditions
; Joined path conditions
(assert (and
  (and (and (< j@79@04 V@15@04) (<= 0 j@79@04)) (< i1@78@04 V@15@04))
  (<= 0 i1@78@04)))
; [eval] aloc(opt_get1(aloc(opt_get1(G), i1).option$array$), j)
; [eval] opt_get1(aloc(opt_get1(G), i1).option$array$)
; [eval] aloc(opt_get1(G), i1)
; [eval] opt_get1(G)
(push) ; 6
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 6
; Joined path conditions
(push) ; 6
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 7
(assert (not (< i1@78@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               12867
;  :arith-add-rows          4474
;  :arith-assert-diseq      145
;  :arith-assert-lower      2872
;  :arith-assert-upper      2034
;  :arith-bound-prop        541
;  :arith-conflicts         60
;  :arith-eq-adapter        1977
;  :arith-fixed-eqs         1837
;  :arith-offset-eqs        1233
;  :arith-pivots            1584
;  :conflicts               145
;  :datatype-accessor-ax    47
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               693
;  :del-clause              26955
;  :final-checks            5
;  :max-generation          9
;  :max-memory              8.21
;  :memory                  8.10
;  :minimized-lits          29
;  :mk-bool-var             33986
;  :mk-clause               27228
;  :num-allocs              317139
;  :num-checks              74
;  :propagations            9144
;  :quant-instantiations    13055
;  :rlimit-count            766102)
(assert (< i1@78@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(pop) ; 6
; Joined path conditions
(assert (< i1@78@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@73@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@78@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@78@04)))
(push) ; 6
(assert (not (ite
  (and
    (<
      (inv@72@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@78@04))
      V@15@04)
    (<=
      0
      (inv@72@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@78@04))))
  (< $Perm.No $k@71@04)
  false)))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               12905
;  :arith-add-rows          4492
;  :arith-assert-diseq      145
;  :arith-assert-lower      2877
;  :arith-assert-upper      2039
;  :arith-bound-prop        545
;  :arith-conflicts         61
;  :arith-eq-adapter        1981
;  :arith-fixed-eqs         1841
;  :arith-offset-eqs        1238
;  :arith-pivots            1589
;  :conflicts               146
;  :datatype-accessor-ax    47
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               693
;  :del-clause              26955
;  :final-checks            5
;  :max-generation          9
;  :max-memory              8.21
;  :memory                  8.11
;  :minimized-lits          29
;  :mk-bool-var             34121
;  :mk-clause               27305
;  :num-allocs              317896
;  :num-checks              75
;  :propagations            9148
;  :quant-instantiations    13111
;  :rlimit-count            768646)
(push) ; 6
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 7
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@73@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@78@04))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               12905
;  :arith-add-rows          4492
;  :arith-assert-diseq      145
;  :arith-assert-lower      2877
;  :arith-assert-upper      2039
;  :arith-bound-prop        545
;  :arith-conflicts         61
;  :arith-eq-adapter        1981
;  :arith-fixed-eqs         1841
;  :arith-offset-eqs        1238
;  :arith-pivots            1589
;  :conflicts               147
;  :datatype-accessor-ax    47
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               693
;  :del-clause              26955
;  :final-checks            5
;  :max-generation          9
;  :max-memory              8.21
;  :memory                  8.11
;  :minimized-lits          29
;  :mk-bool-var             34121
;  :mk-clause               27305
;  :num-allocs              317985
;  :num-checks              76
;  :propagations            9148
;  :quant-instantiations    13111
;  :rlimit-count            768741)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@73@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@78@04))
    (as None<option<array>>  option<array>))))
(pop) ; 6
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@73@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@78@04))
    (as None<option<array>>  option<array>))))
(push) ; 6
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 7
(assert (not (<
  j@79@04
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@73@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@78@04)))))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               12911
;  :arith-add-rows          4496
;  :arith-assert-diseq      145
;  :arith-assert-lower      2880
;  :arith-assert-upper      2040
;  :arith-bound-prop        545
;  :arith-conflicts         62
;  :arith-eq-adapter        1982
;  :arith-fixed-eqs         1842
;  :arith-offset-eqs        1238
;  :arith-pivots            1591
;  :conflicts               148
;  :datatype-accessor-ax    47
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               693
;  :del-clause              26959
;  :final-checks            5
;  :max-generation          9
;  :max-memory              8.21
;  :memory                  8.11
;  :minimized-lits          29
;  :mk-bool-var             34132
;  :mk-clause               27309
;  :num-allocs              318175
;  :num-checks              77
;  :propagations            9150
;  :quant-instantiations    13118
;  :rlimit-count            769203)
(assert (<
  j@79@04
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@73@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@78@04))))))
(pop) ; 6
; Joined path conditions
(assert (<
  j@79@04
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@73@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@78@04))))))
(pop) ; 5
(declare-fun inv@80@04 ($Ref) Int)
(declare-fun inv@81@04 ($Ref) Int)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(assert (forall ((i1@78@04 Int) (j@79@04 Int)) (!
  (and
    (< i1@78@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@73@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@78@04)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@78@04))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@73@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@78@04))
        (as None<option<array>>  option<array>)))
    (<
      j@79@04
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@73@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@78@04))))))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@73@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@78@04))) j@79@04))
  :qid |int-aux|)))
; Check receiver injectivity
(push) ; 5
(assert (not (forall ((i11@78@04 Int) (j1@79@04 Int) (i12@78@04 Int) (j2@79@04 Int)) (!
  (implies
    (and
      (and
        (and (and (< j1@79@04 V@15@04) (<= 0 j1@79@04)) (< i11@78@04 V@15@04))
        (<= 0 i11@78@04))
      (and
        (and (and (< j2@79@04 V@15@04) (<= 0 j2@79@04)) (< i12@78@04 V@15@04))
        (<= 0 i12@78@04))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@73@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i11@78@04))) j1@79@04)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@73@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i12@78@04))) j2@79@04)))
    (and (= i11@78@04 i12@78@04) (= j1@79@04 j2@79@04)))
  
  :qid |int-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               12982
;  :arith-add-rows          4525
;  :arith-assert-diseq      145
;  :arith-assert-lower      2894
;  :arith-assert-upper      2044
;  :arith-bound-prop        548
;  :arith-conflicts         62
;  :arith-eq-adapter        1994
;  :arith-fixed-eqs         1844
;  :arith-offset-eqs        1241
;  :arith-pivots            1605
;  :conflicts               149
;  :datatype-accessor-ax    47
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               693
;  :del-clause              27177
;  :final-checks            5
;  :max-generation          9
;  :max-memory              8.21
;  :memory                  8.08
;  :minimized-lits          29
;  :mk-bool-var             34413
;  :mk-clause               27450
;  :num-allocs              319925
;  :num-checks              78
;  :propagations            9179
;  :quant-instantiations    13247
;  :rlimit-count            775649
;  :time                    0.00)
; Definitional axioms for inverse functions
(assert (forall ((i1@78@04 Int) (j@79@04 Int)) (!
  (implies
    (and
      (and (and (< j@79@04 V@15@04) (<= 0 j@79@04)) (< i1@78@04 V@15@04))
      (<= 0 i1@78@04))
    (and
      (=
        (inv@80@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@73@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@78@04))) j@79@04))
        i1@78@04)
      (=
        (inv@81@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@73@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@78@04))) j@79@04))
        j@79@04)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@73@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@78@04))) j@79@04))
  )))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@81@04 r) V@15@04) (<= 0 (inv@81@04 r)))
        (< (inv@80@04 r) V@15@04))
      (<= 0 (inv@80@04 r)))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@73@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) (inv@80@04 r)))) (inv@81@04 r))
      r))
  :pattern ((inv@80@04 r))
  :pattern ((inv@81@04 r))
  :qid |int-fctOfInv|)))
; Permissions are non-negative
; Field permissions are at most one
; Permission implies non-null receiver
(assert (forall ((i1@78@04 Int) (j@79@04 Int)) (!
  (implies
    (and
      (and (and (< j@79@04 V@15@04) (<= 0 j@79@04)) (< i1@78@04 V@15@04))
      (<= 0 i1@78@04))
    (not
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@73@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@78@04))) j@79@04)
        $Ref.null)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@73@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@78@04))) j@79@04))
  :qid |int-permImpliesNonNull|)))
(declare-const sm@82@04 $FVF<Int>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@81@04 r) V@15@04) (<= 0 (inv@81@04 r)))
        (< (inv@80@04 r) V@15@04))
      (<= 0 (inv@80@04 r)))
    (=
      ($FVF.lookup_int (as sm@82@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@82@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04))))))))))))) r))
  :qid |qp.fvfValDef46|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04))))))))))))) r) r)
  :pattern (($FVF.lookup_int (as sm@82@04  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef47|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@81@04 r) V@15@04) (<= 0 (inv@81@04 r)))
        (< (inv@80@04 r) V@15@04))
      (<= 0 (inv@80@04 r)))
    ($FVF.loc_int ($FVF.lookup_int (as sm@82@04  $FVF<Int>) r) r))
  :pattern ((inv@80@04 r) (inv@81@04 r))
  )))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04)))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04)))))))))))))
  $Snap.unit))
; [eval] exc == null ==> P != (None(): option[array])
; [eval] exc == null
(push) ; 5
(set-option :timeout 10)
(push) ; 6
(assert (not (not (= exc@16@04 $Ref.null))))
(check-sat)
; unknown
(pop) ; 6
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               13574
;  :arith-add-rows          4726
;  :arith-assert-diseq      150
;  :arith-assert-lower      3025
;  :arith-assert-upper      2143
;  :arith-bound-prop        571
;  :arith-conflicts         63
;  :arith-eq-adapter        2091
;  :arith-fixed-eqs         1936
;  :arith-offset-eqs        1285
;  :arith-pivots            1663
;  :conflicts               150
;  :datatype-accessor-ax    48
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               717
;  :del-clause              28932
;  :final-checks            5
;  :max-generation          9
;  :max-memory              8.25
;  :memory                  8.14
;  :minimized-lits          29
;  :mk-bool-var             36510
;  :mk-clause               29205
;  :num-allocs              327993
;  :num-checks              79
;  :propagations            9758
;  :quant-instantiations    14022
;  :rlimit-count            813236
;  :time                    0.01)
; [then-branch: 52 | exc@16@04 == Null | live]
; [else-branch: 52 | exc@16@04 != Null | dead]
(push) ; 6
; [then-branch: 52 | exc@16@04 == Null]
; [eval] P != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 6
(pop) ; 5
; Joined path conditions
(assert (implies
  (= exc@16@04 $Ref.null)
  (not (= P@14@04 (as None<option<array>>  option<array>)))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04)))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04)))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04))))))))))))))
  $Snap.unit))
; [eval] exc == null ==> alen(opt_get1(P)) == V
; [eval] exc == null
(push) ; 5
(push) ; 6
(assert (not (not (= exc@16@04 $Ref.null))))
(check-sat)
; unknown
(pop) ; 6
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               14124
;  :arith-add-rows          4875
;  :arith-assert-diseq      155
;  :arith-assert-lower      3151
;  :arith-assert-upper      2236
;  :arith-bound-prop        593
;  :arith-conflicts         63
;  :arith-eq-adapter        2182
;  :arith-fixed-eqs         2023
;  :arith-offset-eqs        1328
;  :arith-pivots            1715
;  :conflicts               150
;  :datatype-accessor-ax    49
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               739
;  :del-clause              30478
;  :final-checks            5
;  :max-generation          9
;  :max-memory              8.25
;  :memory                  8.14
;  :minimized-lits          29
;  :mk-bool-var             38303
;  :mk-clause               30751
;  :num-allocs              334089
;  :num-checks              80
;  :propagations            10252
;  :quant-instantiations    14707
;  :rlimit-count            843571
;  :time                    0.01)
; [then-branch: 53 | exc@16@04 == Null | live]
; [else-branch: 53 | exc@16@04 != Null | dead]
(push) ; 6
; [then-branch: 53 | exc@16@04 == Null]
; [eval] alen(opt_get1(P)) == V
; [eval] alen(opt_get1(P))
; [eval] opt_get1(P)
(push) ; 7
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 7
; Joined path conditions
(pop) ; 6
(pop) ; 5
; Joined path conditions
(assert (implies
  (= exc@16@04 $Ref.null)
  (= (alen<Int> (opt_get1 $Snap.unit P@14@04)) V@15@04)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04))))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04)))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04))))))))))))))))))
; [eval] exc == null
(push) ; 5
(assert (not (not (= exc@16@04 $Ref.null))))
(check-sat)
; unknown
(pop) ; 5
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               14715
;  :arith-add-rows          5078
;  :arith-assert-diseq      160
;  :arith-assert-lower      3282
;  :arith-assert-upper      2335
;  :arith-bound-prop        616
;  :arith-conflicts         64
;  :arith-eq-adapter        2279
;  :arith-fixed-eqs         2115
;  :arith-offset-eqs        1372
;  :arith-pivots            1775
;  :conflicts               151
;  :datatype-accessor-ax    50
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               763
;  :del-clause              32233
;  :final-checks            5
;  :max-generation          9
;  :max-memory              8.27
;  :memory                  8.15
;  :minimized-lits          29
;  :mk-bool-var             40393
;  :mk-clause               32506
;  :num-allocs              341066
;  :num-checks              81
;  :propagations            10831
;  :quant-instantiations    15482
;  :rlimit-count            878278
;  :time                    0.01)
; [then-branch: 54 | exc@16@04 == Null | live]
; [else-branch: 54 | exc@16@04 != Null | dead]
(push) ; 5
; [then-branch: 54 | exc@16@04 == Null]
(declare-const i1@83@04 Int)
(push) ; 6
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 7
; [then-branch: 55 | 0 <= i1@83@04 | live]
; [else-branch: 55 | !(0 <= i1@83@04) | live]
(push) ; 8
; [then-branch: 55 | 0 <= i1@83@04]
(assert (<= 0 i1@83@04))
; [eval] i1 < V
(pop) ; 8
(push) ; 8
; [else-branch: 55 | !(0 <= i1@83@04)]
(assert (not (<= 0 i1@83@04)))
(pop) ; 8
(pop) ; 7
; Joined path conditions
; Joined path conditions
(assert (and (< i1@83@04 V@15@04) (<= 0 i1@83@04)))
; [eval] aloc(opt_get1(P), i1)
; [eval] opt_get1(P)
(push) ; 7
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 7
; Joined path conditions
(push) ; 7
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 8
(assert (not (< i1@83@04 (alen<Int> (opt_get1 $Snap.unit P@14@04)))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               14715
;  :arith-add-rows          5079
;  :arith-assert-diseq      160
;  :arith-assert-lower      3284
;  :arith-assert-upper      2335
;  :arith-bound-prop        616
;  :arith-conflicts         64
;  :arith-eq-adapter        2279
;  :arith-fixed-eqs         2115
;  :arith-offset-eqs        1372
;  :arith-pivots            1775
;  :conflicts               151
;  :datatype-accessor-ax    50
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               763
;  :del-clause              32233
;  :final-checks            5
;  :max-generation          9
;  :max-memory              8.27
;  :memory                  8.16
;  :minimized-lits          29
;  :mk-bool-var             40395
;  :mk-clause               32506
;  :num-allocs              341170
;  :num-checks              82
;  :propagations            10831
;  :quant-instantiations    15482
;  :rlimit-count            878464)
(assert (< i1@83@04 (alen<Int> (opt_get1 $Snap.unit P@14@04))))
(pop) ; 7
; Joined path conditions
(assert (< i1@83@04 (alen<Int> (opt_get1 $Snap.unit P@14@04))))
(pop) ; 6
(declare-fun inv@84@04 ($Ref) Int)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(assert (forall ((i1@83@04 Int)) (!
  (< i1@83@04 (alen<Int> (opt_get1 $Snap.unit P@14@04)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i1@83@04))
  :qid |int-aux|)))
; Check receiver injectivity
(push) ; 6
(assert (not (forall ((i11@83@04 Int) (i12@83@04 Int)) (!
  (implies
    (and
      (and (< i11@83@04 V@15@04) (<= 0 i11@83@04))
      (and (< i12@83@04 V@15@04) (<= 0 i12@83@04))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i11@83@04)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i12@83@04)))
    (= i11@83@04 i12@83@04))
  
  :qid |int-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               14726
;  :arith-add-rows          5083
;  :arith-assert-diseq      161
;  :arith-assert-lower      3288
;  :arith-assert-upper      2335
;  :arith-bound-prop        616
;  :arith-conflicts         64
;  :arith-eq-adapter        2280
;  :arith-fixed-eqs         2115
;  :arith-offset-eqs        1372
;  :arith-pivots            1775
;  :conflicts               152
;  :datatype-accessor-ax    50
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               763
;  :del-clause              32239
;  :final-checks            5
;  :max-generation          9
;  :max-memory              8.27
;  :memory                  8.16
;  :minimized-lits          29
;  :mk-bool-var             40417
;  :mk-clause               32512
;  :num-allocs              341696
;  :num-checks              83
;  :propagations            10831
;  :quant-instantiations    15499
;  :rlimit-count            879440)
; Definitional axioms for inverse functions
(assert (forall ((i1@83@04 Int)) (!
  (implies
    (and (< i1@83@04 V@15@04) (<= 0 i1@83@04))
    (=
      (inv@84@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i1@83@04))
      i1@83@04))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i1@83@04))
  )))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@84@04 r) V@15@04) (<= 0 (inv@84@04 r)))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) (inv@84@04 r))
      r))
  :pattern ((inv@84@04 r))
  :qid |int-fctOfInv|)))
; Permissions are non-negative
; Field permissions are at most one
; Permission implies non-null receiver
(assert (forall ((i1@83@04 Int)) (!
  (implies
    (and (< i1@83@04 V@15@04) (<= 0 i1@83@04))
    (not
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i1@83@04)
        $Ref.null)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i1@83@04))
  :qid |int-permImpliesNonNull|)))
(declare-const sm@85@04 $FVF<Int>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@84@04 r) V@15@04) (<= 0 (inv@84@04 r)))
    (=
      ($FVF.lookup_int (as sm@85@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04)))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@85@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04)))))))))))))))) r))
  :qid |qp.fvfValDef48|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@81@04 r) V@15@04) (<= 0 (inv@81@04 r)))
        (< (inv@80@04 r) V@15@04))
      (<= 0 (inv@80@04 r)))
    (=
      ($FVF.lookup_int (as sm@85@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@85@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04))))))))))))) r))
  :qid |qp.fvfValDef49|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04)))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@85@04  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef50|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@84@04 r) V@15@04) (<= 0 (inv@84@04 r)))
    ($FVF.loc_int ($FVF.lookup_int (as sm@85@04  $FVF<Int>) r) r))
  :pattern ((inv@84@04 r))
  )))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04)))))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04))))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04)))))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04))))))))))))))))
  $Snap.unit))
; [eval] exc == null ==> valid_graph_vertices(this, P, V)
; [eval] exc == null
(push) ; 6
(set-option :timeout 10)
(push) ; 7
(assert (not (not (= exc@16@04 $Ref.null))))
(check-sat)
; unknown
(pop) ; 7
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               15564
;  :arith-add-rows          5253
;  :arith-assert-diseq      165
;  :arith-assert-lower      3485
;  :arith-assert-upper      2479
;  :arith-bound-prop        633
;  :arith-conflicts         65
;  :arith-eq-adapter        2406
;  :arith-fixed-eqs         2252
;  :arith-offset-eqs        1418
;  :arith-pivots            1847
;  :conflicts               153
;  :datatype-accessor-ax    51
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               800
;  :del-clause              34348
;  :final-checks            5
;  :max-generation          9
;  :max-memory              8.27
;  :memory                  7.98
;  :minimized-lits          29
;  :mk-bool-var             42857
;  :mk-clause               34621
;  :num-allocs              350308
;  :num-checks              84
;  :propagations            11577
;  :quant-instantiations    16463
;  :rlimit-count            914239
;  :time                    0.01)
; [then-branch: 56 | exc@16@04 == Null | live]
; [else-branch: 56 | exc@16@04 != Null | dead]
(push) ; 7
; [then-branch: 56 | exc@16@04 == Null]
; [eval] valid_graph_vertices(this, P, V)
(push) ; 8
; [eval] this != null
; [eval] p != (None(): option[array])
; [eval] (None(): option[array])
; [eval] alen(opt_get1(p)) == V
; [eval] alen(opt_get1(p))
; [eval] opt_get1(p)
(push) ; 9
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 9
; Joined path conditions
(declare-const i1@86@04 Int)
(push) ; 9
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 10
; [then-branch: 57 | 0 <= i1@86@04 | live]
; [else-branch: 57 | !(0 <= i1@86@04) | live]
(push) ; 11
; [then-branch: 57 | 0 <= i1@86@04]
(assert (<= 0 i1@86@04))
; [eval] i1 < V
(pop) ; 11
(push) ; 11
; [else-branch: 57 | !(0 <= i1@86@04)]
(assert (not (<= 0 i1@86@04)))
(pop) ; 11
(pop) ; 10
; Joined path conditions
; Joined path conditions
(assert (and (< i1@86@04 V@15@04) (<= 0 i1@86@04)))
(declare-const $k@87@04 $Perm)
(assert ($Perm.isReadVar $k@87@04 $Perm.Write))
; [eval] aloc(opt_get1(p), i1)
; [eval] opt_get1(p)
(push) ; 10
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 10
; Joined path conditions
(push) ; 10
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 11
(assert (not (< i1@86@04 (alen<Int> (opt_get1 $Snap.unit P@14@04)))))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               15564
;  :arith-add-rows          5254
;  :arith-assert-diseq      166
;  :arith-assert-lower      3489
;  :arith-assert-upper      2480
;  :arith-bound-prop        633
;  :arith-conflicts         65
;  :arith-eq-adapter        2407
;  :arith-fixed-eqs         2252
;  :arith-offset-eqs        1418
;  :arith-pivots            1847
;  :conflicts               153
;  :datatype-accessor-ax    51
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               800
;  :del-clause              34348
;  :final-checks            5
;  :max-generation          9
;  :max-memory              8.27
;  :memory                  7.98
;  :minimized-lits          29
;  :mk-bool-var             42863
;  :mk-clause               34623
;  :num-allocs              350479
;  :num-checks              85
;  :propagations            11578
;  :quant-instantiations    16463
;  :rlimit-count            914576)
(assert (< i1@86@04 (alen<Int> (opt_get1 $Snap.unit P@14@04))))
(pop) ; 10
; Joined path conditions
(assert (< i1@86@04 (alen<Int> (opt_get1 $Snap.unit P@14@04))))
(pop) ; 9
(declare-fun inv@88@04 ($Ref) Int)
; Nested auxiliary terms: globals
(assert ($Perm.isReadVar $k@87@04 $Perm.Write))
; Nested auxiliary terms: non-globals
(assert (forall ((i1@86@04 Int)) (!
  (< i1@86@04 (alen<Int> (opt_get1 $Snap.unit P@14@04)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i1@86@04))
  :qid |int-aux|)))
(push) ; 9
(assert (not (forall ((i1@86@04 Int)) (!
  (implies
    (and (< i1@86@04 V@15@04) (<= 0 i1@86@04))
    (or (= $k@87@04 $Perm.No) (< $Perm.No $k@87@04)))
  
  ))))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               15564
;  :arith-add-rows          5255
;  :arith-assert-diseq      167
;  :arith-assert-lower      3491
;  :arith-assert-upper      2481
;  :arith-bound-prop        633
;  :arith-conflicts         65
;  :arith-eq-adapter        2408
;  :arith-fixed-eqs         2252
;  :arith-offset-eqs        1418
;  :arith-pivots            1847
;  :conflicts               154
;  :datatype-accessor-ax    51
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               800
;  :del-clause              34350
;  :final-checks            5
;  :max-generation          9
;  :max-memory              8.27
;  :memory                  7.98
;  :minimized-lits          29
;  :mk-bool-var             42870
;  :mk-clause               34625
;  :num-allocs              350908
;  :num-checks              86
;  :propagations            11579
;  :quant-instantiations    16463
;  :rlimit-count            915122)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 9
(assert (not (forall ((i11@86@04 Int) (i12@86@04 Int)) (!
  (implies
    (and
      (and
        (and
          (and (< i11@86@04 V@15@04) (<= 0 i11@86@04))
          ($FVF.loc_int ($FVF.lookup_int (as sm@85@04  $FVF<Int>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit P@14@04) i11@86@04)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit P@14@04) i11@86@04)))
        (< $Perm.No $k@87@04))
      (and
        (and
          (and (< i12@86@04 V@15@04) (<= 0 i12@86@04))
          ($FVF.loc_int ($FVF.lookup_int (as sm@85@04  $FVF<Int>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit P@14@04) i12@86@04)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit P@14@04) i12@86@04)))
        (< $Perm.No $k@87@04))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i11@86@04)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i12@86@04)))
    (= i11@86@04 i12@86@04))
  
  :qid |int-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               15579
;  :arith-add-rows          5264
;  :arith-assert-diseq      168
;  :arith-assert-lower      3495
;  :arith-assert-upper      2481
;  :arith-bound-prop        633
;  :arith-conflicts         65
;  :arith-eq-adapter        2409
;  :arith-fixed-eqs         2252
;  :arith-offset-eqs        1418
;  :arith-pivots            1849
;  :conflicts               155
;  :datatype-accessor-ax    51
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               800
;  :del-clause              34361
;  :final-checks            5
;  :max-generation          9
;  :max-memory              8.27
;  :memory                  7.99
;  :minimized-lits          29
;  :mk-bool-var             42906
;  :mk-clause               34636
;  :num-allocs              351374
;  :num-checks              87
;  :propagations            11581
;  :quant-instantiations    16487
;  :rlimit-count            916386)
; Definitional axioms for inverse functions
(assert (forall ((i1@86@04 Int)) (!
  (implies
    (and (and (< i1@86@04 V@15@04) (<= 0 i1@86@04)) (< $Perm.No $k@87@04))
    (=
      (inv@88@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i1@86@04))
      i1@86@04))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i1@86@04))
  :qid |int-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and (< (inv@88@04 r) V@15@04) (<= 0 (inv@88@04 r)))
      (< $Perm.No $k@87@04))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) (inv@88@04 r))
      r))
  :pattern ((inv@88@04 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@88@04 r) V@15@04) (<= 0 (inv@88@04 r)))
    ($FVF.loc_int ($FVF.lookup_int (as sm@85@04  $FVF<Int>) r) r))
  :pattern ((inv@88@04 r))
  )))
; Precomputing data for removing quantified permissions
(define-fun pTaken@89@04 ((r $Ref)) $Perm
  (ite
    (and (< (inv@88@04 r) V@15@04) (<= 0 (inv@88@04 r)))
    ($Perm.min
      (ite
        (and (< (inv@84@04 r) V@15@04) (<= 0 (inv@84@04 r)))
        $Perm.Write
        $Perm.No)
      $k@87@04)
    $Perm.No))
(define-fun pTaken@90@04 ((r $Ref)) $Perm
  (ite
    (and (< (inv@88@04 r) V@15@04) (<= 0 (inv@88@04 r)))
    ($Perm.min
      (ite
        (and
          (and
            (and (< (inv@81@04 r) V@15@04) (<= 0 (inv@81@04 r)))
            (< (inv@80@04 r) V@15@04))
          (<= 0 (inv@80@04 r)))
        $Perm.Write
        $Perm.No)
      (- $k@87@04 (pTaken@89@04 r)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Constrain original permissions $k@87@04
(assert (forall ((r $Ref)) (!
  (implies
    (not
      (=
        (ite
          (and (< (inv@84@04 r) V@15@04) (<= 0 (inv@84@04 r)))
          $Perm.Write
          $Perm.No)
        $Perm.No))
    (ite
      (and (< (inv@84@04 r) V@15@04) (<= 0 (inv@84@04 r)))
      (<
        (ite
          (and (< (inv@88@04 r) V@15@04) (<= 0 (inv@88@04 r)))
          $k@87@04
          $Perm.No)
        $Perm.Write)
      (<
        (ite
          (and (< (inv@88@04 r) V@15@04) (<= 0 (inv@88@04 r)))
          $k@87@04
          $Perm.No)
        $Perm.No)))
  :pattern ((inv@84@04 r))
  :pattern ((inv@88@04 r))
  :qid |qp.srp51|)))
; Intermediate check if already taken enough permissions
(set-option :timeout 500)
(push) ; 9
(assert (not (forall ((r $Ref)) (!
  (implies
    (and (< (inv@88@04 r) V@15@04) (<= 0 (inv@88@04 r)))
    (= (- $k@87@04 (pTaken@89@04 r)) $Perm.No))
  
  ))))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               16253
;  :arith-add-rows          5481
;  :arith-assert-diseq      181
;  :arith-assert-lower      3652
;  :arith-assert-upper      2596
;  :arith-bound-prop        664
;  :arith-conflicts         68
;  :arith-eq-adapter        2542
;  :arith-fixed-eqs         2354
;  :arith-offset-eqs        1463
;  :arith-pivots            1931
;  :conflicts               169
;  :datatype-accessor-ax    51
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               835
;  :del-clause              36418
;  :final-checks            5
;  :max-generation          9
;  :max-memory              8.27
;  :memory                  8.08
;  :minimized-lits          30
;  :mk-bool-var             45235
;  :mk-clause               36726
;  :num-allocs              360781
;  :num-checks              89
;  :propagations            12151
;  :quant-instantiations    17323
;  :rlimit-count            960064
;  :time                    0.00)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@91@04 $FVF<Int>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (iff
    (Set_in r ($FVF.domain_int (as sm@91@04  $FVF<Int>)))
    (and
      (and (< (inv@88@04 r) V@15@04) (<= 0 (inv@88@04 r)))
      (< $Perm.No $k@87@04)))
  :pattern ((Set_in r ($FVF.domain_int (as sm@91@04  $FVF<Int>))))
  :qid |qp.fvfDomDef55|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@88@04 r) V@15@04) (<= 0 (inv@88@04 r)))
        (< $Perm.No $k@87@04))
      (and (< (inv@84@04 r) V@15@04) (<= 0 (inv@84@04 r))))
    (=
      ($FVF.lookup_int (as sm@91@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04)))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@91@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04)))))))))))))))) r))
  :qid |qp.fvfValDef52|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@88@04 r) V@15@04) (<= 0 (inv@88@04 r)))
        (< $Perm.No $k@87@04))
      (and
        (and
          (and (< (inv@81@04 r) V@15@04) (<= 0 (inv@81@04 r)))
          (< (inv@80@04 r) V@15@04))
        (<= 0 (inv@80@04 r))))
    (=
      ($FVF.lookup_int (as sm@91@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@91@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04))))))))))))) r))
  :qid |qp.fvfValDef53|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04)))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@91@04  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef54|)))
(pop) ; 8
; Joined path conditions
(assert ($Perm.isReadVar $k@87@04 $Perm.Write))
(assert (forall ((i1@86@04 Int)) (!
  (implies
    (and (and (< i1@86@04 V@15@04) (<= 0 i1@86@04)) (< $Perm.No $k@87@04))
    (=
      (inv@88@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i1@86@04))
      i1@86@04))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i1@86@04))
  :qid |int-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and (< (inv@88@04 r) V@15@04) (<= 0 (inv@88@04 r)))
      (< $Perm.No $k@87@04))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) (inv@88@04 r))
      r))
  :pattern ((inv@88@04 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (iff
    (Set_in r ($FVF.domain_int (as sm@91@04  $FVF<Int>)))
    (and
      (and (< (inv@88@04 r) V@15@04) (<= 0 (inv@88@04 r)))
      (< $Perm.No $k@87@04)))
  :pattern ((Set_in r ($FVF.domain_int (as sm@91@04  $FVF<Int>))))
  :qid |qp.fvfDomDef55|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@88@04 r) V@15@04) (<= 0 (inv@88@04 r)))
        (< $Perm.No $k@87@04))
      (and (< (inv@84@04 r) V@15@04) (<= 0 (inv@84@04 r))))
    (=
      ($FVF.lookup_int (as sm@91@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04)))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@91@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04)))))))))))))))) r))
  :qid |qp.fvfValDef52|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@88@04 r) V@15@04) (<= 0 (inv@88@04 r)))
        (< $Perm.No $k@87@04))
      (and
        (and
          (and (< (inv@81@04 r) V@15@04) (<= 0 (inv@81@04 r)))
          (< (inv@80@04 r) V@15@04))
        (<= 0 (inv@80@04 r))))
    (=
      ($FVF.lookup_int (as sm@91@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@91@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04))))))))))))) r))
  :qid |qp.fvfValDef53|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04)))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@91@04  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef54|)))
(assert (and
  (forall ((i1@86@04 Int)) (!
    (< i1@86@04 (alen<Int> (opt_get1 $Snap.unit P@14@04)))
    :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i1@86@04))
    :qid |int-aux|))
  (forall ((r $Ref)) (!
    (implies
      (and (< (inv@88@04 r) V@15@04) (<= 0 (inv@88@04 r)))
      ($FVF.loc_int ($FVF.lookup_int (as sm@85@04  $FVF<Int>) r) r))
    :pattern ((inv@88@04 r))
    ))
  (forall ((r $Ref)) (!
    (implies
      (not
        (=
          (ite
            (and (< (inv@84@04 r) V@15@04) (<= 0 (inv@84@04 r)))
            $Perm.Write
            $Perm.No)
          $Perm.No))
      (ite
        (and (< (inv@84@04 r) V@15@04) (<= 0 (inv@84@04 r)))
        (<
          (ite
            (and (< (inv@88@04 r) V@15@04) (<= 0 (inv@88@04 r)))
            $k@87@04
            $Perm.No)
          $Perm.Write)
        (<
          (ite
            (and (< (inv@88@04 r) V@15@04) (<= 0 (inv@88@04 r)))
            $k@87@04
            $Perm.No)
          $Perm.No)))
    :pattern ((inv@84@04 r))
    :pattern ((inv@88@04 r))
    :qid |qp.srp51|))))
(pop) ; 7
(pop) ; 6
; Joined path conditions
(assert ($Perm.isReadVar $k@87@04 $Perm.Write))
(assert (forall ((i1@86@04 Int)) (!
  (implies
    (and (and (< i1@86@04 V@15@04) (<= 0 i1@86@04)) (< $Perm.No $k@87@04))
    (=
      (inv@88@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i1@86@04))
      i1@86@04))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i1@86@04))
  :qid |int-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and (< (inv@88@04 r) V@15@04) (<= 0 (inv@88@04 r)))
      (< $Perm.No $k@87@04))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) (inv@88@04 r))
      r))
  :pattern ((inv@88@04 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (iff
    (Set_in r ($FVF.domain_int (as sm@91@04  $FVF<Int>)))
    (and
      (and (< (inv@88@04 r) V@15@04) (<= 0 (inv@88@04 r)))
      (< $Perm.No $k@87@04)))
  :pattern ((Set_in r ($FVF.domain_int (as sm@91@04  $FVF<Int>))))
  :qid |qp.fvfDomDef55|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@88@04 r) V@15@04) (<= 0 (inv@88@04 r)))
        (< $Perm.No $k@87@04))
      (and (< (inv@84@04 r) V@15@04) (<= 0 (inv@84@04 r))))
    (=
      ($FVF.lookup_int (as sm@91@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04)))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@91@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04)))))))))))))))) r))
  :qid |qp.fvfValDef52|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@88@04 r) V@15@04) (<= 0 (inv@88@04 r)))
        (< $Perm.No $k@87@04))
      (and
        (and
          (and (< (inv@81@04 r) V@15@04) (<= 0 (inv@81@04 r)))
          (< (inv@80@04 r) V@15@04))
        (<= 0 (inv@80@04 r))))
    (=
      ($FVF.lookup_int (as sm@91@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@91@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04))))))))))))) r))
  :qid |qp.fvfValDef53|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04)))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@91@04  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef54|)))
(assert (implies
  (= exc@16@04 $Ref.null)
  (and
    (forall ((i1@86@04 Int)) (!
      (< i1@86@04 (alen<Int> (opt_get1 $Snap.unit P@14@04)))
      :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i1@86@04))
      :qid |int-aux|))
    (forall ((r $Ref)) (!
      (implies
        (and (< (inv@88@04 r) V@15@04) (<= 0 (inv@88@04 r)))
        ($FVF.loc_int ($FVF.lookup_int (as sm@85@04  $FVF<Int>) r) r))
      :pattern ((inv@88@04 r))
      ))
    (forall ((r $Ref)) (!
      (implies
        (not
          (=
            (ite
              (and (< (inv@84@04 r) V@15@04) (<= 0 (inv@84@04 r)))
              $Perm.Write
              $Perm.No)
            $Perm.No))
        (ite
          (and (< (inv@84@04 r) V@15@04) (<= 0 (inv@84@04 r)))
          (<
            (ite
              (and (< (inv@88@04 r) V@15@04) (<= 0 (inv@88@04 r)))
              $k@87@04
              $Perm.No)
            $Perm.Write)
          (<
            (ite
              (and (< (inv@88@04 r) V@15@04) (<= 0 (inv@88@04 r)))
              $k@87@04
              $Perm.No)
            $Perm.No)))
      :pattern ((inv@84@04 r))
      :pattern ((inv@88@04 r))
      :qid |qp.srp51|)))))
(assert (implies
  (= exc@16@04 $Ref.null)
  (valid_graph_vertices ($Snap.combine
    $Snap.unit
    ($Snap.combine
      $Snap.unit
      ($Snap.combine
        $Snap.unit
        ($SortWrappers.$FVF<Int>To$Snap (as sm@91@04  $FVF<Int>))))) this@9@04 P@14@04 V@15@04)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04))))))))))))))))
  $Snap.unit))
; [eval] exc == null ==> FlowNetwork1(this, G, V, s, t)
; [eval] exc == null
(push) ; 6
(set-option :timeout 10)
(push) ; 7
(assert (not (not (= exc@16@04 $Ref.null))))
(check-sat)
; unknown
(pop) ; 7
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               16771
;  :arith-add-rows          5631
;  :arith-assert-diseq      185
;  :arith-assert-lower      3769
;  :arith-assert-upper      2680
;  :arith-bound-prop        683
;  :arith-conflicts         69
;  :arith-eq-adapter        2615
;  :arith-fixed-eqs         2432
;  :arith-offset-eqs        1487
;  :arith-pivots            1979
;  :conflicts               170
;  :datatype-accessor-ax    54
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               865
;  :del-clause              38062
;  :final-checks            5
;  :max-generation          11
;  :max-memory              8.29
;  :memory                  8.18
;  :minimized-lits          30
;  :mk-bool-var             47117
;  :mk-clause               38387
;  :num-allocs              369289
;  :num-checks              90
;  :propagations            12601
;  :quant-instantiations    17972
;  :rlimit-count            994906
;  :time                    0.01)
; [then-branch: 58 | exc@16@04 == Null | live]
; [else-branch: 58 | exc@16@04 != Null | dead]
(push) ; 7
; [then-branch: 58 | exc@16@04 == Null]
; [eval] FlowNetwork1(this, G, V, s, t)
(push) ; 8
; [eval] this != null
; [eval] G != (None(): option[array])
; [eval] (None(): option[array])
; [eval] alen(opt_get1(G)) == V
; [eval] alen(opt_get1(G))
; [eval] opt_get1(G)
(push) ; 9
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 9
; Joined path conditions
(declare-const i1@92@04 Int)
(push) ; 9
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 10
; [then-branch: 59 | 0 <= i1@92@04 | live]
; [else-branch: 59 | !(0 <= i1@92@04) | live]
(push) ; 11
; [then-branch: 59 | 0 <= i1@92@04]
(assert (<= 0 i1@92@04))
; [eval] i1 < V
(pop) ; 11
(push) ; 11
; [else-branch: 59 | !(0 <= i1@92@04)]
(assert (not (<= 0 i1@92@04)))
(pop) ; 11
(pop) ; 10
; Joined path conditions
; Joined path conditions
(assert (and (< i1@92@04 V@15@04) (<= 0 i1@92@04)))
(declare-const $k@93@04 $Perm)
(assert ($Perm.isReadVar $k@93@04 $Perm.Write))
; [eval] aloc(opt_get1(G), i1)
; [eval] opt_get1(G)
(push) ; 10
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 10
; Joined path conditions
(push) ; 10
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 11
(assert (not (< i1@92@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               16771
;  :arith-add-rows          5632
;  :arith-assert-diseq      186
;  :arith-assert-lower      3773
;  :arith-assert-upper      2681
;  :arith-bound-prop        683
;  :arith-conflicts         69
;  :arith-eq-adapter        2616
;  :arith-fixed-eqs         2432
;  :arith-offset-eqs        1487
;  :arith-pivots            1979
;  :conflicts               170
;  :datatype-accessor-ax    54
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               865
;  :del-clause              38062
;  :final-checks            5
;  :max-generation          11
;  :max-memory              8.29
;  :memory                  8.18
;  :minimized-lits          30
;  :mk-bool-var             47123
;  :mk-clause               38389
;  :num-allocs              369460
;  :num-checks              91
;  :propagations            12602
;  :quant-instantiations    17972
;  :rlimit-count            995244)
(assert (< i1@92@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(pop) ; 10
; Joined path conditions
(assert (< i1@92@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(pop) ; 9
(declare-fun inv@94@04 ($Ref) Int)
; Nested auxiliary terms: globals
(assert ($Perm.isReadVar $k@93@04 $Perm.Write))
; Nested auxiliary terms: non-globals
(assert (forall ((i1@92@04 Int)) (!
  (< i1@92@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@92@04))
  :qid |option$array$-aux|)))
(push) ; 9
(assert (not (forall ((i1@92@04 Int)) (!
  (implies
    (and (< i1@92@04 V@15@04) (<= 0 i1@92@04))
    (or (= $k@93@04 $Perm.No) (< $Perm.No $k@93@04)))
  
  ))))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               16771
;  :arith-add-rows          5633
;  :arith-assert-diseq      187
;  :arith-assert-lower      3775
;  :arith-assert-upper      2682
;  :arith-bound-prop        683
;  :arith-conflicts         69
;  :arith-eq-adapter        2617
;  :arith-fixed-eqs         2432
;  :arith-offset-eqs        1487
;  :arith-pivots            1979
;  :conflicts               171
;  :datatype-accessor-ax    54
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               865
;  :del-clause              38064
;  :final-checks            5
;  :max-generation          11
;  :max-memory              8.29
;  :memory                  8.18
;  :minimized-lits          30
;  :mk-bool-var             47130
;  :mk-clause               38391
;  :num-allocs              369888
;  :num-checks              92
;  :propagations            12603
;  :quant-instantiations    17972
;  :rlimit-count            995790)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 9
(assert (not (forall ((i11@92@04 Int) (i12@92@04 Int)) (!
  (implies
    (and
      (and
        (and
          (and (< i11@92@04 V@15@04) (<= 0 i11@92@04))
          ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@73@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i11@92@04)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i11@92@04)))
        (< $Perm.No $k@93@04))
      (and
        (and
          (and (< i12@92@04 V@15@04) (<= 0 i12@92@04))
          ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@73@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i12@92@04)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i12@92@04)))
        (< $Perm.No $k@93@04))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i11@92@04)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i12@92@04)))
    (= i11@92@04 i12@92@04))
  
  :qid |option$array$-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               16791
;  :arith-add-rows          5640
;  :arith-assert-diseq      188
;  :arith-assert-lower      3779
;  :arith-assert-upper      2682
;  :arith-bound-prop        683
;  :arith-conflicts         69
;  :arith-eq-adapter        2618
;  :arith-fixed-eqs         2432
;  :arith-offset-eqs        1487
;  :arith-pivots            1983
;  :conflicts               172
;  :datatype-accessor-ax    54
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               865
;  :del-clause              38071
;  :final-checks            5
;  :max-generation          11
;  :max-memory              8.29
;  :memory                  8.18
;  :minimized-lits          30
;  :mk-bool-var             47167
;  :mk-clause               38398
;  :num-allocs              370412
;  :num-checks              93
;  :propagations            12603
;  :quant-instantiations    18002
;  :rlimit-count            997212)
; Definitional axioms for inverse functions
(assert (forall ((i1@92@04 Int)) (!
  (implies
    (and (and (< i1@92@04 V@15@04) (<= 0 i1@92@04)) (< $Perm.No $k@93@04))
    (=
      (inv@94@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@92@04))
      i1@92@04))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@92@04))
  :qid |option$array$-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and (< (inv@94@04 r) V@15@04) (<= 0 (inv@94@04 r)))
      (< $Perm.No $k@93@04))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) (inv@94@04 r))
      r))
  :pattern ((inv@94@04 r))
  :qid |option$array$-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@94@04 r) V@15@04) (<= 0 (inv@94@04 r)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@73@04  $FVF<option<array>>) r) r))
  :pattern ((inv@94@04 r))
  )))
; Precomputing data for removing quantified permissions
(define-fun pTaken@95@04 ((r $Ref)) $Perm
  (ite
    (and (< (inv@94@04 r) V@15@04) (<= 0 (inv@94@04 r)))
    ($Perm.min
      (ite
        (and (< (inv@72@04 r) V@15@04) (<= 0 (inv@72@04 r)))
        $k@71@04
        $Perm.No)
      $k@93@04)
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Constrain original permissions $k@93@04
(assert (forall ((r $Ref)) (!
  (implies
    (not
      (=
        (ite
          (and (< (inv@72@04 r) V@15@04) (<= 0 (inv@72@04 r)))
          $k@71@04
          $Perm.No)
        $Perm.No))
    (ite
      (and (< (inv@72@04 r) V@15@04) (<= 0 (inv@72@04 r)))
      (<
        (ite
          (and (< (inv@94@04 r) V@15@04) (<= 0 (inv@94@04 r)))
          $k@93@04
          $Perm.No)
        $k@71@04)
      (<
        (ite
          (and (< (inv@94@04 r) V@15@04) (<= 0 (inv@94@04 r)))
          $k@93@04
          $Perm.No)
        $Perm.No)))
  :pattern ((inv@72@04 r))
  :pattern ((inv@94@04 r))
  :qid |qp.srp56|)))
; Intermediate check if already taken enough permissions
(set-option :timeout 500)
(push) ; 9
(assert (not (forall ((r $Ref)) (!
  (implies
    (and (< (inv@94@04 r) V@15@04) (<= 0 (inv@94@04 r)))
    (= (- $k@93@04 (pTaken@95@04 r)) $Perm.No))
  
  ))))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               17597
;  :arith-add-rows          5992
;  :arith-assert-diseq      203
;  :arith-assert-lower      3952
;  :arith-assert-upper      2809
;  :arith-bound-prop        726
;  :arith-conflicts         72
;  :arith-eq-adapter        2770
;  :arith-fixed-eqs         2547
;  :arith-offset-eqs        1564
;  :arith-pivots            2084
;  :conflicts               192
;  :datatype-accessor-ax    54
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               911
;  :del-clause              40640
;  :final-checks            5
;  :max-generation          11
;  :max-memory              8.41
;  :memory                  8.29
;  :minimized-lits          35
;  :mk-bool-var             50061
;  :mk-clause               41008
;  :num-allocs              381441
;  :num-checks              95
;  :propagations            13251
;  :quant-instantiations    18989
;  :rlimit-count            1044124
;  :time                    0.00)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@96@04 $FVF<option<array>>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (iff
    (Set_in r ($FVF.domain_option$array$ (as sm@96@04  $FVF<option<array>>)))
    (and
      (and (< (inv@94@04 r) V@15@04) (<= 0 (inv@94@04 r)))
      (< $Perm.No $k@93@04)))
  :pattern ((Set_in r ($FVF.domain_option$array$ (as sm@96@04  $FVF<option<array>>))))
  :qid |qp.fvfDomDef59|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@94@04 r) V@15@04) (<= 0 (inv@94@04 r)))
        (< $Perm.No $k@93@04))
      (ite
        (and (< (inv@72@04 r) V@15@04) (<= 0 (inv@72@04 r)))
        (< $Perm.No $k@71@04)
        false))
    (=
      ($FVF.lookup_option$array$ (as sm@96@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@96@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04))))))))) r))
  :qid |qp.fvfValDef57|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04))))))))) r) r)
  :pattern (($FVF.lookup_option$array$ (as sm@96@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef58|)))
; [eval] (forall i1: Int :: 0 <= i1 && i1 < V ==> aloc(opt_get1(G), i1).option$array$ != (None(): option[array]))
(declare-const i1@97@04 Int)
(push) ; 9
; [eval] 0 <= i1 && i1 < V ==> aloc(opt_get1(G), i1).option$array$ != (None(): option[array])
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 10
; [then-branch: 60 | 0 <= i1@97@04 | live]
; [else-branch: 60 | !(0 <= i1@97@04) | live]
(push) ; 11
; [then-branch: 60 | 0 <= i1@97@04]
(assert (<= 0 i1@97@04))
; [eval] i1 < V
(pop) ; 11
(push) ; 11
; [else-branch: 60 | !(0 <= i1@97@04)]
(assert (not (<= 0 i1@97@04)))
(pop) ; 11
(pop) ; 10
; Joined path conditions
; Joined path conditions
(push) ; 10
; [then-branch: 61 | i1@97@04 < V@15@04 && 0 <= i1@97@04 | live]
; [else-branch: 61 | !(i1@97@04 < V@15@04 && 0 <= i1@97@04) | live]
(push) ; 11
; [then-branch: 61 | i1@97@04 < V@15@04 && 0 <= i1@97@04]
(assert (and (< i1@97@04 V@15@04) (<= 0 i1@97@04)))
; [eval] aloc(opt_get1(G), i1).option$array$ != (None(): option[array])
; [eval] aloc(opt_get1(G), i1)
; [eval] opt_get1(G)
(push) ; 12
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 12
; Joined path conditions
(push) ; 12
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 13
(assert (not (< i1@97@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))))
(check-sat)
; unsat
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               17597
;  :arith-add-rows          5993
;  :arith-assert-diseq      203
;  :arith-assert-lower      3954
;  :arith-assert-upper      2809
;  :arith-bound-prop        726
;  :arith-conflicts         72
;  :arith-eq-adapter        2770
;  :arith-fixed-eqs         2547
;  :arith-offset-eqs        1564
;  :arith-pivots            2085
;  :conflicts               192
;  :datatype-accessor-ax    54
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               911
;  :del-clause              40640
;  :final-checks            5
;  :max-generation          11
;  :max-memory              8.41
;  :memory                  8.29
;  :minimized-lits          35
;  :mk-bool-var             50066
;  :mk-clause               41008
;  :num-allocs              382044
;  :num-checks              96
;  :propagations            13251
;  :quant-instantiations    18989
;  :rlimit-count            1045474)
(assert (< i1@97@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(pop) ; 12
; Joined path conditions
(assert (< i1@97@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(declare-const sm@98@04 $FVF<option<array>>)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@72@04 r) V@15@04) (<= 0 (inv@72@04 r)))
      (< $Perm.No $k@71@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@98@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@98@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04))))))))) r))
  :qid |qp.fvfValDef60|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04))))))))) r) r)
  :pattern (($FVF.lookup_option$array$ (as sm@98@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef61|)))
(declare-const pm@99@04 $FPM)
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@99@04  $FPM) r)
    (ite (and (< (inv@72@04 r) V@15@04) (<= 0 (inv@72@04 r))) $k@71@04 $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@99@04  $FPM) r))
  :qid |qp.resPrmSumDef62|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@98@04  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04))))))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@99@04  $FPM) r))
  :qid |qp.resTrgDef63|)))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@98@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@97@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@97@04)))
(push) ; 12
(assert (not (<
  $Perm.No
  ($FVF.perm_option$array$ (as pm@99@04  $FPM) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@97@04)))))
(check-sat)
; unsat
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               17667
;  :arith-add-rows          6023
;  :arith-assert-diseq      206
;  :arith-assert-lower      3969
;  :arith-assert-upper      2819
;  :arith-bound-prop        732
;  :arith-conflicts         74
;  :arith-eq-adapter        2782
;  :arith-fixed-eqs         2555
;  :arith-offset-eqs        1575
;  :arith-pivots            2095
;  :conflicts               195
;  :datatype-accessor-ax    54
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               913
;  :del-clause              40644
;  :final-checks            5
;  :max-generation          11
;  :max-memory              8.41
;  :memory                  8.28
;  :minimized-lits          35
;  :mk-bool-var             50247
;  :mk-clause               41112
;  :num-allocs              383551
;  :num-checks              97
;  :propagations            13267
;  :quant-instantiations    19054
;  :rlimit-count            1050001)
; [eval] (None(): option[array])
(pop) ; 11
(push) ; 11
; [else-branch: 61 | !(i1@97@04 < V@15@04 && 0 <= i1@97@04)]
(assert (not (and (< i1@97@04 V@15@04) (<= 0 i1@97@04))))
(pop) ; 11
(pop) ; 10
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@72@04 r) V@15@04) (<= 0 (inv@72@04 r)))
      (< $Perm.No $k@71@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@98@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@98@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04))))))))) r))
  :qid |qp.fvfValDef60|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04))))))))) r) r)
  :pattern (($FVF.lookup_option$array$ (as sm@98@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef61|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@99@04  $FPM) r)
    (ite (and (< (inv@72@04 r) V@15@04) (<= 0 (inv@72@04 r))) $k@71@04 $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@99@04  $FPM) r))
  :qid |qp.resPrmSumDef62|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@98@04  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04))))))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@99@04  $FPM) r))
  :qid |qp.resTrgDef63|)))
(assert (implies
  (and (< i1@97@04 V@15@04) (<= 0 i1@97@04))
  (and
    (< i1@97@04 V@15@04)
    (<= 0 i1@97@04)
    (< i1@97@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@98@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@97@04)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@97@04)))))
; Joined path conditions
(pop) ; 9
; Nested auxiliary terms: globals (aux)
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@72@04 r) V@15@04) (<= 0 (inv@72@04 r)))
      (< $Perm.No $k@71@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@98@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@98@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04))))))))) r))
  :qid |qp.fvfValDef60|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04))))))))) r) r)
  :pattern (($FVF.lookup_option$array$ (as sm@98@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef61|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@99@04  $FPM) r)
    (ite (and (< (inv@72@04 r) V@15@04) (<= 0 (inv@72@04 r))) $k@71@04 $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@99@04  $FPM) r))
  :qid |qp.resPrmSumDef62|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@98@04  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04))))))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@99@04  $FPM) r))
  :qid |qp.resTrgDef63|)))
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
; Nested auxiliary terms: non-globals (tlq)
(push) ; 9
(assert (not (forall ((i1@97@04 Int)) (!
  (implies
    (and (< i1@97@04 V@15@04) (<= 0 i1@97@04))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@98@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@97@04))
        (as None<option<array>>  option<array>))))
  
  :qid |prog.l<no position>|))))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               17787
;  :arith-add-rows          6102
;  :arith-assert-diseq      208
;  :arith-assert-lower      3993
;  :arith-assert-upper      2835
;  :arith-bound-prop        742
;  :arith-conflicts         75
;  :arith-eq-adapter        2798
;  :arith-fixed-eqs         2568
;  :arith-offset-eqs        1591
;  :arith-pivots            2124
;  :conflicts               212
;  :datatype-accessor-ax    54
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               929
;  :del-clause              41380
;  :final-checks            5
;  :max-generation          11
;  :max-memory              8.41
;  :memory                  8.26
;  :minimized-lits          35
;  :mk-bool-var             50801
;  :mk-clause               41748
;  :num-allocs              386304
;  :num-checks              98
;  :propagations            13355
;  :quant-instantiations    19232
;  :rlimit-count            1061160
;  :time                    0.00)
(assert (forall ((i1@97@04 Int)) (!
  (implies
    (and (< i1@97@04 V@15@04) (<= 0 i1@97@04))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@98@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@97@04))
        (as None<option<array>>  option<array>))))
  
  :qid |prog.l<no position>|)))
; [eval] (forall i1: Int :: 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(G), i1).option$array$)) == V)
(declare-const i1@100@04 Int)
(push) ; 9
; [eval] 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(G), i1).option$array$)) == V
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 10
; [then-branch: 62 | 0 <= i1@100@04 | live]
; [else-branch: 62 | !(0 <= i1@100@04) | live]
(push) ; 11
; [then-branch: 62 | 0 <= i1@100@04]
(assert (<= 0 i1@100@04))
; [eval] i1 < V
(pop) ; 11
(push) ; 11
; [else-branch: 62 | !(0 <= i1@100@04)]
(assert (not (<= 0 i1@100@04)))
(pop) ; 11
(pop) ; 10
; Joined path conditions
; Joined path conditions
(push) ; 10
; [then-branch: 63 | i1@100@04 < V@15@04 && 0 <= i1@100@04 | live]
; [else-branch: 63 | !(i1@100@04 < V@15@04 && 0 <= i1@100@04) | live]
(push) ; 11
; [then-branch: 63 | i1@100@04 < V@15@04 && 0 <= i1@100@04]
(assert (and (< i1@100@04 V@15@04) (<= 0 i1@100@04)))
; [eval] alen(opt_get1(aloc(opt_get1(G), i1).option$array$)) == V
; [eval] alen(opt_get1(aloc(opt_get1(G), i1).option$array$))
; [eval] opt_get1(aloc(opt_get1(G), i1).option$array$)
; [eval] aloc(opt_get1(G), i1)
; [eval] opt_get1(G)
(push) ; 12
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 12
; Joined path conditions
(push) ; 12
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 13
(assert (not (< i1@100@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))))
(check-sat)
; unsat
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               17787
;  :arith-add-rows          6103
;  :arith-assert-diseq      208
;  :arith-assert-lower      3995
;  :arith-assert-upper      2835
;  :arith-bound-prop        742
;  :arith-conflicts         75
;  :arith-eq-adapter        2798
;  :arith-fixed-eqs         2568
;  :arith-offset-eqs        1591
;  :arith-pivots            2124
;  :conflicts               212
;  :datatype-accessor-ax    54
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               929
;  :del-clause              41380
;  :final-checks            5
;  :max-generation          11
;  :max-memory              8.41
;  :memory                  8.30
;  :minimized-lits          35
;  :mk-bool-var             50804
;  :mk-clause               41748
;  :num-allocs              386623
;  :num-checks              99
;  :propagations            13355
;  :quant-instantiations    19232
;  :rlimit-count            1061630)
(assert (< i1@100@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(pop) ; 12
; Joined path conditions
(assert (< i1@100@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(declare-const sm@101@04 $FVF<option<array>>)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@72@04 r) V@15@04) (<= 0 (inv@72@04 r)))
      (< $Perm.No $k@71@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@101@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@101@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04))))))))) r))
  :qid |qp.fvfValDef64|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04))))))))) r) r)
  :pattern (($FVF.lookup_option$array$ (as sm@101@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef65|)))
(declare-const pm@102@04 $FPM)
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@102@04  $FPM) r)
    (ite (and (< (inv@72@04 r) V@15@04) (<= 0 (inv@72@04 r))) $k@71@04 $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@102@04  $FPM) r))
  :qid |qp.resPrmSumDef66|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@101@04  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04))))))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@102@04  $FPM) r))
  :qid |qp.resTrgDef67|)))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@101@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@100@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@100@04)))
(push) ; 12
(assert (not (<
  $Perm.No
  ($FVF.perm_option$array$ (as pm@102@04  $FPM) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@100@04)))))
(check-sat)
; unsat
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               17849
;  :arith-add-rows          6128
;  :arith-assert-diseq      211
;  :arith-assert-lower      4007
;  :arith-assert-upper      2848
;  :arith-bound-prop        747
;  :arith-conflicts         77
;  :arith-eq-adapter        2810
;  :arith-fixed-eqs         2576
;  :arith-offset-eqs        1591
;  :arith-pivots            2136
;  :conflicts               215
;  :datatype-accessor-ax    54
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               931
;  :del-clause              41384
;  :final-checks            5
;  :max-generation          11
;  :max-memory              8.41
;  :memory                  8.31
;  :minimized-lits          35
;  :mk-bool-var             50988
;  :mk-clause               41853
;  :num-allocs              388133
;  :num-checks              100
;  :propagations            13370
;  :quant-instantiations    19299
;  :rlimit-count            1066214)
(push) ; 12
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 13
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@101@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@100@04))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               17953
;  :arith-add-rows          6182
;  :arith-assert-diseq      213
;  :arith-assert-lower      4022
;  :arith-assert-upper      2858
;  :arith-bound-prop        752
;  :arith-conflicts         78
;  :arith-eq-adapter        2820
;  :arith-fixed-eqs         2583
;  :arith-offset-eqs        1607
;  :arith-pivots            2143
;  :conflicts               232
;  :datatype-accessor-ax    54
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               947
;  :del-clause              41912
;  :final-checks            5
;  :max-generation          11
;  :max-memory              8.41
;  :memory                  8.31
;  :minimized-lits          35
;  :mk-bool-var             51379
;  :mk-clause               42381
;  :num-allocs              389437
;  :num-checks              101
;  :propagations            13476
;  :quant-instantiations    19416
;  :rlimit-count            1072751
;  :time                    0.00)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@101@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@100@04))
    (as None<option<array>>  option<array>))))
(pop) ; 12
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@101@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@100@04))
    (as None<option<array>>  option<array>))))
(pop) ; 11
(push) ; 11
; [else-branch: 63 | !(i1@100@04 < V@15@04 && 0 <= i1@100@04)]
(assert (not (and (< i1@100@04 V@15@04) (<= 0 i1@100@04))))
(pop) ; 11
(pop) ; 10
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@72@04 r) V@15@04) (<= 0 (inv@72@04 r)))
      (< $Perm.No $k@71@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@101@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@101@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04))))))))) r))
  :qid |qp.fvfValDef64|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04))))))))) r) r)
  :pattern (($FVF.lookup_option$array$ (as sm@101@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef65|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@102@04  $FPM) r)
    (ite (and (< (inv@72@04 r) V@15@04) (<= 0 (inv@72@04 r))) $k@71@04 $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@102@04  $FPM) r))
  :qid |qp.resPrmSumDef66|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@101@04  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04))))))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@102@04  $FPM) r))
  :qid |qp.resTrgDef67|)))
(assert (implies
  (and (< i1@100@04 V@15@04) (<= 0 i1@100@04))
  (and
    (< i1@100@04 V@15@04)
    (<= 0 i1@100@04)
    (< i1@100@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@101@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@100@04)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@100@04))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@101@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@100@04))
        (as None<option<array>>  option<array>))))))
; Joined path conditions
(pop) ; 9
; Nested auxiliary terms: globals (aux)
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@72@04 r) V@15@04) (<= 0 (inv@72@04 r)))
      (< $Perm.No $k@71@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@101@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@101@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04))))))))) r))
  :qid |qp.fvfValDef64|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04))))))))) r) r)
  :pattern (($FVF.lookup_option$array$ (as sm@101@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef65|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@102@04  $FPM) r)
    (ite (and (< (inv@72@04 r) V@15@04) (<= 0 (inv@72@04 r))) $k@71@04 $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@102@04  $FPM) r))
  :qid |qp.resPrmSumDef66|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@101@04  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04))))))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@102@04  $FPM) r))
  :qid |qp.resTrgDef67|)))
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
; Nested auxiliary terms: non-globals (tlq)
(push) ; 9
(assert (not (forall ((i1@100@04 Int)) (!
  (implies
    (and (< i1@100@04 V@15@04) (<= 0 i1@100@04))
    (=
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@101@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@100@04))))
      V@15@04))
  
  :qid |prog.l<no position>|))))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               18119
;  :arith-add-rows          6268
;  :arith-assert-diseq      217
;  :arith-assert-lower      4047
;  :arith-assert-upper      2874
;  :arith-bound-prop        762
;  :arith-conflicts         79
;  :arith-eq-adapter        2837
;  :arith-fixed-eqs         2596
;  :arith-offset-eqs        1623
;  :arith-pivots            2173
;  :conflicts               250
;  :datatype-accessor-ax    54
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               964
;  :del-clause              42663
;  :final-checks            5
;  :max-generation          11
;  :max-memory              8.41
;  :memory                  8.30
;  :minimized-lits          35
;  :mk-bool-var             51960
;  :mk-clause               43031
;  :num-allocs              392313
;  :num-checks              102
;  :propagations            13594
;  :quant-instantiations    19613
;  :rlimit-count            1084605
;  :time                    0.00)
(assert (forall ((i1@100@04 Int)) (!
  (implies
    (and (< i1@100@04 V@15@04) (<= 0 i1@100@04))
    (=
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@101@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@100@04))))
      V@15@04))
  
  :qid |prog.l<no position>|)))
; [eval] (forall i1: Int :: (forall i2: Int :: { aloc(opt_get1(G), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(G), i1).option$array$ == aloc(opt_get1(G), i2).option$array$ ==> i1 == i2))
(declare-const i1@103@04 Int)
(push) ; 9
; [eval] (forall i2: Int :: { aloc(opt_get1(G), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(G), i1).option$array$ == aloc(opt_get1(G), i2).option$array$ ==> i1 == i2)
(declare-const i2@104@04 Int)
(push) ; 10
; [eval] 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(G), i1).option$array$ == aloc(opt_get1(G), i2).option$array$ ==> i1 == i2
; [eval] 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(G), i1).option$array$ == aloc(opt_get1(G), i2).option$array$
; [eval] 0 <= i1
(push) ; 11
; [then-branch: 64 | 0 <= i1@103@04 | live]
; [else-branch: 64 | !(0 <= i1@103@04) | live]
(push) ; 12
; [then-branch: 64 | 0 <= i1@103@04]
(assert (<= 0 i1@103@04))
; [eval] i1 < V
(push) ; 13
; [then-branch: 65 | i1@103@04 < V@15@04 | live]
; [else-branch: 65 | !(i1@103@04 < V@15@04) | live]
(push) ; 14
; [then-branch: 65 | i1@103@04 < V@15@04]
(assert (< i1@103@04 V@15@04))
; [eval] 0 <= i2
(push) ; 15
; [then-branch: 66 | 0 <= i2@104@04 | live]
; [else-branch: 66 | !(0 <= i2@104@04) | live]
(push) ; 16
; [then-branch: 66 | 0 <= i2@104@04]
(assert (<= 0 i2@104@04))
; [eval] i2 < V
(push) ; 17
; [then-branch: 67 | i2@104@04 < V@15@04 | live]
; [else-branch: 67 | !(i2@104@04 < V@15@04) | live]
(push) ; 18
; [then-branch: 67 | i2@104@04 < V@15@04]
(assert (< i2@104@04 V@15@04))
; [eval] aloc(opt_get1(G), i1).option$array$ == aloc(opt_get1(G), i2).option$array$
; [eval] aloc(opt_get1(G), i1)
; [eval] opt_get1(G)
(push) ; 19
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 19
; Joined path conditions
(push) ; 19
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 20
(assert (not (< i1@103@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))))
(check-sat)
; unsat
(pop) ; 20
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               18119
;  :arith-add-rows          6270
;  :arith-assert-diseq      217
;  :arith-assert-lower      4051
;  :arith-assert-upper      2874
;  :arith-bound-prop        762
;  :arith-conflicts         79
;  :arith-eq-adapter        2837
;  :arith-fixed-eqs         2596
;  :arith-offset-eqs        1623
;  :arith-pivots            2173
;  :conflicts               250
;  :datatype-accessor-ax    54
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               964
;  :del-clause              42663
;  :final-checks            5
;  :max-generation          11
;  :max-memory              8.41
;  :memory                  8.30
;  :minimized-lits          35
;  :mk-bool-var             51965
;  :mk-clause               43031
;  :num-allocs              392841
;  :num-checks              103
;  :propagations            13594
;  :quant-instantiations    19613
;  :rlimit-count            1085238)
(assert (< i1@103@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(pop) ; 19
; Joined path conditions
(assert (< i1@103@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(declare-const sm@105@04 $FVF<option<array>>)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@72@04 r) V@15@04) (<= 0 (inv@72@04 r)))
      (< $Perm.No $k@71@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@105@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@105@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04))))))))) r))
  :qid |qp.fvfValDef68|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04))))))))) r) r)
  :pattern (($FVF.lookup_option$array$ (as sm@105@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef69|)))
(declare-const pm@106@04 $FPM)
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@106@04  $FPM) r)
    (ite (and (< (inv@72@04 r) V@15@04) (<= 0 (inv@72@04 r))) $k@71@04 $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@106@04  $FPM) r))
  :qid |qp.resPrmSumDef70|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@105@04  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04))))))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@106@04  $FPM) r))
  :qid |qp.resTrgDef71|)))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@105@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@103@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@103@04)))
(push) ; 19
(assert (not (<
  $Perm.No
  ($FVF.perm_option$array$ (as pm@106@04  $FPM) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@103@04)))))
(check-sat)
; unsat
(pop) ; 19
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               18192
;  :arith-add-rows          6296
;  :arith-assert-diseq      220
;  :arith-assert-lower      4067
;  :arith-assert-upper      2886
;  :arith-bound-prop        767
;  :arith-conflicts         81
;  :arith-eq-adapter        2850
;  :arith-fixed-eqs         2605
;  :arith-offset-eqs        1623
;  :arith-pivots            2183
;  :conflicts               253
;  :datatype-accessor-ax    54
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               966
;  :del-clause              42667
;  :final-checks            5
;  :max-generation          11
;  :max-memory              8.41
;  :memory                  8.32
;  :minimized-lits          35
;  :mk-bool-var             52161
;  :mk-clause               43139
;  :num-allocs              394404
;  :num-checks              104
;  :propagations            13613
;  :quant-instantiations    19688
;  :rlimit-count            1089991)
; [eval] aloc(opt_get1(G), i2)
; [eval] opt_get1(G)
(push) ; 19
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 19
; Joined path conditions
(push) ; 19
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 20
(assert (not (< i2@104@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))))
(check-sat)
; unsat
(pop) ; 20
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               18192
;  :arith-add-rows          6296
;  :arith-assert-diseq      220
;  :arith-assert-lower      4067
;  :arith-assert-upper      2886
;  :arith-bound-prop        767
;  :arith-conflicts         81
;  :arith-eq-adapter        2850
;  :arith-fixed-eqs         2605
;  :arith-offset-eqs        1623
;  :arith-pivots            2183
;  :conflicts               253
;  :datatype-accessor-ax    54
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               966
;  :del-clause              42667
;  :final-checks            5
;  :max-generation          11
;  :max-memory              8.41
;  :memory                  8.32
;  :minimized-lits          35
;  :mk-bool-var             52161
;  :mk-clause               43139
;  :num-allocs              394430
;  :num-checks              105
;  :propagations            13613
;  :quant-instantiations    19688
;  :rlimit-count            1090021)
(assert (< i2@104@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(pop) ; 19
; Joined path conditions
(assert (< i2@104@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(declare-const sm@107@04 $FVF<option<array>>)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@72@04 r) V@15@04) (<= 0 (inv@72@04 r)))
      (< $Perm.No $k@71@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@107@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@107@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04))))))))) r))
  :qid |qp.fvfValDef72|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04))))))))) r) r)
  :pattern (($FVF.lookup_option$array$ (as sm@107@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef73|)))
(declare-const pm@108@04 $FPM)
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@108@04  $FPM) r)
    (ite (and (< (inv@72@04 r) V@15@04) (<= 0 (inv@72@04 r))) $k@71@04 $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@108@04  $FPM) r))
  :qid |qp.resPrmSumDef74|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@107@04  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04))))))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@108@04  $FPM) r))
  :qid |qp.resTrgDef75|)))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@107@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@104@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@104@04)))
(push) ; 19
(assert (not (<
  $Perm.No
  ($FVF.perm_option$array$ (as pm@108@04  $FPM) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@104@04)))))
(check-sat)
; unsat
(pop) ; 19
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               18265
;  :arith-add-rows          6324
;  :arith-assert-diseq      223
;  :arith-assert-lower      4082
;  :arith-assert-upper      2899
;  :arith-bound-prop        772
;  :arith-conflicts         83
;  :arith-eq-adapter        2864
;  :arith-fixed-eqs         2614
;  :arith-offset-eqs        1623
;  :arith-pivots            2196
;  :conflicts               256
;  :datatype-accessor-ax    54
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               968
;  :del-clause              42671
;  :final-checks            5
;  :max-generation          11
;  :max-memory              8.41
;  :memory                  8.32
;  :minimized-lits          35
;  :mk-bool-var             52342
;  :mk-clause               43247
;  :num-allocs              396018
;  :num-checks              106
;  :propagations            13646
;  :quant-instantiations    19763
;  :rlimit-count            1095205)
(pop) ; 18
(push) ; 18
; [else-branch: 67 | !(i2@104@04 < V@15@04)]
(assert (not (< i2@104@04 V@15@04)))
(pop) ; 18
(pop) ; 17
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@72@04 r) V@15@04) (<= 0 (inv@72@04 r)))
      (< $Perm.No $k@71@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@105@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@105@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04))))))))) r))
  :qid |qp.fvfValDef68|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04))))))))) r) r)
  :pattern (($FVF.lookup_option$array$ (as sm@105@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef69|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@106@04  $FPM) r)
    (ite (and (< (inv@72@04 r) V@15@04) (<= 0 (inv@72@04 r))) $k@71@04 $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@106@04  $FPM) r))
  :qid |qp.resPrmSumDef70|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@105@04  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04))))))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@106@04  $FPM) r))
  :qid |qp.resTrgDef71|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@72@04 r) V@15@04) (<= 0 (inv@72@04 r)))
      (< $Perm.No $k@71@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@107@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@107@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04))))))))) r))
  :qid |qp.fvfValDef72|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04))))))))) r) r)
  :pattern (($FVF.lookup_option$array$ (as sm@107@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef73|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@108@04  $FPM) r)
    (ite (and (< (inv@72@04 r) V@15@04) (<= 0 (inv@72@04 r))) $k@71@04 $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@108@04  $FPM) r))
  :qid |qp.resPrmSumDef74|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@107@04  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04))))))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@108@04  $FPM) r))
  :qid |qp.resTrgDef75|)))
(assert (implies
  (< i2@104@04 V@15@04)
  (and
    (< i2@104@04 V@15@04)
    (< i1@103@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@105@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@103@04)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@103@04))
    (< i2@104@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@107@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@104@04)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@104@04)))))
; Joined path conditions
(pop) ; 16
(push) ; 16
; [else-branch: 66 | !(0 <= i2@104@04)]
(assert (not (<= 0 i2@104@04)))
(pop) ; 16
(pop) ; 15
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@72@04 r) V@15@04) (<= 0 (inv@72@04 r)))
      (< $Perm.No $k@71@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@105@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@105@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04))))))))) r))
  :qid |qp.fvfValDef68|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04))))))))) r) r)
  :pattern (($FVF.lookup_option$array$ (as sm@105@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef69|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@106@04  $FPM) r)
    (ite (and (< (inv@72@04 r) V@15@04) (<= 0 (inv@72@04 r))) $k@71@04 $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@106@04  $FPM) r))
  :qid |qp.resPrmSumDef70|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@105@04  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04))))))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@106@04  $FPM) r))
  :qid |qp.resTrgDef71|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@72@04 r) V@15@04) (<= 0 (inv@72@04 r)))
      (< $Perm.No $k@71@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@107@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@107@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04))))))))) r))
  :qid |qp.fvfValDef72|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04))))))))) r) r)
  :pattern (($FVF.lookup_option$array$ (as sm@107@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef73|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@108@04  $FPM) r)
    (ite (and (< (inv@72@04 r) V@15@04) (<= 0 (inv@72@04 r))) $k@71@04 $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@108@04  $FPM) r))
  :qid |qp.resPrmSumDef74|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@107@04  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04))))))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@108@04  $FPM) r))
  :qid |qp.resTrgDef75|)))
(assert (implies
  (<= 0 i2@104@04)
  (and
    (<= 0 i2@104@04)
    (implies
      (< i2@104@04 V@15@04)
      (and
        (< i2@104@04 V@15@04)
        (< i1@103@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@105@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@103@04)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@103@04))
        (< i2@104@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@107@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@104@04)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@104@04)))))))
; Joined path conditions
(pop) ; 14
(push) ; 14
; [else-branch: 65 | !(i1@103@04 < V@15@04)]
(assert (not (< i1@103@04 V@15@04)))
(pop) ; 14
(pop) ; 13
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@72@04 r) V@15@04) (<= 0 (inv@72@04 r)))
      (< $Perm.No $k@71@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@105@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@105@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04))))))))) r))
  :qid |qp.fvfValDef68|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04))))))))) r) r)
  :pattern (($FVF.lookup_option$array$ (as sm@105@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef69|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@106@04  $FPM) r)
    (ite (and (< (inv@72@04 r) V@15@04) (<= 0 (inv@72@04 r))) $k@71@04 $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@106@04  $FPM) r))
  :qid |qp.resPrmSumDef70|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@105@04  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04))))))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@106@04  $FPM) r))
  :qid |qp.resTrgDef71|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@72@04 r) V@15@04) (<= 0 (inv@72@04 r)))
      (< $Perm.No $k@71@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@107@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@107@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04))))))))) r))
  :qid |qp.fvfValDef72|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04))))))))) r) r)
  :pattern (($FVF.lookup_option$array$ (as sm@107@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef73|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@108@04  $FPM) r)
    (ite (and (< (inv@72@04 r) V@15@04) (<= 0 (inv@72@04 r))) $k@71@04 $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@108@04  $FPM) r))
  :qid |qp.resPrmSumDef74|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@107@04  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04))))))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@108@04  $FPM) r))
  :qid |qp.resTrgDef75|)))
(assert (implies
  (< i1@103@04 V@15@04)
  (and
    (< i1@103@04 V@15@04)
    (implies
      (<= 0 i2@104@04)
      (and
        (<= 0 i2@104@04)
        (implies
          (< i2@104@04 V@15@04)
          (and
            (< i2@104@04 V@15@04)
            (< i1@103@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@105@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@103@04)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@103@04))
            (< i2@104@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@107@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@104@04)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@104@04)))))))))
; Joined path conditions
(pop) ; 12
(push) ; 12
; [else-branch: 64 | !(0 <= i1@103@04)]
(assert (not (<= 0 i1@103@04)))
(pop) ; 12
(pop) ; 11
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@72@04 r) V@15@04) (<= 0 (inv@72@04 r)))
      (< $Perm.No $k@71@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@105@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@105@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04))))))))) r))
  :qid |qp.fvfValDef68|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04))))))))) r) r)
  :pattern (($FVF.lookup_option$array$ (as sm@105@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef69|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@106@04  $FPM) r)
    (ite (and (< (inv@72@04 r) V@15@04) (<= 0 (inv@72@04 r))) $k@71@04 $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@106@04  $FPM) r))
  :qid |qp.resPrmSumDef70|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@105@04  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04))))))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@106@04  $FPM) r))
  :qid |qp.resTrgDef71|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@72@04 r) V@15@04) (<= 0 (inv@72@04 r)))
      (< $Perm.No $k@71@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@107@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@107@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04))))))))) r))
  :qid |qp.fvfValDef72|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04))))))))) r) r)
  :pattern (($FVF.lookup_option$array$ (as sm@107@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef73|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@108@04  $FPM) r)
    (ite (and (< (inv@72@04 r) V@15@04) (<= 0 (inv@72@04 r))) $k@71@04 $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@108@04  $FPM) r))
  :qid |qp.resPrmSumDef74|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@107@04  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04))))))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@108@04  $FPM) r))
  :qid |qp.resTrgDef75|)))
(assert (implies
  (<= 0 i1@103@04)
  (and
    (<= 0 i1@103@04)
    (implies
      (< i1@103@04 V@15@04)
      (and
        (< i1@103@04 V@15@04)
        (implies
          (<= 0 i2@104@04)
          (and
            (<= 0 i2@104@04)
            (implies
              (< i2@104@04 V@15@04)
              (and
                (< i2@104@04 V@15@04)
                (< i1@103@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@105@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@103@04)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@103@04))
                (< i2@104@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@107@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@104@04)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@104@04)))))))))))
; Joined path conditions
(push) ; 11
; [then-branch: 68 | Lookup(option$array$,sm@105@04,aloc((_, _), opt_get1(_, G@11@04), i1@103@04)) == Lookup(option$array$,sm@107@04,aloc((_, _), opt_get1(_, G@11@04), i2@104@04)) && i2@104@04 < V@15@04 && 0 <= i2@104@04 && i1@103@04 < V@15@04 && 0 <= i1@103@04 | live]
; [else-branch: 68 | !(Lookup(option$array$,sm@105@04,aloc((_, _), opt_get1(_, G@11@04), i1@103@04)) == Lookup(option$array$,sm@107@04,aloc((_, _), opt_get1(_, G@11@04), i2@104@04)) && i2@104@04 < V@15@04 && 0 <= i2@104@04 && i1@103@04 < V@15@04 && 0 <= i1@103@04) | live]
(push) ; 12
; [then-branch: 68 | Lookup(option$array$,sm@105@04,aloc((_, _), opt_get1(_, G@11@04), i1@103@04)) == Lookup(option$array$,sm@107@04,aloc((_, _), opt_get1(_, G@11@04), i2@104@04)) && i2@104@04 < V@15@04 && 0 <= i2@104@04 && i1@103@04 < V@15@04 && 0 <= i1@103@04]
(assert (and
  (and
    (and
      (and
        (=
          ($FVF.lookup_option$array$ (as sm@105@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@103@04))
          ($FVF.lookup_option$array$ (as sm@107@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@104@04)))
        (< i2@104@04 V@15@04))
      (<= 0 i2@104@04))
    (< i1@103@04 V@15@04))
  (<= 0 i1@103@04)))
; [eval] i1 == i2
(pop) ; 12
(push) ; 12
; [else-branch: 68 | !(Lookup(option$array$,sm@105@04,aloc((_, _), opt_get1(_, G@11@04), i1@103@04)) == Lookup(option$array$,sm@107@04,aloc((_, _), opt_get1(_, G@11@04), i2@104@04)) && i2@104@04 < V@15@04 && 0 <= i2@104@04 && i1@103@04 < V@15@04 && 0 <= i1@103@04)]
(assert (not
  (and
    (and
      (and
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@105@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@103@04))
            ($FVF.lookup_option$array$ (as sm@107@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@104@04)))
          (< i2@104@04 V@15@04))
        (<= 0 i2@104@04))
      (< i1@103@04 V@15@04))
    (<= 0 i1@103@04))))
(pop) ; 12
(pop) ; 11
; Joined path conditions
(assert (implies
  (and
    (and
      (and
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@105@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@103@04))
            ($FVF.lookup_option$array$ (as sm@107@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@104@04)))
          (< i2@104@04 V@15@04))
        (<= 0 i2@104@04))
      (< i1@103@04 V@15@04))
    (<= 0 i1@103@04))
  (and
    (=
      ($FVF.lookup_option$array$ (as sm@105@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@103@04))
      ($FVF.lookup_option$array$ (as sm@107@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@104@04)))
    (< i2@104@04 V@15@04)
    (<= 0 i2@104@04)
    (< i1@103@04 V@15@04)
    (<= 0 i1@103@04))))
; Joined path conditions
(pop) ; 10
; Nested auxiliary terms: globals (aux)
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@72@04 r) V@15@04) (<= 0 (inv@72@04 r)))
      (< $Perm.No $k@71@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@105@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@105@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04))))))))) r))
  :qid |qp.fvfValDef68|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04))))))))) r) r)
  :pattern (($FVF.lookup_option$array$ (as sm@105@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef69|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@106@04  $FPM) r)
    (ite (and (< (inv@72@04 r) V@15@04) (<= 0 (inv@72@04 r))) $k@71@04 $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@106@04  $FPM) r))
  :qid |qp.resPrmSumDef70|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@105@04  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04))))))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@106@04  $FPM) r))
  :qid |qp.resTrgDef71|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@72@04 r) V@15@04) (<= 0 (inv@72@04 r)))
      (< $Perm.No $k@71@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@107@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@107@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04))))))))) r))
  :qid |qp.fvfValDef72|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04))))))))) r) r)
  :pattern (($FVF.lookup_option$array$ (as sm@107@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef73|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@108@04  $FPM) r)
    (ite (and (< (inv@72@04 r) V@15@04) (<= 0 (inv@72@04 r))) $k@71@04 $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@108@04  $FPM) r))
  :qid |qp.resPrmSumDef74|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@107@04  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04))))))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@108@04  $FPM) r))
  :qid |qp.resTrgDef75|)))
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i2@104@04 Int)) (!
  (and
    (implies
      (<= 0 i1@103@04)
      (and
        (<= 0 i1@103@04)
        (implies
          (< i1@103@04 V@15@04)
          (and
            (< i1@103@04 V@15@04)
            (implies
              (<= 0 i2@104@04)
              (and
                (<= 0 i2@104@04)
                (implies
                  (< i2@104@04 V@15@04)
                  (and
                    (< i2@104@04 V@15@04)
                    (< i1@103@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
                    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@105@04  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@103@04)) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@103@04))
                    (< i2@104@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
                    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@107@04  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@104@04)) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@104@04))))))))))
    (implies
      (and
        (and
          (and
            (and
              (=
                ($FVF.lookup_option$array$ (as sm@105@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@103@04))
                ($FVF.lookup_option$array$ (as sm@107@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@104@04)))
              (< i2@104@04 V@15@04))
            (<= 0 i2@104@04))
          (< i1@103@04 V@15@04))
        (<= 0 i1@103@04))
      (and
        (=
          ($FVF.lookup_option$array$ (as sm@105@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@103@04))
          ($FVF.lookup_option$array$ (as sm@107@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@104@04)))
        (< i2@104@04 V@15@04)
        (<= 0 i2@104@04)
        (< i1@103@04 V@15@04)
        (<= 0 i1@103@04))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@104@04))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 9
; Nested auxiliary terms: globals (aux)
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@72@04 r) V@15@04) (<= 0 (inv@72@04 r)))
      (< $Perm.No $k@71@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@105@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@105@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04))))))))) r))
  :qid |qp.fvfValDef68|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04))))))))) r) r)
  :pattern (($FVF.lookup_option$array$ (as sm@105@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef69|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@106@04  $FPM) r)
    (ite (and (< (inv@72@04 r) V@15@04) (<= 0 (inv@72@04 r))) $k@71@04 $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@106@04  $FPM) r))
  :qid |qp.resPrmSumDef70|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@105@04  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04))))))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@106@04  $FPM) r))
  :qid |qp.resTrgDef71|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@72@04 r) V@15@04) (<= 0 (inv@72@04 r)))
      (< $Perm.No $k@71@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@107@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@107@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04))))))))) r))
  :qid |qp.fvfValDef72|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04))))))))) r) r)
  :pattern (($FVF.lookup_option$array$ (as sm@107@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef73|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@108@04  $FPM) r)
    (ite (and (< (inv@72@04 r) V@15@04) (<= 0 (inv@72@04 r))) $k@71@04 $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@108@04  $FPM) r))
  :qid |qp.resPrmSumDef74|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@107@04  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04))))))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@108@04  $FPM) r))
  :qid |qp.resTrgDef75|)))
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
; Nested auxiliary terms: non-globals (tlq)
(push) ; 9
(assert (not (forall ((i1@103@04 Int)) (!
  (forall ((i2@104@04 Int)) (!
    (implies
      (and
        (and
          (and
            (and
              (=
                ($FVF.lookup_option$array$ (as sm@105@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@103@04))
                ($FVF.lookup_option$array$ (as sm@107@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@104@04)))
              (< i2@104@04 V@15@04))
            (<= 0 i2@104@04))
          (< i1@103@04 V@15@04))
        (<= 0 i1@103@04))
      (= i1@103@04 i2@104@04))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@104@04))
    :qid |prog.l<no position>|))
  
  :qid |prog.l<no position>|))))
(check-sat)
; unsat
(pop) ; 9
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               18504
;  :arith-add-rows          6557
;  :arith-assert-diseq      227
;  :arith-assert-lower      4125
;  :arith-assert-upper      2926
;  :arith-bound-prop        795
;  :arith-conflicts         84
;  :arith-eq-adapter        2893
;  :arith-fixed-eqs         2638
;  :arith-offset-eqs        1654
;  :arith-pivots            2262
;  :conflicts               274
;  :datatype-accessor-ax    54
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               985
;  :del-clause              43685
;  :final-checks            5
;  :max-generation          11
;  :max-memory              8.41
;  :memory                  8.31
;  :minimized-lits          35
;  :mk-bool-var             53225
;  :mk-clause               44053
;  :num-allocs              402895
;  :num-checks              107
;  :propagations            13784
;  :quant-instantiations    20050
;  :rlimit-count            1118136
;  :time                    0.01)
(assert (forall ((i1@103@04 Int)) (!
  (forall ((i2@104@04 Int)) (!
    (implies
      (and
        (and
          (and
            (and
              (=
                ($FVF.lookup_option$array$ (as sm@105@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@103@04))
                ($FVF.lookup_option$array$ (as sm@107@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@104@04)))
              (< i2@104@04 V@15@04))
            (<= 0 i2@104@04))
          (< i1@103@04 V@15@04))
        (<= 0 i1@103@04))
      (= i1@103@04 i2@104@04))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@104@04))
    :qid |prog.l<no position>|))
  
  :qid |prog.l<no position>|)))
(declare-const i1@109@04 Int)
(declare-const j@110@04 Int)
(push) ; 9
; [eval] 0 <= i1 && i1 < V && (0 <= j && j < V)
; [eval] 0 <= i1
(push) ; 10
; [then-branch: 69 | 0 <= i1@109@04 | live]
; [else-branch: 69 | !(0 <= i1@109@04) | live]
(push) ; 11
; [then-branch: 69 | 0 <= i1@109@04]
(assert (<= 0 i1@109@04))
; [eval] i1 < V
(push) ; 12
; [then-branch: 70 | i1@109@04 < V@15@04 | live]
; [else-branch: 70 | !(i1@109@04 < V@15@04) | live]
(push) ; 13
; [then-branch: 70 | i1@109@04 < V@15@04]
(assert (< i1@109@04 V@15@04))
; [eval] 0 <= j
(push) ; 14
; [then-branch: 71 | 0 <= j@110@04 | live]
; [else-branch: 71 | !(0 <= j@110@04) | live]
(push) ; 15
; [then-branch: 71 | 0 <= j@110@04]
(assert (<= 0 j@110@04))
; [eval] j < V
(pop) ; 15
(push) ; 15
; [else-branch: 71 | !(0 <= j@110@04)]
(assert (not (<= 0 j@110@04)))
(pop) ; 15
(pop) ; 14
; Joined path conditions
; Joined path conditions
(pop) ; 13
(push) ; 13
; [else-branch: 70 | !(i1@109@04 < V@15@04)]
(assert (not (< i1@109@04 V@15@04)))
(pop) ; 13
(pop) ; 12
; Joined path conditions
; Joined path conditions
(pop) ; 11
(push) ; 11
; [else-branch: 69 | !(0 <= i1@109@04)]
(assert (not (<= 0 i1@109@04)))
(pop) ; 11
(pop) ; 10
; Joined path conditions
; Joined path conditions
(assert (and
  (and (and (< j@110@04 V@15@04) (<= 0 j@110@04)) (< i1@109@04 V@15@04))
  (<= 0 i1@109@04)))
(declare-const $k@111@04 $Perm)
(assert ($Perm.isReadVar $k@111@04 $Perm.Write))
; [eval] aloc(opt_get1(aloc(opt_get1(G), i1).option$array$), j)
; [eval] opt_get1(aloc(opt_get1(G), i1).option$array$)
; [eval] aloc(opt_get1(G), i1)
; [eval] opt_get1(G)
(push) ; 10
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 10
; Joined path conditions
(push) ; 10
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 11
(assert (not (< i1@109@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               18504
;  :arith-add-rows          6560
;  :arith-assert-diseq      228
;  :arith-assert-lower      4133
;  :arith-assert-upper      2927
;  :arith-bound-prop        795
;  :arith-conflicts         84
;  :arith-eq-adapter        2894
;  :arith-fixed-eqs         2638
;  :arith-offset-eqs        1654
;  :arith-pivots            2262
;  :conflicts               274
;  :datatype-accessor-ax    54
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               985
;  :del-clause              43685
;  :final-checks            5
;  :max-generation          11
;  :max-memory              8.41
;  :memory                  8.31
;  :minimized-lits          35
;  :mk-bool-var             53236
;  :mk-clause               44055
;  :num-allocs              403567
;  :num-checks              108
;  :propagations            13785
;  :quant-instantiations    20050
;  :rlimit-count            1119229)
(assert (< i1@109@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(pop) ; 10
; Joined path conditions
(assert (< i1@109@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(declare-const sm@112@04 $FVF<option<array>>)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@72@04 r) V@15@04) (<= 0 (inv@72@04 r)))
      (< $Perm.No $k@71@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@112@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@112@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04))))))))) r))
  :qid |qp.fvfValDef76|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04))))))))) r) r)
  :pattern (($FVF.lookup_option$array$ (as sm@112@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef77|)))
(declare-const pm@113@04 $FPM)
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@113@04  $FPM) r)
    (ite (and (< (inv@72@04 r) V@15@04) (<= 0 (inv@72@04 r))) $k@71@04 $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@113@04  $FPM) r))
  :qid |qp.resPrmSumDef78|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@112@04  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04))))))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@113@04  $FPM) r))
  :qid |qp.resTrgDef79|)))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@112@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@109@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@109@04)))
(push) ; 10
(assert (not (<
  $Perm.No
  ($FVF.perm_option$array$ (as pm@113@04  $FPM) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@109@04)))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               18579
;  :arith-add-rows          6586
;  :arith-assert-diseq      231
;  :arith-assert-lower      4148
;  :arith-assert-upper      2940
;  :arith-bound-prop        800
;  :arith-conflicts         86
;  :arith-eq-adapter        2907
;  :arith-fixed-eqs         2647
;  :arith-offset-eqs        1654
;  :arith-pivots            2275
;  :conflicts               277
;  :datatype-accessor-ax    54
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               987
;  :del-clause              43689
;  :final-checks            5
;  :max-generation          11
;  :max-memory              8.41
;  :memory                  8.32
;  :minimized-lits          35
;  :mk-bool-var             53433
;  :mk-clause               44165
;  :num-allocs              405186
;  :num-checks              109
;  :propagations            13808
;  :quant-instantiations    20128
;  :rlimit-count            1124183)
(push) ; 10
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 11
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@112@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@109@04))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               18695
;  :arith-add-rows          6641
;  :arith-assert-diseq      233
;  :arith-assert-lower      4165
;  :arith-assert-upper      2951
;  :arith-bound-prop        805
;  :arith-conflicts         87
;  :arith-eq-adapter        2918
;  :arith-fixed-eqs         2655
;  :arith-offset-eqs        1670
;  :arith-pivots            2284
;  :conflicts               294
;  :datatype-accessor-ax    54
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1003
;  :del-clause              44225
;  :final-checks            5
;  :max-generation          11
;  :max-memory              8.41
;  :memory                  8.32
;  :minimized-lits          35
;  :mk-bool-var             53840
;  :mk-clause               44701
;  :num-allocs              406605
;  :num-checks              110
;  :propagations            13917
;  :quant-instantiations    20257
;  :rlimit-count            1131087
;  :time                    0.00)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@112@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@109@04))
    (as None<option<array>>  option<array>))))
(pop) ; 10
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@112@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@109@04))
    (as None<option<array>>  option<array>))))
(push) ; 10
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 11
(assert (not (<
  j@110@04
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@112@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@109@04)))))))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               18864
;  :arith-add-rows          6724
;  :arith-assert-diseq      235
;  :arith-assert-lower      4184
;  :arith-assert-upper      2964
;  :arith-bound-prop        810
;  :arith-conflicts         89
;  :arith-eq-adapter        2933
;  :arith-fixed-eqs         2664
;  :arith-offset-eqs        1686
;  :arith-pivots            2296
;  :conflicts               311
;  :datatype-accessor-ax    54
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1019
;  :del-clause              44771
;  :final-checks            5
;  :max-generation          11
;  :max-memory              8.41
;  :memory                  8.32
;  :minimized-lits          35
;  :mk-bool-var             54292
;  :mk-clause               45247
;  :num-allocs              408229
;  :num-checks              111
;  :propagations            14059
;  :quant-instantiations    20400
;  :rlimit-count            1138623
;  :time                    0.00)
(assert (<
  j@110@04
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@112@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@109@04))))))
(pop) ; 10
; Joined path conditions
(assert (<
  j@110@04
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@112@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@109@04))))))
(pop) ; 9
(declare-fun inv@114@04 ($Ref) Int)
(declare-fun inv@115@04 ($Ref) Int)
; Nested auxiliary terms: globals
(assert ($Perm.isReadVar $k@111@04 $Perm.Write))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@72@04 r) V@15@04) (<= 0 (inv@72@04 r)))
      (< $Perm.No $k@71@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@112@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@112@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04))))))))) r))
  :qid |qp.fvfValDef76|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04))))))))) r) r)
  :pattern (($FVF.lookup_option$array$ (as sm@112@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef77|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@113@04  $FPM) r)
    (ite (and (< (inv@72@04 r) V@15@04) (<= 0 (inv@72@04 r))) $k@71@04 $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@113@04  $FPM) r))
  :qid |qp.resPrmSumDef78|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@112@04  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04))))))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@113@04  $FPM) r))
  :qid |qp.resTrgDef79|)))
; Nested auxiliary terms: non-globals
(assert (forall ((i1@109@04 Int) (j@110@04 Int)) (!
  (and
    (< i1@109@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@112@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@109@04)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@109@04))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@112@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@109@04))
        (as None<option<array>>  option<array>)))
    (<
      j@110@04
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@112@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@109@04))))))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@112@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@109@04))) j@110@04))
  :qid |int-aux|)))
(push) ; 9
(assert (not (forall ((i1@109@04 Int) (j@110@04 Int)) (!
  (implies
    (and
      (and (and (< j@110@04 V@15@04) (<= 0 j@110@04)) (< i1@109@04 V@15@04))
      (<= 0 i1@109@04))
    (or (= $k@111@04 $Perm.No) (< $Perm.No $k@111@04)))
  
  ))))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               18864
;  :arith-add-rows          6732
;  :arith-assert-diseq      236
;  :arith-assert-lower      4186
;  :arith-assert-upper      2965
;  :arith-bound-prop        810
;  :arith-conflicts         89
;  :arith-eq-adapter        2934
;  :arith-fixed-eqs         2664
;  :arith-offset-eqs        1686
;  :arith-pivots            2305
;  :conflicts               312
;  :datatype-accessor-ax    54
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1019
;  :del-clause              44879
;  :final-checks            5
;  :max-generation          11
;  :max-memory              8.41
;  :memory                  8.31
;  :minimized-lits          35
;  :mk-bool-var             54305
;  :mk-clause               45249
;  :num-allocs              409248
;  :num-checks              112
;  :propagations            14060
;  :quant-instantiations    20400
;  :rlimit-count            1140946)
(declare-const sm@116@04 $FVF<Int>)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@81@04 r) V@15@04) (<= 0 (inv@81@04 r)))
        (< (inv@80@04 r) V@15@04))
      (<= 0 (inv@80@04 r)))
    (=
      ($FVF.lookup_int (as sm@116@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@116@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04))))))))))))) r))
  :qid |qp.fvfValDef80|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@84@04 r) V@15@04) (<= 0 (inv@84@04 r)))
    (=
      ($FVF.lookup_int (as sm@116@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04)))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@116@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04)))))))))))))))) r))
  :qid |qp.fvfValDef81|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04)))))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@116@04  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef82|)))
; Check receiver injectivity
(push) ; 9
(assert (not (forall ((i11@109@04 Int) (j1@110@04 Int) (i12@109@04 Int) (j2@110@04 Int)) (!
  (implies
    (and
      (and
        (and
          (and
            (and
              (and (< j1@110@04 V@15@04) (<= 0 j1@110@04))
              (< i11@109@04 V@15@04))
            (<= 0 i11@109@04))
          ($FVF.loc_int ($FVF.lookup_int (as sm@116@04  $FVF<Int>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@112@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i11@109@04))) j1@110@04)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@112@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i11@109@04))) j1@110@04)))
        (< $Perm.No $k@111@04))
      (and
        (and
          (and
            (and
              (and (< j2@110@04 V@15@04) (<= 0 j2@110@04))
              (< i12@109@04 V@15@04))
            (<= 0 i12@109@04))
          ($FVF.loc_int ($FVF.lookup_int (as sm@116@04  $FVF<Int>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@112@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i12@109@04))) j2@110@04)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@112@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i12@109@04))) j2@110@04)))
        (< $Perm.No $k@111@04))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@112@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i11@109@04))) j1@110@04)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@112@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i12@109@04))) j2@110@04)))
    (and (= i11@109@04 i12@109@04) (= j1@110@04 j2@110@04)))
  
  :qid |int-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 9
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               19252
;  :arith-add-rows          7006
;  :arith-assert-diseq      240
;  :arith-assert-lower      4248
;  :arith-assert-upper      3007
;  :arith-bound-prop        837
;  :arith-conflicts         92
;  :arith-eq-adapter        2975
;  :arith-fixed-eqs         2697
;  :arith-offset-eqs        1717
;  :arith-pivots            2372
;  :conflicts               332
;  :datatype-accessor-ax    54
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1042
;  :del-clause              45805
;  :final-checks            5
;  :max-generation          11
;  :max-memory              8.64
;  :memory                  8.50
;  :minimized-lits          35
;  :mk-bool-var             55412
;  :mk-clause               46175
;  :num-allocs              414180
;  :num-checks              113
;  :propagations            14263
;  :quant-instantiations    20758
;  :rlimit-count            1162503
;  :time                    0.01)
; Definitional axioms for inverse functions
(assert (forall ((i1@109@04 Int) (j@110@04 Int)) (!
  (implies
    (and
      (and
        (and (and (< j@110@04 V@15@04) (<= 0 j@110@04)) (< i1@109@04 V@15@04))
        (<= 0 i1@109@04))
      (< $Perm.No $k@111@04))
    (and
      (=
        (inv@114@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@112@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@109@04))) j@110@04))
        i1@109@04)
      (=
        (inv@115@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@112@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@109@04))) j@110@04))
        j@110@04)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@112@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@109@04))) j@110@04))
  :qid |int-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and
          (and (< (inv@115@04 r) V@15@04) (<= 0 (inv@115@04 r)))
          (< (inv@114@04 r) V@15@04))
        (<= 0 (inv@114@04 r)))
      (< $Perm.No $k@111@04))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@112@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) (inv@114@04 r)))) (inv@115@04 r))
      r))
  :pattern ((inv@114@04 r))
  :pattern ((inv@115@04 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@115@04 r) V@15@04) (<= 0 (inv@115@04 r)))
        (< (inv@114@04 r) V@15@04))
      (<= 0 (inv@114@04 r)))
    ($FVF.loc_int ($FVF.lookup_int (as sm@116@04  $FVF<Int>) r) r))
  :pattern ((inv@114@04 r) (inv@115@04 r))
  )))
; Precomputing data for removing quantified permissions
(define-fun pTaken@117@04 ((r $Ref)) $Perm
  (ite
    (and
      (and
        (and (< (inv@115@04 r) V@15@04) (<= 0 (inv@115@04 r)))
        (< (inv@114@04 r) V@15@04))
      (<= 0 (inv@114@04 r)))
    ($Perm.min
      (ite
        (and
          (and
            (and (< (inv@81@04 r) V@15@04) (<= 0 (inv@81@04 r)))
            (< (inv@80@04 r) V@15@04))
          (<= 0 (inv@80@04 r)))
        $Perm.Write
        $Perm.No)
      $k@111@04)
    $Perm.No))
(define-fun pTaken@118@04 ((r $Ref)) $Perm
  (ite
    (and
      (and
        (and (< (inv@115@04 r) V@15@04) (<= 0 (inv@115@04 r)))
        (< (inv@114@04 r) V@15@04))
      (<= 0 (inv@114@04 r)))
    ($Perm.min
      (ite
        (and (< (inv@84@04 r) V@15@04) (<= 0 (inv@84@04 r)))
        $Perm.Write
        $Perm.No)
      (- $k@111@04 (pTaken@117@04 r)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Constrain original permissions $k@111@04
(assert (forall ((r $Ref)) (!
  (implies
    (not
      (=
        (ite
          (and
            (and
              (and (< (inv@81@04 r) V@15@04) (<= 0 (inv@81@04 r)))
              (< (inv@80@04 r) V@15@04))
            (<= 0 (inv@80@04 r)))
          $Perm.Write
          $Perm.No)
        $Perm.No))
    (ite
      (and
        (and
          (and (< (inv@81@04 r) V@15@04) (<= 0 (inv@81@04 r)))
          (< (inv@80@04 r) V@15@04))
        (<= 0 (inv@80@04 r)))
      (<
        (ite
          (and
            (and
              (and (< (inv@115@04 r) V@15@04) (<= 0 (inv@115@04 r)))
              (< (inv@114@04 r) V@15@04))
            (<= 0 (inv@114@04 r)))
          $k@111@04
          $Perm.No)
        $Perm.Write)
      (<
        (ite
          (and
            (and
              (and (< (inv@115@04 r) V@15@04) (<= 0 (inv@115@04 r)))
              (< (inv@114@04 r) V@15@04))
            (<= 0 (inv@114@04 r)))
          $k@111@04
          $Perm.No)
        $Perm.No)))
  :pattern ((inv@81@04 r))
  :pattern ((inv@80@04 r))
  :pattern ((inv@115@04 r))
  :pattern ((inv@114@04 r))
  :qid |qp.srp83|)))
; Intermediate check if already taken enough permissions
(set-option :timeout 500)
(push) ; 9
(assert (not (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@115@04 r) V@15@04) (<= 0 (inv@115@04 r)))
        (< (inv@114@04 r) V@15@04))
      (<= 0 (inv@114@04 r)))
    (= (- $k@111@04 (pTaken@117@04 r)) $Perm.No))
  
  ))))
(check-sat)
; unsat
(pop) ; 9
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               20126
;  :arith-add-rows          7429
;  :arith-assert-diseq      251
;  :arith-assert-lower      4433
;  :arith-assert-upper      3137
;  :arith-bound-prop        860
;  :arith-conflicts         98
;  :arith-eq-adapter        3114
;  :arith-fixed-eqs         2805
;  :arith-offset-eqs        1777
;  :arith-pivots            2494
;  :conflicts               355
;  :datatype-accessor-ax    54
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1088
;  :del-clause              48135
;  :final-checks            5
;  :max-generation          11
;  :max-memory              8.66
;  :memory                  8.35
;  :minimized-lits          35
;  :mk-bool-var             57936
;  :mk-clause               48511
;  :num-allocs              424520
;  :num-checks              115
;  :propagations            14894
;  :quant-instantiations    21655
;  :rlimit-count            1209767
;  :time                    0.01)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@119@04 $FVF<Int>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (iff
    (Set_in r ($FVF.domain_int (as sm@119@04  $FVF<Int>)))
    (and
      (and
        (and
          (and (< (inv@115@04 r) V@15@04) (<= 0 (inv@115@04 r)))
          (< (inv@114@04 r) V@15@04))
        (<= 0 (inv@114@04 r)))
      (< $Perm.No $k@111@04)))
  :pattern ((Set_in r ($FVF.domain_int (as sm@119@04  $FVF<Int>))))
  :qid |qp.fvfDomDef87|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and
          (and
            (and (< (inv@115@04 r) V@15@04) (<= 0 (inv@115@04 r)))
            (< (inv@114@04 r) V@15@04))
          (<= 0 (inv@114@04 r)))
        (< $Perm.No $k@111@04))
      (and
        (and
          (and (< (inv@81@04 r) V@15@04) (<= 0 (inv@81@04 r)))
          (< (inv@80@04 r) V@15@04))
        (<= 0 (inv@80@04 r))))
    (=
      ($FVF.lookup_int (as sm@119@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@119@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04))))))))))))) r))
  :qid |qp.fvfValDef84|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and
          (and
            (and (< (inv@115@04 r) V@15@04) (<= 0 (inv@115@04 r)))
            (< (inv@114@04 r) V@15@04))
          (<= 0 (inv@114@04 r)))
        (< $Perm.No $k@111@04))
      (and (< (inv@84@04 r) V@15@04) (<= 0 (inv@84@04 r))))
    (=
      ($FVF.lookup_int (as sm@119@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04)))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@119@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04)))))))))))))))) r))
  :qid |qp.fvfValDef85|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04)))))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@119@04  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef86|)))
(pop) ; 8
; Joined path conditions
(assert ($Perm.isReadVar $k@93@04 $Perm.Write))
(assert (forall ((i1@92@04 Int)) (!
  (implies
    (and (and (< i1@92@04 V@15@04) (<= 0 i1@92@04)) (< $Perm.No $k@93@04))
    (=
      (inv@94@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@92@04))
      i1@92@04))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@92@04))
  :qid |option$array$-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and (< (inv@94@04 r) V@15@04) (<= 0 (inv@94@04 r)))
      (< $Perm.No $k@93@04))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) (inv@94@04 r))
      r))
  :pattern ((inv@94@04 r))
  :qid |option$array$-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (iff
    (Set_in r ($FVF.domain_option$array$ (as sm@96@04  $FVF<option<array>>)))
    (and
      (and (< (inv@94@04 r) V@15@04) (<= 0 (inv@94@04 r)))
      (< $Perm.No $k@93@04)))
  :pattern ((Set_in r ($FVF.domain_option$array$ (as sm@96@04  $FVF<option<array>>))))
  :qid |qp.fvfDomDef59|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@94@04 r) V@15@04) (<= 0 (inv@94@04 r)))
        (< $Perm.No $k@93@04))
      (ite
        (and (< (inv@72@04 r) V@15@04) (<= 0 (inv@72@04 r)))
        (< $Perm.No $k@71@04)
        false))
    (=
      ($FVF.lookup_option$array$ (as sm@96@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@96@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04))))))))) r))
  :qid |qp.fvfValDef57|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04))))))))) r) r)
  :pattern (($FVF.lookup_option$array$ (as sm@96@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef58|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@72@04 r) V@15@04) (<= 0 (inv@72@04 r)))
      (< $Perm.No $k@71@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@98@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@98@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04))))))))) r))
  :qid |qp.fvfValDef60|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04))))))))) r) r)
  :pattern (($FVF.lookup_option$array$ (as sm@98@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef61|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@99@04  $FPM) r)
    (ite (and (< (inv@72@04 r) V@15@04) (<= 0 (inv@72@04 r))) $k@71@04 $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@99@04  $FPM) r))
  :qid |qp.resPrmSumDef62|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@98@04  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04))))))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@99@04  $FPM) r))
  :qid |qp.resTrgDef63|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@72@04 r) V@15@04) (<= 0 (inv@72@04 r)))
      (< $Perm.No $k@71@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@101@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@101@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04))))))))) r))
  :qid |qp.fvfValDef64|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04))))))))) r) r)
  :pattern (($FVF.lookup_option$array$ (as sm@101@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef65|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@102@04  $FPM) r)
    (ite (and (< (inv@72@04 r) V@15@04) (<= 0 (inv@72@04 r))) $k@71@04 $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@102@04  $FPM) r))
  :qid |qp.resPrmSumDef66|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@101@04  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04))))))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@102@04  $FPM) r))
  :qid |qp.resTrgDef67|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@72@04 r) V@15@04) (<= 0 (inv@72@04 r)))
      (< $Perm.No $k@71@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@105@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@105@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04))))))))) r))
  :qid |qp.fvfValDef68|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04))))))))) r) r)
  :pattern (($FVF.lookup_option$array$ (as sm@105@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef69|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@106@04  $FPM) r)
    (ite (and (< (inv@72@04 r) V@15@04) (<= 0 (inv@72@04 r))) $k@71@04 $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@106@04  $FPM) r))
  :qid |qp.resPrmSumDef70|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@105@04  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04))))))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@106@04  $FPM) r))
  :qid |qp.resTrgDef71|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@72@04 r) V@15@04) (<= 0 (inv@72@04 r)))
      (< $Perm.No $k@71@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@107@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@107@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04))))))))) r))
  :qid |qp.fvfValDef72|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04))))))))) r) r)
  :pattern (($FVF.lookup_option$array$ (as sm@107@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef73|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@108@04  $FPM) r)
    (ite (and (< (inv@72@04 r) V@15@04) (<= 0 (inv@72@04 r))) $k@71@04 $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@108@04  $FPM) r))
  :qid |qp.resPrmSumDef74|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@107@04  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04))))))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@108@04  $FPM) r))
  :qid |qp.resTrgDef75|)))
(assert ($Perm.isReadVar $k@111@04 $Perm.Write))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@72@04 r) V@15@04) (<= 0 (inv@72@04 r)))
      (< $Perm.No $k@71@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@112@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@112@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04))))))))) r))
  :qid |qp.fvfValDef76|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04))))))))) r) r)
  :pattern (($FVF.lookup_option$array$ (as sm@112@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef77|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@113@04  $FPM) r)
    (ite (and (< (inv@72@04 r) V@15@04) (<= 0 (inv@72@04 r))) $k@71@04 $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@113@04  $FPM) r))
  :qid |qp.resPrmSumDef78|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@112@04  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04))))))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@113@04  $FPM) r))
  :qid |qp.resTrgDef79|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@81@04 r) V@15@04) (<= 0 (inv@81@04 r)))
        (< (inv@80@04 r) V@15@04))
      (<= 0 (inv@80@04 r)))
    (=
      ($FVF.lookup_int (as sm@116@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@116@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04))))))))))))) r))
  :qid |qp.fvfValDef80|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@84@04 r) V@15@04) (<= 0 (inv@84@04 r)))
    (=
      ($FVF.lookup_int (as sm@116@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04)))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@116@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04)))))))))))))))) r))
  :qid |qp.fvfValDef81|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04)))))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@116@04  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef82|)))
(assert (forall ((i1@109@04 Int) (j@110@04 Int)) (!
  (implies
    (and
      (and
        (and (and (< j@110@04 V@15@04) (<= 0 j@110@04)) (< i1@109@04 V@15@04))
        (<= 0 i1@109@04))
      (< $Perm.No $k@111@04))
    (and
      (=
        (inv@114@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@112@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@109@04))) j@110@04))
        i1@109@04)
      (=
        (inv@115@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@112@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@109@04))) j@110@04))
        j@110@04)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@112@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@109@04))) j@110@04))
  :qid |int-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and
          (and (< (inv@115@04 r) V@15@04) (<= 0 (inv@115@04 r)))
          (< (inv@114@04 r) V@15@04))
        (<= 0 (inv@114@04 r)))
      (< $Perm.No $k@111@04))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@112@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) (inv@114@04 r)))) (inv@115@04 r))
      r))
  :pattern ((inv@114@04 r))
  :pattern ((inv@115@04 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (iff
    (Set_in r ($FVF.domain_int (as sm@119@04  $FVF<Int>)))
    (and
      (and
        (and
          (and (< (inv@115@04 r) V@15@04) (<= 0 (inv@115@04 r)))
          (< (inv@114@04 r) V@15@04))
        (<= 0 (inv@114@04 r)))
      (< $Perm.No $k@111@04)))
  :pattern ((Set_in r ($FVF.domain_int (as sm@119@04  $FVF<Int>))))
  :qid |qp.fvfDomDef87|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and
          (and
            (and (< (inv@115@04 r) V@15@04) (<= 0 (inv@115@04 r)))
            (< (inv@114@04 r) V@15@04))
          (<= 0 (inv@114@04 r)))
        (< $Perm.No $k@111@04))
      (and
        (and
          (and (< (inv@81@04 r) V@15@04) (<= 0 (inv@81@04 r)))
          (< (inv@80@04 r) V@15@04))
        (<= 0 (inv@80@04 r))))
    (=
      ($FVF.lookup_int (as sm@119@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@119@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04))))))))))))) r))
  :qid |qp.fvfValDef84|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and
          (and
            (and (< (inv@115@04 r) V@15@04) (<= 0 (inv@115@04 r)))
            (< (inv@114@04 r) V@15@04))
          (<= 0 (inv@114@04 r)))
        (< $Perm.No $k@111@04))
      (and (< (inv@84@04 r) V@15@04) (<= 0 (inv@84@04 r))))
    (=
      ($FVF.lookup_int (as sm@119@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04)))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@119@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04)))))))))))))))) r))
  :qid |qp.fvfValDef85|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04)))))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@119@04  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef86|)))
(assert (and
  (forall ((i1@92@04 Int)) (!
    (< i1@92@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
    :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@92@04))
    :qid |option$array$-aux|))
  (forall ((r $Ref)) (!
    (implies
      (and (< (inv@94@04 r) V@15@04) (<= 0 (inv@94@04 r)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@73@04  $FVF<option<array>>) r) r))
    :pattern ((inv@94@04 r))
    ))
  (forall ((r $Ref)) (!
    (implies
      (not
        (=
          (ite
            (and (< (inv@72@04 r) V@15@04) (<= 0 (inv@72@04 r)))
            $k@71@04
            $Perm.No)
          $Perm.No))
      (ite
        (and (< (inv@72@04 r) V@15@04) (<= 0 (inv@72@04 r)))
        (<
          (ite
            (and (< (inv@94@04 r) V@15@04) (<= 0 (inv@94@04 r)))
            $k@93@04
            $Perm.No)
          $k@71@04)
        (<
          (ite
            (and (< (inv@94@04 r) V@15@04) (<= 0 (inv@94@04 r)))
            $k@93@04
            $Perm.No)
          $Perm.No)))
    :pattern ((inv@72@04 r))
    :pattern ((inv@94@04 r))
    :qid |qp.srp56|))
  (forall ((i1@97@04 Int)) (!
    (implies
      (and (< i1@97@04 V@15@04) (<= 0 i1@97@04))
      (not
        (=
          ($FVF.lookup_option$array$ (as sm@98@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@97@04))
          (as None<option<array>>  option<array>))))
    
    :qid |prog.l<no position>|))
  (forall ((i1@100@04 Int)) (!
    (implies
      (and (< i1@100@04 V@15@04) (<= 0 i1@100@04))
      (=
        (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@101@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@100@04))))
        V@15@04))
    
    :qid |prog.l<no position>|))
  (forall ((i1@103@04 Int)) (!
    (forall ((i2@104@04 Int)) (!
      (implies
        (and
          (and
            (and
              (and
                (=
                  ($FVF.lookup_option$array$ (as sm@105@04  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@103@04))
                  ($FVF.lookup_option$array$ (as sm@107@04  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@104@04)))
                (< i2@104@04 V@15@04))
              (<= 0 i2@104@04))
            (< i1@103@04 V@15@04))
          (<= 0 i1@103@04))
        (= i1@103@04 i2@104@04))
      :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@104@04))
      :qid |prog.l<no position>|))
    
    :qid |prog.l<no position>|))
  (forall ((i1@109@04 Int) (j@110@04 Int)) (!
    (and
      (< i1@109@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@112@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@109@04)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@109@04))
      (not
        (=
          ($FVF.lookup_option$array$ (as sm@112@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@109@04))
          (as None<option<array>>  option<array>)))
      (<
        j@110@04
        (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@112@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@109@04))))))
    :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@112@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@109@04))) j@110@04))
    :qid |int-aux|))
  (forall ((r $Ref)) (!
    (implies
      (and
        (and
          (and (< (inv@115@04 r) V@15@04) (<= 0 (inv@115@04 r)))
          (< (inv@114@04 r) V@15@04))
        (<= 0 (inv@114@04 r)))
      ($FVF.loc_int ($FVF.lookup_int (as sm@116@04  $FVF<Int>) r) r))
    :pattern ((inv@114@04 r) (inv@115@04 r))
    ))
  (forall ((r $Ref)) (!
    (implies
      (not
        (=
          (ite
            (and
              (and
                (and (< (inv@81@04 r) V@15@04) (<= 0 (inv@81@04 r)))
                (< (inv@80@04 r) V@15@04))
              (<= 0 (inv@80@04 r)))
            $Perm.Write
            $Perm.No)
          $Perm.No))
      (ite
        (and
          (and
            (and (< (inv@81@04 r) V@15@04) (<= 0 (inv@81@04 r)))
            (< (inv@80@04 r) V@15@04))
          (<= 0 (inv@80@04 r)))
        (<
          (ite
            (and
              (and
                (and (< (inv@115@04 r) V@15@04) (<= 0 (inv@115@04 r)))
                (< (inv@114@04 r) V@15@04))
              (<= 0 (inv@114@04 r)))
            $k@111@04
            $Perm.No)
          $Perm.Write)
        (<
          (ite
            (and
              (and
                (and (< (inv@115@04 r) V@15@04) (<= 0 (inv@115@04 r)))
                (< (inv@114@04 r) V@15@04))
              (<= 0 (inv@114@04 r)))
            $k@111@04
            $Perm.No)
          $Perm.No)))
    :pattern ((inv@81@04 r))
    :pattern ((inv@80@04 r))
    :pattern ((inv@115@04 r))
    :pattern ((inv@114@04 r))
    :qid |qp.srp83|))))
(pop) ; 7
(pop) ; 6
; Joined path conditions
(assert ($Perm.isReadVar $k@93@04 $Perm.Write))
(assert (forall ((i1@92@04 Int)) (!
  (implies
    (and (and (< i1@92@04 V@15@04) (<= 0 i1@92@04)) (< $Perm.No $k@93@04))
    (=
      (inv@94@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@92@04))
      i1@92@04))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@92@04))
  :qid |option$array$-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and (< (inv@94@04 r) V@15@04) (<= 0 (inv@94@04 r)))
      (< $Perm.No $k@93@04))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) (inv@94@04 r))
      r))
  :pattern ((inv@94@04 r))
  :qid |option$array$-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (iff
    (Set_in r ($FVF.domain_option$array$ (as sm@96@04  $FVF<option<array>>)))
    (and
      (and (< (inv@94@04 r) V@15@04) (<= 0 (inv@94@04 r)))
      (< $Perm.No $k@93@04)))
  :pattern ((Set_in r ($FVF.domain_option$array$ (as sm@96@04  $FVF<option<array>>))))
  :qid |qp.fvfDomDef59|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@94@04 r) V@15@04) (<= 0 (inv@94@04 r)))
        (< $Perm.No $k@93@04))
      (ite
        (and (< (inv@72@04 r) V@15@04) (<= 0 (inv@72@04 r)))
        (< $Perm.No $k@71@04)
        false))
    (=
      ($FVF.lookup_option$array$ (as sm@96@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@96@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04))))))))) r))
  :qid |qp.fvfValDef57|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04))))))))) r) r)
  :pattern (($FVF.lookup_option$array$ (as sm@96@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef58|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@72@04 r) V@15@04) (<= 0 (inv@72@04 r)))
      (< $Perm.No $k@71@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@98@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@98@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04))))))))) r))
  :qid |qp.fvfValDef60|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04))))))))) r) r)
  :pattern (($FVF.lookup_option$array$ (as sm@98@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef61|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@99@04  $FPM) r)
    (ite (and (< (inv@72@04 r) V@15@04) (<= 0 (inv@72@04 r))) $k@71@04 $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@99@04  $FPM) r))
  :qid |qp.resPrmSumDef62|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@98@04  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04))))))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@99@04  $FPM) r))
  :qid |qp.resTrgDef63|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@72@04 r) V@15@04) (<= 0 (inv@72@04 r)))
      (< $Perm.No $k@71@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@101@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@101@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04))))))))) r))
  :qid |qp.fvfValDef64|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04))))))))) r) r)
  :pattern (($FVF.lookup_option$array$ (as sm@101@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef65|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@102@04  $FPM) r)
    (ite (and (< (inv@72@04 r) V@15@04) (<= 0 (inv@72@04 r))) $k@71@04 $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@102@04  $FPM) r))
  :qid |qp.resPrmSumDef66|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@101@04  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04))))))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@102@04  $FPM) r))
  :qid |qp.resTrgDef67|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@72@04 r) V@15@04) (<= 0 (inv@72@04 r)))
      (< $Perm.No $k@71@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@105@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@105@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04))))))))) r))
  :qid |qp.fvfValDef68|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04))))))))) r) r)
  :pattern (($FVF.lookup_option$array$ (as sm@105@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef69|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@106@04  $FPM) r)
    (ite (and (< (inv@72@04 r) V@15@04) (<= 0 (inv@72@04 r))) $k@71@04 $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@106@04  $FPM) r))
  :qid |qp.resPrmSumDef70|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@105@04  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04))))))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@106@04  $FPM) r))
  :qid |qp.resTrgDef71|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@72@04 r) V@15@04) (<= 0 (inv@72@04 r)))
      (< $Perm.No $k@71@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@107@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@107@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04))))))))) r))
  :qid |qp.fvfValDef72|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04))))))))) r) r)
  :pattern (($FVF.lookup_option$array$ (as sm@107@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef73|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@108@04  $FPM) r)
    (ite (and (< (inv@72@04 r) V@15@04) (<= 0 (inv@72@04 r))) $k@71@04 $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@108@04  $FPM) r))
  :qid |qp.resPrmSumDef74|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@107@04  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04))))))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@108@04  $FPM) r))
  :qid |qp.resTrgDef75|)))
(assert ($Perm.isReadVar $k@111@04 $Perm.Write))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@72@04 r) V@15@04) (<= 0 (inv@72@04 r)))
      (< $Perm.No $k@71@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@112@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@112@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04))))))))) r))
  :qid |qp.fvfValDef76|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04))))))))) r) r)
  :pattern (($FVF.lookup_option$array$ (as sm@112@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef77|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@113@04  $FPM) r)
    (ite (and (< (inv@72@04 r) V@15@04) (<= 0 (inv@72@04 r))) $k@71@04 $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@113@04  $FPM) r))
  :qid |qp.resPrmSumDef78|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@112@04  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04))))))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@113@04  $FPM) r))
  :qid |qp.resTrgDef79|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@81@04 r) V@15@04) (<= 0 (inv@81@04 r)))
        (< (inv@80@04 r) V@15@04))
      (<= 0 (inv@80@04 r)))
    (=
      ($FVF.lookup_int (as sm@116@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@116@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04))))))))))))) r))
  :qid |qp.fvfValDef80|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@84@04 r) V@15@04) (<= 0 (inv@84@04 r)))
    (=
      ($FVF.lookup_int (as sm@116@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04)))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@116@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04)))))))))))))))) r))
  :qid |qp.fvfValDef81|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04)))))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@116@04  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef82|)))
(assert (forall ((i1@109@04 Int) (j@110@04 Int)) (!
  (implies
    (and
      (and
        (and (and (< j@110@04 V@15@04) (<= 0 j@110@04)) (< i1@109@04 V@15@04))
        (<= 0 i1@109@04))
      (< $Perm.No $k@111@04))
    (and
      (=
        (inv@114@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@112@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@109@04))) j@110@04))
        i1@109@04)
      (=
        (inv@115@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@112@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@109@04))) j@110@04))
        j@110@04)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@112@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@109@04))) j@110@04))
  :qid |int-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and
          (and (< (inv@115@04 r) V@15@04) (<= 0 (inv@115@04 r)))
          (< (inv@114@04 r) V@15@04))
        (<= 0 (inv@114@04 r)))
      (< $Perm.No $k@111@04))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@112@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) (inv@114@04 r)))) (inv@115@04 r))
      r))
  :pattern ((inv@114@04 r))
  :pattern ((inv@115@04 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (iff
    (Set_in r ($FVF.domain_int (as sm@119@04  $FVF<Int>)))
    (and
      (and
        (and
          (and (< (inv@115@04 r) V@15@04) (<= 0 (inv@115@04 r)))
          (< (inv@114@04 r) V@15@04))
        (<= 0 (inv@114@04 r)))
      (< $Perm.No $k@111@04)))
  :pattern ((Set_in r ($FVF.domain_int (as sm@119@04  $FVF<Int>))))
  :qid |qp.fvfDomDef87|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and
          (and
            (and (< (inv@115@04 r) V@15@04) (<= 0 (inv@115@04 r)))
            (< (inv@114@04 r) V@15@04))
          (<= 0 (inv@114@04 r)))
        (< $Perm.No $k@111@04))
      (and
        (and
          (and (< (inv@81@04 r) V@15@04) (<= 0 (inv@81@04 r)))
          (< (inv@80@04 r) V@15@04))
        (<= 0 (inv@80@04 r))))
    (=
      ($FVF.lookup_int (as sm@119@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@119@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04))))))))))))) r))
  :qid |qp.fvfValDef84|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and
          (and
            (and (< (inv@115@04 r) V@15@04) (<= 0 (inv@115@04 r)))
            (< (inv@114@04 r) V@15@04))
          (<= 0 (inv@114@04 r)))
        (< $Perm.No $k@111@04))
      (and (< (inv@84@04 r) V@15@04) (<= 0 (inv@84@04 r))))
    (=
      ($FVF.lookup_int (as sm@119@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04)))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@119@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04)))))))))))))))) r))
  :qid |qp.fvfValDef85|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@04)))))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@119@04  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef86|)))
(assert (implies
  (= exc@16@04 $Ref.null)
  (and
    (forall ((i1@92@04 Int)) (!
      (< i1@92@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
      :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@92@04))
      :qid |option$array$-aux|))
    (forall ((r $Ref)) (!
      (implies
        (and (< (inv@94@04 r) V@15@04) (<= 0 (inv@94@04 r)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@73@04  $FVF<option<array>>) r) r))
      :pattern ((inv@94@04 r))
      ))
    (forall ((r $Ref)) (!
      (implies
        (not
          (=
            (ite
              (and (< (inv@72@04 r) V@15@04) (<= 0 (inv@72@04 r)))
              $k@71@04
              $Perm.No)
            $Perm.No))
        (ite
          (and (< (inv@72@04 r) V@15@04) (<= 0 (inv@72@04 r)))
          (<
            (ite
              (and (< (inv@94@04 r) V@15@04) (<= 0 (inv@94@04 r)))
              $k@93@04
              $Perm.No)
            $k@71@04)
          (<
            (ite
              (and (< (inv@94@04 r) V@15@04) (<= 0 (inv@94@04 r)))
              $k@93@04
              $Perm.No)
            $Perm.No)))
      :pattern ((inv@72@04 r))
      :pattern ((inv@94@04 r))
      :qid |qp.srp56|))
    (forall ((i1@97@04 Int)) (!
      (implies
        (and (< i1@97@04 V@15@04) (<= 0 i1@97@04))
        (not
          (=
            ($FVF.lookup_option$array$ (as sm@98@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@97@04))
            (as None<option<array>>  option<array>))))
      
      :qid |prog.l<no position>|))
    (forall ((i1@100@04 Int)) (!
      (implies
        (and (< i1@100@04 V@15@04) (<= 0 i1@100@04))
        (=
          (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@101@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@100@04))))
          V@15@04))
      
      :qid |prog.l<no position>|))
    (forall ((i1@103@04 Int)) (!
      (forall ((i2@104@04 Int)) (!
        (implies
          (and
            (and
              (and
                (and
                  (=
                    ($FVF.lookup_option$array$ (as sm@105@04  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@103@04))
                    ($FVF.lookup_option$array$ (as sm@107@04  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@104@04)))
                  (< i2@104@04 V@15@04))
                (<= 0 i2@104@04))
              (< i1@103@04 V@15@04))
            (<= 0 i1@103@04))
          (= i1@103@04 i2@104@04))
        :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@104@04))
        :qid |prog.l<no position>|))
      
      :qid |prog.l<no position>|))
    (forall ((i1@109@04 Int) (j@110@04 Int)) (!
      (and
        (< i1@109@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@112@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@109@04)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@109@04))
        (not
          (=
            ($FVF.lookup_option$array$ (as sm@112@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@109@04))
            (as None<option<array>>  option<array>)))
        (<
          j@110@04
          (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@112@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@109@04))))))
      :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@112@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@109@04))) j@110@04))
      :qid |int-aux|))
    (forall ((r $Ref)) (!
      (implies
        (and
          (and
            (and (< (inv@115@04 r) V@15@04) (<= 0 (inv@115@04 r)))
            (< (inv@114@04 r) V@15@04))
          (<= 0 (inv@114@04 r)))
        ($FVF.loc_int ($FVF.lookup_int (as sm@116@04  $FVF<Int>) r) r))
      :pattern ((inv@114@04 r) (inv@115@04 r))
      ))
    (forall ((r $Ref)) (!
      (implies
        (not
          (=
            (ite
              (and
                (and
                  (and (< (inv@81@04 r) V@15@04) (<= 0 (inv@81@04 r)))
                  (< (inv@80@04 r) V@15@04))
                (<= 0 (inv@80@04 r)))
              $Perm.Write
              $Perm.No)
            $Perm.No))
        (ite
          (and
            (and
              (and (< (inv@81@04 r) V@15@04) (<= 0 (inv@81@04 r)))
              (< (inv@80@04 r) V@15@04))
            (<= 0 (inv@80@04 r)))
          (<
            (ite
              (and
                (and
                  (and (< (inv@115@04 r) V@15@04) (<= 0 (inv@115@04 r)))
                  (< (inv@114@04 r) V@15@04))
                (<= 0 (inv@114@04 r)))
              $k@111@04
              $Perm.No)
            $Perm.Write)
          (<
            (ite
              (and
                (and
                  (and (< (inv@115@04 r) V@15@04) (<= 0 (inv@115@04 r)))
                  (< (inv@114@04 r) V@15@04))
                (<= 0 (inv@114@04 r)))
              $k@111@04
              $Perm.No)
            $Perm.No)))
      :pattern ((inv@81@04 r))
      :pattern ((inv@80@04 r))
      :pattern ((inv@115@04 r))
      :pattern ((inv@114@04 r))
      :qid |qp.srp83|)))))
(assert (implies
  (= exc@16@04 $Ref.null)
  (FlowNetwork1 ($Snap.combine
    $Snap.unit
    ($Snap.combine
      $Snap.unit
      ($Snap.combine
        $Snap.unit
        ($Snap.combine
          ($SortWrappers.$FVF<option<array>>To$Snap (as sm@96@04  $FVF<option<array>>))
          ($Snap.combine
            $Snap.unit
            ($Snap.combine
              $Snap.unit
              ($Snap.combine
                $Snap.unit
                ($SortWrappers.$FVF<Int>To$Snap (as sm@119@04  $FVF<Int>))))))))) this@9@04 G@11@04 V@15@04 s@12@04 t@13@04)))
(pop) ; 5
(pop) ; 4
(pop) ; 3
(pop) ; 2
(push) ; 2
; [exec]
; var return: Int
(declare-const return@120@04 Int)
; [exec]
; var maxFlow: Int
(declare-const maxFlow@121@04 Int)
; [exec]
; var u: Int
(declare-const u@122@04 Int)
; [exec]
; var G_seq: Seq[Seq[Int]]
(declare-const G_seq@123@04 Seq<Seq<Int>>)
; [exec]
; var Gf_seq: Seq[Seq[Int]]
(declare-const Gf_seq@124@04 Seq<Seq<Int>>)
; [exec]
; var P_seq: Seq[Int]
(declare-const P_seq@125@04 Seq<Int>)
; [exec]
; var bottleneckPathFlow: Int
(declare-const bottleneckPathFlow@126@04 Int)
; [exec]
; var v: Int
(declare-const v@127@04 Int)
; [exec]
; var v1: Int
(declare-const v1@128@04 Int)
; [exec]
; var res1: Bool
(declare-const res1@129@04 Bool)
; [exec]
; var excBeforeLoop: Ref
(declare-const excBeforeLoop@130@04 $Ref)
; [exec]
; var excBeforeLoop1: Ref
(declare-const excBeforeLoop1@131@04 $Ref)
; [exec]
; var excBeforeLoop2: Ref
(declare-const excBeforeLoop2@132@04 $Ref)
; [exec]
; exc := null
; [exec]
; maxFlow := 0
; [exec]
; u := 0
; [exec]
; G_seq := matrixValues(this, G, V)
; [eval] matrixValues(this, G, V)
(push) ; 3
; [eval] this != null
; [eval] a2 != (None(): option[array])
; [eval] (None(): option[array])
; [eval] alen(opt_get1(a2)) == V
; [eval] alen(opt_get1(a2))
; [eval] opt_get1(a2)
(push) ; 4
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 4
; Joined path conditions
(declare-const i1@133@04 Int)
(push) ; 4
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 5
; [then-branch: 72 | 0 <= i1@133@04 | live]
; [else-branch: 72 | !(0 <= i1@133@04) | live]
(push) ; 6
; [then-branch: 72 | 0 <= i1@133@04]
(assert (<= 0 i1@133@04))
; [eval] i1 < V
(pop) ; 6
(push) ; 6
; [else-branch: 72 | !(0 <= i1@133@04)]
(assert (not (<= 0 i1@133@04)))
(pop) ; 6
(pop) ; 5
; Joined path conditions
; Joined path conditions
(assert (and (< i1@133@04 V@15@04) (<= 0 i1@133@04)))
(declare-const $k@134@04 $Perm)
(assert ($Perm.isReadVar $k@134@04 $Perm.Write))
; [eval] aloc(opt_get1(a2), i1)
; [eval] opt_get1(a2)
(push) ; 5
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 5
; Joined path conditions
(push) ; 5
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 6
(assert (not (< i1@133@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               20126
;  :arith-add-rows          7432
;  :arith-assert-diseq      252
;  :arith-assert-lower      4437
;  :arith-assert-upper      3138
;  :arith-bound-prop        860
;  :arith-conflicts         98
;  :arith-eq-adapter        3115
;  :arith-fixed-eqs         2805
;  :arith-offset-eqs        1777
;  :arith-pivots            2506
;  :conflicts               355
;  :datatype-accessor-ax    54
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1088
;  :del-clause              48240
;  :final-checks            5
;  :max-generation          11
;  :max-memory              8.66
;  :memory                  8.32
;  :minimized-lits          35
;  :mk-bool-var             57942
;  :mk-clause               48513
;  :num-allocs              428419
;  :num-checks              116
;  :propagations            14895
;  :quant-instantiations    21655
;  :rlimit-count            1214316)
(assert (< i1@133@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(pop) ; 5
; Joined path conditions
(assert (< i1@133@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(pop) ; 4
(declare-fun inv@135@04 ($Ref) Int)
; Nested auxiliary terms: globals
(assert ($Perm.isReadVar $k@134@04 $Perm.Write))
; Nested auxiliary terms: non-globals
(assert (forall ((i1@133@04 Int)) (!
  (< i1@133@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@133@04))
  :qid |option$array$-aux|)))
(push) ; 4
(assert (not (forall ((i1@133@04 Int)) (!
  (implies
    (and (< i1@133@04 V@15@04) (<= 0 i1@133@04))
    (or (= $k@134@04 $Perm.No) (< $Perm.No $k@134@04)))
  
  ))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               20126
;  :arith-add-rows          7433
;  :arith-assert-diseq      253
;  :arith-assert-lower      4439
;  :arith-assert-upper      3139
;  :arith-bound-prop        860
;  :arith-conflicts         98
;  :arith-eq-adapter        3116
;  :arith-fixed-eqs         2805
;  :arith-offset-eqs        1777
;  :arith-pivots            2507
;  :conflicts               356
;  :datatype-accessor-ax    54
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1088
;  :del-clause              48242
;  :final-checks            5
;  :max-generation          11
;  :max-memory              8.66
;  :memory                  8.32
;  :minimized-lits          35
;  :mk-bool-var             57949
;  :mk-clause               48515
;  :num-allocs              428852
;  :num-checks              117
;  :propagations            14896
;  :quant-instantiations    21655
;  :rlimit-count            1214867)
(declare-const sm@136@04 $FVF<option<array>>)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
      (< $Perm.No $k@20@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@136@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@136@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r))
  :qid |qp.fvfValDef88|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r)
  :pattern (($FVF.lookup_option$array$ (as sm@136@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef89|)))
; Check receiver injectivity
(push) ; 4
(assert (not (forall ((i11@133@04 Int) (i12@133@04 Int)) (!
  (implies
    (and
      (and
        (and
          (and (< i11@133@04 V@15@04) (<= 0 i11@133@04))
          ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i11@133@04)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i11@133@04)))
        (< $Perm.No $k@134@04))
      (and
        (and
          (and (< i12@133@04 V@15@04) (<= 0 i12@133@04))
          ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i12@133@04)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i12@133@04)))
        (< $Perm.No $k@134@04))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i11@133@04)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i12@133@04)))
    (= i11@133@04 i12@133@04))
  
  :qid |option$array$-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               20144
;  :arith-add-rows          7438
;  :arith-assert-diseq      254
;  :arith-assert-lower      4443
;  :arith-assert-upper      3139
;  :arith-bound-prop        860
;  :arith-conflicts         98
;  :arith-eq-adapter        3117
;  :arith-fixed-eqs         2805
;  :arith-offset-eqs        1777
;  :arith-pivots            2509
;  :conflicts               357
;  :datatype-accessor-ax    54
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1088
;  :del-clause              48249
;  :final-checks            5
;  :max-generation          11
;  :max-memory              8.66
;  :memory                  8.32
;  :minimized-lits          35
;  :mk-bool-var             57986
;  :mk-clause               48522
;  :num-allocs              429699
;  :num-checks              118
;  :propagations            14896
;  :quant-instantiations    21681
;  :rlimit-count            1216927)
; Definitional axioms for inverse functions
(assert (forall ((i1@133@04 Int)) (!
  (implies
    (and (and (< i1@133@04 V@15@04) (<= 0 i1@133@04)) (< $Perm.No $k@134@04))
    (=
      (inv@135@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@133@04))
      i1@133@04))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@133@04))
  :qid |option$array$-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and (< (inv@135@04 r) V@15@04) (<= 0 (inv@135@04 r)))
      (< $Perm.No $k@134@04))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) (inv@135@04 r))
      r))
  :pattern ((inv@135@04 r))
  :qid |option$array$-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@135@04 r) V@15@04) (<= 0 (inv@135@04 r)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@04  $FVF<option<array>>) r) r))
  :pattern ((inv@135@04 r))
  )))
; Precomputing data for removing quantified permissions
(define-fun pTaken@137@04 ((r $Ref)) $Perm
  (ite
    (and (< (inv@135@04 r) V@15@04) (<= 0 (inv@135@04 r)))
    ($Perm.min
      (ite
        (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
        $k@20@04
        $Perm.No)
      $k@134@04)
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Constrain original permissions $k@134@04
(assert (forall ((r $Ref)) (!
  (implies
    (not
      (=
        (ite
          (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
          $k@20@04
          $Perm.No)
        $Perm.No))
    (ite
      (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
      (<
        (ite
          (and (< (inv@135@04 r) V@15@04) (<= 0 (inv@135@04 r)))
          $k@134@04
          $Perm.No)
        $k@20@04)
      (<
        (ite
          (and (< (inv@135@04 r) V@15@04) (<= 0 (inv@135@04 r)))
          $k@134@04
          $Perm.No)
        $Perm.No)))
  :pattern ((inv@21@04 r))
  :pattern ((inv@135@04 r))
  :qid |qp.srp90|)))
; Intermediate check if already taken enough permissions
(set-option :timeout 500)
(push) ; 4
(assert (not (forall ((r $Ref)) (!
  (implies
    (and (< (inv@135@04 r) V@15@04) (<= 0 (inv@135@04 r)))
    (= (- $k@134@04 (pTaken@137@04 r)) $Perm.No))
  
  ))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               20861
;  :arith-add-rows          7731
;  :arith-assert-diseq      275
;  :arith-assert-lower      4617
;  :arith-assert-upper      3256
;  :arith-bound-prop        895
;  :arith-conflicts         101
;  :arith-eq-adapter        3259
;  :arith-fixed-eqs         2910
;  :arith-offset-eqs        1832
;  :arith-pivots            2596
;  :conflicts               372
;  :datatype-accessor-ax    54
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1124
;  :del-clause              50005
;  :final-checks            5
;  :max-generation          11
;  :max-memory              8.66
;  :memory                  8.42
;  :minimized-lits          37
;  :mk-bool-var             59985
;  :mk-clause               50305
;  :num-allocs              438070
;  :num-checks              120
;  :propagations            15439
;  :quant-instantiations    22400
;  :rlimit-count            1252745
;  :time                    0.00)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@138@04 $FVF<option<array>>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (iff
    (Set_in r ($FVF.domain_option$array$ (as sm@138@04  $FVF<option<array>>)))
    (and
      (and (< (inv@135@04 r) V@15@04) (<= 0 (inv@135@04 r)))
      (< $Perm.No $k@134@04)))
  :pattern ((Set_in r ($FVF.domain_option$array$ (as sm@138@04  $FVF<option<array>>))))
  :qid |qp.fvfDomDef93|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@135@04 r) V@15@04) (<= 0 (inv@135@04 r)))
        (< $Perm.No $k@134@04))
      (ite
        (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
        (< $Perm.No $k@20@04)
        false))
    (=
      ($FVF.lookup_option$array$ (as sm@138@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@138@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r))
  :qid |qp.fvfValDef91|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r)
  :pattern (($FVF.lookup_option$array$ (as sm@138@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef92|)))
; [eval] (forall i1: Int :: 0 <= i1 && i1 < V ==> aloc(opt_get1(a2), i1).option$array$ != (None(): option[array]))
(declare-const i1@139@04 Int)
(push) ; 4
; [eval] 0 <= i1 && i1 < V ==> aloc(opt_get1(a2), i1).option$array$ != (None(): option[array])
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 5
; [then-branch: 73 | 0 <= i1@139@04 | live]
; [else-branch: 73 | !(0 <= i1@139@04) | live]
(push) ; 6
; [then-branch: 73 | 0 <= i1@139@04]
(assert (<= 0 i1@139@04))
; [eval] i1 < V
(pop) ; 6
(push) ; 6
; [else-branch: 73 | !(0 <= i1@139@04)]
(assert (not (<= 0 i1@139@04)))
(pop) ; 6
(pop) ; 5
; Joined path conditions
; Joined path conditions
(push) ; 5
; [then-branch: 74 | i1@139@04 < V@15@04 && 0 <= i1@139@04 | live]
; [else-branch: 74 | !(i1@139@04 < V@15@04 && 0 <= i1@139@04) | live]
(push) ; 6
; [then-branch: 74 | i1@139@04 < V@15@04 && 0 <= i1@139@04]
(assert (and (< i1@139@04 V@15@04) (<= 0 i1@139@04)))
; [eval] aloc(opt_get1(a2), i1).option$array$ != (None(): option[array])
; [eval] aloc(opt_get1(a2), i1)
; [eval] opt_get1(a2)
(push) ; 7
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 7
; Joined path conditions
(push) ; 7
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 8
(assert (not (< i1@139@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               20861
;  :arith-add-rows          7732
;  :arith-assert-diseq      275
;  :arith-assert-lower      4619
;  :arith-assert-upper      3256
;  :arith-bound-prop        895
;  :arith-conflicts         101
;  :arith-eq-adapter        3259
;  :arith-fixed-eqs         2910
;  :arith-offset-eqs        1832
;  :arith-pivots            2596
;  :conflicts               372
;  :datatype-accessor-ax    54
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1124
;  :del-clause              50005
;  :final-checks            5
;  :max-generation          11
;  :max-memory              8.66
;  :memory                  8.42
;  :minimized-lits          37
;  :mk-bool-var             59990
;  :mk-clause               50305
;  :num-allocs              438669
;  :num-checks              121
;  :propagations            15439
;  :quant-instantiations    22400
;  :rlimit-count            1254090)
(assert (< i1@139@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(pop) ; 7
; Joined path conditions
(assert (< i1@139@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(declare-const sm@140@04 $FVF<option<array>>)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
      (< $Perm.No $k@20@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@140@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@140@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r))
  :qid |qp.fvfValDef94|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r)
  :pattern (($FVF.lookup_option$array$ (as sm@140@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef95|)))
(declare-const pm@141@04 $FPM)
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@141@04  $FPM) r)
    (ite (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r))) $k@20@04 $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@141@04  $FPM) r))
  :qid |qp.resPrmSumDef96|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@140@04  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@141@04  $FPM) r))
  :qid |qp.resTrgDef97|)))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@140@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@139@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@139@04)))
(push) ; 7
(assert (not (<
  $Perm.No
  ($FVF.perm_option$array$ (as pm@141@04  $FPM) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@139@04)))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               20927
;  :arith-add-rows          7759
;  :arith-assert-diseq      278
;  :arith-assert-lower      4634
;  :arith-assert-upper      3265
;  :arith-bound-prop        899
;  :arith-conflicts         103
;  :arith-eq-adapter        3270
;  :arith-fixed-eqs         2917
;  :arith-offset-eqs        1832
;  :arith-pivots            2607
;  :conflicts               375
;  :datatype-accessor-ax    54
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1126
;  :del-clause              50009
;  :final-checks            5
;  :max-generation          11
;  :max-memory              8.66
;  :memory                  8.42
;  :minimized-lits          37
;  :mk-bool-var             60119
;  :mk-clause               50376
;  :num-allocs              440037
;  :num-checks              122
;  :propagations            15467
;  :quant-instantiations    22450
;  :rlimit-count            1258097)
; [eval] (None(): option[array])
(pop) ; 6
(push) ; 6
; [else-branch: 74 | !(i1@139@04 < V@15@04 && 0 <= i1@139@04)]
(assert (not (and (< i1@139@04 V@15@04) (<= 0 i1@139@04))))
(pop) ; 6
(pop) ; 5
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
      (< $Perm.No $k@20@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@140@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@140@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r))
  :qid |qp.fvfValDef94|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r)
  :pattern (($FVF.lookup_option$array$ (as sm@140@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef95|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@141@04  $FPM) r)
    (ite (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r))) $k@20@04 $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@141@04  $FPM) r))
  :qid |qp.resPrmSumDef96|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@140@04  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@141@04  $FPM) r))
  :qid |qp.resTrgDef97|)))
(assert (implies
  (and (< i1@139@04 V@15@04) (<= 0 i1@139@04))
  (and
    (< i1@139@04 V@15@04)
    (<= 0 i1@139@04)
    (< i1@139@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@140@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@139@04)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@139@04)))))
; Joined path conditions
(pop) ; 4
; Nested auxiliary terms: globals (aux)
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
      (< $Perm.No $k@20@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@140@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@140@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r))
  :qid |qp.fvfValDef94|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r)
  :pattern (($FVF.lookup_option$array$ (as sm@140@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef95|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@141@04  $FPM) r)
    (ite (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r))) $k@20@04 $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@141@04  $FPM) r))
  :qid |qp.resPrmSumDef96|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@140@04  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@141@04  $FPM) r))
  :qid |qp.resTrgDef97|)))
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
; Nested auxiliary terms: non-globals (tlq)
(push) ; 4
(assert (not (forall ((i1@139@04 Int)) (!
  (implies
    (and (< i1@139@04 V@15@04) (<= 0 i1@139@04))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@140@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@139@04))
        (as None<option<array>>  option<array>))))
  
  :qid |prog.l<no position>|))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               21045
;  :arith-add-rows          7823
;  :arith-assert-diseq      280
;  :arith-assert-lower      4658
;  :arith-assert-upper      3281
;  :arith-bound-prop        907
;  :arith-conflicts         104
;  :arith-eq-adapter        3286
;  :arith-fixed-eqs         2930
;  :arith-offset-eqs        1846
;  :arith-pivots            2636
;  :conflicts               386
;  :datatype-accessor-ax    54
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1136
;  :del-clause              50489
;  :final-checks            5
;  :max-generation          11
;  :max-memory              8.66
;  :memory                  8.40
;  :minimized-lits          37
;  :mk-bool-var             60490
;  :mk-clause               50789
;  :num-allocs              442355
;  :num-checks              123
;  :propagations            15532
;  :quant-instantiations    22581
;  :rlimit-count            1266781
;  :time                    0.00)
(assert (forall ((i1@139@04 Int)) (!
  (implies
    (and (< i1@139@04 V@15@04) (<= 0 i1@139@04))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@140@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@139@04))
        (as None<option<array>>  option<array>))))
  
  :qid |prog.l<no position>|)))
; [eval] (forall i1: Int :: 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(a2), i1).option$array$)) == V)
(declare-const i1@142@04 Int)
(push) ; 4
; [eval] 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(a2), i1).option$array$)) == V
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 5
; [then-branch: 75 | 0 <= i1@142@04 | live]
; [else-branch: 75 | !(0 <= i1@142@04) | live]
(push) ; 6
; [then-branch: 75 | 0 <= i1@142@04]
(assert (<= 0 i1@142@04))
; [eval] i1 < V
(pop) ; 6
(push) ; 6
; [else-branch: 75 | !(0 <= i1@142@04)]
(assert (not (<= 0 i1@142@04)))
(pop) ; 6
(pop) ; 5
; Joined path conditions
; Joined path conditions
(push) ; 5
; [then-branch: 76 | i1@142@04 < V@15@04 && 0 <= i1@142@04 | live]
; [else-branch: 76 | !(i1@142@04 < V@15@04 && 0 <= i1@142@04) | live]
(push) ; 6
; [then-branch: 76 | i1@142@04 < V@15@04 && 0 <= i1@142@04]
(assert (and (< i1@142@04 V@15@04) (<= 0 i1@142@04)))
; [eval] alen(opt_get1(aloc(opt_get1(a2), i1).option$array$)) == V
; [eval] alen(opt_get1(aloc(opt_get1(a2), i1).option$array$))
; [eval] opt_get1(aloc(opt_get1(a2), i1).option$array$)
; [eval] aloc(opt_get1(a2), i1)
; [eval] opt_get1(a2)
(push) ; 7
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 7
; Joined path conditions
(push) ; 7
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 8
(assert (not (< i1@142@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               21045
;  :arith-add-rows          7824
;  :arith-assert-diseq      280
;  :arith-assert-lower      4660
;  :arith-assert-upper      3281
;  :arith-bound-prop        907
;  :arith-conflicts         104
;  :arith-eq-adapter        3286
;  :arith-fixed-eqs         2930
;  :arith-offset-eqs        1846
;  :arith-pivots            2637
;  :conflicts               386
;  :datatype-accessor-ax    54
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1136
;  :del-clause              50489
;  :final-checks            5
;  :max-generation          11
;  :max-memory              8.66
;  :memory                  8.40
;  :minimized-lits          37
;  :mk-bool-var             60493
;  :mk-clause               50789
;  :num-allocs              442680
;  :num-checks              124
;  :propagations            15532
;  :quant-instantiations    22581
;  :rlimit-count            1267256)
(assert (< i1@142@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(pop) ; 7
; Joined path conditions
(assert (< i1@142@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(declare-const sm@143@04 $FVF<option<array>>)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
      (< $Perm.No $k@20@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@143@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@143@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r))
  :qid |qp.fvfValDef98|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r)
  :pattern (($FVF.lookup_option$array$ (as sm@143@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef99|)))
(declare-const pm@144@04 $FPM)
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@144@04  $FPM) r)
    (ite (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r))) $k@20@04 $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@144@04  $FPM) r))
  :qid |qp.resPrmSumDef100|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@143@04  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@144@04  $FPM) r))
  :qid |qp.resTrgDef101|)))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@143@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@142@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@142@04)))
(push) ; 7
(assert (not (<
  $Perm.No
  ($FVF.perm_option$array$ (as pm@144@04  $FPM) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@142@04)))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               21129
;  :arith-add-rows          7853
;  :arith-assert-diseq      283
;  :arith-assert-lower      4675
;  :arith-assert-upper      3290
;  :arith-bound-prop        912
;  :arith-conflicts         106
;  :arith-eq-adapter        3297
;  :arith-fixed-eqs         2937
;  :arith-offset-eqs        1855
;  :arith-pivots            2649
;  :conflicts               389
;  :datatype-accessor-ax    54
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1138
;  :del-clause              50493
;  :final-checks            5
;  :max-generation          11
;  :max-memory              8.66
;  :memory                  8.41
;  :minimized-lits          37
;  :mk-bool-var             60625
;  :mk-clause               50861
;  :num-allocs              444056
;  :num-checks              125
;  :propagations            15565
;  :quant-instantiations    22633
;  :rlimit-count            1271334)
(push) ; 7
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 8
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@143@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@142@04))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               21206
;  :arith-add-rows          7891
;  :arith-assert-diseq      285
;  :arith-assert-lower      4691
;  :arith-assert-upper      3301
;  :arith-bound-prop        915
;  :arith-conflicts         107
;  :arith-eq-adapter        3308
;  :arith-fixed-eqs         2945
;  :arith-offset-eqs        1860
;  :arith-pivots            2658
;  :conflicts               400
;  :datatype-accessor-ax    54
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1148
;  :del-clause              50832
;  :final-checks            5
;  :max-generation          11
;  :max-memory              8.66
;  :memory                  8.41
;  :minimized-lits          37
;  :mk-bool-var             60886
;  :mk-clause               51200
;  :num-allocs              445043
;  :num-checks              126
;  :propagations            15624
;  :quant-instantiations    22719
;  :rlimit-count            1276139
;  :time                    0.00)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@143@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@142@04))
    (as None<option<array>>  option<array>))))
(pop) ; 7
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@143@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@142@04))
    (as None<option<array>>  option<array>))))
(pop) ; 6
(push) ; 6
; [else-branch: 76 | !(i1@142@04 < V@15@04 && 0 <= i1@142@04)]
(assert (not (and (< i1@142@04 V@15@04) (<= 0 i1@142@04))))
(pop) ; 6
(pop) ; 5
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
      (< $Perm.No $k@20@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@143@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@143@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r))
  :qid |qp.fvfValDef98|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r)
  :pattern (($FVF.lookup_option$array$ (as sm@143@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef99|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@144@04  $FPM) r)
    (ite (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r))) $k@20@04 $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@144@04  $FPM) r))
  :qid |qp.resPrmSumDef100|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@143@04  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@144@04  $FPM) r))
  :qid |qp.resTrgDef101|)))
(assert (implies
  (and (< i1@142@04 V@15@04) (<= 0 i1@142@04))
  (and
    (< i1@142@04 V@15@04)
    (<= 0 i1@142@04)
    (< i1@142@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@143@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@142@04)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@142@04))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@143@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@142@04))
        (as None<option<array>>  option<array>))))))
; Joined path conditions
(pop) ; 4
; Nested auxiliary terms: globals (aux)
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
      (< $Perm.No $k@20@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@143@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@143@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r))
  :qid |qp.fvfValDef98|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r)
  :pattern (($FVF.lookup_option$array$ (as sm@143@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef99|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@144@04  $FPM) r)
    (ite (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r))) $k@20@04 $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@144@04  $FPM) r))
  :qid |qp.resPrmSumDef100|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@143@04  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@144@04  $FPM) r))
  :qid |qp.resTrgDef101|)))
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
; Nested auxiliary terms: non-globals (tlq)
(push) ; 4
(assert (not (forall ((i1@142@04 Int)) (!
  (implies
    (and (< i1@142@04 V@15@04) (<= 0 i1@142@04))
    (=
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@143@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@142@04))))
      V@15@04))
  
  :qid |prog.l<no position>|))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               21344
;  :arith-add-rows          7949
;  :arith-assert-diseq      289
;  :arith-assert-lower      4716
;  :arith-assert-upper      3317
;  :arith-bound-prop        923
;  :arith-conflicts         108
;  :arith-eq-adapter        3325
;  :arith-fixed-eqs         2958
;  :arith-offset-eqs        1874
;  :arith-pivots            2685
;  :conflicts               412
;  :datatype-accessor-ax    54
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1159
;  :del-clause              51322
;  :final-checks            5
;  :max-generation          11
;  :max-memory              8.66
;  :memory                  8.40
;  :minimized-lits          37
;  :mk-bool-var             61270
;  :mk-clause               51622
;  :num-allocs              447396
;  :num-checks              127
;  :propagations            15714
;  :quant-instantiations    22859
;  :rlimit-count            1285074
;  :time                    0.00)
(assert (forall ((i1@142@04 Int)) (!
  (implies
    (and (< i1@142@04 V@15@04) (<= 0 i1@142@04))
    (=
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@143@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@142@04))))
      V@15@04))
  
  :qid |prog.l<no position>|)))
; [eval] (forall i1: Int :: (forall i2: Int :: { aloc(opt_get1(a2), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(a2), i1).option$array$ == aloc(opt_get1(a2), i2).option$array$ ==> i1 == i2))
(declare-const i1@145@04 Int)
(push) ; 4
; [eval] (forall i2: Int :: { aloc(opt_get1(a2), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(a2), i1).option$array$ == aloc(opt_get1(a2), i2).option$array$ ==> i1 == i2)
(declare-const i2@146@04 Int)
(push) ; 5
; [eval] 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(a2), i1).option$array$ == aloc(opt_get1(a2), i2).option$array$ ==> i1 == i2
; [eval] 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(a2), i1).option$array$ == aloc(opt_get1(a2), i2).option$array$
; [eval] 0 <= i1
(push) ; 6
; [then-branch: 77 | 0 <= i1@145@04 | live]
; [else-branch: 77 | !(0 <= i1@145@04) | live]
(push) ; 7
; [then-branch: 77 | 0 <= i1@145@04]
(assert (<= 0 i1@145@04))
; [eval] i1 < V
(push) ; 8
; [then-branch: 78 | i1@145@04 < V@15@04 | live]
; [else-branch: 78 | !(i1@145@04 < V@15@04) | live]
(push) ; 9
; [then-branch: 78 | i1@145@04 < V@15@04]
(assert (< i1@145@04 V@15@04))
; [eval] 0 <= i2
(push) ; 10
; [then-branch: 79 | 0 <= i2@146@04 | live]
; [else-branch: 79 | !(0 <= i2@146@04) | live]
(push) ; 11
; [then-branch: 79 | 0 <= i2@146@04]
(assert (<= 0 i2@146@04))
; [eval] i2 < V
(push) ; 12
; [then-branch: 80 | i2@146@04 < V@15@04 | live]
; [else-branch: 80 | !(i2@146@04 < V@15@04) | live]
(push) ; 13
; [then-branch: 80 | i2@146@04 < V@15@04]
(assert (< i2@146@04 V@15@04))
; [eval] aloc(opt_get1(a2), i1).option$array$ == aloc(opt_get1(a2), i2).option$array$
; [eval] aloc(opt_get1(a2), i1)
; [eval] opt_get1(a2)
(push) ; 14
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 14
; Joined path conditions
(push) ; 14
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 15
(assert (not (< i1@145@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))))
(check-sat)
; unsat
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               21344
;  :arith-add-rows          7951
;  :arith-assert-diseq      289
;  :arith-assert-lower      4720
;  :arith-assert-upper      3317
;  :arith-bound-prop        923
;  :arith-conflicts         108
;  :arith-eq-adapter        3325
;  :arith-fixed-eqs         2958
;  :arith-offset-eqs        1874
;  :arith-pivots            2685
;  :conflicts               412
;  :datatype-accessor-ax    54
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1159
;  :del-clause              51322
;  :final-checks            5
;  :max-generation          11
;  :max-memory              8.66
;  :memory                  8.40
;  :minimized-lits          37
;  :mk-bool-var             61275
;  :mk-clause               51622
;  :num-allocs              447917
;  :num-checks              128
;  :propagations            15714
;  :quant-instantiations    22859
;  :rlimit-count            1285707)
(assert (< i1@145@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(pop) ; 14
; Joined path conditions
(assert (< i1@145@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(declare-const sm@147@04 $FVF<option<array>>)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
      (< $Perm.No $k@20@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@147@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@147@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r))
  :qid |qp.fvfValDef102|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r)
  :pattern (($FVF.lookup_option$array$ (as sm@147@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef103|)))
(declare-const pm@148@04 $FPM)
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@148@04  $FPM) r)
    (ite (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r))) $k@20@04 $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@148@04  $FPM) r))
  :qid |qp.resPrmSumDef104|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@147@04  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@148@04  $FPM) r))
  :qid |qp.resTrgDef105|)))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@147@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@145@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@145@04)))
(push) ; 14
(assert (not (<
  $Perm.No
  ($FVF.perm_option$array$ (as pm@148@04  $FPM) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@145@04)))))
(check-sat)
; unsat
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               21441
;  :arith-add-rows          7979
;  :arith-assert-diseq      292
;  :arith-assert-lower      4737
;  :arith-assert-upper      3327
;  :arith-bound-prop        927
;  :arith-conflicts         110
;  :arith-eq-adapter        3337
;  :arith-fixed-eqs         2966
;  :arith-offset-eqs        1874
;  :arith-pivots            2698
;  :conflicts               415
;  :datatype-accessor-ax    54
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1161
;  :del-clause              51326
;  :final-checks            5
;  :max-generation          11
;  :max-memory              8.66
;  :memory                  8.41
;  :minimized-lits          37
;  :mk-bool-var             61418
;  :mk-clause               51697
;  :num-allocs              449345
;  :num-checks              129
;  :propagations            15748
;  :quant-instantiations    22918
;  :rlimit-count            1289984)
; [eval] aloc(opt_get1(a2), i2)
; [eval] opt_get1(a2)
(push) ; 14
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 14
; Joined path conditions
(push) ; 14
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 15
(assert (not (< i2@146@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))))
(check-sat)
; unsat
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               21441
;  :arith-add-rows          7979
;  :arith-assert-diseq      292
;  :arith-assert-lower      4737
;  :arith-assert-upper      3327
;  :arith-bound-prop        927
;  :arith-conflicts         110
;  :arith-eq-adapter        3337
;  :arith-fixed-eqs         2966
;  :arith-offset-eqs        1874
;  :arith-pivots            2698
;  :conflicts               415
;  :datatype-accessor-ax    54
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1161
;  :del-clause              51326
;  :final-checks            5
;  :max-generation          11
;  :max-memory              8.66
;  :memory                  8.41
;  :minimized-lits          37
;  :mk-bool-var             61418
;  :mk-clause               51697
;  :num-allocs              449371
;  :num-checks              130
;  :propagations            15748
;  :quant-instantiations    22918
;  :rlimit-count            1290014)
(assert (< i2@146@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(pop) ; 14
; Joined path conditions
(assert (< i2@146@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(declare-const sm@149@04 $FVF<option<array>>)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
      (< $Perm.No $k@20@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@149@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@149@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r))
  :qid |qp.fvfValDef106|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r)
  :pattern (($FVF.lookup_option$array$ (as sm@149@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef107|)))
(declare-const pm@150@04 $FPM)
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@150@04  $FPM) r)
    (ite (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r))) $k@20@04 $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@150@04  $FPM) r))
  :qid |qp.resPrmSumDef108|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@149@04  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@150@04  $FPM) r))
  :qid |qp.resTrgDef109|)))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@149@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@146@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@146@04)))
(push) ; 14
(assert (not (<
  $Perm.No
  ($FVF.perm_option$array$ (as pm@150@04  $FPM) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@146@04)))))
(check-sat)
; unsat
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               21542
;  :arith-add-rows          8015
;  :arith-assert-diseq      295
;  :arith-assert-lower      4754
;  :arith-assert-upper      3337
;  :arith-bound-prop        931
;  :arith-conflicts         112
;  :arith-eq-adapter        3350
;  :arith-fixed-eqs         2974
;  :arith-offset-eqs        1874
;  :arith-pivots            2710
;  :conflicts               418
;  :datatype-accessor-ax    54
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1163
;  :del-clause              51330
;  :final-checks            5
;  :max-generation          11
;  :max-memory              8.66
;  :memory                  8.43
;  :minimized-lits          37
;  :mk-bool-var             61563
;  :mk-clause               51780
;  :num-allocs              450835
;  :num-checks              131
;  :propagations            15790
;  :quant-instantiations    22980
;  :rlimit-count            1294627)
(pop) ; 13
(push) ; 13
; [else-branch: 80 | !(i2@146@04 < V@15@04)]
(assert (not (< i2@146@04 V@15@04)))
(pop) ; 13
(pop) ; 12
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
      (< $Perm.No $k@20@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@147@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@147@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r))
  :qid |qp.fvfValDef102|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r)
  :pattern (($FVF.lookup_option$array$ (as sm@147@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef103|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@148@04  $FPM) r)
    (ite (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r))) $k@20@04 $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@148@04  $FPM) r))
  :qid |qp.resPrmSumDef104|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@147@04  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@148@04  $FPM) r))
  :qid |qp.resTrgDef105|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
      (< $Perm.No $k@20@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@149@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@149@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r))
  :qid |qp.fvfValDef106|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r)
  :pattern (($FVF.lookup_option$array$ (as sm@149@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef107|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@150@04  $FPM) r)
    (ite (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r))) $k@20@04 $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@150@04  $FPM) r))
  :qid |qp.resPrmSumDef108|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@149@04  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@150@04  $FPM) r))
  :qid |qp.resTrgDef109|)))
(assert (implies
  (< i2@146@04 V@15@04)
  (and
    (< i2@146@04 V@15@04)
    (< i1@145@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@147@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@145@04)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@145@04))
    (< i2@146@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@149@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@146@04)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@146@04)))))
; Joined path conditions
(pop) ; 11
(push) ; 11
; [else-branch: 79 | !(0 <= i2@146@04)]
(assert (not (<= 0 i2@146@04)))
(pop) ; 11
(pop) ; 10
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
      (< $Perm.No $k@20@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@147@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@147@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r))
  :qid |qp.fvfValDef102|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r)
  :pattern (($FVF.lookup_option$array$ (as sm@147@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef103|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@148@04  $FPM) r)
    (ite (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r))) $k@20@04 $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@148@04  $FPM) r))
  :qid |qp.resPrmSumDef104|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@147@04  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@148@04  $FPM) r))
  :qid |qp.resTrgDef105|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
      (< $Perm.No $k@20@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@149@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@149@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r))
  :qid |qp.fvfValDef106|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r)
  :pattern (($FVF.lookup_option$array$ (as sm@149@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef107|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@150@04  $FPM) r)
    (ite (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r))) $k@20@04 $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@150@04  $FPM) r))
  :qid |qp.resPrmSumDef108|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@149@04  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@150@04  $FPM) r))
  :qid |qp.resTrgDef109|)))
(assert (implies
  (<= 0 i2@146@04)
  (and
    (<= 0 i2@146@04)
    (implies
      (< i2@146@04 V@15@04)
      (and
        (< i2@146@04 V@15@04)
        (< i1@145@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@147@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@145@04)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@145@04))
        (< i2@146@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@149@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@146@04)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@146@04)))))))
; Joined path conditions
(pop) ; 9
(push) ; 9
; [else-branch: 78 | !(i1@145@04 < V@15@04)]
(assert (not (< i1@145@04 V@15@04)))
(pop) ; 9
(pop) ; 8
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
      (< $Perm.No $k@20@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@147@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@147@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r))
  :qid |qp.fvfValDef102|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r)
  :pattern (($FVF.lookup_option$array$ (as sm@147@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef103|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@148@04  $FPM) r)
    (ite (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r))) $k@20@04 $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@148@04  $FPM) r))
  :qid |qp.resPrmSumDef104|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@147@04  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@148@04  $FPM) r))
  :qid |qp.resTrgDef105|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
      (< $Perm.No $k@20@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@149@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@149@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r))
  :qid |qp.fvfValDef106|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r)
  :pattern (($FVF.lookup_option$array$ (as sm@149@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef107|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@150@04  $FPM) r)
    (ite (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r))) $k@20@04 $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@150@04  $FPM) r))
  :qid |qp.resPrmSumDef108|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@149@04  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@150@04  $FPM) r))
  :qid |qp.resTrgDef109|)))
(assert (implies
  (< i1@145@04 V@15@04)
  (and
    (< i1@145@04 V@15@04)
    (implies
      (<= 0 i2@146@04)
      (and
        (<= 0 i2@146@04)
        (implies
          (< i2@146@04 V@15@04)
          (and
            (< i2@146@04 V@15@04)
            (< i1@145@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@147@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@145@04)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@145@04))
            (< i2@146@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@149@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@146@04)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@146@04)))))))))
; Joined path conditions
(pop) ; 7
(push) ; 7
; [else-branch: 77 | !(0 <= i1@145@04)]
(assert (not (<= 0 i1@145@04)))
(pop) ; 7
(pop) ; 6
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
      (< $Perm.No $k@20@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@147@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@147@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r))
  :qid |qp.fvfValDef102|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r)
  :pattern (($FVF.lookup_option$array$ (as sm@147@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef103|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@148@04  $FPM) r)
    (ite (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r))) $k@20@04 $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@148@04  $FPM) r))
  :qid |qp.resPrmSumDef104|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@147@04  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@148@04  $FPM) r))
  :qid |qp.resTrgDef105|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
      (< $Perm.No $k@20@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@149@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@149@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r))
  :qid |qp.fvfValDef106|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r)
  :pattern (($FVF.lookup_option$array$ (as sm@149@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef107|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@150@04  $FPM) r)
    (ite (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r))) $k@20@04 $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@150@04  $FPM) r))
  :qid |qp.resPrmSumDef108|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@149@04  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@150@04  $FPM) r))
  :qid |qp.resTrgDef109|)))
(assert (implies
  (<= 0 i1@145@04)
  (and
    (<= 0 i1@145@04)
    (implies
      (< i1@145@04 V@15@04)
      (and
        (< i1@145@04 V@15@04)
        (implies
          (<= 0 i2@146@04)
          (and
            (<= 0 i2@146@04)
            (implies
              (< i2@146@04 V@15@04)
              (and
                (< i2@146@04 V@15@04)
                (< i1@145@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@147@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@145@04)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@145@04))
                (< i2@146@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@149@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@146@04)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@146@04)))))))))))
; Joined path conditions
(push) ; 6
; [then-branch: 81 | Lookup(option$array$,sm@147@04,aloc((_, _), opt_get1(_, G@11@04), i1@145@04)) == Lookup(option$array$,sm@149@04,aloc((_, _), opt_get1(_, G@11@04), i2@146@04)) && i2@146@04 < V@15@04 && 0 <= i2@146@04 && i1@145@04 < V@15@04 && 0 <= i1@145@04 | live]
; [else-branch: 81 | !(Lookup(option$array$,sm@147@04,aloc((_, _), opt_get1(_, G@11@04), i1@145@04)) == Lookup(option$array$,sm@149@04,aloc((_, _), opt_get1(_, G@11@04), i2@146@04)) && i2@146@04 < V@15@04 && 0 <= i2@146@04 && i1@145@04 < V@15@04 && 0 <= i1@145@04) | live]
(push) ; 7
; [then-branch: 81 | Lookup(option$array$,sm@147@04,aloc((_, _), opt_get1(_, G@11@04), i1@145@04)) == Lookup(option$array$,sm@149@04,aloc((_, _), opt_get1(_, G@11@04), i2@146@04)) && i2@146@04 < V@15@04 && 0 <= i2@146@04 && i1@145@04 < V@15@04 && 0 <= i1@145@04]
(assert (and
  (and
    (and
      (and
        (=
          ($FVF.lookup_option$array$ (as sm@147@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@145@04))
          ($FVF.lookup_option$array$ (as sm@149@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@146@04)))
        (< i2@146@04 V@15@04))
      (<= 0 i2@146@04))
    (< i1@145@04 V@15@04))
  (<= 0 i1@145@04)))
; [eval] i1 == i2
(pop) ; 7
(push) ; 7
; [else-branch: 81 | !(Lookup(option$array$,sm@147@04,aloc((_, _), opt_get1(_, G@11@04), i1@145@04)) == Lookup(option$array$,sm@149@04,aloc((_, _), opt_get1(_, G@11@04), i2@146@04)) && i2@146@04 < V@15@04 && 0 <= i2@146@04 && i1@145@04 < V@15@04 && 0 <= i1@145@04)]
(assert (not
  (and
    (and
      (and
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@147@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@145@04))
            ($FVF.lookup_option$array$ (as sm@149@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@146@04)))
          (< i2@146@04 V@15@04))
        (<= 0 i2@146@04))
      (< i1@145@04 V@15@04))
    (<= 0 i1@145@04))))
(pop) ; 7
(pop) ; 6
; Joined path conditions
(assert (implies
  (and
    (and
      (and
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@147@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@145@04))
            ($FVF.lookup_option$array$ (as sm@149@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@146@04)))
          (< i2@146@04 V@15@04))
        (<= 0 i2@146@04))
      (< i1@145@04 V@15@04))
    (<= 0 i1@145@04))
  (and
    (=
      ($FVF.lookup_option$array$ (as sm@147@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@145@04))
      ($FVF.lookup_option$array$ (as sm@149@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@146@04)))
    (< i2@146@04 V@15@04)
    (<= 0 i2@146@04)
    (< i1@145@04 V@15@04)
    (<= 0 i1@145@04))))
; Joined path conditions
(pop) ; 5
; Nested auxiliary terms: globals (aux)
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
      (< $Perm.No $k@20@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@147@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@147@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r))
  :qid |qp.fvfValDef102|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r)
  :pattern (($FVF.lookup_option$array$ (as sm@147@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef103|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@148@04  $FPM) r)
    (ite (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r))) $k@20@04 $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@148@04  $FPM) r))
  :qid |qp.resPrmSumDef104|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@147@04  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@148@04  $FPM) r))
  :qid |qp.resTrgDef105|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
      (< $Perm.No $k@20@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@149@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@149@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r))
  :qid |qp.fvfValDef106|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r)
  :pattern (($FVF.lookup_option$array$ (as sm@149@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef107|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@150@04  $FPM) r)
    (ite (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r))) $k@20@04 $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@150@04  $FPM) r))
  :qid |qp.resPrmSumDef108|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@149@04  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@150@04  $FPM) r))
  :qid |qp.resTrgDef109|)))
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i2@146@04 Int)) (!
  (and
    (implies
      (<= 0 i1@145@04)
      (and
        (<= 0 i1@145@04)
        (implies
          (< i1@145@04 V@15@04)
          (and
            (< i1@145@04 V@15@04)
            (implies
              (<= 0 i2@146@04)
              (and
                (<= 0 i2@146@04)
                (implies
                  (< i2@146@04 V@15@04)
                  (and
                    (< i2@146@04 V@15@04)
                    (< i1@145@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
                    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@147@04  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@145@04)) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@145@04))
                    (< i2@146@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
                    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@149@04  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@146@04)) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@146@04))))))))))
    (implies
      (and
        (and
          (and
            (and
              (=
                ($FVF.lookup_option$array$ (as sm@147@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@145@04))
                ($FVF.lookup_option$array$ (as sm@149@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@146@04)))
              (< i2@146@04 V@15@04))
            (<= 0 i2@146@04))
          (< i1@145@04 V@15@04))
        (<= 0 i1@145@04))
      (and
        (=
          ($FVF.lookup_option$array$ (as sm@147@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@145@04))
          ($FVF.lookup_option$array$ (as sm@149@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@146@04)))
        (< i2@146@04 V@15@04)
        (<= 0 i2@146@04)
        (< i1@145@04 V@15@04)
        (<= 0 i1@145@04))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@146@04))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 4
; Nested auxiliary terms: globals (aux)
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
      (< $Perm.No $k@20@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@147@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@147@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r))
  :qid |qp.fvfValDef102|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r)
  :pattern (($FVF.lookup_option$array$ (as sm@147@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef103|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@148@04  $FPM) r)
    (ite (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r))) $k@20@04 $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@148@04  $FPM) r))
  :qid |qp.resPrmSumDef104|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@147@04  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@148@04  $FPM) r))
  :qid |qp.resTrgDef105|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
      (< $Perm.No $k@20@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@149@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@149@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r))
  :qid |qp.fvfValDef106|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r)
  :pattern (($FVF.lookup_option$array$ (as sm@149@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef107|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@150@04  $FPM) r)
    (ite (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r))) $k@20@04 $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@150@04  $FPM) r))
  :qid |qp.resPrmSumDef108|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@149@04  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@150@04  $FPM) r))
  :qid |qp.resTrgDef109|)))
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
; Nested auxiliary terms: non-globals (tlq)
(push) ; 4
(assert (not (forall ((i1@145@04 Int)) (!
  (forall ((i2@146@04 Int)) (!
    (implies
      (and
        (and
          (and
            (and
              (=
                ($FVF.lookup_option$array$ (as sm@147@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@145@04))
                ($FVF.lookup_option$array$ (as sm@149@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@146@04)))
              (< i2@146@04 V@15@04))
            (<= 0 i2@146@04))
          (< i1@145@04 V@15@04))
        (<= 0 i1@145@04))
      (= i1@145@04 i2@146@04))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@146@04))
    :qid |prog.l<no position>|))
  
  :qid |prog.l<no position>|))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               21752
;  :arith-add-rows          8189
;  :arith-assert-diseq      299
;  :arith-assert-lower      4797
;  :arith-assert-upper      3364
;  :arith-bound-prop        949
;  :arith-conflicts         114
;  :arith-eq-adapter        3378
;  :arith-fixed-eqs         2997
;  :arith-offset-eqs        1901
;  :arith-pivots            2771
;  :conflicts               431
;  :datatype-accessor-ax    54
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1175
;  :del-clause              52037
;  :final-checks            5
;  :max-generation          11
;  :max-memory              8.66
;  :memory                  8.42
;  :minimized-lits          37
;  :mk-bool-var             62187
;  :mk-clause               52337
;  :num-allocs              457102
;  :num-checks              132
;  :propagations            15891
;  :quant-instantiations    23203
;  :rlimit-count            1313927
;  :time                    0.00)
(assert (forall ((i1@145@04 Int)) (!
  (forall ((i2@146@04 Int)) (!
    (implies
      (and
        (and
          (and
            (and
              (=
                ($FVF.lookup_option$array$ (as sm@147@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@145@04))
                ($FVF.lookup_option$array$ (as sm@149@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@146@04)))
              (< i2@146@04 V@15@04))
            (<= 0 i2@146@04))
          (< i1@145@04 V@15@04))
        (<= 0 i1@145@04))
      (= i1@145@04 i2@146@04))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@146@04))
    :qid |prog.l<no position>|))
  
  :qid |prog.l<no position>|)))
(declare-const i1@151@04 Int)
(declare-const j@152@04 Int)
(push) ; 4
; [eval] 0 <= i1 && i1 < V && (0 <= j && j < V)
; [eval] 0 <= i1
(push) ; 5
; [then-branch: 82 | 0 <= i1@151@04 | live]
; [else-branch: 82 | !(0 <= i1@151@04) | live]
(push) ; 6
; [then-branch: 82 | 0 <= i1@151@04]
(assert (<= 0 i1@151@04))
; [eval] i1 < V
(push) ; 7
; [then-branch: 83 | i1@151@04 < V@15@04 | live]
; [else-branch: 83 | !(i1@151@04 < V@15@04) | live]
(push) ; 8
; [then-branch: 83 | i1@151@04 < V@15@04]
(assert (< i1@151@04 V@15@04))
; [eval] 0 <= j
(push) ; 9
; [then-branch: 84 | 0 <= j@152@04 | live]
; [else-branch: 84 | !(0 <= j@152@04) | live]
(push) ; 10
; [then-branch: 84 | 0 <= j@152@04]
(assert (<= 0 j@152@04))
; [eval] j < V
(pop) ; 10
(push) ; 10
; [else-branch: 84 | !(0 <= j@152@04)]
(assert (not (<= 0 j@152@04)))
(pop) ; 10
(pop) ; 9
; Joined path conditions
; Joined path conditions
(pop) ; 8
(push) ; 8
; [else-branch: 83 | !(i1@151@04 < V@15@04)]
(assert (not (< i1@151@04 V@15@04)))
(pop) ; 8
(pop) ; 7
; Joined path conditions
; Joined path conditions
(pop) ; 6
(push) ; 6
; [else-branch: 82 | !(0 <= i1@151@04)]
(assert (not (<= 0 i1@151@04)))
(pop) ; 6
(pop) ; 5
; Joined path conditions
; Joined path conditions
(assert (and
  (and (and (< j@152@04 V@15@04) (<= 0 j@152@04)) (< i1@151@04 V@15@04))
  (<= 0 i1@151@04)))
(declare-const $k@153@04 $Perm)
(assert ($Perm.isReadVar $k@153@04 $Perm.Write))
; [eval] aloc(opt_get1(aloc(opt_get1(a2), i1).option$array$), j)
; [eval] opt_get1(aloc(opt_get1(a2), i1).option$array$)
; [eval] aloc(opt_get1(a2), i1)
; [eval] opt_get1(a2)
(push) ; 5
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 5
; Joined path conditions
(push) ; 5
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 6
(assert (not (< i1@151@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               21752
;  :arith-add-rows          8192
;  :arith-assert-diseq      300
;  :arith-assert-lower      4805
;  :arith-assert-upper      3365
;  :arith-bound-prop        949
;  :arith-conflicts         114
;  :arith-eq-adapter        3379
;  :arith-fixed-eqs         2997
;  :arith-offset-eqs        1901
;  :arith-pivots            2773
;  :conflicts               431
;  :datatype-accessor-ax    54
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1175
;  :del-clause              52037
;  :final-checks            5
;  :max-generation          11
;  :max-memory              8.66
;  :memory                  8.42
;  :minimized-lits          37
;  :mk-bool-var             62198
;  :mk-clause               52339
;  :num-allocs              457777
;  :num-checks              133
;  :propagations            15892
;  :quant-instantiations    23203
;  :rlimit-count            1315030)
(assert (< i1@151@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(pop) ; 5
; Joined path conditions
(assert (< i1@151@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(declare-const sm@154@04 $FVF<option<array>>)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
      (< $Perm.No $k@20@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@154@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@154@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r))
  :qid |qp.fvfValDef110|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r)
  :pattern (($FVF.lookup_option$array$ (as sm@154@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef111|)))
(declare-const pm@155@04 $FPM)
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@155@04  $FPM) r)
    (ite (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r))) $k@20@04 $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@155@04  $FPM) r))
  :qid |qp.resPrmSumDef112|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@154@04  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@155@04  $FPM) r))
  :qid |qp.resTrgDef113|)))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@154@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@151@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@151@04)))
(push) ; 5
(assert (not (<
  $Perm.No
  ($FVF.perm_option$array$ (as pm@155@04  $FPM) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@151@04)))))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               21853
;  :arith-add-rows          8218
;  :arith-assert-diseq      303
;  :arith-assert-lower      4822
;  :arith-assert-upper      3375
;  :arith-bound-prop        953
;  :arith-conflicts         116
;  :arith-eq-adapter        3391
;  :arith-fixed-eqs         3005
;  :arith-offset-eqs        1901
;  :arith-pivots            2785
;  :conflicts               434
;  :datatype-accessor-ax    54
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1177
;  :del-clause              52041
;  :final-checks            5
;  :max-generation          11
;  :max-memory              8.66
;  :memory                  8.43
;  :minimized-lits          37
;  :mk-bool-var             62344
;  :mk-clause               52416
;  :num-allocs              459245
;  :num-checks              134
;  :propagations            15930
;  :quant-instantiations    23265
;  :rlimit-count            1319419)
(push) ; 5
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 6
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@154@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@151@04))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               21961
;  :arith-add-rows          8257
;  :arith-assert-diseq      305
;  :arith-assert-lower      4840
;  :arith-assert-upper      3387
;  :arith-bound-prop        957
;  :arith-conflicts         117
;  :arith-eq-adapter        3403
;  :arith-fixed-eqs         3014
;  :arith-offset-eqs        1915
;  :arith-pivots            2796
;  :conflicts               445
;  :datatype-accessor-ax    54
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1187
;  :del-clause              52389
;  :final-checks            5
;  :max-generation          11
;  :max-memory              8.66
;  :memory                  8.42
;  :minimized-lits          37
;  :mk-bool-var             62621
;  :mk-clause               52764
;  :num-allocs              460334
;  :num-checks              135
;  :propagations            16013
;  :quant-instantiations    23363
;  :rlimit-count            1324666
;  :time                    0.00)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@154@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@151@04))
    (as None<option<array>>  option<array>))))
(pop) ; 5
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@154@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@151@04))
    (as None<option<array>>  option<array>))))
(push) ; 5
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 6
(assert (not (<
  j@152@04
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@154@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@151@04)))))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               22137
;  :arith-add-rows          8314
;  :arith-assert-diseq      307
;  :arith-assert-lower      4861
;  :arith-assert-upper      3400
;  :arith-bound-prop        961
;  :arith-conflicts         119
;  :arith-eq-adapter        3419
;  :arith-fixed-eqs         3024
;  :arith-offset-eqs        1929
;  :arith-pivots            2810
;  :conflicts               456
;  :datatype-accessor-ax    54
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1197
;  :del-clause              52747
;  :final-checks            5
;  :max-generation          11
;  :max-memory              8.66
;  :memory                  8.42
;  :minimized-lits          37
;  :mk-bool-var             62936
;  :mk-clause               53122
;  :num-allocs              461629
;  :num-checks              136
;  :propagations            16125
;  :quant-instantiations    23474
;  :rlimit-count            1330572
;  :time                    0.00)
(assert (<
  j@152@04
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@154@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@151@04))))))
(pop) ; 5
; Joined path conditions
(assert (<
  j@152@04
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@154@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@151@04))))))
(pop) ; 4
(declare-fun inv@156@04 ($Ref) Int)
(declare-fun inv@157@04 ($Ref) Int)
; Nested auxiliary terms: globals
(assert ($Perm.isReadVar $k@153@04 $Perm.Write))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
      (< $Perm.No $k@20@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@154@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@154@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r))
  :qid |qp.fvfValDef110|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r)
  :pattern (($FVF.lookup_option$array$ (as sm@154@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef111|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@155@04  $FPM) r)
    (ite (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r))) $k@20@04 $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@155@04  $FPM) r))
  :qid |qp.resPrmSumDef112|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@154@04  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@155@04  $FPM) r))
  :qid |qp.resTrgDef113|)))
; Nested auxiliary terms: non-globals
(assert (forall ((i1@151@04 Int) (j@152@04 Int)) (!
  (and
    (< i1@151@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@154@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@151@04)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@151@04))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@154@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@151@04))
        (as None<option<array>>  option<array>)))
    (<
      j@152@04
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@154@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@151@04))))))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@154@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@151@04))) j@152@04))
  :qid |int-aux|)))
(push) ; 4
(assert (not (forall ((i1@151@04 Int) (j@152@04 Int)) (!
  (implies
    (and
      (and (and (< j@152@04 V@15@04) (<= 0 j@152@04)) (< i1@151@04 V@15@04))
      (<= 0 i1@151@04))
    (or (= $k@153@04 $Perm.No) (< $Perm.No $k@153@04)))
  
  ))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               22137
;  :arith-add-rows          8321
;  :arith-assert-diseq      308
;  :arith-assert-lower      4863
;  :arith-assert-upper      3401
;  :arith-bound-prop        961
;  :arith-conflicts         119
;  :arith-eq-adapter        3420
;  :arith-fixed-eqs         3024
;  :arith-offset-eqs        1929
;  :arith-pivots            2819
;  :conflicts               457
;  :datatype-accessor-ax    54
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1197
;  :del-clause              52822
;  :final-checks            5
;  :max-generation          11
;  :max-memory              8.66
;  :memory                  8.41
;  :minimized-lits          37
;  :mk-bool-var             62949
;  :mk-clause               53124
;  :num-allocs              462676
;  :num-checks              137
;  :propagations            16126
;  :quant-instantiations    23474
;  :rlimit-count            1332878)
(declare-const sm@158@04 $FVF<Int>)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@30@04 r) V@15@04) (<= 0 (inv@30@04 r)))
        (< (inv@29@04 r) V@15@04))
      (<= 0 (inv@29@04 r)))
    (=
      ($FVF.lookup_int (as sm@158@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@158@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))))))) r))
  :qid |qp.fvfValDef114|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@33@04 r) V@15@04) (<= 0 (inv@33@04 r)))
    (=
      ($FVF.lookup_int (as sm@158@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04)))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@158@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04)))))))))))))))) r))
  :qid |qp.fvfValDef115|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04)))))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@158@04  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef116|)))
; Check receiver injectivity
(push) ; 4
(assert (not (forall ((i11@151@04 Int) (j1@152@04 Int) (i12@151@04 Int) (j2@152@04 Int)) (!
  (implies
    (and
      (and
        (and
          (and
            (and
              (and (< j1@152@04 V@15@04) (<= 0 j1@152@04))
              (< i11@151@04 V@15@04))
            (<= 0 i11@151@04))
          ($FVF.loc_int ($FVF.lookup_int (as sm@158@04  $FVF<Int>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@154@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i11@151@04))) j1@152@04)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@154@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i11@151@04))) j1@152@04)))
        (< $Perm.No $k@153@04))
      (and
        (and
          (and
            (and
              (and (< j2@152@04 V@15@04) (<= 0 j2@152@04))
              (< i12@151@04 V@15@04))
            (<= 0 i12@151@04))
          ($FVF.loc_int ($FVF.lookup_int (as sm@158@04  $FVF<Int>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@154@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i12@151@04))) j2@152@04)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@154@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i12@151@04))) j2@152@04)))
        (< $Perm.No $k@153@04))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@154@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i11@151@04))) j1@152@04)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@154@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i12@151@04))) j2@152@04)))
    (and (= i11@151@04 i12@151@04) (= j1@152@04 j2@152@04)))
  
  :qid |int-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 4
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               22584
;  :arith-add-rows          8648
;  :arith-assert-diseq      312
;  :arith-assert-lower      4945
;  :arith-assert-upper      3461
;  :arith-bound-prop        993
;  :arith-conflicts         124
;  :arith-eq-adapter        3469
;  :arith-fixed-eqs         3071
;  :arith-offset-eqs        1978
;  :arith-pivots            2905
;  :conflicts               475
;  :datatype-accessor-ax    54
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1214
;  :del-clause              53610
;  :final-checks            5
;  :max-generation          11
;  :max-memory              8.66
;  :memory                  8.42
;  :minimized-lits          37
;  :mk-bool-var             63925
;  :mk-clause               53912
;  :num-allocs              467309
;  :num-checks              138
;  :propagations            16300
;  :quant-instantiations    23792
;  :rlimit-count            1353026
;  :time                    0.01)
; Definitional axioms for inverse functions
(assert (forall ((i1@151@04 Int) (j@152@04 Int)) (!
  (implies
    (and
      (and
        (and (and (< j@152@04 V@15@04) (<= 0 j@152@04)) (< i1@151@04 V@15@04))
        (<= 0 i1@151@04))
      (< $Perm.No $k@153@04))
    (and
      (=
        (inv@156@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@154@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@151@04))) j@152@04))
        i1@151@04)
      (=
        (inv@157@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@154@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@151@04))) j@152@04))
        j@152@04)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@154@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@151@04))) j@152@04))
  :qid |int-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and
          (and (< (inv@157@04 r) V@15@04) (<= 0 (inv@157@04 r)))
          (< (inv@156@04 r) V@15@04))
        (<= 0 (inv@156@04 r)))
      (< $Perm.No $k@153@04))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@154@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) (inv@156@04 r)))) (inv@157@04 r))
      r))
  :pattern ((inv@156@04 r))
  :pattern ((inv@157@04 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@157@04 r) V@15@04) (<= 0 (inv@157@04 r)))
        (< (inv@156@04 r) V@15@04))
      (<= 0 (inv@156@04 r)))
    ($FVF.loc_int ($FVF.lookup_int (as sm@158@04  $FVF<Int>) r) r))
  :pattern ((inv@156@04 r) (inv@157@04 r))
  )))
; Precomputing data for removing quantified permissions
(define-fun pTaken@159@04 ((r $Ref)) $Perm
  (ite
    (and
      (and
        (and (< (inv@157@04 r) V@15@04) (<= 0 (inv@157@04 r)))
        (< (inv@156@04 r) V@15@04))
      (<= 0 (inv@156@04 r)))
    ($Perm.min
      (ite
        (and
          (and
            (and (< (inv@30@04 r) V@15@04) (<= 0 (inv@30@04 r)))
            (< (inv@29@04 r) V@15@04))
          (<= 0 (inv@29@04 r)))
        $Perm.Write
        $Perm.No)
      $k@153@04)
    $Perm.No))
(define-fun pTaken@160@04 ((r $Ref)) $Perm
  (ite
    (and
      (and
        (and (< (inv@157@04 r) V@15@04) (<= 0 (inv@157@04 r)))
        (< (inv@156@04 r) V@15@04))
      (<= 0 (inv@156@04 r)))
    ($Perm.min
      (ite
        (and (< (inv@33@04 r) V@15@04) (<= 0 (inv@33@04 r)))
        $Perm.Write
        $Perm.No)
      (- $k@153@04 (pTaken@159@04 r)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Constrain original permissions $k@153@04
(assert (forall ((r $Ref)) (!
  (implies
    (not
      (=
        (ite
          (and
            (and
              (and (< (inv@30@04 r) V@15@04) (<= 0 (inv@30@04 r)))
              (< (inv@29@04 r) V@15@04))
            (<= 0 (inv@29@04 r)))
          $Perm.Write
          $Perm.No)
        $Perm.No))
    (ite
      (and
        (and
          (and (< (inv@30@04 r) V@15@04) (<= 0 (inv@30@04 r)))
          (< (inv@29@04 r) V@15@04))
        (<= 0 (inv@29@04 r)))
      (<
        (ite
          (and
            (and
              (and (< (inv@157@04 r) V@15@04) (<= 0 (inv@157@04 r)))
              (< (inv@156@04 r) V@15@04))
            (<= 0 (inv@156@04 r)))
          $k@153@04
          $Perm.No)
        $Perm.Write)
      (<
        (ite
          (and
            (and
              (and (< (inv@157@04 r) V@15@04) (<= 0 (inv@157@04 r)))
              (< (inv@156@04 r) V@15@04))
            (<= 0 (inv@156@04 r)))
          $k@153@04
          $Perm.No)
        $Perm.No)))
  :pattern ((inv@30@04 r))
  :pattern ((inv@29@04 r))
  :pattern ((inv@157@04 r))
  :pattern ((inv@156@04 r))
  :qid |qp.srp117|)))
; Intermediate check if already taken enough permissions
(set-option :timeout 500)
(push) ; 4
(assert (not (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@157@04 r) V@15@04) (<= 0 (inv@157@04 r)))
        (< (inv@156@04 r) V@15@04))
      (<= 0 (inv@156@04 r)))
    (= (- $k@153@04 (pTaken@159@04 r)) $Perm.No))
  
  ))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               23513
;  :arith-add-rows          9020
;  :arith-assert-diseq      321
;  :arith-assert-lower      5142
;  :arith-assert-upper      3603
;  :arith-bound-prop        1015
;  :arith-conflicts         130
;  :arith-eq-adapter        3606
;  :arith-fixed-eqs         3193
;  :arith-offset-eqs        2035
;  :arith-pivots            3027
;  :conflicts               493
;  :datatype-accessor-ax    54
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1257
;  :del-clause              55548
;  :final-checks            5
;  :max-generation          11
;  :max-memory              8.66
;  :memory                  8.44
;  :minimized-lits          37
;  :mk-bool-var             66061
;  :mk-clause               55857
;  :num-allocs              476539
;  :num-checks              140
;  :propagations            16935
;  :quant-instantiations    24630
;  :rlimit-count            1394761
;  :time                    0.01)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@161@04 $FVF<Int>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (iff
    (Set_in r ($FVF.domain_int (as sm@161@04  $FVF<Int>)))
    (and
      (and
        (and
          (and (< (inv@157@04 r) V@15@04) (<= 0 (inv@157@04 r)))
          (< (inv@156@04 r) V@15@04))
        (<= 0 (inv@156@04 r)))
      (< $Perm.No $k@153@04)))
  :pattern ((Set_in r ($FVF.domain_int (as sm@161@04  $FVF<Int>))))
  :qid |qp.fvfDomDef121|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and
          (and
            (and (< (inv@157@04 r) V@15@04) (<= 0 (inv@157@04 r)))
            (< (inv@156@04 r) V@15@04))
          (<= 0 (inv@156@04 r)))
        (< $Perm.No $k@153@04))
      (and
        (and
          (and (< (inv@30@04 r) V@15@04) (<= 0 (inv@30@04 r)))
          (< (inv@29@04 r) V@15@04))
        (<= 0 (inv@29@04 r))))
    (=
      ($FVF.lookup_int (as sm@161@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@161@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))))))) r))
  :qid |qp.fvfValDef118|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and
          (and
            (and (< (inv@157@04 r) V@15@04) (<= 0 (inv@157@04 r)))
            (< (inv@156@04 r) V@15@04))
          (<= 0 (inv@156@04 r)))
        (< $Perm.No $k@153@04))
      (and (< (inv@33@04 r) V@15@04) (<= 0 (inv@33@04 r))))
    (=
      ($FVF.lookup_int (as sm@161@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04)))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@161@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04)))))))))))))))) r))
  :qid |qp.fvfValDef119|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04)))))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@161@04  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef120|)))
(pop) ; 3
; Joined path conditions
(assert ($Perm.isReadVar $k@134@04 $Perm.Write))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
      (< $Perm.No $k@20@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@136@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@136@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r))
  :qid |qp.fvfValDef88|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r)
  :pattern (($FVF.lookup_option$array$ (as sm@136@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef89|)))
(assert (forall ((i1@133@04 Int)) (!
  (implies
    (and (and (< i1@133@04 V@15@04) (<= 0 i1@133@04)) (< $Perm.No $k@134@04))
    (=
      (inv@135@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@133@04))
      i1@133@04))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@133@04))
  :qid |option$array$-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and (< (inv@135@04 r) V@15@04) (<= 0 (inv@135@04 r)))
      (< $Perm.No $k@134@04))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) (inv@135@04 r))
      r))
  :pattern ((inv@135@04 r))
  :qid |option$array$-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (iff
    (Set_in r ($FVF.domain_option$array$ (as sm@138@04  $FVF<option<array>>)))
    (and
      (and (< (inv@135@04 r) V@15@04) (<= 0 (inv@135@04 r)))
      (< $Perm.No $k@134@04)))
  :pattern ((Set_in r ($FVF.domain_option$array$ (as sm@138@04  $FVF<option<array>>))))
  :qid |qp.fvfDomDef93|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@135@04 r) V@15@04) (<= 0 (inv@135@04 r)))
        (< $Perm.No $k@134@04))
      (ite
        (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
        (< $Perm.No $k@20@04)
        false))
    (=
      ($FVF.lookup_option$array$ (as sm@138@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@138@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r))
  :qid |qp.fvfValDef91|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r)
  :pattern (($FVF.lookup_option$array$ (as sm@138@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef92|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
      (< $Perm.No $k@20@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@140@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@140@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r))
  :qid |qp.fvfValDef94|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r)
  :pattern (($FVF.lookup_option$array$ (as sm@140@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef95|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@141@04  $FPM) r)
    (ite (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r))) $k@20@04 $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@141@04  $FPM) r))
  :qid |qp.resPrmSumDef96|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@140@04  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@141@04  $FPM) r))
  :qid |qp.resTrgDef97|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
      (< $Perm.No $k@20@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@143@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@143@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r))
  :qid |qp.fvfValDef98|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r)
  :pattern (($FVF.lookup_option$array$ (as sm@143@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef99|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@144@04  $FPM) r)
    (ite (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r))) $k@20@04 $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@144@04  $FPM) r))
  :qid |qp.resPrmSumDef100|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@143@04  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@144@04  $FPM) r))
  :qid |qp.resTrgDef101|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
      (< $Perm.No $k@20@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@147@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@147@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r))
  :qid |qp.fvfValDef102|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r)
  :pattern (($FVF.lookup_option$array$ (as sm@147@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef103|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@148@04  $FPM) r)
    (ite (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r))) $k@20@04 $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@148@04  $FPM) r))
  :qid |qp.resPrmSumDef104|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@147@04  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@148@04  $FPM) r))
  :qid |qp.resTrgDef105|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
      (< $Perm.No $k@20@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@149@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@149@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r))
  :qid |qp.fvfValDef106|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r)
  :pattern (($FVF.lookup_option$array$ (as sm@149@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef107|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@150@04  $FPM) r)
    (ite (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r))) $k@20@04 $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@150@04  $FPM) r))
  :qid |qp.resPrmSumDef108|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@149@04  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@150@04  $FPM) r))
  :qid |qp.resTrgDef109|)))
(assert ($Perm.isReadVar $k@153@04 $Perm.Write))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
      (< $Perm.No $k@20@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@154@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@154@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r))
  :qid |qp.fvfValDef110|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r)
  :pattern (($FVF.lookup_option$array$ (as sm@154@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef111|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@155@04  $FPM) r)
    (ite (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r))) $k@20@04 $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@155@04  $FPM) r))
  :qid |qp.resPrmSumDef112|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@154@04  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@155@04  $FPM) r))
  :qid |qp.resTrgDef113|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@30@04 r) V@15@04) (<= 0 (inv@30@04 r)))
        (< (inv@29@04 r) V@15@04))
      (<= 0 (inv@29@04 r)))
    (=
      ($FVF.lookup_int (as sm@158@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@158@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))))))) r))
  :qid |qp.fvfValDef114|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@33@04 r) V@15@04) (<= 0 (inv@33@04 r)))
    (=
      ($FVF.lookup_int (as sm@158@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04)))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@158@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04)))))))))))))))) r))
  :qid |qp.fvfValDef115|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04)))))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@158@04  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef116|)))
(assert (forall ((i1@151@04 Int) (j@152@04 Int)) (!
  (implies
    (and
      (and
        (and (and (< j@152@04 V@15@04) (<= 0 j@152@04)) (< i1@151@04 V@15@04))
        (<= 0 i1@151@04))
      (< $Perm.No $k@153@04))
    (and
      (=
        (inv@156@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@154@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@151@04))) j@152@04))
        i1@151@04)
      (=
        (inv@157@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@154@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@151@04))) j@152@04))
        j@152@04)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@154@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@151@04))) j@152@04))
  :qid |int-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and
          (and (< (inv@157@04 r) V@15@04) (<= 0 (inv@157@04 r)))
          (< (inv@156@04 r) V@15@04))
        (<= 0 (inv@156@04 r)))
      (< $Perm.No $k@153@04))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@154@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) (inv@156@04 r)))) (inv@157@04 r))
      r))
  :pattern ((inv@156@04 r))
  :pattern ((inv@157@04 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (iff
    (Set_in r ($FVF.domain_int (as sm@161@04  $FVF<Int>)))
    (and
      (and
        (and
          (and (< (inv@157@04 r) V@15@04) (<= 0 (inv@157@04 r)))
          (< (inv@156@04 r) V@15@04))
        (<= 0 (inv@156@04 r)))
      (< $Perm.No $k@153@04)))
  :pattern ((Set_in r ($FVF.domain_int (as sm@161@04  $FVF<Int>))))
  :qid |qp.fvfDomDef121|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and
          (and
            (and (< (inv@157@04 r) V@15@04) (<= 0 (inv@157@04 r)))
            (< (inv@156@04 r) V@15@04))
          (<= 0 (inv@156@04 r)))
        (< $Perm.No $k@153@04))
      (and
        (and
          (and (< (inv@30@04 r) V@15@04) (<= 0 (inv@30@04 r)))
          (< (inv@29@04 r) V@15@04))
        (<= 0 (inv@29@04 r))))
    (=
      ($FVF.lookup_int (as sm@161@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@161@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))))))) r))
  :qid |qp.fvfValDef118|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and
          (and
            (and (< (inv@157@04 r) V@15@04) (<= 0 (inv@157@04 r)))
            (< (inv@156@04 r) V@15@04))
          (<= 0 (inv@156@04 r)))
        (< $Perm.No $k@153@04))
      (and (< (inv@33@04 r) V@15@04) (<= 0 (inv@33@04 r))))
    (=
      ($FVF.lookup_int (as sm@161@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04)))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@161@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04)))))))))))))))) r))
  :qid |qp.fvfValDef119|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04)))))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@161@04  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef120|)))
(assert (and
  (forall ((i1@133@04 Int)) (!
    (< i1@133@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
    :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@133@04))
    :qid |option$array$-aux|))
  (forall ((r $Ref)) (!
    (implies
      (and (< (inv@135@04 r) V@15@04) (<= 0 (inv@135@04 r)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@04  $FVF<option<array>>) r) r))
    :pattern ((inv@135@04 r))
    ))
  (forall ((r $Ref)) (!
    (implies
      (not
        (=
          (ite
            (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
            $k@20@04
            $Perm.No)
          $Perm.No))
      (ite
        (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
        (<
          (ite
            (and (< (inv@135@04 r) V@15@04) (<= 0 (inv@135@04 r)))
            $k@134@04
            $Perm.No)
          $k@20@04)
        (<
          (ite
            (and (< (inv@135@04 r) V@15@04) (<= 0 (inv@135@04 r)))
            $k@134@04
            $Perm.No)
          $Perm.No)))
    :pattern ((inv@21@04 r))
    :pattern ((inv@135@04 r))
    :qid |qp.srp90|))
  (forall ((i1@139@04 Int)) (!
    (implies
      (and (< i1@139@04 V@15@04) (<= 0 i1@139@04))
      (not
        (=
          ($FVF.lookup_option$array$ (as sm@140@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@139@04))
          (as None<option<array>>  option<array>))))
    
    :qid |prog.l<no position>|))
  (forall ((i1@142@04 Int)) (!
    (implies
      (and (< i1@142@04 V@15@04) (<= 0 i1@142@04))
      (=
        (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@143@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@142@04))))
        V@15@04))
    
    :qid |prog.l<no position>|))
  (forall ((i1@145@04 Int)) (!
    (forall ((i2@146@04 Int)) (!
      (implies
        (and
          (and
            (and
              (and
                (=
                  ($FVF.lookup_option$array$ (as sm@147@04  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@145@04))
                  ($FVF.lookup_option$array$ (as sm@149@04  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@146@04)))
                (< i2@146@04 V@15@04))
              (<= 0 i2@146@04))
            (< i1@145@04 V@15@04))
          (<= 0 i1@145@04))
        (= i1@145@04 i2@146@04))
      :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@146@04))
      :qid |prog.l<no position>|))
    
    :qid |prog.l<no position>|))
  (forall ((i1@151@04 Int) (j@152@04 Int)) (!
    (and
      (< i1@151@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@154@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@151@04)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@151@04))
      (not
        (=
          ($FVF.lookup_option$array$ (as sm@154@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@151@04))
          (as None<option<array>>  option<array>)))
      (<
        j@152@04
        (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@154@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@151@04))))))
    :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@154@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@151@04))) j@152@04))
    :qid |int-aux|))
  (forall ((r $Ref)) (!
    (implies
      (and
        (and
          (and (< (inv@157@04 r) V@15@04) (<= 0 (inv@157@04 r)))
          (< (inv@156@04 r) V@15@04))
        (<= 0 (inv@156@04 r)))
      ($FVF.loc_int ($FVF.lookup_int (as sm@158@04  $FVF<Int>) r) r))
    :pattern ((inv@156@04 r) (inv@157@04 r))
    ))
  (forall ((r $Ref)) (!
    (implies
      (not
        (=
          (ite
            (and
              (and
                (and (< (inv@30@04 r) V@15@04) (<= 0 (inv@30@04 r)))
                (< (inv@29@04 r) V@15@04))
              (<= 0 (inv@29@04 r)))
            $Perm.Write
            $Perm.No)
          $Perm.No))
      (ite
        (and
          (and
            (and (< (inv@30@04 r) V@15@04) (<= 0 (inv@30@04 r)))
            (< (inv@29@04 r) V@15@04))
          (<= 0 (inv@29@04 r)))
        (<
          (ite
            (and
              (and
                (and (< (inv@157@04 r) V@15@04) (<= 0 (inv@157@04 r)))
                (< (inv@156@04 r) V@15@04))
              (<= 0 (inv@156@04 r)))
            $k@153@04
            $Perm.No)
          $Perm.Write)
        (<
          (ite
            (and
              (and
                (and (< (inv@157@04 r) V@15@04) (<= 0 (inv@157@04 r)))
                (< (inv@156@04 r) V@15@04))
              (<= 0 (inv@156@04 r)))
            $k@153@04
            $Perm.No)
          $Perm.No)))
    :pattern ((inv@30@04 r))
    :pattern ((inv@29@04 r))
    :pattern ((inv@157@04 r))
    :pattern ((inv@156@04 r))
    :qid |qp.srp117|))))
(declare-const G_seq@162@04 Seq<Seq<Int>>)
(assert (Seq_equal
  G_seq@162@04
  (matrixValues ($Snap.combine
    $Snap.unit
    ($Snap.combine
      $Snap.unit
      ($Snap.combine
        $Snap.unit
        ($Snap.combine
          ($SortWrappers.$FVF<option<array>>To$Snap (as sm@138@04  $FVF<option<array>>))
          ($Snap.combine
            $Snap.unit
            ($Snap.combine
              $Snap.unit
              ($Snap.combine
                $Snap.unit
                ($SortWrappers.$FVF<Int>To$Snap (as sm@161@04  $FVF<Int>))))))))) this@9@04 G@11@04 V@15@04)))
; [exec]
; Gf_seq := matrixValues(this, G, V)
; [eval] matrixValues(this, G, V)
(push) ; 3
; [eval] this != null
; [eval] a2 != (None(): option[array])
; [eval] (None(): option[array])
; [eval] alen(opt_get1(a2)) == V
; [eval] alen(opt_get1(a2))
; [eval] opt_get1(a2)
(push) ; 4
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 4
; Joined path conditions
(declare-const i1@163@04 Int)
(push) ; 4
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 5
; [then-branch: 85 | 0 <= i1@163@04 | live]
; [else-branch: 85 | !(0 <= i1@163@04) | live]
(push) ; 6
; [then-branch: 85 | 0 <= i1@163@04]
(assert (<= 0 i1@163@04))
; [eval] i1 < V
(pop) ; 6
(push) ; 6
; [else-branch: 85 | !(0 <= i1@163@04)]
(assert (not (<= 0 i1@163@04)))
(pop) ; 6
(pop) ; 5
; Joined path conditions
; Joined path conditions
(assert (and (< i1@163@04 V@15@04) (<= 0 i1@163@04)))
(declare-const $k@164@04 $Perm)
(assert ($Perm.isReadVar $k@164@04 $Perm.Write))
; [eval] aloc(opt_get1(a2), i1)
; [eval] opt_get1(a2)
(push) ; 5
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 5
; Joined path conditions
(push) ; 5
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 6
(assert (not (< i1@163@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               23551
;  :arith-add-rows          9029
;  :arith-assert-diseq      327
;  :arith-assert-lower      5159
;  :arith-assert-upper      3611
;  :arith-bound-prop        1015
;  :arith-conflicts         130
;  :arith-eq-adapter        3616
;  :arith-fixed-eqs         3195
;  :arith-offset-eqs        2035
;  :arith-pivots            3038
;  :conflicts               493
;  :datatype-accessor-ax    61
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1257
;  :del-clause              55586
;  :final-checks            5
;  :max-generation          11
;  :max-memory              8.66
;  :memory                  8.44
;  :minimized-lits          37
;  :mk-bool-var             66249
;  :mk-clause               55971
;  :num-allocs              484334
;  :num-checks              141
;  :propagations            16965
;  :quant-instantiations    24651
;  :rlimit-count            1415823)
(assert (< i1@163@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(pop) ; 5
; Joined path conditions
(assert (< i1@163@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(pop) ; 4
(declare-fun inv@165@04 ($Ref) Int)
; Nested auxiliary terms: globals
(assert ($Perm.isReadVar $k@164@04 $Perm.Write))
; Nested auxiliary terms: non-globals
(assert (forall ((i1@163@04 Int)) (!
  (< i1@163@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@163@04))
  :qid |option$array$-aux|)))
(push) ; 4
(assert (not (forall ((i1@163@04 Int)) (!
  (implies
    (and (< i1@163@04 V@15@04) (<= 0 i1@163@04))
    (or (= $k@164@04 $Perm.No) (< $Perm.No $k@164@04)))
  
  ))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               23551
;  :arith-add-rows          9030
;  :arith-assert-diseq      328
;  :arith-assert-lower      5161
;  :arith-assert-upper      3612
;  :arith-bound-prop        1015
;  :arith-conflicts         130
;  :arith-eq-adapter        3617
;  :arith-fixed-eqs         3195
;  :arith-offset-eqs        2035
;  :arith-pivots            3039
;  :conflicts               494
;  :datatype-accessor-ax    61
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1257
;  :del-clause              55588
;  :final-checks            5
;  :max-generation          11
;  :max-memory              8.66
;  :memory                  8.44
;  :minimized-lits          37
;  :mk-bool-var             66256
;  :mk-clause               55973
;  :num-allocs              484764
;  :num-checks              142
;  :propagations            16966
;  :quant-instantiations    24651
;  :rlimit-count            1416374)
(declare-const sm@166@04 $FVF<option<array>>)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
      (< $Perm.No $k@20@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@166@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@166@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r))
  :qid |qp.fvfValDef122|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r)
  :pattern (($FVF.lookup_option$array$ (as sm@166@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef123|)))
; Check receiver injectivity
(push) ; 4
(assert (not (forall ((i11@163@04 Int) (i12@163@04 Int)) (!
  (implies
    (and
      (and
        (and
          (and (< i11@163@04 V@15@04) (<= 0 i11@163@04))
          ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@166@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i11@163@04)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i11@163@04)))
        (< $Perm.No $k@164@04))
      (and
        (and
          (and (< i12@163@04 V@15@04) (<= 0 i12@163@04))
          ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@166@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i12@163@04)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i12@163@04)))
        (< $Perm.No $k@164@04))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i11@163@04)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i12@163@04)))
    (= i11@163@04 i12@163@04))
  
  :qid |option$array$-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               23575
;  :arith-add-rows          9033
;  :arith-assert-diseq      329
;  :arith-assert-lower      5165
;  :arith-assert-upper      3612
;  :arith-bound-prop        1015
;  :arith-conflicts         130
;  :arith-eq-adapter        3618
;  :arith-fixed-eqs         3195
;  :arith-offset-eqs        2035
;  :arith-pivots            3039
;  :conflicts               495
;  :datatype-accessor-ax    61
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1257
;  :del-clause              55595
;  :final-checks            5
;  :max-generation          11
;  :max-memory              8.66
;  :memory                  8.43
;  :minimized-lits          37
;  :mk-bool-var             66302
;  :mk-clause               55980
;  :num-allocs              485725
;  :num-checks              143
;  :propagations            16966
;  :quant-instantiations    24688
;  :rlimit-count            1418793)
; Definitional axioms for inverse functions
(assert (forall ((i1@163@04 Int)) (!
  (implies
    (and (and (< i1@163@04 V@15@04) (<= 0 i1@163@04)) (< $Perm.No $k@164@04))
    (=
      (inv@165@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@163@04))
      i1@163@04))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@163@04))
  :qid |option$array$-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and (< (inv@165@04 r) V@15@04) (<= 0 (inv@165@04 r)))
      (< $Perm.No $k@164@04))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) (inv@165@04 r))
      r))
  :pattern ((inv@165@04 r))
  :qid |option$array$-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@165@04 r) V@15@04) (<= 0 (inv@165@04 r)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@166@04  $FVF<option<array>>) r) r))
  :pattern ((inv@165@04 r))
  )))
; Precomputing data for removing quantified permissions
(define-fun pTaken@167@04 ((r $Ref)) $Perm
  (ite
    (and (< (inv@165@04 r) V@15@04) (<= 0 (inv@165@04 r)))
    ($Perm.min
      (ite
        (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
        $k@20@04
        $Perm.No)
      $k@164@04)
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Constrain original permissions $k@164@04
(assert (forall ((r $Ref)) (!
  (implies
    (not
      (=
        (ite
          (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
          $k@20@04
          $Perm.No)
        $Perm.No))
    (ite
      (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
      (<
        (ite
          (and (< (inv@165@04 r) V@15@04) (<= 0 (inv@165@04 r)))
          $k@164@04
          $Perm.No)
        $k@20@04)
      (<
        (ite
          (and (< (inv@165@04 r) V@15@04) (<= 0 (inv@165@04 r)))
          $k@164@04
          $Perm.No)
        $Perm.No)))
  :pattern ((inv@21@04 r))
  :pattern ((inv@165@04 r))
  :qid |qp.srp124|)))
; Intermediate check if already taken enough permissions
(set-option :timeout 500)
(push) ; 4
(assert (not (forall ((r $Ref)) (!
  (implies
    (and (< (inv@165@04 r) V@15@04) (<= 0 (inv@165@04 r)))
    (= (- $k@164@04 (pTaken@167@04 r)) $Perm.No))
  
  ))))
(check-sat)
; unsat
(pop) ; 4
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               24532
;  :arith-add-rows          9571
;  :arith-assert-diseq      356
;  :arith-assert-lower      5386
;  :arith-assert-upper      3755
;  :arith-bound-prop        1060
;  :arith-conflicts         134
;  :arith-eq-adapter        3790
;  :arith-fixed-eqs         3326
;  :arith-offset-eqs        2093
;  :arith-pivots            3180
;  :conflicts               518
;  :datatype-accessor-ax    61
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1330
;  :del-clause              58670
;  :final-checks            5
;  :max-generation          11
;  :max-memory              8.66
;  :memory                  8.49
;  :minimized-lits          39
;  :mk-bool-var             69661
;  :mk-clause               59086
;  :num-allocs              498846
;  :num-checks              145
;  :propagations            17671
;  :quant-instantiations    25799
;  :rlimit-count            1467917
;  :time                    0.01)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@168@04 $FVF<option<array>>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (iff
    (Set_in r ($FVF.domain_option$array$ (as sm@168@04  $FVF<option<array>>)))
    (and
      (and (< (inv@165@04 r) V@15@04) (<= 0 (inv@165@04 r)))
      (< $Perm.No $k@164@04)))
  :pattern ((Set_in r ($FVF.domain_option$array$ (as sm@168@04  $FVF<option<array>>))))
  :qid |qp.fvfDomDef127|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@165@04 r) V@15@04) (<= 0 (inv@165@04 r)))
        (< $Perm.No $k@164@04))
      (ite
        (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
        (< $Perm.No $k@20@04)
        false))
    (=
      ($FVF.lookup_option$array$ (as sm@168@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@168@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r))
  :qid |qp.fvfValDef125|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r)
  :pattern (($FVF.lookup_option$array$ (as sm@168@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef126|)))
; [eval] (forall i1: Int :: 0 <= i1 && i1 < V ==> aloc(opt_get1(a2), i1).option$array$ != (None(): option[array]))
(declare-const i1@169@04 Int)
(push) ; 4
; [eval] 0 <= i1 && i1 < V ==> aloc(opt_get1(a2), i1).option$array$ != (None(): option[array])
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 5
; [then-branch: 86 | 0 <= i1@169@04 | live]
; [else-branch: 86 | !(0 <= i1@169@04) | live]
(push) ; 6
; [then-branch: 86 | 0 <= i1@169@04]
(assert (<= 0 i1@169@04))
; [eval] i1 < V
(pop) ; 6
(push) ; 6
; [else-branch: 86 | !(0 <= i1@169@04)]
(assert (not (<= 0 i1@169@04)))
(pop) ; 6
(pop) ; 5
; Joined path conditions
; Joined path conditions
(push) ; 5
; [then-branch: 87 | i1@169@04 < V@15@04 && 0 <= i1@169@04 | live]
; [else-branch: 87 | !(i1@169@04 < V@15@04 && 0 <= i1@169@04) | live]
(push) ; 6
; [then-branch: 87 | i1@169@04 < V@15@04 && 0 <= i1@169@04]
(assert (and (< i1@169@04 V@15@04) (<= 0 i1@169@04)))
; [eval] aloc(opt_get1(a2), i1).option$array$ != (None(): option[array])
; [eval] aloc(opt_get1(a2), i1)
; [eval] opt_get1(a2)
(push) ; 7
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 7
; Joined path conditions
(push) ; 7
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 8
(assert (not (< i1@169@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               24532
;  :arith-add-rows          9572
;  :arith-assert-diseq      356
;  :arith-assert-lower      5388
;  :arith-assert-upper      3755
;  :arith-bound-prop        1060
;  :arith-conflicts         134
;  :arith-eq-adapter        3790
;  :arith-fixed-eqs         3326
;  :arith-offset-eqs        2093
;  :arith-pivots            3180
;  :conflicts               518
;  :datatype-accessor-ax    61
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1330
;  :del-clause              58670
;  :final-checks            5
;  :max-generation          11
;  :max-memory              8.66
;  :memory                  8.49
;  :minimized-lits          39
;  :mk-bool-var             69666
;  :mk-clause               59086
;  :num-allocs              499445
;  :num-checks              146
;  :propagations            17671
;  :quant-instantiations    25799
;  :rlimit-count            1469262)
(assert (< i1@169@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(pop) ; 7
; Joined path conditions
(assert (< i1@169@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(declare-const sm@170@04 $FVF<option<array>>)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
      (< $Perm.No $k@20@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@170@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@170@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r))
  :qid |qp.fvfValDef128|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r)
  :pattern (($FVF.lookup_option$array$ (as sm@170@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef129|)))
(declare-const pm@171@04 $FPM)
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@171@04  $FPM) r)
    (ite (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r))) $k@20@04 $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@171@04  $FPM) r))
  :qid |qp.resPrmSumDef130|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@170@04  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@171@04  $FPM) r))
  :qid |qp.resTrgDef131|)))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@170@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@169@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@169@04)))
(push) ; 7
(assert (not (<
  $Perm.No
  ($FVF.perm_option$array$ (as pm@171@04  $FPM) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@169@04)))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               24645
;  :arith-add-rows          9605
;  :arith-assert-diseq      359
;  :arith-assert-lower      5407
;  :arith-assert-upper      3766
;  :arith-bound-prop        1065
;  :arith-conflicts         136
;  :arith-eq-adapter        3803
;  :arith-fixed-eqs         3335
;  :arith-offset-eqs        2093
;  :arith-pivots            3195
;  :conflicts               521
;  :datatype-accessor-ax    61
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1332
;  :del-clause              58674
;  :final-checks            5
;  :max-generation          11
;  :max-memory              8.81
;  :memory                  8.67
;  :minimized-lits          39
;  :mk-bool-var             69839
;  :mk-clause               59186
;  :num-allocs              501018
;  :num-checks              147
;  :propagations            17715
;  :quant-instantiations    25871
;  :rlimit-count            1474131)
; [eval] (None(): option[array])
(pop) ; 6
(push) ; 6
; [else-branch: 87 | !(i1@169@04 < V@15@04 && 0 <= i1@169@04)]
(assert (not (and (< i1@169@04 V@15@04) (<= 0 i1@169@04))))
(pop) ; 6
(pop) ; 5
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
      (< $Perm.No $k@20@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@170@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@170@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r))
  :qid |qp.fvfValDef128|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r)
  :pattern (($FVF.lookup_option$array$ (as sm@170@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef129|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@171@04  $FPM) r)
    (ite (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r))) $k@20@04 $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@171@04  $FPM) r))
  :qid |qp.resPrmSumDef130|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@170@04  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@171@04  $FPM) r))
  :qid |qp.resTrgDef131|)))
(assert (implies
  (and (< i1@169@04 V@15@04) (<= 0 i1@169@04))
  (and
    (< i1@169@04 V@15@04)
    (<= 0 i1@169@04)
    (< i1@169@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@170@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@169@04)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@169@04)))))
; Joined path conditions
(pop) ; 4
; Nested auxiliary terms: globals (aux)
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
      (< $Perm.No $k@20@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@170@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@170@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r))
  :qid |qp.fvfValDef128|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r)
  :pattern (($FVF.lookup_option$array$ (as sm@170@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef129|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@171@04  $FPM) r)
    (ite (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r))) $k@20@04 $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@171@04  $FPM) r))
  :qid |qp.resPrmSumDef130|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@170@04  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@171@04  $FPM) r))
  :qid |qp.resTrgDef131|)))
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
; Nested auxiliary terms: non-globals (tlq)
(push) ; 4
(assert (not (forall ((i1@169@04 Int)) (!
  (implies
    (and (< i1@169@04 V@15@04) (<= 0 i1@169@04))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@170@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@169@04))
        (as None<option<array>>  option<array>))))
  
  :qid |prog.l<no position>|))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               24851
;  :arith-add-rows          9737
;  :arith-assert-diseq      364
;  :arith-assert-lower      5454
;  :arith-assert-upper      3797
;  :arith-bound-prop        1080
;  :arith-conflicts         137
;  :arith-eq-adapter        3837
;  :arith-fixed-eqs         3364
;  :arith-offset-eqs        2114
;  :arith-pivots            3242
;  :conflicts               539
;  :datatype-accessor-ax    61
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1354
;  :del-clause              59664
;  :final-checks            5
;  :max-generation          11
;  :max-memory              8.81
;  :memory                  8.65
;  :minimized-lits          39
;  :mk-bool-var             70758
;  :mk-clause               60080
;  :num-allocs              505158
;  :num-checks              148
;  :propagations            17838
;  :quant-instantiations    26162
;  :rlimit-count            1489007
;  :time                    0.00)
(assert (forall ((i1@169@04 Int)) (!
  (implies
    (and (< i1@169@04 V@15@04) (<= 0 i1@169@04))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@170@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@169@04))
        (as None<option<array>>  option<array>))))
  
  :qid |prog.l<no position>|)))
; [eval] (forall i1: Int :: 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(a2), i1).option$array$)) == V)
(declare-const i1@172@04 Int)
(push) ; 4
; [eval] 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(a2), i1).option$array$)) == V
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 5
; [then-branch: 88 | 0 <= i1@172@04 | live]
; [else-branch: 88 | !(0 <= i1@172@04) | live]
(push) ; 6
; [then-branch: 88 | 0 <= i1@172@04]
(assert (<= 0 i1@172@04))
; [eval] i1 < V
(pop) ; 6
(push) ; 6
; [else-branch: 88 | !(0 <= i1@172@04)]
(assert (not (<= 0 i1@172@04)))
(pop) ; 6
(pop) ; 5
; Joined path conditions
; Joined path conditions
(push) ; 5
; [then-branch: 89 | i1@172@04 < V@15@04 && 0 <= i1@172@04 | live]
; [else-branch: 89 | !(i1@172@04 < V@15@04 && 0 <= i1@172@04) | live]
(push) ; 6
; [then-branch: 89 | i1@172@04 < V@15@04 && 0 <= i1@172@04]
(assert (and (< i1@172@04 V@15@04) (<= 0 i1@172@04)))
; [eval] alen(opt_get1(aloc(opt_get1(a2), i1).option$array$)) == V
; [eval] alen(opt_get1(aloc(opt_get1(a2), i1).option$array$))
; [eval] opt_get1(aloc(opt_get1(a2), i1).option$array$)
; [eval] aloc(opt_get1(a2), i1)
; [eval] opt_get1(a2)
(push) ; 7
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 7
; Joined path conditions
(push) ; 7
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 8
(assert (not (< i1@172@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               24851
;  :arith-add-rows          9738
;  :arith-assert-diseq      364
;  :arith-assert-lower      5456
;  :arith-assert-upper      3797
;  :arith-bound-prop        1080
;  :arith-conflicts         137
;  :arith-eq-adapter        3837
;  :arith-fixed-eqs         3364
;  :arith-offset-eqs        2114
;  :arith-pivots            3243
;  :conflicts               539
;  :datatype-accessor-ax    61
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1354
;  :del-clause              59664
;  :final-checks            5
;  :max-generation          11
;  :max-memory              8.81
;  :memory                  8.65
;  :minimized-lits          39
;  :mk-bool-var             70761
;  :mk-clause               60080
;  :num-allocs              505474
;  :num-checks              149
;  :propagations            17838
;  :quant-instantiations    26162
;  :rlimit-count            1489482)
(assert (< i1@172@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(pop) ; 7
; Joined path conditions
(assert (< i1@172@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(declare-const sm@173@04 $FVF<option<array>>)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
      (< $Perm.No $k@20@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@173@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@173@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r))
  :qid |qp.fvfValDef132|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r)
  :pattern (($FVF.lookup_option$array$ (as sm@173@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef133|)))
(declare-const pm@174@04 $FPM)
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@174@04  $FPM) r)
    (ite (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r))) $k@20@04 $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@174@04  $FPM) r))
  :qid |qp.resPrmSumDef134|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@173@04  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@174@04  $FPM) r))
  :qid |qp.resTrgDef135|)))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@173@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@172@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@172@04)))
(push) ; 7
(assert (not (<
  $Perm.No
  ($FVF.perm_option$array$ (as pm@174@04  $FPM) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@172@04)))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               24983
;  :arith-add-rows          9777
;  :arith-assert-diseq      367
;  :arith-assert-lower      5475
;  :arith-assert-upper      3808
;  :arith-bound-prop        1086
;  :arith-conflicts         139
;  :arith-eq-adapter        3850
;  :arith-fixed-eqs         3373
;  :arith-offset-eqs        2125
;  :arith-pivots            3257
;  :conflicts               542
;  :datatype-accessor-ax    61
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1356
;  :del-clause              59668
;  :final-checks            5
;  :max-generation          11
;  :max-memory              8.81
;  :memory                  8.66
;  :minimized-lits          39
;  :mk-bool-var             70936
;  :mk-clause               60181
;  :num-allocs              507062
;  :num-checks              150
;  :propagations            17887
;  :quant-instantiations    26236
;  :rlimit-count            1494470)
(push) ; 7
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 8
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@173@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@172@04))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               25134
;  :arith-add-rows          9883
;  :arith-assert-diseq      372
;  :arith-assert-lower      5511
;  :arith-assert-upper      3832
;  :arith-bound-prop        1095
;  :arith-conflicts         140
;  :arith-eq-adapter        3877
;  :arith-fixed-eqs         3395
;  :arith-offset-eqs        2135
;  :arith-pivots            3278
;  :conflicts               560
;  :datatype-accessor-ax    61
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1378
;  :del-clause              60458
;  :final-checks            5
;  :max-generation          11
;  :max-memory              8.81
;  :memory                  8.66
;  :minimized-lits          39
;  :mk-bool-var             71704
;  :mk-clause               60971
;  :num-allocs              509708
;  :num-checks              151
;  :propagations            18004
;  :quant-instantiations    26462
;  :rlimit-count            1504710
;  :time                    0.00)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@173@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@172@04))
    (as None<option<array>>  option<array>))))
(pop) ; 7
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@173@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@172@04))
    (as None<option<array>>  option<array>))))
(pop) ; 6
(push) ; 6
; [else-branch: 89 | !(i1@172@04 < V@15@04 && 0 <= i1@172@04)]
(assert (not (and (< i1@172@04 V@15@04) (<= 0 i1@172@04))))
(pop) ; 6
(pop) ; 5
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
      (< $Perm.No $k@20@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@173@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@173@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r))
  :qid |qp.fvfValDef132|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r)
  :pattern (($FVF.lookup_option$array$ (as sm@173@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef133|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@174@04  $FPM) r)
    (ite (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r))) $k@20@04 $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@174@04  $FPM) r))
  :qid |qp.resPrmSumDef134|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@173@04  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@174@04  $FPM) r))
  :qid |qp.resTrgDef135|)))
(assert (implies
  (and (< i1@172@04 V@15@04) (<= 0 i1@172@04))
  (and
    (< i1@172@04 V@15@04)
    (<= 0 i1@172@04)
    (< i1@172@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@173@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@172@04)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@172@04))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@173@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@172@04))
        (as None<option<array>>  option<array>))))))
; Joined path conditions
(pop) ; 4
; Nested auxiliary terms: globals (aux)
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
      (< $Perm.No $k@20@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@173@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@173@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r))
  :qid |qp.fvfValDef132|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r)
  :pattern (($FVF.lookup_option$array$ (as sm@173@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef133|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@174@04  $FPM) r)
    (ite (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r))) $k@20@04 $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@174@04  $FPM) r))
  :qid |qp.resPrmSumDef134|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@173@04  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@174@04  $FPM) r))
  :qid |qp.resTrgDef135|)))
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
; Nested auxiliary terms: non-globals (tlq)
(push) ; 4
(assert (not (forall ((i1@172@04 Int)) (!
  (implies
    (and (< i1@172@04 V@15@04) (<= 0 i1@172@04))
    (=
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@173@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@172@04))))
      V@15@04))
  
  :qid |prog.l<no position>|))))
(check-sat)
; unsat
(pop) ; 4
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               25370
;  :arith-add-rows          10007
;  :arith-assert-diseq      379
;  :arith-assert-lower      5559
;  :arith-assert-upper      3863
;  :arith-bound-prop        1110
;  :arith-conflicts         141
;  :arith-eq-adapter        3912
;  :arith-fixed-eqs         3424
;  :arith-offset-eqs        2156
;  :arith-pivots            3324
;  :conflicts               578
;  :datatype-accessor-ax    61
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1401
;  :del-clause              61459
;  :final-checks            5
;  :max-generation          11
;  :max-memory              8.81
;  :memory                  8.65
;  :minimized-lits          39
;  :mk-bool-var             72627
;  :mk-clause               61875
;  :num-allocs              513870
;  :num-checks              152
;  :propagations            18163
;  :quant-instantiations    26764
;  :rlimit-count            1519936
;  :time                    0.01)
(assert (forall ((i1@172@04 Int)) (!
  (implies
    (and (< i1@172@04 V@15@04) (<= 0 i1@172@04))
    (=
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@173@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@172@04))))
      V@15@04))
  
  :qid |prog.l<no position>|)))
; [eval] (forall i1: Int :: (forall i2: Int :: { aloc(opt_get1(a2), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(a2), i1).option$array$ == aloc(opt_get1(a2), i2).option$array$ ==> i1 == i2))
(declare-const i1@175@04 Int)
(push) ; 4
; [eval] (forall i2: Int :: { aloc(opt_get1(a2), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(a2), i1).option$array$ == aloc(opt_get1(a2), i2).option$array$ ==> i1 == i2)
(declare-const i2@176@04 Int)
(push) ; 5
; [eval] 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(a2), i1).option$array$ == aloc(opt_get1(a2), i2).option$array$ ==> i1 == i2
; [eval] 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(a2), i1).option$array$ == aloc(opt_get1(a2), i2).option$array$
; [eval] 0 <= i1
(push) ; 6
; [then-branch: 90 | 0 <= i1@175@04 | live]
; [else-branch: 90 | !(0 <= i1@175@04) | live]
(push) ; 7
; [then-branch: 90 | 0 <= i1@175@04]
(assert (<= 0 i1@175@04))
; [eval] i1 < V
(push) ; 8
; [then-branch: 91 | i1@175@04 < V@15@04 | live]
; [else-branch: 91 | !(i1@175@04 < V@15@04) | live]
(push) ; 9
; [then-branch: 91 | i1@175@04 < V@15@04]
(assert (< i1@175@04 V@15@04))
; [eval] 0 <= i2
(push) ; 10
; [then-branch: 92 | 0 <= i2@176@04 | live]
; [else-branch: 92 | !(0 <= i2@176@04) | live]
(push) ; 11
; [then-branch: 92 | 0 <= i2@176@04]
(assert (<= 0 i2@176@04))
; [eval] i2 < V
(push) ; 12
; [then-branch: 93 | i2@176@04 < V@15@04 | live]
; [else-branch: 93 | !(i2@176@04 < V@15@04) | live]
(push) ; 13
; [then-branch: 93 | i2@176@04 < V@15@04]
(assert (< i2@176@04 V@15@04))
; [eval] aloc(opt_get1(a2), i1).option$array$ == aloc(opt_get1(a2), i2).option$array$
; [eval] aloc(opt_get1(a2), i1)
; [eval] opt_get1(a2)
(push) ; 14
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 14
; Joined path conditions
(push) ; 14
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 15
(assert (not (< i1@175@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))))
(check-sat)
; unsat
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               25370
;  :arith-add-rows          10009
;  :arith-assert-diseq      379
;  :arith-assert-lower      5563
;  :arith-assert-upper      3863
;  :arith-bound-prop        1110
;  :arith-conflicts         141
;  :arith-eq-adapter        3912
;  :arith-fixed-eqs         3424
;  :arith-offset-eqs        2156
;  :arith-pivots            3325
;  :conflicts               578
;  :datatype-accessor-ax    61
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1401
;  :del-clause              61459
;  :final-checks            5
;  :max-generation          11
;  :max-memory              8.81
;  :memory                  8.66
;  :minimized-lits          39
;  :mk-bool-var             72632
;  :mk-clause               61875
;  :num-allocs              514389
;  :num-checks              153
;  :propagations            18163
;  :quant-instantiations    26764
;  :rlimit-count            1520575)
(assert (< i1@175@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(pop) ; 14
; Joined path conditions
(assert (< i1@175@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(declare-const sm@177@04 $FVF<option<array>>)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
      (< $Perm.No $k@20@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@177@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@177@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r))
  :qid |qp.fvfValDef136|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r)
  :pattern (($FVF.lookup_option$array$ (as sm@177@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef137|)))
(declare-const pm@178@04 $FPM)
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@178@04  $FPM) r)
    (ite (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r))) $k@20@04 $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@178@04  $FPM) r))
  :qid |qp.resPrmSumDef138|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@177@04  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@178@04  $FPM) r))
  :qid |qp.resTrgDef139|)))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@177@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@175@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@175@04)))
(push) ; 14
(assert (not (<
  $Perm.No
  ($FVF.perm_option$array$ (as pm@178@04  $FPM) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@175@04)))))
(check-sat)
; unsat
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               25527
;  :arith-add-rows          10048
;  :arith-assert-diseq      382
;  :arith-assert-lower      5584
;  :arith-assert-upper      3875
;  :arith-bound-prop        1116
;  :arith-conflicts         143
;  :arith-eq-adapter        3926
;  :arith-fixed-eqs         3434
;  :arith-offset-eqs        2167
;  :arith-pivots            3340
;  :conflicts               581
;  :datatype-accessor-ax    61
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1403
;  :del-clause              61463
;  :final-checks            5
;  :max-generation          11
;  :max-memory              8.81
;  :memory                  8.71
;  :minimized-lits          39
;  :mk-bool-var             72818
;  :mk-clause               61979
;  :num-allocs              516019
;  :num-checks              154
;  :propagations            18216
;  :quant-instantiations    26845
;  :rlimit-count            1525740)
; [eval] aloc(opt_get1(a2), i2)
; [eval] opt_get1(a2)
(push) ; 14
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 14
; Joined path conditions
(push) ; 14
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 15
(assert (not (< i2@176@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))))
(check-sat)
; unsat
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               25527
;  :arith-add-rows          10048
;  :arith-assert-diseq      382
;  :arith-assert-lower      5584
;  :arith-assert-upper      3875
;  :arith-bound-prop        1116
;  :arith-conflicts         143
;  :arith-eq-adapter        3926
;  :arith-fixed-eqs         3434
;  :arith-offset-eqs        2167
;  :arith-pivots            3340
;  :conflicts               581
;  :datatype-accessor-ax    61
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1403
;  :del-clause              61463
;  :final-checks            5
;  :max-generation          11
;  :max-memory              8.81
;  :memory                  8.71
;  :minimized-lits          39
;  :mk-bool-var             72818
;  :mk-clause               61979
;  :num-allocs              516045
;  :num-checks              155
;  :propagations            18216
;  :quant-instantiations    26845
;  :rlimit-count            1525770)
(assert (< i2@176@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(pop) ; 14
; Joined path conditions
(assert (< i2@176@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(declare-const sm@179@04 $FVF<option<array>>)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
      (< $Perm.No $k@20@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@179@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@179@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r))
  :qid |qp.fvfValDef140|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r)
  :pattern (($FVF.lookup_option$array$ (as sm@179@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef141|)))
(declare-const pm@180@04 $FPM)
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@180@04  $FPM) r)
    (ite (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r))) $k@20@04 $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@180@04  $FPM) r))
  :qid |qp.resPrmSumDef142|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@179@04  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@180@04  $FPM) r))
  :qid |qp.resTrgDef143|)))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@179@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@176@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@176@04)))
(push) ; 14
(assert (not (<
  $Perm.No
  ($FVF.perm_option$array$ (as pm@180@04  $FPM) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@176@04)))))
(check-sat)
; unsat
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               25676
;  :arith-add-rows          10089
;  :arith-assert-diseq      385
;  :arith-assert-lower      5603
;  :arith-assert-upper      3889
;  :arith-bound-prop        1121
;  :arith-conflicts         145
;  :arith-eq-adapter        3941
;  :arith-fixed-eqs         3444
;  :arith-offset-eqs        2167
;  :arith-pivots            3356
;  :conflicts               584
;  :datatype-accessor-ax    61
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1405
;  :del-clause              61467
;  :final-checks            5
;  :max-generation          11
;  :max-memory              8.81
;  :memory                  8.72
;  :minimized-lits          39
;  :mk-bool-var             72997
;  :mk-clause               62085
;  :num-allocs              517708
;  :num-checks              156
;  :propagations            18274
;  :quant-instantiations    26929
;  :rlimit-count            1531286)
(pop) ; 13
(push) ; 13
; [else-branch: 93 | !(i2@176@04 < V@15@04)]
(assert (not (< i2@176@04 V@15@04)))
(pop) ; 13
(pop) ; 12
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
      (< $Perm.No $k@20@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@177@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@177@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r))
  :qid |qp.fvfValDef136|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r)
  :pattern (($FVF.lookup_option$array$ (as sm@177@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef137|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@178@04  $FPM) r)
    (ite (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r))) $k@20@04 $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@178@04  $FPM) r))
  :qid |qp.resPrmSumDef138|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@177@04  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@178@04  $FPM) r))
  :qid |qp.resTrgDef139|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
      (< $Perm.No $k@20@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@179@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@179@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r))
  :qid |qp.fvfValDef140|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r)
  :pattern (($FVF.lookup_option$array$ (as sm@179@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef141|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@180@04  $FPM) r)
    (ite (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r))) $k@20@04 $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@180@04  $FPM) r))
  :qid |qp.resPrmSumDef142|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@179@04  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@180@04  $FPM) r))
  :qid |qp.resTrgDef143|)))
(assert (implies
  (< i2@176@04 V@15@04)
  (and
    (< i2@176@04 V@15@04)
    (< i1@175@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@177@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@175@04)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@175@04))
    (< i2@176@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@179@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@176@04)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@176@04)))))
; Joined path conditions
(pop) ; 11
(push) ; 11
; [else-branch: 92 | !(0 <= i2@176@04)]
(assert (not (<= 0 i2@176@04)))
(pop) ; 11
(pop) ; 10
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
      (< $Perm.No $k@20@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@177@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@177@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r))
  :qid |qp.fvfValDef136|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r)
  :pattern (($FVF.lookup_option$array$ (as sm@177@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef137|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@178@04  $FPM) r)
    (ite (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r))) $k@20@04 $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@178@04  $FPM) r))
  :qid |qp.resPrmSumDef138|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@177@04  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@178@04  $FPM) r))
  :qid |qp.resTrgDef139|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
      (< $Perm.No $k@20@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@179@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@179@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r))
  :qid |qp.fvfValDef140|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r)
  :pattern (($FVF.lookup_option$array$ (as sm@179@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef141|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@180@04  $FPM) r)
    (ite (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r))) $k@20@04 $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@180@04  $FPM) r))
  :qid |qp.resPrmSumDef142|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@179@04  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@180@04  $FPM) r))
  :qid |qp.resTrgDef143|)))
(assert (implies
  (<= 0 i2@176@04)
  (and
    (<= 0 i2@176@04)
    (implies
      (< i2@176@04 V@15@04)
      (and
        (< i2@176@04 V@15@04)
        (< i1@175@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@177@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@175@04)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@175@04))
        (< i2@176@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@179@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@176@04)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@176@04)))))))
; Joined path conditions
(pop) ; 9
(push) ; 9
; [else-branch: 91 | !(i1@175@04 < V@15@04)]
(assert (not (< i1@175@04 V@15@04)))
(pop) ; 9
(pop) ; 8
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
      (< $Perm.No $k@20@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@177@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@177@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r))
  :qid |qp.fvfValDef136|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r)
  :pattern (($FVF.lookup_option$array$ (as sm@177@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef137|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@178@04  $FPM) r)
    (ite (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r))) $k@20@04 $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@178@04  $FPM) r))
  :qid |qp.resPrmSumDef138|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@177@04  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@178@04  $FPM) r))
  :qid |qp.resTrgDef139|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
      (< $Perm.No $k@20@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@179@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@179@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r))
  :qid |qp.fvfValDef140|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r)
  :pattern (($FVF.lookup_option$array$ (as sm@179@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef141|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@180@04  $FPM) r)
    (ite (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r))) $k@20@04 $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@180@04  $FPM) r))
  :qid |qp.resPrmSumDef142|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@179@04  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@180@04  $FPM) r))
  :qid |qp.resTrgDef143|)))
(assert (implies
  (< i1@175@04 V@15@04)
  (and
    (< i1@175@04 V@15@04)
    (implies
      (<= 0 i2@176@04)
      (and
        (<= 0 i2@176@04)
        (implies
          (< i2@176@04 V@15@04)
          (and
            (< i2@176@04 V@15@04)
            (< i1@175@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@177@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@175@04)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@175@04))
            (< i2@176@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@179@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@176@04)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@176@04)))))))))
; Joined path conditions
(pop) ; 7
(push) ; 7
; [else-branch: 90 | !(0 <= i1@175@04)]
(assert (not (<= 0 i1@175@04)))
(pop) ; 7
(pop) ; 6
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
      (< $Perm.No $k@20@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@177@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@177@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r))
  :qid |qp.fvfValDef136|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r)
  :pattern (($FVF.lookup_option$array$ (as sm@177@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef137|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@178@04  $FPM) r)
    (ite (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r))) $k@20@04 $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@178@04  $FPM) r))
  :qid |qp.resPrmSumDef138|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@177@04  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@178@04  $FPM) r))
  :qid |qp.resTrgDef139|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
      (< $Perm.No $k@20@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@179@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@179@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r))
  :qid |qp.fvfValDef140|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r)
  :pattern (($FVF.lookup_option$array$ (as sm@179@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef141|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@180@04  $FPM) r)
    (ite (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r))) $k@20@04 $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@180@04  $FPM) r))
  :qid |qp.resPrmSumDef142|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@179@04  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@180@04  $FPM) r))
  :qid |qp.resTrgDef143|)))
(assert (implies
  (<= 0 i1@175@04)
  (and
    (<= 0 i1@175@04)
    (implies
      (< i1@175@04 V@15@04)
      (and
        (< i1@175@04 V@15@04)
        (implies
          (<= 0 i2@176@04)
          (and
            (<= 0 i2@176@04)
            (implies
              (< i2@176@04 V@15@04)
              (and
                (< i2@176@04 V@15@04)
                (< i1@175@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@177@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@175@04)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@175@04))
                (< i2@176@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@179@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@176@04)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@176@04)))))))))))
; Joined path conditions
(push) ; 6
; [then-branch: 94 | Lookup(option$array$,sm@177@04,aloc((_, _), opt_get1(_, G@11@04), i1@175@04)) == Lookup(option$array$,sm@179@04,aloc((_, _), opt_get1(_, G@11@04), i2@176@04)) && i2@176@04 < V@15@04 && 0 <= i2@176@04 && i1@175@04 < V@15@04 && 0 <= i1@175@04 | live]
; [else-branch: 94 | !(Lookup(option$array$,sm@177@04,aloc((_, _), opt_get1(_, G@11@04), i1@175@04)) == Lookup(option$array$,sm@179@04,aloc((_, _), opt_get1(_, G@11@04), i2@176@04)) && i2@176@04 < V@15@04 && 0 <= i2@176@04 && i1@175@04 < V@15@04 && 0 <= i1@175@04) | live]
(push) ; 7
; [then-branch: 94 | Lookup(option$array$,sm@177@04,aloc((_, _), opt_get1(_, G@11@04), i1@175@04)) == Lookup(option$array$,sm@179@04,aloc((_, _), opt_get1(_, G@11@04), i2@176@04)) && i2@176@04 < V@15@04 && 0 <= i2@176@04 && i1@175@04 < V@15@04 && 0 <= i1@175@04]
(assert (and
  (and
    (and
      (and
        (=
          ($FVF.lookup_option$array$ (as sm@177@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@175@04))
          ($FVF.lookup_option$array$ (as sm@179@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@176@04)))
        (< i2@176@04 V@15@04))
      (<= 0 i2@176@04))
    (< i1@175@04 V@15@04))
  (<= 0 i1@175@04)))
; [eval] i1 == i2
(pop) ; 7
(push) ; 7
; [else-branch: 94 | !(Lookup(option$array$,sm@177@04,aloc((_, _), opt_get1(_, G@11@04), i1@175@04)) == Lookup(option$array$,sm@179@04,aloc((_, _), opt_get1(_, G@11@04), i2@176@04)) && i2@176@04 < V@15@04 && 0 <= i2@176@04 && i1@175@04 < V@15@04 && 0 <= i1@175@04)]
(assert (not
  (and
    (and
      (and
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@177@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@175@04))
            ($FVF.lookup_option$array$ (as sm@179@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@176@04)))
          (< i2@176@04 V@15@04))
        (<= 0 i2@176@04))
      (< i1@175@04 V@15@04))
    (<= 0 i1@175@04))))
(pop) ; 7
(pop) ; 6
; Joined path conditions
(assert (implies
  (and
    (and
      (and
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@177@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@175@04))
            ($FVF.lookup_option$array$ (as sm@179@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@176@04)))
          (< i2@176@04 V@15@04))
        (<= 0 i2@176@04))
      (< i1@175@04 V@15@04))
    (<= 0 i1@175@04))
  (and
    (=
      ($FVF.lookup_option$array$ (as sm@177@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@175@04))
      ($FVF.lookup_option$array$ (as sm@179@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@176@04)))
    (< i2@176@04 V@15@04)
    (<= 0 i2@176@04)
    (< i1@175@04 V@15@04)
    (<= 0 i1@175@04))))
; Joined path conditions
(pop) ; 5
; Nested auxiliary terms: globals (aux)
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
      (< $Perm.No $k@20@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@177@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@177@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r))
  :qid |qp.fvfValDef136|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r)
  :pattern (($FVF.lookup_option$array$ (as sm@177@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef137|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@178@04  $FPM) r)
    (ite (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r))) $k@20@04 $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@178@04  $FPM) r))
  :qid |qp.resPrmSumDef138|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@177@04  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@178@04  $FPM) r))
  :qid |qp.resTrgDef139|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
      (< $Perm.No $k@20@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@179@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@179@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r))
  :qid |qp.fvfValDef140|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r)
  :pattern (($FVF.lookup_option$array$ (as sm@179@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef141|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@180@04  $FPM) r)
    (ite (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r))) $k@20@04 $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@180@04  $FPM) r))
  :qid |qp.resPrmSumDef142|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@179@04  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@180@04  $FPM) r))
  :qid |qp.resTrgDef143|)))
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i2@176@04 Int)) (!
  (and
    (implies
      (<= 0 i1@175@04)
      (and
        (<= 0 i1@175@04)
        (implies
          (< i1@175@04 V@15@04)
          (and
            (< i1@175@04 V@15@04)
            (implies
              (<= 0 i2@176@04)
              (and
                (<= 0 i2@176@04)
                (implies
                  (< i2@176@04 V@15@04)
                  (and
                    (< i2@176@04 V@15@04)
                    (< i1@175@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
                    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@177@04  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@175@04)) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@175@04))
                    (< i2@176@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
                    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@179@04  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@176@04)) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@176@04))))))))))
    (implies
      (and
        (and
          (and
            (and
              (=
                ($FVF.lookup_option$array$ (as sm@177@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@175@04))
                ($FVF.lookup_option$array$ (as sm@179@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@176@04)))
              (< i2@176@04 V@15@04))
            (<= 0 i2@176@04))
          (< i1@175@04 V@15@04))
        (<= 0 i1@175@04))
      (and
        (=
          ($FVF.lookup_option$array$ (as sm@177@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@175@04))
          ($FVF.lookup_option$array$ (as sm@179@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@176@04)))
        (< i2@176@04 V@15@04)
        (<= 0 i2@176@04)
        (< i1@175@04 V@15@04)
        (<= 0 i1@175@04))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@176@04))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 4
; Nested auxiliary terms: globals (aux)
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
      (< $Perm.No $k@20@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@177@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@177@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r))
  :qid |qp.fvfValDef136|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r)
  :pattern (($FVF.lookup_option$array$ (as sm@177@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef137|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@178@04  $FPM) r)
    (ite (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r))) $k@20@04 $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@178@04  $FPM) r))
  :qid |qp.resPrmSumDef138|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@177@04  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@178@04  $FPM) r))
  :qid |qp.resTrgDef139|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
      (< $Perm.No $k@20@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@179@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@179@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r))
  :qid |qp.fvfValDef140|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r)
  :pattern (($FVF.lookup_option$array$ (as sm@179@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef141|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@180@04  $FPM) r)
    (ite (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r))) $k@20@04 $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@180@04  $FPM) r))
  :qid |qp.resPrmSumDef142|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@179@04  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@180@04  $FPM) r))
  :qid |qp.resTrgDef143|)))
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
; Nested auxiliary terms: non-globals (tlq)
(push) ; 4
(assert (not (forall ((i1@175@04 Int)) (!
  (forall ((i2@176@04 Int)) (!
    (implies
      (and
        (and
          (and
            (and
              (=
                ($FVF.lookup_option$array$ (as sm@177@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@175@04))
                ($FVF.lookup_option$array$ (as sm@179@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@176@04)))
              (< i2@176@04 V@15@04))
            (<= 0 i2@176@04))
          (< i1@175@04 V@15@04))
        (<= 0 i1@175@04))
      (= i1@175@04 i2@176@04))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@176@04))
    :qid |prog.l<no position>|))
  
  :qid |prog.l<no position>|))))
(check-sat)
; unsat
(pop) ; 4
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               26034
;  :arith-add-rows          10372
;  :arith-assert-diseq      392
;  :arith-assert-lower      5675
;  :arith-assert-upper      3935
;  :arith-bound-prop        1149
;  :arith-conflicts         147
;  :arith-eq-adapter        3992
;  :arith-fixed-eqs         3487
;  :arith-offset-eqs        2205
;  :arith-pivots            3447
;  :conflicts               602
;  :datatype-accessor-ax    61
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1429
;  :del-clause              62766
;  :final-checks            5
;  :max-generation          11
;  :max-memory              8.81
;  :memory                  8.73
;  :minimized-lits          39
;  :mk-bool-var             74280
;  :mk-clause               63182
;  :num-allocs              526310
;  :num-checks              157
;  :propagations            18455
;  :quant-instantiations    27355
;  :rlimit-count            1558036
;  :time                    0.01)
(assert (forall ((i1@175@04 Int)) (!
  (forall ((i2@176@04 Int)) (!
    (implies
      (and
        (and
          (and
            (and
              (=
                ($FVF.lookup_option$array$ (as sm@177@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@175@04))
                ($FVF.lookup_option$array$ (as sm@179@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@176@04)))
              (< i2@176@04 V@15@04))
            (<= 0 i2@176@04))
          (< i1@175@04 V@15@04))
        (<= 0 i1@175@04))
      (= i1@175@04 i2@176@04))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@176@04))
    :qid |prog.l<no position>|))
  
  :qid |prog.l<no position>|)))
(declare-const i1@181@04 Int)
(declare-const j@182@04 Int)
(push) ; 4
; [eval] 0 <= i1 && i1 < V && (0 <= j && j < V)
; [eval] 0 <= i1
(push) ; 5
; [then-branch: 95 | 0 <= i1@181@04 | live]
; [else-branch: 95 | !(0 <= i1@181@04) | live]
(push) ; 6
; [then-branch: 95 | 0 <= i1@181@04]
(assert (<= 0 i1@181@04))
; [eval] i1 < V
(push) ; 7
; [then-branch: 96 | i1@181@04 < V@15@04 | live]
; [else-branch: 96 | !(i1@181@04 < V@15@04) | live]
(push) ; 8
; [then-branch: 96 | i1@181@04 < V@15@04]
(assert (< i1@181@04 V@15@04))
; [eval] 0 <= j
(push) ; 9
; [then-branch: 97 | 0 <= j@182@04 | live]
; [else-branch: 97 | !(0 <= j@182@04) | live]
(push) ; 10
; [then-branch: 97 | 0 <= j@182@04]
(assert (<= 0 j@182@04))
; [eval] j < V
(pop) ; 10
(push) ; 10
; [else-branch: 97 | !(0 <= j@182@04)]
(assert (not (<= 0 j@182@04)))
(pop) ; 10
(pop) ; 9
; Joined path conditions
; Joined path conditions
(pop) ; 8
(push) ; 8
; [else-branch: 96 | !(i1@181@04 < V@15@04)]
(assert (not (< i1@181@04 V@15@04)))
(pop) ; 8
(pop) ; 7
; Joined path conditions
; Joined path conditions
(pop) ; 6
(push) ; 6
; [else-branch: 95 | !(0 <= i1@181@04)]
(assert (not (<= 0 i1@181@04)))
(pop) ; 6
(pop) ; 5
; Joined path conditions
; Joined path conditions
(assert (and
  (and (and (< j@182@04 V@15@04) (<= 0 j@182@04)) (< i1@181@04 V@15@04))
  (<= 0 i1@181@04)))
(declare-const $k@183@04 $Perm)
(assert ($Perm.isReadVar $k@183@04 $Perm.Write))
; [eval] aloc(opt_get1(aloc(opt_get1(a2), i1).option$array$), j)
; [eval] opt_get1(aloc(opt_get1(a2), i1).option$array$)
; [eval] aloc(opt_get1(a2), i1)
; [eval] opt_get1(a2)
(push) ; 5
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 5
; Joined path conditions
(push) ; 5
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 6
(assert (not (< i1@181@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               26034
;  :arith-add-rows          10375
;  :arith-assert-diseq      393
;  :arith-assert-lower      5683
;  :arith-assert-upper      3936
;  :arith-bound-prop        1149
;  :arith-conflicts         147
;  :arith-eq-adapter        3993
;  :arith-fixed-eqs         3487
;  :arith-offset-eqs        2205
;  :arith-pivots            3451
;  :conflicts               602
;  :datatype-accessor-ax    61
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1429
;  :del-clause              62766
;  :final-checks            5
;  :max-generation          11
;  :max-memory              8.81
;  :memory                  8.73
;  :minimized-lits          39
;  :mk-bool-var             74291
;  :mk-clause               63184
;  :num-allocs              526988
;  :num-checks              158
;  :propagations            18456
;  :quant-instantiations    27355
;  :rlimit-count            1559149)
(assert (< i1@181@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(pop) ; 5
; Joined path conditions
(assert (< i1@181@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(declare-const sm@184@04 $FVF<option<array>>)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
      (< $Perm.No $k@20@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@184@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@184@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r))
  :qid |qp.fvfValDef144|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r)
  :pattern (($FVF.lookup_option$array$ (as sm@184@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef145|)))
(declare-const pm@185@04 $FPM)
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@185@04  $FPM) r)
    (ite (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r))) $k@20@04 $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@185@04  $FPM) r))
  :qid |qp.resPrmSumDef146|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@184@04  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@185@04  $FPM) r))
  :qid |qp.resTrgDef147|)))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@184@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@181@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@181@04)))
(push) ; 5
(assert (not (<
  $Perm.No
  ($FVF.perm_option$array$ (as pm@185@04  $FPM) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@181@04)))))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               26194
;  :arith-add-rows          10415
;  :arith-assert-diseq      396
;  :arith-assert-lower      5704
;  :arith-assert-upper      3948
;  :arith-bound-prop        1155
;  :arith-conflicts         149
;  :arith-eq-adapter        4007
;  :arith-fixed-eqs         3497
;  :arith-offset-eqs        2216
;  :arith-pivots            3468
;  :conflicts               605
;  :datatype-accessor-ax    61
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1431
;  :del-clause              62770
;  :final-checks            5
;  :max-generation          11
;  :max-memory              8.81
;  :memory                  8.74
;  :minimized-lits          39
;  :mk-bool-var             74479
;  :mk-clause               63290
;  :num-allocs              528663
;  :num-checks              159
;  :propagations            18513
;  :quant-instantiations    27439
;  :rlimit-count            1564497)
(push) ; 5
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 6
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@184@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@181@04))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               26360
;  :arith-add-rows          10523
;  :arith-assert-diseq      401
;  :arith-assert-lower      5744
;  :arith-assert-upper      3974
;  :arith-bound-prop        1164
;  :arith-conflicts         150
;  :arith-eq-adapter        4036
;  :arith-fixed-eqs         3521
;  :arith-offset-eqs        2226
;  :arith-pivots            3493
;  :conflicts               623
;  :datatype-accessor-ax    61
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1453
;  :del-clause              63578
;  :final-checks            5
;  :max-generation          11
;  :max-memory              8.81
;  :memory                  8.74
;  :minimized-lits          39
;  :mk-bool-var             75281
;  :mk-clause               64098
;  :num-allocs              531529
;  :num-checks              160
;  :propagations            18630
;  :quant-instantiations    27691
;  :rlimit-count            1575471
;  :time                    0.00)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@184@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@181@04))
    (as None<option<array>>  option<array>))))
(pop) ; 5
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@184@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@181@04))
    (as None<option<array>>  option<array>))))
(push) ; 5
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 6
(assert (not (<
  j@182@04
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@184@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@181@04)))))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               26631
;  :arith-add-rows          10659
;  :arith-assert-diseq      406
;  :arith-assert-lower      5786
;  :arith-assert-upper      4002
;  :arith-bound-prop        1173
;  :arith-conflicts         152
;  :arith-eq-adapter        4070
;  :arith-fixed-eqs         3546
;  :arith-offset-eqs        2236
;  :arith-pivots            3519
;  :conflicts               641
;  :datatype-accessor-ax    61
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1475
;  :del-clause              64398
;  :final-checks            5
;  :max-generation          11
;  :max-memory              8.81
;  :memory                  8.74
;  :minimized-lits          39
;  :mk-bool-var             76134
;  :mk-clause               64918
;  :num-allocs              534628
;  :num-checks              161
;  :propagations            18812
;  :quant-instantiations    27957
;  :rlimit-count            1587203
;  :time                    0.01)
(assert (<
  j@182@04
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@184@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@181@04))))))
(pop) ; 5
; Joined path conditions
(assert (<
  j@182@04
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@184@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@181@04))))))
(pop) ; 4
(declare-fun inv@186@04 ($Ref) Int)
(declare-fun inv@187@04 ($Ref) Int)
; Nested auxiliary terms: globals
(assert ($Perm.isReadVar $k@183@04 $Perm.Write))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
      (< $Perm.No $k@20@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@184@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@184@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r))
  :qid |qp.fvfValDef144|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r)
  :pattern (($FVF.lookup_option$array$ (as sm@184@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef145|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@185@04  $FPM) r)
    (ite (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r))) $k@20@04 $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@185@04  $FPM) r))
  :qid |qp.resPrmSumDef146|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@184@04  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@185@04  $FPM) r))
  :qid |qp.resTrgDef147|)))
; Nested auxiliary terms: non-globals
(assert (forall ((i1@181@04 Int) (j@182@04 Int)) (!
  (and
    (< i1@181@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@184@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@181@04)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@181@04))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@184@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@181@04))
        (as None<option<array>>  option<array>)))
    (<
      j@182@04
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@184@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@181@04))))))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@184@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@181@04))) j@182@04))
  :qid |int-aux|)))
(push) ; 4
(assert (not (forall ((i1@181@04 Int) (j@182@04 Int)) (!
  (implies
    (and
      (and (and (< j@182@04 V@15@04) (<= 0 j@182@04)) (< i1@181@04 V@15@04))
      (<= 0 i1@181@04))
    (or (= $k@183@04 $Perm.No) (< $Perm.No $k@183@04)))
  
  ))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               26631
;  :arith-add-rows          10669
;  :arith-assert-diseq      407
;  :arith-assert-lower      5788
;  :arith-assert-upper      4003
;  :arith-bound-prop        1173
;  :arith-conflicts         152
;  :arith-eq-adapter        4071
;  :arith-fixed-eqs         3546
;  :arith-offset-eqs        2236
;  :arith-pivots            3532
;  :conflicts               642
;  :datatype-accessor-ax    61
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1475
;  :del-clause              64502
;  :final-checks            5
;  :max-generation          11
;  :max-memory              8.81
;  :memory                  8.72
;  :minimized-lits          39
;  :mk-bool-var             76147
;  :mk-clause               64920
;  :num-allocs              535660
;  :num-checks              162
;  :propagations            18813
;  :quant-instantiations    27957
;  :rlimit-count            1589562)
(declare-const sm@188@04 $FVF<Int>)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@30@04 r) V@15@04) (<= 0 (inv@30@04 r)))
        (< (inv@29@04 r) V@15@04))
      (<= 0 (inv@29@04 r)))
    (=
      ($FVF.lookup_int (as sm@188@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@188@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))))))) r))
  :qid |qp.fvfValDef148|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@33@04 r) V@15@04) (<= 0 (inv@33@04 r)))
    (=
      ($FVF.lookup_int (as sm@188@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04)))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@188@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04)))))))))))))))) r))
  :qid |qp.fvfValDef149|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04)))))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@188@04  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef150|)))
; Check receiver injectivity
(push) ; 4
(assert (not (forall ((i11@181@04 Int) (j1@182@04 Int) (i12@181@04 Int) (j2@182@04 Int)) (!
  (implies
    (and
      (and
        (and
          (and
            (and
              (and (< j1@182@04 V@15@04) (<= 0 j1@182@04))
              (< i11@181@04 V@15@04))
            (<= 0 i11@181@04))
          ($FVF.loc_int ($FVF.lookup_int (as sm@188@04  $FVF<Int>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@184@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i11@181@04))) j1@182@04)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@184@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i11@181@04))) j1@182@04)))
        (< $Perm.No $k@183@04))
      (and
        (and
          (and
            (and
              (and (< j2@182@04 V@15@04) (<= 0 j2@182@04))
              (< i12@181@04 V@15@04))
            (<= 0 i12@181@04))
          ($FVF.loc_int ($FVF.lookup_int (as sm@188@04  $FVF<Int>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@184@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i12@181@04))) j2@182@04)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@184@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i12@181@04))) j2@182@04)))
        (< $Perm.No $k@183@04))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@184@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i11@181@04))) j1@182@04)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@184@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i12@181@04))) j2@182@04)))
    (and (= i11@181@04 i12@181@04) (= j1@182@04 j2@182@04)))
  
  :qid |int-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 4
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               27120
;  :arith-add-rows          11106
;  :arith-assert-diseq      414
;  :arith-assert-lower      5884
;  :arith-assert-upper      4065
;  :arith-bound-prop        1209
;  :arith-conflicts         154
;  :arith-eq-adapter        4137
;  :arith-fixed-eqs         3603
;  :arith-offset-eqs        2297
;  :arith-pivots            3631
;  :conflicts               660
;  :datatype-accessor-ax    61
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1499
;  :del-clause              65788
;  :final-checks            5
;  :max-generation          11
;  :max-memory              8.99
;  :memory                  8.90
;  :minimized-lits          39
;  :mk-bool-var             77773
;  :mk-clause               66206
;  :num-allocs              542729
;  :num-checks              163
;  :propagations            19058
;  :quant-instantiations    28475
;  :rlimit-count            1616241
;  :time                    0.01)
; Definitional axioms for inverse functions
(assert (forall ((i1@181@04 Int) (j@182@04 Int)) (!
  (implies
    (and
      (and
        (and (and (< j@182@04 V@15@04) (<= 0 j@182@04)) (< i1@181@04 V@15@04))
        (<= 0 i1@181@04))
      (< $Perm.No $k@183@04))
    (and
      (=
        (inv@186@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@184@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@181@04))) j@182@04))
        i1@181@04)
      (=
        (inv@187@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@184@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@181@04))) j@182@04))
        j@182@04)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@184@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@181@04))) j@182@04))
  :qid |int-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and
          (and (< (inv@187@04 r) V@15@04) (<= 0 (inv@187@04 r)))
          (< (inv@186@04 r) V@15@04))
        (<= 0 (inv@186@04 r)))
      (< $Perm.No $k@183@04))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@184@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) (inv@186@04 r)))) (inv@187@04 r))
      r))
  :pattern ((inv@186@04 r))
  :pattern ((inv@187@04 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@187@04 r) V@15@04) (<= 0 (inv@187@04 r)))
        (< (inv@186@04 r) V@15@04))
      (<= 0 (inv@186@04 r)))
    ($FVF.loc_int ($FVF.lookup_int (as sm@188@04  $FVF<Int>) r) r))
  :pattern ((inv@186@04 r) (inv@187@04 r))
  )))
; Precomputing data for removing quantified permissions
(define-fun pTaken@189@04 ((r $Ref)) $Perm
  (ite
    (and
      (and
        (and (< (inv@187@04 r) V@15@04) (<= 0 (inv@187@04 r)))
        (< (inv@186@04 r) V@15@04))
      (<= 0 (inv@186@04 r)))
    ($Perm.min
      (ite
        (and
          (and
            (and (< (inv@30@04 r) V@15@04) (<= 0 (inv@30@04 r)))
            (< (inv@29@04 r) V@15@04))
          (<= 0 (inv@29@04 r)))
        $Perm.Write
        $Perm.No)
      $k@183@04)
    $Perm.No))
(define-fun pTaken@190@04 ((r $Ref)) $Perm
  (ite
    (and
      (and
        (and (< (inv@187@04 r) V@15@04) (<= 0 (inv@187@04 r)))
        (< (inv@186@04 r) V@15@04))
      (<= 0 (inv@186@04 r)))
    ($Perm.min
      (ite
        (and (< (inv@33@04 r) V@15@04) (<= 0 (inv@33@04 r)))
        $Perm.Write
        $Perm.No)
      (- $k@183@04 (pTaken@189@04 r)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Constrain original permissions $k@183@04
(assert (forall ((r $Ref)) (!
  (implies
    (not
      (=
        (ite
          (and
            (and
              (and (< (inv@30@04 r) V@15@04) (<= 0 (inv@30@04 r)))
              (< (inv@29@04 r) V@15@04))
            (<= 0 (inv@29@04 r)))
          $Perm.Write
          $Perm.No)
        $Perm.No))
    (ite
      (and
        (and
          (and (< (inv@30@04 r) V@15@04) (<= 0 (inv@30@04 r)))
          (< (inv@29@04 r) V@15@04))
        (<= 0 (inv@29@04 r)))
      (<
        (ite
          (and
            (and
              (and (< (inv@187@04 r) V@15@04) (<= 0 (inv@187@04 r)))
              (< (inv@186@04 r) V@15@04))
            (<= 0 (inv@186@04 r)))
          $k@183@04
          $Perm.No)
        $Perm.Write)
      (<
        (ite
          (and
            (and
              (and (< (inv@187@04 r) V@15@04) (<= 0 (inv@187@04 r)))
              (< (inv@186@04 r) V@15@04))
            (<= 0 (inv@186@04 r)))
          $k@183@04
          $Perm.No)
        $Perm.No)))
  :pattern ((inv@30@04 r))
  :pattern ((inv@29@04 r))
  :pattern ((inv@187@04 r))
  :pattern ((inv@186@04 r))
  :qid |qp.srp151|)))
; Intermediate check if already taken enough permissions
(set-option :timeout 500)
(push) ; 4
(assert (not (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@187@04 r) V@15@04) (<= 0 (inv@187@04 r)))
        (< (inv@186@04 r) V@15@04))
      (<= 0 (inv@186@04 r)))
    (= (- $k@183@04 (pTaken@189@04 r)) $Perm.No))
  
  ))))
(check-sat)
; unsat
(pop) ; 4
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               28235
;  :arith-add-rows          11751
;  :arith-assert-diseq      433
;  :arith-assert-lower      6125
;  :arith-assert-upper      4240
;  :arith-bound-prop        1250
;  :arith-conflicts         161
;  :arith-eq-adapter        4326
;  :arith-fixed-eqs         3759
;  :arith-offset-eqs        2374
;  :arith-pivots            3803
;  :conflicts               683
;  :datatype-accessor-ax    61
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1557
;  :del-clause              68695
;  :final-checks            5
;  :max-generation          11
;  :max-memory              9.08
;  :memory                  8.97
;  :minimized-lits          40
;  :mk-bool-var             80956
;  :mk-clause               69126
;  :num-allocs              555738
;  :num-checks              165
;  :propagations            19719
;  :quant-instantiations    29639
;  :rlimit-count            1670682
;  :time                    0.01)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@191@04 $FVF<Int>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (iff
    (Set_in r ($FVF.domain_int (as sm@191@04  $FVF<Int>)))
    (and
      (and
        (and
          (and (< (inv@187@04 r) V@15@04) (<= 0 (inv@187@04 r)))
          (< (inv@186@04 r) V@15@04))
        (<= 0 (inv@186@04 r)))
      (< $Perm.No $k@183@04)))
  :pattern ((Set_in r ($FVF.domain_int (as sm@191@04  $FVF<Int>))))
  :qid |qp.fvfDomDef155|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and
          (and
            (and (< (inv@187@04 r) V@15@04) (<= 0 (inv@187@04 r)))
            (< (inv@186@04 r) V@15@04))
          (<= 0 (inv@186@04 r)))
        (< $Perm.No $k@183@04))
      (and
        (and
          (and (< (inv@30@04 r) V@15@04) (<= 0 (inv@30@04 r)))
          (< (inv@29@04 r) V@15@04))
        (<= 0 (inv@29@04 r))))
    (=
      ($FVF.lookup_int (as sm@191@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@191@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))))))) r))
  :qid |qp.fvfValDef152|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and
          (and
            (and (< (inv@187@04 r) V@15@04) (<= 0 (inv@187@04 r)))
            (< (inv@186@04 r) V@15@04))
          (<= 0 (inv@186@04 r)))
        (< $Perm.No $k@183@04))
      (and (< (inv@33@04 r) V@15@04) (<= 0 (inv@33@04 r))))
    (=
      ($FVF.lookup_int (as sm@191@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04)))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@191@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04)))))))))))))))) r))
  :qid |qp.fvfValDef153|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04)))))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@191@04  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef154|)))
(pop) ; 3
; Joined path conditions
(assert ($Perm.isReadVar $k@164@04 $Perm.Write))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
      (< $Perm.No $k@20@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@166@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@166@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r))
  :qid |qp.fvfValDef122|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r)
  :pattern (($FVF.lookup_option$array$ (as sm@166@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef123|)))
(assert (forall ((i1@163@04 Int)) (!
  (implies
    (and (and (< i1@163@04 V@15@04) (<= 0 i1@163@04)) (< $Perm.No $k@164@04))
    (=
      (inv@165@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@163@04))
      i1@163@04))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@163@04))
  :qid |option$array$-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and (< (inv@165@04 r) V@15@04) (<= 0 (inv@165@04 r)))
      (< $Perm.No $k@164@04))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) (inv@165@04 r))
      r))
  :pattern ((inv@165@04 r))
  :qid |option$array$-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (iff
    (Set_in r ($FVF.domain_option$array$ (as sm@168@04  $FVF<option<array>>)))
    (and
      (and (< (inv@165@04 r) V@15@04) (<= 0 (inv@165@04 r)))
      (< $Perm.No $k@164@04)))
  :pattern ((Set_in r ($FVF.domain_option$array$ (as sm@168@04  $FVF<option<array>>))))
  :qid |qp.fvfDomDef127|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@165@04 r) V@15@04) (<= 0 (inv@165@04 r)))
        (< $Perm.No $k@164@04))
      (ite
        (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
        (< $Perm.No $k@20@04)
        false))
    (=
      ($FVF.lookup_option$array$ (as sm@168@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@168@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r))
  :qid |qp.fvfValDef125|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r)
  :pattern (($FVF.lookup_option$array$ (as sm@168@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef126|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
      (< $Perm.No $k@20@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@170@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@170@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r))
  :qid |qp.fvfValDef128|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r)
  :pattern (($FVF.lookup_option$array$ (as sm@170@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef129|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@171@04  $FPM) r)
    (ite (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r))) $k@20@04 $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@171@04  $FPM) r))
  :qid |qp.resPrmSumDef130|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@170@04  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@171@04  $FPM) r))
  :qid |qp.resTrgDef131|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
      (< $Perm.No $k@20@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@173@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@173@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r))
  :qid |qp.fvfValDef132|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r)
  :pattern (($FVF.lookup_option$array$ (as sm@173@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef133|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@174@04  $FPM) r)
    (ite (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r))) $k@20@04 $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@174@04  $FPM) r))
  :qid |qp.resPrmSumDef134|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@173@04  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@174@04  $FPM) r))
  :qid |qp.resTrgDef135|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
      (< $Perm.No $k@20@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@177@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@177@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r))
  :qid |qp.fvfValDef136|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r)
  :pattern (($FVF.lookup_option$array$ (as sm@177@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef137|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@178@04  $FPM) r)
    (ite (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r))) $k@20@04 $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@178@04  $FPM) r))
  :qid |qp.resPrmSumDef138|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@177@04  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@178@04  $FPM) r))
  :qid |qp.resTrgDef139|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
      (< $Perm.No $k@20@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@179@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@179@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r))
  :qid |qp.fvfValDef140|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r)
  :pattern (($FVF.lookup_option$array$ (as sm@179@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef141|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@180@04  $FPM) r)
    (ite (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r))) $k@20@04 $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@180@04  $FPM) r))
  :qid |qp.resPrmSumDef142|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@179@04  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@180@04  $FPM) r))
  :qid |qp.resTrgDef143|)))
(assert ($Perm.isReadVar $k@183@04 $Perm.Write))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
      (< $Perm.No $k@20@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@184@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@184@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r))
  :qid |qp.fvfValDef144|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r)
  :pattern (($FVF.lookup_option$array$ (as sm@184@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef145|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@185@04  $FPM) r)
    (ite (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r))) $k@20@04 $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@185@04  $FPM) r))
  :qid |qp.resPrmSumDef146|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@184@04  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@185@04  $FPM) r))
  :qid |qp.resTrgDef147|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@30@04 r) V@15@04) (<= 0 (inv@30@04 r)))
        (< (inv@29@04 r) V@15@04))
      (<= 0 (inv@29@04 r)))
    (=
      ($FVF.lookup_int (as sm@188@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@188@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))))))) r))
  :qid |qp.fvfValDef148|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@33@04 r) V@15@04) (<= 0 (inv@33@04 r)))
    (=
      ($FVF.lookup_int (as sm@188@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04)))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@188@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04)))))))))))))))) r))
  :qid |qp.fvfValDef149|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04)))))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@188@04  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef150|)))
(assert (forall ((i1@181@04 Int) (j@182@04 Int)) (!
  (implies
    (and
      (and
        (and (and (< j@182@04 V@15@04) (<= 0 j@182@04)) (< i1@181@04 V@15@04))
        (<= 0 i1@181@04))
      (< $Perm.No $k@183@04))
    (and
      (=
        (inv@186@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@184@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@181@04))) j@182@04))
        i1@181@04)
      (=
        (inv@187@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@184@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@181@04))) j@182@04))
        j@182@04)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@184@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@181@04))) j@182@04))
  :qid |int-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and
          (and (< (inv@187@04 r) V@15@04) (<= 0 (inv@187@04 r)))
          (< (inv@186@04 r) V@15@04))
        (<= 0 (inv@186@04 r)))
      (< $Perm.No $k@183@04))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@184@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) (inv@186@04 r)))) (inv@187@04 r))
      r))
  :pattern ((inv@186@04 r))
  :pattern ((inv@187@04 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (iff
    (Set_in r ($FVF.domain_int (as sm@191@04  $FVF<Int>)))
    (and
      (and
        (and
          (and (< (inv@187@04 r) V@15@04) (<= 0 (inv@187@04 r)))
          (< (inv@186@04 r) V@15@04))
        (<= 0 (inv@186@04 r)))
      (< $Perm.No $k@183@04)))
  :pattern ((Set_in r ($FVF.domain_int (as sm@191@04  $FVF<Int>))))
  :qid |qp.fvfDomDef155|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and
          (and
            (and (< (inv@187@04 r) V@15@04) (<= 0 (inv@187@04 r)))
            (< (inv@186@04 r) V@15@04))
          (<= 0 (inv@186@04 r)))
        (< $Perm.No $k@183@04))
      (and
        (and
          (and (< (inv@30@04 r) V@15@04) (<= 0 (inv@30@04 r)))
          (< (inv@29@04 r) V@15@04))
        (<= 0 (inv@29@04 r))))
    (=
      ($FVF.lookup_int (as sm@191@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@191@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))))))) r))
  :qid |qp.fvfValDef152|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and
          (and
            (and (< (inv@187@04 r) V@15@04) (<= 0 (inv@187@04 r)))
            (< (inv@186@04 r) V@15@04))
          (<= 0 (inv@186@04 r)))
        (< $Perm.No $k@183@04))
      (and (< (inv@33@04 r) V@15@04) (<= 0 (inv@33@04 r))))
    (=
      ($FVF.lookup_int (as sm@191@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04)))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@191@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04)))))))))))))))) r))
  :qid |qp.fvfValDef153|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04)))))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@191@04  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef154|)))
(assert (and
  (forall ((i1@163@04 Int)) (!
    (< i1@163@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
    :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@163@04))
    :qid |option$array$-aux|))
  (forall ((r $Ref)) (!
    (implies
      (and (< (inv@165@04 r) V@15@04) (<= 0 (inv@165@04 r)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@166@04  $FVF<option<array>>) r) r))
    :pattern ((inv@165@04 r))
    ))
  (forall ((r $Ref)) (!
    (implies
      (not
        (=
          (ite
            (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
            $k@20@04
            $Perm.No)
          $Perm.No))
      (ite
        (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
        (<
          (ite
            (and (< (inv@165@04 r) V@15@04) (<= 0 (inv@165@04 r)))
            $k@164@04
            $Perm.No)
          $k@20@04)
        (<
          (ite
            (and (< (inv@165@04 r) V@15@04) (<= 0 (inv@165@04 r)))
            $k@164@04
            $Perm.No)
          $Perm.No)))
    :pattern ((inv@21@04 r))
    :pattern ((inv@165@04 r))
    :qid |qp.srp124|))
  (forall ((i1@169@04 Int)) (!
    (implies
      (and (< i1@169@04 V@15@04) (<= 0 i1@169@04))
      (not
        (=
          ($FVF.lookup_option$array$ (as sm@170@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@169@04))
          (as None<option<array>>  option<array>))))
    
    :qid |prog.l<no position>|))
  (forall ((i1@172@04 Int)) (!
    (implies
      (and (< i1@172@04 V@15@04) (<= 0 i1@172@04))
      (=
        (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@173@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@172@04))))
        V@15@04))
    
    :qid |prog.l<no position>|))
  (forall ((i1@175@04 Int)) (!
    (forall ((i2@176@04 Int)) (!
      (implies
        (and
          (and
            (and
              (and
                (=
                  ($FVF.lookup_option$array$ (as sm@177@04  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@175@04))
                  ($FVF.lookup_option$array$ (as sm@179@04  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@176@04)))
                (< i2@176@04 V@15@04))
              (<= 0 i2@176@04))
            (< i1@175@04 V@15@04))
          (<= 0 i1@175@04))
        (= i1@175@04 i2@176@04))
      :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@176@04))
      :qid |prog.l<no position>|))
    
    :qid |prog.l<no position>|))
  (forall ((i1@181@04 Int) (j@182@04 Int)) (!
    (and
      (< i1@181@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@184@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@181@04)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@181@04))
      (not
        (=
          ($FVF.lookup_option$array$ (as sm@184@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@181@04))
          (as None<option<array>>  option<array>)))
      (<
        j@182@04
        (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@184@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@181@04))))))
    :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@184@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@181@04))) j@182@04))
    :qid |int-aux|))
  (forall ((r $Ref)) (!
    (implies
      (and
        (and
          (and (< (inv@187@04 r) V@15@04) (<= 0 (inv@187@04 r)))
          (< (inv@186@04 r) V@15@04))
        (<= 0 (inv@186@04 r)))
      ($FVF.loc_int ($FVF.lookup_int (as sm@188@04  $FVF<Int>) r) r))
    :pattern ((inv@186@04 r) (inv@187@04 r))
    ))
  (forall ((r $Ref)) (!
    (implies
      (not
        (=
          (ite
            (and
              (and
                (and (< (inv@30@04 r) V@15@04) (<= 0 (inv@30@04 r)))
                (< (inv@29@04 r) V@15@04))
              (<= 0 (inv@29@04 r)))
            $Perm.Write
            $Perm.No)
          $Perm.No))
      (ite
        (and
          (and
            (and (< (inv@30@04 r) V@15@04) (<= 0 (inv@30@04 r)))
            (< (inv@29@04 r) V@15@04))
          (<= 0 (inv@29@04 r)))
        (<
          (ite
            (and
              (and
                (and (< (inv@187@04 r) V@15@04) (<= 0 (inv@187@04 r)))
                (< (inv@186@04 r) V@15@04))
              (<= 0 (inv@186@04 r)))
            $k@183@04
            $Perm.No)
          $Perm.Write)
        (<
          (ite
            (and
              (and
                (and (< (inv@187@04 r) V@15@04) (<= 0 (inv@187@04 r)))
                (< (inv@186@04 r) V@15@04))
              (<= 0 (inv@186@04 r)))
            $k@183@04
            $Perm.No)
          $Perm.No)))
    :pattern ((inv@30@04 r))
    :pattern ((inv@29@04 r))
    :pattern ((inv@187@04 r))
    :pattern ((inv@186@04 r))
    :qid |qp.srp151|))))
(declare-const Gf_seq@192@04 Seq<Seq<Int>>)
(assert (Seq_equal
  Gf_seq@192@04
  (matrixValues ($Snap.combine
    $Snap.unit
    ($Snap.combine
      $Snap.unit
      ($Snap.combine
        $Snap.unit
        ($Snap.combine
          ($SortWrappers.$FVF<option<array>>To$Snap (as sm@168@04  $FVF<option<array>>))
          ($Snap.combine
            $Snap.unit
            ($Snap.combine
              $Snap.unit
              ($Snap.combine
                $Snap.unit
                ($SortWrappers.$FVF<Int>To$Snap (as sm@191@04  $FVF<Int>))))))))) this@9@04 G@11@04 V@15@04)))
; [exec]
; P_seq := unknown(P, 0, alen(opt_get1(P)))
; [eval] unknown(P, 0, alen(opt_get1(P)))
; [eval] alen(opt_get1(P))
; [eval] opt_get1(P)
(push) ; 3
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 3
; Joined path conditions
(push) ; 3
; [eval] a2 != (None(): option[array])
; [eval] (None(): option[array])
; [eval] 0 <= from
; [eval] from <= to
(set-option :timeout 0)
(push) ; 4
(assert (not (<= 0 (alen<Int> (opt_get1 $Snap.unit P@14@04)))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               28274
;  :arith-add-rows          11870
;  :arith-assert-diseq      435
;  :arith-assert-lower      6132
;  :arith-assert-upper      4245
;  :arith-bound-prop        1250
;  :arith-conflicts         162
;  :arith-eq-adapter        4332
;  :arith-fixed-eqs         3761
;  :arith-offset-eqs        2374
;  :arith-pivots            3828
;  :conflicts               684
;  :datatype-accessor-ax    68
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1557
;  :del-clause              68743
;  :final-checks            5
;  :max-generation          11
;  :max-memory              9.08
;  :memory                  8.95
;  :minimized-lits          40
;  :mk-bool-var             81145
;  :mk-clause               69246
;  :num-allocs              563383
;  :num-checks              166
;  :propagations            19739
;  :quant-instantiations    29663
;  :rlimit-count            1693345)
(assert (<= 0 (alen<Int> (opt_get1 $Snap.unit P@14@04))))
; [eval] to <= alen(opt_get1(a2))
; [eval] alen(opt_get1(a2))
; [eval] opt_get1(a2)
(push) ; 4
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 4
; Joined path conditions
(declare-const i1@193@04 Int)
(push) ; 4
; [eval] from <= i1 && i1 < to
; [eval] from <= i1
(push) ; 5
; [then-branch: 98 | 0 <= i1@193@04 | live]
; [else-branch: 98 | !(0 <= i1@193@04) | live]
(push) ; 6
; [then-branch: 98 | 0 <= i1@193@04]
(assert (<= 0 i1@193@04))
; [eval] i1 < to
(pop) ; 6
(push) ; 6
; [else-branch: 98 | !(0 <= i1@193@04)]
(assert (not (<= 0 i1@193@04)))
(pop) ; 6
(pop) ; 5
; Joined path conditions
; Joined path conditions
(assert (and (< i1@193@04 (alen<Int> (opt_get1 $Snap.unit P@14@04))) (<= 0 i1@193@04)))
(declare-const $k@194@04 $Perm)
(assert ($Perm.isReadVar $k@194@04 $Perm.Write))
; [eval] aloc(opt_get1(a2), i1)
; [eval] opt_get1(a2)
(push) ; 5
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 5
; Joined path conditions
(push) ; 5
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(pop) ; 5
; Joined path conditions
(pop) ; 4
(declare-fun inv@195@04 ($Ref) Int)
; Nested auxiliary terms: globals
(assert ($Perm.isReadVar $k@194@04 $Perm.Write))
; Nested auxiliary terms: non-globals
(push) ; 4
(assert (not (forall ((i1@193@04 Int)) (!
  (implies
    (and
      (< i1@193@04 (alen<Int> (opt_get1 $Snap.unit P@14@04)))
      (<= 0 i1@193@04))
    (or (= $k@194@04 $Perm.No) (< $Perm.No $k@194@04)))
  
  ))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               28274
;  :arith-add-rows          11870
;  :arith-assert-diseq      437
;  :arith-assert-lower      6139
;  :arith-assert-upper      4247
;  :arith-bound-prop        1250
;  :arith-conflicts         162
;  :arith-eq-adapter        4334
;  :arith-fixed-eqs         3761
;  :arith-offset-eqs        2374
;  :arith-pivots            3828
;  :conflicts               685
;  :datatype-accessor-ax    68
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1557
;  :del-clause              68745
;  :final-checks            5
;  :max-generation          11
;  :max-memory              9.08
;  :memory                  8.95
;  :minimized-lits          40
;  :mk-bool-var             81158
;  :mk-clause               69250
;  :num-allocs              563898
;  :num-checks              167
;  :propagations            19741
;  :quant-instantiations    29663
;  :rlimit-count            1694046)
(declare-const sm@196@04 $FVF<Int>)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@33@04 r) V@15@04) (<= 0 (inv@33@04 r)))
    (=
      ($FVF.lookup_int (as sm@196@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04)))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@196@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04)))))))))))))))) r))
  :qid |qp.fvfValDef156|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@30@04 r) V@15@04) (<= 0 (inv@30@04 r)))
        (< (inv@29@04 r) V@15@04))
      (<= 0 (inv@29@04 r)))
    (=
      ($FVF.lookup_int (as sm@196@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@196@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))))))) r))
  :qid |qp.fvfValDef157|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04)))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@196@04  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef158|)))
; Check receiver injectivity
(push) ; 4
(assert (not (forall ((i11@193@04 Int) (i12@193@04 Int)) (!
  (implies
    (and
      (and
        (and
          (and
            (< i11@193@04 (alen<Int> (opt_get1 $Snap.unit P@14@04)))
            (<= 0 i11@193@04))
          ($FVF.loc_int ($FVF.lookup_int (as sm@196@04  $FVF<Int>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit P@14@04) i11@193@04)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit P@14@04) i11@193@04)))
        (< $Perm.No $k@194@04))
      (and
        (and
          (and
            (< i12@193@04 (alen<Int> (opt_get1 $Snap.unit P@14@04)))
            (<= 0 i12@193@04))
          ($FVF.loc_int ($FVF.lookup_int (as sm@196@04  $FVF<Int>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit P@14@04) i12@193@04)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit P@14@04) i12@193@04)))
        (< $Perm.No $k@194@04))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i11@193@04)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i12@193@04)))
    (= i11@193@04 i12@193@04))
  
  :qid |int-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               28288
;  :arith-add-rows          11874
;  :arith-assert-diseq      438
;  :arith-assert-lower      6143
;  :arith-assert-upper      4247
;  :arith-bound-prop        1250
;  :arith-conflicts         162
;  :arith-eq-adapter        4335
;  :arith-fixed-eqs         3761
;  :arith-offset-eqs        2374
;  :arith-pivots            3830
;  :conflicts               686
;  :datatype-accessor-ax    68
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1557
;  :del-clause              68756
;  :final-checks            5
;  :max-generation          11
;  :max-memory              9.08
;  :memory                  8.96
;  :minimized-lits          40
;  :mk-bool-var             81196
;  :mk-clause               69261
;  :num-allocs              564866
;  :num-checks              168
;  :propagations            19743
;  :quant-instantiations    29681
;  :rlimit-count            1696779)
; Definitional axioms for inverse functions
(assert (forall ((i1@193@04 Int)) (!
  (implies
    (and
      (and
        (< i1@193@04 (alen<Int> (opt_get1 $Snap.unit P@14@04)))
        (<= 0 i1@193@04))
      (< $Perm.No $k@194@04))
    (=
      (inv@195@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i1@193@04))
      i1@193@04))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i1@193@04))
  :qid |int-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (< (inv@195@04 r) (alen<Int> (opt_get1 $Snap.unit P@14@04)))
        (<= 0 (inv@195@04 r)))
      (< $Perm.No $k@194@04))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) (inv@195@04 r))
      r))
  :pattern ((inv@195@04 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (< (inv@195@04 r) (alen<Int> (opt_get1 $Snap.unit P@14@04)))
      (<= 0 (inv@195@04 r)))
    ($FVF.loc_int ($FVF.lookup_int (as sm@196@04  $FVF<Int>) r) r))
  :pattern ((inv@195@04 r))
  )))
; Precomputing data for removing quantified permissions
(define-fun pTaken@197@04 ((r $Ref)) $Perm
  (ite
    (and
      (< (inv@195@04 r) (alen<Int> (opt_get1 $Snap.unit P@14@04)))
      (<= 0 (inv@195@04 r)))
    ($Perm.min
      (ite
        (and (< (inv@33@04 r) V@15@04) (<= 0 (inv@33@04 r)))
        $Perm.Write
        $Perm.No)
      $k@194@04)
    $Perm.No))
(define-fun pTaken@198@04 ((r $Ref)) $Perm
  (ite
    (and
      (< (inv@195@04 r) (alen<Int> (opt_get1 $Snap.unit P@14@04)))
      (<= 0 (inv@195@04 r)))
    ($Perm.min
      (ite
        (and
          (and
            (and (< (inv@30@04 r) V@15@04) (<= 0 (inv@30@04 r)))
            (< (inv@29@04 r) V@15@04))
          (<= 0 (inv@29@04 r)))
        $Perm.Write
        $Perm.No)
      (- $k@194@04 (pTaken@197@04 r)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Constrain original permissions $k@194@04
(assert (forall ((r $Ref)) (!
  (implies
    (not
      (=
        (ite
          (and (< (inv@33@04 r) V@15@04) (<= 0 (inv@33@04 r)))
          $Perm.Write
          $Perm.No)
        $Perm.No))
    (ite
      (and (< (inv@33@04 r) V@15@04) (<= 0 (inv@33@04 r)))
      (<
        (ite
          (and
            (< (inv@195@04 r) (alen<Int> (opt_get1 $Snap.unit P@14@04)))
            (<= 0 (inv@195@04 r)))
          $k@194@04
          $Perm.No)
        $Perm.Write)
      (<
        (ite
          (and
            (< (inv@195@04 r) (alen<Int> (opt_get1 $Snap.unit P@14@04)))
            (<= 0 (inv@195@04 r)))
          $k@194@04
          $Perm.No)
        $Perm.No)))
  :pattern ((inv@33@04 r))
  :pattern ((inv@195@04 r))
  :qid |qp.srp159|)))
; Intermediate check if already taken enough permissions
(set-option :timeout 500)
(push) ; 4
(assert (not (forall ((r $Ref)) (!
  (implies
    (and
      (< (inv@195@04 r) (alen<Int> (opt_get1 $Snap.unit P@14@04)))
      (<= 0 (inv@195@04 r)))
    (= (- $k@194@04 (pTaken@197@04 r)) $Perm.No))
  
  ))))
(check-sat)
; unsat
(pop) ; 4
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               29331
;  :arith-add-rows          12132
;  :arith-assert-diseq      459
;  :arith-assert-lower      6349
;  :arith-assert-upper      4379
;  :arith-bound-prop        1289
;  :arith-conflicts         164
;  :arith-eq-adapter        4515
;  :arith-fixed-eqs         3883
;  :arith-offset-eqs        2450
;  :arith-pivots            4002
;  :conflicts               708
;  :datatype-accessor-ax    68
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1641
;  :del-clause              72554
;  :final-checks            5
;  :max-generation          11
;  :max-memory              9.43
;  :memory                  9.30
;  :minimized-lits          43
;  :mk-bool-var             85234
;  :mk-clause               73080
;  :num-allocs              581006
;  :num-checks              170
;  :propagations            20409
;  :quant-instantiations    31071
;  :rlimit-count            1757460
;  :time                    0.01)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@199@04 $FVF<Int>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (iff
    (Set_in r ($FVF.domain_int (as sm@199@04  $FVF<Int>)))
    (and
      (and
        (< (inv@195@04 r) (alen<Int> (opt_get1 $Snap.unit P@14@04)))
        (<= 0 (inv@195@04 r)))
      (< $Perm.No $k@194@04)))
  :pattern ((Set_in r ($FVF.domain_int (as sm@199@04  $FVF<Int>))))
  :qid |qp.fvfDomDef163|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and
          (< (inv@195@04 r) (alen<Int> (opt_get1 $Snap.unit P@14@04)))
          (<= 0 (inv@195@04 r)))
        (< $Perm.No $k@194@04))
      (and (< (inv@33@04 r) V@15@04) (<= 0 (inv@33@04 r))))
    (=
      ($FVF.lookup_int (as sm@199@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04)))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@199@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04)))))))))))))))) r))
  :qid |qp.fvfValDef160|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and
          (< (inv@195@04 r) (alen<Int> (opt_get1 $Snap.unit P@14@04)))
          (<= 0 (inv@195@04 r)))
        (< $Perm.No $k@194@04))
      (and
        (and
          (and (< (inv@30@04 r) V@15@04) (<= 0 (inv@30@04 r)))
          (< (inv@29@04 r) V@15@04))
        (<= 0 (inv@29@04 r))))
    (=
      ($FVF.lookup_int (as sm@199@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@199@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))))))) r))
  :qid |qp.fvfValDef161|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04)))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@199@04  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef162|)))
(pop) ; 3
; Joined path conditions
(assert ($Perm.isReadVar $k@194@04 $Perm.Write))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@33@04 r) V@15@04) (<= 0 (inv@33@04 r)))
    (=
      ($FVF.lookup_int (as sm@196@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04)))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@196@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04)))))))))))))))) r))
  :qid |qp.fvfValDef156|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@30@04 r) V@15@04) (<= 0 (inv@30@04 r)))
        (< (inv@29@04 r) V@15@04))
      (<= 0 (inv@29@04 r)))
    (=
      ($FVF.lookup_int (as sm@196@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@196@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))))))) r))
  :qid |qp.fvfValDef157|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04)))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@196@04  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef158|)))
(assert (forall ((i1@193@04 Int)) (!
  (implies
    (and
      (and
        (< i1@193@04 (alen<Int> (opt_get1 $Snap.unit P@14@04)))
        (<= 0 i1@193@04))
      (< $Perm.No $k@194@04))
    (=
      (inv@195@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i1@193@04))
      i1@193@04))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i1@193@04))
  :qid |int-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (< (inv@195@04 r) (alen<Int> (opt_get1 $Snap.unit P@14@04)))
        (<= 0 (inv@195@04 r)))
      (< $Perm.No $k@194@04))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) (inv@195@04 r))
      r))
  :pattern ((inv@195@04 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (iff
    (Set_in r ($FVF.domain_int (as sm@199@04  $FVF<Int>)))
    (and
      (and
        (< (inv@195@04 r) (alen<Int> (opt_get1 $Snap.unit P@14@04)))
        (<= 0 (inv@195@04 r)))
      (< $Perm.No $k@194@04)))
  :pattern ((Set_in r ($FVF.domain_int (as sm@199@04  $FVF<Int>))))
  :qid |qp.fvfDomDef163|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and
          (< (inv@195@04 r) (alen<Int> (opt_get1 $Snap.unit P@14@04)))
          (<= 0 (inv@195@04 r)))
        (< $Perm.No $k@194@04))
      (and (< (inv@33@04 r) V@15@04) (<= 0 (inv@33@04 r))))
    (=
      ($FVF.lookup_int (as sm@199@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04)))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@199@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04)))))))))))))))) r))
  :qid |qp.fvfValDef160|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and
          (< (inv@195@04 r) (alen<Int> (opt_get1 $Snap.unit P@14@04)))
          (<= 0 (inv@195@04 r)))
        (< $Perm.No $k@194@04))
      (and
        (and
          (and (< (inv@30@04 r) V@15@04) (<= 0 (inv@30@04 r)))
          (< (inv@29@04 r) V@15@04))
        (<= 0 (inv@29@04 r))))
    (=
      ($FVF.lookup_int (as sm@199@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@199@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))))))) r))
  :qid |qp.fvfValDef161|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04)))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@199@04  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef162|)))
(assert (and
  (<= 0 (alen<Int> (opt_get1 $Snap.unit P@14@04)))
  (forall ((r $Ref)) (!
    (implies
      (and
        (< (inv@195@04 r) (alen<Int> (opt_get1 $Snap.unit P@14@04)))
        (<= 0 (inv@195@04 r)))
      ($FVF.loc_int ($FVF.lookup_int (as sm@196@04  $FVF<Int>) r) r))
    :pattern ((inv@195@04 r))
    ))
  (forall ((r $Ref)) (!
    (implies
      (not
        (=
          (ite
            (and (< (inv@33@04 r) V@15@04) (<= 0 (inv@33@04 r)))
            $Perm.Write
            $Perm.No)
          $Perm.No))
      (ite
        (and (< (inv@33@04 r) V@15@04) (<= 0 (inv@33@04 r)))
        (<
          (ite
            (and
              (< (inv@195@04 r) (alen<Int> (opt_get1 $Snap.unit P@14@04)))
              (<= 0 (inv@195@04 r)))
            $k@194@04
            $Perm.No)
          $Perm.Write)
        (<
          (ite
            (and
              (< (inv@195@04 r) (alen<Int> (opt_get1 $Snap.unit P@14@04)))
              (<= 0 (inv@195@04 r)))
            $k@194@04
            $Perm.No)
          $Perm.No)))
    :pattern ((inv@33@04 r))
    :pattern ((inv@195@04 r))
    :qid |qp.srp159|))))
(declare-const P_seq@200@04 Seq<Int>)
(assert (Seq_equal
  P_seq@200@04
  (unknown_ ($Snap.combine
    $Snap.unit
    ($Snap.combine
      $Snap.unit
      ($Snap.combine
        $Snap.unit
        ($Snap.combine
          $Snap.unit
          ($SortWrappers.$FVF<Int>To$Snap (as sm@199@04  $FVF<Int>)))))) P@14@04 0 (alen<Int> (opt_get1 $Snap.unit P@14@04)))))
; [exec]
; assert FlowNetwork1(this, G, V, s, t)
; [eval] FlowNetwork1(this, G, V, s, t)
(push) ; 3
; [eval] this != null
; [eval] G != (None(): option[array])
; [eval] (None(): option[array])
; [eval] alen(opt_get1(G)) == V
; [eval] alen(opt_get1(G))
; [eval] opt_get1(G)
(push) ; 4
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 4
; Joined path conditions
(declare-const i1@201@04 Int)
(push) ; 4
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 5
; [then-branch: 99 | 0 <= i1@201@04 | live]
; [else-branch: 99 | !(0 <= i1@201@04) | live]
(push) ; 6
; [then-branch: 99 | 0 <= i1@201@04]
(assert (<= 0 i1@201@04))
; [eval] i1 < V
(pop) ; 6
(push) ; 6
; [else-branch: 99 | !(0 <= i1@201@04)]
(assert (not (<= 0 i1@201@04)))
(pop) ; 6
(pop) ; 5
; Joined path conditions
; Joined path conditions
(assert (and (< i1@201@04 V@15@04) (<= 0 i1@201@04)))
(declare-const $k@202@04 $Perm)
(assert ($Perm.isReadVar $k@202@04 $Perm.Write))
; [eval] aloc(opt_get1(G), i1)
; [eval] opt_get1(G)
(push) ; 5
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 5
; Joined path conditions
(push) ; 5
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 6
(assert (not (< i1@201@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               29364
;  :arith-add-rows          12142
;  :arith-assert-diseq      462
;  :arith-assert-lower      6362
;  :arith-assert-upper      4385
;  :arith-bound-prop        1289
;  :arith-conflicts         164
;  :arith-eq-adapter        4523
;  :arith-fixed-eqs         3885
;  :arith-offset-eqs        2452
;  :arith-pivots            4021
;  :conflicts               708
;  :datatype-accessor-ax    72
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1641
;  :del-clause              72577
;  :final-checks            5
;  :max-generation          11
;  :max-memory              9.43
;  :memory                  9.30
;  :minimized-lits          43
;  :mk-bool-var             85361
;  :mk-clause               73172
;  :num-allocs              583736
;  :num-checks              171
;  :propagations            20436
;  :quant-instantiations    31091
;  :rlimit-count            1765461)
(assert (< i1@201@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(pop) ; 5
; Joined path conditions
(assert (< i1@201@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(pop) ; 4
(declare-fun inv@203@04 ($Ref) Int)
; Nested auxiliary terms: globals
(assert ($Perm.isReadVar $k@202@04 $Perm.Write))
; Nested auxiliary terms: non-globals
(assert (forall ((i1@201@04 Int)) (!
  (< i1@201@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@201@04))
  :qid |option$array$-aux|)))
(push) ; 4
(assert (not (forall ((i1@201@04 Int)) (!
  (implies
    (and (< i1@201@04 V@15@04) (<= 0 i1@201@04))
    (or (= $k@202@04 $Perm.No) (< $Perm.No $k@202@04)))
  
  ))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               29364
;  :arith-add-rows          12142
;  :arith-assert-diseq      463
;  :arith-assert-lower      6364
;  :arith-assert-upper      4386
;  :arith-bound-prop        1289
;  :arith-conflicts         164
;  :arith-eq-adapter        4524
;  :arith-fixed-eqs         3885
;  :arith-offset-eqs        2452
;  :arith-pivots            4022
;  :conflicts               709
;  :datatype-accessor-ax    72
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1641
;  :del-clause              72579
;  :final-checks            5
;  :max-generation          11
;  :max-memory              9.43
;  :memory                  9.30
;  :minimized-lits          43
;  :mk-bool-var             85368
;  :mk-clause               73174
;  :num-allocs              584165
;  :num-checks              172
;  :propagations            20437
;  :quant-instantiations    31091
;  :rlimit-count            1766009)
(declare-const sm@204@04 $FVF<option<array>>)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
      (< $Perm.No $k@20@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@204@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@204@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r))
  :qid |qp.fvfValDef164|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r)
  :pattern (($FVF.lookup_option$array$ (as sm@204@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef165|)))
; Check receiver injectivity
(push) ; 4
(assert (not (forall ((i11@201@04 Int) (i12@201@04 Int)) (!
  (implies
    (and
      (and
        (and
          (and (< i11@201@04 V@15@04) (<= 0 i11@201@04))
          ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@204@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i11@201@04)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i11@201@04)))
        (< $Perm.No $k@202@04))
      (and
        (and
          (and (< i12@201@04 V@15@04) (<= 0 i12@201@04))
          ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@204@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i12@201@04)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i12@201@04)))
        (< $Perm.No $k@202@04))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i11@201@04)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i12@201@04)))
    (= i11@201@04 i12@201@04))
  
  :qid |option$array$-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               29393
;  :arith-add-rows          12146
;  :arith-assert-diseq      464
;  :arith-assert-lower      6368
;  :arith-assert-upper      4386
;  :arith-bound-prop        1289
;  :arith-conflicts         164
;  :arith-eq-adapter        4525
;  :arith-fixed-eqs         3885
;  :arith-offset-eqs        2452
;  :arith-pivots            4024
;  :conflicts               710
;  :datatype-accessor-ax    72
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1641
;  :del-clause              72586
;  :final-checks            5
;  :max-generation          11
;  :max-memory              9.43
;  :memory                  9.30
;  :minimized-lits          43
;  :mk-bool-var             85422
;  :mk-clause               73181
;  :num-allocs              585222
;  :num-checks              173
;  :propagations            20437
;  :quant-instantiations    31139
;  :rlimit-count            1768828)
; Definitional axioms for inverse functions
(assert (forall ((i1@201@04 Int)) (!
  (implies
    (and (and (< i1@201@04 V@15@04) (<= 0 i1@201@04)) (< $Perm.No $k@202@04))
    (=
      (inv@203@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@201@04))
      i1@201@04))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@201@04))
  :qid |option$array$-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and (< (inv@203@04 r) V@15@04) (<= 0 (inv@203@04 r)))
      (< $Perm.No $k@202@04))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) (inv@203@04 r))
      r))
  :pattern ((inv@203@04 r))
  :qid |option$array$-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@203@04 r) V@15@04) (<= 0 (inv@203@04 r)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@204@04  $FVF<option<array>>) r) r))
  :pattern ((inv@203@04 r))
  )))
; Precomputing data for removing quantified permissions
(define-fun pTaken@205@04 ((r $Ref)) $Perm
  (ite
    (and (< (inv@203@04 r) V@15@04) (<= 0 (inv@203@04 r)))
    ($Perm.min
      (ite
        (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
        $k@20@04
        $Perm.No)
      $k@202@04)
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Constrain original permissions $k@202@04
(assert (forall ((r $Ref)) (!
  (implies
    (not
      (=
        (ite
          (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
          $k@20@04
          $Perm.No)
        $Perm.No))
    (ite
      (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
      (<
        (ite
          (and (< (inv@203@04 r) V@15@04) (<= 0 (inv@203@04 r)))
          $k@202@04
          $Perm.No)
        $k@20@04)
      (<
        (ite
          (and (< (inv@203@04 r) V@15@04) (<= 0 (inv@203@04 r)))
          $k@202@04
          $Perm.No)
        $Perm.No)))
  :pattern ((inv@21@04 r))
  :pattern ((inv@203@04 r))
  :qid |qp.srp166|)))
; Intermediate check if already taken enough permissions
(set-option :timeout 500)
(push) ; 4
(assert (not (forall ((r $Ref)) (!
  (implies
    (and (< (inv@203@04 r) V@15@04) (<= 0 (inv@203@04 r)))
    (= (- $k@202@04 (pTaken@205@04 r)) $Perm.No))
  
  ))))
(check-sat)
; unsat
(pop) ; 4
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               30484
;  :arith-add-rows          12578
;  :arith-assert-diseq      492
;  :arith-assert-lower      6598
;  :arith-assert-upper      4534
;  :arith-bound-prop        1353
;  :arith-conflicts         166
;  :arith-eq-adapter        4728
;  :arith-fixed-eqs         4023
;  :arith-offset-eqs        2542
;  :arith-pivots            4257
;  :conflicts               731
;  :datatype-accessor-ax    72
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1744
;  :del-clause              76961
;  :final-checks            5
;  :max-generation          11
;  :max-memory              9.86
;  :memory                  9.73
;  :minimized-lits          45
;  :mk-bool-var             89748
;  :mk-clause               77590
;  :num-allocs              602642
;  :num-checks              175
;  :propagations            21151
;  :quant-instantiations    32655
;  :rlimit-count            1834677
;  :time                    0.01)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@206@04 $FVF<option<array>>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (iff
    (Set_in r ($FVF.domain_option$array$ (as sm@206@04  $FVF<option<array>>)))
    (and
      (and (< (inv@203@04 r) V@15@04) (<= 0 (inv@203@04 r)))
      (< $Perm.No $k@202@04)))
  :pattern ((Set_in r ($FVF.domain_option$array$ (as sm@206@04  $FVF<option<array>>))))
  :qid |qp.fvfDomDef169|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@203@04 r) V@15@04) (<= 0 (inv@203@04 r)))
        (< $Perm.No $k@202@04))
      (ite
        (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
        (< $Perm.No $k@20@04)
        false))
    (=
      ($FVF.lookup_option$array$ (as sm@206@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@206@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r))
  :qid |qp.fvfValDef167|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r)
  :pattern (($FVF.lookup_option$array$ (as sm@206@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef168|)))
; [eval] (forall i1: Int :: 0 <= i1 && i1 < V ==> aloc(opt_get1(G), i1).option$array$ != (None(): option[array]))
(declare-const i1@207@04 Int)
(push) ; 4
; [eval] 0 <= i1 && i1 < V ==> aloc(opt_get1(G), i1).option$array$ != (None(): option[array])
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 5
; [then-branch: 100 | 0 <= i1@207@04 | live]
; [else-branch: 100 | !(0 <= i1@207@04) | live]
(push) ; 6
; [then-branch: 100 | 0 <= i1@207@04]
(assert (<= 0 i1@207@04))
; [eval] i1 < V
(pop) ; 6
(push) ; 6
; [else-branch: 100 | !(0 <= i1@207@04)]
(assert (not (<= 0 i1@207@04)))
(pop) ; 6
(pop) ; 5
; Joined path conditions
; Joined path conditions
(push) ; 5
; [then-branch: 101 | i1@207@04 < V@15@04 && 0 <= i1@207@04 | live]
; [else-branch: 101 | !(i1@207@04 < V@15@04 && 0 <= i1@207@04) | live]
(push) ; 6
; [then-branch: 101 | i1@207@04 < V@15@04 && 0 <= i1@207@04]
(assert (and (< i1@207@04 V@15@04) (<= 0 i1@207@04)))
; [eval] aloc(opt_get1(G), i1).option$array$ != (None(): option[array])
; [eval] aloc(opt_get1(G), i1)
; [eval] opt_get1(G)
(push) ; 7
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 7
; Joined path conditions
(push) ; 7
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 8
(assert (not (< i1@207@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               30484
;  :arith-add-rows          12578
;  :arith-assert-diseq      492
;  :arith-assert-lower      6600
;  :arith-assert-upper      4534
;  :arith-bound-prop        1353
;  :arith-conflicts         166
;  :arith-eq-adapter        4728
;  :arith-fixed-eqs         4023
;  :arith-offset-eqs        2542
;  :arith-pivots            4257
;  :conflicts               731
;  :datatype-accessor-ax    72
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1744
;  :del-clause              76961
;  :final-checks            5
;  :max-generation          11
;  :max-memory              9.86
;  :memory                  9.73
;  :minimized-lits          45
;  :mk-bool-var             89753
;  :mk-clause               77590
;  :num-allocs              603240
;  :num-checks              176
;  :propagations            21151
;  :quant-instantiations    32655
;  :rlimit-count            1836021)
(assert (< i1@207@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(pop) ; 7
; Joined path conditions
(assert (< i1@207@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(declare-const sm@208@04 $FVF<option<array>>)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
      (< $Perm.No $k@20@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@208@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@208@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r))
  :qid |qp.fvfValDef170|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r)
  :pattern (($FVF.lookup_option$array$ (as sm@208@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef171|)))
(declare-const pm@209@04 $FPM)
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@209@04  $FPM) r)
    (ite (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r))) $k@20@04 $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@209@04  $FPM) r))
  :qid |qp.resPrmSumDef172|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@208@04  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@209@04  $FPM) r))
  :qid |qp.resTrgDef173|)))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@208@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@207@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@207@04)))
(push) ; 7
(assert (not (<
  $Perm.No
  ($FVF.perm_option$array$ (as pm@209@04  $FPM) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@207@04)))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               30643
;  :arith-add-rows          12601
;  :arith-assert-diseq      495
;  :arith-assert-lower      6623
;  :arith-assert-upper      4547
;  :arith-bound-prop        1359
;  :arith-conflicts         168
;  :arith-eq-adapter        4743
;  :arith-fixed-eqs         4034
;  :arith-offset-eqs        2542
;  :arith-pivots            4272
;  :conflicts               734
;  :datatype-accessor-ax    72
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1746
;  :del-clause              76965
;  :final-checks            5
;  :max-generation          11
;  :max-memory              9.86
;  :memory                  9.75
;  :minimized-lits          45
;  :mk-bool-var             89969
;  :mk-clause               77719
;  :num-allocs              605010
;  :num-checks              177
;  :propagations            21211
;  :quant-instantiations    32749
;  :rlimit-count            1841530)
; [eval] (None(): option[array])
(pop) ; 6
(push) ; 6
; [else-branch: 101 | !(i1@207@04 < V@15@04 && 0 <= i1@207@04)]
(assert (not (and (< i1@207@04 V@15@04) (<= 0 i1@207@04))))
(pop) ; 6
(pop) ; 5
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
      (< $Perm.No $k@20@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@208@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@208@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r))
  :qid |qp.fvfValDef170|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r)
  :pattern (($FVF.lookup_option$array$ (as sm@208@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef171|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@209@04  $FPM) r)
    (ite (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r))) $k@20@04 $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@209@04  $FPM) r))
  :qid |qp.resPrmSumDef172|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@208@04  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@209@04  $FPM) r))
  :qid |qp.resTrgDef173|)))
(assert (implies
  (and (< i1@207@04 V@15@04) (<= 0 i1@207@04))
  (and
    (< i1@207@04 V@15@04)
    (<= 0 i1@207@04)
    (< i1@207@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@208@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@207@04)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@207@04)))))
; Joined path conditions
(pop) ; 4
; Nested auxiliary terms: globals (aux)
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
      (< $Perm.No $k@20@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@208@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@208@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r))
  :qid |qp.fvfValDef170|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r)
  :pattern (($FVF.lookup_option$array$ (as sm@208@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef171|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@209@04  $FPM) r)
    (ite (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r))) $k@20@04 $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@209@04  $FPM) r))
  :qid |qp.resPrmSumDef172|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@208@04  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@209@04  $FPM) r))
  :qid |qp.resTrgDef173|)))
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
; Nested auxiliary terms: non-globals (tlq)
(push) ; 4
(assert (not (forall ((i1@207@04 Int)) (!
  (implies
    (and (< i1@207@04 V@15@04) (<= 0 i1@207@04))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@208@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@207@04))
        (as None<option<array>>  option<array>))))
  
  :qid |prog.l<no position>|))))
(check-sat)
; unsat
(pop) ; 4
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               31065
;  :arith-add-rows          12743
;  :arith-assert-diseq      504
;  :arith-assert-lower      6722
;  :arith-assert-upper      4615
;  :arith-bound-prop        1386
;  :arith-conflicts         169
;  :arith-eq-adapter        4821
;  :arith-fixed-eqs         4099
;  :arith-offset-eqs        2591
;  :arith-pivots            4373
;  :conflicts               752
;  :datatype-accessor-ax    72
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1795
;  :del-clause              79148
;  :final-checks            5
;  :max-generation          11
;  :max-memory              9.86
;  :memory                  9.72
;  :minimized-lits          45
;  :mk-bool-var             91915
;  :mk-clause               79777
;  :num-allocs              612664
;  :num-checks              178
;  :propagations            21470
;  :quant-instantiations    33420
;  :rlimit-count            1870790
;  :time                    0.01)
(assert (forall ((i1@207@04 Int)) (!
  (implies
    (and (< i1@207@04 V@15@04) (<= 0 i1@207@04))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@208@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@207@04))
        (as None<option<array>>  option<array>))))
  
  :qid |prog.l<no position>|)))
; [eval] (forall i1: Int :: 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(G), i1).option$array$)) == V)
(declare-const i1@210@04 Int)
(push) ; 4
; [eval] 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(G), i1).option$array$)) == V
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 5
; [then-branch: 102 | 0 <= i1@210@04 | live]
; [else-branch: 102 | !(0 <= i1@210@04) | live]
(push) ; 6
; [then-branch: 102 | 0 <= i1@210@04]
(assert (<= 0 i1@210@04))
; [eval] i1 < V
(pop) ; 6
(push) ; 6
; [else-branch: 102 | !(0 <= i1@210@04)]
(assert (not (<= 0 i1@210@04)))
(pop) ; 6
(pop) ; 5
; Joined path conditions
; Joined path conditions
(push) ; 5
; [then-branch: 103 | i1@210@04 < V@15@04 && 0 <= i1@210@04 | live]
; [else-branch: 103 | !(i1@210@04 < V@15@04 && 0 <= i1@210@04) | live]
(push) ; 6
; [then-branch: 103 | i1@210@04 < V@15@04 && 0 <= i1@210@04]
(assert (and (< i1@210@04 V@15@04) (<= 0 i1@210@04)))
; [eval] alen(opt_get1(aloc(opt_get1(G), i1).option$array$)) == V
; [eval] alen(opt_get1(aloc(opt_get1(G), i1).option$array$))
; [eval] opt_get1(aloc(opt_get1(G), i1).option$array$)
; [eval] aloc(opt_get1(G), i1)
; [eval] opt_get1(G)
(push) ; 7
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 7
; Joined path conditions
(push) ; 7
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 8
(assert (not (< i1@210@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               31065
;  :arith-add-rows          12743
;  :arith-assert-diseq      504
;  :arith-assert-lower      6724
;  :arith-assert-upper      4615
;  :arith-bound-prop        1386
;  :arith-conflicts         169
;  :arith-eq-adapter        4821
;  :arith-fixed-eqs         4099
;  :arith-offset-eqs        2591
;  :arith-pivots            4373
;  :conflicts               752
;  :datatype-accessor-ax    72
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1795
;  :del-clause              79148
;  :final-checks            5
;  :max-generation          11
;  :max-memory              9.86
;  :memory                  9.76
;  :minimized-lits          45
;  :mk-bool-var             91918
;  :mk-clause               79777
;  :num-allocs              612987
;  :num-checks              179
;  :propagations            21470
;  :quant-instantiations    33420
;  :rlimit-count            1871259)
(assert (< i1@210@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(pop) ; 7
; Joined path conditions
(assert (< i1@210@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(declare-const sm@211@04 $FVF<option<array>>)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
      (< $Perm.No $k@20@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@211@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@211@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r))
  :qid |qp.fvfValDef174|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r)
  :pattern (($FVF.lookup_option$array$ (as sm@211@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef175|)))
(declare-const pm@212@04 $FPM)
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@212@04  $FPM) r)
    (ite (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r))) $k@20@04 $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@212@04  $FPM) r))
  :qid |qp.resPrmSumDef176|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@211@04  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@212@04  $FPM) r))
  :qid |qp.resTrgDef177|)))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@211@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@210@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@210@04)))
(push) ; 7
(assert (not (<
  $Perm.No
  ($FVF.perm_option$array$ (as pm@212@04  $FPM) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@210@04)))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               31228
;  :arith-add-rows          12766
;  :arith-assert-diseq      507
;  :arith-assert-lower      6747
;  :arith-assert-upper      4628
;  :arith-bound-prop        1392
;  :arith-conflicts         171
;  :arith-eq-adapter        4836
;  :arith-fixed-eqs         4110
;  :arith-offset-eqs        2591
;  :arith-pivots            4391
;  :conflicts               755
;  :datatype-accessor-ax    72
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1797
;  :del-clause              79152
;  :final-checks            5
;  :max-generation          11
;  :max-memory              9.86
;  :memory                  9.79
;  :minimized-lits          45
;  :mk-bool-var             92135
;  :mk-clause               79907
;  :num-allocs              614769
;  :num-checks              180
;  :propagations            21532
;  :quant-instantiations    33516
;  :rlimit-count            1876852)
(push) ; 7
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 8
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@211@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@210@04))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 8
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               31616
;  :arith-add-rows          12879
;  :arith-assert-diseq      516
;  :arith-assert-lower      6832
;  :arith-assert-upper      4687
;  :arith-bound-prop        1413
;  :arith-conflicts         172
;  :arith-eq-adapter        4905
;  :arith-fixed-eqs         4166
;  :arith-offset-eqs        2640
;  :arith-pivots            4460
;  :conflicts               773
;  :datatype-accessor-ax    72
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1846
;  :del-clause              81078
;  :final-checks            5
;  :max-generation          11
;  :max-memory              9.92
;  :memory                  9.80
;  :minimized-lits          45
;  :mk-bool-var             93892
;  :mk-clause               81833
;  :num-allocs              620736
;  :num-checks              181
;  :propagations            21826
;  :quant-instantiations    34104
;  :rlimit-count            1901074
;  :time                    0.01)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@211@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@210@04))
    (as None<option<array>>  option<array>))))
(pop) ; 7
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@211@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@210@04))
    (as None<option<array>>  option<array>))))
(pop) ; 6
(push) ; 6
; [else-branch: 103 | !(i1@210@04 < V@15@04 && 0 <= i1@210@04)]
(assert (not (and (< i1@210@04 V@15@04) (<= 0 i1@210@04))))
(pop) ; 6
(pop) ; 5
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
      (< $Perm.No $k@20@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@211@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@211@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r))
  :qid |qp.fvfValDef174|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r)
  :pattern (($FVF.lookup_option$array$ (as sm@211@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef175|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@212@04  $FPM) r)
    (ite (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r))) $k@20@04 $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@212@04  $FPM) r))
  :qid |qp.resPrmSumDef176|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@211@04  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@212@04  $FPM) r))
  :qid |qp.resTrgDef177|)))
(assert (implies
  (and (< i1@210@04 V@15@04) (<= 0 i1@210@04))
  (and
    (< i1@210@04 V@15@04)
    (<= 0 i1@210@04)
    (< i1@210@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@211@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@210@04)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@210@04))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@211@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@210@04))
        (as None<option<array>>  option<array>))))))
; Joined path conditions
(pop) ; 4
; Nested auxiliary terms: globals (aux)
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
      (< $Perm.No $k@20@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@211@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@211@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r))
  :qid |qp.fvfValDef174|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r)
  :pattern (($FVF.lookup_option$array$ (as sm@211@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef175|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@212@04  $FPM) r)
    (ite (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r))) $k@20@04 $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@212@04  $FPM) r))
  :qid |qp.resPrmSumDef176|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@211@04  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@212@04  $FPM) r))
  :qid |qp.resTrgDef177|)))
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
; Nested auxiliary terms: non-globals (tlq)
(push) ; 4
(assert (not (forall ((i1@210@04 Int)) (!
  (implies
    (and (< i1@210@04 V@15@04) (<= 0 i1@210@04))
    (=
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@211@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@210@04))))
      V@15@04))
  
  :qid |prog.l<no position>|))))
(check-sat)
; unsat
(pop) ; 4
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               32084
;  :arith-add-rows          13004
;  :arith-assert-diseq      527
;  :arith-assert-lower      6932
;  :arith-assert-upper      4755
;  :arith-bound-prop        1440
;  :arith-conflicts         173
;  :arith-eq-adapter        4984
;  :arith-fixed-eqs         4231
;  :arith-offset-eqs        2689
;  :arith-pivots            4562
;  :conflicts               791
;  :datatype-accessor-ax    72
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1896
;  :del-clause              83274
;  :final-checks            5
;  :max-generation          11
;  :max-memory              9.94
;  :memory                  9.80
;  :minimized-lits          45
;  :mk-bool-var             95838
;  :mk-clause               83903
;  :num-allocs              628315
;  :num-checks              182
;  :propagations            22132
;  :quant-instantiations    34790
;  :rlimit-count            1930844
;  :time                    0.01)
(assert (forall ((i1@210@04 Int)) (!
  (implies
    (and (< i1@210@04 V@15@04) (<= 0 i1@210@04))
    (=
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@211@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@210@04))))
      V@15@04))
  
  :qid |prog.l<no position>|)))
; [eval] (forall i1: Int :: (forall i2: Int :: { aloc(opt_get1(G), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(G), i1).option$array$ == aloc(opt_get1(G), i2).option$array$ ==> i1 == i2))
(declare-const i1@213@04 Int)
(push) ; 4
; [eval] (forall i2: Int :: { aloc(opt_get1(G), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(G), i1).option$array$ == aloc(opt_get1(G), i2).option$array$ ==> i1 == i2)
(declare-const i2@214@04 Int)
(push) ; 5
; [eval] 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(G), i1).option$array$ == aloc(opt_get1(G), i2).option$array$ ==> i1 == i2
; [eval] 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(G), i1).option$array$ == aloc(opt_get1(G), i2).option$array$
; [eval] 0 <= i1
(push) ; 6
; [then-branch: 104 | 0 <= i1@213@04 | live]
; [else-branch: 104 | !(0 <= i1@213@04) | live]
(push) ; 7
; [then-branch: 104 | 0 <= i1@213@04]
(assert (<= 0 i1@213@04))
; [eval] i1 < V
(push) ; 8
; [then-branch: 105 | i1@213@04 < V@15@04 | live]
; [else-branch: 105 | !(i1@213@04 < V@15@04) | live]
(push) ; 9
; [then-branch: 105 | i1@213@04 < V@15@04]
(assert (< i1@213@04 V@15@04))
; [eval] 0 <= i2
(push) ; 10
; [then-branch: 106 | 0 <= i2@214@04 | live]
; [else-branch: 106 | !(0 <= i2@214@04) | live]
(push) ; 11
; [then-branch: 106 | 0 <= i2@214@04]
(assert (<= 0 i2@214@04))
; [eval] i2 < V
(push) ; 12
; [then-branch: 107 | i2@214@04 < V@15@04 | live]
; [else-branch: 107 | !(i2@214@04 < V@15@04) | live]
(push) ; 13
; [then-branch: 107 | i2@214@04 < V@15@04]
(assert (< i2@214@04 V@15@04))
; [eval] aloc(opt_get1(G), i1).option$array$ == aloc(opt_get1(G), i2).option$array$
; [eval] aloc(opt_get1(G), i1)
; [eval] opt_get1(G)
(push) ; 14
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 14
; Joined path conditions
(push) ; 14
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 15
(assert (not (< i1@213@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))))
(check-sat)
; unsat
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               32084
;  :arith-add-rows          13004
;  :arith-assert-diseq      527
;  :arith-assert-lower      6936
;  :arith-assert-upper      4755
;  :arith-bound-prop        1440
;  :arith-conflicts         173
;  :arith-eq-adapter        4984
;  :arith-fixed-eqs         4231
;  :arith-offset-eqs        2689
;  :arith-pivots            4563
;  :conflicts               791
;  :datatype-accessor-ax    72
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1896
;  :del-clause              83274
;  :final-checks            5
;  :max-generation          11
;  :max-memory              9.94
;  :memory                  9.80
;  :minimized-lits          45
;  :mk-bool-var             95843
;  :mk-clause               83903
;  :num-allocs              628834
;  :num-checks              183
;  :propagations            22132
;  :quant-instantiations    34790
;  :rlimit-count            1931480)
(assert (< i1@213@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(pop) ; 14
; Joined path conditions
(assert (< i1@213@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(declare-const sm@215@04 $FVF<option<array>>)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
      (< $Perm.No $k@20@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@215@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@215@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r))
  :qid |qp.fvfValDef178|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r)
  :pattern (($FVF.lookup_option$array$ (as sm@215@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef179|)))
(declare-const pm@216@04 $FPM)
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@216@04  $FPM) r)
    (ite (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r))) $k@20@04 $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@216@04  $FPM) r))
  :qid |qp.resPrmSumDef180|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@215@04  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@216@04  $FPM) r))
  :qid |qp.resTrgDef181|)))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@215@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@213@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@213@04)))
(push) ; 14
(assert (not (<
  $Perm.No
  ($FVF.perm_option$array$ (as pm@216@04  $FPM) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@213@04)))))
(check-sat)
; unsat
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               32288
;  :arith-add-rows          13033
;  :arith-assert-diseq      530
;  :arith-assert-lower      6961
;  :arith-assert-upper      4769
;  :arith-bound-prop        1447
;  :arith-conflicts         175
;  :arith-eq-adapter        5000
;  :arith-fixed-eqs         4243
;  :arith-offset-eqs        2702
;  :arith-pivots            4581
;  :conflicts               794
;  :datatype-accessor-ax    72
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1898
;  :del-clause              83278
;  :final-checks            5
;  :max-generation          11
;  :max-memory              9.94
;  :memory                  9.84
;  :minimized-lits          45
;  :mk-bool-var             96071
;  :mk-clause               84036
;  :num-allocs              630666
;  :num-checks              184
;  :propagations            22201
;  :quant-instantiations    34893
;  :rlimit-count            1937299)
; [eval] aloc(opt_get1(G), i2)
; [eval] opt_get1(G)
(push) ; 14
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 14
; Joined path conditions
(push) ; 14
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 15
(assert (not (< i2@214@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))))
(check-sat)
; unsat
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               32288
;  :arith-add-rows          13033
;  :arith-assert-diseq      530
;  :arith-assert-lower      6961
;  :arith-assert-upper      4769
;  :arith-bound-prop        1447
;  :arith-conflicts         175
;  :arith-eq-adapter        5000
;  :arith-fixed-eqs         4243
;  :arith-offset-eqs        2702
;  :arith-pivots            4581
;  :conflicts               794
;  :datatype-accessor-ax    72
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1898
;  :del-clause              83278
;  :final-checks            5
;  :max-generation          11
;  :max-memory              9.94
;  :memory                  9.84
;  :minimized-lits          45
;  :mk-bool-var             96071
;  :mk-clause               84036
;  :num-allocs              630692
;  :num-checks              185
;  :propagations            22201
;  :quant-instantiations    34893
;  :rlimit-count            1937329)
(assert (< i2@214@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(pop) ; 14
; Joined path conditions
(assert (< i2@214@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(declare-const sm@217@04 $FVF<option<array>>)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
      (< $Perm.No $k@20@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@217@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@217@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r))
  :qid |qp.fvfValDef182|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r)
  :pattern (($FVF.lookup_option$array$ (as sm@217@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef183|)))
(declare-const pm@218@04 $FPM)
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@218@04  $FPM) r)
    (ite (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r))) $k@20@04 $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@218@04  $FPM) r))
  :qid |qp.resPrmSumDef184|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@217@04  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@218@04  $FPM) r))
  :qid |qp.resTrgDef185|)))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@217@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@214@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@214@04)))
(push) ; 14
(assert (not (<
  $Perm.No
  ($FVF.perm_option$array$ (as pm@218@04  $FPM) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@214@04)))))
(check-sat)
; unsat
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               32487
;  :arith-add-rows          13058
;  :arith-assert-diseq      533
;  :arith-assert-lower      6986
;  :arith-assert-upper      4783
;  :arith-bound-prop        1453
;  :arith-conflicts         177
;  :arith-eq-adapter        5017
;  :arith-fixed-eqs         4255
;  :arith-offset-eqs        2702
;  :arith-pivots            4599
;  :conflicts               797
;  :datatype-accessor-ax    72
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1900
;  :del-clause              83282
;  :final-checks            5
;  :max-generation          11
;  :max-memory              9.94
;  :memory                  9.84
;  :minimized-lits          45
;  :mk-bool-var             96286
;  :mk-clause               84165
;  :num-allocs              632549
;  :num-checks              186
;  :propagations            22275
;  :quant-instantiations    34999
;  :rlimit-count            1943450)
(pop) ; 13
(push) ; 13
; [else-branch: 107 | !(i2@214@04 < V@15@04)]
(assert (not (< i2@214@04 V@15@04)))
(pop) ; 13
(pop) ; 12
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
      (< $Perm.No $k@20@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@215@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@215@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r))
  :qid |qp.fvfValDef178|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r)
  :pattern (($FVF.lookup_option$array$ (as sm@215@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef179|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@216@04  $FPM) r)
    (ite (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r))) $k@20@04 $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@216@04  $FPM) r))
  :qid |qp.resPrmSumDef180|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@215@04  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@216@04  $FPM) r))
  :qid |qp.resTrgDef181|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
      (< $Perm.No $k@20@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@217@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@217@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r))
  :qid |qp.fvfValDef182|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r)
  :pattern (($FVF.lookup_option$array$ (as sm@217@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef183|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@218@04  $FPM) r)
    (ite (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r))) $k@20@04 $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@218@04  $FPM) r))
  :qid |qp.resPrmSumDef184|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@217@04  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@218@04  $FPM) r))
  :qid |qp.resTrgDef185|)))
(assert (implies
  (< i2@214@04 V@15@04)
  (and
    (< i2@214@04 V@15@04)
    (< i1@213@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@215@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@213@04)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@213@04))
    (< i2@214@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@217@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@214@04)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@214@04)))))
; Joined path conditions
(pop) ; 11
(push) ; 11
; [else-branch: 106 | !(0 <= i2@214@04)]
(assert (not (<= 0 i2@214@04)))
(pop) ; 11
(pop) ; 10
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
      (< $Perm.No $k@20@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@215@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@215@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r))
  :qid |qp.fvfValDef178|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r)
  :pattern (($FVF.lookup_option$array$ (as sm@215@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef179|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@216@04  $FPM) r)
    (ite (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r))) $k@20@04 $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@216@04  $FPM) r))
  :qid |qp.resPrmSumDef180|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@215@04  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@216@04  $FPM) r))
  :qid |qp.resTrgDef181|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
      (< $Perm.No $k@20@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@217@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@217@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r))
  :qid |qp.fvfValDef182|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r)
  :pattern (($FVF.lookup_option$array$ (as sm@217@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef183|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@218@04  $FPM) r)
    (ite (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r))) $k@20@04 $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@218@04  $FPM) r))
  :qid |qp.resPrmSumDef184|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@217@04  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@218@04  $FPM) r))
  :qid |qp.resTrgDef185|)))
(assert (implies
  (<= 0 i2@214@04)
  (and
    (<= 0 i2@214@04)
    (implies
      (< i2@214@04 V@15@04)
      (and
        (< i2@214@04 V@15@04)
        (< i1@213@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@215@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@213@04)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@213@04))
        (< i2@214@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@217@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@214@04)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@214@04)))))))
; Joined path conditions
(pop) ; 9
(push) ; 9
; [else-branch: 105 | !(i1@213@04 < V@15@04)]
(assert (not (< i1@213@04 V@15@04)))
(pop) ; 9
(pop) ; 8
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
      (< $Perm.No $k@20@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@215@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@215@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r))
  :qid |qp.fvfValDef178|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r)
  :pattern (($FVF.lookup_option$array$ (as sm@215@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef179|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@216@04  $FPM) r)
    (ite (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r))) $k@20@04 $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@216@04  $FPM) r))
  :qid |qp.resPrmSumDef180|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@215@04  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@216@04  $FPM) r))
  :qid |qp.resTrgDef181|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
      (< $Perm.No $k@20@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@217@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@217@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r))
  :qid |qp.fvfValDef182|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r)
  :pattern (($FVF.lookup_option$array$ (as sm@217@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef183|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@218@04  $FPM) r)
    (ite (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r))) $k@20@04 $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@218@04  $FPM) r))
  :qid |qp.resPrmSumDef184|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@217@04  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@218@04  $FPM) r))
  :qid |qp.resTrgDef185|)))
(assert (implies
  (< i1@213@04 V@15@04)
  (and
    (< i1@213@04 V@15@04)
    (implies
      (<= 0 i2@214@04)
      (and
        (<= 0 i2@214@04)
        (implies
          (< i2@214@04 V@15@04)
          (and
            (< i2@214@04 V@15@04)
            (< i1@213@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@215@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@213@04)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@213@04))
            (< i2@214@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@217@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@214@04)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@214@04)))))))))
; Joined path conditions
(pop) ; 7
(push) ; 7
; [else-branch: 104 | !(0 <= i1@213@04)]
(assert (not (<= 0 i1@213@04)))
(pop) ; 7
(pop) ; 6
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
      (< $Perm.No $k@20@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@215@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@215@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r))
  :qid |qp.fvfValDef178|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r)
  :pattern (($FVF.lookup_option$array$ (as sm@215@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef179|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@216@04  $FPM) r)
    (ite (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r))) $k@20@04 $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@216@04  $FPM) r))
  :qid |qp.resPrmSumDef180|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@215@04  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@216@04  $FPM) r))
  :qid |qp.resTrgDef181|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
      (< $Perm.No $k@20@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@217@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@217@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r))
  :qid |qp.fvfValDef182|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r)
  :pattern (($FVF.lookup_option$array$ (as sm@217@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef183|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@218@04  $FPM) r)
    (ite (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r))) $k@20@04 $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@218@04  $FPM) r))
  :qid |qp.resPrmSumDef184|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@217@04  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@218@04  $FPM) r))
  :qid |qp.resTrgDef185|)))
(assert (implies
  (<= 0 i1@213@04)
  (and
    (<= 0 i1@213@04)
    (implies
      (< i1@213@04 V@15@04)
      (and
        (< i1@213@04 V@15@04)
        (implies
          (<= 0 i2@214@04)
          (and
            (<= 0 i2@214@04)
            (implies
              (< i2@214@04 V@15@04)
              (and
                (< i2@214@04 V@15@04)
                (< i1@213@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@215@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@213@04)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@213@04))
                (< i2@214@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@217@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@214@04)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@214@04)))))))))))
; Joined path conditions
(push) ; 6
; [then-branch: 108 | Lookup(option$array$,sm@215@04,aloc((_, _), opt_get1(_, G@11@04), i1@213@04)) == Lookup(option$array$,sm@217@04,aloc((_, _), opt_get1(_, G@11@04), i2@214@04)) && i2@214@04 < V@15@04 && 0 <= i2@214@04 && i1@213@04 < V@15@04 && 0 <= i1@213@04 | live]
; [else-branch: 108 | !(Lookup(option$array$,sm@215@04,aloc((_, _), opt_get1(_, G@11@04), i1@213@04)) == Lookup(option$array$,sm@217@04,aloc((_, _), opt_get1(_, G@11@04), i2@214@04)) && i2@214@04 < V@15@04 && 0 <= i2@214@04 && i1@213@04 < V@15@04 && 0 <= i1@213@04) | live]
(push) ; 7
; [then-branch: 108 | Lookup(option$array$,sm@215@04,aloc((_, _), opt_get1(_, G@11@04), i1@213@04)) == Lookup(option$array$,sm@217@04,aloc((_, _), opt_get1(_, G@11@04), i2@214@04)) && i2@214@04 < V@15@04 && 0 <= i2@214@04 && i1@213@04 < V@15@04 && 0 <= i1@213@04]
(assert (and
  (and
    (and
      (and
        (=
          ($FVF.lookup_option$array$ (as sm@215@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@213@04))
          ($FVF.lookup_option$array$ (as sm@217@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@214@04)))
        (< i2@214@04 V@15@04))
      (<= 0 i2@214@04))
    (< i1@213@04 V@15@04))
  (<= 0 i1@213@04)))
; [eval] i1 == i2
(pop) ; 7
(push) ; 7
; [else-branch: 108 | !(Lookup(option$array$,sm@215@04,aloc((_, _), opt_get1(_, G@11@04), i1@213@04)) == Lookup(option$array$,sm@217@04,aloc((_, _), opt_get1(_, G@11@04), i2@214@04)) && i2@214@04 < V@15@04 && 0 <= i2@214@04 && i1@213@04 < V@15@04 && 0 <= i1@213@04)]
(assert (not
  (and
    (and
      (and
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@215@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@213@04))
            ($FVF.lookup_option$array$ (as sm@217@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@214@04)))
          (< i2@214@04 V@15@04))
        (<= 0 i2@214@04))
      (< i1@213@04 V@15@04))
    (<= 0 i1@213@04))))
(pop) ; 7
(pop) ; 6
; Joined path conditions
(assert (implies
  (and
    (and
      (and
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@215@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@213@04))
            ($FVF.lookup_option$array$ (as sm@217@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@214@04)))
          (< i2@214@04 V@15@04))
        (<= 0 i2@214@04))
      (< i1@213@04 V@15@04))
    (<= 0 i1@213@04))
  (and
    (=
      ($FVF.lookup_option$array$ (as sm@215@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@213@04))
      ($FVF.lookup_option$array$ (as sm@217@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@214@04)))
    (< i2@214@04 V@15@04)
    (<= 0 i2@214@04)
    (< i1@213@04 V@15@04)
    (<= 0 i1@213@04))))
; Joined path conditions
(pop) ; 5
; Nested auxiliary terms: globals (aux)
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
      (< $Perm.No $k@20@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@215@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@215@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r))
  :qid |qp.fvfValDef178|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r)
  :pattern (($FVF.lookup_option$array$ (as sm@215@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef179|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@216@04  $FPM) r)
    (ite (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r))) $k@20@04 $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@216@04  $FPM) r))
  :qid |qp.resPrmSumDef180|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@215@04  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@216@04  $FPM) r))
  :qid |qp.resTrgDef181|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
      (< $Perm.No $k@20@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@217@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@217@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r))
  :qid |qp.fvfValDef182|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r)
  :pattern (($FVF.lookup_option$array$ (as sm@217@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef183|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@218@04  $FPM) r)
    (ite (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r))) $k@20@04 $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@218@04  $FPM) r))
  :qid |qp.resPrmSumDef184|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@217@04  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@218@04  $FPM) r))
  :qid |qp.resTrgDef185|)))
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i2@214@04 Int)) (!
  (and
    (implies
      (<= 0 i1@213@04)
      (and
        (<= 0 i1@213@04)
        (implies
          (< i1@213@04 V@15@04)
          (and
            (< i1@213@04 V@15@04)
            (implies
              (<= 0 i2@214@04)
              (and
                (<= 0 i2@214@04)
                (implies
                  (< i2@214@04 V@15@04)
                  (and
                    (< i2@214@04 V@15@04)
                    (< i1@213@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
                    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@215@04  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@213@04)) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@213@04))
                    (< i2@214@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
                    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@217@04  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@214@04)) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@214@04))))))))))
    (implies
      (and
        (and
          (and
            (and
              (=
                ($FVF.lookup_option$array$ (as sm@215@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@213@04))
                ($FVF.lookup_option$array$ (as sm@217@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@214@04)))
              (< i2@214@04 V@15@04))
            (<= 0 i2@214@04))
          (< i1@213@04 V@15@04))
        (<= 0 i1@213@04))
      (and
        (=
          ($FVF.lookup_option$array$ (as sm@215@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@213@04))
          ($FVF.lookup_option$array$ (as sm@217@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@214@04)))
        (< i2@214@04 V@15@04)
        (<= 0 i2@214@04)
        (< i1@213@04 V@15@04)
        (<= 0 i1@213@04))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@214@04))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 4
; Nested auxiliary terms: globals (aux)
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
      (< $Perm.No $k@20@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@215@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@215@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r))
  :qid |qp.fvfValDef178|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r)
  :pattern (($FVF.lookup_option$array$ (as sm@215@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef179|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@216@04  $FPM) r)
    (ite (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r))) $k@20@04 $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@216@04  $FPM) r))
  :qid |qp.resPrmSumDef180|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@215@04  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@216@04  $FPM) r))
  :qid |qp.resTrgDef181|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
      (< $Perm.No $k@20@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@217@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@217@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r))
  :qid |qp.fvfValDef182|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r)
  :pattern (($FVF.lookup_option$array$ (as sm@217@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef183|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@218@04  $FPM) r)
    (ite (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r))) $k@20@04 $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@218@04  $FPM) r))
  :qid |qp.resPrmSumDef184|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@217@04  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@218@04  $FPM) r))
  :qid |qp.resTrgDef185|)))
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
; Nested auxiliary terms: non-globals (tlq)
(push) ; 4
(assert (not (forall ((i1@213@04 Int)) (!
  (forall ((i2@214@04 Int)) (!
    (implies
      (and
        (and
          (and
            (and
              (=
                ($FVF.lookup_option$array$ (as sm@215@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@213@04))
                ($FVF.lookup_option$array$ (as sm@217@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@214@04)))
              (< i2@214@04 V@15@04))
            (<= 0 i2@214@04))
          (< i1@213@04 V@15@04))
        (<= 0 i1@213@04))
      (= i1@213@04 i2@214@04))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@214@04))
    :qid |prog.l<no position>|))
  
  :qid |prog.l<no position>|))))
(check-sat)
; unsat
(pop) ; 4
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               33097
;  :arith-add-rows          13337
;  :arith-assert-diseq      544
;  :arith-assert-lower      7118
;  :arith-assert-upper      4871
;  :arith-bound-prop        1496
;  :arith-conflicts         179
;  :arith-eq-adapter        5119
;  :arith-fixed-eqs         4339
;  :arith-offset-eqs        2772
;  :arith-pivots            4759
;  :conflicts               815
;  :datatype-accessor-ax    72
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1951
;  :del-clause              85894
;  :final-checks            5
;  :max-generation          11
;  :max-memory              10.19
;  :memory                  10.04
;  :minimized-lits          45
;  :mk-bool-var             98729
;  :mk-clause               86523
;  :num-allocs              645776
;  :num-checks              187
;  :propagations            22614
;  :quant-instantiations    35872
;  :rlimit-count            1987399
;  :time                    0.01)
(assert (forall ((i1@213@04 Int)) (!
  (forall ((i2@214@04 Int)) (!
    (implies
      (and
        (and
          (and
            (and
              (=
                ($FVF.lookup_option$array$ (as sm@215@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@213@04))
                ($FVF.lookup_option$array$ (as sm@217@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@214@04)))
              (< i2@214@04 V@15@04))
            (<= 0 i2@214@04))
          (< i1@213@04 V@15@04))
        (<= 0 i1@213@04))
      (= i1@213@04 i2@214@04))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@214@04))
    :qid |prog.l<no position>|))
  
  :qid |prog.l<no position>|)))
(declare-const i1@219@04 Int)
(declare-const j@220@04 Int)
(push) ; 4
; [eval] 0 <= i1 && i1 < V && (0 <= j && j < V)
; [eval] 0 <= i1
(push) ; 5
; [then-branch: 109 | 0 <= i1@219@04 | live]
; [else-branch: 109 | !(0 <= i1@219@04) | live]
(push) ; 6
; [then-branch: 109 | 0 <= i1@219@04]
(assert (<= 0 i1@219@04))
; [eval] i1 < V
(push) ; 7
; [then-branch: 110 | i1@219@04 < V@15@04 | live]
; [else-branch: 110 | !(i1@219@04 < V@15@04) | live]
(push) ; 8
; [then-branch: 110 | i1@219@04 < V@15@04]
(assert (< i1@219@04 V@15@04))
; [eval] 0 <= j
(push) ; 9
; [then-branch: 111 | 0 <= j@220@04 | live]
; [else-branch: 111 | !(0 <= j@220@04) | live]
(push) ; 10
; [then-branch: 111 | 0 <= j@220@04]
(assert (<= 0 j@220@04))
; [eval] j < V
(pop) ; 10
(push) ; 10
; [else-branch: 111 | !(0 <= j@220@04)]
(assert (not (<= 0 j@220@04)))
(pop) ; 10
(pop) ; 9
; Joined path conditions
; Joined path conditions
(pop) ; 8
(push) ; 8
; [else-branch: 110 | !(i1@219@04 < V@15@04)]
(assert (not (< i1@219@04 V@15@04)))
(pop) ; 8
(pop) ; 7
; Joined path conditions
; Joined path conditions
(pop) ; 6
(push) ; 6
; [else-branch: 109 | !(0 <= i1@219@04)]
(assert (not (<= 0 i1@219@04)))
(pop) ; 6
(pop) ; 5
; Joined path conditions
; Joined path conditions
(assert (and
  (and (and (< j@220@04 V@15@04) (<= 0 j@220@04)) (< i1@219@04 V@15@04))
  (<= 0 i1@219@04)))
(declare-const $k@221@04 $Perm)
(assert ($Perm.isReadVar $k@221@04 $Perm.Write))
; [eval] aloc(opt_get1(aloc(opt_get1(G), i1).option$array$), j)
; [eval] opt_get1(aloc(opt_get1(G), i1).option$array$)
; [eval] aloc(opt_get1(G), i1)
; [eval] opt_get1(G)
(push) ; 5
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 5
; Joined path conditions
(push) ; 5
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 6
(assert (not (< i1@219@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               33097
;  :arith-add-rows          13337
;  :arith-assert-diseq      545
;  :arith-assert-lower      7126
;  :arith-assert-upper      4872
;  :arith-bound-prop        1496
;  :arith-conflicts         179
;  :arith-eq-adapter        5120
;  :arith-fixed-eqs         4339
;  :arith-offset-eqs        2772
;  :arith-pivots            4759
;  :conflicts               815
;  :datatype-accessor-ax    72
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1951
;  :del-clause              85894
;  :final-checks            5
;  :max-generation          11
;  :max-memory              10.19
;  :memory                  10.04
;  :minimized-lits          45
;  :mk-bool-var             98740
;  :mk-clause               86525
;  :num-allocs              646451
;  :num-checks              188
;  :propagations            22615
;  :quant-instantiations    35872
;  :rlimit-count            1988489)
(assert (< i1@219@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(pop) ; 5
; Joined path conditions
(assert (< i1@219@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(declare-const sm@222@04 $FVF<option<array>>)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
      (< $Perm.No $k@20@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@222@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@222@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r))
  :qid |qp.fvfValDef186|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r)
  :pattern (($FVF.lookup_option$array$ (as sm@222@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef187|)))
(declare-const pm@223@04 $FPM)
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@223@04  $FPM) r)
    (ite (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r))) $k@20@04 $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@223@04  $FPM) r))
  :qid |qp.resPrmSumDef188|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@222@04  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@223@04  $FPM) r))
  :qid |qp.resTrgDef189|)))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@222@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@219@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@219@04)))
(push) ; 5
(assert (not (<
  $Perm.No
  ($FVF.perm_option$array$ (as pm@223@04  $FPM) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@219@04)))))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               33289
;  :arith-add-rows          13360
;  :arith-assert-diseq      548
;  :arith-assert-lower      7151
;  :arith-assert-upper      4886
;  :arith-bound-prop        1502
;  :arith-conflicts         181
;  :arith-eq-adapter        5136
;  :arith-fixed-eqs         4351
;  :arith-offset-eqs        2772
;  :arith-pivots            4779
;  :conflicts               818
;  :datatype-accessor-ax    72
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1953
;  :del-clause              85898
;  :final-checks            5
;  :max-generation          11
;  :max-memory              10.19
;  :memory                  10.06
;  :minimized-lits          45
;  :mk-bool-var             98971
;  :mk-clause               86660
;  :num-allocs              648321
;  :num-checks              189
;  :propagations            22685
;  :quant-instantiations    35978
;  :rlimit-count            1994439)
(push) ; 5
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 6
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@222@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@219@04))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 6
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               33702
;  :arith-add-rows          13473
;  :arith-assert-diseq      557
;  :arith-assert-lower      7244
;  :arith-assert-upper      4949
;  :arith-bound-prop        1523
;  :arith-conflicts         182
;  :arith-eq-adapter        5209
;  :arith-fixed-eqs         4411
;  :arith-offset-eqs        2821
;  :arith-pivots            4856
;  :conflicts               836
;  :datatype-accessor-ax    72
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               2002
;  :del-clause              87866
;  :final-checks            5
;  :max-generation          11
;  :max-memory              10.19
;  :memory                  10.05
;  :minimized-lits          45
;  :mk-bool-var             100804
;  :mk-clause               88628
;  :num-allocs              654826
;  :num-checks              190
;  :propagations            22982
;  :quant-instantiations    36626
;  :rlimit-count            2020347
;  :time                    0.01)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@222@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@219@04))
    (as None<option<array>>  option<array>))))
(pop) ; 5
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@222@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@219@04))
    (as None<option<array>>  option<array>))))
(push) ; 5
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 6
(assert (not (<
  j@220@04
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@222@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@219@04)))))))
(check-sat)
; unsat
(pop) ; 6
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               34244
;  :arith-add-rows          13595
;  :arith-assert-diseq      566
;  :arith-assert-lower      7340
;  :arith-assert-upper      5013
;  :arith-bound-prop        1544
;  :arith-conflicts         184
;  :arith-eq-adapter        5288
;  :arith-fixed-eqs         4472
;  :arith-offset-eqs        2870
;  :arith-pivots            4936
;  :conflicts               854
;  :datatype-accessor-ax    72
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               2051
;  :del-clause              89848
;  :final-checks            5
;  :max-generation          11
;  :max-memory              10.80
;  :memory                  10.37
;  :minimized-lits          45
;  :mk-bool-var             102694
;  :mk-clause               90610
;  :num-allocs              661478
;  :num-checks              191
;  :propagations            23330
;  :quant-instantiations    37289
;  :rlimit-count            2046871
;  :time                    0.01)
(assert (<
  j@220@04
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@222@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@219@04))))))
(pop) ; 5
; Joined path conditions
(assert (<
  j@220@04
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@222@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@219@04))))))
(pop) ; 4
(declare-fun inv@224@04 ($Ref) Int)
(declare-fun inv@225@04 ($Ref) Int)
; Nested auxiliary terms: globals
(assert ($Perm.isReadVar $k@221@04 $Perm.Write))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
      (< $Perm.No $k@20@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@222@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@222@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r))
  :qid |qp.fvfValDef186|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r)
  :pattern (($FVF.lookup_option$array$ (as sm@222@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef187|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@223@04  $FPM) r)
    (ite (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r))) $k@20@04 $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@223@04  $FPM) r))
  :qid |qp.resPrmSumDef188|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@222@04  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@223@04  $FPM) r))
  :qid |qp.resTrgDef189|)))
; Nested auxiliary terms: non-globals
(assert (forall ((i1@219@04 Int) (j@220@04 Int)) (!
  (and
    (< i1@219@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@222@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@219@04)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@219@04))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@222@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@219@04))
        (as None<option<array>>  option<array>)))
    (<
      j@220@04
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@222@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@219@04))))))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@222@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@219@04))) j@220@04))
  :qid |int-aux|)))
(push) ; 4
(assert (not (forall ((i1@219@04 Int) (j@220@04 Int)) (!
  (implies
    (and
      (and (and (< j@220@04 V@15@04) (<= 0 j@220@04)) (< i1@219@04 V@15@04))
      (<= 0 i1@219@04))
    (or (= $k@221@04 $Perm.No) (< $Perm.No $k@221@04)))
  
  ))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               34244
;  :arith-add-rows          13602
;  :arith-assert-diseq      567
;  :arith-assert-lower      7342
;  :arith-assert-upper      5014
;  :arith-bound-prop        1544
;  :arith-conflicts         184
;  :arith-eq-adapter        5289
;  :arith-fixed-eqs         4472
;  :arith-offset-eqs        2870
;  :arith-pivots            4952
;  :conflicts               855
;  :datatype-accessor-ax    72
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               2051
;  :del-clause              89981
;  :final-checks            5
;  :max-generation          11
;  :max-memory              10.80
;  :memory                  10.35
;  :minimized-lits          45
;  :mk-bool-var             102707
;  :mk-clause               90612
;  :num-allocs              662523
;  :num-checks              192
;  :propagations            23331
;  :quant-instantiations    37289
;  :rlimit-count            2049231)
(declare-const sm@226@04 $FVF<Int>)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@30@04 r) V@15@04) (<= 0 (inv@30@04 r)))
        (< (inv@29@04 r) V@15@04))
      (<= 0 (inv@29@04 r)))
    (=
      ($FVF.lookup_int (as sm@226@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@226@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))))))) r))
  :qid |qp.fvfValDef190|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@33@04 r) V@15@04) (<= 0 (inv@33@04 r)))
    (=
      ($FVF.lookup_int (as sm@226@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04)))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@226@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04)))))))))))))))) r))
  :qid |qp.fvfValDef191|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04)))))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@226@04  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef192|)))
; Check receiver injectivity
(push) ; 4
(assert (not (forall ((i11@219@04 Int) (j1@220@04 Int) (i12@219@04 Int) (j2@220@04 Int)) (!
  (implies
    (and
      (and
        (and
          (and
            (and
              (and (< j1@220@04 V@15@04) (<= 0 j1@220@04))
              (< i11@219@04 V@15@04))
            (<= 0 i11@219@04))
          ($FVF.loc_int ($FVF.lookup_int (as sm@226@04  $FVF<Int>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@222@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i11@219@04))) j1@220@04)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@222@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i11@219@04))) j1@220@04)))
        (< $Perm.No $k@221@04))
      (and
        (and
          (and
            (and
              (and (< j2@220@04 V@15@04) (<= 0 j2@220@04))
              (< i12@219@04 V@15@04))
            (<= 0 i12@219@04))
          ($FVF.loc_int ($FVF.lookup_int (as sm@226@04  $FVF<Int>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@222@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i12@219@04))) j2@220@04)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@222@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i12@219@04))) j2@220@04)))
        (< $Perm.No $k@221@04))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@222@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i11@219@04))) j1@220@04)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@222@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i12@219@04))) j2@220@04)))
    (and (= i11@219@04 i12@219@04) (= j1@220@04 j2@220@04)))
  
  :qid |int-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 4
; 0.02s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               35043
;  :arith-add-rows          14019
;  :arith-assert-diseq      578
;  :arith-assert-lower      7503
;  :arith-assert-upper      5124
;  :arith-bound-prop        1605
;  :arith-conflicts         186
;  :arith-eq-adapter        5409
;  :arith-fixed-eqs         4574
;  :arith-offset-eqs        2967
;  :arith-pivots            5126
;  :conflicts               873
;  :datatype-accessor-ax    72
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               2104
;  :del-clause              92674
;  :final-checks            5
;  :max-generation          11
;  :max-memory              11.83
;  :memory                  11.41
;  :minimized-lits          48
;  :mk-bool-var             105628
;  :mk-clause               93305
;  :num-allocs              674905
;  :num-checks              193
;  :propagations            23710
;  :quant-instantiations    38300
;  :rlimit-count            2095575
;  :time                    0.02)
; Definitional axioms for inverse functions
(assert (forall ((i1@219@04 Int) (j@220@04 Int)) (!
  (implies
    (and
      (and
        (and (and (< j@220@04 V@15@04) (<= 0 j@220@04)) (< i1@219@04 V@15@04))
        (<= 0 i1@219@04))
      (< $Perm.No $k@221@04))
    (and
      (=
        (inv@224@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@222@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@219@04))) j@220@04))
        i1@219@04)
      (=
        (inv@225@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@222@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@219@04))) j@220@04))
        j@220@04)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@222@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@219@04))) j@220@04))
  :qid |int-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and
          (and (< (inv@225@04 r) V@15@04) (<= 0 (inv@225@04 r)))
          (< (inv@224@04 r) V@15@04))
        (<= 0 (inv@224@04 r)))
      (< $Perm.No $k@221@04))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@222@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) (inv@224@04 r)))) (inv@225@04 r))
      r))
  :pattern ((inv@224@04 r))
  :pattern ((inv@225@04 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@225@04 r) V@15@04) (<= 0 (inv@225@04 r)))
        (< (inv@224@04 r) V@15@04))
      (<= 0 (inv@224@04 r)))
    ($FVF.loc_int ($FVF.lookup_int (as sm@226@04  $FVF<Int>) r) r))
  :pattern ((inv@224@04 r) (inv@225@04 r))
  )))
; Precomputing data for removing quantified permissions
(define-fun pTaken@227@04 ((r $Ref)) $Perm
  (ite
    (and
      (and
        (and (< (inv@225@04 r) V@15@04) (<= 0 (inv@225@04 r)))
        (< (inv@224@04 r) V@15@04))
      (<= 0 (inv@224@04 r)))
    ($Perm.min
      (ite
        (and
          (and
            (and (< (inv@30@04 r) V@15@04) (<= 0 (inv@30@04 r)))
            (< (inv@29@04 r) V@15@04))
          (<= 0 (inv@29@04 r)))
        $Perm.Write
        $Perm.No)
      $k@221@04)
    $Perm.No))
(define-fun pTaken@228@04 ((r $Ref)) $Perm
  (ite
    (and
      (and
        (and (< (inv@225@04 r) V@15@04) (<= 0 (inv@225@04 r)))
        (< (inv@224@04 r) V@15@04))
      (<= 0 (inv@224@04 r)))
    ($Perm.min
      (ite
        (and (< (inv@33@04 r) V@15@04) (<= 0 (inv@33@04 r)))
        $Perm.Write
        $Perm.No)
      (- $k@221@04 (pTaken@227@04 r)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Constrain original permissions $k@221@04
(assert (forall ((r $Ref)) (!
  (implies
    (not
      (=
        (ite
          (and
            (and
              (and (< (inv@30@04 r) V@15@04) (<= 0 (inv@30@04 r)))
              (< (inv@29@04 r) V@15@04))
            (<= 0 (inv@29@04 r)))
          $Perm.Write
          $Perm.No)
        $Perm.No))
    (ite
      (and
        (and
          (and (< (inv@30@04 r) V@15@04) (<= 0 (inv@30@04 r)))
          (< (inv@29@04 r) V@15@04))
        (<= 0 (inv@29@04 r)))
      (<
        (ite
          (and
            (and
              (and (< (inv@225@04 r) V@15@04) (<= 0 (inv@225@04 r)))
              (< (inv@224@04 r) V@15@04))
            (<= 0 (inv@224@04 r)))
          $k@221@04
          $Perm.No)
        $Perm.Write)
      (<
        (ite
          (and
            (and
              (and (< (inv@225@04 r) V@15@04) (<= 0 (inv@225@04 r)))
              (< (inv@224@04 r) V@15@04))
            (<= 0 (inv@224@04 r)))
          $k@221@04
          $Perm.No)
        $Perm.No)))
  :pattern ((inv@30@04 r))
  :pattern ((inv@29@04 r))
  :pattern ((inv@225@04 r))
  :pattern ((inv@224@04 r))
  :qid |qp.srp193|)))
; Intermediate check if already taken enough permissions
(set-option :timeout 500)
(push) ; 4
(assert (not (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@225@04 r) V@15@04) (<= 0 (inv@225@04 r)))
        (< (inv@224@04 r) V@15@04))
      (<= 0 (inv@224@04 r)))
    (= (- $k@221@04 (pTaken@227@04 r)) $Perm.No))
  
  ))))
(check-sat)
; unsat
(pop) ; 4
; 0.02s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               36779
;  :arith-add-rows          14685
;  :arith-assert-diseq      602
;  :arith-assert-lower      7845
;  :arith-assert-upper      5362
;  :arith-bound-prop        1678
;  :arith-conflicts         192
;  :arith-eq-adapter        5686
;  :arith-fixed-eqs         4812
;  :arith-offset-eqs        3157
;  :arith-pivots            5394
;  :conflicts               897
;  :datatype-accessor-ax    72
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               2212
;  :del-clause              97777
;  :final-checks            5
;  :max-generation          11
;  :max-memory              11.83
;  :memory                  11.46
;  :minimized-lits          51
;  :mk-bool-var             110912
;  :mk-clause               98431
;  :num-allocs              695244
;  :num-checks              195
;  :propagations            24724
;  :quant-instantiations    40166
;  :rlimit-count            2176610
;  :time                    0.01)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@229@04 $FVF<Int>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (iff
    (Set_in r ($FVF.domain_int (as sm@229@04  $FVF<Int>)))
    (and
      (and
        (and
          (and (< (inv@225@04 r) V@15@04) (<= 0 (inv@225@04 r)))
          (< (inv@224@04 r) V@15@04))
        (<= 0 (inv@224@04 r)))
      (< $Perm.No $k@221@04)))
  :pattern ((Set_in r ($FVF.domain_int (as sm@229@04  $FVF<Int>))))
  :qid |qp.fvfDomDef197|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and
          (and
            (and (< (inv@225@04 r) V@15@04) (<= 0 (inv@225@04 r)))
            (< (inv@224@04 r) V@15@04))
          (<= 0 (inv@224@04 r)))
        (< $Perm.No $k@221@04))
      (and
        (and
          (and (< (inv@30@04 r) V@15@04) (<= 0 (inv@30@04 r)))
          (< (inv@29@04 r) V@15@04))
        (<= 0 (inv@29@04 r))))
    (=
      ($FVF.lookup_int (as sm@229@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@229@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))))))) r))
  :qid |qp.fvfValDef194|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and
          (and
            (and (< (inv@225@04 r) V@15@04) (<= 0 (inv@225@04 r)))
            (< (inv@224@04 r) V@15@04))
          (<= 0 (inv@224@04 r)))
        (< $Perm.No $k@221@04))
      (and (< (inv@33@04 r) V@15@04) (<= 0 (inv@33@04 r))))
    (=
      ($FVF.lookup_int (as sm@229@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04)))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@229@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04)))))))))))))))) r))
  :qid |qp.fvfValDef195|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04)))))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@229@04  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef196|)))
(pop) ; 3
; Joined path conditions
(assert ($Perm.isReadVar $k@202@04 $Perm.Write))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
      (< $Perm.No $k@20@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@204@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@204@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r))
  :qid |qp.fvfValDef164|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r)
  :pattern (($FVF.lookup_option$array$ (as sm@204@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef165|)))
(assert (forall ((i1@201@04 Int)) (!
  (implies
    (and (and (< i1@201@04 V@15@04) (<= 0 i1@201@04)) (< $Perm.No $k@202@04))
    (=
      (inv@203@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@201@04))
      i1@201@04))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@201@04))
  :qid |option$array$-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and (< (inv@203@04 r) V@15@04) (<= 0 (inv@203@04 r)))
      (< $Perm.No $k@202@04))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) (inv@203@04 r))
      r))
  :pattern ((inv@203@04 r))
  :qid |option$array$-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (iff
    (Set_in r ($FVF.domain_option$array$ (as sm@206@04  $FVF<option<array>>)))
    (and
      (and (< (inv@203@04 r) V@15@04) (<= 0 (inv@203@04 r)))
      (< $Perm.No $k@202@04)))
  :pattern ((Set_in r ($FVF.domain_option$array$ (as sm@206@04  $FVF<option<array>>))))
  :qid |qp.fvfDomDef169|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@203@04 r) V@15@04) (<= 0 (inv@203@04 r)))
        (< $Perm.No $k@202@04))
      (ite
        (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
        (< $Perm.No $k@20@04)
        false))
    (=
      ($FVF.lookup_option$array$ (as sm@206@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@206@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r))
  :qid |qp.fvfValDef167|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r)
  :pattern (($FVF.lookup_option$array$ (as sm@206@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef168|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
      (< $Perm.No $k@20@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@208@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@208@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r))
  :qid |qp.fvfValDef170|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r)
  :pattern (($FVF.lookup_option$array$ (as sm@208@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef171|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@209@04  $FPM) r)
    (ite (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r))) $k@20@04 $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@209@04  $FPM) r))
  :qid |qp.resPrmSumDef172|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@208@04  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@209@04  $FPM) r))
  :qid |qp.resTrgDef173|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
      (< $Perm.No $k@20@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@211@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@211@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r))
  :qid |qp.fvfValDef174|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r)
  :pattern (($FVF.lookup_option$array$ (as sm@211@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef175|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@212@04  $FPM) r)
    (ite (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r))) $k@20@04 $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@212@04  $FPM) r))
  :qid |qp.resPrmSumDef176|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@211@04  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@212@04  $FPM) r))
  :qid |qp.resTrgDef177|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
      (< $Perm.No $k@20@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@215@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@215@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r))
  :qid |qp.fvfValDef178|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r)
  :pattern (($FVF.lookup_option$array$ (as sm@215@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef179|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@216@04  $FPM) r)
    (ite (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r))) $k@20@04 $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@216@04  $FPM) r))
  :qid |qp.resPrmSumDef180|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@215@04  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@216@04  $FPM) r))
  :qid |qp.resTrgDef181|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
      (< $Perm.No $k@20@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@217@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@217@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r))
  :qid |qp.fvfValDef182|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r)
  :pattern (($FVF.lookup_option$array$ (as sm@217@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef183|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@218@04  $FPM) r)
    (ite (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r))) $k@20@04 $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@218@04  $FPM) r))
  :qid |qp.resPrmSumDef184|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@217@04  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@218@04  $FPM) r))
  :qid |qp.resTrgDef185|)))
(assert ($Perm.isReadVar $k@221@04 $Perm.Write))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
      (< $Perm.No $k@20@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@222@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@222@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r))
  :qid |qp.fvfValDef186|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r)
  :pattern (($FVF.lookup_option$array$ (as sm@222@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef187|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@223@04  $FPM) r)
    (ite (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r))) $k@20@04 $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@223@04  $FPM) r))
  :qid |qp.resPrmSumDef188|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@222@04  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@223@04  $FPM) r))
  :qid |qp.resTrgDef189|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@30@04 r) V@15@04) (<= 0 (inv@30@04 r)))
        (< (inv@29@04 r) V@15@04))
      (<= 0 (inv@29@04 r)))
    (=
      ($FVF.lookup_int (as sm@226@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@226@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))))))) r))
  :qid |qp.fvfValDef190|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@33@04 r) V@15@04) (<= 0 (inv@33@04 r)))
    (=
      ($FVF.lookup_int (as sm@226@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04)))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@226@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04)))))))))))))))) r))
  :qid |qp.fvfValDef191|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04)))))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@226@04  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef192|)))
(assert (forall ((i1@219@04 Int) (j@220@04 Int)) (!
  (implies
    (and
      (and
        (and (and (< j@220@04 V@15@04) (<= 0 j@220@04)) (< i1@219@04 V@15@04))
        (<= 0 i1@219@04))
      (< $Perm.No $k@221@04))
    (and
      (=
        (inv@224@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@222@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@219@04))) j@220@04))
        i1@219@04)
      (=
        (inv@225@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@222@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@219@04))) j@220@04))
        j@220@04)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@222@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@219@04))) j@220@04))
  :qid |int-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and
          (and (< (inv@225@04 r) V@15@04) (<= 0 (inv@225@04 r)))
          (< (inv@224@04 r) V@15@04))
        (<= 0 (inv@224@04 r)))
      (< $Perm.No $k@221@04))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@222@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) (inv@224@04 r)))) (inv@225@04 r))
      r))
  :pattern ((inv@224@04 r))
  :pattern ((inv@225@04 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (iff
    (Set_in r ($FVF.domain_int (as sm@229@04  $FVF<Int>)))
    (and
      (and
        (and
          (and (< (inv@225@04 r) V@15@04) (<= 0 (inv@225@04 r)))
          (< (inv@224@04 r) V@15@04))
        (<= 0 (inv@224@04 r)))
      (< $Perm.No $k@221@04)))
  :pattern ((Set_in r ($FVF.domain_int (as sm@229@04  $FVF<Int>))))
  :qid |qp.fvfDomDef197|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and
          (and
            (and (< (inv@225@04 r) V@15@04) (<= 0 (inv@225@04 r)))
            (< (inv@224@04 r) V@15@04))
          (<= 0 (inv@224@04 r)))
        (< $Perm.No $k@221@04))
      (and
        (and
          (and (< (inv@30@04 r) V@15@04) (<= 0 (inv@30@04 r)))
          (< (inv@29@04 r) V@15@04))
        (<= 0 (inv@29@04 r))))
    (=
      ($FVF.lookup_int (as sm@229@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@229@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))))))) r))
  :qid |qp.fvfValDef194|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and
          (and
            (and (< (inv@225@04 r) V@15@04) (<= 0 (inv@225@04 r)))
            (< (inv@224@04 r) V@15@04))
          (<= 0 (inv@224@04 r)))
        (< $Perm.No $k@221@04))
      (and (< (inv@33@04 r) V@15@04) (<= 0 (inv@33@04 r))))
    (=
      ($FVF.lookup_int (as sm@229@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04)))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@229@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04)))))))))))))))) r))
  :qid |qp.fvfValDef195|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04)))))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@229@04  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef196|)))
(assert (and
  (forall ((i1@201@04 Int)) (!
    (< i1@201@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
    :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@201@04))
    :qid |option$array$-aux|))
  (forall ((r $Ref)) (!
    (implies
      (and (< (inv@203@04 r) V@15@04) (<= 0 (inv@203@04 r)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@204@04  $FVF<option<array>>) r) r))
    :pattern ((inv@203@04 r))
    ))
  (forall ((r $Ref)) (!
    (implies
      (not
        (=
          (ite
            (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
            $k@20@04
            $Perm.No)
          $Perm.No))
      (ite
        (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
        (<
          (ite
            (and (< (inv@203@04 r) V@15@04) (<= 0 (inv@203@04 r)))
            $k@202@04
            $Perm.No)
          $k@20@04)
        (<
          (ite
            (and (< (inv@203@04 r) V@15@04) (<= 0 (inv@203@04 r)))
            $k@202@04
            $Perm.No)
          $Perm.No)))
    :pattern ((inv@21@04 r))
    :pattern ((inv@203@04 r))
    :qid |qp.srp166|))
  (forall ((i1@207@04 Int)) (!
    (implies
      (and (< i1@207@04 V@15@04) (<= 0 i1@207@04))
      (not
        (=
          ($FVF.lookup_option$array$ (as sm@208@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@207@04))
          (as None<option<array>>  option<array>))))
    
    :qid |prog.l<no position>|))
  (forall ((i1@210@04 Int)) (!
    (implies
      (and (< i1@210@04 V@15@04) (<= 0 i1@210@04))
      (=
        (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@211@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@210@04))))
        V@15@04))
    
    :qid |prog.l<no position>|))
  (forall ((i1@213@04 Int)) (!
    (forall ((i2@214@04 Int)) (!
      (implies
        (and
          (and
            (and
              (and
                (=
                  ($FVF.lookup_option$array$ (as sm@215@04  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@213@04))
                  ($FVF.lookup_option$array$ (as sm@217@04  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@214@04)))
                (< i2@214@04 V@15@04))
              (<= 0 i2@214@04))
            (< i1@213@04 V@15@04))
          (<= 0 i1@213@04))
        (= i1@213@04 i2@214@04))
      :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@214@04))
      :qid |prog.l<no position>|))
    
    :qid |prog.l<no position>|))
  (forall ((i1@219@04 Int) (j@220@04 Int)) (!
    (and
      (< i1@219@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@222@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@219@04)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@219@04))
      (not
        (=
          ($FVF.lookup_option$array$ (as sm@222@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@219@04))
          (as None<option<array>>  option<array>)))
      (<
        j@220@04
        (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@222@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@219@04))))))
    :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@222@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@219@04))) j@220@04))
    :qid |int-aux|))
  (forall ((r $Ref)) (!
    (implies
      (and
        (and
          (and (< (inv@225@04 r) V@15@04) (<= 0 (inv@225@04 r)))
          (< (inv@224@04 r) V@15@04))
        (<= 0 (inv@224@04 r)))
      ($FVF.loc_int ($FVF.lookup_int (as sm@226@04  $FVF<Int>) r) r))
    :pattern ((inv@224@04 r) (inv@225@04 r))
    ))
  (forall ((r $Ref)) (!
    (implies
      (not
        (=
          (ite
            (and
              (and
                (and (< (inv@30@04 r) V@15@04) (<= 0 (inv@30@04 r)))
                (< (inv@29@04 r) V@15@04))
              (<= 0 (inv@29@04 r)))
            $Perm.Write
            $Perm.No)
          $Perm.No))
      (ite
        (and
          (and
            (and (< (inv@30@04 r) V@15@04) (<= 0 (inv@30@04 r)))
            (< (inv@29@04 r) V@15@04))
          (<= 0 (inv@29@04 r)))
        (<
          (ite
            (and
              (and
                (and (< (inv@225@04 r) V@15@04) (<= 0 (inv@225@04 r)))
                (< (inv@224@04 r) V@15@04))
              (<= 0 (inv@224@04 r)))
            $k@221@04
            $Perm.No)
          $Perm.Write)
        (<
          (ite
            (and
              (and
                (and (< (inv@225@04 r) V@15@04) (<= 0 (inv@225@04 r)))
                (< (inv@224@04 r) V@15@04))
              (<= 0 (inv@224@04 r)))
            $k@221@04
            $Perm.No)
          $Perm.No)))
    :pattern ((inv@30@04 r))
    :pattern ((inv@29@04 r))
    :pattern ((inv@225@04 r))
    :pattern ((inv@224@04 r))
    :qid |qp.srp193|))))
(set-option :timeout 0)
(push) ; 3
(assert (not (FlowNetwork1 ($Snap.combine
  $Snap.unit
  ($Snap.combine
    $Snap.unit
    ($Snap.combine
      $Snap.unit
      ($Snap.combine
        ($SortWrappers.$FVF<option<array>>To$Snap (as sm@206@04  $FVF<option<array>>))
        ($Snap.combine
          $Snap.unit
          ($Snap.combine
            $Snap.unit
            ($Snap.combine
              $Snap.unit
              ($SortWrappers.$FVF<Int>To$Snap (as sm@229@04  $FVF<Int>))))))))) this@9@04 G@11@04 V@15@04 s@12@04 t@13@04)))
(check-sat)
; unsat
(pop) ; 3
; 1.56s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               143294
;  :arith-add-rows          57438
;  :arith-assert-diseq      1093
;  :arith-assert-lower      25758
;  :arith-assert-upper      20896
;  :arith-bound-prop        4330
;  :arith-conflicts         269
;  :arith-eq-adapter        19532
;  :arith-fixed-eqs         19415
;  :arith-offset-eqs        12219
;  :arith-pivots            16696
;  :conflicts               1012
;  :datatype-accessor-ax    122
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               8133
;  :del-clause              383109
;  :final-checks            5
;  :max-generation          11
;  :max-memory              43.03
;  :memory                  41.00
;  :minimized-lits          88
;  :mk-bool-var             390468
;  :mk-clause               383706
;  :num-allocs              1595875
;  :num-checks              196
;  :propagations            85287
;  :quant-instantiations    142738
;  :restarts                1
;  :rlimit-count            4933435
;  :time                    1.56)
(assert (FlowNetwork1 ($Snap.combine
  $Snap.unit
  ($Snap.combine
    $Snap.unit
    ($Snap.combine
      $Snap.unit
      ($Snap.combine
        ($SortWrappers.$FVF<option<array>>To$Snap (as sm@206@04  $FVF<option<array>>))
        ($Snap.combine
          $Snap.unit
          ($Snap.combine
            $Snap.unit
            ($Snap.combine
              $Snap.unit
              ($SortWrappers.$FVF<Int>To$Snap (as sm@229@04  $FVF<Int>))))))))) this@9@04 G@11@04 V@15@04 s@12@04 t@13@04))
; [exec]
; label loop
; [exec]
; excBeforeLoop := exc
; [exec]
; exc, res1 := hasAugmentingPath(this, tid, G, V, s, t, P)
; [eval] this != null
; [eval] Gf != (None(): option[array])
; [eval] (None(): option[array])
; [eval] alen(opt_get1(Gf)) == V
; [eval] alen(opt_get1(Gf))
; [eval] opt_get1(Gf)
(push) ; 3
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 3
; Joined path conditions
(declare-const i1@230@04 Int)
(push) ; 3
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 4
; [then-branch: 112 | 0 <= i1@230@04 | live]
; [else-branch: 112 | !(0 <= i1@230@04) | live]
(push) ; 5
; [then-branch: 112 | 0 <= i1@230@04]
(assert (<= 0 i1@230@04))
; [eval] i1 < V
(pop) ; 5
(push) ; 5
; [else-branch: 112 | !(0 <= i1@230@04)]
(assert (not (<= 0 i1@230@04)))
(pop) ; 5
(pop) ; 4
; Joined path conditions
; Joined path conditions
(assert (and (< i1@230@04 V@15@04) (<= 0 i1@230@04)))
(declare-const $k@231@04 $Perm)
(assert ($Perm.isReadVar $k@231@04 $Perm.Write))
; [eval] aloc(opt_get1(Gf), i1)
; [eval] opt_get1(Gf)
(push) ; 4
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 4
; Joined path conditions
(push) ; 4
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 5
(assert (not (< i1@230@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               143353
;  :arith-add-rows          57443
;  :arith-assert-diseq      1094
;  :arith-assert-lower      25762
;  :arith-assert-upper      20897
;  :arith-bound-prop        4330
;  :arith-conflicts         269
;  :arith-eq-adapter        19534
;  :arith-fixed-eqs         19415
;  :arith-offset-eqs        12219
;  :arith-pivots            16696
;  :conflicts               1012
;  :datatype-accessor-ax    136
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               8133
;  :del-clause              383109
;  :final-checks            5
;  :max-generation          11
;  :max-memory              43.03
;  :memory                  41.02
;  :minimized-lits          88
;  :mk-bool-var             390750
;  :mk-clause               383943
;  :num-allocs              1597221
;  :num-checks              197
;  :propagations            85316
;  :quant-instantiations    142788
;  :restarts                1
;  :rlimit-count            4936757)
(assert (< i1@230@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(pop) ; 4
; Joined path conditions
(assert (< i1@230@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(pop) ; 3
(declare-fun inv@232@04 ($Ref) Int)
; Nested auxiliary terms: globals
(assert ($Perm.isReadVar $k@231@04 $Perm.Write))
; Nested auxiliary terms: non-globals
(assert (forall ((i1@230@04 Int)) (!
  (< i1@230@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@230@04))
  :qid |option$array$-aux|)))
(push) ; 3
(assert (not (forall ((i1@230@04 Int)) (!
  (implies
    (and (< i1@230@04 V@15@04) (<= 0 i1@230@04))
    (or (= $k@231@04 $Perm.No) (< $Perm.No $k@231@04)))
  
  ))))
(check-sat)
; unsat
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               143353
;  :arith-add-rows          57444
;  :arith-assert-diseq      1095
;  :arith-assert-lower      25764
;  :arith-assert-upper      20898
;  :arith-bound-prop        4330
;  :arith-conflicts         269
;  :arith-eq-adapter        19535
;  :arith-fixed-eqs         19415
;  :arith-offset-eqs        12219
;  :arith-pivots            16696
;  :conflicts               1013
;  :datatype-accessor-ax    136
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               8133
;  :del-clause              383111
;  :final-checks            5
;  :max-generation          11
;  :max-memory              43.03
;  :memory                  41.02
;  :minimized-lits          88
;  :mk-bool-var             390757
;  :mk-clause               383945
;  :num-allocs              1597652
;  :num-checks              198
;  :propagations            85317
;  :quant-instantiations    142788
;  :restarts                1
;  :rlimit-count            4937303)
(declare-const sm@233@04 $FVF<option<array>>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
      (< $Perm.No $k@20@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@233@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@233@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r))
  :qid |qp.fvfValDef198|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r)
  :pattern (($FVF.lookup_option$array$ (as sm@233@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef199|)))
; Check receiver injectivity
(push) ; 3
(assert (not (forall ((i11@230@04 Int) (i12@230@04 Int)) (!
  (implies
    (and
      (and
        (and
          (and (< i11@230@04 V@15@04) (<= 0 i11@230@04))
          ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@233@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i11@230@04)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i11@230@04)))
        (< $Perm.No $k@231@04))
      (and
        (and
          (and (< i12@230@04 V@15@04) (<= 0 i12@230@04))
          ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@233@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i12@230@04)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i12@230@04)))
        (< $Perm.No $k@231@04))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i11@230@04)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i12@230@04)))
    (= i11@230@04 i12@230@04))
  
  :qid |option$array$-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 3
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               143391
;  :arith-add-rows          57453
;  :arith-assert-diseq      1096
;  :arith-assert-lower      25768
;  :arith-assert-upper      20898
;  :arith-bound-prop        4330
;  :arith-conflicts         269
;  :arith-eq-adapter        19536
;  :arith-fixed-eqs         19415
;  :arith-offset-eqs        12219
;  :arith-pivots            16700
;  :conflicts               1014
;  :datatype-accessor-ax    136
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               8133
;  :del-clause              383118
;  :final-checks            5
;  :max-generation          11
;  :max-memory              43.03
;  :memory                  41.48
;  :minimized-lits          88
;  :mk-bool-var             390823
;  :mk-clause               383952
;  :num-allocs              1598834
;  :num-checks              199
;  :propagations            85317
;  :quant-instantiations    142849
;  :restarts                1
;  :rlimit-count            4940592
;  :time                    0.01)
; Definitional axioms for inverse functions
(assert (forall ((i1@230@04 Int)) (!
  (implies
    (and (and (< i1@230@04 V@15@04) (<= 0 i1@230@04)) (< $Perm.No $k@231@04))
    (=
      (inv@232@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@230@04))
      i1@230@04))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@230@04))
  :qid |option$array$-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and (< (inv@232@04 r) V@15@04) (<= 0 (inv@232@04 r)))
      (< $Perm.No $k@231@04))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) (inv@232@04 r))
      r))
  :pattern ((inv@232@04 r))
  :qid |option$array$-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@232@04 r) V@15@04) (<= 0 (inv@232@04 r)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@233@04  $FVF<option<array>>) r) r))
  :pattern ((inv@232@04 r))
  )))
; Precomputing data for removing quantified permissions
(define-fun pTaken@234@04 ((r $Ref)) $Perm
  (ite
    (and (< (inv@232@04 r) V@15@04) (<= 0 (inv@232@04 r)))
    ($Perm.min
      (ite
        (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
        $k@20@04
        $Perm.No)
      $k@231@04)
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Constrain original permissions $k@231@04
(assert (forall ((r $Ref)) (!
  (implies
    (not
      (=
        (ite
          (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
          $k@20@04
          $Perm.No)
        $Perm.No))
    (ite
      (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
      (<
        (ite
          (and (< (inv@232@04 r) V@15@04) (<= 0 (inv@232@04 r)))
          $k@231@04
          $Perm.No)
        $k@20@04)
      (<
        (ite
          (and (< (inv@232@04 r) V@15@04) (<= 0 (inv@232@04 r)))
          $k@231@04
          $Perm.No)
        $Perm.No)))
  :pattern ((inv@21@04 r))
  :pattern ((inv@232@04 r))
  :qid |qp.srp200|)))
; Intermediate check if already taken enough permissions
(set-option :timeout 500)
(push) ; 3
(assert (not (forall ((r $Ref)) (!
  (implies
    (and (< (inv@232@04 r) V@15@04) (<= 0 (inv@232@04 r)))
    (= (- $k@231@04 (pTaken@234@04 r)) $Perm.No))
  
  ))))
(check-sat)
; unsat
(pop) ; 3
; 0.02s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               144899
;  :arith-add-rows          58612
;  :arith-assert-diseq      1131
;  :arith-assert-lower      26033
;  :arith-assert-upper      21069
;  :arith-bound-prop        4454
;  :arith-conflicts         272
;  :arith-eq-adapter        19754
;  :arith-fixed-eqs         19582
;  :arith-offset-eqs        12329
;  :arith-pivots            16981
;  :conflicts               1036
;  :datatype-accessor-ax    136
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               8311
;  :del-clause              389923
;  :final-checks            5
;  :max-generation          11
;  :max-memory              43.03
;  :memory                  40.37
;  :minimized-lits          90
;  :mk-bool-var             396743
;  :mk-clause               390652
;  :num-allocs              1619084
;  :num-checks              201
;  :propagations            86391
;  :quant-instantiations    144571
;  :restarts                1
;  :rlimit-count            5020586
;  :time                    0.02)
; Final check if taken enough permissions
; Done removing quantified permissions
; Definitional axioms for snapshot map values
; [eval] (forall i1: Int :: { aloc(opt_get1(Gf), i1) } 0 <= i1 && i1 < V ==> aloc(opt_get1(Gf), i1).option$array$ != (None(): option[array]))
(declare-const i1@235@04 Int)
(push) ; 3
; [eval] 0 <= i1 && i1 < V ==> aloc(opt_get1(Gf), i1).option$array$ != (None(): option[array])
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 4
; [then-branch: 113 | 0 <= i1@235@04 | live]
; [else-branch: 113 | !(0 <= i1@235@04) | live]
(push) ; 5
; [then-branch: 113 | 0 <= i1@235@04]
(assert (<= 0 i1@235@04))
; [eval] i1 < V
(pop) ; 5
(push) ; 5
; [else-branch: 113 | !(0 <= i1@235@04)]
(assert (not (<= 0 i1@235@04)))
(pop) ; 5
(pop) ; 4
; Joined path conditions
; Joined path conditions
(push) ; 4
; [then-branch: 114 | i1@235@04 < V@15@04 && 0 <= i1@235@04 | live]
; [else-branch: 114 | !(i1@235@04 < V@15@04 && 0 <= i1@235@04) | live]
(push) ; 5
; [then-branch: 114 | i1@235@04 < V@15@04 && 0 <= i1@235@04]
(assert (and (< i1@235@04 V@15@04) (<= 0 i1@235@04)))
; [eval] aloc(opt_get1(Gf), i1).option$array$ != (None(): option[array])
; [eval] aloc(opt_get1(Gf), i1)
; [eval] opt_get1(Gf)
(push) ; 6
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 6
; Joined path conditions
(push) ; 6
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 7
(assert (not (< i1@235@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               144899
;  :arith-add-rows          58613
;  :arith-assert-diseq      1131
;  :arith-assert-lower      26035
;  :arith-assert-upper      21069
;  :arith-bound-prop        4454
;  :arith-conflicts         272
;  :arith-eq-adapter        19754
;  :arith-fixed-eqs         19582
;  :arith-offset-eqs        12329
;  :arith-pivots            16981
;  :conflicts               1036
;  :datatype-accessor-ax    136
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               8311
;  :del-clause              389923
;  :final-checks            5
;  :max-generation          11
;  :max-memory              43.03
;  :memory                  40.37
;  :minimized-lits          90
;  :mk-bool-var             396745
;  :mk-clause               390652
;  :num-allocs              1619193
;  :num-checks              202
;  :propagations            86391
;  :quant-instantiations    144571
;  :restarts                1
;  :rlimit-count            5020777)
(assert (< i1@235@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(pop) ; 6
; Joined path conditions
(assert (< i1@235@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@233@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@235@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@235@04)))
(push) ; 6
(assert (not (ite
  (and
    (<
      (inv@21@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@235@04))
      V@15@04)
    (<=
      0
      (inv@21@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@235@04))))
  (< $Perm.No $k@20@04)
  false)))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               144968
;  :arith-add-rows          58648
;  :arith-assert-diseq      1131
;  :arith-assert-lower      26050
;  :arith-assert-upper      21081
;  :arith-bound-prop        4461
;  :arith-conflicts         273
;  :arith-eq-adapter        19765
;  :arith-fixed-eqs         19593
;  :arith-offset-eqs        12329
;  :arith-pivots            16993
;  :conflicts               1037
;  :datatype-accessor-ax    136
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               8311
;  :del-clause              389923
;  :final-checks            5
;  :max-generation          11
;  :max-memory              43.03
;  :memory                  40.20
;  :minimized-lits          90
;  :mk-bool-var             396989
;  :mk-clause               390811
;  :num-allocs              1620493
;  :num-checks              203
;  :propagations            86392
;  :quant-instantiations    144684
;  :restarts                1
;  :rlimit-count            5025171)
; [eval] (None(): option[array])
(pop) ; 5
(push) ; 5
; [else-branch: 114 | !(i1@235@04 < V@15@04 && 0 <= i1@235@04)]
(assert (not (and (< i1@235@04 V@15@04) (<= 0 i1@235@04))))
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (implies
  (and (< i1@235@04 V@15@04) (<= 0 i1@235@04))
  (and
    (< i1@235@04 V@15@04)
    (<= 0 i1@235@04)
    (< i1@235@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@233@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@235@04)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@235@04)))))
; Joined path conditions
(pop) ; 3
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@235@04 Int)) (!
  (implies
    (and (< i1@235@04 V@15@04) (<= 0 i1@235@04))
    (and
      (< i1@235@04 V@15@04)
      (<= 0 i1@235@04)
      (< i1@235@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@233@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@235@04)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@235@04))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@235@04))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(push) ; 3
(assert (not (forall ((i1@235@04 Int)) (!
  (implies
    (and (< i1@235@04 V@15@04) (<= 0 i1@235@04))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@233@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@235@04))
        (as None<option<array>>  option<array>))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@235@04))
  :qid |prog.l<no position>|))))
(check-sat)
; unsat
(pop) ; 3
; 0.02s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               145661
;  :arith-add-rows          59085
;  :arith-assert-diseq      1140
;  :arith-assert-lower      26182
;  :arith-assert-upper      21177
;  :arith-bound-prop        4515
;  :arith-conflicts         274
;  :arith-eq-adapter        19871
;  :arith-fixed-eqs         19686
;  :arith-offset-eqs        12396
;  :arith-pivots            17114
;  :conflicts               1055
;  :datatype-accessor-ax    136
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               8404
;  :del-clause              393653
;  :final-checks            5
;  :max-generation          11
;  :max-memory              43.03
;  :memory                  40.19
;  :minimized-lits          90
;  :mk-bool-var             399990
;  :mk-clause               394382
;  :num-allocs              1630232
;  :num-checks              204
;  :propagations            86906
;  :quant-instantiations    145636
;  :restarts                1
;  :rlimit-count            5066722
;  :time                    0.02)
(assert (forall ((i1@235@04 Int)) (!
  (implies
    (and (< i1@235@04 V@15@04) (<= 0 i1@235@04))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@233@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@235@04))
        (as None<option<array>>  option<array>))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@235@04))
  :qid |prog.l<no position>|)))
; [eval] (forall i1: Int :: { alen(opt_get1(aloc(opt_get1(Gf), i1).option$array$)) } 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(Gf), i1).option$array$)) == V)
(declare-const i1@236@04 Int)
(push) ; 3
; [eval] 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(Gf), i1).option$array$)) == V
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 4
; [then-branch: 115 | 0 <= i1@236@04 | live]
; [else-branch: 115 | !(0 <= i1@236@04) | live]
(push) ; 5
; [then-branch: 115 | 0 <= i1@236@04]
(assert (<= 0 i1@236@04))
; [eval] i1 < V
(pop) ; 5
(push) ; 5
; [else-branch: 115 | !(0 <= i1@236@04)]
(assert (not (<= 0 i1@236@04)))
(pop) ; 5
(pop) ; 4
; Joined path conditions
; Joined path conditions
(push) ; 4
; [then-branch: 116 | i1@236@04 < V@15@04 && 0 <= i1@236@04 | live]
; [else-branch: 116 | !(i1@236@04 < V@15@04 && 0 <= i1@236@04) | live]
(push) ; 5
; [then-branch: 116 | i1@236@04 < V@15@04 && 0 <= i1@236@04]
(assert (and (< i1@236@04 V@15@04) (<= 0 i1@236@04)))
; [eval] alen(opt_get1(aloc(opt_get1(Gf), i1).option$array$)) == V
; [eval] alen(opt_get1(aloc(opt_get1(Gf), i1).option$array$))
; [eval] opt_get1(aloc(opt_get1(Gf), i1).option$array$)
; [eval] aloc(opt_get1(Gf), i1)
; [eval] opt_get1(Gf)
(push) ; 6
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 6
; Joined path conditions
(push) ; 6
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 7
(assert (not (< i1@236@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               145661
;  :arith-add-rows          59086
;  :arith-assert-diseq      1140
;  :arith-assert-lower      26184
;  :arith-assert-upper      21177
;  :arith-bound-prop        4515
;  :arith-conflicts         274
;  :arith-eq-adapter        19871
;  :arith-fixed-eqs         19686
;  :arith-offset-eqs        12396
;  :arith-pivots            17115
;  :conflicts               1055
;  :datatype-accessor-ax    136
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               8404
;  :del-clause              393653
;  :final-checks            5
;  :max-generation          11
;  :max-memory              43.03
;  :memory                  40.19
;  :minimized-lits          90
;  :mk-bool-var             399993
;  :mk-clause               394382
;  :num-allocs              1630532
;  :num-checks              205
;  :propagations            86906
;  :quant-instantiations    145636
;  :restarts                1
;  :rlimit-count            5067227)
(assert (< i1@236@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(pop) ; 6
; Joined path conditions
(assert (< i1@236@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@233@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@236@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@236@04)))
(push) ; 6
(assert (not (ite
  (and
    (<
      (inv@21@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@236@04))
      V@15@04)
    (<=
      0
      (inv@21@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@236@04))))
  (< $Perm.No $k@20@04)
  false)))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               145747
;  :arith-add-rows          59128
;  :arith-assert-diseq      1140
;  :arith-assert-lower      26199
;  :arith-assert-upper      21189
;  :arith-bound-prop        4523
;  :arith-conflicts         275
;  :arith-eq-adapter        19882
;  :arith-fixed-eqs         19697
;  :arith-offset-eqs        12411
;  :arith-pivots            17127
;  :conflicts               1056
;  :datatype-accessor-ax    136
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               8404
;  :del-clause              393653
;  :final-checks            5
;  :max-generation          11
;  :max-memory              43.03
;  :memory                  40.11
;  :minimized-lits          90
;  :mk-bool-var             400238
;  :mk-clause               394541
;  :num-allocs              1631837
;  :num-checks              206
;  :propagations            86910
;  :quant-instantiations    145751
;  :restarts                1
;  :rlimit-count            5071740)
(push) ; 6
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 7
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@233@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@236@04))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               145747
;  :arith-add-rows          59128
;  :arith-assert-diseq      1140
;  :arith-assert-lower      26199
;  :arith-assert-upper      21189
;  :arith-bound-prop        4523
;  :arith-conflicts         275
;  :arith-eq-adapter        19882
;  :arith-fixed-eqs         19697
;  :arith-offset-eqs        12411
;  :arith-pivots            17127
;  :conflicts               1057
;  :datatype-accessor-ax    136
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               8404
;  :del-clause              393653
;  :final-checks            5
;  :max-generation          11
;  :max-memory              43.03
;  :memory                  40.11
;  :minimized-lits          90
;  :mk-bool-var             400238
;  :mk-clause               394541
;  :num-allocs              1631926
;  :num-checks              207
;  :propagations            86910
;  :quant-instantiations    145751
;  :restarts                1
;  :rlimit-count            5071835)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@233@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@236@04))
    (as None<option<array>>  option<array>))))
(pop) ; 6
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@233@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@236@04))
    (as None<option<array>>  option<array>))))
(pop) ; 5
(push) ; 5
; [else-branch: 116 | !(i1@236@04 < V@15@04 && 0 <= i1@236@04)]
(assert (not (and (< i1@236@04 V@15@04) (<= 0 i1@236@04))))
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (implies
  (and (< i1@236@04 V@15@04) (<= 0 i1@236@04))
  (and
    (< i1@236@04 V@15@04)
    (<= 0 i1@236@04)
    (< i1@236@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@233@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@236@04)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@236@04))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@233@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@236@04))
        (as None<option<array>>  option<array>))))))
; Joined path conditions
(pop) ; 3
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@236@04 Int)) (!
  (implies
    (and (< i1@236@04 V@15@04) (<= 0 i1@236@04))
    (and
      (< i1@236@04 V@15@04)
      (<= 0 i1@236@04)
      (< i1@236@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@233@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@236@04)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@236@04))
      (not
        (=
          ($FVF.lookup_option$array$ (as sm@233@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@236@04))
          (as None<option<array>>  option<array>)))))
  :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@233@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@236@04)))))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(push) ; 3
(assert (not (forall ((i1@236@04 Int)) (!
  (implies
    (and (< i1@236@04 V@15@04) (<= 0 i1@236@04))
    (=
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@233@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@236@04))))
      V@15@04))
  :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@233@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@236@04)))))
  :qid |prog.l<no position>|))))
(check-sat)
; unsat
(pop) ; 3
; 0.02s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               146498
;  :arith-add-rows          59563
;  :arith-assert-diseq      1151
;  :arith-assert-lower      26332
;  :arith-assert-upper      21285
;  :arith-bound-prop        4576
;  :arith-conflicts         276
;  :arith-eq-adapter        19989
;  :arith-fixed-eqs         19790
;  :arith-offset-eqs        12476
;  :arith-pivots            17246
;  :conflicts               1075
;  :datatype-accessor-ax    136
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               8497
;  :del-clause              397389
;  :final-checks            5
;  :max-generation          11
;  :max-memory              43.03
;  :memory                  40.10
;  :minimized-lits          90
;  :mk-bool-var             403252
;  :mk-clause               398118
;  :num-allocs              1641718
;  :num-checks              208
;  :propagations            87467
;  :quant-instantiations    146713
;  :restarts                1
;  :rlimit-count            5113894
;  :time                    0.02)
(assert (forall ((i1@236@04 Int)) (!
  (implies
    (and (< i1@236@04 V@15@04) (<= 0 i1@236@04))
    (=
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@233@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@236@04))))
      V@15@04))
  :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@233@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@236@04)))))
  :qid |prog.l<no position>|)))
; [eval] (forall i1: Int :: { aloc(opt_get1(Gf), i1) } (forall i2: Int :: { aloc(opt_get1(Gf), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(Gf), i1).option$array$ == aloc(opt_get1(Gf), i2).option$array$ ==> i1 == i2))
(declare-const i1@237@04 Int)
(push) ; 3
; [eval] (forall i2: Int :: { aloc(opt_get1(Gf), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(Gf), i1).option$array$ == aloc(opt_get1(Gf), i2).option$array$ ==> i1 == i2)
(declare-const i2@238@04 Int)
(push) ; 4
; [eval] 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(Gf), i1).option$array$ == aloc(opt_get1(Gf), i2).option$array$ ==> i1 == i2
; [eval] 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(Gf), i1).option$array$ == aloc(opt_get1(Gf), i2).option$array$
; [eval] 0 <= i1
(push) ; 5
; [then-branch: 117 | 0 <= i1@237@04 | live]
; [else-branch: 117 | !(0 <= i1@237@04) | live]
(push) ; 6
; [then-branch: 117 | 0 <= i1@237@04]
(assert (<= 0 i1@237@04))
; [eval] i1 < V
(push) ; 7
; [then-branch: 118 | i1@237@04 < V@15@04 | live]
; [else-branch: 118 | !(i1@237@04 < V@15@04) | live]
(push) ; 8
; [then-branch: 118 | i1@237@04 < V@15@04]
(assert (< i1@237@04 V@15@04))
; [eval] 0 <= i2
(push) ; 9
; [then-branch: 119 | 0 <= i2@238@04 | live]
; [else-branch: 119 | !(0 <= i2@238@04) | live]
(push) ; 10
; [then-branch: 119 | 0 <= i2@238@04]
(assert (<= 0 i2@238@04))
; [eval] i2 < V
(push) ; 11
; [then-branch: 120 | i2@238@04 < V@15@04 | live]
; [else-branch: 120 | !(i2@238@04 < V@15@04) | live]
(push) ; 12
; [then-branch: 120 | i2@238@04 < V@15@04]
(assert (< i2@238@04 V@15@04))
; [eval] aloc(opt_get1(Gf), i1).option$array$ == aloc(opt_get1(Gf), i2).option$array$
; [eval] aloc(opt_get1(Gf), i1)
; [eval] opt_get1(Gf)
(push) ; 13
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 13
; Joined path conditions
(push) ; 13
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 14
(assert (not (< i1@237@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))))
(check-sat)
; unsat
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               146498
;  :arith-add-rows          59565
;  :arith-assert-diseq      1151
;  :arith-assert-lower      26336
;  :arith-assert-upper      21285
;  :arith-bound-prop        4576
;  :arith-conflicts         276
;  :arith-eq-adapter        19989
;  :arith-fixed-eqs         19790
;  :arith-offset-eqs        12476
;  :arith-pivots            17246
;  :conflicts               1075
;  :datatype-accessor-ax    136
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               8497
;  :del-clause              397389
;  :final-checks            5
;  :max-generation          11
;  :max-memory              43.03
;  :memory                  40.10
;  :minimized-lits          90
;  :mk-bool-var             403257
;  :mk-clause               398118
;  :num-allocs              1642195
;  :num-checks              209
;  :propagations            87467
;  :quant-instantiations    146713
;  :restarts                1
;  :rlimit-count            5114539)
(assert (< i1@237@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(pop) ; 13
; Joined path conditions
(assert (< i1@237@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@233@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@237@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@237@04)))
(push) ; 13
(assert (not (ite
  (and
    (<
      (inv@21@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@237@04))
      V@15@04)
    (<=
      0
      (inv@21@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@237@04))))
  (< $Perm.No $k@20@04)
  false)))
(check-sat)
; unsat
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               146566
;  :arith-add-rows          59600
;  :arith-assert-diseq      1151
;  :arith-assert-lower      26351
;  :arith-assert-upper      21297
;  :arith-bound-prop        4583
;  :arith-conflicts         277
;  :arith-eq-adapter        20000
;  :arith-fixed-eqs         19801
;  :arith-offset-eqs        12476
;  :arith-pivots            17258
;  :conflicts               1076
;  :datatype-accessor-ax    136
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               8497
;  :del-clause              397389
;  :final-checks            5
;  :max-generation          11
;  :max-memory              43.03
;  :memory                  40.12
;  :minimized-lits          90
;  :mk-bool-var             403502
;  :mk-clause               398277
;  :num-allocs              1643502
;  :num-checks              210
;  :propagations            87468
;  :quant-instantiations    146828
;  :restarts                1
;  :rlimit-count            5118992)
; [eval] aloc(opt_get1(Gf), i2)
; [eval] opt_get1(Gf)
(push) ; 13
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 13
; Joined path conditions
(push) ; 13
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 14
(assert (not (< i2@238@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))))
(check-sat)
; unsat
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               146566
;  :arith-add-rows          59600
;  :arith-assert-diseq      1151
;  :arith-assert-lower      26351
;  :arith-assert-upper      21297
;  :arith-bound-prop        4583
;  :arith-conflicts         277
;  :arith-eq-adapter        20000
;  :arith-fixed-eqs         19801
;  :arith-offset-eqs        12476
;  :arith-pivots            17258
;  :conflicts               1076
;  :datatype-accessor-ax    136
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               8497
;  :del-clause              397389
;  :final-checks            5
;  :max-generation          11
;  :max-memory              43.03
;  :memory                  40.12
;  :minimized-lits          90
;  :mk-bool-var             403502
;  :mk-clause               398277
;  :num-allocs              1643528
;  :num-checks              211
;  :propagations            87468
;  :quant-instantiations    146828
;  :restarts                1
;  :rlimit-count            5119022)
(assert (< i2@238@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(pop) ; 13
; Joined path conditions
(assert (< i2@238@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@233@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@238@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@238@04)))
(push) ; 13
(assert (not (ite
  (and
    (<
      (inv@21@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@238@04))
      V@15@04)
    (<=
      0
      (inv@21@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@238@04))))
  (< $Perm.No $k@20@04)
  false)))
(check-sat)
; unsat
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               146644
;  :arith-add-rows          59637
;  :arith-assert-diseq      1151
;  :arith-assert-lower      26366
;  :arith-assert-upper      21309
;  :arith-bound-prop        4590
;  :arith-conflicts         278
;  :arith-eq-adapter        20012
;  :arith-fixed-eqs         19812
;  :arith-offset-eqs        12476
;  :arith-pivots            17270
;  :conflicts               1077
;  :datatype-accessor-ax    136
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               8497
;  :del-clause              397389
;  :final-checks            5
;  :max-generation          11
;  :max-memory              43.03
;  :memory                  40.09
;  :minimized-lits          90
;  :mk-bool-var             403713
;  :mk-clause               398416
;  :num-allocs              1644840
;  :num-checks              212
;  :propagations            87475
;  :quant-instantiations    146942
;  :restarts                1
;  :rlimit-count            5123743)
(pop) ; 12
(push) ; 12
; [else-branch: 120 | !(i2@238@04 < V@15@04)]
(assert (not (< i2@238@04 V@15@04)))
(pop) ; 12
(pop) ; 11
; Joined path conditions
(assert (implies
  (< i2@238@04 V@15@04)
  (and
    (< i2@238@04 V@15@04)
    (< i1@237@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@233@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@237@04)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@237@04))
    (< i2@238@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@233@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@238@04)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@238@04)))))
; Joined path conditions
(pop) ; 10
(push) ; 10
; [else-branch: 119 | !(0 <= i2@238@04)]
(assert (not (<= 0 i2@238@04)))
(pop) ; 10
(pop) ; 9
; Joined path conditions
(assert (implies
  (<= 0 i2@238@04)
  (and
    (<= 0 i2@238@04)
    (implies
      (< i2@238@04 V@15@04)
      (and
        (< i2@238@04 V@15@04)
        (< i1@237@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@233@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@237@04)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@237@04))
        (< i2@238@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@233@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@238@04)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@238@04)))))))
; Joined path conditions
(pop) ; 8
(push) ; 8
; [else-branch: 118 | !(i1@237@04 < V@15@04)]
(assert (not (< i1@237@04 V@15@04)))
(pop) ; 8
(pop) ; 7
; Joined path conditions
(assert (implies
  (< i1@237@04 V@15@04)
  (and
    (< i1@237@04 V@15@04)
    (implies
      (<= 0 i2@238@04)
      (and
        (<= 0 i2@238@04)
        (implies
          (< i2@238@04 V@15@04)
          (and
            (< i2@238@04 V@15@04)
            (< i1@237@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@233@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@237@04)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@237@04))
            (< i2@238@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@233@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@238@04)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@238@04)))))))))
; Joined path conditions
(pop) ; 6
(push) ; 6
; [else-branch: 117 | !(0 <= i1@237@04)]
(assert (not (<= 0 i1@237@04)))
(pop) ; 6
(pop) ; 5
; Joined path conditions
(assert (implies
  (<= 0 i1@237@04)
  (and
    (<= 0 i1@237@04)
    (implies
      (< i1@237@04 V@15@04)
      (and
        (< i1@237@04 V@15@04)
        (implies
          (<= 0 i2@238@04)
          (and
            (<= 0 i2@238@04)
            (implies
              (< i2@238@04 V@15@04)
              (and
                (< i2@238@04 V@15@04)
                (< i1@237@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@233@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@237@04)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@237@04))
                (< i2@238@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@233@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@238@04)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@238@04)))))))))))
; Joined path conditions
(push) ; 5
; [then-branch: 121 | Lookup(option$array$,sm@233@04,aloc((_, _), opt_get1(_, G@11@04), i1@237@04)) == Lookup(option$array$,sm@233@04,aloc((_, _), opt_get1(_, G@11@04), i2@238@04)) && i2@238@04 < V@15@04 && 0 <= i2@238@04 && i1@237@04 < V@15@04 && 0 <= i1@237@04 | live]
; [else-branch: 121 | !(Lookup(option$array$,sm@233@04,aloc((_, _), opt_get1(_, G@11@04), i1@237@04)) == Lookup(option$array$,sm@233@04,aloc((_, _), opt_get1(_, G@11@04), i2@238@04)) && i2@238@04 < V@15@04 && 0 <= i2@238@04 && i1@237@04 < V@15@04 && 0 <= i1@237@04) | live]
(push) ; 6
; [then-branch: 121 | Lookup(option$array$,sm@233@04,aloc((_, _), opt_get1(_, G@11@04), i1@237@04)) == Lookup(option$array$,sm@233@04,aloc((_, _), opt_get1(_, G@11@04), i2@238@04)) && i2@238@04 < V@15@04 && 0 <= i2@238@04 && i1@237@04 < V@15@04 && 0 <= i1@237@04]
(assert (and
  (and
    (and
      (and
        (=
          ($FVF.lookup_option$array$ (as sm@233@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@237@04))
          ($FVF.lookup_option$array$ (as sm@233@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@238@04)))
        (< i2@238@04 V@15@04))
      (<= 0 i2@238@04))
    (< i1@237@04 V@15@04))
  (<= 0 i1@237@04)))
; [eval] i1 == i2
(pop) ; 6
(push) ; 6
; [else-branch: 121 | !(Lookup(option$array$,sm@233@04,aloc((_, _), opt_get1(_, G@11@04), i1@237@04)) == Lookup(option$array$,sm@233@04,aloc((_, _), opt_get1(_, G@11@04), i2@238@04)) && i2@238@04 < V@15@04 && 0 <= i2@238@04 && i1@237@04 < V@15@04 && 0 <= i1@237@04)]
(assert (not
  (and
    (and
      (and
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@233@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@237@04))
            ($FVF.lookup_option$array$ (as sm@233@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@238@04)))
          (< i2@238@04 V@15@04))
        (<= 0 i2@238@04))
      (< i1@237@04 V@15@04))
    (<= 0 i1@237@04))))
(pop) ; 6
(pop) ; 5
; Joined path conditions
(assert (implies
  (and
    (and
      (and
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@233@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@237@04))
            ($FVF.lookup_option$array$ (as sm@233@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@238@04)))
          (< i2@238@04 V@15@04))
        (<= 0 i2@238@04))
      (< i1@237@04 V@15@04))
    (<= 0 i1@237@04))
  (and
    (=
      ($FVF.lookup_option$array$ (as sm@233@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@237@04))
      ($FVF.lookup_option$array$ (as sm@233@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@238@04)))
    (< i2@238@04 V@15@04)
    (<= 0 i2@238@04)
    (< i1@237@04 V@15@04)
    (<= 0 i1@237@04))))
; Joined path conditions
(pop) ; 4
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i2@238@04 Int)) (!
  (and
    (implies
      (<= 0 i1@237@04)
      (and
        (<= 0 i1@237@04)
        (implies
          (< i1@237@04 V@15@04)
          (and
            (< i1@237@04 V@15@04)
            (implies
              (<= 0 i2@238@04)
              (and
                (<= 0 i2@238@04)
                (implies
                  (< i2@238@04 V@15@04)
                  (and
                    (< i2@238@04 V@15@04)
                    (< i1@237@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
                    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@233@04  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@237@04)) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@237@04))
                    (< i2@238@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
                    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@233@04  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@238@04)) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@238@04))))))))))
    (implies
      (and
        (and
          (and
            (and
              (=
                ($FVF.lookup_option$array$ (as sm@233@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@237@04))
                ($FVF.lookup_option$array$ (as sm@233@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@238@04)))
              (< i2@238@04 V@15@04))
            (<= 0 i2@238@04))
          (< i1@237@04 V@15@04))
        (<= 0 i1@237@04))
      (and
        (=
          ($FVF.lookup_option$array$ (as sm@233@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@237@04))
          ($FVF.lookup_option$array$ (as sm@233@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@238@04)))
        (< i2@238@04 V@15@04)
        (<= 0 i2@238@04)
        (< i1@237@04 V@15@04)
        (<= 0 i1@237@04))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@238@04))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 3
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@237@04 Int)) (!
  (forall ((i2@238@04 Int)) (!
    (and
      (implies
        (<= 0 i1@237@04)
        (and
          (<= 0 i1@237@04)
          (implies
            (< i1@237@04 V@15@04)
            (and
              (< i1@237@04 V@15@04)
              (implies
                (<= 0 i2@238@04)
                (and
                  (<= 0 i2@238@04)
                  (implies
                    (< i2@238@04 V@15@04)
                    (and
                      (< i2@238@04 V@15@04)
                      (< i1@237@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
                      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@233@04  $FVF<option<array>>) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@237@04)) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@237@04))
                      (< i2@238@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
                      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@233@04  $FVF<option<array>>) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@238@04)) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@238@04))))))))))
      (implies
        (and
          (and
            (and
              (and
                (=
                  ($FVF.lookup_option$array$ (as sm@233@04  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@237@04))
                  ($FVF.lookup_option$array$ (as sm@233@04  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@238@04)))
                (< i2@238@04 V@15@04))
              (<= 0 i2@238@04))
            (< i1@237@04 V@15@04))
          (<= 0 i1@237@04))
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@233@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@237@04))
            ($FVF.lookup_option$array$ (as sm@233@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@238@04)))
          (< i2@238@04 V@15@04)
          (<= 0 i2@238@04)
          (< i1@237@04 V@15@04)
          (<= 0 i1@237@04))))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@238@04))
    :qid |prog.l<no position>-aux|))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@237@04))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(push) ; 3
(assert (not (forall ((i1@237@04 Int)) (!
  (forall ((i2@238@04 Int)) (!
    (implies
      (and
        (and
          (and
            (and
              (=
                ($FVF.lookup_option$array$ (as sm@233@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@237@04))
                ($FVF.lookup_option$array$ (as sm@233@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@238@04)))
              (< i2@238@04 V@15@04))
            (<= 0 i2@238@04))
          (< i1@237@04 V@15@04))
        (<= 0 i1@237@04))
      (= i1@237@04 i2@238@04))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@238@04))
    :qid |prog.l<no position>|))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@237@04))
  :qid |prog.l<no position>|))))
(check-sat)
; unsat
(pop) ; 3
; 0.02s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               147525
;  :arith-add-rows          60250
;  :arith-assert-diseq      1162
;  :arith-assert-lower      26524
;  :arith-assert-upper      21423
;  :arith-bound-prop        4664
;  :arith-conflicts         280
;  :arith-eq-adapter        20140
;  :arith-fixed-eqs         19922
;  :arith-offset-eqs        12558
;  :arith-pivots            17439
;  :conflicts               1095
;  :datatype-accessor-ax    136
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               8592
;  :del-clause              401748
;  :final-checks            5
;  :max-generation          11
;  :max-memory              43.03
;  :memory                  40.06
;  :minimized-lits          90
;  :mk-bool-var             407529
;  :mk-clause               402477
;  :num-allocs              1657704
;  :num-checks              213
;  :propagations            88151
;  :quant-instantiations    148124
;  :restarts                1
;  :rlimit-count            5179225
;  :time                    0.02)
(assert (forall ((i1@237@04 Int)) (!
  (forall ((i2@238@04 Int)) (!
    (implies
      (and
        (and
          (and
            (and
              (=
                ($FVF.lookup_option$array$ (as sm@233@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@237@04))
                ($FVF.lookup_option$array$ (as sm@233@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@238@04)))
              (< i2@238@04 V@15@04))
            (<= 0 i2@238@04))
          (< i1@237@04 V@15@04))
        (<= 0 i1@237@04))
      (= i1@237@04 i2@238@04))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@238@04))
    :qid |prog.l<no position>|))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@237@04))
  :qid |prog.l<no position>|)))
; [eval] p != (None(): option[array])
; [eval] (None(): option[array])
; [eval] alen(opt_get1(p)) == V
; [eval] alen(opt_get1(p))
; [eval] opt_get1(p)
(push) ; 3
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 3
; Joined path conditions
; [eval] 0 <= s
; [eval] s < V
; [eval] 0 <= t
; [eval] t < V
(declare-const i1@239@04 Int)
(declare-const j1@240@04 Int)
(push) ; 3
; [eval] 0 <= i1 && i1 < V && (0 <= j1 && j1 < V)
; [eval] 0 <= i1
(push) ; 4
; [then-branch: 122 | 0 <= i1@239@04 | live]
; [else-branch: 122 | !(0 <= i1@239@04) | live]
(push) ; 5
; [then-branch: 122 | 0 <= i1@239@04]
(assert (<= 0 i1@239@04))
; [eval] i1 < V
(push) ; 6
; [then-branch: 123 | i1@239@04 < V@15@04 | live]
; [else-branch: 123 | !(i1@239@04 < V@15@04) | live]
(push) ; 7
; [then-branch: 123 | i1@239@04 < V@15@04]
(assert (< i1@239@04 V@15@04))
; [eval] 0 <= j1
(push) ; 8
; [then-branch: 124 | 0 <= j1@240@04 | live]
; [else-branch: 124 | !(0 <= j1@240@04) | live]
(push) ; 9
; [then-branch: 124 | 0 <= j1@240@04]
(assert (<= 0 j1@240@04))
; [eval] j1 < V
(pop) ; 9
(push) ; 9
; [else-branch: 124 | !(0 <= j1@240@04)]
(assert (not (<= 0 j1@240@04)))
(pop) ; 9
(pop) ; 8
; Joined path conditions
; Joined path conditions
(pop) ; 7
(push) ; 7
; [else-branch: 123 | !(i1@239@04 < V@15@04)]
(assert (not (< i1@239@04 V@15@04)))
(pop) ; 7
(pop) ; 6
; Joined path conditions
; Joined path conditions
(pop) ; 5
(push) ; 5
; [else-branch: 122 | !(0 <= i1@239@04)]
(assert (not (<= 0 i1@239@04)))
(pop) ; 5
(pop) ; 4
; Joined path conditions
; Joined path conditions
(assert (and
  (and (and (< j1@240@04 V@15@04) (<= 0 j1@240@04)) (< i1@239@04 V@15@04))
  (<= 0 i1@239@04)))
; [eval] aloc(opt_get1(aloc(opt_get1(Gf), i1).option$array$), j1)
; [eval] opt_get1(aloc(opt_get1(Gf), i1).option$array$)
; [eval] aloc(opt_get1(Gf), i1)
; [eval] opt_get1(Gf)
(push) ; 4
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 4
; Joined path conditions
(push) ; 4
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 5
(assert (not (< i1@239@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               147525
;  :arith-add-rows          60253
;  :arith-assert-diseq      1162
;  :arith-assert-lower      26530
;  :arith-assert-upper      21423
;  :arith-bound-prop        4664
;  :arith-conflicts         280
;  :arith-eq-adapter        20140
;  :arith-fixed-eqs         19922
;  :arith-offset-eqs        12558
;  :arith-pivots            17442
;  :conflicts               1095
;  :datatype-accessor-ax    136
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               8592
;  :del-clause              401748
;  :final-checks            5
;  :max-generation          11
;  :max-memory              43.03
;  :memory                  40.06
;  :minimized-lits          90
;  :mk-bool-var             407536
;  :mk-clause               402477
;  :num-allocs              1658298
;  :num-checks              214
;  :propagations            88151
;  :quant-instantiations    148124
;  :restarts                1
;  :rlimit-count            5180244)
(assert (< i1@239@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(pop) ; 4
; Joined path conditions
(assert (< i1@239@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@233@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@239@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@239@04)))
(push) ; 4
(assert (not (ite
  (and
    (<
      (inv@21@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@239@04))
      V@15@04)
    (<=
      0
      (inv@21@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@239@04))))
  (< $Perm.No $k@20@04)
  false)))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               147593
;  :arith-add-rows          60288
;  :arith-assert-diseq      1162
;  :arith-assert-lower      26545
;  :arith-assert-upper      21435
;  :arith-bound-prop        4671
;  :arith-conflicts         281
;  :arith-eq-adapter        20151
;  :arith-fixed-eqs         19933
;  :arith-offset-eqs        12558
;  :arith-pivots            17454
;  :conflicts               1096
;  :datatype-accessor-ax    136
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               8592
;  :del-clause              401748
;  :final-checks            5
;  :max-generation          11
;  :max-memory              43.03
;  :memory                  40.08
;  :minimized-lits          90
;  :mk-bool-var             407790
;  :mk-clause               402636
;  :num-allocs              1659674
;  :num-checks              215
;  :propagations            88152
;  :quant-instantiations    148242
;  :restarts                1
;  :rlimit-count            5185016)
(push) ; 4
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 5
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@233@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@239@04))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               147593
;  :arith-add-rows          60288
;  :arith-assert-diseq      1162
;  :arith-assert-lower      26545
;  :arith-assert-upper      21435
;  :arith-bound-prop        4671
;  :arith-conflicts         281
;  :arith-eq-adapter        20151
;  :arith-fixed-eqs         19933
;  :arith-offset-eqs        12558
;  :arith-pivots            17454
;  :conflicts               1097
;  :datatype-accessor-ax    136
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               8592
;  :del-clause              401748
;  :final-checks            5
;  :max-generation          11
;  :max-memory              43.03
;  :memory                  40.08
;  :minimized-lits          90
;  :mk-bool-var             407790
;  :mk-clause               402636
;  :num-allocs              1659763
;  :num-checks              216
;  :propagations            88152
;  :quant-instantiations    148242
;  :restarts                1
;  :rlimit-count            5185111)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@233@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@239@04))
    (as None<option<array>>  option<array>))))
(pop) ; 4
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@233@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@239@04))
    (as None<option<array>>  option<array>))))
(push) ; 4
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 5
(assert (not (<
  j1@240@04
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@233@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@239@04)))))))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               147597
;  :arith-add-rows          60291
;  :arith-assert-diseq      1162
;  :arith-assert-lower      26547
;  :arith-assert-upper      21435
;  :arith-bound-prop        4673
;  :arith-conflicts         281
;  :arith-eq-adapter        20152
;  :arith-fixed-eqs         19933
;  :arith-offset-eqs        12558
;  :arith-pivots            17456
;  :conflicts               1098
;  :datatype-accessor-ax    136
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               8592
;  :del-clause              401754
;  :final-checks            5
;  :max-generation          11
;  :max-memory              43.03
;  :memory                  40.08
;  :minimized-lits          90
;  :mk-bool-var             407801
;  :mk-clause               402642
;  :num-allocs              1659953
;  :num-checks              217
;  :propagations            88152
;  :quant-instantiations    148249
;  :restarts                1
;  :rlimit-count            5185529)
(assert (<
  j1@240@04
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@233@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@239@04))))))
(pop) ; 4
; Joined path conditions
(assert (<
  j1@240@04
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@233@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@239@04))))))
(pop) ; 3
(declare-fun inv@241@04 ($Ref) Int)
(declare-fun inv@242@04 ($Ref) Int)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(assert (forall ((i1@239@04 Int) (j1@240@04 Int)) (!
  (and
    (< i1@239@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@233@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@239@04)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@239@04))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@233@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@239@04))
        (as None<option<array>>  option<array>)))
    (<
      j1@240@04
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@233@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@239@04))))))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@233@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@239@04))) j1@240@04))
  :qid |int-aux|)))
(declare-const sm@243@04 $FVF<Int>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@30@04 r) V@15@04) (<= 0 (inv@30@04 r)))
        (< (inv@29@04 r) V@15@04))
      (<= 0 (inv@29@04 r)))
    (=
      ($FVF.lookup_int (as sm@243@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@243@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))))))) r))
  :qid |qp.fvfValDef201|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@33@04 r) V@15@04) (<= 0 (inv@33@04 r)))
    (=
      ($FVF.lookup_int (as sm@243@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04)))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@243@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04)))))))))))))))) r))
  :qid |qp.fvfValDef202|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04)))))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@243@04  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef203|)))
; Check receiver injectivity
(push) ; 3
(assert (not (forall ((i11@239@04 Int) (j11@240@04 Int) (i12@239@04 Int) (j12@240@04 Int)) (!
  (implies
    (and
      (and
        (and
          (and
            (and (< j11@240@04 V@15@04) (<= 0 j11@240@04))
            (< i11@239@04 V@15@04))
          (<= 0 i11@239@04))
        ($FVF.loc_int ($FVF.lookup_int (as sm@243@04  $FVF<Int>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@233@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i11@239@04))) j11@240@04)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@233@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i11@239@04))) j11@240@04)))
      (and
        (and
          (and
            (and (< j12@240@04 V@15@04) (<= 0 j12@240@04))
            (< i12@239@04 V@15@04))
          (<= 0 i12@239@04))
        ($FVF.loc_int ($FVF.lookup_int (as sm@243@04  $FVF<Int>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@233@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i12@239@04))) j12@240@04)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@233@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i12@239@04))) j12@240@04)))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@233@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i11@239@04))) j11@240@04)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@233@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i12@239@04))) j12@240@04)))
    (and (= i11@239@04 i12@239@04) (= j11@240@04 j12@240@04)))
  
  :qid |int-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 3
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               147748
;  :arith-add-rows          60368
;  :arith-assert-diseq      1162
;  :arith-assert-lower      26568
;  :arith-assert-upper      21438
;  :arith-bound-prop        4677
;  :arith-conflicts         281
;  :arith-eq-adapter        20181
;  :arith-fixed-eqs         19935
;  :arith-offset-eqs        12564
;  :arith-pivots            17479
;  :conflicts               1099
;  :datatype-accessor-ax    136
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               8592
;  :del-clause              402415
;  :final-checks            5
;  :max-generation          11
;  :max-memory              43.03
;  :memory                  40.04
;  :minimized-lits          90
;  :mk-bool-var             408598
;  :mk-clause               403144
;  :num-allocs              1664073
;  :num-checks              218
;  :propagations            88184
;  :quant-instantiations    148577
;  :restarts                1
;  :rlimit-count            5201279
;  :time                    0.01)
; Definitional axioms for inverse functions
(assert (forall ((i1@239@04 Int) (j1@240@04 Int)) (!
  (implies
    (and
      (and (and (< j1@240@04 V@15@04) (<= 0 j1@240@04)) (< i1@239@04 V@15@04))
      (<= 0 i1@239@04))
    (and
      (=
        (inv@241@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@233@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@239@04))) j1@240@04))
        i1@239@04)
      (=
        (inv@242@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@233@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@239@04))) j1@240@04))
        j1@240@04)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@233@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@239@04))) j1@240@04))
  :qid |int-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@242@04 r) V@15@04) (<= 0 (inv@242@04 r)))
        (< (inv@241@04 r) V@15@04))
      (<= 0 (inv@241@04 r)))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@233@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) (inv@241@04 r)))) (inv@242@04 r))
      r))
  :pattern ((inv@241@04 r))
  :pattern ((inv@242@04 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@242@04 r) V@15@04) (<= 0 (inv@242@04 r)))
        (< (inv@241@04 r) V@15@04))
      (<= 0 (inv@241@04 r)))
    ($FVF.loc_int ($FVF.lookup_int (as sm@243@04  $FVF<Int>) r) r))
  :pattern ((inv@241@04 r) (inv@242@04 r))
  )))
; Precomputing data for removing quantified permissions
(define-fun pTaken@244@04 ((r $Ref)) $Perm
  (ite
    (and
      (and
        (and (< (inv@242@04 r) V@15@04) (<= 0 (inv@242@04 r)))
        (< (inv@241@04 r) V@15@04))
      (<= 0 (inv@241@04 r)))
    ($Perm.min
      (ite
        (and
          (and
            (and (< (inv@30@04 r) V@15@04) (<= 0 (inv@30@04 r)))
            (< (inv@29@04 r) V@15@04))
          (<= 0 (inv@29@04 r)))
        $Perm.Write
        $Perm.No)
      $Perm.Write)
    $Perm.No))
(define-fun pTaken@245@04 ((r $Ref)) $Perm
  (ite
    (and
      (and
        (and (< (inv@242@04 r) V@15@04) (<= 0 (inv@242@04 r)))
        (< (inv@241@04 r) V@15@04))
      (<= 0 (inv@241@04 r)))
    ($Perm.min
      (ite
        (and (< (inv@33@04 r) V@15@04) (<= 0 (inv@33@04 r)))
        $Perm.Write
        $Perm.No)
      (- $Perm.Write (pTaken@244@04 r)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 500)
(push) ; 3
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and
          (and
            (and (< (inv@30@04 r) V@15@04) (<= 0 (inv@30@04 r)))
            (< (inv@29@04 r) V@15@04))
          (<= 0 (inv@29@04 r)))
        $Perm.Write
        $Perm.No)
      (pTaken@244@04 r))
    $Perm.No)
  
  ))))
(check-sat)
; unsat
(pop) ; 3
; 0.18s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               155273
;  :arith-add-rows          65378
;  :arith-assert-diseq      1245
;  :arith-assert-lower      27968
;  :arith-assert-upper      22476
;  :arith-bound-prop        4959
;  :arith-conflicts         290
;  :arith-eq-adapter        21307
;  :arith-fixed-eqs         21058
;  :arith-offset-eqs        13185
;  :arith-pivots            18561
;  :conflicts               1119
;  :datatype-accessor-ax    136
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               9174
;  :del-clause              434403
;  :final-checks            5
;  :max-generation          11
;  :max-memory              43.03
;  :memory                  40.28
;  :minimized-lits          90
;  :mk-bool-var             440916
;  :mk-clause               435139
;  :num-allocs              1758789
;  :num-checks              220
;  :propagations            94656
;  :quant-instantiations    159211
;  :restarts                1
;  :rlimit-count            5515261
;  :time                    0.18)
; Intermediate check if already taken enough permissions
(push) ; 3
(assert (not (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@242@04 r) V@15@04) (<= 0 (inv@242@04 r)))
        (< (inv@241@04 r) V@15@04))
      (<= 0 (inv@241@04 r)))
    (= (- $Perm.Write (pTaken@244@04 r)) $Perm.No))
  
  ))))
(check-sat)
; unsat
(pop) ; 3
; 0.03s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               156449
;  :arith-add-rows          66148
;  :arith-assert-diseq      1256
;  :arith-assert-lower      28159
;  :arith-assert-upper      22621
;  :arith-bound-prop        5029
;  :arith-conflicts         294
;  :arith-eq-adapter        21452
;  :arith-fixed-eqs         21203
;  :arith-offset-eqs        13296
;  :arith-pivots            18735
;  :conflicts               1138
;  :datatype-accessor-ax    136
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               9260
;  :del-clause              438332
;  :final-checks            5
;  :max-generation          11
;  :max-memory              43.03
;  :memory                  40.26
;  :minimized-lits          90
;  :mk-bool-var             444587
;  :mk-clause               439068
;  :num-allocs              1770839
;  :num-checks              221
;  :propagations            95357
;  :quant-instantiations    160345
;  :restarts                1
;  :rlimit-count            5571110
;  :time                    0.03)
; Final check if taken enough permissions
; Done removing quantified permissions
; Definitional axioms for snapshot map values
(declare-const i1@246@04 Int)
(push) ; 3
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 4
; [then-branch: 125 | 0 <= i1@246@04 | live]
; [else-branch: 125 | !(0 <= i1@246@04) | live]
(push) ; 5
; [then-branch: 125 | 0 <= i1@246@04]
(assert (<= 0 i1@246@04))
; [eval] i1 < V
(pop) ; 5
(push) ; 5
; [else-branch: 125 | !(0 <= i1@246@04)]
(assert (not (<= 0 i1@246@04)))
(pop) ; 5
(pop) ; 4
; Joined path conditions
; Joined path conditions
(assert (and (< i1@246@04 V@15@04) (<= 0 i1@246@04)))
; [eval] aloc(opt_get1(p), i1)
; [eval] opt_get1(p)
(push) ; 4
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 4
; Joined path conditions
(push) ; 4
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 5
(assert (not (< i1@246@04 (alen<Int> (opt_get1 $Snap.unit P@14@04)))))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               156449
;  :arith-add-rows          66149
;  :arith-assert-diseq      1256
;  :arith-assert-lower      28161
;  :arith-assert-upper      22621
;  :arith-bound-prop        5029
;  :arith-conflicts         294
;  :arith-eq-adapter        21452
;  :arith-fixed-eqs         21203
;  :arith-offset-eqs        13296
;  :arith-pivots            18735
;  :conflicts               1138
;  :datatype-accessor-ax    136
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               9260
;  :del-clause              438332
;  :final-checks            5
;  :max-generation          11
;  :max-memory              43.03
;  :memory                  40.26
;  :minimized-lits          90
;  :mk-bool-var             444589
;  :mk-clause               439068
;  :num-allocs              1770948
;  :num-checks              222
;  :propagations            95357
;  :quant-instantiations    160345
;  :restarts                1
;  :rlimit-count            5571291)
(assert (< i1@246@04 (alen<Int> (opt_get1 $Snap.unit P@14@04))))
(pop) ; 4
; Joined path conditions
(assert (< i1@246@04 (alen<Int> (opt_get1 $Snap.unit P@14@04))))
(pop) ; 3
(declare-fun inv@247@04 ($Ref) Int)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(assert (forall ((i1@246@04 Int)) (!
  (< i1@246@04 (alen<Int> (opt_get1 $Snap.unit P@14@04)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i1@246@04))
  :qid |int-aux|)))
(declare-const sm@248@04 $FVF<Int>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@33@04 r) V@15@04) (<= 0 (inv@33@04 r)))
    (=
      ($FVF.lookup_int (as sm@248@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04)))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@248@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04)))))))))))))))) r))
  :qid |qp.fvfValDef204|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04)))))))))))))))) r) r)
  :pattern (($FVF.lookup_int (as sm@248@04  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef205|)))
; Check receiver injectivity
(push) ; 3
(assert (not (forall ((i11@246@04 Int) (i12@246@04 Int)) (!
  (implies
    (and
      (and
        (and (< i11@246@04 V@15@04) (<= 0 i11@246@04))
        ($FVF.loc_int ($FVF.lookup_int (as sm@248@04  $FVF<Int>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit P@14@04) i11@246@04)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit P@14@04) i11@246@04)))
      (and
        (and (< i12@246@04 V@15@04) (<= 0 i12@246@04))
        ($FVF.loc_int ($FVF.lookup_int (as sm@248@04  $FVF<Int>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit P@14@04) i12@246@04)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit P@14@04) i12@246@04)))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i11@246@04)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i12@246@04)))
    (= i11@246@04 i12@246@04))
  
  :qid |int-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               156465
;  :arith-add-rows          66158
;  :arith-assert-diseq      1257
;  :arith-assert-lower      28165
;  :arith-assert-upper      22621
;  :arith-bound-prop        5029
;  :arith-conflicts         294
;  :arith-eq-adapter        21453
;  :arith-fixed-eqs         21203
;  :arith-offset-eqs        13296
;  :arith-pivots            18739
;  :conflicts               1139
;  :datatype-accessor-ax    136
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               9260
;  :del-clause              438339
;  :final-checks            5
;  :max-generation          11
;  :max-memory              43.03
;  :memory                  40.17
;  :minimized-lits          90
;  :mk-bool-var             444622
;  :mk-clause               439075
;  :num-allocs              1771799
;  :num-checks              223
;  :propagations            95357
;  :quant-instantiations    160366
;  :restarts                1
;  :rlimit-count            5573486)
; Definitional axioms for inverse functions
(assert (forall ((i1@246@04 Int)) (!
  (implies
    (and (< i1@246@04 V@15@04) (<= 0 i1@246@04))
    (=
      (inv@247@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i1@246@04))
      i1@246@04))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i1@246@04))
  :qid |int-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@247@04 r) V@15@04) (<= 0 (inv@247@04 r)))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) (inv@247@04 r))
      r))
  :pattern ((inv@247@04 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@247@04 r) V@15@04) (<= 0 (inv@247@04 r)))
    ($FVF.loc_int ($FVF.lookup_int (as sm@248@04  $FVF<Int>) r) r))
  :pattern ((inv@247@04 r))
  )))
; Precomputing data for removing quantified permissions
(define-fun pTaken@249@04 ((r $Ref)) $Perm
  (ite
    (and (< (inv@247@04 r) V@15@04) (<= 0 (inv@247@04 r)))
    ($Perm.min
      (ite
        (and (< (inv@33@04 r) V@15@04) (<= 0 (inv@33@04 r)))
        $Perm.Write
        $Perm.No)
      $Perm.Write)
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 500)
(push) ; 3
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and (< (inv@33@04 r) V@15@04) (<= 0 (inv@33@04 r)))
        $Perm.Write
        $Perm.No)
      (pTaken@249@04 r))
    $Perm.No)
  
  ))))
(check-sat)
; unsat
(pop) ; 3
; 0.02s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               157782
;  :arith-add-rows          67102
;  :arith-assert-diseq      1280
;  :arith-assert-lower      28389
;  :arith-assert-upper      22780
;  :arith-bound-prop        5123
;  :arith-conflicts         295
;  :arith-eq-adapter        21637
;  :arith-fixed-eqs         21387
;  :arith-offset-eqs        13453
;  :arith-pivots            18880
;  :conflicts               1161
;  :datatype-accessor-ax    136
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               9390
;  :del-clause              443719
;  :final-checks            5
;  :max-generation          11
;  :max-memory              43.03
;  :memory                  40.14
;  :minimized-lits          90
;  :mk-bool-var             449687
;  :mk-clause               444513
;  :num-allocs              1788975
;  :num-checks              225
;  :propagations            96229
;  :quant-instantiations    161879
;  :restarts                1
;  :rlimit-count            5640552
;  :time                    0.02)
; Intermediate check if already taken enough permissions
(push) ; 3
(assert (not (forall ((r $Ref)) (!
  (implies
    (and (< (inv@247@04 r) V@15@04) (<= 0 (inv@247@04 r)))
    (= (- $Perm.Write (pTaken@249@04 r)) $Perm.No))
  
  ))))
(check-sat)
; unsat
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               157815
;  :arith-add-rows          67124
;  :arith-assert-diseq      1282
;  :arith-assert-lower      28395
;  :arith-assert-upper      22787
;  :arith-bound-prop        5124
;  :arith-conflicts         296
;  :arith-eq-adapter        21642
;  :arith-fixed-eqs         21390
;  :arith-offset-eqs        13453
;  :arith-pivots            18884
;  :conflicts               1162
;  :datatype-accessor-ax    136
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               9390
;  :del-clause              443846
;  :final-checks            5
;  :max-generation          11
;  :max-memory              43.03
;  :memory                  40.14
;  :minimized-lits          90
;  :mk-bool-var             449862
;  :mk-clause               444640
;  :num-allocs              1789742
;  :num-checks              226
;  :propagations            96236
;  :quant-instantiations    161932
;  :restarts                1
;  :rlimit-count            5643356
;  :time                    0.00)
; Final check if taken enough permissions
; Done removing quantified permissions
; Definitional axioms for snapshot map values
; [eval] valid_graph_vertices(this, p, V)
(push) ; 3
; [eval] this != null
; [eval] p != (None(): option[array])
; [eval] (None(): option[array])
; [eval] alen(opt_get1(p)) == V
; [eval] alen(opt_get1(p))
; [eval] opt_get1(p)
(push) ; 4
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 4
; Joined path conditions
(declare-const i1@250@04 Int)
(push) ; 4
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 5
; [then-branch: 126 | 0 <= i1@250@04 | live]
; [else-branch: 126 | !(0 <= i1@250@04) | live]
(push) ; 6
; [then-branch: 126 | 0 <= i1@250@04]
(assert (<= 0 i1@250@04))
; [eval] i1 < V
(pop) ; 6
(push) ; 6
; [else-branch: 126 | !(0 <= i1@250@04)]
(assert (not (<= 0 i1@250@04)))
(pop) ; 6
(pop) ; 5
; Joined path conditions
; Joined path conditions
(assert (and (< i1@250@04 V@15@04) (<= 0 i1@250@04)))
(declare-const $k@251@04 $Perm)
(assert ($Perm.isReadVar $k@251@04 $Perm.Write))
; [eval] aloc(opt_get1(p), i1)
; [eval] opt_get1(p)
(push) ; 5
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 5
; Joined path conditions
(push) ; 5
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 6
(assert (not (< i1@250@04 (alen<Int> (opt_get1 $Snap.unit P@14@04)))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               157815
;  :arith-add-rows          67125
;  :arith-assert-diseq      1283
;  :arith-assert-lower      28399
;  :arith-assert-upper      22788
;  :arith-bound-prop        5124
;  :arith-conflicts         296
;  :arith-eq-adapter        21643
;  :arith-fixed-eqs         21390
;  :arith-offset-eqs        13453
;  :arith-pivots            18885
;  :conflicts               1162
;  :datatype-accessor-ax    136
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               9390
;  :del-clause              443846
;  :final-checks            5
;  :max-generation          11
;  :max-memory              43.03
;  :memory                  40.14
;  :minimized-lits          90
;  :mk-bool-var             449868
;  :mk-clause               444642
;  :num-allocs              1789918
;  :num-checks              227
;  :propagations            96237
;  :quant-instantiations    161932
;  :restarts                1
;  :rlimit-count            5643694)
(assert (< i1@250@04 (alen<Int> (opt_get1 $Snap.unit P@14@04))))
(pop) ; 5
; Joined path conditions
(assert (< i1@250@04 (alen<Int> (opt_get1 $Snap.unit P@14@04))))
(pop) ; 4
(declare-fun inv@252@04 ($Ref) Int)
; Nested auxiliary terms: globals
(assert ($Perm.isReadVar $k@251@04 $Perm.Write))
; Nested auxiliary terms: non-globals
(assert (forall ((i1@250@04 Int)) (!
  (< i1@250@04 (alen<Int> (opt_get1 $Snap.unit P@14@04)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i1@250@04))
  :qid |int-aux|)))
(push) ; 4
(assert (not (forall ((i1@250@04 Int)) (!
  (implies
    (and (< i1@250@04 V@15@04) (<= 0 i1@250@04))
    (or (= $k@251@04 $Perm.No) (< $Perm.No $k@251@04)))
  
  ))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               157815
;  :arith-add-rows          67126
;  :arith-assert-diseq      1284
;  :arith-assert-lower      28401
;  :arith-assert-upper      22789
;  :arith-bound-prop        5124
;  :arith-conflicts         296
;  :arith-eq-adapter        21644
;  :arith-fixed-eqs         21390
;  :arith-offset-eqs        13453
;  :arith-pivots            18886
;  :conflicts               1163
;  :datatype-accessor-ax    136
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               9390
;  :del-clause              443848
;  :final-checks            5
;  :max-generation          11
;  :max-memory              43.03
;  :memory                  40.14
;  :minimized-lits          90
;  :mk-bool-var             449875
;  :mk-clause               444644
;  :num-allocs              1790346
;  :num-checks              228
;  :propagations            96238
;  :quant-instantiations    161932
;  :restarts                1
;  :rlimit-count            5644244)
(declare-const sm@253@04 $FVF<Int>)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@33@04 r) V@15@04) (<= 0 (inv@33@04 r)))
    (=
      ($FVF.lookup_int (as sm@253@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04)))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@253@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04)))))))))))))))) r))
  :qid |qp.fvfValDef206|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@30@04 r) V@15@04) (<= 0 (inv@30@04 r)))
        (< (inv@29@04 r) V@15@04))
      (<= 0 (inv@29@04 r)))
    (=
      ($FVF.lookup_int (as sm@253@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@253@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))))))) r))
  :qid |qp.fvfValDef207|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04)))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@253@04  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef208|)))
; Check receiver injectivity
(push) ; 4
(assert (not (forall ((i11@250@04 Int) (i12@250@04 Int)) (!
  (implies
    (and
      (and
        (and
          (and (< i11@250@04 V@15@04) (<= 0 i11@250@04))
          ($FVF.loc_int ($FVF.lookup_int (as sm@253@04  $FVF<Int>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit P@14@04) i11@250@04)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit P@14@04) i11@250@04)))
        (< $Perm.No $k@251@04))
      (and
        (and
          (and (< i12@250@04 V@15@04) (<= 0 i12@250@04))
          ($FVF.loc_int ($FVF.lookup_int (as sm@253@04  $FVF<Int>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit P@14@04) i12@250@04)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit P@14@04) i12@250@04)))
        (< $Perm.No $k@251@04))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i11@250@04)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i12@250@04)))
    (= i11@250@04 i12@250@04))
  
  :qid |int-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               157832
;  :arith-add-rows          67133
;  :arith-assert-diseq      1285
;  :arith-assert-lower      28405
;  :arith-assert-upper      22789
;  :arith-bound-prop        5124
;  :arith-conflicts         296
;  :arith-eq-adapter        21645
;  :arith-fixed-eqs         21390
;  :arith-offset-eqs        13453
;  :arith-pivots            18886
;  :conflicts               1164
;  :datatype-accessor-ax    136
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               9390
;  :del-clause              443859
;  :final-checks            5
;  :max-generation          11
;  :max-memory              43.03
;  :memory                  40.12
;  :minimized-lits          90
;  :mk-bool-var             449916
;  :mk-clause               444655
;  :num-allocs              1791340
;  :num-checks              229
;  :propagations            96240
;  :quant-instantiations    161958
;  :restarts                1
;  :rlimit-count            5647104)
; Definitional axioms for inverse functions
(assert (forall ((i1@250@04 Int)) (!
  (implies
    (and (and (< i1@250@04 V@15@04) (<= 0 i1@250@04)) (< $Perm.No $k@251@04))
    (=
      (inv@252@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i1@250@04))
      i1@250@04))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i1@250@04))
  :qid |int-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and (< (inv@252@04 r) V@15@04) (<= 0 (inv@252@04 r)))
      (< $Perm.No $k@251@04))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) (inv@252@04 r))
      r))
  :pattern ((inv@252@04 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@252@04 r) V@15@04) (<= 0 (inv@252@04 r)))
    ($FVF.loc_int ($FVF.lookup_int (as sm@253@04  $FVF<Int>) r) r))
  :pattern ((inv@252@04 r))
  )))
; Precomputing data for removing quantified permissions
(define-fun pTaken@254@04 ((r $Ref)) $Perm
  (ite
    (and (< (inv@252@04 r) V@15@04) (<= 0 (inv@252@04 r)))
    ($Perm.min
      (ite
        (and (< (inv@33@04 r) V@15@04) (<= 0 (inv@33@04 r)))
        $Perm.Write
        $Perm.No)
      $k@251@04)
    $Perm.No))
(define-fun pTaken@255@04 ((r $Ref)) $Perm
  (ite
    (and (< (inv@252@04 r) V@15@04) (<= 0 (inv@252@04 r)))
    ($Perm.min
      (ite
        (and
          (and
            (and (< (inv@30@04 r) V@15@04) (<= 0 (inv@30@04 r)))
            (< (inv@29@04 r) V@15@04))
          (<= 0 (inv@29@04 r)))
        $Perm.Write
        $Perm.No)
      (- $k@251@04 (pTaken@254@04 r)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Constrain original permissions $k@251@04
(assert (forall ((r $Ref)) (!
  (implies
    (not
      (=
        (ite
          (and (< (inv@33@04 r) V@15@04) (<= 0 (inv@33@04 r)))
          $Perm.Write
          $Perm.No)
        $Perm.No))
    (ite
      (and (< (inv@33@04 r) V@15@04) (<= 0 (inv@33@04 r)))
      (<
        (ite
          (and (< (inv@252@04 r) V@15@04) (<= 0 (inv@252@04 r)))
          $k@251@04
          $Perm.No)
        $Perm.Write)
      (<
        (ite
          (and (< (inv@252@04 r) V@15@04) (<= 0 (inv@252@04 r)))
          $k@251@04
          $Perm.No)
        $Perm.No)))
  :pattern ((inv@33@04 r))
  :pattern ((inv@252@04 r))
  :qid |qp.srp209|)))
; Intermediate check if already taken enough permissions
(set-option :timeout 500)
(push) ; 4
(assert (not (forall ((r $Ref)) (!
  (implies
    (and (< (inv@252@04 r) V@15@04) (<= 0 (inv@252@04 r)))
    (= (- $k@251@04 (pTaken@254@04 r)) $Perm.No))
  
  ))))
(check-sat)
; unsat
(pop) ; 4
; 0.02s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               158878
;  :arith-add-rows          67618
;  :arith-assert-diseq      1311
;  :arith-assert-lower      28600
;  :arith-assert-upper      22932
;  :arith-bound-prop        5172
;  :arith-conflicts         299
;  :arith-eq-adapter        21773
;  :arith-fixed-eqs         21568
;  :arith-offset-eqs        13592
;  :arith-pivots            18954
;  :conflicts               1185
;  :datatype-accessor-ax    136
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               9518
;  :del-clause              448810
;  :final-checks            5
;  :max-generation          11
;  :max-memory              43.03
;  :memory                  40.12
;  :minimized-lits          91
;  :mk-bool-var             453910
;  :mk-clause               449647
;  :num-allocs              1804563
;  :num-checks              231
;  :propagations            97149
;  :quant-instantiations    163214
;  :restarts                1
;  :rlimit-count            5705740
;  :time                    0.02)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@256@04 $FVF<Int>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (iff
    (Set_in r ($FVF.domain_int (as sm@256@04  $FVF<Int>)))
    (and
      (and (< (inv@252@04 r) V@15@04) (<= 0 (inv@252@04 r)))
      (< $Perm.No $k@251@04)))
  :pattern ((Set_in r ($FVF.domain_int (as sm@256@04  $FVF<Int>))))
  :qid |qp.fvfDomDef213|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@252@04 r) V@15@04) (<= 0 (inv@252@04 r)))
        (< $Perm.No $k@251@04))
      (and (< (inv@33@04 r) V@15@04) (<= 0 (inv@33@04 r))))
    (=
      ($FVF.lookup_int (as sm@256@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04)))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@256@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04)))))))))))))))) r))
  :qid |qp.fvfValDef210|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@252@04 r) V@15@04) (<= 0 (inv@252@04 r)))
        (< $Perm.No $k@251@04))
      (and
        (and
          (and (< (inv@30@04 r) V@15@04) (<= 0 (inv@30@04 r)))
          (< (inv@29@04 r) V@15@04))
        (<= 0 (inv@29@04 r))))
    (=
      ($FVF.lookup_int (as sm@256@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@256@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))))))) r))
  :qid |qp.fvfValDef211|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04)))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@256@04  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef212|)))
(pop) ; 3
; Joined path conditions
(assert ($Perm.isReadVar $k@251@04 $Perm.Write))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@33@04 r) V@15@04) (<= 0 (inv@33@04 r)))
    (=
      ($FVF.lookup_int (as sm@253@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04)))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@253@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04)))))))))))))))) r))
  :qid |qp.fvfValDef206|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@30@04 r) V@15@04) (<= 0 (inv@30@04 r)))
        (< (inv@29@04 r) V@15@04))
      (<= 0 (inv@29@04 r)))
    (=
      ($FVF.lookup_int (as sm@253@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@253@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))))))) r))
  :qid |qp.fvfValDef207|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04)))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@253@04  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef208|)))
(assert (forall ((i1@250@04 Int)) (!
  (implies
    (and (and (< i1@250@04 V@15@04) (<= 0 i1@250@04)) (< $Perm.No $k@251@04))
    (=
      (inv@252@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i1@250@04))
      i1@250@04))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i1@250@04))
  :qid |int-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and (< (inv@252@04 r) V@15@04) (<= 0 (inv@252@04 r)))
      (< $Perm.No $k@251@04))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) (inv@252@04 r))
      r))
  :pattern ((inv@252@04 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (iff
    (Set_in r ($FVF.domain_int (as sm@256@04  $FVF<Int>)))
    (and
      (and (< (inv@252@04 r) V@15@04) (<= 0 (inv@252@04 r)))
      (< $Perm.No $k@251@04)))
  :pattern ((Set_in r ($FVF.domain_int (as sm@256@04  $FVF<Int>))))
  :qid |qp.fvfDomDef213|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@252@04 r) V@15@04) (<= 0 (inv@252@04 r)))
        (< $Perm.No $k@251@04))
      (and (< (inv@33@04 r) V@15@04) (<= 0 (inv@33@04 r))))
    (=
      ($FVF.lookup_int (as sm@256@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04)))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@256@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04)))))))))))))))) r))
  :qid |qp.fvfValDef210|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@252@04 r) V@15@04) (<= 0 (inv@252@04 r)))
        (< $Perm.No $k@251@04))
      (and
        (and
          (and (< (inv@30@04 r) V@15@04) (<= 0 (inv@30@04 r)))
          (< (inv@29@04 r) V@15@04))
        (<= 0 (inv@29@04 r))))
    (=
      ($FVF.lookup_int (as sm@256@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@256@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))))))) r))
  :qid |qp.fvfValDef211|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04)))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@256@04  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef212|)))
(assert (and
  (forall ((i1@250@04 Int)) (!
    (< i1@250@04 (alen<Int> (opt_get1 $Snap.unit P@14@04)))
    :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i1@250@04))
    :qid |int-aux|))
  (forall ((r $Ref)) (!
    (implies
      (and (< (inv@252@04 r) V@15@04) (<= 0 (inv@252@04 r)))
      ($FVF.loc_int ($FVF.lookup_int (as sm@253@04  $FVF<Int>) r) r))
    :pattern ((inv@252@04 r))
    ))
  (forall ((r $Ref)) (!
    (implies
      (not
        (=
          (ite
            (and (< (inv@33@04 r) V@15@04) (<= 0 (inv@33@04 r)))
            $Perm.Write
            $Perm.No)
          $Perm.No))
      (ite
        (and (< (inv@33@04 r) V@15@04) (<= 0 (inv@33@04 r)))
        (<
          (ite
            (and (< (inv@252@04 r) V@15@04) (<= 0 (inv@252@04 r)))
            $k@251@04
            $Perm.No)
          $Perm.Write)
        (<
          (ite
            (and (< (inv@252@04 r) V@15@04) (<= 0 (inv@252@04 r)))
            $k@251@04
            $Perm.No)
          $Perm.No)))
    :pattern ((inv@33@04 r))
    :pattern ((inv@252@04 r))
    :qid |qp.srp209|))))
(set-option :timeout 0)
(push) ; 3
(assert (not (valid_graph_vertices ($Snap.combine
  $Snap.unit
  ($Snap.combine
    $Snap.unit
    ($Snap.combine
      $Snap.unit
      ($SortWrappers.$FVF<Int>To$Snap (as sm@256@04  $FVF<Int>))))) this@9@04 P@14@04 V@15@04)))
(check-sat)
; unsat
(pop) ; 3
; 2.09s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               257075
;  :arith-add-rows          122236
;  :arith-assert-diseq      2709
;  :arith-assert-lower      45393
;  :arith-assert-upper      37450
;  :arith-bound-prop        7496
;  :arith-conflicts         359
;  :arith-eq-adapter        34176
;  :arith-fixed-eqs         34939
;  :arith-offset-eqs        22002
;  :arith-pivots            27928
;  :conflicts               1280
;  :datatype-accessor-ax    155
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               15231
;  :del-clause              777163
;  :final-checks            5
;  :max-generation          11
;  :max-memory              60.52
;  :memory                  57.71
;  :minimized-lits          127
;  :mk-bool-var             767990
;  :mk-clause               777959
;  :num-allocs              2707193
;  :num-checks              232
;  :propagations            167356
;  :quant-instantiations    277063
;  :restarts                1
;  :rlimit-count            8820621
;  :time                    2.08)
(assert (valid_graph_vertices ($Snap.combine
  $Snap.unit
  ($Snap.combine
    $Snap.unit
    ($Snap.combine
      $Snap.unit
      ($SortWrappers.$FVF<Int>To$Snap (as sm@256@04  $FVF<Int>))))) this@9@04 P@14@04 V@15@04))
(declare-const exc@257@04 $Ref)
(declare-const res@258@04 Bool)
(declare-const $t@259@04 $Snap)
(assert (= $t@259@04 ($Snap.combine ($Snap.first $t@259@04) ($Snap.second $t@259@04))))
(assert (= ($Snap.first $t@259@04) $Snap.unit))
; [eval] exc == null
(assert (= exc@257@04 $Ref.null))
(assert (=
  ($Snap.second $t@259@04)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@259@04))
    ($Snap.second ($Snap.second $t@259@04)))))
(assert (= ($Snap.first ($Snap.second $t@259@04)) $Snap.unit))
; [eval] exc == null ==> Gf != (None(): option[array])
; [eval] exc == null
(push) ; 3
(set-option :timeout 10)
(push) ; 4
(assert (not (not (= exc@257@04 $Ref.null))))
(check-sat)
; unknown
(pop) ; 4
; 0.02s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               257104
;  :arith-add-rows          122239
;  :arith-assert-diseq      2709
;  :arith-assert-lower      45393
;  :arith-assert-upper      37450
;  :arith-bound-prop        7496
;  :arith-conflicts         359
;  :arith-eq-adapter        34176
;  :arith-fixed-eqs         34939
;  :arith-offset-eqs        22002
;  :arith-pivots            27928
;  :conflicts               1280
;  :datatype-accessor-ax    160
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               15231
;  :del-clause              777163
;  :final-checks            5
;  :max-generation          11
;  :max-memory              60.52
;  :memory                  57.72
;  :minimized-lits          127
;  :mk-bool-var             768099
;  :mk-clause               778050
;  :num-allocs              2707687
;  :num-checks              233
;  :propagations            167367
;  :quant-instantiations    277082
;  :restarts                1
;  :rlimit-count            8821764
;  :time                    0.02)
; [then-branch: 127 | exc@257@04 == Null | live]
; [else-branch: 127 | exc@257@04 != Null | dead]
(push) ; 4
; [then-branch: 127 | exc@257@04 == Null]
; [eval] Gf != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 4
(pop) ; 3
; Joined path conditions
(assert (implies
  (= exc@257@04 $Ref.null)
  (not (= G@11@04 (as None<option<array>>  option<array>)))))
(assert (=
  ($Snap.second ($Snap.second $t@259@04))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second $t@259@04)))
    ($Snap.second ($Snap.second ($Snap.second $t@259@04))))))
(assert (= ($Snap.first ($Snap.second ($Snap.second $t@259@04))) $Snap.unit))
; [eval] exc == null ==> alen(opt_get1(Gf)) == V
; [eval] exc == null
(push) ; 3
(push) ; 4
(assert (not (not (= exc@257@04 $Ref.null))))
(check-sat)
; unknown
(pop) ; 4
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               257566
;  :arith-add-rows          122416
;  :arith-assert-diseq      2721
;  :arith-assert-lower      45492
;  :arith-assert-upper      37517
;  :arith-bound-prop        7541
;  :arith-conflicts         359
;  :arith-eq-adapter        34260
;  :arith-fixed-eqs         35027
;  :arith-offset-eqs        22051
;  :arith-pivots            27943
;  :conflicts               1281
;  :datatype-accessor-ax    161
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               15264
;  :del-clause              779540
;  :final-checks            5
;  :max-generation          11
;  :max-memory              60.52
;  :memory                  57.53
;  :minimized-lits          129
;  :mk-bool-var             769997
;  :mk-clause               780427
;  :num-allocs              2714550
;  :num-checks              234
;  :propagations            167791
;  :quant-instantiations    277919
;  :restarts                1
;  :rlimit-count            8851315
;  :time                    0.01)
; [then-branch: 128 | exc@257@04 == Null | live]
; [else-branch: 128 | exc@257@04 != Null | dead]
(push) ; 4
; [then-branch: 128 | exc@257@04 == Null]
; [eval] alen(opt_get1(Gf)) == V
; [eval] alen(opt_get1(Gf))
; [eval] opt_get1(Gf)
(push) ; 5
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 5
; Joined path conditions
(pop) ; 4
(pop) ; 3
; Joined path conditions
(assert (implies
  (= exc@257@04 $Ref.null)
  (= (alen<Int> (opt_get1 $Snap.unit G@11@04)) V@15@04)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second $t@259@04)))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@259@04))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@259@04)))))))
; [eval] exc == null
(push) ; 3
(assert (not (not (= exc@257@04 $Ref.null))))
(check-sat)
; unknown
(pop) ; 3
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               257947
;  :arith-add-rows          122565
;  :arith-assert-diseq      2729
;  :arith-assert-lower      45573
;  :arith-assert-upper      37573
;  :arith-bound-prop        7585
;  :arith-conflicts         359
;  :arith-eq-adapter        34329
;  :arith-fixed-eqs         35104
;  :arith-offset-eqs        22100
;  :arith-pivots            27951
;  :conflicts               1282
;  :datatype-accessor-ax    162
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               15295
;  :del-clause              781412
;  :final-checks            5
;  :max-generation          11
;  :max-memory              60.52
;  :memory                  56.74
;  :minimized-lits          131
;  :mk-bool-var             771487
;  :mk-clause               782299
;  :num-allocs              2720001
;  :num-checks              235
;  :propagations            168184
;  :quant-instantiations    278578
;  :restarts                1
;  :rlimit-count            8873526
;  :time                    0.01)
; [then-branch: 129 | exc@257@04 == Null | live]
; [else-branch: 129 | exc@257@04 != Null | dead]
(push) ; 3
; [then-branch: 129 | exc@257@04 == Null]
(declare-const i1@260@04 Int)
(push) ; 4
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 5
; [then-branch: 130 | 0 <= i1@260@04 | live]
; [else-branch: 130 | !(0 <= i1@260@04) | live]
(push) ; 6
; [then-branch: 130 | 0 <= i1@260@04]
(assert (<= 0 i1@260@04))
; [eval] i1 < V
(pop) ; 6
(push) ; 6
; [else-branch: 130 | !(0 <= i1@260@04)]
(assert (not (<= 0 i1@260@04)))
(pop) ; 6
(pop) ; 5
; Joined path conditions
; Joined path conditions
(assert (and (< i1@260@04 V@15@04) (<= 0 i1@260@04)))
; [eval] aloc(opt_get1(Gf), i1)
; [eval] opt_get1(Gf)
(push) ; 5
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 5
; Joined path conditions
(push) ; 5
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 6
(assert (not (< i1@260@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               257947
;  :arith-add-rows          122566
;  :arith-assert-diseq      2729
;  :arith-assert-lower      45575
;  :arith-assert-upper      37573
;  :arith-bound-prop        7585
;  :arith-conflicts         359
;  :arith-eq-adapter        34329
;  :arith-fixed-eqs         35104
;  :arith-offset-eqs        22100
;  :arith-pivots            27951
;  :conflicts               1282
;  :datatype-accessor-ax    162
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               15295
;  :del-clause              781412
;  :final-checks            5
;  :max-generation          11
;  :max-memory              60.52
;  :memory                  56.74
;  :minimized-lits          131
;  :mk-bool-var             771489
;  :mk-clause               782299
;  :num-allocs              2720104
;  :num-checks              236
;  :propagations            168184
;  :quant-instantiations    278578
;  :restarts                1
;  :rlimit-count            8873712)
(assert (< i1@260@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(pop) ; 5
; Joined path conditions
(assert (< i1@260@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(declare-const $k@261@04 $Perm)
(assert ($Perm.isReadVar $k@261@04 $Perm.Write))
(pop) ; 4
(declare-fun inv@262@04 ($Ref) Int)
; Nested auxiliary terms: globals
(assert ($Perm.isReadVar $k@261@04 $Perm.Write))
; Nested auxiliary terms: non-globals
(assert (forall ((i1@260@04 Int)) (!
  (< i1@260@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@260@04))
  :qid |option$array$-aux|)))
(push) ; 4
(assert (not (forall ((i1@260@04 Int)) (!
  (implies
    (and (< i1@260@04 V@15@04) (<= 0 i1@260@04))
    (or (= $k@261@04 $Perm.No) (< $Perm.No $k@261@04)))
  
  ))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               257947
;  :arith-add-rows          122567
;  :arith-assert-diseq      2730
;  :arith-assert-lower      45577
;  :arith-assert-upper      37574
;  :arith-bound-prop        7585
;  :arith-conflicts         359
;  :arith-eq-adapter        34330
;  :arith-fixed-eqs         35104
;  :arith-offset-eqs        22100
;  :arith-pivots            27951
;  :conflicts               1283
;  :datatype-accessor-ax    162
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               15295
;  :del-clause              781412
;  :final-checks            5
;  :max-generation          11
;  :max-memory              60.52
;  :memory                  56.74
;  :minimized-lits          131
;  :mk-bool-var             771496
;  :mk-clause               782301
;  :num-allocs              2720573
;  :num-checks              237
;  :propagations            168185
;  :quant-instantiations    278578
;  :restarts                1
;  :rlimit-count            8874283)
; Check receiver injectivity
(push) ; 4
(assert (not (forall ((i11@260@04 Int) (i12@260@04 Int)) (!
  (implies
    (and
      (and (and (< i11@260@04 V@15@04) (<= 0 i11@260@04)) (< $Perm.No $k@261@04))
      (and (and (< i12@260@04 V@15@04) (<= 0 i12@260@04)) (< $Perm.No $k@261@04))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i11@260@04)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i12@260@04)))
    (= i11@260@04 i12@260@04))
  
  :qid |option$array$-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               257985
;  :arith-add-rows          122573
;  :arith-assert-diseq      2731
;  :arith-assert-lower      45581
;  :arith-assert-upper      37574
;  :arith-bound-prop        7585
;  :arith-conflicts         359
;  :arith-eq-adapter        34331
;  :arith-fixed-eqs         35104
;  :arith-offset-eqs        22100
;  :arith-pivots            27953
;  :conflicts               1284
;  :datatype-accessor-ax    162
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               15295
;  :del-clause              781418
;  :final-checks            5
;  :max-generation          11
;  :max-memory              60.52
;  :memory                  56.37
;  :minimized-lits          131
;  :mk-bool-var             771556
;  :mk-clause               782307
;  :num-allocs              2721399
;  :num-checks              238
;  :propagations            168185
;  :quant-instantiations    278641
;  :restarts                1
;  :rlimit-count            8876729
;  :time                    0.00)
; Definitional axioms for inverse functions
(assert (forall ((i1@260@04 Int)) (!
  (implies
    (and (and (< i1@260@04 V@15@04) (<= 0 i1@260@04)) (< $Perm.No $k@261@04))
    (=
      (inv@262@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@260@04))
      i1@260@04))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@260@04))
  )))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and (< (inv@262@04 r) V@15@04) (<= 0 (inv@262@04 r)))
      (< $Perm.No $k@261@04))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) (inv@262@04 r))
      r))
  :pattern ((inv@262@04 r))
  :qid |option$array$-fctOfInv|)))
; Permissions are non-negative
(assert (forall ((i1@260@04 Int)) (!
  (<= $Perm.No $k@261@04)
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@260@04))
  :qid |option$array$-permAtLeastZero|)))
; Field permissions are at most one
(assert (forall ((i1@260@04 Int)) (!
  (<= $k@261@04 $Perm.Write)
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@260@04))
  :qid |option$array$-permAtMostOne|)))
; Permission implies non-null receiver
(assert (forall ((i1@260@04 Int)) (!
  (implies
    (and (and (< i1@260@04 V@15@04) (<= 0 i1@260@04)) (< $Perm.No $k@261@04))
    (not
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@260@04)
        $Ref.null)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@260@04))
  :qid |option$array$-permImpliesNonNull|)))
(declare-const sm@263@04 $FVF<option<array>>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@262@04 r) V@15@04) (<= 0 (inv@262@04 r)))
      (< $Perm.No $k@261@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@263@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@259@04))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@263@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@259@04))))) r))
  :qid |qp.fvfValDef214|)))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (ite
          (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
          $k@20@04
          $Perm.No)
        (pTaken@234@04 r)))
    (=
      ($FVF.lookup_option$array$ (as sm@263@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@263@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r))
  :qid |qp.fvfValDef215|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@259@04))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r))
  :pattern (($FVF.lookup_option$array$ (as sm@263@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef216|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@262@04 r) V@15@04) (<= 0 (inv@262@04 r)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@263@04  $FVF<option<array>>) r) r))
  :pattern ((inv@262@04 r))
  )))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@259@04))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@259@04)))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@259@04))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@259@04)))))
  $Snap.unit))
; [eval] exc == null ==> (forall i1: Int :: { aloc(opt_get1(Gf), i1) } 0 <= i1 && i1 < V ==> aloc(opt_get1(Gf), i1).option$array$ != (None(): option[array]))
; [eval] exc == null
(push) ; 4
(set-option :timeout 10)
(push) ; 5
(assert (not (not (= exc@257@04 $Ref.null))))
(check-sat)
; unknown
(pop) ; 5
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               258352
;  :arith-add-rows          122728
;  :arith-assert-diseq      2739
;  :arith-assert-lower      45661
;  :arith-assert-upper      37632
;  :arith-bound-prop        7630
;  :arith-conflicts         359
;  :arith-eq-adapter        34381
;  :arith-fixed-eqs         35182
;  :arith-offset-eqs        22148
;  :arith-pivots            27963
;  :conflicts               1285
;  :datatype-accessor-ax    163
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               15325
;  :del-clause              782984
;  :final-checks            5
;  :max-generation          11
;  :max-memory              60.52
;  :memory                  56.18
;  :minimized-lits          133
;  :mk-bool-var             772856
;  :mk-clause               783873
;  :num-allocs              2727154
;  :num-checks              239
;  :propagations            168564
;  :quant-instantiations    279124
;  :restarts                1
;  :rlimit-count            8899812
;  :time                    0.01)
; [then-branch: 131 | exc@257@04 == Null | live]
; [else-branch: 131 | exc@257@04 != Null | dead]
(push) ; 5
; [then-branch: 131 | exc@257@04 == Null]
; [eval] (forall i1: Int :: { aloc(opt_get1(Gf), i1) } 0 <= i1 && i1 < V ==> aloc(opt_get1(Gf), i1).option$array$ != (None(): option[array]))
(declare-const i1@264@04 Int)
(push) ; 6
; [eval] 0 <= i1 && i1 < V ==> aloc(opt_get1(Gf), i1).option$array$ != (None(): option[array])
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 7
; [then-branch: 132 | 0 <= i1@264@04 | live]
; [else-branch: 132 | !(0 <= i1@264@04) | live]
(push) ; 8
; [then-branch: 132 | 0 <= i1@264@04]
(assert (<= 0 i1@264@04))
; [eval] i1 < V
(pop) ; 8
(push) ; 8
; [else-branch: 132 | !(0 <= i1@264@04)]
(assert (not (<= 0 i1@264@04)))
(pop) ; 8
(pop) ; 7
; Joined path conditions
; Joined path conditions
(push) ; 7
; [then-branch: 133 | i1@264@04 < V@15@04 && 0 <= i1@264@04 | live]
; [else-branch: 133 | !(i1@264@04 < V@15@04 && 0 <= i1@264@04) | live]
(push) ; 8
; [then-branch: 133 | i1@264@04 < V@15@04 && 0 <= i1@264@04]
(assert (and (< i1@264@04 V@15@04) (<= 0 i1@264@04)))
; [eval] aloc(opt_get1(Gf), i1).option$array$ != (None(): option[array])
; [eval] aloc(opt_get1(Gf), i1)
; [eval] opt_get1(Gf)
(push) ; 9
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 9
; Joined path conditions
(push) ; 9
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 10
(assert (not (< i1@264@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               258352
;  :arith-add-rows          122729
;  :arith-assert-diseq      2739
;  :arith-assert-lower      45663
;  :arith-assert-upper      37632
;  :arith-bound-prop        7630
;  :arith-conflicts         359
;  :arith-eq-adapter        34381
;  :arith-fixed-eqs         35182
;  :arith-offset-eqs        22148
;  :arith-pivots            27963
;  :conflicts               1285
;  :datatype-accessor-ax    163
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               15325
;  :del-clause              782984
;  :final-checks            5
;  :max-generation          11
;  :max-memory              60.52
;  :memory                  56.18
;  :minimized-lits          133
;  :mk-bool-var             772858
;  :mk-clause               783873
;  :num-allocs              2727257
;  :num-checks              240
;  :propagations            168564
;  :quant-instantiations    279124
;  :restarts                1
;  :rlimit-count            8900008)
(assert (< i1@264@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(pop) ; 9
; Joined path conditions
(assert (< i1@264@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@263@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@264@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@264@04)))
(push) ; 9
(assert (not (<
  $Perm.No
  (+
    (ite
      (and
        (<
          (inv@262@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@264@04))
          V@15@04)
        (<=
          0
          (inv@262@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@264@04))))
      $k@261@04
      $Perm.No)
    (-
      (ite
        (and
          (<
            (inv@21@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@264@04))
            V@15@04)
          (<=
            0
            (inv@21@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@264@04))))
        $k@20@04
        $Perm.No)
      (pTaken@234@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@264@04)))))))
(check-sat)
; unsat
(pop) ; 9
; 0.03s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               259144
;  :arith-add-rows          123405
;  :arith-assert-diseq      2757
;  :arith-assert-lower      45805
;  :arith-assert-upper      37727
;  :arith-bound-prop        7711
;  :arith-conflicts         362
;  :arith-eq-adapter        34503
;  :arith-fixed-eqs         35295
;  :arith-offset-eqs        22228
;  :arith-pivots            28034
;  :conflicts               1304
;  :datatype-accessor-ax    163
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               15429
;  :del-clause              787832
;  :final-checks            5
;  :max-generation          11
;  :max-memory              60.52
;  :memory                  56.11
;  :minimized-lits          135
;  :mk-bool-var             776974
;  :mk-clause               788942
;  :num-allocs              2740441
;  :num-checks              241
;  :propagations            169340
;  :quant-instantiations    280432
;  :restarts                1
;  :rlimit-count            8952894
;  :time                    0.03)
; [eval] (None(): option[array])
(pop) ; 8
(push) ; 8
; [else-branch: 133 | !(i1@264@04 < V@15@04 && 0 <= i1@264@04)]
(assert (not (and (< i1@264@04 V@15@04) (<= 0 i1@264@04))))
(pop) ; 8
(pop) ; 7
; Joined path conditions
(assert (implies
  (and (< i1@264@04 V@15@04) (<= 0 i1@264@04))
  (and
    (< i1@264@04 V@15@04)
    (<= 0 i1@264@04)
    (< i1@264@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@263@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@264@04)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@264@04)))))
; Joined path conditions
(pop) ; 6
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@264@04 Int)) (!
  (implies
    (and (< i1@264@04 V@15@04) (<= 0 i1@264@04))
    (and
      (< i1@264@04 V@15@04)
      (<= 0 i1@264@04)
      (< i1@264@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@263@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@264@04)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@264@04))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@264@04))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (implies
  (= exc@257@04 $Ref.null)
  (forall ((i1@264@04 Int)) (!
    (implies
      (and (< i1@264@04 V@15@04) (<= 0 i1@264@04))
      (and
        (< i1@264@04 V@15@04)
        (<= 0 i1@264@04)
        (< i1@264@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@263@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@264@04)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@264@04))))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@264@04))
    :qid |prog.l<no position>-aux|))))
(assert (implies
  (= exc@257@04 $Ref.null)
  (forall ((i1@264@04 Int)) (!
    (implies
      (and (< i1@264@04 V@15@04) (<= 0 i1@264@04))
      (not
        (=
          ($FVF.lookup_option$array$ (as sm@263@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@264@04))
          (as None<option<array>>  option<array>))))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@264@04))
    :qid |prog.l<no position>|))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@259@04)))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@259@04))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@259@04)))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@259@04))))))
  $Snap.unit))
; [eval] exc == null ==> (forall i1: Int :: { alen(opt_get1(aloc(opt_get1(Gf), i1).option$array$)) } 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(Gf), i1).option$array$)) == V)
; [eval] exc == null
(push) ; 4
(set-option :timeout 10)
(push) ; 5
(assert (not (not (= exc@257@04 $Ref.null))))
(check-sat)
; unknown
(pop) ; 5
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               259335
;  :arith-add-rows          123536
;  :arith-assert-diseq      2764
;  :arith-assert-lower      45863
;  :arith-assert-upper      37770
;  :arith-bound-prop        7720
;  :arith-conflicts         362
;  :arith-eq-adapter        34541
;  :arith-fixed-eqs         35347
;  :arith-offset-eqs        22254
;  :arith-pivots            28058
;  :conflicts               1304
;  :datatype-accessor-ax    164
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               15459
;  :del-clause              789409
;  :final-checks            5
;  :max-generation          11
;  :max-memory              60.52
;  :memory                  56.04
;  :minimized-lits          135
;  :mk-bool-var             778065
;  :mk-clause               790298
;  :num-allocs              2744418
;  :num-checks              242
;  :propagations            169509
;  :quant-instantiations    280822
;  :restarts                1
;  :rlimit-count            8969400
;  :time                    0.01)
; [then-branch: 134 | exc@257@04 == Null | live]
; [else-branch: 134 | exc@257@04 != Null | dead]
(push) ; 5
; [then-branch: 134 | exc@257@04 == Null]
; [eval] (forall i1: Int :: { alen(opt_get1(aloc(opt_get1(Gf), i1).option$array$)) } 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(Gf), i1).option$array$)) == V)
(declare-const i1@265@04 Int)
(push) ; 6
; [eval] 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(Gf), i1).option$array$)) == V
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 7
; [then-branch: 135 | 0 <= i1@265@04 | live]
; [else-branch: 135 | !(0 <= i1@265@04) | live]
(push) ; 8
; [then-branch: 135 | 0 <= i1@265@04]
(assert (<= 0 i1@265@04))
; [eval] i1 < V
(pop) ; 8
(push) ; 8
; [else-branch: 135 | !(0 <= i1@265@04)]
(assert (not (<= 0 i1@265@04)))
(pop) ; 8
(pop) ; 7
; Joined path conditions
; Joined path conditions
(push) ; 7
; [then-branch: 136 | i1@265@04 < V@15@04 && 0 <= i1@265@04 | live]
; [else-branch: 136 | !(i1@265@04 < V@15@04 && 0 <= i1@265@04) | live]
(push) ; 8
; [then-branch: 136 | i1@265@04 < V@15@04 && 0 <= i1@265@04]
(assert (and (< i1@265@04 V@15@04) (<= 0 i1@265@04)))
; [eval] alen(opt_get1(aloc(opt_get1(Gf), i1).option$array$)) == V
; [eval] alen(opt_get1(aloc(opt_get1(Gf), i1).option$array$))
; [eval] opt_get1(aloc(opt_get1(Gf), i1).option$array$)
; [eval] aloc(opt_get1(Gf), i1)
; [eval] opt_get1(Gf)
(push) ; 9
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 9
; Joined path conditions
(push) ; 9
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 10
(assert (not (< i1@265@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               259335
;  :arith-add-rows          123537
;  :arith-assert-diseq      2764
;  :arith-assert-lower      45865
;  :arith-assert-upper      37770
;  :arith-bound-prop        7720
;  :arith-conflicts         362
;  :arith-eq-adapter        34541
;  :arith-fixed-eqs         35347
;  :arith-offset-eqs        22254
;  :arith-pivots            28059
;  :conflicts               1304
;  :datatype-accessor-ax    164
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               15459
;  :del-clause              789409
;  :final-checks            5
;  :max-generation          11
;  :max-memory              60.52
;  :memory                  56.04
;  :minimized-lits          135
;  :mk-bool-var             778067
;  :mk-clause               790298
;  :num-allocs              2744521
;  :num-checks              243
;  :propagations            169509
;  :quant-instantiations    280822
;  :restarts                1
;  :rlimit-count            8969601)
(assert (< i1@265@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(pop) ; 9
; Joined path conditions
(assert (< i1@265@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@263@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@265@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@265@04)))
(push) ; 9
(assert (not (<
  $Perm.No
  (+
    (ite
      (and
        (<
          (inv@262@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@265@04))
          V@15@04)
        (<=
          0
          (inv@262@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@265@04))))
      $k@261@04
      $Perm.No)
    (-
      (ite
        (and
          (<
            (inv@21@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@265@04))
            V@15@04)
          (<=
            0
            (inv@21@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@265@04))))
        $k@20@04
        $Perm.No)
      (pTaken@234@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@265@04)))))))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               259568
;  :arith-add-rows          123637
;  :arith-assert-diseq      2776
;  :arith-assert-lower      45933
;  :arith-assert-upper      37802
;  :arith-bound-prop        7757
;  :arith-conflicts         364
;  :arith-eq-adapter        34580
;  :arith-fixed-eqs         35375
;  :arith-offset-eqs        22273
;  :arith-pivots            28105
;  :conflicts               1308
;  :datatype-accessor-ax    164
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               15462
;  :del-clause              789503
;  :final-checks            5
;  :max-generation          11
;  :max-memory              60.52
;  :memory                  56.04
;  :minimized-lits          135
;  :mk-bool-var             778502
;  :mk-clause               790613
;  :num-allocs              2746599
;  :num-checks              244
;  :propagations            169597
;  :quant-instantiations    280975
;  :restarts                1
;  :rlimit-count            8977358
;  :time                    0.00)
(push) ; 9
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 10
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@263@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@265@04))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               259568
;  :arith-add-rows          123637
;  :arith-assert-diseq      2776
;  :arith-assert-lower      45933
;  :arith-assert-upper      37802
;  :arith-bound-prop        7757
;  :arith-conflicts         364
;  :arith-eq-adapter        34580
;  :arith-fixed-eqs         35375
;  :arith-offset-eqs        22273
;  :arith-pivots            28105
;  :conflicts               1309
;  :datatype-accessor-ax    164
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               15462
;  :del-clause              789503
;  :final-checks            5
;  :max-generation          11
;  :max-memory              60.52
;  :memory                  56.04
;  :minimized-lits          135
;  :mk-bool-var             778502
;  :mk-clause               790613
;  :num-allocs              2746689
;  :num-checks              245
;  :propagations            169597
;  :quant-instantiations    280975
;  :restarts                1
;  :rlimit-count            8977453)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@263@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@265@04))
    (as None<option<array>>  option<array>))))
(pop) ; 9
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@263@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@265@04))
    (as None<option<array>>  option<array>))))
(pop) ; 8
(push) ; 8
; [else-branch: 136 | !(i1@265@04 < V@15@04 && 0 <= i1@265@04)]
(assert (not (and (< i1@265@04 V@15@04) (<= 0 i1@265@04))))
(pop) ; 8
(pop) ; 7
; Joined path conditions
(assert (implies
  (and (< i1@265@04 V@15@04) (<= 0 i1@265@04))
  (and
    (< i1@265@04 V@15@04)
    (<= 0 i1@265@04)
    (< i1@265@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@263@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@265@04)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@265@04))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@263@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@265@04))
        (as None<option<array>>  option<array>))))))
; Joined path conditions
(pop) ; 6
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@265@04 Int)) (!
  (implies
    (and (< i1@265@04 V@15@04) (<= 0 i1@265@04))
    (and
      (< i1@265@04 V@15@04)
      (<= 0 i1@265@04)
      (< i1@265@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@263@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@265@04)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@265@04))
      (not
        (=
          ($FVF.lookup_option$array$ (as sm@263@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@265@04))
          (as None<option<array>>  option<array>)))))
  :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@263@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@265@04)))))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (implies
  (= exc@257@04 $Ref.null)
  (forall ((i1@265@04 Int)) (!
    (implies
      (and (< i1@265@04 V@15@04) (<= 0 i1@265@04))
      (and
        (< i1@265@04 V@15@04)
        (<= 0 i1@265@04)
        (< i1@265@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@263@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@265@04)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@265@04))
        (not
          (=
            ($FVF.lookup_option$array$ (as sm@263@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@265@04))
            (as None<option<array>>  option<array>)))))
    :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@263@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@265@04)))))
    :qid |prog.l<no position>-aux|))))
(assert (implies
  (= exc@257@04 $Ref.null)
  (forall ((i1@265@04 Int)) (!
    (implies
      (and (< i1@265@04 V@15@04) (<= 0 i1@265@04))
      (=
        (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@263@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@265@04))))
        V@15@04))
    :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@263@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@265@04)))))
    :qid |prog.l<no position>|))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@259@04))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@259@04)))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@259@04))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@259@04)))))))
  $Snap.unit))
; [eval] exc == null ==> (forall i1: Int :: { aloc(opt_get1(Gf), i1) } (forall i2: Int :: { aloc(opt_get1(Gf), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(Gf), i1).option$array$ == aloc(opt_get1(Gf), i2).option$array$ ==> i1 == i2))
; [eval] exc == null
(push) ; 4
(set-option :timeout 10)
(push) ; 5
(assert (not (not (= exc@257@04 $Ref.null))))
(check-sat)
; unknown
(pop) ; 5
; 0.02s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               259945
;  :arith-add-rows          123802
;  :arith-assert-diseq      2784
;  :arith-assert-lower      46013
;  :arith-assert-upper      37859
;  :arith-bound-prop        7802
;  :arith-conflicts         364
;  :arith-eq-adapter        34640
;  :arith-fixed-eqs         35453
;  :arith-offset-eqs        22322
;  :arith-pivots            28132
;  :conflicts               1310
;  :datatype-accessor-ax    165
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               15493
;  :del-clause              791405
;  :final-checks            5
;  :max-generation          11
;  :max-memory              60.52
;  :memory                  53.78
;  :minimized-lits          137
;  :mk-bool-var             779907
;  :mk-clause               792294
;  :num-allocs              2751910
;  :num-checks              246
;  :propagations            169983
;  :quant-instantiations    281513
;  :restarts                1
;  :rlimit-count            8999843
;  :time                    0.02)
; [then-branch: 137 | exc@257@04 == Null | live]
; [else-branch: 137 | exc@257@04 != Null | dead]
(push) ; 5
; [then-branch: 137 | exc@257@04 == Null]
; [eval] (forall i1: Int :: { aloc(opt_get1(Gf), i1) } (forall i2: Int :: { aloc(opt_get1(Gf), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(Gf), i1).option$array$ == aloc(opt_get1(Gf), i2).option$array$ ==> i1 == i2))
(declare-const i1@266@04 Int)
(push) ; 6
; [eval] (forall i2: Int :: { aloc(opt_get1(Gf), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(Gf), i1).option$array$ == aloc(opt_get1(Gf), i2).option$array$ ==> i1 == i2)
(declare-const i2@267@04 Int)
(push) ; 7
; [eval] 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(Gf), i1).option$array$ == aloc(opt_get1(Gf), i2).option$array$ ==> i1 == i2
; [eval] 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(Gf), i1).option$array$ == aloc(opt_get1(Gf), i2).option$array$
; [eval] 0 <= i1
(push) ; 8
; [then-branch: 138 | 0 <= i1@266@04 | live]
; [else-branch: 138 | !(0 <= i1@266@04) | live]
(push) ; 9
; [then-branch: 138 | 0 <= i1@266@04]
(assert (<= 0 i1@266@04))
; [eval] i1 < V
(push) ; 10
; [then-branch: 139 | i1@266@04 < V@15@04 | live]
; [else-branch: 139 | !(i1@266@04 < V@15@04) | live]
(push) ; 11
; [then-branch: 139 | i1@266@04 < V@15@04]
(assert (< i1@266@04 V@15@04))
; [eval] 0 <= i2
(push) ; 12
; [then-branch: 140 | 0 <= i2@267@04 | live]
; [else-branch: 140 | !(0 <= i2@267@04) | live]
(push) ; 13
; [then-branch: 140 | 0 <= i2@267@04]
(assert (<= 0 i2@267@04))
; [eval] i2 < V
(push) ; 14
; [then-branch: 141 | i2@267@04 < V@15@04 | live]
; [else-branch: 141 | !(i2@267@04 < V@15@04) | live]
(push) ; 15
; [then-branch: 141 | i2@267@04 < V@15@04]
(assert (< i2@267@04 V@15@04))
; [eval] aloc(opt_get1(Gf), i1).option$array$ == aloc(opt_get1(Gf), i2).option$array$
; [eval] aloc(opt_get1(Gf), i1)
; [eval] opt_get1(Gf)
(push) ; 16
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 16
; Joined path conditions
(push) ; 16
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 17
(assert (not (< i1@266@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))))
(check-sat)
; unsat
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               259945
;  :arith-add-rows          123804
;  :arith-assert-diseq      2784
;  :arith-assert-lower      46017
;  :arith-assert-upper      37859
;  :arith-bound-prop        7802
;  :arith-conflicts         364
;  :arith-eq-adapter        34640
;  :arith-fixed-eqs         35453
;  :arith-offset-eqs        22322
;  :arith-pivots            28133
;  :conflicts               1310
;  :datatype-accessor-ax    165
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               15493
;  :del-clause              791405
;  :final-checks            5
;  :max-generation          11
;  :max-memory              60.52
;  :memory                  53.79
;  :minimized-lits          137
;  :mk-bool-var             779911
;  :mk-clause               792294
;  :num-allocs              2752192
;  :num-checks              247
;  :propagations            169983
;  :quant-instantiations    281513
;  :restarts                1
;  :rlimit-count            9000190)
(assert (< i1@266@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(pop) ; 16
; Joined path conditions
(assert (< i1@266@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@263@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@266@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@266@04)))
(push) ; 16
(assert (not (<
  $Perm.No
  (+
    (ite
      (and
        (<
          (inv@262@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@266@04))
          V@15@04)
        (<=
          0
          (inv@262@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@266@04))))
      $k@261@04
      $Perm.No)
    (-
      (ite
        (and
          (<
            (inv@21@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@266@04))
            V@15@04)
          (<=
            0
            (inv@21@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@266@04))))
        $k@20@04
        $Perm.No)
      (pTaken@234@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@266@04)))))))
(check-sat)
; unsat
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               260208
;  :arith-add-rows          123924
;  :arith-assert-diseq      2795
;  :arith-assert-lower      46086
;  :arith-assert-upper      37889
;  :arith-bound-prop        7837
;  :arith-conflicts         367
;  :arith-eq-adapter        34677
;  :arith-fixed-eqs         35480
;  :arith-offset-eqs        22351
;  :arith-pivots            28177
;  :conflicts               1316
;  :datatype-accessor-ax    165
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               15519
;  :del-clause              791940
;  :final-checks            5
;  :max-generation          11
;  :max-memory              60.52
;  :memory                  53.85
;  :minimized-lits          138
;  :mk-bool-var             780615
;  :mk-clause               793050
;  :num-allocs              2755058
;  :num-checks              248
;  :propagations            170135
;  :quant-instantiations    281712
;  :restarts                1
;  :rlimit-count            9012571
;  :time                    0.00)
; [eval] aloc(opt_get1(Gf), i2)
; [eval] opt_get1(Gf)
(push) ; 16
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 16
; Joined path conditions
(push) ; 16
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 17
(assert (not (< i2@267@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))))
(check-sat)
; unsat
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               260208
;  :arith-add-rows          123924
;  :arith-assert-diseq      2795
;  :arith-assert-lower      46086
;  :arith-assert-upper      37889
;  :arith-bound-prop        7837
;  :arith-conflicts         367
;  :arith-eq-adapter        34677
;  :arith-fixed-eqs         35480
;  :arith-offset-eqs        22351
;  :arith-pivots            28177
;  :conflicts               1316
;  :datatype-accessor-ax    165
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               15519
;  :del-clause              791940
;  :final-checks            5
;  :max-generation          11
;  :max-memory              60.52
;  :memory                  53.85
;  :minimized-lits          138
;  :mk-bool-var             780615
;  :mk-clause               793050
;  :num-allocs              2755084
;  :num-checks              249
;  :propagations            170135
;  :quant-instantiations    281712
;  :restarts                1
;  :rlimit-count            9012601)
(assert (< i2@267@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(pop) ; 16
; Joined path conditions
(assert (< i2@267@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@263@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@267@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@267@04)))
(push) ; 16
(assert (not (<
  $Perm.No
  (+
    (ite
      (and
        (<
          (inv@262@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@267@04))
          V@15@04)
        (<=
          0
          (inv@262@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@267@04))))
      $k@261@04
      $Perm.No)
    (-
      (ite
        (and
          (<
            (inv@21@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@267@04))
            V@15@04)
          (<=
            0
            (inv@21@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@267@04))))
        $k@20@04
        $Perm.No)
      (pTaken@234@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@267@04)))))))
(check-sat)
; unsat
(pop) ; 16
; 0.03s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               261254
;  :arith-add-rows          124681
;  :arith-assert-diseq      2830
;  :arith-assert-lower      46312
;  :arith-assert-upper      38012
;  :arith-bound-prop        7941
;  :arith-conflicts         375
;  :arith-eq-adapter        34857
;  :arith-fixed-eqs         35612
;  :arith-offset-eqs        22450
;  :arith-pivots            28270
;  :conflicts               1340
;  :datatype-accessor-ax    165
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               15675
;  :del-clause              798197
;  :final-checks            5
;  :max-generation          11
;  :max-memory              60.52
;  :memory                  54.13
;  :minimized-lits          141
;  :mk-bool-var             785592
;  :mk-clause               799484
;  :num-allocs              2771636
;  :num-checks              250
;  :propagations            171227
;  :quant-instantiations    283241
;  :restarts                1
;  :rlimit-count            9086240
;  :time                    0.03)
(pop) ; 15
(push) ; 15
; [else-branch: 141 | !(i2@267@04 < V@15@04)]
(assert (not (< i2@267@04 V@15@04)))
(pop) ; 15
(pop) ; 14
; Joined path conditions
(assert (implies
  (< i2@267@04 V@15@04)
  (and
    (< i2@267@04 V@15@04)
    (< i1@266@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@263@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@266@04)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@266@04))
    (< i2@267@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@263@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@267@04)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@267@04)))))
; Joined path conditions
(pop) ; 13
(push) ; 13
; [else-branch: 140 | !(0 <= i2@267@04)]
(assert (not (<= 0 i2@267@04)))
(pop) ; 13
(pop) ; 12
; Joined path conditions
(assert (implies
  (<= 0 i2@267@04)
  (and
    (<= 0 i2@267@04)
    (implies
      (< i2@267@04 V@15@04)
      (and
        (< i2@267@04 V@15@04)
        (< i1@266@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@263@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@266@04)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@266@04))
        (< i2@267@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@263@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@267@04)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@267@04)))))))
; Joined path conditions
(pop) ; 11
(push) ; 11
; [else-branch: 139 | !(i1@266@04 < V@15@04)]
(assert (not (< i1@266@04 V@15@04)))
(pop) ; 11
(pop) ; 10
; Joined path conditions
(assert (implies
  (< i1@266@04 V@15@04)
  (and
    (< i1@266@04 V@15@04)
    (implies
      (<= 0 i2@267@04)
      (and
        (<= 0 i2@267@04)
        (implies
          (< i2@267@04 V@15@04)
          (and
            (< i2@267@04 V@15@04)
            (< i1@266@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@263@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@266@04)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@266@04))
            (< i2@267@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@263@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@267@04)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@267@04)))))))))
; Joined path conditions
(pop) ; 9
(push) ; 9
; [else-branch: 138 | !(0 <= i1@266@04)]
(assert (not (<= 0 i1@266@04)))
(pop) ; 9
(pop) ; 8
; Joined path conditions
(assert (implies
  (<= 0 i1@266@04)
  (and
    (<= 0 i1@266@04)
    (implies
      (< i1@266@04 V@15@04)
      (and
        (< i1@266@04 V@15@04)
        (implies
          (<= 0 i2@267@04)
          (and
            (<= 0 i2@267@04)
            (implies
              (< i2@267@04 V@15@04)
              (and
                (< i2@267@04 V@15@04)
                (< i1@266@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@263@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@266@04)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@266@04))
                (< i2@267@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@263@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@267@04)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@267@04)))))))))))
; Joined path conditions
(push) ; 8
; [then-branch: 142 | Lookup(option$array$,sm@263@04,aloc((_, _), opt_get1(_, G@11@04), i1@266@04)) == Lookup(option$array$,sm@263@04,aloc((_, _), opt_get1(_, G@11@04), i2@267@04)) && i2@267@04 < V@15@04 && 0 <= i2@267@04 && i1@266@04 < V@15@04 && 0 <= i1@266@04 | live]
; [else-branch: 142 | !(Lookup(option$array$,sm@263@04,aloc((_, _), opt_get1(_, G@11@04), i1@266@04)) == Lookup(option$array$,sm@263@04,aloc((_, _), opt_get1(_, G@11@04), i2@267@04)) && i2@267@04 < V@15@04 && 0 <= i2@267@04 && i1@266@04 < V@15@04 && 0 <= i1@266@04) | live]
(push) ; 9
; [then-branch: 142 | Lookup(option$array$,sm@263@04,aloc((_, _), opt_get1(_, G@11@04), i1@266@04)) == Lookup(option$array$,sm@263@04,aloc((_, _), opt_get1(_, G@11@04), i2@267@04)) && i2@267@04 < V@15@04 && 0 <= i2@267@04 && i1@266@04 < V@15@04 && 0 <= i1@266@04]
(assert (and
  (and
    (and
      (and
        (=
          ($FVF.lookup_option$array$ (as sm@263@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@266@04))
          ($FVF.lookup_option$array$ (as sm@263@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@267@04)))
        (< i2@267@04 V@15@04))
      (<= 0 i2@267@04))
    (< i1@266@04 V@15@04))
  (<= 0 i1@266@04)))
; [eval] i1 == i2
(pop) ; 9
(push) ; 9
; [else-branch: 142 | !(Lookup(option$array$,sm@263@04,aloc((_, _), opt_get1(_, G@11@04), i1@266@04)) == Lookup(option$array$,sm@263@04,aloc((_, _), opt_get1(_, G@11@04), i2@267@04)) && i2@267@04 < V@15@04 && 0 <= i2@267@04 && i1@266@04 < V@15@04 && 0 <= i1@266@04)]
(assert (not
  (and
    (and
      (and
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@263@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@266@04))
            ($FVF.lookup_option$array$ (as sm@263@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@267@04)))
          (< i2@267@04 V@15@04))
        (<= 0 i2@267@04))
      (< i1@266@04 V@15@04))
    (<= 0 i1@266@04))))
(pop) ; 9
(pop) ; 8
; Joined path conditions
(assert (implies
  (and
    (and
      (and
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@263@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@266@04))
            ($FVF.lookup_option$array$ (as sm@263@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@267@04)))
          (< i2@267@04 V@15@04))
        (<= 0 i2@267@04))
      (< i1@266@04 V@15@04))
    (<= 0 i1@266@04))
  (and
    (=
      ($FVF.lookup_option$array$ (as sm@263@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@266@04))
      ($FVF.lookup_option$array$ (as sm@263@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@267@04)))
    (< i2@267@04 V@15@04)
    (<= 0 i2@267@04)
    (< i1@266@04 V@15@04)
    (<= 0 i1@266@04))))
; Joined path conditions
(pop) ; 7
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i2@267@04 Int)) (!
  (and
    (implies
      (<= 0 i1@266@04)
      (and
        (<= 0 i1@266@04)
        (implies
          (< i1@266@04 V@15@04)
          (and
            (< i1@266@04 V@15@04)
            (implies
              (<= 0 i2@267@04)
              (and
                (<= 0 i2@267@04)
                (implies
                  (< i2@267@04 V@15@04)
                  (and
                    (< i2@267@04 V@15@04)
                    (< i1@266@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
                    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@263@04  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@266@04)) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@266@04))
                    (< i2@267@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
                    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@263@04  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@267@04)) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@267@04))))))))))
    (implies
      (and
        (and
          (and
            (and
              (=
                ($FVF.lookup_option$array$ (as sm@263@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@266@04))
                ($FVF.lookup_option$array$ (as sm@263@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@267@04)))
              (< i2@267@04 V@15@04))
            (<= 0 i2@267@04))
          (< i1@266@04 V@15@04))
        (<= 0 i1@266@04))
      (and
        (=
          ($FVF.lookup_option$array$ (as sm@263@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@266@04))
          ($FVF.lookup_option$array$ (as sm@263@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@267@04)))
        (< i2@267@04 V@15@04)
        (<= 0 i2@267@04)
        (< i1@266@04 V@15@04)
        (<= 0 i1@266@04))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@267@04))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 6
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@266@04 Int)) (!
  (forall ((i2@267@04 Int)) (!
    (and
      (implies
        (<= 0 i1@266@04)
        (and
          (<= 0 i1@266@04)
          (implies
            (< i1@266@04 V@15@04)
            (and
              (< i1@266@04 V@15@04)
              (implies
                (<= 0 i2@267@04)
                (and
                  (<= 0 i2@267@04)
                  (implies
                    (< i2@267@04 V@15@04)
                    (and
                      (< i2@267@04 V@15@04)
                      (< i1@266@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
                      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@263@04  $FVF<option<array>>) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@266@04)) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@266@04))
                      (< i2@267@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
                      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@263@04  $FVF<option<array>>) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@267@04)) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@267@04))))))))))
      (implies
        (and
          (and
            (and
              (and
                (=
                  ($FVF.lookup_option$array$ (as sm@263@04  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@266@04))
                  ($FVF.lookup_option$array$ (as sm@263@04  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@267@04)))
                (< i2@267@04 V@15@04))
              (<= 0 i2@267@04))
            (< i1@266@04 V@15@04))
          (<= 0 i1@266@04))
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@263@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@266@04))
            ($FVF.lookup_option$array$ (as sm@263@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@267@04)))
          (< i2@267@04 V@15@04)
          (<= 0 i2@267@04)
          (< i1@266@04 V@15@04)
          (<= 0 i1@266@04))))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@267@04))
    :qid |prog.l<no position>-aux|))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@266@04))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (implies
  (= exc@257@04 $Ref.null)
  (forall ((i1@266@04 Int)) (!
    (forall ((i2@267@04 Int)) (!
      (and
        (implies
          (<= 0 i1@266@04)
          (and
            (<= 0 i1@266@04)
            (implies
              (< i1@266@04 V@15@04)
              (and
                (< i1@266@04 V@15@04)
                (implies
                  (<= 0 i2@267@04)
                  (and
                    (<= 0 i2@267@04)
                    (implies
                      (< i2@267@04 V@15@04)
                      (and
                        (< i2@267@04 V@15@04)
                        (< i1@266@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
                        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@263@04  $FVF<option<array>>) (aloc ($Snap.combine
                          $Snap.unit
                          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@266@04)) (aloc ($Snap.combine
                          $Snap.unit
                          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@266@04))
                        (< i2@267@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
                        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@263@04  $FVF<option<array>>) (aloc ($Snap.combine
                          $Snap.unit
                          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@267@04)) (aloc ($Snap.combine
                          $Snap.unit
                          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@267@04))))))))))
        (implies
          (and
            (and
              (and
                (and
                  (=
                    ($FVF.lookup_option$array$ (as sm@263@04  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@266@04))
                    ($FVF.lookup_option$array$ (as sm@263@04  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@267@04)))
                  (< i2@267@04 V@15@04))
                (<= 0 i2@267@04))
              (< i1@266@04 V@15@04))
            (<= 0 i1@266@04))
          (and
            (=
              ($FVF.lookup_option$array$ (as sm@263@04  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@266@04))
              ($FVF.lookup_option$array$ (as sm@263@04  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@267@04)))
            (< i2@267@04 V@15@04)
            (<= 0 i2@267@04)
            (< i1@266@04 V@15@04)
            (<= 0 i1@266@04))))
      :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@267@04))
      :qid |prog.l<no position>-aux|))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@266@04))
    :qid |prog.l<no position>-aux|))))
(assert (implies
  (= exc@257@04 $Ref.null)
  (forall ((i1@266@04 Int)) (!
    (forall ((i2@267@04 Int)) (!
      (implies
        (and
          (and
            (and
              (and
                (=
                  ($FVF.lookup_option$array$ (as sm@263@04  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@266@04))
                  ($FVF.lookup_option$array$ (as sm@263@04  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@267@04)))
                (< i2@267@04 V@15@04))
              (<= 0 i2@267@04))
            (< i1@266@04 V@15@04))
          (<= 0 i1@266@04))
        (= i1@266@04 i2@267@04))
      :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@267@04))
      :qid |prog.l<no position>|))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@266@04))
    :qid |prog.l<no position>|))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@259@04)))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@259@04))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@259@04)))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@259@04))))))))
  $Snap.unit))
; [eval] exc == null ==> p != (None(): option[array])
; [eval] exc == null
(push) ; 4
(set-option :timeout 10)
(push) ; 5
(assert (not (not (= exc@257@04 $Ref.null))))
(check-sat)
; unknown
(pop) ; 5
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               261567
;  :arith-add-rows          124847
;  :arith-assert-diseq      2838
;  :arith-assert-lower      46392
;  :arith-assert-upper      38069
;  :arith-bound-prop        7986
;  :arith-conflicts         375
;  :arith-eq-adapter        34907
;  :arith-fixed-eqs         35690
;  :arith-offset-eqs        22498
;  :arith-pivots            28311
;  :conflicts               1340
;  :datatype-accessor-ax    166
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               15705
;  :del-clause              800280
;  :final-checks            5
;  :max-generation          11
;  :max-memory              60.52
;  :memory                  54.17
;  :minimized-lits          141
;  :mk-bool-var             786982
;  :mk-clause               801169
;  :num-allocs              2777944
;  :num-checks              251
;  :propagations            171516
;  :quant-instantiations    283758
;  :restarts                1
;  :rlimit-count            9113277
;  :time                    0.01)
; [then-branch: 143 | exc@257@04 == Null | live]
; [else-branch: 143 | exc@257@04 != Null | dead]
(push) ; 5
; [then-branch: 143 | exc@257@04 == Null]
; [eval] p != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (implies
  (= exc@257@04 $Ref.null)
  (not (= P@14@04 (as None<option<array>>  option<array>)))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@259@04))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@259@04)))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@259@04))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@259@04)))))))))
  $Snap.unit))
; [eval] exc == null ==> alen(opt_get1(p)) == V
; [eval] exc == null
(push) ; 4
(push) ; 5
(assert (not (not (= exc@257@04 $Ref.null))))
(check-sat)
; unknown
(pop) ; 5
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               261944
;  :arith-add-rows          125002
;  :arith-assert-diseq      2846
;  :arith-assert-lower      46472
;  :arith-assert-upper      38126
;  :arith-bound-prop        8031
;  :arith-conflicts         375
;  :arith-eq-adapter        34958
;  :arith-fixed-eqs         35768
;  :arith-offset-eqs        22547
;  :arith-pivots            28321
;  :conflicts               1341
;  :datatype-accessor-ax    167
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               15736
;  :del-clause              802016
;  :final-checks            5
;  :max-generation          11
;  :max-memory              60.52
;  :memory                  54.01
;  :minimized-lits          143
;  :mk-bool-var             788426
;  :mk-clause               802905
;  :num-allocs              2782892
;  :num-checks              252
;  :propagations            171937
;  :quant-instantiations    284290
;  :restarts                1
;  :rlimit-count            9136198
;  :time                    0.01)
; [then-branch: 144 | exc@257@04 == Null | live]
; [else-branch: 144 | exc@257@04 != Null | dead]
(push) ; 5
; [then-branch: 144 | exc@257@04 == Null]
; [eval] alen(opt_get1(p)) == V
; [eval] alen(opt_get1(p))
; [eval] opt_get1(p)
(push) ; 6
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 6
; Joined path conditions
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (implies
  (= exc@257@04 $Ref.null)
  (= (alen<Int> (opt_get1 $Snap.unit P@14@04)) V@15@04)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@259@04)))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@259@04))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@259@04)))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@259@04))))))))))
  $Snap.unit))
; [eval] exc == null ==> 0 <= s
; [eval] exc == null
(push) ; 4
(push) ; 5
(assert (not (not (= exc@257@04 $Ref.null))))
(check-sat)
; unknown
(pop) ; 5
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               262257
;  :arith-add-rows          125144
;  :arith-assert-diseq      2854
;  :arith-assert-lower      46552
;  :arith-assert-upper      38183
;  :arith-bound-prop        8076
;  :arith-conflicts         375
;  :arith-eq-adapter        35008
;  :arith-fixed-eqs         35846
;  :arith-offset-eqs        22595
;  :arith-pivots            28331
;  :conflicts               1341
;  :datatype-accessor-ax    168
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               15766
;  :del-clause              803545
;  :final-checks            5
;  :max-generation          11
;  :max-memory              60.52
;  :memory                  54.09
;  :minimized-lits          143
;  :mk-bool-var             789719
;  :mk-clause               804434
;  :num-allocs              2788240
;  :num-checks              253
;  :propagations            172226
;  :quant-instantiations    284786
;  :restarts                1
;  :rlimit-count            9161109
;  :time                    0.01)
; [then-branch: 145 | exc@257@04 == Null | live]
; [else-branch: 145 | exc@257@04 != Null | dead]
(push) ; 5
; [then-branch: 145 | exc@257@04 == Null]
; [eval] 0 <= s
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (implies (= exc@257@04 $Ref.null) (<= 0 s@12@04)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@259@04))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@259@04)))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@259@04))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@259@04)))))))))))
  $Snap.unit))
; [eval] exc == null ==> s < V
; [eval] exc == null
(push) ; 4
(push) ; 5
(assert (not (not (= exc@257@04 $Ref.null))))
(check-sat)
; unknown
(pop) ; 5
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               262448
;  :arith-add-rows          125265
;  :arith-assert-diseq      2861
;  :arith-assert-lower      46610
;  :arith-assert-upper      38226
;  :arith-bound-prop        8085
;  :arith-conflicts         375
;  :arith-eq-adapter        35046
;  :arith-fixed-eqs         35898
;  :arith-offset-eqs        22621
;  :arith-pivots            28341
;  :conflicts               1341
;  :datatype-accessor-ax    169
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               15796
;  :del-clause              804914
;  :final-checks            5
;  :max-generation          11
;  :max-memory              60.52
;  :memory                  53.99
;  :minimized-lits          143
;  :mk-bool-var             790822
;  :mk-clause               805803
;  :num-allocs              2791908
;  :num-checks              254
;  :propagations            172395
;  :quant-instantiations    285178
;  :restarts                1
;  :rlimit-count            9177045
;  :time                    0.01)
; [then-branch: 146 | exc@257@04 == Null | live]
; [else-branch: 146 | exc@257@04 != Null | dead]
(push) ; 5
; [then-branch: 146 | exc@257@04 == Null]
; [eval] s < V
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (implies (= exc@257@04 $Ref.null) (< s@12@04 V@15@04)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@259@04)))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@259@04))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@259@04)))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@259@04))))))))))))
  $Snap.unit))
; [eval] exc == null ==> 0 <= t
; [eval] exc == null
(push) ; 4
(push) ; 5
(assert (not (not (= exc@257@04 $Ref.null))))
(check-sat)
; unknown
(pop) ; 5
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               262761
;  :arith-add-rows          125407
;  :arith-assert-diseq      2869
;  :arith-assert-lower      46690
;  :arith-assert-upper      38283
;  :arith-bound-prop        8130
;  :arith-conflicts         375
;  :arith-eq-adapter        35096
;  :arith-fixed-eqs         35976
;  :arith-offset-eqs        22669
;  :arith-pivots            28351
;  :conflicts               1341
;  :datatype-accessor-ax    170
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               15826
;  :del-clause              806431
;  :final-checks            5
;  :max-generation          11
;  :max-memory              60.52
;  :memory                  54.08
;  :minimized-lits          143
;  :mk-bool-var             792055
;  :mk-clause               807320
;  :num-allocs              2796979
;  :num-checks              255
;  :propagations            172684
;  :quant-instantiations    285622
;  :restarts                1
;  :rlimit-count            9200794
;  :time                    0.01)
; [then-branch: 147 | exc@257@04 == Null | live]
; [else-branch: 147 | exc@257@04 != Null | dead]
(push) ; 5
; [then-branch: 147 | exc@257@04 == Null]
; [eval] 0 <= t
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (implies (= exc@257@04 $Ref.null) (<= 0 t@13@04)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@259@04))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@259@04)))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@259@04))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@259@04)))))))))))))
  $Snap.unit))
; [eval] exc == null ==> t < V
; [eval] exc == null
(push) ; 4
(push) ; 5
(assert (not (not (= exc@257@04 $Ref.null))))
(check-sat)
; unknown
(pop) ; 5
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               262952
;  :arith-add-rows          125522
;  :arith-assert-diseq      2876
;  :arith-assert-lower      46748
;  :arith-assert-upper      38326
;  :arith-bound-prop        8139
;  :arith-conflicts         375
;  :arith-eq-adapter        35132
;  :arith-fixed-eqs         36028
;  :arith-offset-eqs        22695
;  :arith-pivots            28361
;  :conflicts               1341
;  :datatype-accessor-ax    171
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               15856
;  :del-clause              807693
;  :final-checks            5
;  :max-generation          11
;  :max-memory              60.52
;  :memory                  54.07
;  :minimized-lits          143
;  :mk-bool-var             793093
;  :mk-clause               808582
;  :num-allocs              2800450
;  :num-checks              256
;  :propagations            172853
;  :quant-instantiations    285991
;  :restarts                1
;  :rlimit-count            9215820
;  :time                    0.01)
; [then-branch: 148 | exc@257@04 == Null | live]
; [else-branch: 148 | exc@257@04 != Null | dead]
(push) ; 5
; [then-branch: 148 | exc@257@04 == Null]
; [eval] t < V
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (implies (= exc@257@04 $Ref.null) (< t@13@04 V@15@04)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@259@04)))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@259@04))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@259@04)))))))))))))))))
; [eval] exc == null
(push) ; 4
(assert (not (not (= exc@257@04 $Ref.null))))
(check-sat)
; unknown
(pop) ; 4
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               263328
;  :arith-add-rows          125677
;  :arith-assert-diseq      2884
;  :arith-assert-lower      46828
;  :arith-assert-upper      38383
;  :arith-bound-prop        8184
;  :arith-conflicts         375
;  :arith-eq-adapter        35190
;  :arith-fixed-eqs         36106
;  :arith-offset-eqs        22744
;  :arith-pivots            28371
;  :conflicts               1342
;  :datatype-accessor-ax    172
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               15887
;  :del-clause              809463
;  :final-checks            5
;  :max-generation          11
;  :max-memory              60.52
;  :memory                  54.00
;  :minimized-lits          145
;  :mk-bool-var             794559
;  :mk-clause               810352
;  :num-allocs              2805524
;  :num-checks              257
;  :propagations            173274
;  :quant-instantiations    286543
;  :restarts                1
;  :rlimit-count            9239214
;  :time                    0.01)
; [then-branch: 149 | exc@257@04 == Null | live]
; [else-branch: 149 | exc@257@04 != Null | dead]
(push) ; 4
; [then-branch: 149 | exc@257@04 == Null]
(declare-const i1@268@04 Int)
(declare-const j1@269@04 Int)
(push) ; 5
; [eval] 0 <= i1 && i1 < V && (0 <= j1 && j1 < V)
; [eval] 0 <= i1
(push) ; 6
; [then-branch: 150 | 0 <= i1@268@04 | live]
; [else-branch: 150 | !(0 <= i1@268@04) | live]
(push) ; 7
; [then-branch: 150 | 0 <= i1@268@04]
(assert (<= 0 i1@268@04))
; [eval] i1 < V
(push) ; 8
; [then-branch: 151 | i1@268@04 < V@15@04 | live]
; [else-branch: 151 | !(i1@268@04 < V@15@04) | live]
(push) ; 9
; [then-branch: 151 | i1@268@04 < V@15@04]
(assert (< i1@268@04 V@15@04))
; [eval] 0 <= j1
(push) ; 10
; [then-branch: 152 | 0 <= j1@269@04 | live]
; [else-branch: 152 | !(0 <= j1@269@04) | live]
(push) ; 11
; [then-branch: 152 | 0 <= j1@269@04]
(assert (<= 0 j1@269@04))
; [eval] j1 < V
(pop) ; 11
(push) ; 11
; [else-branch: 152 | !(0 <= j1@269@04)]
(assert (not (<= 0 j1@269@04)))
(pop) ; 11
(pop) ; 10
; Joined path conditions
; Joined path conditions
(pop) ; 9
(push) ; 9
; [else-branch: 151 | !(i1@268@04 < V@15@04)]
(assert (not (< i1@268@04 V@15@04)))
(pop) ; 9
(pop) ; 8
; Joined path conditions
; Joined path conditions
(pop) ; 7
(push) ; 7
; [else-branch: 150 | !(0 <= i1@268@04)]
(assert (not (<= 0 i1@268@04)))
(pop) ; 7
(pop) ; 6
; Joined path conditions
; Joined path conditions
(assert (and
  (and (and (< j1@269@04 V@15@04) (<= 0 j1@269@04)) (< i1@268@04 V@15@04))
  (<= 0 i1@268@04)))
; [eval] aloc(opt_get1(aloc(opt_get1(Gf), i1).option$array$), j1)
; [eval] opt_get1(aloc(opt_get1(Gf), i1).option$array$)
; [eval] aloc(opt_get1(Gf), i1)
; [eval] opt_get1(Gf)
(push) ; 6
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 6
; Joined path conditions
(push) ; 6
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 7
(assert (not (< i1@268@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               263328
;  :arith-add-rows          125680
;  :arith-assert-diseq      2884
;  :arith-assert-lower      46834
;  :arith-assert-upper      38383
;  :arith-bound-prop        8184
;  :arith-conflicts         375
;  :arith-eq-adapter        35190
;  :arith-fixed-eqs         36106
;  :arith-offset-eqs        22744
;  :arith-pivots            28372
;  :conflicts               1342
;  :datatype-accessor-ax    172
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               15887
;  :del-clause              809463
;  :final-checks            5
;  :max-generation          11
;  :max-memory              60.52
;  :memory                  54.00
;  :minimized-lits          145
;  :mk-bool-var             794565
;  :mk-clause               810352
;  :num-allocs              2805802
;  :num-checks              258
;  :propagations            173274
;  :quant-instantiations    286543
;  :restarts                1
;  :rlimit-count            9239694)
(assert (< i1@268@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(pop) ; 6
; Joined path conditions
(assert (< i1@268@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@263@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@268@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@268@04)))
(push) ; 6
(assert (not (<
  $Perm.No
  (+
    (ite
      (and
        (<
          (inv@262@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@268@04))
          V@15@04)
        (<=
          0
          (inv@262@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@268@04))))
      $k@261@04
      $Perm.No)
    (-
      (ite
        (and
          (<
            (inv@21@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@268@04))
            V@15@04)
          (<=
            0
            (inv@21@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@268@04))))
        $k@20@04
        $Perm.No)
      (pTaken@234@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@268@04)))))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               263619
;  :arith-add-rows          125830
;  :arith-assert-diseq      2896
;  :arith-assert-lower      46903
;  :arith-assert-upper      38414
;  :arith-bound-prop        8221
;  :arith-conflicts         378
;  :arith-eq-adapter        35228
;  :arith-fixed-eqs         36132
;  :arith-offset-eqs        22773
;  :arith-pivots            28417
;  :conflicts               1348
;  :datatype-accessor-ax    172
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               15936
;  :del-clause              810447
;  :final-checks            5
;  :max-generation          11
;  :max-memory              60.52
;  :memory                  54.06
;  :minimized-lits          146
;  :mk-bool-var             795560
;  :mk-clause               811557
;  :num-allocs              2808986
;  :num-checks              259
;  :propagations            173491
;  :quant-instantiations    286792
;  :restarts                1
;  :rlimit-count            9253964
;  :time                    0.00)
(push) ; 6
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 7
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@263@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@268@04))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               263619
;  :arith-add-rows          125830
;  :arith-assert-diseq      2896
;  :arith-assert-lower      46903
;  :arith-assert-upper      38414
;  :arith-bound-prop        8221
;  :arith-conflicts         378
;  :arith-eq-adapter        35228
;  :arith-fixed-eqs         36132
;  :arith-offset-eqs        22773
;  :arith-pivots            28417
;  :conflicts               1349
;  :datatype-accessor-ax    172
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               15936
;  :del-clause              810447
;  :final-checks            5
;  :max-generation          11
;  :max-memory              60.52
;  :memory                  54.06
;  :minimized-lits          146
;  :mk-bool-var             795560
;  :mk-clause               811557
;  :num-allocs              2809076
;  :num-checks              260
;  :propagations            173491
;  :quant-instantiations    286792
;  :restarts                1
;  :rlimit-count            9254059)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@263@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@268@04))
    (as None<option<array>>  option<array>))))
(pop) ; 6
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@263@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@268@04))
    (as None<option<array>>  option<array>))))
(push) ; 6
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 7
(assert (not (<
  j1@269@04
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@263@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@268@04)))))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               263625
;  :arith-add-rows          125834
;  :arith-assert-diseq      2896
;  :arith-assert-lower      46905
;  :arith-assert-upper      38416
;  :arith-bound-prop        8221
;  :arith-conflicts         379
;  :arith-eq-adapter        35229
;  :arith-fixed-eqs         36133
;  :arith-offset-eqs        22773
;  :arith-pivots            28419
;  :conflicts               1350
;  :datatype-accessor-ax    172
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               15936
;  :del-clause              810451
;  :final-checks            5
;  :max-generation          11
;  :max-memory              60.52
;  :memory                  54.05
;  :minimized-lits          146
;  :mk-bool-var             795571
;  :mk-clause               811561
;  :num-allocs              2809261
;  :num-checks              261
;  :propagations            173493
;  :quant-instantiations    286799
;  :restarts                1
;  :rlimit-count            9254517)
(assert (<
  j1@269@04
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@263@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@268@04))))))
(pop) ; 6
; Joined path conditions
(assert (<
  j1@269@04
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@263@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@268@04))))))
(pop) ; 5
(declare-fun inv@270@04 ($Ref) Int)
(declare-fun inv@271@04 ($Ref) Int)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(assert (forall ((i1@268@04 Int) (j1@269@04 Int)) (!
  (and
    (< i1@268@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@263@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@268@04)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@268@04))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@263@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@268@04))
        (as None<option<array>>  option<array>)))
    (<
      j1@269@04
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@263@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@268@04))))))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@263@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@268@04))) j1@269@04))
  :qid |int-aux|)))
; Check receiver injectivity
(push) ; 5
(assert (not (forall ((i11@268@04 Int) (j11@269@04 Int) (i12@268@04 Int) (j12@269@04 Int)) (!
  (implies
    (and
      (and
        (and
          (and (< j11@269@04 V@15@04) (<= 0 j11@269@04))
          (< i11@268@04 V@15@04))
        (<= 0 i11@268@04))
      (and
        (and
          (and (< j12@269@04 V@15@04) (<= 0 j12@269@04))
          (< i12@268@04 V@15@04))
        (<= 0 i12@268@04))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@263@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i11@268@04))) j11@269@04)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@263@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i12@268@04))) j12@269@04)))
    (and (= i11@268@04 i12@268@04) (= j11@269@04 j12@269@04)))
  
  :qid |int-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               263769
;  :arith-add-rows          125906
;  :arith-assert-diseq      2896
;  :arith-assert-lower      46929
;  :arith-assert-upper      38424
;  :arith-bound-prop        8228
;  :arith-conflicts         379
;  :arith-eq-adapter        35259
;  :arith-fixed-eqs         36139
;  :arith-offset-eqs        22780
;  :arith-pivots            28452
;  :conflicts               1351
;  :datatype-accessor-ax    172
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               15936
;  :del-clause              811095
;  :final-checks            5
;  :max-generation          11
;  :max-memory              60.52
;  :memory                  54.07
;  :minimized-lits          146
;  :mk-bool-var             796257
;  :mk-clause               811984
;  :num-allocs              2812611
;  :num-checks              262
;  :propagations            173528
;  :quant-instantiations    287098
;  :restarts                1
;  :rlimit-count            9267806
;  :time                    0.00)
; Definitional axioms for inverse functions
(assert (forall ((i1@268@04 Int) (j1@269@04 Int)) (!
  (implies
    (and
      (and (and (< j1@269@04 V@15@04) (<= 0 j1@269@04)) (< i1@268@04 V@15@04))
      (<= 0 i1@268@04))
    (and
      (=
        (inv@270@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@263@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@268@04))) j1@269@04))
        i1@268@04)
      (=
        (inv@271@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@263@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@268@04))) j1@269@04))
        j1@269@04)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@263@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@268@04))) j1@269@04))
  )))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@271@04 r) V@15@04) (<= 0 (inv@271@04 r)))
        (< (inv@270@04 r) V@15@04))
      (<= 0 (inv@270@04 r)))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@263@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) (inv@270@04 r)))) (inv@271@04 r))
      r))
  :pattern ((inv@270@04 r))
  :pattern ((inv@271@04 r))
  :qid |int-fctOfInv|)))
; Permissions are non-negative
; Field permissions are at most one
; Permission implies non-null receiver
(assert (forall ((i1@268@04 Int) (j1@269@04 Int)) (!
  (implies
    (and
      (and (and (< j1@269@04 V@15@04) (<= 0 j1@269@04)) (< i1@268@04 V@15@04))
      (<= 0 i1@268@04))
    (not
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@263@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@268@04))) j1@269@04)
        $Ref.null)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@263@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@268@04))) j1@269@04))
  :qid |int-permImpliesNonNull|)))
(declare-const sm@272@04 $FVF<Int>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@271@04 r) V@15@04) (<= 0 (inv@271@04 r)))
        (< (inv@270@04 r) V@15@04))
      (<= 0 (inv@270@04 r)))
    (=
      ($FVF.lookup_int (as sm@272@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@259@04))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@272@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@259@04))))))))))))))) r))
  :qid |qp.fvfValDef217|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@259@04))))))))))))))) r) r)
  :pattern (($FVF.lookup_int (as sm@272@04  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef218|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@271@04 r) V@15@04) (<= 0 (inv@271@04 r)))
        (< (inv@270@04 r) V@15@04))
      (<= 0 (inv@270@04 r)))
    ($FVF.loc_int ($FVF.lookup_int (as sm@272@04  $FVF<Int>) r) r))
  :pattern ((inv@270@04 r) (inv@271@04 r))
  )))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@259@04))))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@259@04)))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@259@04))))))))))))))))))
; [eval] exc == null
(set-option :timeout 10)
(push) ; 5
(assert (not (not (= exc@257@04 $Ref.null))))
(check-sat)
; unknown
(pop) ; 5
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               264081
;  :arith-add-rows          126048
;  :arith-assert-diseq      2904
;  :arith-assert-lower      47009
;  :arith-assert-upper      38481
;  :arith-bound-prop        8273
;  :arith-conflicts         379
;  :arith-eq-adapter        35309
;  :arith-fixed-eqs         36217
;  :arith-offset-eqs        22828
;  :arith-pivots            28462
;  :conflicts               1351
;  :datatype-accessor-ax    173
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               15966
;  :del-clause              812688
;  :final-checks            5
;  :max-generation          11
;  :max-memory              60.52
;  :memory                  54.16
;  :minimized-lits          146
;  :mk-bool-var             797606
;  :mk-clause               813577
;  :num-allocs              2818922
;  :num-checks              263
;  :propagations            173817
;  :quant-instantiations    287608
;  :restarts                1
;  :rlimit-count            9295778
;  :time                    0.01)
; [then-branch: 153 | exc@257@04 == Null | live]
; [else-branch: 153 | exc@257@04 != Null | dead]
(push) ; 5
; [then-branch: 153 | exc@257@04 == Null]
(declare-const i1@273@04 Int)
(push) ; 6
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 7
; [then-branch: 154 | 0 <= i1@273@04 | live]
; [else-branch: 154 | !(0 <= i1@273@04) | live]
(push) ; 8
; [then-branch: 154 | 0 <= i1@273@04]
(assert (<= 0 i1@273@04))
; [eval] i1 < V
(pop) ; 8
(push) ; 8
; [else-branch: 154 | !(0 <= i1@273@04)]
(assert (not (<= 0 i1@273@04)))
(pop) ; 8
(pop) ; 7
; Joined path conditions
; Joined path conditions
(assert (and (< i1@273@04 V@15@04) (<= 0 i1@273@04)))
; [eval] aloc(opt_get1(p), i1)
; [eval] opt_get1(p)
(push) ; 7
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 7
; Joined path conditions
(push) ; 7
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 8
(assert (not (< i1@273@04 (alen<Int> (opt_get1 $Snap.unit P@14@04)))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               264081
;  :arith-add-rows          126049
;  :arith-assert-diseq      2904
;  :arith-assert-lower      47011
;  :arith-assert-upper      38481
;  :arith-bound-prop        8273
;  :arith-conflicts         379
;  :arith-eq-adapter        35309
;  :arith-fixed-eqs         36217
;  :arith-offset-eqs        22828
;  :arith-pivots            28463
;  :conflicts               1351
;  :datatype-accessor-ax    173
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               15966
;  :del-clause              812688
;  :final-checks            5
;  :max-generation          11
;  :max-memory              60.52
;  :memory                  54.16
;  :minimized-lits          146
;  :mk-bool-var             797608
;  :mk-clause               813577
;  :num-allocs              2819025
;  :num-checks              264
;  :propagations            173817
;  :quant-instantiations    287608
;  :restarts                1
;  :rlimit-count            9295969)
(assert (< i1@273@04 (alen<Int> (opt_get1 $Snap.unit P@14@04))))
(pop) ; 7
; Joined path conditions
(assert (< i1@273@04 (alen<Int> (opt_get1 $Snap.unit P@14@04))))
(pop) ; 6
(declare-fun inv@274@04 ($Ref) Int)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(assert (forall ((i1@273@04 Int)) (!
  (< i1@273@04 (alen<Int> (opt_get1 $Snap.unit P@14@04)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i1@273@04))
  :qid |int-aux|)))
; Check receiver injectivity
(push) ; 6
(assert (not (forall ((i11@273@04 Int) (i12@273@04 Int)) (!
  (implies
    (and
      (and (< i11@273@04 V@15@04) (<= 0 i11@273@04))
      (and (< i12@273@04 V@15@04) (<= 0 i12@273@04))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i11@273@04)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i12@273@04)))
    (= i11@273@04 i12@273@04))
  
  :qid |int-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               264101
;  :arith-add-rows          126055
;  :arith-assert-diseq      2905
;  :arith-assert-lower      47015
;  :arith-assert-upper      38481
;  :arith-bound-prop        8273
;  :arith-conflicts         379
;  :arith-eq-adapter        35310
;  :arith-fixed-eqs         36217
;  :arith-offset-eqs        22828
;  :arith-pivots            28466
;  :conflicts               1352
;  :datatype-accessor-ax    173
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               15966
;  :del-clause              812694
;  :final-checks            5
;  :max-generation          11
;  :max-memory              60.52
;  :memory                  54.16
;  :minimized-lits          146
;  :mk-bool-var             797639
;  :mk-clause               813583
;  :num-allocs              2819604
;  :num-checks              265
;  :propagations            173817
;  :quant-instantiations    287637
;  :restarts                1
;  :rlimit-count            9297244
;  :time                    0.00)
; Definitional axioms for inverse functions
(assert (forall ((i1@273@04 Int)) (!
  (implies
    (and (< i1@273@04 V@15@04) (<= 0 i1@273@04))
    (=
      (inv@274@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i1@273@04))
      i1@273@04))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i1@273@04))
  )))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@274@04 r) V@15@04) (<= 0 (inv@274@04 r)))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) (inv@274@04 r))
      r))
  :pattern ((inv@274@04 r))
  :qid |int-fctOfInv|)))
; Permissions are non-negative
; Field permissions are at most one
; Permission implies non-null receiver
(assert (forall ((i1@273@04 Int)) (!
  (implies
    (and (< i1@273@04 V@15@04) (<= 0 i1@273@04))
    (not
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i1@273@04)
        $Ref.null)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i1@273@04))
  :qid |int-permImpliesNonNull|)))
(declare-const sm@275@04 $FVF<Int>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@274@04 r) V@15@04) (<= 0 (inv@274@04 r)))
    (=
      ($FVF.lookup_int (as sm@275@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@259@04)))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@275@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@259@04)))))))))))))))) r))
  :qid |qp.fvfValDef219|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@271@04 r) V@15@04) (<= 0 (inv@271@04 r)))
        (< (inv@270@04 r) V@15@04))
      (<= 0 (inv@270@04 r)))
    (=
      ($FVF.lookup_int (as sm@275@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@259@04))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@275@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@259@04))))))))))))))) r))
  :qid |qp.fvfValDef220|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@259@04)))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@259@04))))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@275@04  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef221|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@274@04 r) V@15@04) (<= 0 (inv@274@04 r)))
    ($FVF.loc_int ($FVF.lookup_int (as sm@275@04  $FVF<Int>) r) r))
  :pattern ((inv@274@04 r))
  )))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@259@04)))))))))))))))
  $Snap.unit))
; [eval] exc == null ==> valid_graph_vertices(this, p, V)
; [eval] exc == null
(push) ; 6
(set-option :timeout 10)
(push) ; 7
(assert (not (not (= exc@257@04 $Ref.null))))
(check-sat)
; unknown
(pop) ; 7
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               264494
;  :arith-add-rows          126212
;  :arith-assert-diseq      2913
;  :arith-assert-lower      47097
;  :arith-assert-upper      38538
;  :arith-bound-prop        8318
;  :arith-conflicts         379
;  :arith-eq-adapter        35382
;  :arith-fixed-eqs         36295
;  :arith-offset-eqs        22877
;  :arith-pivots            28476
;  :conflicts               1353
;  :datatype-accessor-ax    173
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               15997
;  :del-clause              814884
;  :final-checks            5
;  :max-generation          11
;  :max-memory              60.52
;  :memory                  54.01
;  :minimized-lits          148
;  :mk-bool-var             799405
;  :mk-clause               815773
;  :num-allocs              2826896
;  :num-checks              266
;  :propagations            174258
;  :quant-instantiations    288380
;  :restarts                1
;  :rlimit-count            9326749
;  :time                    0.01)
; [then-branch: 155 | exc@257@04 == Null | live]
; [else-branch: 155 | exc@257@04 != Null | dead]
(push) ; 7
; [then-branch: 155 | exc@257@04 == Null]
; [eval] valid_graph_vertices(this, p, V)
(push) ; 8
; [eval] this != null
; [eval] p != (None(): option[array])
; [eval] (None(): option[array])
; [eval] alen(opt_get1(p)) == V
; [eval] alen(opt_get1(p))
; [eval] opt_get1(p)
(push) ; 9
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 9
; Joined path conditions
(declare-const i1@276@04 Int)
(push) ; 9
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 10
; [then-branch: 156 | 0 <= i1@276@04 | live]
; [else-branch: 156 | !(0 <= i1@276@04) | live]
(push) ; 11
; [then-branch: 156 | 0 <= i1@276@04]
(assert (<= 0 i1@276@04))
; [eval] i1 < V
(pop) ; 11
(push) ; 11
; [else-branch: 156 | !(0 <= i1@276@04)]
(assert (not (<= 0 i1@276@04)))
(pop) ; 11
(pop) ; 10
; Joined path conditions
; Joined path conditions
(assert (and (< i1@276@04 V@15@04) (<= 0 i1@276@04)))
(declare-const $k@277@04 $Perm)
(assert ($Perm.isReadVar $k@277@04 $Perm.Write))
; [eval] aloc(opt_get1(p), i1)
; [eval] opt_get1(p)
(push) ; 10
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 10
; Joined path conditions
(push) ; 10
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 11
(assert (not (< i1@276@04 (alen<Int> (opt_get1 $Snap.unit P@14@04)))))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               264494
;  :arith-add-rows          126213
;  :arith-assert-diseq      2914
;  :arith-assert-lower      47101
;  :arith-assert-upper      38539
;  :arith-bound-prop        8318
;  :arith-conflicts         379
;  :arith-eq-adapter        35383
;  :arith-fixed-eqs         36295
;  :arith-offset-eqs        22877
;  :arith-pivots            28476
;  :conflicts               1353
;  :datatype-accessor-ax    173
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               15997
;  :del-clause              814884
;  :final-checks            5
;  :max-generation          11
;  :max-memory              60.52
;  :memory                  54.01
;  :minimized-lits          148
;  :mk-bool-var             799411
;  :mk-clause               815775
;  :num-allocs              2827067
;  :num-checks              267
;  :propagations            174259
;  :quant-instantiations    288380
;  :restarts                1
;  :rlimit-count            9327087)
(assert (< i1@276@04 (alen<Int> (opt_get1 $Snap.unit P@14@04))))
(pop) ; 10
; Joined path conditions
(assert (< i1@276@04 (alen<Int> (opt_get1 $Snap.unit P@14@04))))
(pop) ; 9
(declare-fun inv@278@04 ($Ref) Int)
; Nested auxiliary terms: globals
(assert ($Perm.isReadVar $k@277@04 $Perm.Write))
; Nested auxiliary terms: non-globals
(assert (forall ((i1@276@04 Int)) (!
  (< i1@276@04 (alen<Int> (opt_get1 $Snap.unit P@14@04)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i1@276@04))
  :qid |int-aux|)))
(push) ; 9
(assert (not (forall ((i1@276@04 Int)) (!
  (implies
    (and (< i1@276@04 V@15@04) (<= 0 i1@276@04))
    (or (= $k@277@04 $Perm.No) (< $Perm.No $k@277@04)))
  
  ))))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               264494
;  :arith-add-rows          126214
;  :arith-assert-diseq      2915
;  :arith-assert-lower      47103
;  :arith-assert-upper      38540
;  :arith-bound-prop        8318
;  :arith-conflicts         379
;  :arith-eq-adapter        35384
;  :arith-fixed-eqs         36295
;  :arith-offset-eqs        22877
;  :arith-pivots            28476
;  :conflicts               1354
;  :datatype-accessor-ax    173
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               15997
;  :del-clause              814886
;  :final-checks            5
;  :max-generation          11
;  :max-memory              60.52
;  :memory                  54.01
;  :minimized-lits          148
;  :mk-bool-var             799418
;  :mk-clause               815777
;  :num-allocs              2827497
;  :num-checks              268
;  :propagations            174260
;  :quant-instantiations    288380
;  :restarts                1
;  :rlimit-count            9327634)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 9
(assert (not (forall ((i11@276@04 Int) (i12@276@04 Int)) (!
  (implies
    (and
      (and
        (and
          (and (< i11@276@04 V@15@04) (<= 0 i11@276@04))
          ($FVF.loc_int ($FVF.lookup_int (as sm@275@04  $FVF<Int>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit P@14@04) i11@276@04)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit P@14@04) i11@276@04)))
        (< $Perm.No $k@277@04))
      (and
        (and
          (and (< i12@276@04 V@15@04) (<= 0 i12@276@04))
          ($FVF.loc_int ($FVF.lookup_int (as sm@275@04  $FVF<Int>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit P@14@04) i12@276@04)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit P@14@04) i12@276@04)))
        (< $Perm.No $k@277@04))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i11@276@04)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i12@276@04)))
    (= i11@276@04 i12@276@04))
  
  :qid |int-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               264518
;  :arith-add-rows          126221
;  :arith-assert-diseq      2916
;  :arith-assert-lower      47107
;  :arith-assert-upper      38540
;  :arith-bound-prop        8318
;  :arith-conflicts         379
;  :arith-eq-adapter        35385
;  :arith-fixed-eqs         36295
;  :arith-offset-eqs        22877
;  :arith-pivots            28476
;  :conflicts               1355
;  :datatype-accessor-ax    173
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               15997
;  :del-clause              814897
;  :final-checks            5
;  :max-generation          11
;  :max-memory              60.52
;  :memory                  54.02
;  :minimized-lits          148
;  :mk-bool-var             799463
;  :mk-clause               815788
;  :num-allocs              2828014
;  :num-checks              269
;  :propagations            174262
;  :quant-instantiations    288416
;  :restarts                1
;  :rlimit-count            9329132
;  :time                    0.00)
; Definitional axioms for inverse functions
(assert (forall ((i1@276@04 Int)) (!
  (implies
    (and (and (< i1@276@04 V@15@04) (<= 0 i1@276@04)) (< $Perm.No $k@277@04))
    (=
      (inv@278@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i1@276@04))
      i1@276@04))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i1@276@04))
  :qid |int-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and (< (inv@278@04 r) V@15@04) (<= 0 (inv@278@04 r)))
      (< $Perm.No $k@277@04))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) (inv@278@04 r))
      r))
  :pattern ((inv@278@04 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@278@04 r) V@15@04) (<= 0 (inv@278@04 r)))
    ($FVF.loc_int ($FVF.lookup_int (as sm@275@04  $FVF<Int>) r) r))
  :pattern ((inv@278@04 r))
  )))
; Precomputing data for removing quantified permissions
(define-fun pTaken@279@04 ((r $Ref)) $Perm
  (ite
    (and (< (inv@278@04 r) V@15@04) (<= 0 (inv@278@04 r)))
    ($Perm.min
      (ite
        (and (< (inv@274@04 r) V@15@04) (<= 0 (inv@274@04 r)))
        $Perm.Write
        $Perm.No)
      $k@277@04)
    $Perm.No))
(define-fun pTaken@280@04 ((r $Ref)) $Perm
  (ite
    (and (< (inv@278@04 r) V@15@04) (<= 0 (inv@278@04 r)))
    ($Perm.min
      (ite
        (and
          (and
            (and (< (inv@271@04 r) V@15@04) (<= 0 (inv@271@04 r)))
            (< (inv@270@04 r) V@15@04))
          (<= 0 (inv@270@04 r)))
        $Perm.Write
        $Perm.No)
      (- $k@277@04 (pTaken@279@04 r)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Constrain original permissions $k@277@04
(assert (forall ((r $Ref)) (!
  (implies
    (not
      (=
        (ite
          (and (< (inv@274@04 r) V@15@04) (<= 0 (inv@274@04 r)))
          $Perm.Write
          $Perm.No)
        $Perm.No))
    (ite
      (and (< (inv@274@04 r) V@15@04) (<= 0 (inv@274@04 r)))
      (<
        (ite
          (and (< (inv@278@04 r) V@15@04) (<= 0 (inv@278@04 r)))
          $k@277@04
          $Perm.No)
        $Perm.Write)
      (<
        (ite
          (and (< (inv@278@04 r) V@15@04) (<= 0 (inv@278@04 r)))
          $k@277@04
          $Perm.No)
        $Perm.No)))
  :pattern ((inv@274@04 r))
  :pattern ((inv@278@04 r))
  :qid |qp.srp222|)))
; Intermediate check if already taken enough permissions
(set-option :timeout 500)
(push) ; 9
(assert (not (forall ((r $Ref)) (!
  (implies
    (and (< (inv@278@04 r) V@15@04) (<= 0 (inv@278@04 r)))
    (= (- $k@277@04 (pTaken@279@04 r)) $Perm.No))
  
  ))))
(check-sat)
; unsat
(pop) ; 9
; 0.02s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               265508
;  :arith-add-rows          126758
;  :arith-assert-diseq      2942
;  :arith-assert-lower      47309
;  :arith-assert-upper      38677
;  :arith-bound-prop        8383
;  :arith-conflicts         381
;  :arith-eq-adapter        35555
;  :arith-fixed-eqs         36470
;  :arith-offset-eqs        22986
;  :arith-pivots            28539
;  :conflicts               1376
;  :datatype-accessor-ax    173
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               16133
;  :del-clause              821203
;  :final-checks            5
;  :max-generation          11
;  :max-memory              60.52
;  :memory                  54.20
;  :minimized-lits          150
;  :mk-bool-var             804575
;  :mk-clause               822143
;  :num-allocs              2846819
;  :num-checks              271
;  :propagations            175273
;  :quant-instantiations    290140
;  :restarts                1
;  :rlimit-count            9412745
;  :time                    0.02)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@281@04 $FVF<Int>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (iff
    (Set_in r ($FVF.domain_int (as sm@281@04  $FVF<Int>)))
    (and
      (and (< (inv@278@04 r) V@15@04) (<= 0 (inv@278@04 r)))
      (< $Perm.No $k@277@04)))
  :pattern ((Set_in r ($FVF.domain_int (as sm@281@04  $FVF<Int>))))
  :qid |qp.fvfDomDef226|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@278@04 r) V@15@04) (<= 0 (inv@278@04 r)))
        (< $Perm.No $k@277@04))
      (and (< (inv@274@04 r) V@15@04) (<= 0 (inv@274@04 r))))
    (=
      ($FVF.lookup_int (as sm@281@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@259@04)))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@281@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@259@04)))))))))))))))) r))
  :qid |qp.fvfValDef223|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@278@04 r) V@15@04) (<= 0 (inv@278@04 r)))
        (< $Perm.No $k@277@04))
      (and
        (and
          (and (< (inv@271@04 r) V@15@04) (<= 0 (inv@271@04 r)))
          (< (inv@270@04 r) V@15@04))
        (<= 0 (inv@270@04 r))))
    (=
      ($FVF.lookup_int (as sm@281@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@259@04))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@281@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@259@04))))))))))))))) r))
  :qid |qp.fvfValDef224|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@259@04)))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@259@04))))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@281@04  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef225|)))
(pop) ; 8
; Joined path conditions
(assert ($Perm.isReadVar $k@277@04 $Perm.Write))
(assert (forall ((i1@276@04 Int)) (!
  (implies
    (and (and (< i1@276@04 V@15@04) (<= 0 i1@276@04)) (< $Perm.No $k@277@04))
    (=
      (inv@278@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i1@276@04))
      i1@276@04))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i1@276@04))
  :qid |int-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and (< (inv@278@04 r) V@15@04) (<= 0 (inv@278@04 r)))
      (< $Perm.No $k@277@04))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) (inv@278@04 r))
      r))
  :pattern ((inv@278@04 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (iff
    (Set_in r ($FVF.domain_int (as sm@281@04  $FVF<Int>)))
    (and
      (and (< (inv@278@04 r) V@15@04) (<= 0 (inv@278@04 r)))
      (< $Perm.No $k@277@04)))
  :pattern ((Set_in r ($FVF.domain_int (as sm@281@04  $FVF<Int>))))
  :qid |qp.fvfDomDef226|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@278@04 r) V@15@04) (<= 0 (inv@278@04 r)))
        (< $Perm.No $k@277@04))
      (and (< (inv@274@04 r) V@15@04) (<= 0 (inv@274@04 r))))
    (=
      ($FVF.lookup_int (as sm@281@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@259@04)))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@281@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@259@04)))))))))))))))) r))
  :qid |qp.fvfValDef223|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@278@04 r) V@15@04) (<= 0 (inv@278@04 r)))
        (< $Perm.No $k@277@04))
      (and
        (and
          (and (< (inv@271@04 r) V@15@04) (<= 0 (inv@271@04 r)))
          (< (inv@270@04 r) V@15@04))
        (<= 0 (inv@270@04 r))))
    (=
      ($FVF.lookup_int (as sm@281@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@259@04))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@281@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@259@04))))))))))))))) r))
  :qid |qp.fvfValDef224|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@259@04)))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@259@04))))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@281@04  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef225|)))
(assert (and
  (forall ((i1@276@04 Int)) (!
    (< i1@276@04 (alen<Int> (opt_get1 $Snap.unit P@14@04)))
    :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i1@276@04))
    :qid |int-aux|))
  (forall ((r $Ref)) (!
    (implies
      (and (< (inv@278@04 r) V@15@04) (<= 0 (inv@278@04 r)))
      ($FVF.loc_int ($FVF.lookup_int (as sm@275@04  $FVF<Int>) r) r))
    :pattern ((inv@278@04 r))
    ))
  (forall ((r $Ref)) (!
    (implies
      (not
        (=
          (ite
            (and (< (inv@274@04 r) V@15@04) (<= 0 (inv@274@04 r)))
            $Perm.Write
            $Perm.No)
          $Perm.No))
      (ite
        (and (< (inv@274@04 r) V@15@04) (<= 0 (inv@274@04 r)))
        (<
          (ite
            (and (< (inv@278@04 r) V@15@04) (<= 0 (inv@278@04 r)))
            $k@277@04
            $Perm.No)
          $Perm.Write)
        (<
          (ite
            (and (< (inv@278@04 r) V@15@04) (<= 0 (inv@278@04 r)))
            $k@277@04
            $Perm.No)
          $Perm.No)))
    :pattern ((inv@274@04 r))
    :pattern ((inv@278@04 r))
    :qid |qp.srp222|))))
(pop) ; 7
(pop) ; 6
; Joined path conditions
(assert ($Perm.isReadVar $k@277@04 $Perm.Write))
(assert (forall ((i1@276@04 Int)) (!
  (implies
    (and (and (< i1@276@04 V@15@04) (<= 0 i1@276@04)) (< $Perm.No $k@277@04))
    (=
      (inv@278@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i1@276@04))
      i1@276@04))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i1@276@04))
  :qid |int-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and (< (inv@278@04 r) V@15@04) (<= 0 (inv@278@04 r)))
      (< $Perm.No $k@277@04))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) (inv@278@04 r))
      r))
  :pattern ((inv@278@04 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (iff
    (Set_in r ($FVF.domain_int (as sm@281@04  $FVF<Int>)))
    (and
      (and (< (inv@278@04 r) V@15@04) (<= 0 (inv@278@04 r)))
      (< $Perm.No $k@277@04)))
  :pattern ((Set_in r ($FVF.domain_int (as sm@281@04  $FVF<Int>))))
  :qid |qp.fvfDomDef226|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@278@04 r) V@15@04) (<= 0 (inv@278@04 r)))
        (< $Perm.No $k@277@04))
      (and (< (inv@274@04 r) V@15@04) (<= 0 (inv@274@04 r))))
    (=
      ($FVF.lookup_int (as sm@281@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@259@04)))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@281@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@259@04)))))))))))))))) r))
  :qid |qp.fvfValDef223|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@278@04 r) V@15@04) (<= 0 (inv@278@04 r)))
        (< $Perm.No $k@277@04))
      (and
        (and
          (and (< (inv@271@04 r) V@15@04) (<= 0 (inv@271@04 r)))
          (< (inv@270@04 r) V@15@04))
        (<= 0 (inv@270@04 r))))
    (=
      ($FVF.lookup_int (as sm@281@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@259@04))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@281@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@259@04))))))))))))))) r))
  :qid |qp.fvfValDef224|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@259@04)))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@259@04))))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@281@04  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef225|)))
(assert (implies
  (= exc@257@04 $Ref.null)
  (and
    (forall ((i1@276@04 Int)) (!
      (< i1@276@04 (alen<Int> (opt_get1 $Snap.unit P@14@04)))
      :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i1@276@04))
      :qid |int-aux|))
    (forall ((r $Ref)) (!
      (implies
        (and (< (inv@278@04 r) V@15@04) (<= 0 (inv@278@04 r)))
        ($FVF.loc_int ($FVF.lookup_int (as sm@275@04  $FVF<Int>) r) r))
      :pattern ((inv@278@04 r))
      ))
    (forall ((r $Ref)) (!
      (implies
        (not
          (=
            (ite
              (and (< (inv@274@04 r) V@15@04) (<= 0 (inv@274@04 r)))
              $Perm.Write
              $Perm.No)
            $Perm.No))
        (ite
          (and (< (inv@274@04 r) V@15@04) (<= 0 (inv@274@04 r)))
          (<
            (ite
              (and (< (inv@278@04 r) V@15@04) (<= 0 (inv@278@04 r)))
              $k@277@04
              $Perm.No)
            $Perm.Write)
          (<
            (ite
              (and (< (inv@278@04 r) V@15@04) (<= 0 (inv@278@04 r)))
              $k@277@04
              $Perm.No)
            $Perm.No)))
      :pattern ((inv@274@04 r))
      :pattern ((inv@278@04 r))
      :qid |qp.srp222|)))))
(assert (implies
  (= exc@257@04 $Ref.null)
  (valid_graph_vertices ($Snap.combine
    $Snap.unit
    ($Snap.combine
      $Snap.unit
      ($Snap.combine
        $Snap.unit
        ($SortWrappers.$FVF<Int>To$Snap (as sm@281@04  $FVF<Int>))))) this@9@04 P@14@04 V@15@04)))
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
; [eval] exc != null
; [then-branch: 157 | exc@257@04 != Null | dead]
; [else-branch: 157 | exc@257@04 == Null | live]
(push) ; 6
; [else-branch: 157 | exc@257@04 == Null]
(pop) ; 6
; [eval] !(exc != null)
; [eval] exc != null
(set-option :timeout 10)
(push) ; 6
(assert (not (not (= exc@257@04 $Ref.null))))
(check-sat)
; unknown
(pop) ; 6
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               267412
;  :arith-add-rows          127665
;  :arith-assert-diseq      2960
;  :arith-assert-lower      47650
;  :arith-assert-upper      38916
;  :arith-bound-prop        8504
;  :arith-conflicts         383
;  :arith-eq-adapter        35818
;  :arith-fixed-eqs         36717
;  :arith-offset-eqs        23109
;  :arith-pivots            28774
;  :conflicts               1380
;  :datatype-accessor-ax    176
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               16279
;  :del-clause              831264
;  :final-checks            5
;  :max-generation          11
;  :max-memory              60.52
;  :memory                  54.46
;  :minimized-lits          154
;  :mk-bool-var             813750
;  :mk-clause               832354
;  :num-allocs              2878989
;  :num-checks              273
;  :propagations            176938
;  :quant-instantiations    293424
;  :restarts                1
;  :rlimit-count            9560912
;  :time                    0.01)
; [then-branch: 158 | exc@257@04 == Null | live]
; [else-branch: 158 | exc@257@04 != Null | dead]
(push) ; 6
; [then-branch: 158 | exc@257@04 == Null]
(declare-const P_seq@282@04 Seq<Int>)
(declare-const bottleneckPathFlow@283@04 Int)
(declare-const excBeforeLoop1@284@04 $Ref)
(declare-const v@285@04 Int)
(declare-const u@286@04 Int)
(declare-const excBeforeLoop2@287@04 $Ref)
(declare-const v1@288@04 Int)
(declare-const Gf_seq@289@04 Seq<Seq<Int>>)
(declare-const maxFlow@290@04 Int)
(declare-const exc@291@04 $Ref)
(declare-const res1@292@04 Bool)
(push) ; 7
; Loop head block: Check well-definedness of invariant
(declare-const $t@293@04 $Snap)
(assert (= $t@293@04 ($Snap.combine ($Snap.first $t@293@04) ($Snap.second $t@293@04))))
(assert (= ($Snap.first $t@293@04) $Snap.unit))
; [eval] exc == excBeforeLoop
(assert (= exc@291@04 $Ref.null))
(assert (=
  ($Snap.second $t@293@04)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@293@04))
    ($Snap.second ($Snap.second $t@293@04)))))
(assert (= ($Snap.first ($Snap.second $t@293@04)) $Snap.unit))
; [eval] G != (None(): option[array])
; [eval] (None(): option[array])
(assert (=
  ($Snap.second ($Snap.second $t@293@04))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second $t@293@04)))
    ($Snap.second ($Snap.second ($Snap.second $t@293@04))))))
(assert (= ($Snap.first ($Snap.second ($Snap.second $t@293@04))) $Snap.unit))
; [eval] alen(opt_get1(G)) == V
; [eval] alen(opt_get1(G))
; [eval] opt_get1(G)
(push) ; 8
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 8
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second ($Snap.second $t@293@04)))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04)))))))
(declare-const i1@294@04 Int)
(push) ; 8
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 9
; [then-branch: 159 | 0 <= i1@294@04 | live]
; [else-branch: 159 | !(0 <= i1@294@04) | live]
(push) ; 10
; [then-branch: 159 | 0 <= i1@294@04]
(assert (<= 0 i1@294@04))
; [eval] i1 < V
(pop) ; 10
(push) ; 10
; [else-branch: 159 | !(0 <= i1@294@04)]
(assert (not (<= 0 i1@294@04)))
(pop) ; 10
(pop) ; 9
; Joined path conditions
; Joined path conditions
(assert (and (< i1@294@04 V@15@04) (<= 0 i1@294@04)))
; [eval] aloc(opt_get1(G), i1)
; [eval] opt_get1(G)
(push) ; 9
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 9
; Joined path conditions
(push) ; 9
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 10
(assert (not (< i1@294@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               267436
;  :arith-add-rows          127666
;  :arith-assert-diseq      2960
;  :arith-assert-lower      47652
;  :arith-assert-upper      38916
;  :arith-bound-prop        8504
;  :arith-conflicts         383
;  :arith-eq-adapter        35818
;  :arith-fixed-eqs         36717
;  :arith-offset-eqs        23109
;  :arith-pivots            28775
;  :conflicts               1380
;  :datatype-accessor-ax    180
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               16279
;  :del-clause              831264
;  :final-checks            5
;  :max-generation          11
;  :max-memory              60.52
;  :memory                  54.46
;  :minimized-lits          154
;  :mk-bool-var             813760
;  :mk-clause               832354
;  :num-allocs              2879375
;  :num-checks              274
;  :propagations            176938
;  :quant-instantiations    293424
;  :restarts                1
;  :rlimit-count            9561642)
(assert (< i1@294@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(pop) ; 9
; Joined path conditions
(assert (< i1@294@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(declare-const $k@295@04 $Perm)
(assert ($Perm.isReadVar $k@295@04 $Perm.Write))
(pop) ; 8
(declare-fun inv@296@04 ($Ref) Int)
; Nested auxiliary terms: globals
(assert ($Perm.isReadVar $k@295@04 $Perm.Write))
; Nested auxiliary terms: non-globals
(assert (forall ((i1@294@04 Int)) (!
  (< i1@294@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@294@04))
  :qid |option$array$-aux|)))
(push) ; 8
(assert (not (forall ((i1@294@04 Int)) (!
  (implies
    (and (< i1@294@04 V@15@04) (<= 0 i1@294@04))
    (or (= $k@295@04 $Perm.No) (< $Perm.No $k@295@04)))
  
  ))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               267436
;  :arith-add-rows          127667
;  :arith-assert-diseq      2961
;  :arith-assert-lower      47654
;  :arith-assert-upper      38917
;  :arith-bound-prop        8504
;  :arith-conflicts         383
;  :arith-eq-adapter        35819
;  :arith-fixed-eqs         36717
;  :arith-offset-eqs        23109
;  :arith-pivots            28776
;  :conflicts               1381
;  :datatype-accessor-ax    180
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               16279
;  :del-clause              831264
;  :final-checks            5
;  :max-generation          11
;  :max-memory              60.52
;  :memory                  54.46
;  :minimized-lits          154
;  :mk-bool-var             813767
;  :mk-clause               832356
;  :num-allocs              2879843
;  :num-checks              275
;  :propagations            176939
;  :quant-instantiations    293424
;  :restarts                1
;  :rlimit-count            9562218)
; Check receiver injectivity
(push) ; 8
(assert (not (forall ((i11@294@04 Int) (i12@294@04 Int)) (!
  (implies
    (and
      (and (and (< i11@294@04 V@15@04) (<= 0 i11@294@04)) (< $Perm.No $k@295@04))
      (and (and (< i12@294@04 V@15@04) (<= 0 i12@294@04)) (< $Perm.No $k@295@04))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i11@294@04)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i12@294@04)))
    (= i11@294@04 i12@294@04))
  
  :qid |option$array$-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               267476
;  :arith-add-rows          127673
;  :arith-assert-diseq      2962
;  :arith-assert-lower      47658
;  :arith-assert-upper      38917
;  :arith-bound-prop        8504
;  :arith-conflicts         383
;  :arith-eq-adapter        35820
;  :arith-fixed-eqs         36717
;  :arith-offset-eqs        23109
;  :arith-pivots            28778
;  :conflicts               1382
;  :datatype-accessor-ax    180
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               16279
;  :del-clause              831270
;  :final-checks            5
;  :max-generation          11
;  :max-memory              60.52
;  :memory                  54.42
;  :minimized-lits          154
;  :mk-bool-var             813829
;  :mk-clause               832362
;  :num-allocs              2880679
;  :num-checks              276
;  :propagations            176939
;  :quant-instantiations    293491
;  :restarts                1
;  :rlimit-count            9564734
;  :time                    0.00)
; Definitional axioms for inverse functions
(assert (forall ((i1@294@04 Int)) (!
  (implies
    (and (and (< i1@294@04 V@15@04) (<= 0 i1@294@04)) (< $Perm.No $k@295@04))
    (=
      (inv@296@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@294@04))
      i1@294@04))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@294@04))
  )))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and (< (inv@296@04 r) V@15@04) (<= 0 (inv@296@04 r)))
      (< $Perm.No $k@295@04))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) (inv@296@04 r))
      r))
  :pattern ((inv@296@04 r))
  :qid |option$array$-fctOfInv|)))
; Permissions are non-negative
(assert (forall ((i1@294@04 Int)) (!
  (<= $Perm.No $k@295@04)
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@294@04))
  :qid |option$array$-permAtLeastZero|)))
; Field permissions are at most one
(assert (forall ((i1@294@04 Int)) (!
  (<= $k@295@04 $Perm.Write)
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@294@04))
  :qid |option$array$-permAtMostOne|)))
; Permission implies non-null receiver
(assert (forall ((i1@294@04 Int)) (!
  (implies
    (and (and (< i1@294@04 V@15@04) (<= 0 i1@294@04)) (< $Perm.No $k@295@04))
    (not
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@294@04)
        $Ref.null)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@294@04))
  :qid |option$array$-permImpliesNonNull|)))
(declare-const sm@297@04 $FVF<option<array>>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@296@04 r) V@15@04) (<= 0 (inv@296@04 r)))
      (< $Perm.No $k@295@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@297@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@297@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r))
  :qid |qp.fvfValDef227|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r) r)
  :pattern (($FVF.lookup_option$array$ (as sm@297@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef228|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@296@04 r) V@15@04) (<= 0 (inv@296@04 r)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@297@04  $FVF<option<array>>) r) r))
  :pattern ((inv@296@04 r))
  )))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04)))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04)))))
  $Snap.unit))
; [eval] (forall i1: Int :: { aloc(opt_get1(G), i1) } 0 <= i1 && i1 < V ==> aloc(opt_get1(G), i1).option$array$ != (None(): option[array]))
(declare-const i1@298@04 Int)
(push) ; 8
; [eval] 0 <= i1 && i1 < V ==> aloc(opt_get1(G), i1).option$array$ != (None(): option[array])
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 9
; [then-branch: 160 | 0 <= i1@298@04 | live]
; [else-branch: 160 | !(0 <= i1@298@04) | live]
(push) ; 10
; [then-branch: 160 | 0 <= i1@298@04]
(assert (<= 0 i1@298@04))
; [eval] i1 < V
(pop) ; 10
(push) ; 10
; [else-branch: 160 | !(0 <= i1@298@04)]
(assert (not (<= 0 i1@298@04)))
(pop) ; 10
(pop) ; 9
; Joined path conditions
; Joined path conditions
(push) ; 9
; [then-branch: 161 | i1@298@04 < V@15@04 && 0 <= i1@298@04 | live]
; [else-branch: 161 | !(i1@298@04 < V@15@04 && 0 <= i1@298@04) | live]
(push) ; 10
; [then-branch: 161 | i1@298@04 < V@15@04 && 0 <= i1@298@04]
(assert (and (< i1@298@04 V@15@04) (<= 0 i1@298@04)))
; [eval] aloc(opt_get1(G), i1).option$array$ != (None(): option[array])
; [eval] aloc(opt_get1(G), i1)
; [eval] opt_get1(G)
(push) ; 11
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 11
; Joined path conditions
(push) ; 11
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 12
(assert (not (< i1@298@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))))
(check-sat)
; unsat
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               267482
;  :arith-add-rows          127674
;  :arith-assert-diseq      2962
;  :arith-assert-lower      47660
;  :arith-assert-upper      38918
;  :arith-bound-prop        8504
;  :arith-conflicts         383
;  :arith-eq-adapter        35820
;  :arith-fixed-eqs         36717
;  :arith-offset-eqs        23109
;  :arith-pivots            28779
;  :conflicts               1382
;  :datatype-accessor-ax    181
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               16279
;  :del-clause              831270
;  :final-checks            5
;  :max-generation          11
;  :max-memory              60.52
;  :memory                  54.42
;  :minimized-lits          154
;  :mk-bool-var             813840
;  :mk-clause               832362
;  :num-allocs              2881872
;  :num-checks              277
;  :propagations            176939
;  :quant-instantiations    293491
;  :restarts                1
;  :rlimit-count            9567077)
(assert (< i1@298@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(pop) ; 11
; Joined path conditions
(assert (< i1@298@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@297@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@298@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@298@04)))
(push) ; 11
(assert (not (ite
  (and
    (<
      (inv@296@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@298@04))
      V@15@04)
    (<=
      0
      (inv@296@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@298@04))))
  (< $Perm.No $k@295@04)
  false)))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               267592
;  :arith-add-rows          127721
;  :arith-assert-diseq      2962
;  :arith-assert-lower      47676
;  :arith-assert-upper      38931
;  :arith-bound-prop        8513
;  :arith-conflicts         384
;  :arith-eq-adapter        35832
;  :arith-fixed-eqs         36729
;  :arith-offset-eqs        23126
;  :arith-pivots            28792
;  :conflicts               1383
;  :datatype-accessor-ax    181
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               16279
;  :del-clause              831270
;  :final-checks            5
;  :max-generation          11
;  :max-memory              60.52
;  :memory                  54.42
;  :minimized-lits          154
;  :mk-bool-var             814250
;  :mk-clause               832633
;  :num-allocs              2883651
;  :num-checks              278
;  :propagations            176946
;  :quant-instantiations    293651
;  :restarts                1
;  :rlimit-count            9574307)
; [eval] (None(): option[array])
(pop) ; 10
(push) ; 10
; [else-branch: 161 | !(i1@298@04 < V@15@04 && 0 <= i1@298@04)]
(assert (not (and (< i1@298@04 V@15@04) (<= 0 i1@298@04))))
(pop) ; 10
(pop) ; 9
; Joined path conditions
(assert (implies
  (and (< i1@298@04 V@15@04) (<= 0 i1@298@04))
  (and
    (< i1@298@04 V@15@04)
    (<= 0 i1@298@04)
    (< i1@298@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@297@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@298@04)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@298@04)))))
; Joined path conditions
(pop) ; 8
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@298@04 Int)) (!
  (implies
    (and (< i1@298@04 V@15@04) (<= 0 i1@298@04))
    (and
      (< i1@298@04 V@15@04)
      (<= 0 i1@298@04)
      (< i1@298@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@297@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@298@04)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@298@04))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@298@04))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(assert (forall ((i1@298@04 Int)) (!
  (implies
    (and (< i1@298@04 V@15@04) (<= 0 i1@298@04))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@297@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@298@04))
        (as None<option<array>>  option<array>))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@298@04))
  :qid |prog.l<no position>|)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04)))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04)))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04))))))
  $Snap.unit))
; [eval] (forall i1: Int :: { alen(opt_get1(aloc(opt_get1(G), i1).option$array$)) } 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(G), i1).option$array$)) == V)
(declare-const i1@299@04 Int)
(push) ; 8
; [eval] 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(G), i1).option$array$)) == V
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 9
; [then-branch: 162 | 0 <= i1@299@04 | live]
; [else-branch: 162 | !(0 <= i1@299@04) | live]
(push) ; 10
; [then-branch: 162 | 0 <= i1@299@04]
(assert (<= 0 i1@299@04))
; [eval] i1 < V
(pop) ; 10
(push) ; 10
; [else-branch: 162 | !(0 <= i1@299@04)]
(assert (not (<= 0 i1@299@04)))
(pop) ; 10
(pop) ; 9
; Joined path conditions
; Joined path conditions
(push) ; 9
; [then-branch: 163 | i1@299@04 < V@15@04 && 0 <= i1@299@04 | live]
; [else-branch: 163 | !(i1@299@04 < V@15@04 && 0 <= i1@299@04) | live]
(push) ; 10
; [then-branch: 163 | i1@299@04 < V@15@04 && 0 <= i1@299@04]
(assert (and (< i1@299@04 V@15@04) (<= 0 i1@299@04)))
; [eval] alen(opt_get1(aloc(opt_get1(G), i1).option$array$)) == V
; [eval] alen(opt_get1(aloc(opt_get1(G), i1).option$array$))
; [eval] opt_get1(aloc(opt_get1(G), i1).option$array$)
; [eval] aloc(opt_get1(G), i1)
; [eval] opt_get1(G)
(push) ; 11
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 11
; Joined path conditions
(push) ; 11
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 12
(assert (not (< i1@299@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))))
(check-sat)
; unsat
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               267598
;  :arith-add-rows          127731
;  :arith-assert-diseq      2962
;  :arith-assert-lower      47678
;  :arith-assert-upper      38931
;  :arith-bound-prop        8513
;  :arith-conflicts         384
;  :arith-eq-adapter        35832
;  :arith-fixed-eqs         36729
;  :arith-offset-eqs        23126
;  :arith-pivots            28805
;  :conflicts               1383
;  :datatype-accessor-ax    182
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               16279
;  :del-clause              831541
;  :final-checks            5
;  :max-generation          11
;  :max-memory              60.52
;  :memory                  54.40
;  :minimized-lits          154
;  :mk-bool-var             814256
;  :mk-clause               832633
;  :num-allocs              2884194
;  :num-checks              279
;  :propagations            176946
;  :quant-instantiations    293651
;  :restarts                1
;  :rlimit-count            9575611)
(assert (< i1@299@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(pop) ; 11
; Joined path conditions
(assert (< i1@299@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@297@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@299@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@299@04)))
(push) ; 11
(assert (not (ite
  (and
    (<
      (inv@296@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@299@04))
      V@15@04)
    (<=
      0
      (inv@296@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@299@04))))
  (< $Perm.No $k@295@04)
  false)))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               267688
;  :arith-add-rows          127769
;  :arith-assert-diseq      2962
;  :arith-assert-lower      47694
;  :arith-assert-upper      38944
;  :arith-bound-prop        8521
;  :arith-conflicts         385
;  :arith-eq-adapter        35844
;  :arith-fixed-eqs         36741
;  :arith-offset-eqs        23126
;  :arith-pivots            28818
;  :conflicts               1384
;  :datatype-accessor-ax    182
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               16279
;  :del-clause              831541
;  :final-checks            5
;  :max-generation          11
;  :max-memory              60.52
;  :memory                  54.41
;  :minimized-lits          154
;  :mk-bool-var             814668
;  :mk-clause               832904
;  :num-allocs              2885961
;  :num-checks              280
;  :propagations            176950
;  :quant-instantiations    293813
;  :restarts                1
;  :rlimit-count            9582736)
(push) ; 11
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 12
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@297@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@299@04))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               267688
;  :arith-add-rows          127769
;  :arith-assert-diseq      2962
;  :arith-assert-lower      47694
;  :arith-assert-upper      38944
;  :arith-bound-prop        8521
;  :arith-conflicts         385
;  :arith-eq-adapter        35844
;  :arith-fixed-eqs         36741
;  :arith-offset-eqs        23126
;  :arith-pivots            28818
;  :conflicts               1385
;  :datatype-accessor-ax    182
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               16279
;  :del-clause              831541
;  :final-checks            5
;  :max-generation          11
;  :max-memory              60.52
;  :memory                  54.41
;  :minimized-lits          154
;  :mk-bool-var             814668
;  :mk-clause               832904
;  :num-allocs              2886051
;  :num-checks              281
;  :propagations            176950
;  :quant-instantiations    293813
;  :restarts                1
;  :rlimit-count            9582831)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@297@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@299@04))
    (as None<option<array>>  option<array>))))
(pop) ; 11
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@297@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@299@04))
    (as None<option<array>>  option<array>))))
(pop) ; 10
(push) ; 10
; [else-branch: 163 | !(i1@299@04 < V@15@04 && 0 <= i1@299@04)]
(assert (not (and (< i1@299@04 V@15@04) (<= 0 i1@299@04))))
(pop) ; 10
(pop) ; 9
; Joined path conditions
(assert (implies
  (and (< i1@299@04 V@15@04) (<= 0 i1@299@04))
  (and
    (< i1@299@04 V@15@04)
    (<= 0 i1@299@04)
    (< i1@299@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@297@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@299@04)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@299@04))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@297@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@299@04))
        (as None<option<array>>  option<array>))))))
; Joined path conditions
(pop) ; 8
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@299@04 Int)) (!
  (implies
    (and (< i1@299@04 V@15@04) (<= 0 i1@299@04))
    (and
      (< i1@299@04 V@15@04)
      (<= 0 i1@299@04)
      (< i1@299@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@297@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@299@04)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@299@04))
      (not
        (=
          ($FVF.lookup_option$array$ (as sm@297@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@299@04))
          (as None<option<array>>  option<array>)))))
  :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@297@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@299@04)))))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(assert (forall ((i1@299@04 Int)) (!
  (implies
    (and (< i1@299@04 V@15@04) (<= 0 i1@299@04))
    (=
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@297@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@299@04))))
      V@15@04))
  :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@297@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@299@04)))))
  :qid |prog.l<no position>|)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04)))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04)))))))
  $Snap.unit))
; [eval] (forall i1: Int :: { aloc(opt_get1(G), i1) } (forall i2: Int :: { aloc(opt_get1(G), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(G), i1).option$array$ == aloc(opt_get1(G), i2).option$array$ ==> i1 == i2))
(declare-const i1@300@04 Int)
(push) ; 8
; [eval] (forall i2: Int :: { aloc(opt_get1(G), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(G), i1).option$array$ == aloc(opt_get1(G), i2).option$array$ ==> i1 == i2)
(declare-const i2@301@04 Int)
(push) ; 9
; [eval] 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(G), i1).option$array$ == aloc(opt_get1(G), i2).option$array$ ==> i1 == i2
; [eval] 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(G), i1).option$array$ == aloc(opt_get1(G), i2).option$array$
; [eval] 0 <= i1
(push) ; 10
; [then-branch: 164 | 0 <= i1@300@04 | live]
; [else-branch: 164 | !(0 <= i1@300@04) | live]
(push) ; 11
; [then-branch: 164 | 0 <= i1@300@04]
(assert (<= 0 i1@300@04))
; [eval] i1 < V
(push) ; 12
; [then-branch: 165 | i1@300@04 < V@15@04 | live]
; [else-branch: 165 | !(i1@300@04 < V@15@04) | live]
(push) ; 13
; [then-branch: 165 | i1@300@04 < V@15@04]
(assert (< i1@300@04 V@15@04))
; [eval] 0 <= i2
(push) ; 14
; [then-branch: 166 | 0 <= i2@301@04 | live]
; [else-branch: 166 | !(0 <= i2@301@04) | live]
(push) ; 15
; [then-branch: 166 | 0 <= i2@301@04]
(assert (<= 0 i2@301@04))
; [eval] i2 < V
(push) ; 16
; [then-branch: 167 | i2@301@04 < V@15@04 | live]
; [else-branch: 167 | !(i2@301@04 < V@15@04) | live]
(push) ; 17
; [then-branch: 167 | i2@301@04 < V@15@04]
(assert (< i2@301@04 V@15@04))
; [eval] aloc(opt_get1(G), i1).option$array$ == aloc(opt_get1(G), i2).option$array$
; [eval] aloc(opt_get1(G), i1)
; [eval] opt_get1(G)
(push) ; 18
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 18
; Joined path conditions
(push) ; 18
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 19
(assert (not (< i1@300@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))))
(check-sat)
; unsat
(pop) ; 19
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               267694
;  :arith-add-rows          127780
;  :arith-assert-diseq      2962
;  :arith-assert-lower      47698
;  :arith-assert-upper      38944
;  :arith-bound-prop        8521
;  :arith-conflicts         385
;  :arith-eq-adapter        35844
;  :arith-fixed-eqs         36741
;  :arith-offset-eqs        23126
;  :arith-pivots            28832
;  :conflicts               1385
;  :datatype-accessor-ax    183
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               16279
;  :del-clause              831812
;  :final-checks            5
;  :max-generation          11
;  :max-memory              60.52
;  :memory                  54.39
;  :minimized-lits          154
;  :mk-bool-var             814676
;  :mk-clause               832904
;  :num-allocs              2886790
;  :num-checks              282
;  :propagations            176950
;  :quant-instantiations    293813
;  :restarts                1
;  :rlimit-count            9584426)
(assert (< i1@300@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(pop) ; 18
; Joined path conditions
(assert (< i1@300@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@297@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@300@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@300@04)))
(push) ; 18
(assert (not (ite
  (and
    (<
      (inv@296@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@300@04))
      V@15@04)
    (<=
      0
      (inv@296@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@300@04))))
  (< $Perm.No $k@295@04)
  false)))
(check-sat)
; unsat
(pop) ; 18
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               267785
;  :arith-add-rows          127818
;  :arith-assert-diseq      2962
;  :arith-assert-lower      47714
;  :arith-assert-upper      38957
;  :arith-bound-prop        8529
;  :arith-conflicts         386
;  :arith-eq-adapter        35856
;  :arith-fixed-eqs         36753
;  :arith-offset-eqs        23126
;  :arith-pivots            28845
;  :conflicts               1386
;  :datatype-accessor-ax    183
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               16279
;  :del-clause              831812
;  :final-checks            5
;  :max-generation          11
;  :max-memory              60.52
;  :memory                  54.41
;  :minimized-lits          154
;  :mk-bool-var             815089
;  :mk-clause               833175
;  :num-allocs              2888551
;  :num-checks              283
;  :propagations            176954
;  :quant-instantiations    293975
;  :restarts                1
;  :rlimit-count            9591553)
; [eval] aloc(opt_get1(G), i2)
; [eval] opt_get1(G)
(push) ; 18
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 18
; Joined path conditions
(push) ; 18
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 19
(assert (not (< i2@301@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))))
(check-sat)
; unsat
(pop) ; 19
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               267785
;  :arith-add-rows          127818
;  :arith-assert-diseq      2962
;  :arith-assert-lower      47714
;  :arith-assert-upper      38957
;  :arith-bound-prop        8529
;  :arith-conflicts         386
;  :arith-eq-adapter        35856
;  :arith-fixed-eqs         36753
;  :arith-offset-eqs        23126
;  :arith-pivots            28845
;  :conflicts               1386
;  :datatype-accessor-ax    183
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               16279
;  :del-clause              831812
;  :final-checks            5
;  :max-generation          11
;  :max-memory              60.52
;  :memory                  54.41
;  :minimized-lits          154
;  :mk-bool-var             815089
;  :mk-clause               833175
;  :num-allocs              2888577
;  :num-checks              284
;  :propagations            176954
;  :quant-instantiations    293975
;  :restarts                1
;  :rlimit-count            9591583)
(assert (< i2@301@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(pop) ; 18
; Joined path conditions
(assert (< i2@301@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@297@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@301@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@301@04)))
(push) ; 18
(assert (not (ite
  (and
    (<
      (inv@296@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@301@04))
      V@15@04)
    (<=
      0
      (inv@296@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@301@04))))
  (< $Perm.No $k@295@04)
  false)))
(check-sat)
; unsat
(pop) ; 18
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               267894
;  :arith-add-rows          127868
;  :arith-assert-diseq      2962
;  :arith-assert-lower      47730
;  :arith-assert-upper      38970
;  :arith-bound-prop        8538
;  :arith-conflicts         387
;  :arith-eq-adapter        35869
;  :arith-fixed-eqs         36765
;  :arith-offset-eqs        23143
;  :arith-pivots            28858
;  :conflicts               1387
;  :datatype-accessor-ax    183
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               16279
;  :del-clause              831812
;  :final-checks            5
;  :max-generation          11
;  :max-memory              60.52
;  :memory                  54.43
;  :minimized-lits          154
;  :mk-bool-var             815376
;  :mk-clause               833362
;  :num-allocs              2890158
;  :num-checks              285
;  :propagations            176979
;  :quant-instantiations    294118
;  :restarts                1
;  :rlimit-count            9597958)
(pop) ; 17
(push) ; 17
; [else-branch: 167 | !(i2@301@04 < V@15@04)]
(assert (not (< i2@301@04 V@15@04)))
(pop) ; 17
(pop) ; 16
; Joined path conditions
(assert (implies
  (< i2@301@04 V@15@04)
  (and
    (< i2@301@04 V@15@04)
    (< i1@300@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@297@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@300@04)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@300@04))
    (< i2@301@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@297@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@301@04)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@301@04)))))
; Joined path conditions
(pop) ; 15
(push) ; 15
; [else-branch: 166 | !(0 <= i2@301@04)]
(assert (not (<= 0 i2@301@04)))
(pop) ; 15
(pop) ; 14
; Joined path conditions
(assert (implies
  (<= 0 i2@301@04)
  (and
    (<= 0 i2@301@04)
    (implies
      (< i2@301@04 V@15@04)
      (and
        (< i2@301@04 V@15@04)
        (< i1@300@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@297@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@300@04)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@300@04))
        (< i2@301@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@297@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@301@04)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@301@04)))))))
; Joined path conditions
(pop) ; 13
(push) ; 13
; [else-branch: 165 | !(i1@300@04 < V@15@04)]
(assert (not (< i1@300@04 V@15@04)))
(pop) ; 13
(pop) ; 12
; Joined path conditions
(assert (implies
  (< i1@300@04 V@15@04)
  (and
    (< i1@300@04 V@15@04)
    (implies
      (<= 0 i2@301@04)
      (and
        (<= 0 i2@301@04)
        (implies
          (< i2@301@04 V@15@04)
          (and
            (< i2@301@04 V@15@04)
            (< i1@300@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@297@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@300@04)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@300@04))
            (< i2@301@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@297@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@301@04)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@301@04)))))))))
; Joined path conditions
(pop) ; 11
(push) ; 11
; [else-branch: 164 | !(0 <= i1@300@04)]
(assert (not (<= 0 i1@300@04)))
(pop) ; 11
(pop) ; 10
; Joined path conditions
(assert (implies
  (<= 0 i1@300@04)
  (and
    (<= 0 i1@300@04)
    (implies
      (< i1@300@04 V@15@04)
      (and
        (< i1@300@04 V@15@04)
        (implies
          (<= 0 i2@301@04)
          (and
            (<= 0 i2@301@04)
            (implies
              (< i2@301@04 V@15@04)
              (and
                (< i2@301@04 V@15@04)
                (< i1@300@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@297@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@300@04)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@300@04))
                (< i2@301@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@297@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@301@04)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@301@04)))))))))))
; Joined path conditions
(push) ; 10
; [then-branch: 168 | Lookup(option$array$,sm@297@04,aloc((_, _), opt_get1(_, G@11@04), i1@300@04)) == Lookup(option$array$,sm@297@04,aloc((_, _), opt_get1(_, G@11@04), i2@301@04)) && i2@301@04 < V@15@04 && 0 <= i2@301@04 && i1@300@04 < V@15@04 && 0 <= i1@300@04 | live]
; [else-branch: 168 | !(Lookup(option$array$,sm@297@04,aloc((_, _), opt_get1(_, G@11@04), i1@300@04)) == Lookup(option$array$,sm@297@04,aloc((_, _), opt_get1(_, G@11@04), i2@301@04)) && i2@301@04 < V@15@04 && 0 <= i2@301@04 && i1@300@04 < V@15@04 && 0 <= i1@300@04) | live]
(push) ; 11
; [then-branch: 168 | Lookup(option$array$,sm@297@04,aloc((_, _), opt_get1(_, G@11@04), i1@300@04)) == Lookup(option$array$,sm@297@04,aloc((_, _), opt_get1(_, G@11@04), i2@301@04)) && i2@301@04 < V@15@04 && 0 <= i2@301@04 && i1@300@04 < V@15@04 && 0 <= i1@300@04]
(assert (and
  (and
    (and
      (and
        (=
          ($FVF.lookup_option$array$ (as sm@297@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@300@04))
          ($FVF.lookup_option$array$ (as sm@297@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@301@04)))
        (< i2@301@04 V@15@04))
      (<= 0 i2@301@04))
    (< i1@300@04 V@15@04))
  (<= 0 i1@300@04)))
; [eval] i1 == i2
(pop) ; 11
(push) ; 11
; [else-branch: 168 | !(Lookup(option$array$,sm@297@04,aloc((_, _), opt_get1(_, G@11@04), i1@300@04)) == Lookup(option$array$,sm@297@04,aloc((_, _), opt_get1(_, G@11@04), i2@301@04)) && i2@301@04 < V@15@04 && 0 <= i2@301@04 && i1@300@04 < V@15@04 && 0 <= i1@300@04)]
(assert (not
  (and
    (and
      (and
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@297@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@300@04))
            ($FVF.lookup_option$array$ (as sm@297@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@301@04)))
          (< i2@301@04 V@15@04))
        (<= 0 i2@301@04))
      (< i1@300@04 V@15@04))
    (<= 0 i1@300@04))))
(pop) ; 11
(pop) ; 10
; Joined path conditions
(assert (implies
  (and
    (and
      (and
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@297@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@300@04))
            ($FVF.lookup_option$array$ (as sm@297@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@301@04)))
          (< i2@301@04 V@15@04))
        (<= 0 i2@301@04))
      (< i1@300@04 V@15@04))
    (<= 0 i1@300@04))
  (and
    (=
      ($FVF.lookup_option$array$ (as sm@297@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@300@04))
      ($FVF.lookup_option$array$ (as sm@297@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@301@04)))
    (< i2@301@04 V@15@04)
    (<= 0 i2@301@04)
    (< i1@300@04 V@15@04)
    (<= 0 i1@300@04))))
; Joined path conditions
(pop) ; 9
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i2@301@04 Int)) (!
  (and
    (implies
      (<= 0 i1@300@04)
      (and
        (<= 0 i1@300@04)
        (implies
          (< i1@300@04 V@15@04)
          (and
            (< i1@300@04 V@15@04)
            (implies
              (<= 0 i2@301@04)
              (and
                (<= 0 i2@301@04)
                (implies
                  (< i2@301@04 V@15@04)
                  (and
                    (< i2@301@04 V@15@04)
                    (< i1@300@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
                    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@297@04  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@300@04)) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@300@04))
                    (< i2@301@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
                    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@297@04  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@301@04)) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@301@04))))))))))
    (implies
      (and
        (and
          (and
            (and
              (=
                ($FVF.lookup_option$array$ (as sm@297@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@300@04))
                ($FVF.lookup_option$array$ (as sm@297@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@301@04)))
              (< i2@301@04 V@15@04))
            (<= 0 i2@301@04))
          (< i1@300@04 V@15@04))
        (<= 0 i1@300@04))
      (and
        (=
          ($FVF.lookup_option$array$ (as sm@297@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@300@04))
          ($FVF.lookup_option$array$ (as sm@297@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@301@04)))
        (< i2@301@04 V@15@04)
        (<= 0 i2@301@04)
        (< i1@300@04 V@15@04)
        (<= 0 i1@300@04))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@301@04))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 8
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@300@04 Int)) (!
  (forall ((i2@301@04 Int)) (!
    (and
      (implies
        (<= 0 i1@300@04)
        (and
          (<= 0 i1@300@04)
          (implies
            (< i1@300@04 V@15@04)
            (and
              (< i1@300@04 V@15@04)
              (implies
                (<= 0 i2@301@04)
                (and
                  (<= 0 i2@301@04)
                  (implies
                    (< i2@301@04 V@15@04)
                    (and
                      (< i2@301@04 V@15@04)
                      (< i1@300@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
                      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@297@04  $FVF<option<array>>) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@300@04)) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@300@04))
                      (< i2@301@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
                      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@297@04  $FVF<option<array>>) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@301@04)) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@301@04))))))))))
      (implies
        (and
          (and
            (and
              (and
                (=
                  ($FVF.lookup_option$array$ (as sm@297@04  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@300@04))
                  ($FVF.lookup_option$array$ (as sm@297@04  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@301@04)))
                (< i2@301@04 V@15@04))
              (<= 0 i2@301@04))
            (< i1@300@04 V@15@04))
          (<= 0 i1@300@04))
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@297@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@300@04))
            ($FVF.lookup_option$array$ (as sm@297@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@301@04)))
          (< i2@301@04 V@15@04)
          (<= 0 i2@301@04)
          (< i1@300@04 V@15@04)
          (<= 0 i1@300@04))))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@301@04))
    :qid |prog.l<no position>-aux|))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@300@04))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(assert (forall ((i1@300@04 Int)) (!
  (forall ((i2@301@04 Int)) (!
    (implies
      (and
        (and
          (and
            (and
              (=
                ($FVF.lookup_option$array$ (as sm@297@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@300@04))
                ($FVF.lookup_option$array$ (as sm@297@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@301@04)))
              (< i2@301@04 V@15@04))
            (<= 0 i2@301@04))
          (< i1@300@04 V@15@04))
        (<= 0 i1@300@04))
      (= i1@300@04 i2@301@04))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@301@04))
    :qid |prog.l<no position>|))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@300@04))
  :qid |prog.l<no position>|)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04)))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04)))))))))))
(declare-const i1@302@04 Int)
(declare-const j@303@04 Int)
(push) ; 8
; [eval] 0 <= i1 && i1 < V && (0 <= j && j < V)
; [eval] 0 <= i1
(push) ; 9
; [then-branch: 169 | 0 <= i1@302@04 | live]
; [else-branch: 169 | !(0 <= i1@302@04) | live]
(push) ; 10
; [then-branch: 169 | 0 <= i1@302@04]
(assert (<= 0 i1@302@04))
; [eval] i1 < V
(push) ; 11
; [then-branch: 170 | i1@302@04 < V@15@04 | live]
; [else-branch: 170 | !(i1@302@04 < V@15@04) | live]
(push) ; 12
; [then-branch: 170 | i1@302@04 < V@15@04]
(assert (< i1@302@04 V@15@04))
; [eval] 0 <= j
(push) ; 13
; [then-branch: 171 | 0 <= j@303@04 | live]
; [else-branch: 171 | !(0 <= j@303@04) | live]
(push) ; 14
; [then-branch: 171 | 0 <= j@303@04]
(assert (<= 0 j@303@04))
; [eval] j < V
(pop) ; 14
(push) ; 14
; [else-branch: 171 | !(0 <= j@303@04)]
(assert (not (<= 0 j@303@04)))
(pop) ; 14
(pop) ; 13
; Joined path conditions
; Joined path conditions
(pop) ; 12
(push) ; 12
; [else-branch: 170 | !(i1@302@04 < V@15@04)]
(assert (not (< i1@302@04 V@15@04)))
(pop) ; 12
(pop) ; 11
; Joined path conditions
; Joined path conditions
(pop) ; 10
(push) ; 10
; [else-branch: 169 | !(0 <= i1@302@04)]
(assert (not (<= 0 i1@302@04)))
(pop) ; 10
(pop) ; 9
; Joined path conditions
; Joined path conditions
(assert (and
  (and (and (< j@303@04 V@15@04) (<= 0 j@303@04)) (< i1@302@04 V@15@04))
  (<= 0 i1@302@04)))
; [eval] aloc(opt_get1(aloc(opt_get1(G), i1).option$array$), j)
; [eval] opt_get1(aloc(opt_get1(G), i1).option$array$)
; [eval] aloc(opt_get1(G), i1)
; [eval] opt_get1(G)
(push) ; 9
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 9
; Joined path conditions
(push) ; 9
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 10
(assert (not (< i1@302@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               267899
;  :arith-add-rows          127891
;  :arith-assert-diseq      2962
;  :arith-assert-lower      47736
;  :arith-assert-upper      38970
;  :arith-bound-prop        8538
;  :arith-conflicts         387
;  :arith-eq-adapter        35869
;  :arith-fixed-eqs         36765
;  :arith-offset-eqs        23143
;  :arith-pivots            28885
;  :conflicts               1387
;  :datatype-accessor-ax    184
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               16279
;  :del-clause              832294
;  :final-checks            5
;  :max-generation          11
;  :max-memory              60.52
;  :memory                  54.40
;  :minimized-lits          154
;  :mk-bool-var             815398
;  :mk-clause               833386
;  :num-allocs              2891334
;  :num-checks              286
;  :propagations            176979
;  :quant-instantiations    294118
;  :restarts                1
;  :rlimit-count            9601155)
(assert (< i1@302@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(pop) ; 9
; Joined path conditions
(assert (< i1@302@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@297@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@302@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@302@04)))
(push) ; 9
(assert (not (ite
  (and
    (<
      (inv@296@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@302@04))
      V@15@04)
    (<=
      0
      (inv@296@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@302@04))))
  (< $Perm.No $k@295@04)
  false)))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               267990
;  :arith-add-rows          127929
;  :arith-assert-diseq      2962
;  :arith-assert-lower      47752
;  :arith-assert-upper      38983
;  :arith-bound-prop        8546
;  :arith-conflicts         388
;  :arith-eq-adapter        35881
;  :arith-fixed-eqs         36777
;  :arith-offset-eqs        23143
;  :arith-pivots            28898
;  :conflicts               1388
;  :datatype-accessor-ax    184
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               16279
;  :del-clause              832294
;  :final-checks            5
;  :max-generation          11
;  :max-memory              60.52
;  :memory                  54.42
;  :minimized-lits          154
;  :mk-bool-var             815820
;  :mk-clause               833657
;  :num-allocs              2893160
;  :num-checks              287
;  :propagations            176983
;  :quant-instantiations    294283
;  :restarts                1
;  :rlimit-count            9608597)
(push) ; 9
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 10
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@297@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@302@04))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               267990
;  :arith-add-rows          127929
;  :arith-assert-diseq      2962
;  :arith-assert-lower      47752
;  :arith-assert-upper      38983
;  :arith-bound-prop        8546
;  :arith-conflicts         388
;  :arith-eq-adapter        35881
;  :arith-fixed-eqs         36777
;  :arith-offset-eqs        23143
;  :arith-pivots            28898
;  :conflicts               1389
;  :datatype-accessor-ax    184
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               16279
;  :del-clause              832294
;  :final-checks            5
;  :max-generation          11
;  :max-memory              60.52
;  :memory                  54.42
;  :minimized-lits          154
;  :mk-bool-var             815820
;  :mk-clause               833657
;  :num-allocs              2893250
;  :num-checks              288
;  :propagations            176983
;  :quant-instantiations    294283
;  :restarts                1
;  :rlimit-count            9608692)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@297@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@302@04))
    (as None<option<array>>  option<array>))))
(pop) ; 9
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@297@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@302@04))
    (as None<option<array>>  option<array>))))
(push) ; 9
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 10
(assert (not (<
  j@303@04
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@297@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@302@04)))))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               267994
;  :arith-add-rows          127932
;  :arith-assert-diseq      2962
;  :arith-assert-lower      47753
;  :arith-assert-upper      38984
;  :arith-bound-prop        8548
;  :arith-conflicts         388
;  :arith-eq-adapter        35882
;  :arith-fixed-eqs         36777
;  :arith-offset-eqs        23143
;  :arith-pivots            28900
;  :conflicts               1390
;  :datatype-accessor-ax    184
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               16279
;  :del-clause              832300
;  :final-checks            5
;  :max-generation          11
;  :max-memory              60.52
;  :memory                  54.42
;  :minimized-lits          154
;  :mk-bool-var             815831
;  :mk-clause               833663
;  :num-allocs              2893450
;  :num-checks              289
;  :propagations            176983
;  :quant-instantiations    294290
;  :restarts                1
;  :rlimit-count            9609106)
(assert (<
  j@303@04
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@297@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@302@04))))))
(pop) ; 9
; Joined path conditions
(assert (<
  j@303@04
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@297@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@302@04))))))
(pop) ; 8
(declare-fun inv@304@04 ($Ref) Int)
(declare-fun inv@305@04 ($Ref) Int)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(assert (forall ((i1@302@04 Int) (j@303@04 Int)) (!
  (and
    (< i1@302@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@297@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@302@04)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@302@04))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@297@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@302@04))
        (as None<option<array>>  option<array>)))
    (<
      j@303@04
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@297@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@302@04))))))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@297@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@302@04))) j@303@04))
  :qid |int-aux|)))
; Check receiver injectivity
(push) ; 8
(assert (not (forall ((i11@302@04 Int) (j1@303@04 Int) (i12@302@04 Int) (j2@303@04 Int)) (!
  (implies
    (and
      (and
        (and (and (< j1@303@04 V@15@04) (<= 0 j1@303@04)) (< i11@302@04 V@15@04))
        (<= 0 i11@302@04))
      (and
        (and (and (< j2@303@04 V@15@04) (<= 0 j2@303@04)) (< i12@302@04 V@15@04))
        (<= 0 i12@302@04))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@297@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i11@302@04))) j1@303@04)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@297@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i12@302@04))) j2@303@04)))
    (and (= i11@302@04 i12@302@04) (= j1@303@04 j2@303@04)))
  
  :qid |int-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 8
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               268130
;  :arith-add-rows          128001
;  :arith-assert-diseq      2962
;  :arith-assert-lower      47775
;  :arith-assert-upper      38986
;  :arith-bound-prop        8552
;  :arith-conflicts         388
;  :arith-eq-adapter        35910
;  :arith-fixed-eqs         36779
;  :arith-offset-eqs        23149
;  :arith-pivots            28926
;  :conflicts               1391
;  :datatype-accessor-ax    184
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               16279
;  :del-clause              832932
;  :final-checks            5
;  :max-generation          11
;  :max-memory              60.52
;  :memory                  54.40
;  :minimized-lits          154
;  :mk-bool-var             816489
;  :mk-clause               834024
;  :num-allocs              2896856
;  :num-checks              290
;  :propagations            177019
;  :quant-instantiations    294603
;  :restarts                1
;  :rlimit-count            9622612
;  :time                    0.01)
; Definitional axioms for inverse functions
(assert (forall ((i1@302@04 Int) (j@303@04 Int)) (!
  (implies
    (and
      (and (and (< j@303@04 V@15@04) (<= 0 j@303@04)) (< i1@302@04 V@15@04))
      (<= 0 i1@302@04))
    (and
      (=
        (inv@304@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@297@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@302@04))) j@303@04))
        i1@302@04)
      (=
        (inv@305@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@297@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@302@04))) j@303@04))
        j@303@04)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@297@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@302@04))) j@303@04))
  )))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@305@04 r) V@15@04) (<= 0 (inv@305@04 r)))
        (< (inv@304@04 r) V@15@04))
      (<= 0 (inv@304@04 r)))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@297@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) (inv@304@04 r)))) (inv@305@04 r))
      r))
  :pattern ((inv@304@04 r))
  :pattern ((inv@305@04 r))
  :qid |int-fctOfInv|)))
; Permissions are non-negative
; Field permissions are at most one
; Permission implies non-null receiver
(assert (forall ((i1@302@04 Int) (j@303@04 Int)) (!
  (implies
    (and
      (and (and (< j@303@04 V@15@04) (<= 0 j@303@04)) (< i1@302@04 V@15@04))
      (<= 0 i1@302@04))
    (not
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@297@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@302@04))) j@303@04)
        $Ref.null)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@297@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@302@04))) j@303@04))
  :qid |int-permImpliesNonNull|)))
(declare-const sm@306@04 $FVF<Int>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@305@04 r) V@15@04) (<= 0 (inv@305@04 r)))
        (< (inv@304@04 r) V@15@04))
      (<= 0 (inv@304@04 r)))
    (=
      ($FVF.lookup_int (as sm@306@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@306@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04))))))))) r))
  :qid |qp.fvfValDef229|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04))))))))) r) r)
  :pattern (($FVF.lookup_int (as sm@306@04  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef230|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@305@04 r) V@15@04) (<= 0 (inv@305@04 r)))
        (< (inv@304@04 r) V@15@04))
      (<= 0 (inv@304@04 r)))
    ($FVF.loc_int ($FVF.lookup_int (as sm@306@04  $FVF<Int>) r) r))
  :pattern ((inv@304@04 r) (inv@305@04 r))
  )))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04)))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04)))))))))
  $Snap.unit))
; [eval] P != (None(): option[array])
; [eval] (None(): option[array])
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04)))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04)))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04))))))))))
  $Snap.unit))
; [eval] alen(opt_get1(P)) == V
; [eval] alen(opt_get1(P))
; [eval] opt_get1(P)
(push) ; 8
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 8
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04)))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04))))))))))))))
(declare-const i1@307@04 Int)
(push) ; 8
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 9
; [then-branch: 172 | 0 <= i1@307@04 | live]
; [else-branch: 172 | !(0 <= i1@307@04) | live]
(push) ; 10
; [then-branch: 172 | 0 <= i1@307@04]
(assert (<= 0 i1@307@04))
; [eval] i1 < V
(pop) ; 10
(push) ; 10
; [else-branch: 172 | !(0 <= i1@307@04)]
(assert (not (<= 0 i1@307@04)))
(pop) ; 10
(pop) ; 9
; Joined path conditions
; Joined path conditions
(assert (and (< i1@307@04 V@15@04) (<= 0 i1@307@04)))
; [eval] aloc(opt_get1(P), i1)
; [eval] opt_get1(P)
(push) ; 9
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 9
; Joined path conditions
(push) ; 9
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 10
(assert (not (< i1@307@04 (alen<Int> (opt_get1 $Snap.unit P@14@04)))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               268147
;  :arith-add-rows          128002
;  :arith-assert-diseq      2962
;  :arith-assert-lower      47777
;  :arith-assert-upper      38986
;  :arith-bound-prop        8552
;  :arith-conflicts         388
;  :arith-eq-adapter        35910
;  :arith-fixed-eqs         36779
;  :arith-offset-eqs        23149
;  :arith-pivots            28927
;  :conflicts               1391
;  :datatype-accessor-ax    187
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               16279
;  :del-clause              832932
;  :final-checks            5
;  :max-generation          11
;  :max-memory              60.52
;  :memory                  54.40
;  :minimized-lits          154
;  :mk-bool-var             816502
;  :mk-clause               834024
;  :num-allocs              2898167
;  :num-checks              291
;  :propagations            177019
;  :quant-instantiations    294603
;  :restarts                1
;  :rlimit-count            9626091)
(assert (< i1@307@04 (alen<Int> (opt_get1 $Snap.unit P@14@04))))
(pop) ; 9
; Joined path conditions
(assert (< i1@307@04 (alen<Int> (opt_get1 $Snap.unit P@14@04))))
(pop) ; 8
(declare-fun inv@308@04 ($Ref) Int)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(assert (forall ((i1@307@04 Int)) (!
  (< i1@307@04 (alen<Int> (opt_get1 $Snap.unit P@14@04)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i1@307@04))
  :qid |int-aux|)))
; Check receiver injectivity
(push) ; 8
(assert (not (forall ((i11@307@04 Int) (i12@307@04 Int)) (!
  (implies
    (and
      (and (< i11@307@04 V@15@04) (<= 0 i11@307@04))
      (and (< i12@307@04 V@15@04) (<= 0 i12@307@04))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i11@307@04)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i12@307@04)))
    (= i11@307@04 i12@307@04))
  
  :qid |int-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               268172
;  :arith-add-rows          128008
;  :arith-assert-diseq      2963
;  :arith-assert-lower      47781
;  :arith-assert-upper      38986
;  :arith-bound-prop        8552
;  :arith-conflicts         388
;  :arith-eq-adapter        35911
;  :arith-fixed-eqs         36779
;  :arith-offset-eqs        23149
;  :arith-pivots            28930
;  :conflicts               1392
;  :datatype-accessor-ax    187
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               16279
;  :del-clause              832938
;  :final-checks            5
;  :max-generation          11
;  :max-memory              60.52
;  :memory                  54.40
;  :minimized-lits          154
;  :mk-bool-var             816538
;  :mk-clause               834030
;  :num-allocs              2898781
;  :num-checks              292
;  :propagations            177019
;  :quant-instantiations    294642
;  :restarts                1
;  :rlimit-count            9627523)
; Definitional axioms for inverse functions
(assert (forall ((i1@307@04 Int)) (!
  (implies
    (and (< i1@307@04 V@15@04) (<= 0 i1@307@04))
    (=
      (inv@308@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i1@307@04))
      i1@307@04))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i1@307@04))
  )))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@308@04 r) V@15@04) (<= 0 (inv@308@04 r)))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) (inv@308@04 r))
      r))
  :pattern ((inv@308@04 r))
  :qid |int-fctOfInv|)))
; Permissions are non-negative
; Field permissions are at most one
; Permission implies non-null receiver
(assert (forall ((i1@307@04 Int)) (!
  (implies
    (and (< i1@307@04 V@15@04) (<= 0 i1@307@04))
    (not
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i1@307@04)
        $Ref.null)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i1@307@04))
  :qid |int-permImpliesNonNull|)))
(declare-const sm@309@04 $FVF<Int>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@308@04 r) V@15@04) (<= 0 (inv@308@04 r)))
    (=
      ($FVF.lookup_int (as sm@309@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04)))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@309@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04)))))))))))) r))
  :qid |qp.fvfValDef231|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@305@04 r) V@15@04) (<= 0 (inv@305@04 r)))
        (< (inv@304@04 r) V@15@04))
      (<= 0 (inv@304@04 r)))
    (=
      ($FVF.lookup_int (as sm@309@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@309@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04))))))))) r))
  :qid |qp.fvfValDef232|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04)))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@309@04  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef233|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@308@04 r) V@15@04) (<= 0 (inv@308@04 r)))
    ($FVF.loc_int ($FVF.lookup_int (as sm@309@04  $FVF<Int>) r) r))
  :pattern ((inv@308@04 r))
  )))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04)))))))))))
  $Snap.unit))
; [eval] valid_graph_vertices(this, P, V)
(push) ; 8
; [eval] this != null
; [eval] p != (None(): option[array])
; [eval] (None(): option[array])
; [eval] alen(opt_get1(p)) == V
; [eval] alen(opt_get1(p))
; [eval] opt_get1(p)
(push) ; 9
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 9
; Joined path conditions
(declare-const i1@310@04 Int)
(push) ; 9
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 10
; [then-branch: 173 | 0 <= i1@310@04 | live]
; [else-branch: 173 | !(0 <= i1@310@04) | live]
(push) ; 11
; [then-branch: 173 | 0 <= i1@310@04]
(assert (<= 0 i1@310@04))
; [eval] i1 < V
(pop) ; 11
(push) ; 11
; [else-branch: 173 | !(0 <= i1@310@04)]
(assert (not (<= 0 i1@310@04)))
(pop) ; 11
(pop) ; 10
; Joined path conditions
; Joined path conditions
(assert (and (< i1@310@04 V@15@04) (<= 0 i1@310@04)))
(declare-const $k@311@04 $Perm)
(assert ($Perm.isReadVar $k@311@04 $Perm.Write))
; [eval] aloc(opt_get1(p), i1)
; [eval] opt_get1(p)
(push) ; 10
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 10
; Joined path conditions
(push) ; 10
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 11
(assert (not (< i1@310@04 (alen<Int> (opt_get1 $Snap.unit P@14@04)))))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               268173
;  :arith-add-rows          128009
;  :arith-assert-diseq      2964
;  :arith-assert-lower      47785
;  :arith-assert-upper      38987
;  :arith-bound-prop        8552
;  :arith-conflicts         388
;  :arith-eq-adapter        35912
;  :arith-fixed-eqs         36779
;  :arith-offset-eqs        23149
;  :arith-pivots            28931
;  :conflicts               1392
;  :datatype-accessor-ax    187
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               16279
;  :del-clause              832938
;  :final-checks            5
;  :max-generation          11
;  :max-memory              60.52
;  :memory                  54.40
;  :minimized-lits          154
;  :mk-bool-var             816552
;  :mk-clause               834032
;  :num-allocs              2899989
;  :num-checks              293
;  :propagations            177020
;  :quant-instantiations    294642
;  :restarts                1
;  :rlimit-count            9630500)
(assert (< i1@310@04 (alen<Int> (opt_get1 $Snap.unit P@14@04))))
(pop) ; 10
; Joined path conditions
(assert (< i1@310@04 (alen<Int> (opt_get1 $Snap.unit P@14@04))))
(pop) ; 9
(declare-fun inv@312@04 ($Ref) Int)
; Nested auxiliary terms: globals
(assert ($Perm.isReadVar $k@311@04 $Perm.Write))
; Nested auxiliary terms: non-globals
(assert (forall ((i1@310@04 Int)) (!
  (< i1@310@04 (alen<Int> (opt_get1 $Snap.unit P@14@04)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i1@310@04))
  :qid |int-aux|)))
(push) ; 9
(assert (not (forall ((i1@310@04 Int)) (!
  (implies
    (and (< i1@310@04 V@15@04) (<= 0 i1@310@04))
    (or (= $k@311@04 $Perm.No) (< $Perm.No $k@311@04)))
  
  ))))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               268173
;  :arith-add-rows          128010
;  :arith-assert-diseq      2965
;  :arith-assert-lower      47787
;  :arith-assert-upper      38988
;  :arith-bound-prop        8552
;  :arith-conflicts         388
;  :arith-eq-adapter        35913
;  :arith-fixed-eqs         36779
;  :arith-offset-eqs        23149
;  :arith-pivots            28932
;  :conflicts               1393
;  :datatype-accessor-ax    187
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               16279
;  :del-clause              832940
;  :final-checks            5
;  :max-generation          11
;  :max-memory              60.52
;  :memory                  54.40
;  :minimized-lits          154
;  :mk-bool-var             816559
;  :mk-clause               834034
;  :num-allocs              2900421
;  :num-checks              294
;  :propagations            177021
;  :quant-instantiations    294642
;  :restarts                1
;  :rlimit-count            9631050)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 9
(assert (not (forall ((i11@310@04 Int) (i12@310@04 Int)) (!
  (implies
    (and
      (and
        (and
          (and (< i11@310@04 V@15@04) (<= 0 i11@310@04))
          ($FVF.loc_int ($FVF.lookup_int (as sm@309@04  $FVF<Int>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit P@14@04) i11@310@04)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit P@14@04) i11@310@04)))
        (< $Perm.No $k@311@04))
      (and
        (and
          (and (< i12@310@04 V@15@04) (<= 0 i12@310@04))
          ($FVF.loc_int ($FVF.lookup_int (as sm@309@04  $FVF<Int>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit P@14@04) i12@310@04)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit P@14@04) i12@310@04)))
        (< $Perm.No $k@311@04))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i11@310@04)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i12@310@04)))
    (= i11@310@04 i12@310@04))
  
  :qid |int-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               268202
;  :arith-add-rows          128017
;  :arith-assert-diseq      2966
;  :arith-assert-lower      47791
;  :arith-assert-upper      38988
;  :arith-bound-prop        8552
;  :arith-conflicts         388
;  :arith-eq-adapter        35914
;  :arith-fixed-eqs         36779
;  :arith-offset-eqs        23149
;  :arith-pivots            28932
;  :conflicts               1394
;  :datatype-accessor-ax    187
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               16279
;  :del-clause              832951
;  :final-checks            5
;  :max-generation          11
;  :max-memory              60.52
;  :memory                  54.40
;  :minimized-lits          154
;  :mk-bool-var             816609
;  :mk-clause               834045
;  :num-allocs              2900969
;  :num-checks              295
;  :propagations            177023
;  :quant-instantiations    294688
;  :restarts                1
;  :rlimit-count            9632647
;  :time                    0.00)
; Definitional axioms for inverse functions
(assert (forall ((i1@310@04 Int)) (!
  (implies
    (and (and (< i1@310@04 V@15@04) (<= 0 i1@310@04)) (< $Perm.No $k@311@04))
    (=
      (inv@312@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i1@310@04))
      i1@310@04))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i1@310@04))
  :qid |int-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and (< (inv@312@04 r) V@15@04) (<= 0 (inv@312@04 r)))
      (< $Perm.No $k@311@04))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) (inv@312@04 r))
      r))
  :pattern ((inv@312@04 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@312@04 r) V@15@04) (<= 0 (inv@312@04 r)))
    ($FVF.loc_int ($FVF.lookup_int (as sm@309@04  $FVF<Int>) r) r))
  :pattern ((inv@312@04 r))
  )))
; Precomputing data for removing quantified permissions
(define-fun pTaken@313@04 ((r $Ref)) $Perm
  (ite
    (and (< (inv@312@04 r) V@15@04) (<= 0 (inv@312@04 r)))
    ($Perm.min
      (ite
        (and (< (inv@308@04 r) V@15@04) (<= 0 (inv@308@04 r)))
        $Perm.Write
        $Perm.No)
      $k@311@04)
    $Perm.No))
(define-fun pTaken@314@04 ((r $Ref)) $Perm
  (ite
    (and (< (inv@312@04 r) V@15@04) (<= 0 (inv@312@04 r)))
    ($Perm.min
      (ite
        (and
          (and
            (and (< (inv@305@04 r) V@15@04) (<= 0 (inv@305@04 r)))
            (< (inv@304@04 r) V@15@04))
          (<= 0 (inv@304@04 r)))
        $Perm.Write
        $Perm.No)
      (- $k@311@04 (pTaken@313@04 r)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Constrain original permissions $k@311@04
(assert (forall ((r $Ref)) (!
  (implies
    (not
      (=
        (ite
          (and (< (inv@308@04 r) V@15@04) (<= 0 (inv@308@04 r)))
          $Perm.Write
          $Perm.No)
        $Perm.No))
    (ite
      (and (< (inv@308@04 r) V@15@04) (<= 0 (inv@308@04 r)))
      (<
        (ite
          (and (< (inv@312@04 r) V@15@04) (<= 0 (inv@312@04 r)))
          $k@311@04
          $Perm.No)
        $Perm.Write)
      (<
        (ite
          (and (< (inv@312@04 r) V@15@04) (<= 0 (inv@312@04 r)))
          $k@311@04
          $Perm.No)
        $Perm.No)))
  :pattern ((inv@308@04 r))
  :pattern ((inv@312@04 r))
  :qid |qp.srp234|)))
; Intermediate check if already taken enough permissions
(set-option :timeout 500)
(push) ; 9
(assert (not (forall ((r $Ref)) (!
  (implies
    (and (< (inv@312@04 r) V@15@04) (<= 0 (inv@312@04 r)))
    (= (- $k@311@04 (pTaken@313@04 r)) $Perm.No))
  
  ))))
(check-sat)
; unsat
(pop) ; 9
; 0.03s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               269446
;  :arith-add-rows          128700
;  :arith-assert-diseq      2981
;  :arith-assert-lower      47980
;  :arith-assert-upper      39103
;  :arith-bound-prop        8599
;  :arith-conflicts         391
;  :arith-eq-adapter        36074
;  :arith-fixed-eqs         36890
;  :arith-offset-eqs        23198
;  :arith-pivots            29087
;  :conflicts               1417
;  :datatype-accessor-ax    187
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               16408
;  :del-clause              838649
;  :final-checks            5
;  :max-generation          11
;  :max-memory              60.52
;  :memory                  54.45
;  :minimized-lits          154
;  :mk-bool-var             822018
;  :mk-clause               839754
;  :num-allocs              2919980
;  :num-checks              297
;  :propagations            177832
;  :quant-instantiations    296516
;  :restarts                1
;  :rlimit-count            9717520
;  :time                    0.03)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@315@04 $FVF<Int>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (iff
    (Set_in r ($FVF.domain_int (as sm@315@04  $FVF<Int>)))
    (and
      (and (< (inv@312@04 r) V@15@04) (<= 0 (inv@312@04 r)))
      (< $Perm.No $k@311@04)))
  :pattern ((Set_in r ($FVF.domain_int (as sm@315@04  $FVF<Int>))))
  :qid |qp.fvfDomDef238|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@312@04 r) V@15@04) (<= 0 (inv@312@04 r)))
        (< $Perm.No $k@311@04))
      (and (< (inv@308@04 r) V@15@04) (<= 0 (inv@308@04 r))))
    (=
      ($FVF.lookup_int (as sm@315@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04)))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@315@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04)))))))))))) r))
  :qid |qp.fvfValDef235|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@312@04 r) V@15@04) (<= 0 (inv@312@04 r)))
        (< $Perm.No $k@311@04))
      (and
        (and
          (and (< (inv@305@04 r) V@15@04) (<= 0 (inv@305@04 r)))
          (< (inv@304@04 r) V@15@04))
        (<= 0 (inv@304@04 r))))
    (=
      ($FVF.lookup_int (as sm@315@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@315@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04))))))))) r))
  :qid |qp.fvfValDef236|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04)))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@315@04  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef237|)))
(pop) ; 8
; Joined path conditions
(assert ($Perm.isReadVar $k@311@04 $Perm.Write))
(assert (forall ((i1@310@04 Int)) (!
  (implies
    (and (and (< i1@310@04 V@15@04) (<= 0 i1@310@04)) (< $Perm.No $k@311@04))
    (=
      (inv@312@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i1@310@04))
      i1@310@04))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i1@310@04))
  :qid |int-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and (< (inv@312@04 r) V@15@04) (<= 0 (inv@312@04 r)))
      (< $Perm.No $k@311@04))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) (inv@312@04 r))
      r))
  :pattern ((inv@312@04 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (iff
    (Set_in r ($FVF.domain_int (as sm@315@04  $FVF<Int>)))
    (and
      (and (< (inv@312@04 r) V@15@04) (<= 0 (inv@312@04 r)))
      (< $Perm.No $k@311@04)))
  :pattern ((Set_in r ($FVF.domain_int (as sm@315@04  $FVF<Int>))))
  :qid |qp.fvfDomDef238|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@312@04 r) V@15@04) (<= 0 (inv@312@04 r)))
        (< $Perm.No $k@311@04))
      (and (< (inv@308@04 r) V@15@04) (<= 0 (inv@308@04 r))))
    (=
      ($FVF.lookup_int (as sm@315@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04)))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@315@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04)))))))))))) r))
  :qid |qp.fvfValDef235|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@312@04 r) V@15@04) (<= 0 (inv@312@04 r)))
        (< $Perm.No $k@311@04))
      (and
        (and
          (and (< (inv@305@04 r) V@15@04) (<= 0 (inv@305@04 r)))
          (< (inv@304@04 r) V@15@04))
        (<= 0 (inv@304@04 r))))
    (=
      ($FVF.lookup_int (as sm@315@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@315@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04))))))))) r))
  :qid |qp.fvfValDef236|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04)))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@315@04  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef237|)))
(assert (and
  (forall ((i1@310@04 Int)) (!
    (< i1@310@04 (alen<Int> (opt_get1 $Snap.unit P@14@04)))
    :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i1@310@04))
    :qid |int-aux|))
  (forall ((r $Ref)) (!
    (implies
      (and (< (inv@312@04 r) V@15@04) (<= 0 (inv@312@04 r)))
      ($FVF.loc_int ($FVF.lookup_int (as sm@309@04  $FVF<Int>) r) r))
    :pattern ((inv@312@04 r))
    ))
  (forall ((r $Ref)) (!
    (implies
      (not
        (=
          (ite
            (and (< (inv@308@04 r) V@15@04) (<= 0 (inv@308@04 r)))
            $Perm.Write
            $Perm.No)
          $Perm.No))
      (ite
        (and (< (inv@308@04 r) V@15@04) (<= 0 (inv@308@04 r)))
        (<
          (ite
            (and (< (inv@312@04 r) V@15@04) (<= 0 (inv@312@04 r)))
            $k@311@04
            $Perm.No)
          $Perm.Write)
        (<
          (ite
            (and (< (inv@312@04 r) V@15@04) (<= 0 (inv@312@04 r)))
            $k@311@04
            $Perm.No)
          $Perm.No)))
    :pattern ((inv@308@04 r))
    :pattern ((inv@312@04 r))
    :qid |qp.srp234|))))
(assert (valid_graph_vertices ($Snap.combine
  $Snap.unit
  ($Snap.combine
    $Snap.unit
    ($Snap.combine
      $Snap.unit
      ($SortWrappers.$FVF<Int>To$Snap (as sm@315@04  $FVF<Int>))))) this@9@04 P@14@04 V@15@04))
; Loop head block: Check well-definedness of edge conditions
(push) ; 8
(pop) ; 8
(push) ; 8
; [eval] !res1
(pop) ; 8
(pop) ; 7
(push) ; 7
; Loop head block: Establish invariant
; [eval] exc == excBeforeLoop
; [eval] G != (None(): option[array])
; [eval] (None(): option[array])
; [eval] alen(opt_get1(G)) == V
; [eval] alen(opt_get1(G))
; [eval] opt_get1(G)
(push) ; 8
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 8
; Joined path conditions
(declare-const i1@316@04 Int)
(push) ; 8
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 9
; [then-branch: 174 | 0 <= i1@316@04 | live]
; [else-branch: 174 | !(0 <= i1@316@04) | live]
(push) ; 10
; [then-branch: 174 | 0 <= i1@316@04]
(assert (<= 0 i1@316@04))
; [eval] i1 < V
(pop) ; 10
(push) ; 10
; [else-branch: 174 | !(0 <= i1@316@04)]
(assert (not (<= 0 i1@316@04)))
(pop) ; 10
(pop) ; 9
; Joined path conditions
; Joined path conditions
(assert (and (< i1@316@04 V@15@04) (<= 0 i1@316@04)))
(declare-const $k@317@04 $Perm)
(assert ($Perm.isReadVar $k@317@04 $Perm.Write))
; [eval] aloc(opt_get1(G), i1)
; [eval] opt_get1(G)
(push) ; 9
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 9
; Joined path conditions
(push) ; 9
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 10
(assert (not (< i1@316@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               269464
;  :arith-add-rows          128704
;  :arith-assert-diseq      2983
;  :arith-assert-lower      47986
;  :arith-assert-upper      39105
;  :arith-bound-prop        8599
;  :arith-conflicts         391
;  :arith-eq-adapter        36076
;  :arith-fixed-eqs         36890
;  :arith-offset-eqs        23198
;  :arith-pivots            29098
;  :conflicts               1417
;  :datatype-accessor-ax    190
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               16408
;  :del-clause              838773
;  :final-checks            5
;  :max-generation          11
;  :max-memory              60.52
;  :memory                  54.44
;  :minimized-lits          154
;  :mk-bool-var             822161
;  :mk-clause               839865
;  :num-allocs              2922200
;  :num-checks              298
;  :propagations            177845
;  :quant-instantiations    296539
;  :restarts                1
;  :rlimit-count            9723659)
(assert (< i1@316@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(pop) ; 9
; Joined path conditions
(assert (< i1@316@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(pop) ; 8
(declare-fun inv@318@04 ($Ref) Int)
; Nested auxiliary terms: globals
(assert ($Perm.isReadVar $k@317@04 $Perm.Write))
; Nested auxiliary terms: non-globals
(assert (forall ((i1@316@04 Int)) (!
  (< i1@316@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@316@04))
  :qid |option$array$-aux|)))
(push) ; 8
(assert (not (forall ((i1@316@04 Int)) (!
  (implies
    (and (< i1@316@04 V@15@04) (<= 0 i1@316@04))
    (or (= $k@317@04 $Perm.No) (< $Perm.No $k@317@04)))
  
  ))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               269464
;  :arith-add-rows          128705
;  :arith-assert-diseq      2984
;  :arith-assert-lower      47988
;  :arith-assert-upper      39106
;  :arith-bound-prop        8599
;  :arith-conflicts         391
;  :arith-eq-adapter        36077
;  :arith-fixed-eqs         36890
;  :arith-offset-eqs        23198
;  :arith-pivots            29098
;  :conflicts               1418
;  :datatype-accessor-ax    190
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               16408
;  :del-clause              838775
;  :final-checks            5
;  :max-generation          11
;  :max-memory              60.52
;  :memory                  54.44
;  :minimized-lits          154
;  :mk-bool-var             822168
;  :mk-clause               839867
;  :num-allocs              2922629
;  :num-checks              299
;  :propagations            177846
;  :quant-instantiations    296539
;  :restarts                1
;  :rlimit-count            9724205)
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 8
(assert (not (forall ((i11@316@04 Int) (i12@316@04 Int)) (!
  (implies
    (and
      (and
        (and
          (and (< i11@316@04 V@15@04) (<= 0 i11@316@04))
          ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@263@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i11@316@04)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i11@316@04)))
        (< $Perm.No $k@317@04))
      (and
        (and
          (and (< i12@316@04 V@15@04) (<= 0 i12@316@04))
          ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@263@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i12@316@04)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i12@316@04)))
        (< $Perm.No $k@317@04))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i11@316@04)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i12@316@04)))
    (= i11@316@04 i12@316@04))
  
  :qid |option$array$-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               269505
;  :arith-add-rows          128714
;  :arith-assert-diseq      2985
;  :arith-assert-lower      47992
;  :arith-assert-upper      39106
;  :arith-bound-prop        8599
;  :arith-conflicts         391
;  :arith-eq-adapter        36078
;  :arith-fixed-eqs         36890
;  :arith-offset-eqs        23198
;  :arith-pivots            29100
;  :conflicts               1419
;  :datatype-accessor-ax    190
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               16408
;  :del-clause              838798
;  :final-checks            5
;  :max-generation          11
;  :max-memory              60.52
;  :memory                  54.44
;  :minimized-lits          154
;  :mk-bool-var             822252
;  :mk-clause               839890
;  :num-allocs              2923538
;  :num-checks              300
;  :propagations            177848
;  :quant-instantiations    296609
;  :restarts                1
;  :rlimit-count            9726999
;  :time                    0.00)
; Definitional axioms for inverse functions
(assert (forall ((i1@316@04 Int)) (!
  (implies
    (and (and (< i1@316@04 V@15@04) (<= 0 i1@316@04)) (< $Perm.No $k@317@04))
    (=
      (inv@318@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@316@04))
      i1@316@04))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@316@04))
  :qid |option$array$-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and (< (inv@318@04 r) V@15@04) (<= 0 (inv@318@04 r)))
      (< $Perm.No $k@317@04))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) (inv@318@04 r))
      r))
  :pattern ((inv@318@04 r))
  :qid |option$array$-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@318@04 r) V@15@04) (<= 0 (inv@318@04 r)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@263@04  $FVF<option<array>>) r) r))
  :pattern ((inv@318@04 r))
  )))
; Precomputing data for removing quantified permissions
(define-fun pTaken@319@04 ((r $Ref)) $Perm
  (ite
    (and (< (inv@318@04 r) V@15@04) (<= 0 (inv@318@04 r)))
    ($Perm.min
      (ite
        (and (< (inv@262@04 r) V@15@04) (<= 0 (inv@262@04 r)))
        $k@261@04
        $Perm.No)
      $k@317@04)
    $Perm.No))
(define-fun pTaken@320@04 ((r $Ref)) $Perm
  (ite
    (and (< (inv@318@04 r) V@15@04) (<= 0 (inv@318@04 r)))
    ($Perm.min
      (-
        (ite
          (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
          $k@20@04
          $Perm.No)
        (pTaken@234@04 r))
      (- $k@317@04 (pTaken@319@04 r)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Constrain original permissions $k@317@04
(assert (forall ((r $Ref)) (!
  (implies
    (not
      (=
        (ite
          (and (< (inv@262@04 r) V@15@04) (<= 0 (inv@262@04 r)))
          $k@261@04
          $Perm.No)
        $Perm.No))
    (ite
      (and (< (inv@262@04 r) V@15@04) (<= 0 (inv@262@04 r)))
      (<
        (ite
          (and (< (inv@318@04 r) V@15@04) (<= 0 (inv@318@04 r)))
          $k@317@04
          $Perm.No)
        $k@261@04)
      (<
        (ite
          (and (< (inv@318@04 r) V@15@04) (<= 0 (inv@318@04 r)))
          $k@317@04
          $Perm.No)
        $Perm.No)))
  :pattern ((inv@262@04 r))
  :pattern ((inv@318@04 r))
  :qid |qp.srp239|)))
; Intermediate check if already taken enough permissions
(set-option :timeout 500)
(push) ; 8
(assert (not (forall ((r $Ref)) (!
  (implies
    (and (< (inv@318@04 r) V@15@04) (<= 0 (inv@318@04 r)))
    (= (- $k@317@04 (pTaken@319@04 r)) $Perm.No))
  
  ))))
(check-sat)
; unsat
(pop) ; 8
; 0.03s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               271157
;  :arith-add-rows          129689
;  :arith-assert-diseq      3010
;  :arith-assert-lower      48230
;  :arith-assert-upper      39261
;  :arith-bound-prop        8668
;  :arith-conflicts         395
;  :arith-eq-adapter        36286
;  :arith-fixed-eqs         37045
;  :arith-offset-eqs        23316
;  :arith-pivots            29289
;  :conflicts               1443
;  :datatype-accessor-ax    190
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               16545
;  :del-clause              844706
;  :final-checks            5
;  :max-generation          11
;  :max-memory              60.52
;  :memory                  54.46
;  :minimized-lits          158
;  :mk-bool-var             827988
;  :mk-clause               845821
;  :num-allocs              2944275
;  :num-checks              302
;  :propagations            178826
;  :quant-instantiations    298536
;  :restarts                1
;  :rlimit-count            9812342
;  :time                    0.03)
; Final check if taken enough permissions
; Done removing quantified permissions
; Definitional axioms for snapshot map values
; [eval] (forall i1: Int :: { aloc(opt_get1(G), i1) } 0 <= i1 && i1 < V ==> aloc(opt_get1(G), i1).option$array$ != (None(): option[array]))
(declare-const i1@321@04 Int)
(push) ; 8
; [eval] 0 <= i1 && i1 < V ==> aloc(opt_get1(G), i1).option$array$ != (None(): option[array])
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 9
; [then-branch: 175 | 0 <= i1@321@04 | live]
; [else-branch: 175 | !(0 <= i1@321@04) | live]
(push) ; 10
; [then-branch: 175 | 0 <= i1@321@04]
(assert (<= 0 i1@321@04))
; [eval] i1 < V
(pop) ; 10
(push) ; 10
; [else-branch: 175 | !(0 <= i1@321@04)]
(assert (not (<= 0 i1@321@04)))
(pop) ; 10
(pop) ; 9
; Joined path conditions
; Joined path conditions
(push) ; 9
; [then-branch: 176 | i1@321@04 < V@15@04 && 0 <= i1@321@04 | live]
; [else-branch: 176 | !(i1@321@04 < V@15@04 && 0 <= i1@321@04) | live]
(push) ; 10
; [then-branch: 176 | i1@321@04 < V@15@04 && 0 <= i1@321@04]
(assert (and (< i1@321@04 V@15@04) (<= 0 i1@321@04)))
; [eval] aloc(opt_get1(G), i1).option$array$ != (None(): option[array])
; [eval] aloc(opt_get1(G), i1)
; [eval] opt_get1(G)
(push) ; 11
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 11
; Joined path conditions
(push) ; 11
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 12
(assert (not (< i1@321@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))))
(check-sat)
; unsat
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               271157
;  :arith-add-rows          129690
;  :arith-assert-diseq      3010
;  :arith-assert-lower      48232
;  :arith-assert-upper      39261
;  :arith-bound-prop        8668
;  :arith-conflicts         395
;  :arith-eq-adapter        36286
;  :arith-fixed-eqs         37045
;  :arith-offset-eqs        23316
;  :arith-pivots            29289
;  :conflicts               1443
;  :datatype-accessor-ax    190
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               16545
;  :del-clause              844706
;  :final-checks            5
;  :max-generation          11
;  :max-memory              60.52
;  :memory                  54.46
;  :minimized-lits          158
;  :mk-bool-var             827990
;  :mk-clause               845821
;  :num-allocs              2944385
;  :num-checks              303
;  :propagations            178826
;  :quant-instantiations    298536
;  :restarts                1
;  :rlimit-count            9812533)
(assert (< i1@321@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(pop) ; 11
; Joined path conditions
(assert (< i1@321@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@263@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@321@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@321@04)))
(push) ; 11
(assert (not (<
  $Perm.No
  (+
    (ite
      (and
        (<
          (inv@262@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@321@04))
          V@15@04)
        (<=
          0
          (inv@262@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@321@04))))
      $k@261@04
      $Perm.No)
    (-
      (ite
        (and
          (<
            (inv@21@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@321@04))
            V@15@04)
          (<=
            0
            (inv@21@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@321@04))))
        $k@20@04
        $Perm.No)
      (pTaken@234@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@321@04)))))))
(check-sat)
; unsat
(pop) ; 11
; 0.03s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               272218
;  :arith-add-rows          130410
;  :arith-assert-diseq      3023
;  :arith-assert-lower      48381
;  :arith-assert-upper      39358
;  :arith-bound-prop        8720
;  :arith-conflicts         398
;  :arith-eq-adapter        36417
;  :arith-fixed-eqs         37143
;  :arith-offset-eqs        23379
;  :arith-pivots            29385
;  :conflicts               1462
;  :datatype-accessor-ax    190
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               16659
;  :del-clause              849149
;  :final-checks            5
;  :max-generation          11
;  :max-memory              60.52
;  :memory                  54.80
;  :minimized-lits          160
;  :mk-bool-var             832255
;  :mk-clause               850502
;  :num-allocs              2958142
;  :num-checks              304
;  :propagations            179537
;  :quant-instantiations    299817
;  :restarts                1
;  :rlimit-count            9869829
;  :time                    0.03)
; [eval] (None(): option[array])
(pop) ; 10
(push) ; 10
; [else-branch: 176 | !(i1@321@04 < V@15@04 && 0 <= i1@321@04)]
(assert (not (and (< i1@321@04 V@15@04) (<= 0 i1@321@04))))
(pop) ; 10
(pop) ; 9
; Joined path conditions
(assert (implies
  (and (< i1@321@04 V@15@04) (<= 0 i1@321@04))
  (and
    (< i1@321@04 V@15@04)
    (<= 0 i1@321@04)
    (< i1@321@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@263@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@321@04)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@321@04)))))
; Joined path conditions
(pop) ; 8
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@321@04 Int)) (!
  (implies
    (and (< i1@321@04 V@15@04) (<= 0 i1@321@04))
    (and
      (< i1@321@04 V@15@04)
      (<= 0 i1@321@04)
      (< i1@321@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@263@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@321@04)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@321@04))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@321@04))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(push) ; 8
(assert (not (forall ((i1@321@04 Int)) (!
  (implies
    (and (< i1@321@04 V@15@04) (<= 0 i1@321@04))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@263@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@321@04))
        (as None<option<array>>  option<array>))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@321@04))
  :qid |prog.l<no position>|))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               272240
;  :arith-add-rows          130439
;  :arith-assert-diseq      3023
;  :arith-assert-lower      48385
;  :arith-assert-upper      39360
;  :arith-bound-prop        8722
;  :arith-conflicts         398
;  :arith-eq-adapter        36420
;  :arith-fixed-eqs         37145
;  :arith-offset-eqs        23379
;  :arith-pivots            29405
;  :conflicts               1463
;  :datatype-accessor-ax    190
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               16659
;  :del-clause              849540
;  :final-checks            5
;  :max-generation          11
;  :max-memory              60.52
;  :memory                  54.78
;  :minimized-lits          160
;  :mk-bool-var             832446
;  :mk-clause               850655
;  :num-allocs              2959595
;  :num-checks              305
;  :propagations            179543
;  :quant-instantiations    299929
;  :restarts                1
;  :rlimit-count            9874937
;  :time                    0.00)
(assert (forall ((i1@321@04 Int)) (!
  (implies
    (and (< i1@321@04 V@15@04) (<= 0 i1@321@04))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@263@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@321@04))
        (as None<option<array>>  option<array>))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@321@04))
  :qid |prog.l<no position>|)))
; [eval] (forall i1: Int :: { alen(opt_get1(aloc(opt_get1(G), i1).option$array$)) } 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(G), i1).option$array$)) == V)
(declare-const i1@322@04 Int)
(push) ; 8
; [eval] 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(G), i1).option$array$)) == V
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 9
; [then-branch: 177 | 0 <= i1@322@04 | live]
; [else-branch: 177 | !(0 <= i1@322@04) | live]
(push) ; 10
; [then-branch: 177 | 0 <= i1@322@04]
(assert (<= 0 i1@322@04))
; [eval] i1 < V
(pop) ; 10
(push) ; 10
; [else-branch: 177 | !(0 <= i1@322@04)]
(assert (not (<= 0 i1@322@04)))
(pop) ; 10
(pop) ; 9
; Joined path conditions
; Joined path conditions
(push) ; 9
; [then-branch: 178 | i1@322@04 < V@15@04 && 0 <= i1@322@04 | live]
; [else-branch: 178 | !(i1@322@04 < V@15@04 && 0 <= i1@322@04) | live]
(push) ; 10
; [then-branch: 178 | i1@322@04 < V@15@04 && 0 <= i1@322@04]
(assert (and (< i1@322@04 V@15@04) (<= 0 i1@322@04)))
; [eval] alen(opt_get1(aloc(opt_get1(G), i1).option$array$)) == V
; [eval] alen(opt_get1(aloc(opt_get1(G), i1).option$array$))
; [eval] opt_get1(aloc(opt_get1(G), i1).option$array$)
; [eval] aloc(opt_get1(G), i1)
; [eval] opt_get1(G)
(push) ; 11
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 11
; Joined path conditions
(push) ; 11
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 12
(assert (not (< i1@322@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))))
(check-sat)
; unsat
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               272240
;  :arith-add-rows          130440
;  :arith-assert-diseq      3023
;  :arith-assert-lower      48387
;  :arith-assert-upper      39360
;  :arith-bound-prop        8722
;  :arith-conflicts         398
;  :arith-eq-adapter        36420
;  :arith-fixed-eqs         37145
;  :arith-offset-eqs        23379
;  :arith-pivots            29405
;  :conflicts               1463
;  :datatype-accessor-ax    190
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               16659
;  :del-clause              849540
;  :final-checks            5
;  :max-generation          11
;  :max-memory              60.52
;  :memory                  54.78
;  :minimized-lits          160
;  :mk-bool-var             832449
;  :mk-clause               850655
;  :num-allocs              2959888
;  :num-checks              306
;  :propagations            179543
;  :quant-instantiations    299929
;  :restarts                1
;  :rlimit-count            9875437)
(assert (< i1@322@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(pop) ; 11
; Joined path conditions
(assert (< i1@322@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@263@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@322@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@322@04)))
(push) ; 11
(assert (not (<
  $Perm.No
  (+
    (ite
      (and
        (<
          (inv@262@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@322@04))
          V@15@04)
        (<=
          0
          (inv@262@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@322@04))))
      $k@261@04
      $Perm.No)
    (-
      (ite
        (and
          (<
            (inv@21@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@322@04))
            V@15@04)
          (<=
            0
            (inv@21@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@322@04))))
        $k@20@04
        $Perm.No)
      (pTaken@234@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@322@04)))))))
(check-sat)
; unsat
(pop) ; 11
; 0.02s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               273300
;  :arith-add-rows          131149
;  :arith-assert-diseq      3036
;  :arith-assert-lower      48537
;  :arith-assert-upper      39456
;  :arith-bound-prop        8774
;  :arith-conflicts         401
;  :arith-eq-adapter        36550
;  :arith-fixed-eqs         37243
;  :arith-offset-eqs        23442
;  :arith-pivots            29495
;  :conflicts               1482
;  :datatype-accessor-ax    190
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               16773
;  :del-clause              853979
;  :final-checks            5
;  :max-generation          11
;  :max-memory              60.52
;  :memory                  54.81
;  :minimized-lits          162
;  :mk-bool-var             836711
;  :mk-clause               855332
;  :num-allocs              2973678
;  :num-checks              307
;  :propagations            180254
;  :quant-instantiations    301217
;  :restarts                1
;  :rlimit-count            9933176
;  :time                    0.02)
(push) ; 11
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 12
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@263@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@322@04))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               273300
;  :arith-add-rows          131149
;  :arith-assert-diseq      3036
;  :arith-assert-lower      48537
;  :arith-assert-upper      39456
;  :arith-bound-prop        8774
;  :arith-conflicts         401
;  :arith-eq-adapter        36550
;  :arith-fixed-eqs         37243
;  :arith-offset-eqs        23442
;  :arith-pivots            29495
;  :conflicts               1483
;  :datatype-accessor-ax    190
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               16773
;  :del-clause              853979
;  :final-checks            5
;  :max-generation          11
;  :max-memory              60.52
;  :memory                  54.81
;  :minimized-lits          162
;  :mk-bool-var             836711
;  :mk-clause               855332
;  :num-allocs              2973768
;  :num-checks              308
;  :propagations            180254
;  :quant-instantiations    301217
;  :restarts                1
;  :rlimit-count            9933271)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@263@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@322@04))
    (as None<option<array>>  option<array>))))
(pop) ; 11
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@263@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@322@04))
    (as None<option<array>>  option<array>))))
(pop) ; 10
(push) ; 10
; [else-branch: 178 | !(i1@322@04 < V@15@04 && 0 <= i1@322@04)]
(assert (not (and (< i1@322@04 V@15@04) (<= 0 i1@322@04))))
(pop) ; 10
(pop) ; 9
; Joined path conditions
(assert (implies
  (and (< i1@322@04 V@15@04) (<= 0 i1@322@04))
  (and
    (< i1@322@04 V@15@04)
    (<= 0 i1@322@04)
    (< i1@322@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@263@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@322@04)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@322@04))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@263@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@322@04))
        (as None<option<array>>  option<array>))))))
; Joined path conditions
(pop) ; 8
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@322@04 Int)) (!
  (implies
    (and (< i1@322@04 V@15@04) (<= 0 i1@322@04))
    (and
      (< i1@322@04 V@15@04)
      (<= 0 i1@322@04)
      (< i1@322@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@263@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@322@04)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@322@04))
      (not
        (=
          ($FVF.lookup_option$array$ (as sm@263@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@322@04))
          (as None<option<array>>  option<array>)))))
  :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@263@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@322@04)))))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(push) ; 8
(assert (not (forall ((i1@322@04 Int)) (!
  (implies
    (and (< i1@322@04 V@15@04) (<= 0 i1@322@04))
    (=
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@263@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@322@04))))
      V@15@04))
  :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@263@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@322@04)))))
  :qid |prog.l<no position>|))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               273300
;  :arith-add-rows          131166
;  :arith-assert-diseq      3036
;  :arith-assert-lower      48539
;  :arith-assert-upper      39456
;  :arith-bound-prop        8774
;  :arith-conflicts         401
;  :arith-eq-adapter        36553
;  :arith-fixed-eqs         37243
;  :arith-offset-eqs        23442
;  :arith-pivots            29511
;  :conflicts               1484
;  :datatype-accessor-ax    190
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               16773
;  :del-clause              854251
;  :final-checks            5
;  :max-generation          11
;  :max-memory              60.52
;  :memory                  54.78
;  :minimized-lits          162
;  :mk-bool-var             836779
;  :mk-clause               855366
;  :num-allocs              2974590
;  :num-checks              309
;  :propagations            180254
;  :quant-instantiations    301263
;  :restarts                1
;  :rlimit-count            9935724
;  :time                    0.00)
(assert (forall ((i1@322@04 Int)) (!
  (implies
    (and (< i1@322@04 V@15@04) (<= 0 i1@322@04))
    (=
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@263@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@322@04))))
      V@15@04))
  :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@263@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@322@04)))))
  :qid |prog.l<no position>|)))
; [eval] (forall i1: Int :: { aloc(opt_get1(G), i1) } (forall i2: Int :: { aloc(opt_get1(G), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(G), i1).option$array$ == aloc(opt_get1(G), i2).option$array$ ==> i1 == i2))
(declare-const i1@323@04 Int)
(push) ; 8
; [eval] (forall i2: Int :: { aloc(opt_get1(G), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(G), i1).option$array$ == aloc(opt_get1(G), i2).option$array$ ==> i1 == i2)
(declare-const i2@324@04 Int)
(push) ; 9
; [eval] 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(G), i1).option$array$ == aloc(opt_get1(G), i2).option$array$ ==> i1 == i2
; [eval] 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(G), i1).option$array$ == aloc(opt_get1(G), i2).option$array$
; [eval] 0 <= i1
(push) ; 10
; [then-branch: 179 | 0 <= i1@323@04 | live]
; [else-branch: 179 | !(0 <= i1@323@04) | live]
(push) ; 11
; [then-branch: 179 | 0 <= i1@323@04]
(assert (<= 0 i1@323@04))
; [eval] i1 < V
(push) ; 12
; [then-branch: 180 | i1@323@04 < V@15@04 | live]
; [else-branch: 180 | !(i1@323@04 < V@15@04) | live]
(push) ; 13
; [then-branch: 180 | i1@323@04 < V@15@04]
(assert (< i1@323@04 V@15@04))
; [eval] 0 <= i2
(push) ; 14
; [then-branch: 181 | 0 <= i2@324@04 | live]
; [else-branch: 181 | !(0 <= i2@324@04) | live]
(push) ; 15
; [then-branch: 181 | 0 <= i2@324@04]
(assert (<= 0 i2@324@04))
; [eval] i2 < V
(push) ; 16
; [then-branch: 182 | i2@324@04 < V@15@04 | live]
; [else-branch: 182 | !(i2@324@04 < V@15@04) | live]
(push) ; 17
; [then-branch: 182 | i2@324@04 < V@15@04]
(assert (< i2@324@04 V@15@04))
; [eval] aloc(opt_get1(G), i1).option$array$ == aloc(opt_get1(G), i2).option$array$
; [eval] aloc(opt_get1(G), i1)
; [eval] opt_get1(G)
(push) ; 18
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 18
; Joined path conditions
(push) ; 18
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 19
(assert (not (< i1@323@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))))
(check-sat)
; unsat
(pop) ; 19
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               273300
;  :arith-add-rows          131168
;  :arith-assert-diseq      3036
;  :arith-assert-lower      48543
;  :arith-assert-upper      39456
;  :arith-bound-prop        8774
;  :arith-conflicts         401
;  :arith-eq-adapter        36553
;  :arith-fixed-eqs         37243
;  :arith-offset-eqs        23442
;  :arith-pivots            29512
;  :conflicts               1484
;  :datatype-accessor-ax    190
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               16773
;  :del-clause              854251
;  :final-checks            5
;  :max-generation          11
;  :max-memory              60.52
;  :memory                  54.78
;  :minimized-lits          162
;  :mk-bool-var             836784
;  :mk-clause               855366
;  :num-allocs              2975068
;  :num-checks              310
;  :propagations            180254
;  :quant-instantiations    301263
;  :restarts                1
;  :rlimit-count            9936375)
(assert (< i1@323@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(pop) ; 18
; Joined path conditions
(assert (< i1@323@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@263@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@323@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@323@04)))
(push) ; 18
(assert (not (<
  $Perm.No
  (+
    (ite
      (and
        (<
          (inv@262@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@323@04))
          V@15@04)
        (<=
          0
          (inv@262@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@323@04))))
      $k@261@04
      $Perm.No)
    (-
      (ite
        (and
          (<
            (inv@21@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@323@04))
            V@15@04)
          (<=
            0
            (inv@21@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@323@04))))
        $k@20@04
        $Perm.No)
      (pTaken@234@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@323@04)))))))
(check-sat)
; unsat
(pop) ; 18
; 0.03s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               274355
;  :arith-add-rows          131825
;  :arith-assert-diseq      3050
;  :arith-assert-lower      48692
;  :arith-assert-upper      39553
;  :arith-bound-prop        8826
;  :arith-conflicts         404
;  :arith-eq-adapter        36684
;  :arith-fixed-eqs         37341
;  :arith-offset-eqs        23493
;  :arith-pivots            29603
;  :conflicts               1503
;  :datatype-accessor-ax    190
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               16889
;  :del-clause              858693
;  :final-checks            5
;  :max-generation          11
;  :max-memory              60.52
;  :memory                  54.81
;  :minimized-lits          164
;  :mk-bool-var             841051
;  :mk-clause               860046
;  :num-allocs              2988757
;  :num-checks              311
;  :propagations            180965
;  :quant-instantiations    302553
;  :restarts                1
;  :rlimit-count            9994343
;  :time                    0.03)
; [eval] aloc(opt_get1(G), i2)
; [eval] opt_get1(G)
(push) ; 18
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 18
; Joined path conditions
(push) ; 18
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 19
(assert (not (< i2@324@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))))
(check-sat)
; unsat
(pop) ; 19
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               274355
;  :arith-add-rows          131825
;  :arith-assert-diseq      3050
;  :arith-assert-lower      48692
;  :arith-assert-upper      39553
;  :arith-bound-prop        8826
;  :arith-conflicts         404
;  :arith-eq-adapter        36684
;  :arith-fixed-eqs         37341
;  :arith-offset-eqs        23493
;  :arith-pivots            29603
;  :conflicts               1503
;  :datatype-accessor-ax    190
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               16889
;  :del-clause              858693
;  :final-checks            5
;  :max-generation          11
;  :max-memory              60.52
;  :memory                  54.81
;  :minimized-lits          164
;  :mk-bool-var             841051
;  :mk-clause               860046
;  :num-allocs              2988783
;  :num-checks              312
;  :propagations            180965
;  :quant-instantiations    302553
;  :restarts                1
;  :rlimit-count            9994373)
(assert (< i2@324@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(pop) ; 18
; Joined path conditions
(assert (< i2@324@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@263@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@324@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@324@04)))
(push) ; 18
(assert (not (<
  $Perm.No
  (+
    (ite
      (and
        (<
          (inv@262@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@324@04))
          V@15@04)
        (<=
          0
          (inv@262@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@324@04))))
      $k@261@04
      $Perm.No)
    (-
      (ite
        (and
          (<
            (inv@21@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@324@04))
            V@15@04)
          (<=
            0
            (inv@21@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@324@04))))
        $k@20@04
        $Perm.No)
      (pTaken@234@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@324@04)))))))
(check-sat)
; unsat
(pop) ; 18
; 0.03s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               275597
;  :arith-add-rows          132759
;  :arith-assert-diseq      3075
;  :arith-assert-lower      48886
;  :arith-assert-upper      39672
;  :arith-bound-prop        8897
;  :arith-conflicts         412
;  :arith-eq-adapter        36854
;  :arith-fixed-eqs         37450
;  :arith-offset-eqs        23554
;  :arith-pivots            29720
;  :conflicts               1530
;  :datatype-accessor-ax    190
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               17031
;  :del-clause              863989
;  :final-checks            5
;  :max-generation          11
;  :max-memory              60.52
;  :memory                  54.84
;  :minimized-lits          166
;  :mk-bool-var             846129
;  :mk-clause               865538
;  :num-allocs              3005133
;  :num-checks              313
;  :propagations            181896
;  :quant-instantiations    303993
;  :restarts                1
;  :rlimit-count            10062450
;  :time                    0.03)
(pop) ; 17
(push) ; 17
; [else-branch: 182 | !(i2@324@04 < V@15@04)]
(assert (not (< i2@324@04 V@15@04)))
(pop) ; 17
(pop) ; 16
; Joined path conditions
(assert (implies
  (< i2@324@04 V@15@04)
  (and
    (< i2@324@04 V@15@04)
    (< i1@323@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@263@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@323@04)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@323@04))
    (< i2@324@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@263@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@324@04)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@324@04)))))
; Joined path conditions
(pop) ; 15
(push) ; 15
; [else-branch: 181 | !(0 <= i2@324@04)]
(assert (not (<= 0 i2@324@04)))
(pop) ; 15
(pop) ; 14
; Joined path conditions
(assert (implies
  (<= 0 i2@324@04)
  (and
    (<= 0 i2@324@04)
    (implies
      (< i2@324@04 V@15@04)
      (and
        (< i2@324@04 V@15@04)
        (< i1@323@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@263@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@323@04)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@323@04))
        (< i2@324@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@263@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@324@04)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@324@04)))))))
; Joined path conditions
(pop) ; 13
(push) ; 13
; [else-branch: 180 | !(i1@323@04 < V@15@04)]
(assert (not (< i1@323@04 V@15@04)))
(pop) ; 13
(pop) ; 12
; Joined path conditions
(assert (implies
  (< i1@323@04 V@15@04)
  (and
    (< i1@323@04 V@15@04)
    (implies
      (<= 0 i2@324@04)
      (and
        (<= 0 i2@324@04)
        (implies
          (< i2@324@04 V@15@04)
          (and
            (< i2@324@04 V@15@04)
            (< i1@323@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@263@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@323@04)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@323@04))
            (< i2@324@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@263@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@324@04)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@324@04)))))))))
; Joined path conditions
(pop) ; 11
(push) ; 11
; [else-branch: 179 | !(0 <= i1@323@04)]
(assert (not (<= 0 i1@323@04)))
(pop) ; 11
(pop) ; 10
; Joined path conditions
(assert (implies
  (<= 0 i1@323@04)
  (and
    (<= 0 i1@323@04)
    (implies
      (< i1@323@04 V@15@04)
      (and
        (< i1@323@04 V@15@04)
        (implies
          (<= 0 i2@324@04)
          (and
            (<= 0 i2@324@04)
            (implies
              (< i2@324@04 V@15@04)
              (and
                (< i2@324@04 V@15@04)
                (< i1@323@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@263@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@323@04)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@323@04))
                (< i2@324@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@263@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@324@04)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@324@04)))))))))))
; Joined path conditions
(push) ; 10
; [then-branch: 183 | Lookup(option$array$,sm@263@04,aloc((_, _), opt_get1(_, G@11@04), i1@323@04)) == Lookup(option$array$,sm@263@04,aloc((_, _), opt_get1(_, G@11@04), i2@324@04)) && i2@324@04 < V@15@04 && 0 <= i2@324@04 && i1@323@04 < V@15@04 && 0 <= i1@323@04 | live]
; [else-branch: 183 | !(Lookup(option$array$,sm@263@04,aloc((_, _), opt_get1(_, G@11@04), i1@323@04)) == Lookup(option$array$,sm@263@04,aloc((_, _), opt_get1(_, G@11@04), i2@324@04)) && i2@324@04 < V@15@04 && 0 <= i2@324@04 && i1@323@04 < V@15@04 && 0 <= i1@323@04) | live]
(push) ; 11
; [then-branch: 183 | Lookup(option$array$,sm@263@04,aloc((_, _), opt_get1(_, G@11@04), i1@323@04)) == Lookup(option$array$,sm@263@04,aloc((_, _), opt_get1(_, G@11@04), i2@324@04)) && i2@324@04 < V@15@04 && 0 <= i2@324@04 && i1@323@04 < V@15@04 && 0 <= i1@323@04]
(assert (and
  (and
    (and
      (and
        (=
          ($FVF.lookup_option$array$ (as sm@263@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@323@04))
          ($FVF.lookup_option$array$ (as sm@263@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@324@04)))
        (< i2@324@04 V@15@04))
      (<= 0 i2@324@04))
    (< i1@323@04 V@15@04))
  (<= 0 i1@323@04)))
; [eval] i1 == i2
(pop) ; 11
(push) ; 11
; [else-branch: 183 | !(Lookup(option$array$,sm@263@04,aloc((_, _), opt_get1(_, G@11@04), i1@323@04)) == Lookup(option$array$,sm@263@04,aloc((_, _), opt_get1(_, G@11@04), i2@324@04)) && i2@324@04 < V@15@04 && 0 <= i2@324@04 && i1@323@04 < V@15@04 && 0 <= i1@323@04)]
(assert (not
  (and
    (and
      (and
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@263@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@323@04))
            ($FVF.lookup_option$array$ (as sm@263@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@324@04)))
          (< i2@324@04 V@15@04))
        (<= 0 i2@324@04))
      (< i1@323@04 V@15@04))
    (<= 0 i1@323@04))))
(pop) ; 11
(pop) ; 10
; Joined path conditions
(assert (implies
  (and
    (and
      (and
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@263@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@323@04))
            ($FVF.lookup_option$array$ (as sm@263@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@324@04)))
          (< i2@324@04 V@15@04))
        (<= 0 i2@324@04))
      (< i1@323@04 V@15@04))
    (<= 0 i1@323@04))
  (and
    (=
      ($FVF.lookup_option$array$ (as sm@263@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@323@04))
      ($FVF.lookup_option$array$ (as sm@263@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@324@04)))
    (< i2@324@04 V@15@04)
    (<= 0 i2@324@04)
    (< i1@323@04 V@15@04)
    (<= 0 i1@323@04))))
; Joined path conditions
(pop) ; 9
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i2@324@04 Int)) (!
  (and
    (implies
      (<= 0 i1@323@04)
      (and
        (<= 0 i1@323@04)
        (implies
          (< i1@323@04 V@15@04)
          (and
            (< i1@323@04 V@15@04)
            (implies
              (<= 0 i2@324@04)
              (and
                (<= 0 i2@324@04)
                (implies
                  (< i2@324@04 V@15@04)
                  (and
                    (< i2@324@04 V@15@04)
                    (< i1@323@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
                    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@263@04  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@323@04)) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@323@04))
                    (< i2@324@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
                    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@263@04  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@324@04)) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@324@04))))))))))
    (implies
      (and
        (and
          (and
            (and
              (=
                ($FVF.lookup_option$array$ (as sm@263@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@323@04))
                ($FVF.lookup_option$array$ (as sm@263@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@324@04)))
              (< i2@324@04 V@15@04))
            (<= 0 i2@324@04))
          (< i1@323@04 V@15@04))
        (<= 0 i1@323@04))
      (and
        (=
          ($FVF.lookup_option$array$ (as sm@263@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@323@04))
          ($FVF.lookup_option$array$ (as sm@263@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@324@04)))
        (< i2@324@04 V@15@04)
        (<= 0 i2@324@04)
        (< i1@323@04 V@15@04)
        (<= 0 i1@323@04))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@324@04))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 8
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@323@04 Int)) (!
  (forall ((i2@324@04 Int)) (!
    (and
      (implies
        (<= 0 i1@323@04)
        (and
          (<= 0 i1@323@04)
          (implies
            (< i1@323@04 V@15@04)
            (and
              (< i1@323@04 V@15@04)
              (implies
                (<= 0 i2@324@04)
                (and
                  (<= 0 i2@324@04)
                  (implies
                    (< i2@324@04 V@15@04)
                    (and
                      (< i2@324@04 V@15@04)
                      (< i1@323@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
                      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@263@04  $FVF<option<array>>) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@323@04)) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@323@04))
                      (< i2@324@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
                      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@263@04  $FVF<option<array>>) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@324@04)) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@324@04))))))))))
      (implies
        (and
          (and
            (and
              (and
                (=
                  ($FVF.lookup_option$array$ (as sm@263@04  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@323@04))
                  ($FVF.lookup_option$array$ (as sm@263@04  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@324@04)))
                (< i2@324@04 V@15@04))
              (<= 0 i2@324@04))
            (< i1@323@04 V@15@04))
          (<= 0 i1@323@04))
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@263@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@323@04))
            ($FVF.lookup_option$array$ (as sm@263@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@324@04)))
          (< i2@324@04 V@15@04)
          (<= 0 i2@324@04)
          (< i1@323@04 V@15@04)
          (<= 0 i1@323@04))))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@324@04))
    :qid |prog.l<no position>-aux|))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@323@04))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(push) ; 8
(assert (not (forall ((i1@323@04 Int)) (!
  (forall ((i2@324@04 Int)) (!
    (implies
      (and
        (and
          (and
            (and
              (=
                ($FVF.lookup_option$array$ (as sm@263@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@323@04))
                ($FVF.lookup_option$array$ (as sm@263@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@324@04)))
              (< i2@324@04 V@15@04))
            (<= 0 i2@324@04))
          (< i1@323@04 V@15@04))
        (<= 0 i1@323@04))
      (= i1@323@04 i2@324@04))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@324@04))
    :qid |prog.l<no position>|))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@323@04))
  :qid |prog.l<no position>|))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               275735
;  :arith-add-rows          132863
;  :arith-assert-diseq      3076
;  :arith-assert-lower      48904
;  :arith-assert-upper      39678
;  :arith-bound-prop        8905
;  :arith-conflicts         412
;  :arith-eq-adapter        36885
;  :arith-fixed-eqs         37456
;  :arith-offset-eqs        23568
;  :arith-pivots            29770
;  :conflicts               1531
;  :datatype-accessor-ax    190
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               17031
;  :del-clause              864883
;  :final-checks            5
;  :max-generation          11
;  :max-memory              60.52
;  :memory                  54.79
;  :minimized-lits          166
;  :mk-bool-var             846817
;  :mk-clause               865998
;  :num-allocs              3008865
;  :num-checks              314
;  :propagations            181924
;  :quant-instantiations    304282
;  :restarts                1
;  :rlimit-count            10077253
;  :time                    0.01)
(assert (forall ((i1@323@04 Int)) (!
  (forall ((i2@324@04 Int)) (!
    (implies
      (and
        (and
          (and
            (and
              (=
                ($FVF.lookup_option$array$ (as sm@263@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@323@04))
                ($FVF.lookup_option$array$ (as sm@263@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@324@04)))
              (< i2@324@04 V@15@04))
            (<= 0 i2@324@04))
          (< i1@323@04 V@15@04))
        (<= 0 i1@323@04))
      (= i1@323@04 i2@324@04))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@324@04))
    :qid |prog.l<no position>|))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@323@04))
  :qid |prog.l<no position>|)))
(declare-const i1@325@04 Int)
(declare-const j@326@04 Int)
(push) ; 8
; [eval] 0 <= i1 && i1 < V && (0 <= j && j < V)
; [eval] 0 <= i1
(push) ; 9
; [then-branch: 184 | 0 <= i1@325@04 | live]
; [else-branch: 184 | !(0 <= i1@325@04) | live]
(push) ; 10
; [then-branch: 184 | 0 <= i1@325@04]
(assert (<= 0 i1@325@04))
; [eval] i1 < V
(push) ; 11
; [then-branch: 185 | i1@325@04 < V@15@04 | live]
; [else-branch: 185 | !(i1@325@04 < V@15@04) | live]
(push) ; 12
; [then-branch: 185 | i1@325@04 < V@15@04]
(assert (< i1@325@04 V@15@04))
; [eval] 0 <= j
(push) ; 13
; [then-branch: 186 | 0 <= j@326@04 | live]
; [else-branch: 186 | !(0 <= j@326@04) | live]
(push) ; 14
; [then-branch: 186 | 0 <= j@326@04]
(assert (<= 0 j@326@04))
; [eval] j < V
(pop) ; 14
(push) ; 14
; [else-branch: 186 | !(0 <= j@326@04)]
(assert (not (<= 0 j@326@04)))
(pop) ; 14
(pop) ; 13
; Joined path conditions
; Joined path conditions
(pop) ; 12
(push) ; 12
; [else-branch: 185 | !(i1@325@04 < V@15@04)]
(assert (not (< i1@325@04 V@15@04)))
(pop) ; 12
(pop) ; 11
; Joined path conditions
; Joined path conditions
(pop) ; 10
(push) ; 10
; [else-branch: 184 | !(0 <= i1@325@04)]
(assert (not (<= 0 i1@325@04)))
(pop) ; 10
(pop) ; 9
; Joined path conditions
; Joined path conditions
(assert (and
  (and (and (< j@326@04 V@15@04) (<= 0 j@326@04)) (< i1@325@04 V@15@04))
  (<= 0 i1@325@04)))
; [eval] aloc(opt_get1(aloc(opt_get1(G), i1).option$array$), j)
; [eval] opt_get1(aloc(opt_get1(G), i1).option$array$)
; [eval] aloc(opt_get1(G), i1)
; [eval] opt_get1(G)
(push) ; 9
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 9
; Joined path conditions
(push) ; 9
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 10
(assert (not (< i1@325@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               275735
;  :arith-add-rows          132866
;  :arith-assert-diseq      3076
;  :arith-assert-lower      48910
;  :arith-assert-upper      39678
;  :arith-bound-prop        8905
;  :arith-conflicts         412
;  :arith-eq-adapter        36885
;  :arith-fixed-eqs         37456
;  :arith-offset-eqs        23568
;  :arith-pivots            29771
;  :conflicts               1531
;  :datatype-accessor-ax    190
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               17031
;  :del-clause              864883
;  :final-checks            5
;  :max-generation          11
;  :max-memory              60.52
;  :memory                  54.79
;  :minimized-lits          166
;  :mk-bool-var             846824
;  :mk-clause               865998
;  :num-allocs              3009471
;  :num-checks              315
;  :propagations            181924
;  :quant-instantiations    304282
;  :restarts                1
;  :rlimit-count            10078257)
(assert (< i1@325@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(pop) ; 9
; Joined path conditions
(assert (< i1@325@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@263@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@325@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@325@04)))
(push) ; 9
(assert (not (<
  $Perm.No
  (+
    (ite
      (and
        (<
          (inv@262@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@325@04))
          V@15@04)
        (<=
          0
          (inv@262@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@325@04))))
      $k@261@04
      $Perm.No)
    (-
      (ite
        (and
          (<
            (inv@21@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@325@04))
            V@15@04)
          (<=
            0
            (inv@21@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@325@04))))
        $k@20@04
        $Perm.No)
      (pTaken@234@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@325@04)))))))
(check-sat)
; unsat
(pop) ; 9
; 0.03s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               276793
;  :arith-add-rows          133521
;  :arith-assert-diseq      3091
;  :arith-assert-lower      49065
;  :arith-assert-upper      39775
;  :arith-bound-prop        8959
;  :arith-conflicts         415
;  :arith-eq-adapter        37018
;  :arith-fixed-eqs         37555
;  :arith-offset-eqs        23620
;  :arith-pivots            29861
;  :conflicts               1550
;  :datatype-accessor-ax    190
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               17148
;  :del-clause              869364
;  :final-checks            5
;  :max-generation          11
;  :max-memory              60.52
;  :memory                  54.82
;  :minimized-lits          168
;  :mk-bool-var             851154
;  :mk-clause               870717
;  :num-allocs              3023682
;  :num-checks              316
;  :propagations            182636
;  :quant-instantiations    305609
;  :restarts                1
;  :rlimit-count            10138772
;  :time                    0.03)
(push) ; 9
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 10
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@263@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@325@04))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               276793
;  :arith-add-rows          133521
;  :arith-assert-diseq      3091
;  :arith-assert-lower      49065
;  :arith-assert-upper      39775
;  :arith-bound-prop        8959
;  :arith-conflicts         415
;  :arith-eq-adapter        37018
;  :arith-fixed-eqs         37555
;  :arith-offset-eqs        23620
;  :arith-pivots            29861
;  :conflicts               1551
;  :datatype-accessor-ax    190
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               17148
;  :del-clause              869364
;  :final-checks            5
;  :max-generation          11
;  :max-memory              60.52
;  :memory                  54.82
;  :minimized-lits          168
;  :mk-bool-var             851154
;  :mk-clause               870717
;  :num-allocs              3023772
;  :num-checks              317
;  :propagations            182636
;  :quant-instantiations    305609
;  :restarts                1
;  :rlimit-count            10138867)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@263@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@325@04))
    (as None<option<array>>  option<array>))))
(pop) ; 9
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@263@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@325@04))
    (as None<option<array>>  option<array>))))
(push) ; 9
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 10
(assert (not (<
  j@326@04
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@263@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@325@04)))))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               276799
;  :arith-add-rows          133527
;  :arith-assert-diseq      3091
;  :arith-assert-lower      49067
;  :arith-assert-upper      39777
;  :arith-bound-prop        8959
;  :arith-conflicts         416
;  :arith-eq-adapter        37019
;  :arith-fixed-eqs         37556
;  :arith-offset-eqs        23620
;  :arith-pivots            29865
;  :conflicts               1552
;  :datatype-accessor-ax    190
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               17148
;  :del-clause              869368
;  :final-checks            5
;  :max-generation          11
;  :max-memory              60.52
;  :memory                  54.82
;  :minimized-lits          168
;  :mk-bool-var             851165
;  :mk-clause               870721
;  :num-allocs              3023970
;  :num-checks              318
;  :propagations            182638
;  :quant-instantiations    305618
;  :restarts                1
;  :rlimit-count            10139424
;  :time                    0.00)
(assert (<
  j@326@04
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@263@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@325@04))))))
(pop) ; 9
; Joined path conditions
(assert (<
  j@326@04
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@263@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@325@04))))))
(pop) ; 8
(declare-fun inv@327@04 ($Ref) Int)
(declare-fun inv@328@04 ($Ref) Int)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(assert (forall ((i1@325@04 Int) (j@326@04 Int)) (!
  (and
    (< i1@325@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@263@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@325@04)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@325@04))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@263@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@325@04))
        (as None<option<array>>  option<array>)))
    (<
      j@326@04
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@263@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@325@04))))))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@263@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@325@04))) j@326@04))
  :qid |int-aux|)))
(declare-const sm@329@04 $FVF<Int>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@271@04 r) V@15@04) (<= 0 (inv@271@04 r)))
        (< (inv@270@04 r) V@15@04))
      (<= 0 (inv@270@04 r)))
    (=
      ($FVF.lookup_int (as sm@329@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@259@04))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@329@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@259@04))))))))))))))) r))
  :qid |qp.fvfValDef240|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@274@04 r) V@15@04) (<= 0 (inv@274@04 r)))
    (=
      ($FVF.lookup_int (as sm@329@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@259@04)))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@329@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@259@04)))))))))))))))) r))
  :qid |qp.fvfValDef241|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@259@04))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@259@04)))))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@329@04  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef242|)))
; Check receiver injectivity
(push) ; 8
(assert (not (forall ((i11@325@04 Int) (j1@326@04 Int) (i12@325@04 Int) (j2@326@04 Int)) (!
  (implies
    (and
      (and
        (and
          (and
            (and (< j1@326@04 V@15@04) (<= 0 j1@326@04))
            (< i11@325@04 V@15@04))
          (<= 0 i11@325@04))
        ($FVF.loc_int ($FVF.lookup_int (as sm@329@04  $FVF<Int>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@263@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i11@325@04))) j1@326@04)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@263@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i11@325@04))) j1@326@04)))
      (and
        (and
          (and
            (and (< j2@326@04 V@15@04) (<= 0 j2@326@04))
            (< i12@325@04 V@15@04))
          (<= 0 i12@325@04))
        ($FVF.loc_int ($FVF.lookup_int (as sm@329@04  $FVF<Int>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@263@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i12@325@04))) j2@326@04)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@263@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i12@325@04))) j2@326@04)))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@263@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i11@325@04))) j1@326@04)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@263@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i12@325@04))) j2@326@04)))
    (and (= i11@325@04 i12@325@04) (= j1@326@04 j2@326@04)))
  
  :qid |int-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               276894
;  :arith-add-rows          133592
;  :arith-assert-diseq      3091
;  :arith-assert-lower      49076
;  :arith-assert-upper      39778
;  :arith-bound-prop        8961
;  :arith-conflicts         416
;  :arith-eq-adapter        37033
;  :arith-fixed-eqs         37556
;  :arith-offset-eqs        23622
;  :arith-pivots            29891
;  :conflicts               1553
;  :datatype-accessor-ax    190
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               17148
;  :del-clause              869819
;  :final-checks            5
;  :max-generation          11
;  :max-memory              60.52
;  :memory                  54.77
;  :minimized-lits          168
;  :mk-bool-var             851513
;  :mk-clause               870934
;  :num-allocs              3026879
;  :num-checks              319
;  :propagations            182658
;  :quant-instantiations    305805
;  :restarts                1
;  :rlimit-count            10149956
;  :time                    0.00)
; Definitional axioms for inverse functions
(assert (forall ((i1@325@04 Int) (j@326@04 Int)) (!
  (implies
    (and
      (and (and (< j@326@04 V@15@04) (<= 0 j@326@04)) (< i1@325@04 V@15@04))
      (<= 0 i1@325@04))
    (and
      (=
        (inv@327@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@263@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@325@04))) j@326@04))
        i1@325@04)
      (=
        (inv@328@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@263@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@325@04))) j@326@04))
        j@326@04)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@263@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@325@04))) j@326@04))
  :qid |int-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@328@04 r) V@15@04) (<= 0 (inv@328@04 r)))
        (< (inv@327@04 r) V@15@04))
      (<= 0 (inv@327@04 r)))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@263@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) (inv@327@04 r)))) (inv@328@04 r))
      r))
  :pattern ((inv@327@04 r))
  :pattern ((inv@328@04 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@328@04 r) V@15@04) (<= 0 (inv@328@04 r)))
        (< (inv@327@04 r) V@15@04))
      (<= 0 (inv@327@04 r)))
    ($FVF.loc_int ($FVF.lookup_int (as sm@329@04  $FVF<Int>) r) r))
  :pattern ((inv@327@04 r) (inv@328@04 r))
  )))
; Precomputing data for removing quantified permissions
(define-fun pTaken@330@04 ((r $Ref)) $Perm
  (ite
    (and
      (and
        (and (< (inv@328@04 r) V@15@04) (<= 0 (inv@328@04 r)))
        (< (inv@327@04 r) V@15@04))
      (<= 0 (inv@327@04 r)))
    ($Perm.min
      (ite
        (and
          (and
            (and (< (inv@271@04 r) V@15@04) (<= 0 (inv@271@04 r)))
            (< (inv@270@04 r) V@15@04))
          (<= 0 (inv@270@04 r)))
        $Perm.Write
        $Perm.No)
      $Perm.Write)
    $Perm.No))
(define-fun pTaken@331@04 ((r $Ref)) $Perm
  (ite
    (and
      (and
        (and (< (inv@328@04 r) V@15@04) (<= 0 (inv@328@04 r)))
        (< (inv@327@04 r) V@15@04))
      (<= 0 (inv@327@04 r)))
    ($Perm.min
      (ite
        (and (< (inv@274@04 r) V@15@04) (<= 0 (inv@274@04 r)))
        $Perm.Write
        $Perm.No)
      (- $Perm.Write (pTaken@330@04 r)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 500)
(push) ; 8
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and
          (and
            (and (< (inv@271@04 r) V@15@04) (<= 0 (inv@271@04 r)))
            (< (inv@270@04 r) V@15@04))
          (<= 0 (inv@270@04 r)))
        $Perm.Write
        $Perm.No)
      (pTaken@330@04 r))
    $Perm.No)
  
  ))))
(check-sat)
; unsat
(pop) ; 8
; 0.04s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               278488
;  :arith-add-rows          135068
;  :arith-assert-diseq      3111
;  :arith-assert-lower      49314
;  :arith-assert-upper      39935
;  :arith-bound-prop        9043
;  :arith-conflicts         422
;  :arith-eq-adapter        37269
;  :arith-fixed-eqs         37710
;  :arith-offset-eqs        23764
;  :arith-pivots            30072
;  :conflicts               1580
;  :datatype-accessor-ax    190
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               17282
;  :del-clause              875968
;  :final-checks            5
;  :max-generation          11
;  :max-memory              60.52
;  :memory                  54.82
;  :minimized-lits          170
;  :mk-bool-var             858776
;  :mk-clause               877100
;  :num-allocs              3053337
;  :num-checks              321
;  :propagations            183554
;  :quant-instantiations    307619
;  :restarts                1
;  :rlimit-count            10236086
;  :time                    0.04)
; Intermediate check if already taken enough permissions
(push) ; 8
(assert (not (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@328@04 r) V@15@04) (<= 0 (inv@328@04 r)))
        (< (inv@327@04 r) V@15@04))
      (<= 0 (inv@327@04 r)))
    (= (- $Perm.Write (pTaken@330@04 r)) $Perm.No))
  
  ))))
(check-sat)
; unsat
(pop) ; 8
; 0.02s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               278967
;  :arith-add-rows          135565
;  :arith-assert-diseq      3122
;  :arith-assert-lower      49407
;  :arith-assert-upper      40004
;  :arith-bound-prop        9070
;  :arith-conflicts         424
;  :arith-eq-adapter        37334
;  :arith-fixed-eqs         37777
;  :arith-offset-eqs        23797
;  :arith-pivots            30157
;  :conflicts               1598
;  :datatype-accessor-ax    190
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               17392
;  :del-clause              880091
;  :final-checks            5
;  :max-generation          11
;  :max-memory              60.52
;  :memory                  54.82
;  :minimized-lits          170
;  :mk-bool-var             862058
;  :mk-clause               881223
;  :num-allocs              3062772
;  :num-checks              322
;  :propagations            184037
;  :quant-instantiations    308505
;  :restarts                1
;  :rlimit-count            10280511
;  :time                    0.02)
; Final check if taken enough permissions
; Done removing quantified permissions
; Definitional axioms for snapshot map values
; [eval] P != (None(): option[array])
; [eval] (None(): option[array])
; [eval] alen(opt_get1(P)) == V
; [eval] alen(opt_get1(P))
; [eval] opt_get1(P)
(push) ; 8
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 8
; Joined path conditions
(declare-const i1@332@04 Int)
(push) ; 8
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 9
; [then-branch: 187 | 0 <= i1@332@04 | live]
; [else-branch: 187 | !(0 <= i1@332@04) | live]
(push) ; 10
; [then-branch: 187 | 0 <= i1@332@04]
(assert (<= 0 i1@332@04))
; [eval] i1 < V
(pop) ; 10
(push) ; 10
; [else-branch: 187 | !(0 <= i1@332@04)]
(assert (not (<= 0 i1@332@04)))
(pop) ; 10
(pop) ; 9
; Joined path conditions
; Joined path conditions
(assert (and (< i1@332@04 V@15@04) (<= 0 i1@332@04)))
; [eval] aloc(opt_get1(P), i1)
; [eval] opt_get1(P)
(push) ; 9
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 9
; Joined path conditions
(push) ; 9
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 10
(assert (not (< i1@332@04 (alen<Int> (opt_get1 $Snap.unit P@14@04)))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               278967
;  :arith-add-rows          135566
;  :arith-assert-diseq      3122
;  :arith-assert-lower      49409
;  :arith-assert-upper      40004
;  :arith-bound-prop        9070
;  :arith-conflicts         424
;  :arith-eq-adapter        37334
;  :arith-fixed-eqs         37777
;  :arith-offset-eqs        23797
;  :arith-pivots            30157
;  :conflicts               1598
;  :datatype-accessor-ax    190
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               17392
;  :del-clause              880091
;  :final-checks            5
;  :max-generation          11
;  :max-memory              60.52
;  :memory                  54.82
;  :minimized-lits          170
;  :mk-bool-var             862060
;  :mk-clause               881223
;  :num-allocs              3062881
;  :num-checks              323
;  :propagations            184037
;  :quant-instantiations    308505
;  :restarts                1
;  :rlimit-count            10280697)
(assert (< i1@332@04 (alen<Int> (opt_get1 $Snap.unit P@14@04))))
(pop) ; 9
; Joined path conditions
(assert (< i1@332@04 (alen<Int> (opt_get1 $Snap.unit P@14@04))))
(pop) ; 8
(declare-fun inv@333@04 ($Ref) Int)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(assert (forall ((i1@332@04 Int)) (!
  (< i1@332@04 (alen<Int> (opt_get1 $Snap.unit P@14@04)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i1@332@04))
  :qid |int-aux|)))
(declare-const sm@334@04 $FVF<Int>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@274@04 r) V@15@04) (<= 0 (inv@274@04 r)))
    (=
      ($FVF.lookup_int (as sm@334@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@259@04)))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@334@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@259@04)))))))))))))))) r))
  :qid |qp.fvfValDef243|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@259@04)))))))))))))))) r) r)
  :pattern (($FVF.lookup_int (as sm@334@04  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef244|)))
; Check receiver injectivity
(push) ; 8
(assert (not (forall ((i11@332@04 Int) (i12@332@04 Int)) (!
  (implies
    (and
      (and
        (and (< i11@332@04 V@15@04) (<= 0 i11@332@04))
        ($FVF.loc_int ($FVF.lookup_int (as sm@334@04  $FVF<Int>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit P@14@04) i11@332@04)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit P@14@04) i11@332@04)))
      (and
        (and (< i12@332@04 V@15@04) (<= 0 i12@332@04))
        ($FVF.loc_int ($FVF.lookup_int (as sm@334@04  $FVF<Int>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit P@14@04) i12@332@04)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit P@14@04) i12@332@04)))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i11@332@04)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i12@332@04)))
    (= i11@332@04 i12@332@04))
  
  :qid |int-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               278994
;  :arith-add-rows          135573
;  :arith-assert-diseq      3123
;  :arith-assert-lower      49413
;  :arith-assert-upper      40004
;  :arith-bound-prop        9070
;  :arith-conflicts         424
;  :arith-eq-adapter        37335
;  :arith-fixed-eqs         37777
;  :arith-offset-eqs        23797
;  :arith-pivots            30159
;  :conflicts               1599
;  :datatype-accessor-ax    190
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               17392
;  :del-clause              880098
;  :final-checks            5
;  :max-generation          11
;  :max-memory              60.52
;  :memory                  54.82
;  :minimized-lits          170
;  :mk-bool-var             862104
;  :mk-clause               881230
;  :num-allocs              3063807
;  :num-checks              324
;  :propagations            184037
;  :quant-instantiations    308546
;  :restarts                1
;  :rlimit-count            10283239
;  :time                    0.00)
; Definitional axioms for inverse functions
(assert (forall ((i1@332@04 Int)) (!
  (implies
    (and (< i1@332@04 V@15@04) (<= 0 i1@332@04))
    (=
      (inv@333@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i1@332@04))
      i1@332@04))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i1@332@04))
  :qid |int-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@333@04 r) V@15@04) (<= 0 (inv@333@04 r)))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) (inv@333@04 r))
      r))
  :pattern ((inv@333@04 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@333@04 r) V@15@04) (<= 0 (inv@333@04 r)))
    ($FVF.loc_int ($FVF.lookup_int (as sm@334@04  $FVF<Int>) r) r))
  :pattern ((inv@333@04 r))
  )))
; Precomputing data for removing quantified permissions
(define-fun pTaken@335@04 ((r $Ref)) $Perm
  (ite
    (and (< (inv@333@04 r) V@15@04) (<= 0 (inv@333@04 r)))
    ($Perm.min
      (ite
        (and (< (inv@274@04 r) V@15@04) (<= 0 (inv@274@04 r)))
        $Perm.Write
        $Perm.No)
      $Perm.Write)
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 500)
(push) ; 8
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and (< (inv@274@04 r) V@15@04) (<= 0 (inv@274@04 r)))
        $Perm.Write
        $Perm.No)
      (pTaken@335@04 r))
    $Perm.No)
  
  ))))
(check-sat)
; unsat
(pop) ; 8
; 0.04s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               279680
;  :arith-add-rows          136306
;  :arith-assert-diseq      3148
;  :arith-assert-lower      49571
;  :arith-assert-upper      40112
;  :arith-bound-prop        9107
;  :arith-conflicts         427
;  :arith-eq-adapter        37458
;  :arith-fixed-eqs         37893
;  :arith-offset-eqs        23817
;  :arith-pivots            30264
;  :conflicts               1620
;  :datatype-accessor-ax    190
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               17540
;  :del-clause              885663
;  :final-checks            5
;  :max-generation          11
;  :max-memory              60.52
;  :memory                  54.81
;  :minimized-lits          170
;  :mk-bool-var             866842
;  :mk-clause               886806
;  :num-allocs              3078120
;  :num-checks              326
;  :propagations            184712
;  :quant-instantiations    309785
;  :restarts                1
;  :rlimit-count            10340990
;  :time                    0.04)
; Intermediate check if already taken enough permissions
(push) ; 8
(assert (not (forall ((r $Ref)) (!
  (implies
    (and (< (inv@333@04 r) V@15@04) (<= 0 (inv@333@04 r)))
    (= (- $Perm.Write (pTaken@335@04 r)) $Perm.No))
  
  ))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               279740
;  :arith-add-rows          136347
;  :arith-assert-diseq      3150
;  :arith-assert-lower      49587
;  :arith-assert-upper      40123
;  :arith-bound-prop        9109
;  :arith-conflicts         428
;  :arith-eq-adapter        37470
;  :arith-fixed-eqs         37900
;  :arith-offset-eqs        23820
;  :arith-pivots            30271
;  :conflicts               1621
;  :datatype-accessor-ax    190
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               17540
;  :del-clause              885827
;  :final-checks            5
;  :max-generation          11
;  :max-memory              60.52
;  :memory                  54.81
;  :minimized-lits          170
;  :mk-bool-var             867077
;  :mk-clause               886970
;  :num-allocs              3079049
;  :num-checks              327
;  :propagations            184720
;  :quant-instantiations    309858
;  :restarts                1
;  :rlimit-count            10344478
;  :time                    0.00)
; Final check if taken enough permissions
; Done removing quantified permissions
; Definitional axioms for snapshot map values
; [eval] valid_graph_vertices(this, P, V)
(push) ; 8
; [eval] this != null
; [eval] p != (None(): option[array])
; [eval] (None(): option[array])
; [eval] alen(opt_get1(p)) == V
; [eval] alen(opt_get1(p))
; [eval] opt_get1(p)
(push) ; 9
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 9
; Joined path conditions
(declare-const i1@336@04 Int)
(push) ; 9
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 10
; [then-branch: 188 | 0 <= i1@336@04 | live]
; [else-branch: 188 | !(0 <= i1@336@04) | live]
(push) ; 11
; [then-branch: 188 | 0 <= i1@336@04]
(assert (<= 0 i1@336@04))
; [eval] i1 < V
(pop) ; 11
(push) ; 11
; [else-branch: 188 | !(0 <= i1@336@04)]
(assert (not (<= 0 i1@336@04)))
(pop) ; 11
(pop) ; 10
; Joined path conditions
; Joined path conditions
(assert (and (< i1@336@04 V@15@04) (<= 0 i1@336@04)))
(declare-const $k@337@04 $Perm)
(assert ($Perm.isReadVar $k@337@04 $Perm.Write))
; [eval] aloc(opt_get1(p), i1)
; [eval] opt_get1(p)
(push) ; 10
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 10
; Joined path conditions
(push) ; 10
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 11
(assert (not (< i1@336@04 (alen<Int> (opt_get1 $Snap.unit P@14@04)))))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               279740
;  :arith-add-rows          136348
;  :arith-assert-diseq      3151
;  :arith-assert-lower      49591
;  :arith-assert-upper      40124
;  :arith-bound-prop        9109
;  :arith-conflicts         428
;  :arith-eq-adapter        37471
;  :arith-fixed-eqs         37900
;  :arith-offset-eqs        23820
;  :arith-pivots            30272
;  :conflicts               1621
;  :datatype-accessor-ax    190
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               17540
;  :del-clause              885827
;  :final-checks            5
;  :max-generation          11
;  :max-memory              60.52
;  :memory                  54.81
;  :minimized-lits          170
;  :mk-bool-var             867083
;  :mk-clause               886972
;  :num-allocs              3079226
;  :num-checks              328
;  :propagations            184721
;  :quant-instantiations    309858
;  :restarts                1
;  :rlimit-count            10344815)
(assert (< i1@336@04 (alen<Int> (opt_get1 $Snap.unit P@14@04))))
(pop) ; 10
; Joined path conditions
(assert (< i1@336@04 (alen<Int> (opt_get1 $Snap.unit P@14@04))))
(pop) ; 9
(declare-fun inv@338@04 ($Ref) Int)
; Nested auxiliary terms: globals
(assert ($Perm.isReadVar $k@337@04 $Perm.Write))
; Nested auxiliary terms: non-globals
(assert (forall ((i1@336@04 Int)) (!
  (< i1@336@04 (alen<Int> (opt_get1 $Snap.unit P@14@04)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i1@336@04))
  :qid |int-aux|)))
(push) ; 9
(assert (not (forall ((i1@336@04 Int)) (!
  (implies
    (and (< i1@336@04 V@15@04) (<= 0 i1@336@04))
    (or (= $k@337@04 $Perm.No) (< $Perm.No $k@337@04)))
  
  ))))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               279740
;  :arith-add-rows          136349
;  :arith-assert-diseq      3152
;  :arith-assert-lower      49593
;  :arith-assert-upper      40125
;  :arith-bound-prop        9109
;  :arith-conflicts         428
;  :arith-eq-adapter        37472
;  :arith-fixed-eqs         37900
;  :arith-offset-eqs        23820
;  :arith-pivots            30273
;  :conflicts               1622
;  :datatype-accessor-ax    190
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               17540
;  :del-clause              885829
;  :final-checks            5
;  :max-generation          11
;  :max-memory              60.52
;  :memory                  54.81
;  :minimized-lits          170
;  :mk-bool-var             867090
;  :mk-clause               886974
;  :num-allocs              3079657
;  :num-checks              329
;  :propagations            184722
;  :quant-instantiations    309858
;  :restarts                1
;  :rlimit-count            10345366)
(declare-const sm@339@04 $FVF<Int>)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@274@04 r) V@15@04) (<= 0 (inv@274@04 r)))
    (=
      ($FVF.lookup_int (as sm@339@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@259@04)))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@339@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@259@04)))))))))))))))) r))
  :qid |qp.fvfValDef245|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@271@04 r) V@15@04) (<= 0 (inv@271@04 r)))
        (< (inv@270@04 r) V@15@04))
      (<= 0 (inv@270@04 r)))
    (=
      ($FVF.lookup_int (as sm@339@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@259@04))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@339@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@259@04))))))))))))))) r))
  :qid |qp.fvfValDef246|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@259@04)))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@259@04))))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@339@04  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef247|)))
; Check receiver injectivity
(push) ; 9
(assert (not (forall ((i11@336@04 Int) (i12@336@04 Int)) (!
  (implies
    (and
      (and
        (and
          (and (< i11@336@04 V@15@04) (<= 0 i11@336@04))
          ($FVF.loc_int ($FVF.lookup_int (as sm@339@04  $FVF<Int>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit P@14@04) i11@336@04)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit P@14@04) i11@336@04)))
        (< $Perm.No $k@337@04))
      (and
        (and
          (and (< i12@336@04 V@15@04) (<= 0 i12@336@04))
          ($FVF.loc_int ($FVF.lookup_int (as sm@339@04  $FVF<Int>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit P@14@04) i12@336@04)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit P@14@04) i12@336@04)))
        (< $Perm.No $k@337@04))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i11@336@04)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i12@336@04)))
    (= i11@336@04 i12@336@04))
  
  :qid |int-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               279769
;  :arith-add-rows          136356
;  :arith-assert-diseq      3153
;  :arith-assert-lower      49597
;  :arith-assert-upper      40125
;  :arith-bound-prop        9109
;  :arith-conflicts         428
;  :arith-eq-adapter        37473
;  :arith-fixed-eqs         37900
;  :arith-offset-eqs        23820
;  :arith-pivots            30273
;  :conflicts               1623
;  :datatype-accessor-ax    190
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               17540
;  :del-clause              885840
;  :final-checks            5
;  :max-generation          11
;  :max-memory              60.52
;  :memory                  54.80
;  :minimized-lits          170
;  :mk-bool-var             867143
;  :mk-clause               886985
;  :num-allocs              3080704
;  :num-checks              330
;  :propagations            184724
;  :quant-instantiations    309904
;  :restarts                1
;  :rlimit-count            10348660
;  :time                    0.00)
; Definitional axioms for inverse functions
(assert (forall ((i1@336@04 Int)) (!
  (implies
    (and (and (< i1@336@04 V@15@04) (<= 0 i1@336@04)) (< $Perm.No $k@337@04))
    (=
      (inv@338@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i1@336@04))
      i1@336@04))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i1@336@04))
  :qid |int-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and (< (inv@338@04 r) V@15@04) (<= 0 (inv@338@04 r)))
      (< $Perm.No $k@337@04))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) (inv@338@04 r))
      r))
  :pattern ((inv@338@04 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@338@04 r) V@15@04) (<= 0 (inv@338@04 r)))
    ($FVF.loc_int ($FVF.lookup_int (as sm@339@04  $FVF<Int>) r) r))
  :pattern ((inv@338@04 r))
  )))
; Precomputing data for removing quantified permissions
(define-fun pTaken@340@04 ((r $Ref)) $Perm
  (ite
    (and (< (inv@338@04 r) V@15@04) (<= 0 (inv@338@04 r)))
    ($Perm.min
      (ite
        (and (< (inv@274@04 r) V@15@04) (<= 0 (inv@274@04 r)))
        $Perm.Write
        $Perm.No)
      $k@337@04)
    $Perm.No))
(define-fun pTaken@341@04 ((r $Ref)) $Perm
  (ite
    (and (< (inv@338@04 r) V@15@04) (<= 0 (inv@338@04 r)))
    ($Perm.min
      (ite
        (and
          (and
            (and (< (inv@271@04 r) V@15@04) (<= 0 (inv@271@04 r)))
            (< (inv@270@04 r) V@15@04))
          (<= 0 (inv@270@04 r)))
        $Perm.Write
        $Perm.No)
      (- $k@337@04 (pTaken@340@04 r)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Constrain original permissions $k@337@04
(assert (forall ((r $Ref)) (!
  (implies
    (not
      (=
        (ite
          (and (< (inv@274@04 r) V@15@04) (<= 0 (inv@274@04 r)))
          $Perm.Write
          $Perm.No)
        $Perm.No))
    (ite
      (and (< (inv@274@04 r) V@15@04) (<= 0 (inv@274@04 r)))
      (<
        (ite
          (and (< (inv@338@04 r) V@15@04) (<= 0 (inv@338@04 r)))
          $k@337@04
          $Perm.No)
        $Perm.Write)
      (<
        (ite
          (and (< (inv@338@04 r) V@15@04) (<= 0 (inv@338@04 r)))
          $k@337@04
          $Perm.No)
        $Perm.No)))
  :pattern ((inv@274@04 r))
  :pattern ((inv@338@04 r))
  :qid |qp.srp248|)))
; Intermediate check if already taken enough permissions
(set-option :timeout 500)
(push) ; 9
(assert (not (forall ((r $Ref)) (!
  (implies
    (and (< (inv@338@04 r) V@15@04) (<= 0 (inv@338@04 r)))
    (= (- $k@337@04 (pTaken@340@04 r)) $Perm.No))
  
  ))))
(check-sat)
; unsat
(pop) ; 9
; 0.28s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               280401
;  :arith-add-rows          136914
;  :arith-assert-diseq      3172
;  :arith-assert-lower      49728
;  :arith-assert-upper      40212
;  :arith-bound-prop        9138
;  :arith-conflicts         430
;  :arith-eq-adapter        37572
;  :arith-fixed-eqs         37997
;  :arith-offset-eqs        23867
;  :arith-pivots            30322
;  :conflicts               1644
;  :datatype-accessor-ax    190
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               17679
;  :del-clause              890900
;  :final-checks            5
;  :max-generation          11
;  :max-memory              60.52
;  :memory                  54.83
;  :minimized-lits          170
;  :mk-bool-var             871025
;  :mk-clause               892043
;  :num-allocs              3092608
;  :num-checks              332
;  :propagations            185431
;  :quant-instantiations    310965
;  :restarts                1
;  :rlimit-count            10400691
;  :time                    0.28)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@342@04 $FVF<Int>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (iff
    (Set_in r ($FVF.domain_int (as sm@342@04  $FVF<Int>)))
    (and
      (and (< (inv@338@04 r) V@15@04) (<= 0 (inv@338@04 r)))
      (< $Perm.No $k@337@04)))
  :pattern ((Set_in r ($FVF.domain_int (as sm@342@04  $FVF<Int>))))
  :qid |qp.fvfDomDef252|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@338@04 r) V@15@04) (<= 0 (inv@338@04 r)))
        (< $Perm.No $k@337@04))
      (and (< (inv@274@04 r) V@15@04) (<= 0 (inv@274@04 r))))
    (=
      ($FVF.lookup_int (as sm@342@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@259@04)))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@342@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@259@04)))))))))))))))) r))
  :qid |qp.fvfValDef249|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@338@04 r) V@15@04) (<= 0 (inv@338@04 r)))
        (< $Perm.No $k@337@04))
      (and
        (and
          (and (< (inv@271@04 r) V@15@04) (<= 0 (inv@271@04 r)))
          (< (inv@270@04 r) V@15@04))
        (<= 0 (inv@270@04 r))))
    (=
      ($FVF.lookup_int (as sm@342@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@259@04))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@342@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@259@04))))))))))))))) r))
  :qid |qp.fvfValDef250|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@259@04)))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@259@04))))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@342@04  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef251|)))
(pop) ; 8
; Joined path conditions
(assert ($Perm.isReadVar $k@337@04 $Perm.Write))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@274@04 r) V@15@04) (<= 0 (inv@274@04 r)))
    (=
      ($FVF.lookup_int (as sm@339@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@259@04)))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@339@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@259@04)))))))))))))))) r))
  :qid |qp.fvfValDef245|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@271@04 r) V@15@04) (<= 0 (inv@271@04 r)))
        (< (inv@270@04 r) V@15@04))
      (<= 0 (inv@270@04 r)))
    (=
      ($FVF.lookup_int (as sm@339@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@259@04))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@339@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@259@04))))))))))))))) r))
  :qid |qp.fvfValDef246|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@259@04)))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@259@04))))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@339@04  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef247|)))
(assert (forall ((i1@336@04 Int)) (!
  (implies
    (and (and (< i1@336@04 V@15@04) (<= 0 i1@336@04)) (< $Perm.No $k@337@04))
    (=
      (inv@338@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i1@336@04))
      i1@336@04))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i1@336@04))
  :qid |int-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and (< (inv@338@04 r) V@15@04) (<= 0 (inv@338@04 r)))
      (< $Perm.No $k@337@04))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) (inv@338@04 r))
      r))
  :pattern ((inv@338@04 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (iff
    (Set_in r ($FVF.domain_int (as sm@342@04  $FVF<Int>)))
    (and
      (and (< (inv@338@04 r) V@15@04) (<= 0 (inv@338@04 r)))
      (< $Perm.No $k@337@04)))
  :pattern ((Set_in r ($FVF.domain_int (as sm@342@04  $FVF<Int>))))
  :qid |qp.fvfDomDef252|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@338@04 r) V@15@04) (<= 0 (inv@338@04 r)))
        (< $Perm.No $k@337@04))
      (and (< (inv@274@04 r) V@15@04) (<= 0 (inv@274@04 r))))
    (=
      ($FVF.lookup_int (as sm@342@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@259@04)))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@342@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@259@04)))))))))))))))) r))
  :qid |qp.fvfValDef249|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@338@04 r) V@15@04) (<= 0 (inv@338@04 r)))
        (< $Perm.No $k@337@04))
      (and
        (and
          (and (< (inv@271@04 r) V@15@04) (<= 0 (inv@271@04 r)))
          (< (inv@270@04 r) V@15@04))
        (<= 0 (inv@270@04 r))))
    (=
      ($FVF.lookup_int (as sm@342@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@259@04))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@342@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@259@04))))))))))))))) r))
  :qid |qp.fvfValDef250|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@259@04)))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@259@04))))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@342@04  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef251|)))
(assert (and
  (forall ((i1@336@04 Int)) (!
    (< i1@336@04 (alen<Int> (opt_get1 $Snap.unit P@14@04)))
    :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i1@336@04))
    :qid |int-aux|))
  (forall ((r $Ref)) (!
    (implies
      (and (< (inv@338@04 r) V@15@04) (<= 0 (inv@338@04 r)))
      ($FVF.loc_int ($FVF.lookup_int (as sm@339@04  $FVF<Int>) r) r))
    :pattern ((inv@338@04 r))
    ))
  (forall ((r $Ref)) (!
    (implies
      (not
        (=
          (ite
            (and (< (inv@274@04 r) V@15@04) (<= 0 (inv@274@04 r)))
            $Perm.Write
            $Perm.No)
          $Perm.No))
      (ite
        (and (< (inv@274@04 r) V@15@04) (<= 0 (inv@274@04 r)))
        (<
          (ite
            (and (< (inv@338@04 r) V@15@04) (<= 0 (inv@338@04 r)))
            $k@337@04
            $Perm.No)
          $Perm.Write)
        (<
          (ite
            (and (< (inv@338@04 r) V@15@04) (<= 0 (inv@338@04 r)))
            $k@337@04
            $Perm.No)
          $Perm.No)))
    :pattern ((inv@274@04 r))
    :pattern ((inv@338@04 r))
    :qid |qp.srp248|))))
(set-option :timeout 0)
(push) ; 8
(assert (not (valid_graph_vertices ($Snap.combine
  $Snap.unit
  ($Snap.combine
    $Snap.unit
    ($Snap.combine
      $Snap.unit
      ($SortWrappers.$FVF<Int>To$Snap (as sm@342@04  $FVF<Int>))))) this@9@04 P@14@04 V@15@04)))
(check-sat)
; unsat
(pop) ; 8
; 6.59s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               552722
;  :arith-add-rows          251845
;  :arith-assert-diseq      4831
;  :arith-assert-lower      94367
;  :arith-assert-upper      79756
;  :arith-bound-prop        14291
;  :arith-conflicts         520
;  :arith-eq-adapter        72087
;  :arith-fixed-eqs         78735
;  :arith-offset-eqs        46962
;  :arith-pivots            50554
;  :conflicts               1790
;  :datatype-accessor-ax    229
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               28785
;  :del-clause              1732702
;  :final-checks            5
;  :max-generation          12
;  :max-memory              83.11
;  :memory                  79.86
;  :minimized-lits          228
;  :mk-bool-var             1635738
;  :mk-clause               1733847
;  :num-allocs              5207489
;  :num-checks              333
;  :propagations            379680
;  :quant-instantiations    604363
;  :restarts                2
;  :rlimit-count            18344686
;  :time                    6.59)
(assert (valid_graph_vertices ($Snap.combine
  $Snap.unit
  ($Snap.combine
    $Snap.unit
    ($Snap.combine
      $Snap.unit
      ($SortWrappers.$FVF<Int>To$Snap (as sm@342@04  $FVF<Int>))))) this@9@04 P@14@04 V@15@04))
; Loop head block: Execute statements of loop head block (in invariant state)
(push) ; 8
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@308@04 r) V@15@04) (<= 0 (inv@308@04 r)))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) (inv@308@04 r))
      r))
  :pattern ((inv@308@04 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@308@04 r) V@15@04) (<= 0 (inv@308@04 r)))
    (=
      ($FVF.lookup_int (as sm@309@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04)))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@309@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04)))))))))))) r))
  :qid |qp.fvfValDef231|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@305@04 r) V@15@04) (<= 0 (inv@305@04 r)))
        (< (inv@304@04 r) V@15@04))
      (<= 0 (inv@304@04 r)))
    (=
      ($FVF.lookup_int (as sm@309@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@309@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04))))))))) r))
  :qid |qp.fvfValDef232|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04)))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@309@04  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef233|)))
(assert ($Perm.isReadVar $k@311@04 $Perm.Write))
(assert (forall ((i1@310@04 Int)) (!
  (implies
    (and (and (< i1@310@04 V@15@04) (<= 0 i1@310@04)) (< $Perm.No $k@311@04))
    (=
      (inv@312@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i1@310@04))
      i1@310@04))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i1@310@04))
  :qid |int-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and (< (inv@312@04 r) V@15@04) (<= 0 (inv@312@04 r)))
      (< $Perm.No $k@311@04))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) (inv@312@04 r))
      r))
  :pattern ((inv@312@04 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (iff
    (Set_in r ($FVF.domain_int (as sm@315@04  $FVF<Int>)))
    (and
      (and (< (inv@312@04 r) V@15@04) (<= 0 (inv@312@04 r)))
      (< $Perm.No $k@311@04)))
  :pattern ((Set_in r ($FVF.domain_int (as sm@315@04  $FVF<Int>))))
  :qid |qp.fvfDomDef238|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@312@04 r) V@15@04) (<= 0 (inv@312@04 r)))
        (< $Perm.No $k@311@04))
      (and (< (inv@308@04 r) V@15@04) (<= 0 (inv@308@04 r))))
    (=
      ($FVF.lookup_int (as sm@315@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04)))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@315@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04)))))))))))) r))
  :qid |qp.fvfValDef235|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@312@04 r) V@15@04) (<= 0 (inv@312@04 r)))
        (< $Perm.No $k@311@04))
      (and
        (and
          (and (< (inv@305@04 r) V@15@04) (<= 0 (inv@305@04 r)))
          (< (inv@304@04 r) V@15@04))
        (<= 0 (inv@304@04 r))))
    (=
      ($FVF.lookup_int (as sm@315@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@315@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04))))))))) r))
  :qid |qp.fvfValDef236|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04)))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@315@04  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef237|)))
(assert (forall ((i1@307@04 Int)) (!
  (implies
    (and (< i1@307@04 V@15@04) (<= 0 i1@307@04))
    (=
      (inv@308@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i1@307@04))
      i1@307@04))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i1@307@04))
  )))
(assert (forall ((i1@307@04 Int)) (!
  (implies
    (and (< i1@307@04 V@15@04) (<= 0 i1@307@04))
    (not
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i1@307@04)
        $Ref.null)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i1@307@04))
  :qid |int-permImpliesNonNull|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@308@04 r) V@15@04) (<= 0 (inv@308@04 r)))
    ($FVF.loc_int ($FVF.lookup_int (as sm@309@04  $FVF<Int>) r) r))
  :pattern ((inv@308@04 r))
  )))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04)))))))))))
  $Snap.unit))
(assert (forall ((i1@310@04 Int)) (!
  (< i1@310@04 (alen<Int> (opt_get1 $Snap.unit P@14@04)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i1@310@04))
  :qid |int-aux|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@312@04 r) V@15@04) (<= 0 (inv@312@04 r)))
    ($FVF.loc_int ($FVF.lookup_int (as sm@309@04  $FVF<Int>) r) r))
  :pattern ((inv@312@04 r))
  )))
(assert (forall ((r $Ref)) (!
  (implies
    (not
      (=
        (ite
          (and (< (inv@308@04 r) V@15@04) (<= 0 (inv@308@04 r)))
          $Perm.Write
          $Perm.No)
        $Perm.No))
    (ite
      (and (< (inv@308@04 r) V@15@04) (<= 0 (inv@308@04 r)))
      (<
        (ite
          (and (< (inv@312@04 r) V@15@04) (<= 0 (inv@312@04 r)))
          $k@311@04
          $Perm.No)
        $Perm.Write)
      (<
        (ite
          (and (< (inv@312@04 r) V@15@04) (<= 0 (inv@312@04 r)))
          $k@311@04
          $Perm.No)
        $Perm.No)))
  :pattern ((inv@308@04 r))
  :pattern ((inv@312@04 r))
  :qid |qp.srp234|)))
(assert (valid_graph_vertices ($Snap.combine
  $Snap.unit
  ($Snap.combine
    $Snap.unit
    ($Snap.combine
      $Snap.unit
      ($SortWrappers.$FVF<Int>To$Snap (as sm@315@04  $FVF<Int>))))) this@9@04 P@14@04 V@15@04))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@305@04 r) V@15@04) (<= 0 (inv@305@04 r)))
        (< (inv@304@04 r) V@15@04))
      (<= 0 (inv@304@04 r)))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@297@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) (inv@304@04 r)))) (inv@305@04 r))
      r))
  :pattern ((inv@304@04 r))
  :pattern ((inv@305@04 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@305@04 r) V@15@04) (<= 0 (inv@305@04 r)))
        (< (inv@304@04 r) V@15@04))
      (<= 0 (inv@304@04 r)))
    (=
      ($FVF.lookup_int (as sm@306@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@306@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04))))))))) r))
  :qid |qp.fvfValDef229|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04))))))))) r) r)
  :pattern (($FVF.lookup_int (as sm@306@04  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef230|)))
(assert (forall ((i1@302@04 Int) (j@303@04 Int)) (!
  (implies
    (and
      (and (and (< j@303@04 V@15@04) (<= 0 j@303@04)) (< i1@302@04 V@15@04))
      (<= 0 i1@302@04))
    (and
      (=
        (inv@304@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@297@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@302@04))) j@303@04))
        i1@302@04)
      (=
        (inv@305@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@297@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@302@04))) j@303@04))
        j@303@04)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@297@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@302@04))) j@303@04))
  )))
(assert (forall ((i1@302@04 Int) (j@303@04 Int)) (!
  (implies
    (and
      (and (and (< j@303@04 V@15@04) (<= 0 j@303@04)) (< i1@302@04 V@15@04))
      (<= 0 i1@302@04))
    (not
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@297@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@302@04))) j@303@04)
        $Ref.null)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@297@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@302@04))) j@303@04))
  :qid |int-permImpliesNonNull|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@305@04 r) V@15@04) (<= 0 (inv@305@04 r)))
        (< (inv@304@04 r) V@15@04))
      (<= 0 (inv@304@04 r)))
    ($FVF.loc_int ($FVF.lookup_int (as sm@306@04  $FVF<Int>) r) r))
  :pattern ((inv@304@04 r) (inv@305@04 r))
  )))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04)))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04)))))))))
  $Snap.unit))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04)))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04)))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04))))))))))
  $Snap.unit))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04)))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04))))))))))))))
(assert (forall ((i1@307@04 Int)) (!
  (< i1@307@04 (alen<Int> (opt_get1 $Snap.unit P@14@04)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i1@307@04))
  :qid |int-aux|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and (< (inv@296@04 r) V@15@04) (<= 0 (inv@296@04 r)))
      (< $Perm.No $k@295@04))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) (inv@296@04 r))
      r))
  :pattern ((inv@296@04 r))
  :qid |option$array$-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@296@04 r) V@15@04) (<= 0 (inv@296@04 r)))
      (< $Perm.No $k@295@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@297@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@297@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r))
  :qid |qp.fvfValDef227|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r) r)
  :pattern (($FVF.lookup_option$array$ (as sm@297@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef228|)))
(assert (forall ((i1@294@04 Int)) (!
  (implies
    (and (and (< i1@294@04 V@15@04) (<= 0 i1@294@04)) (< $Perm.No $k@295@04))
    (=
      (inv@296@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@294@04))
      i1@294@04))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@294@04))
  )))
(assert (forall ((i1@294@04 Int)) (!
  (<= $Perm.No $k@295@04)
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@294@04))
  :qid |option$array$-permAtLeastZero|)))
(assert (forall ((i1@294@04 Int)) (!
  (<= $k@295@04 $Perm.Write)
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@294@04))
  :qid |option$array$-permAtMostOne|)))
(assert (forall ((i1@294@04 Int)) (!
  (implies
    (and (and (< i1@294@04 V@15@04) (<= 0 i1@294@04)) (< $Perm.No $k@295@04))
    (not
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@294@04)
        $Ref.null)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@294@04))
  :qid |option$array$-permImpliesNonNull|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@296@04 r) V@15@04) (<= 0 (inv@296@04 r)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@297@04  $FVF<option<array>>) r) r))
  :pattern ((inv@296@04 r))
  )))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04)))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04)))))
  $Snap.unit))
(assert (forall ((i1@298@04 Int)) (!
  (implies
    (and (< i1@298@04 V@15@04) (<= 0 i1@298@04))
    (and
      (< i1@298@04 V@15@04)
      (<= 0 i1@298@04)
      (< i1@298@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@297@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@298@04)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@298@04))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@298@04))
  :qid |prog.l<no position>-aux|)))
(assert (forall ((i1@298@04 Int)) (!
  (implies
    (and (< i1@298@04 V@15@04) (<= 0 i1@298@04))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@297@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@298@04))
        (as None<option<array>>  option<array>))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@298@04))
  :qid |prog.l<no position>|)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04)))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04)))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04))))))
  $Snap.unit))
(assert (forall ((i1@299@04 Int)) (!
  (implies
    (and (< i1@299@04 V@15@04) (<= 0 i1@299@04))
    (and
      (< i1@299@04 V@15@04)
      (<= 0 i1@299@04)
      (< i1@299@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@297@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@299@04)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@299@04))
      (not
        (=
          ($FVF.lookup_option$array$ (as sm@297@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@299@04))
          (as None<option<array>>  option<array>)))))
  :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@297@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@299@04)))))
  :qid |prog.l<no position>-aux|)))
(assert (forall ((i1@299@04 Int)) (!
  (implies
    (and (< i1@299@04 V@15@04) (<= 0 i1@299@04))
    (=
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@297@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@299@04))))
      V@15@04))
  :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@297@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@299@04)))))
  :qid |prog.l<no position>|)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04)))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04)))))))
  $Snap.unit))
(assert (forall ((i1@300@04 Int)) (!
  (forall ((i2@301@04 Int)) (!
    (and
      (implies
        (<= 0 i1@300@04)
        (and
          (<= 0 i1@300@04)
          (implies
            (< i1@300@04 V@15@04)
            (and
              (< i1@300@04 V@15@04)
              (implies
                (<= 0 i2@301@04)
                (and
                  (<= 0 i2@301@04)
                  (implies
                    (< i2@301@04 V@15@04)
                    (and
                      (< i2@301@04 V@15@04)
                      (< i1@300@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
                      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@297@04  $FVF<option<array>>) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@300@04)) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@300@04))
                      (< i2@301@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
                      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@297@04  $FVF<option<array>>) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@301@04)) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@301@04))))))))))
      (implies
        (and
          (and
            (and
              (and
                (=
                  ($FVF.lookup_option$array$ (as sm@297@04  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@300@04))
                  ($FVF.lookup_option$array$ (as sm@297@04  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@301@04)))
                (< i2@301@04 V@15@04))
              (<= 0 i2@301@04))
            (< i1@300@04 V@15@04))
          (<= 0 i1@300@04))
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@297@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@300@04))
            ($FVF.lookup_option$array$ (as sm@297@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@301@04)))
          (< i2@301@04 V@15@04)
          (<= 0 i2@301@04)
          (< i1@300@04 V@15@04)
          (<= 0 i1@300@04))))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@301@04))
    :qid |prog.l<no position>-aux|))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@300@04))
  :qid |prog.l<no position>-aux|)))
(assert (forall ((i1@300@04 Int)) (!
  (forall ((i2@301@04 Int)) (!
    (implies
      (and
        (and
          (and
            (and
              (=
                ($FVF.lookup_option$array$ (as sm@297@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@300@04))
                ($FVF.lookup_option$array$ (as sm@297@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@301@04)))
              (< i2@301@04 V@15@04))
            (<= 0 i2@301@04))
          (< i1@300@04 V@15@04))
        (<= 0 i1@300@04))
      (= i1@300@04 i2@301@04))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@301@04))
    :qid |prog.l<no position>|))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@300@04))
  :qid |prog.l<no position>|)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04)))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04)))))))))))
(assert (forall ((i1@302@04 Int) (j@303@04 Int)) (!
  (and
    (< i1@302@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@297@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@302@04)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@302@04))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@297@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@302@04))
        (as None<option<array>>  option<array>)))
    (<
      j@303@04
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@297@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@302@04))))))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@297@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@302@04))) j@303@04))
  :qid |int-aux|)))
(assert ($Perm.isReadVar $k@295@04 $Perm.Write))
(assert (= $t@293@04 ($Snap.combine ($Snap.first $t@293@04) ($Snap.second $t@293@04))))
(assert (= ($Snap.first $t@293@04) $Snap.unit))
(assert (= exc@291@04 $Ref.null))
(assert (=
  ($Snap.second $t@293@04)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@293@04))
    ($Snap.second ($Snap.second $t@293@04)))))
(assert (= ($Snap.first ($Snap.second $t@293@04)) $Snap.unit))
(assert (=
  ($Snap.second ($Snap.second $t@293@04))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second $t@293@04)))
    ($Snap.second ($Snap.second ($Snap.second $t@293@04))))))
(assert (= ($Snap.first ($Snap.second ($Snap.second $t@293@04))) $Snap.unit))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second $t@293@04)))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04)))))))
(assert (forall ((i1@294@04 Int)) (!
  (< i1@294@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@294@04))
  :qid |option$array$-aux|)))
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
(set-option :timeout 10)
(check-sat)
; unknown
; Loop head block: Follow loop-internal edges
(push) ; 9
(assert (not (not res1@292@04)))
(check-sat)
; unknown
(pop) ; 9
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               553585
;  :arith-add-rows          252354
;  :arith-assert-diseq      4859
;  :arith-assert-lower      94562
;  :arith-assert-upper      79894
;  :arith-bound-prop        14305
;  :arith-conflicts         520
;  :arith-eq-adapter        72194
;  :arith-fixed-eqs         78903
;  :arith-offset-eqs        47016
;  :arith-pivots            50608
;  :conflicts               1790
;  :datatype-accessor-ax    246
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               28911
;  :del-clause              1737877
;  :final-checks            5
;  :max-generation          12
;  :max-memory              83.11
;  :memory                  77.96
;  :minimized-lits          228
;  :mk-bool-var             1640355
;  :mk-clause               1739238
;  :num-allocs              5228507
;  :num-checks              336
;  :propagations            380489
;  :quant-instantiations    605821
;  :restarts                2
;  :rlimit-count            18427930
;  :time                    0.01)
(push) ; 9
(assert (not res1@292@04))
(check-sat)
; unknown
(pop) ; 9
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               553832
;  :arith-add-rows          252500
;  :arith-assert-diseq      4867
;  :arith-assert-lower      94625
;  :arith-assert-upper      79939
;  :arith-bound-prop        14305
;  :arith-conflicts         520
;  :arith-eq-adapter        72229
;  :arith-fixed-eqs         78959
;  :arith-offset-eqs        47034
;  :arith-pivots            50624
;  :conflicts               1790
;  :datatype-accessor-ax    246
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               28947
;  :del-clause              1739413
;  :final-checks            5
;  :max-generation          12
;  :max-memory              83.11
;  :memory                  77.59
;  :minimized-lits          228
;  :mk-bool-var             1641663
;  :mk-clause               1740774
;  :num-allocs              5232769
;  :num-checks              337
;  :propagations            380736
;  :quant-instantiations    606272
;  :restarts                2
;  :rlimit-count            18447776
;  :time                    0.01)
; [then-branch: 189 | res1@292@04 | live]
; [else-branch: 189 | !(res1@292@04) | live]
(push) ; 9
; [then-branch: 189 | res1@292@04]
(assert res1@292@04)
; [exec]
; P_seq := unknown(P, 0, alen(opt_get1(P)))
; [eval] unknown(P, 0, alen(opt_get1(P)))
; [eval] alen(opt_get1(P))
; [eval] opt_get1(P)
(push) ; 10
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 10
; Joined path conditions
(push) ; 10
; [eval] a2 != (None(): option[array])
; [eval] (None(): option[array])
; [eval] 0 <= from
; [eval] from <= to
; [eval] to <= alen(opt_get1(a2))
; [eval] alen(opt_get1(a2))
; [eval] opt_get1(a2)
(push) ; 11
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 11
; Joined path conditions
(declare-const i1@343@04 Int)
(push) ; 11
; [eval] from <= i1 && i1 < to
; [eval] from <= i1
(push) ; 12
; [then-branch: 190 | 0 <= i1@343@04 | live]
; [else-branch: 190 | !(0 <= i1@343@04) | live]
(push) ; 13
; [then-branch: 190 | 0 <= i1@343@04]
(assert (<= 0 i1@343@04))
; [eval] i1 < to
(pop) ; 13
(push) ; 13
; [else-branch: 190 | !(0 <= i1@343@04)]
(assert (not (<= 0 i1@343@04)))
(pop) ; 13
(pop) ; 12
; Joined path conditions
; Joined path conditions
(assert (and (< i1@343@04 (alen<Int> (opt_get1 $Snap.unit P@14@04))) (<= 0 i1@343@04)))
(declare-const $k@344@04 $Perm)
(assert ($Perm.isReadVar $k@344@04 $Perm.Write))
; [eval] aloc(opt_get1(a2), i1)
; [eval] opt_get1(a2)
(push) ; 12
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 12
; Joined path conditions
(push) ; 12
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(pop) ; 12
; Joined path conditions
(pop) ; 11
(declare-fun inv@345@04 ($Ref) Int)
; Nested auxiliary terms: globals
(assert ($Perm.isReadVar $k@344@04 $Perm.Write))
; Nested auxiliary terms: non-globals
(set-option :timeout 0)
(push) ; 11
(assert (not (forall ((i1@343@04 Int)) (!
  (implies
    (and
      (< i1@343@04 (alen<Int> (opt_get1 $Snap.unit P@14@04)))
      (<= 0 i1@343@04))
    (or (= $k@344@04 $Perm.No) (< $Perm.No $k@344@04)))
  
  ))))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               553832
;  :arith-add-rows          252502
;  :arith-assert-diseq      4869
;  :arith-assert-lower      94631
;  :arith-assert-upper      79941
;  :arith-bound-prop        14305
;  :arith-conflicts         520
;  :arith-eq-adapter        72231
;  :arith-fixed-eqs         78959
;  :arith-offset-eqs        47034
;  :arith-pivots            50626
;  :conflicts               1791
;  :datatype-accessor-ax    246
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               28947
;  :del-clause              1739415
;  :final-checks            5
;  :max-generation          12
;  :max-memory              83.11
;  :memory                  77.59
;  :minimized-lits          228
;  :mk-bool-var             1641676
;  :mk-clause               1740778
;  :num-allocs              5233279
;  :num-checks              338
;  :propagations            380738
;  :quant-instantiations    606272
;  :restarts                2
;  :rlimit-count            18448497)
(declare-const sm@346@04 $FVF<Int>)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@308@04 r) V@15@04) (<= 0 (inv@308@04 r)))
    (=
      ($FVF.lookup_int (as sm@346@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04)))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@346@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04)))))))))))) r))
  :qid |qp.fvfValDef253|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@305@04 r) V@15@04) (<= 0 (inv@305@04 r)))
        (< (inv@304@04 r) V@15@04))
      (<= 0 (inv@304@04 r)))
    (=
      ($FVF.lookup_int (as sm@346@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@346@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04))))))))) r))
  :qid |qp.fvfValDef254|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04)))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@346@04  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef255|)))
; Check receiver injectivity
(push) ; 11
(assert (not (forall ((i11@343@04 Int) (i12@343@04 Int)) (!
  (implies
    (and
      (and
        (and
          (and
            (< i11@343@04 (alen<Int> (opt_get1 $Snap.unit P@14@04)))
            (<= 0 i11@343@04))
          ($FVF.loc_int ($FVF.lookup_int (as sm@346@04  $FVF<Int>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit P@14@04) i11@343@04)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit P@14@04) i11@343@04)))
        (< $Perm.No $k@344@04))
      (and
        (and
          (and
            (< i12@343@04 (alen<Int> (opt_get1 $Snap.unit P@14@04)))
            (<= 0 i12@343@04))
          ($FVF.loc_int ($FVF.lookup_int (as sm@346@04  $FVF<Int>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit P@14@04) i12@343@04)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit P@14@04) i12@343@04)))
        (< $Perm.No $k@344@04))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i11@343@04)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i12@343@04)))
    (= i11@343@04 i12@343@04))
  
  :qid |int-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               553871
;  :arith-add-rows          252511
;  :arith-assert-diseq      4870
;  :arith-assert-lower      94635
;  :arith-assert-upper      79941
;  :arith-bound-prop        14305
;  :arith-conflicts         520
;  :arith-eq-adapter        72232
;  :arith-fixed-eqs         78959
;  :arith-offset-eqs        47034
;  :arith-pivots            50628
;  :conflicts               1792
;  :datatype-accessor-ax    246
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               28947
;  :del-clause              1739426
;  :final-checks            5
;  :max-generation          12
;  :max-memory              83.11
;  :memory                  77.40
;  :minimized-lits          228
;  :mk-bool-var             1641739
;  :mk-clause               1740789
;  :num-allocs              5234361
;  :num-checks              339
;  :propagations            380740
;  :quant-instantiations    606332
;  :restarts                2
;  :rlimit-count            18451869
;  :time                    0.00)
; Definitional axioms for inverse functions
(assert (forall ((i1@343@04 Int)) (!
  (implies
    (and
      (and
        (< i1@343@04 (alen<Int> (opt_get1 $Snap.unit P@14@04)))
        (<= 0 i1@343@04))
      (< $Perm.No $k@344@04))
    (=
      (inv@345@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i1@343@04))
      i1@343@04))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i1@343@04))
  :qid |int-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (< (inv@345@04 r) (alen<Int> (opt_get1 $Snap.unit P@14@04)))
        (<= 0 (inv@345@04 r)))
      (< $Perm.No $k@344@04))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) (inv@345@04 r))
      r))
  :pattern ((inv@345@04 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (< (inv@345@04 r) (alen<Int> (opt_get1 $Snap.unit P@14@04)))
      (<= 0 (inv@345@04 r)))
    ($FVF.loc_int ($FVF.lookup_int (as sm@346@04  $FVF<Int>) r) r))
  :pattern ((inv@345@04 r))
  )))
; Precomputing data for removing quantified permissions
(define-fun pTaken@347@04 ((r $Ref)) $Perm
  (ite
    (and
      (< (inv@345@04 r) (alen<Int> (opt_get1 $Snap.unit P@14@04)))
      (<= 0 (inv@345@04 r)))
    ($Perm.min
      (ite
        (and (< (inv@308@04 r) V@15@04) (<= 0 (inv@308@04 r)))
        $Perm.Write
        $Perm.No)
      $k@344@04)
    $Perm.No))
(define-fun pTaken@348@04 ((r $Ref)) $Perm
  (ite
    (and
      (< (inv@345@04 r) (alen<Int> (opt_get1 $Snap.unit P@14@04)))
      (<= 0 (inv@345@04 r)))
    ($Perm.min
      (ite
        (and
          (and
            (and (< (inv@305@04 r) V@15@04) (<= 0 (inv@305@04 r)))
            (< (inv@304@04 r) V@15@04))
          (<= 0 (inv@304@04 r)))
        $Perm.Write
        $Perm.No)
      (- $k@344@04 (pTaken@347@04 r)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Constrain original permissions $k@344@04
(assert (forall ((r $Ref)) (!
  (implies
    (not
      (=
        (ite
          (and (< (inv@308@04 r) V@15@04) (<= 0 (inv@308@04 r)))
          $Perm.Write
          $Perm.No)
        $Perm.No))
    (ite
      (and (< (inv@308@04 r) V@15@04) (<= 0 (inv@308@04 r)))
      (<
        (ite
          (and
            (< (inv@345@04 r) (alen<Int> (opt_get1 $Snap.unit P@14@04)))
            (<= 0 (inv@345@04 r)))
          $k@344@04
          $Perm.No)
        $Perm.Write)
      (<
        (ite
          (and
            (< (inv@345@04 r) (alen<Int> (opt_get1 $Snap.unit P@14@04)))
            (<= 0 (inv@345@04 r)))
          $k@344@04
          $Perm.No)
        $Perm.No)))
  :pattern ((inv@308@04 r))
  :pattern ((inv@345@04 r))
  :qid |qp.srp256|)))
; Intermediate check if already taken enough permissions
(set-option :timeout 500)
(push) ; 11
(assert (not (forall ((r $Ref)) (!
  (implies
    (and
      (< (inv@345@04 r) (alen<Int> (opt_get1 $Snap.unit P@14@04)))
      (<= 0 (inv@345@04 r)))
    (= (- $k@344@04 (pTaken@347@04 r)) $Perm.No))
  
  ))))
(check-sat)
; unsat
(pop) ; 11
; 0.03s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               554772
;  :arith-add-rows          253295
;  :arith-assert-diseq      4892
;  :arith-assert-lower      94800
;  :arith-assert-upper      80052
;  :arith-bound-prop        14337
;  :arith-conflicts         522
;  :arith-eq-adapter        72344
;  :arith-fixed-eqs         79088
;  :arith-offset-eqs        47103
;  :arith-pivots            50705
;  :conflicts               1813
;  :datatype-accessor-ax    246
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               29149
;  :del-clause              1747153
;  :final-checks            5
;  :max-generation          12
;  :max-memory              83.11
;  :memory                  77.21
;  :minimized-lits          228
;  :mk-bool-var             1647857
;  :mk-clause               1748514
;  :num-allocs              5252033
;  :num-checks              341
;  :propagations            381770
;  :quant-instantiations    607930
;  :restarts                2
;  :rlimit-count            18533944
;  :time                    0.03)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@349@04 $FVF<Int>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (iff
    (Set_in r ($FVF.domain_int (as sm@349@04  $FVF<Int>)))
    (and
      (and
        (< (inv@345@04 r) (alen<Int> (opt_get1 $Snap.unit P@14@04)))
        (<= 0 (inv@345@04 r)))
      (< $Perm.No $k@344@04)))
  :pattern ((Set_in r ($FVF.domain_int (as sm@349@04  $FVF<Int>))))
  :qid |qp.fvfDomDef260|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and
          (< (inv@345@04 r) (alen<Int> (opt_get1 $Snap.unit P@14@04)))
          (<= 0 (inv@345@04 r)))
        (< $Perm.No $k@344@04))
      (and (< (inv@308@04 r) V@15@04) (<= 0 (inv@308@04 r))))
    (=
      ($FVF.lookup_int (as sm@349@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04)))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@349@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04)))))))))))) r))
  :qid |qp.fvfValDef257|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and
          (< (inv@345@04 r) (alen<Int> (opt_get1 $Snap.unit P@14@04)))
          (<= 0 (inv@345@04 r)))
        (< $Perm.No $k@344@04))
      (and
        (and
          (and (< (inv@305@04 r) V@15@04) (<= 0 (inv@305@04 r)))
          (< (inv@304@04 r) V@15@04))
        (<= 0 (inv@304@04 r))))
    (=
      ($FVF.lookup_int (as sm@349@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@349@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04))))))))) r))
  :qid |qp.fvfValDef258|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04)))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@349@04  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef259|)))
(pop) ; 10
; Joined path conditions
(assert ($Perm.isReadVar $k@344@04 $Perm.Write))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@308@04 r) V@15@04) (<= 0 (inv@308@04 r)))
    (=
      ($FVF.lookup_int (as sm@346@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04)))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@346@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04)))))))))))) r))
  :qid |qp.fvfValDef253|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@305@04 r) V@15@04) (<= 0 (inv@305@04 r)))
        (< (inv@304@04 r) V@15@04))
      (<= 0 (inv@304@04 r)))
    (=
      ($FVF.lookup_int (as sm@346@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@346@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04))))))))) r))
  :qid |qp.fvfValDef254|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04)))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@346@04  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef255|)))
(assert (forall ((i1@343@04 Int)) (!
  (implies
    (and
      (and
        (< i1@343@04 (alen<Int> (opt_get1 $Snap.unit P@14@04)))
        (<= 0 i1@343@04))
      (< $Perm.No $k@344@04))
    (=
      (inv@345@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i1@343@04))
      i1@343@04))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i1@343@04))
  :qid |int-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (< (inv@345@04 r) (alen<Int> (opt_get1 $Snap.unit P@14@04)))
        (<= 0 (inv@345@04 r)))
      (< $Perm.No $k@344@04))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) (inv@345@04 r))
      r))
  :pattern ((inv@345@04 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (iff
    (Set_in r ($FVF.domain_int (as sm@349@04  $FVF<Int>)))
    (and
      (and
        (< (inv@345@04 r) (alen<Int> (opt_get1 $Snap.unit P@14@04)))
        (<= 0 (inv@345@04 r)))
      (< $Perm.No $k@344@04)))
  :pattern ((Set_in r ($FVF.domain_int (as sm@349@04  $FVF<Int>))))
  :qid |qp.fvfDomDef260|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and
          (< (inv@345@04 r) (alen<Int> (opt_get1 $Snap.unit P@14@04)))
          (<= 0 (inv@345@04 r)))
        (< $Perm.No $k@344@04))
      (and (< (inv@308@04 r) V@15@04) (<= 0 (inv@308@04 r))))
    (=
      ($FVF.lookup_int (as sm@349@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04)))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@349@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04)))))))))))) r))
  :qid |qp.fvfValDef257|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and
          (< (inv@345@04 r) (alen<Int> (opt_get1 $Snap.unit P@14@04)))
          (<= 0 (inv@345@04 r)))
        (< $Perm.No $k@344@04))
      (and
        (and
          (and (< (inv@305@04 r) V@15@04) (<= 0 (inv@305@04 r)))
          (< (inv@304@04 r) V@15@04))
        (<= 0 (inv@304@04 r))))
    (=
      ($FVF.lookup_int (as sm@349@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@349@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04))))))))) r))
  :qid |qp.fvfValDef258|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04)))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@349@04  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef259|)))
(assert (and
  (forall ((r $Ref)) (!
    (implies
      (and
        (< (inv@345@04 r) (alen<Int> (opt_get1 $Snap.unit P@14@04)))
        (<= 0 (inv@345@04 r)))
      ($FVF.loc_int ($FVF.lookup_int (as sm@346@04  $FVF<Int>) r) r))
    :pattern ((inv@345@04 r))
    ))
  (forall ((r $Ref)) (!
    (implies
      (not
        (=
          (ite
            (and (< (inv@308@04 r) V@15@04) (<= 0 (inv@308@04 r)))
            $Perm.Write
            $Perm.No)
          $Perm.No))
      (ite
        (and (< (inv@308@04 r) V@15@04) (<= 0 (inv@308@04 r)))
        (<
          (ite
            (and
              (< (inv@345@04 r) (alen<Int> (opt_get1 $Snap.unit P@14@04)))
              (<= 0 (inv@345@04 r)))
            $k@344@04
            $Perm.No)
          $Perm.Write)
        (<
          (ite
            (and
              (< (inv@345@04 r) (alen<Int> (opt_get1 $Snap.unit P@14@04)))
              (<= 0 (inv@345@04 r)))
            $k@344@04
            $Perm.No)
          $Perm.No)))
    :pattern ((inv@308@04 r))
    :pattern ((inv@345@04 r))
    :qid |qp.srp256|))))
(declare-const P_seq@350@04 Seq<Int>)
(assert (Seq_equal
  P_seq@350@04
  (unknown_ ($Snap.combine
    $Snap.unit
    ($Snap.combine
      $Snap.unit
      ($Snap.combine
        $Snap.unit
        ($Snap.combine
          $Snap.unit
          ($SortWrappers.$FVF<Int>To$Snap (as sm@349@04  $FVF<Int>)))))) P@14@04 0 (alen<Int> (opt_get1 $Snap.unit P@14@04)))))
; [exec]
; bottleneckPathFlow := 999999999
; [exec]
; label loop1
; [exec]
; excBeforeLoop1 := exc
; [exec]
; v := t
(declare-const u@351@04 Int)
(declare-const bottleneckPathFlow@352@04 Int)
(declare-const v@353@04 Int)
(push) ; 10
; Loop head block: Check well-definedness of invariant
(declare-const $t@354@04 $Snap)
(assert (= $t@354@04 ($Snap.combine ($Snap.first $t@354@04) ($Snap.second $t@354@04))))
(assert (= ($Snap.first $t@354@04) $Snap.unit))
; [eval] exc == excBeforeLoop1
(assert (=
  ($Snap.second $t@354@04)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@354@04))
    ($Snap.second ($Snap.second $t@354@04)))))
(assert (= ($Snap.first ($Snap.second $t@354@04)) $Snap.unit))
; [eval] 0 <= v
(assert (<= 0 v@353@04))
(assert (=
  ($Snap.second ($Snap.second $t@354@04))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second $t@354@04)))
    ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))
(assert (= ($Snap.first ($Snap.second ($Snap.second $t@354@04))) $Snap.unit))
; [eval] v < V
(assert (< v@353@04 V@15@04))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second $t@354@04)))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@354@04))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04)))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@354@04))))
  $Snap.unit))
; [eval] G != (None(): option[array])
; [eval] (None(): option[array])
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04)))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04)))))
  $Snap.unit))
; [eval] alen(opt_get1(G)) == V
; [eval] alen(opt_get1(G))
; [eval] opt_get1(G)
(push) ; 11
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 11
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04)))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04)))))))))
(declare-const i1@355@04 Int)
(push) ; 11
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 12
; [then-branch: 191 | 0 <= i1@355@04 | live]
; [else-branch: 191 | !(0 <= i1@355@04) | live]
(push) ; 13
; [then-branch: 191 | 0 <= i1@355@04]
(assert (<= 0 i1@355@04))
; [eval] i1 < V
(pop) ; 13
(push) ; 13
; [else-branch: 191 | !(0 <= i1@355@04)]
(assert (not (<= 0 i1@355@04)))
(pop) ; 13
(pop) ; 12
; Joined path conditions
; Joined path conditions
(assert (and (< i1@355@04 V@15@04) (<= 0 i1@355@04)))
; [eval] aloc(opt_get1(G), i1)
; [eval] opt_get1(G)
(push) ; 12
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 12
; Joined path conditions
(push) ; 12
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 13
(assert (not (< i1@355@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))))
(check-sat)
; unsat
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               554844
;  :arith-add-rows          253303
;  :arith-assert-diseq      4893
;  :arith-assert-lower      94810
;  :arith-assert-upper      80056
;  :arith-bound-prop        14337
;  :arith-conflicts         522
;  :arith-eq-adapter        72350
;  :arith-fixed-eqs         79090
;  :arith-offset-eqs        47103
;  :arith-pivots            50709
;  :conflicts               1813
;  :datatype-accessor-ax    256
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               29149
;  :del-clause              1747153
;  :final-checks            5
;  :max-generation          12
;  :max-memory              83.11
;  :memory                  77.22
;  :minimized-lits          228
;  :mk-bool-var             1648056
;  :mk-clause               1748652
;  :num-allocs              5255061
;  :num-checks              342
;  :propagations            381792
;  :quant-instantiations    607963
;  :restarts                2
;  :rlimit-count            18542901)
(assert (< i1@355@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(pop) ; 12
; Joined path conditions
(assert (< i1@355@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(declare-const $k@356@04 $Perm)
(assert ($Perm.isReadVar $k@356@04 $Perm.Write))
(pop) ; 11
(declare-fun inv@357@04 ($Ref) Int)
; Nested auxiliary terms: globals
(assert ($Perm.isReadVar $k@356@04 $Perm.Write))
; Nested auxiliary terms: non-globals
(assert (forall ((i1@355@04 Int)) (!
  (< i1@355@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@355@04))
  :qid |option$array$-aux|)))
(push) ; 11
(assert (not (forall ((i1@355@04 Int)) (!
  (implies
    (and (< i1@355@04 V@15@04) (<= 0 i1@355@04))
    (or (= $k@356@04 $Perm.No) (< $Perm.No $k@356@04)))
  
  ))))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               554844
;  :arith-add-rows          253304
;  :arith-assert-diseq      4894
;  :arith-assert-lower      94812
;  :arith-assert-upper      80057
;  :arith-bound-prop        14337
;  :arith-conflicts         522
;  :arith-eq-adapter        72351
;  :arith-fixed-eqs         79090
;  :arith-offset-eqs        47103
;  :arith-pivots            50709
;  :conflicts               1814
;  :datatype-accessor-ax    256
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               29149
;  :del-clause              1747153
;  :final-checks            5
;  :max-generation          12
;  :max-memory              83.11
;  :memory                  77.23
;  :minimized-lits          228
;  :mk-bool-var             1648063
;  :mk-clause               1748654
;  :num-allocs              5255526
;  :num-checks              343
;  :propagations            381793
;  :quant-instantiations    607963
;  :restarts                2
;  :rlimit-count            18543473)
; Check receiver injectivity
(push) ; 11
(assert (not (forall ((i11@355@04 Int) (i12@355@04 Int)) (!
  (implies
    (and
      (and (and (< i11@355@04 V@15@04) (<= 0 i11@355@04)) (< $Perm.No $k@356@04))
      (and (and (< i12@355@04 V@15@04) (<= 0 i12@355@04)) (< $Perm.No $k@356@04))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i11@355@04)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i12@355@04)))
    (= i11@355@04 i12@355@04))
  
  :qid |option$array$-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               554888
;  :arith-add-rows          253308
;  :arith-assert-diseq      4895
;  :arith-assert-lower      94816
;  :arith-assert-upper      80057
;  :arith-bound-prop        14337
;  :arith-conflicts         522
;  :arith-eq-adapter        72352
;  :arith-fixed-eqs         79090
;  :arith-offset-eqs        47103
;  :arith-pivots            50709
;  :conflicts               1815
;  :datatype-accessor-ax    256
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               29149
;  :del-clause              1747159
;  :final-checks            5
;  :max-generation          12
;  :max-memory              83.11
;  :memory                  77.23
;  :minimized-lits          228
;  :mk-bool-var             1648129
;  :mk-clause               1748660
;  :num-allocs              5256387
;  :num-checks              344
;  :propagations            381793
;  :quant-instantiations    608038
;  :restarts                2
;  :rlimit-count            18546099
;  :time                    0.00)
; Definitional axioms for inverse functions
(assert (forall ((i1@355@04 Int)) (!
  (implies
    (and (and (< i1@355@04 V@15@04) (<= 0 i1@355@04)) (< $Perm.No $k@356@04))
    (=
      (inv@357@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@355@04))
      i1@355@04))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@355@04))
  )))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and (< (inv@357@04 r) V@15@04) (<= 0 (inv@357@04 r)))
      (< $Perm.No $k@356@04))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) (inv@357@04 r))
      r))
  :pattern ((inv@357@04 r))
  :qid |option$array$-fctOfInv|)))
; Permissions are non-negative
(assert (forall ((i1@355@04 Int)) (!
  (<= $Perm.No $k@356@04)
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@355@04))
  :qid |option$array$-permAtLeastZero|)))
; Field permissions are at most one
(assert (forall ((i1@355@04 Int)) (!
  (<= $k@356@04 $Perm.Write)
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@355@04))
  :qid |option$array$-permAtMostOne|)))
; Permission implies non-null receiver
(assert (forall ((i1@355@04 Int)) (!
  (implies
    (and (and (< i1@355@04 V@15@04) (<= 0 i1@355@04)) (< $Perm.No $k@356@04))
    (not
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@355@04)
        $Ref.null)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@355@04))
  :qid |option$array$-permImpliesNonNull|)))
(declare-const sm@358@04 $FVF<option<array>>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@357@04 r) V@15@04) (<= 0 (inv@357@04 r)))
      (< $Perm.No $k@356@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@358@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@358@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))) r))
  :qid |qp.fvfValDef261|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))) r) r)
  :pattern (($FVF.lookup_option$array$ (as sm@358@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef262|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@357@04 r) V@15@04) (<= 0 (inv@357@04 r)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@358@04  $FVF<option<array>>) r) r))
  :pattern ((inv@357@04 r))
  )))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04)))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04)))))))
  $Snap.unit))
; [eval] (forall i1: Int :: { aloc(opt_get1(G), i1) } 0 <= i1 && i1 < V ==> aloc(opt_get1(G), i1).option$array$ != (None(): option[array]))
(declare-const i1@359@04 Int)
(push) ; 11
; [eval] 0 <= i1 && i1 < V ==> aloc(opt_get1(G), i1).option$array$ != (None(): option[array])
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 12
; [then-branch: 192 | 0 <= i1@359@04 | live]
; [else-branch: 192 | !(0 <= i1@359@04) | live]
(push) ; 13
; [then-branch: 192 | 0 <= i1@359@04]
(assert (<= 0 i1@359@04))
; [eval] i1 < V
(pop) ; 13
(push) ; 13
; [else-branch: 192 | !(0 <= i1@359@04)]
(assert (not (<= 0 i1@359@04)))
(pop) ; 13
(pop) ; 12
; Joined path conditions
; Joined path conditions
(push) ; 12
; [then-branch: 193 | i1@359@04 < V@15@04 && 0 <= i1@359@04 | live]
; [else-branch: 193 | !(i1@359@04 < V@15@04 && 0 <= i1@359@04) | live]
(push) ; 13
; [then-branch: 193 | i1@359@04 < V@15@04 && 0 <= i1@359@04]
(assert (and (< i1@359@04 V@15@04) (<= 0 i1@359@04)))
; [eval] aloc(opt_get1(G), i1).option$array$ != (None(): option[array])
; [eval] aloc(opt_get1(G), i1)
; [eval] opt_get1(G)
(push) ; 14
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 14
; Joined path conditions
(push) ; 14
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 15
(assert (not (< i1@359@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))))
(check-sat)
; unsat
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               554894
;  :arith-add-rows          253309
;  :arith-assert-diseq      4895
;  :arith-assert-lower      94818
;  :arith-assert-upper      80058
;  :arith-bound-prop        14337
;  :arith-conflicts         522
;  :arith-eq-adapter        72352
;  :arith-fixed-eqs         79090
;  :arith-offset-eqs        47103
;  :arith-pivots            50710
;  :conflicts               1815
;  :datatype-accessor-ax    257
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               29149
;  :del-clause              1747159
;  :final-checks            5
;  :max-generation          12
;  :max-memory              83.11
;  :memory                  77.24
;  :minimized-lits          228
;  :mk-bool-var             1648140
;  :mk-clause               1748660
;  :num-allocs              5257585
;  :num-checks              345
;  :propagations            381793
;  :quant-instantiations    608038
;  :restarts                2
;  :rlimit-count            18548544)
(assert (< i1@359@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(pop) ; 14
; Joined path conditions
(assert (< i1@359@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@358@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@359@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@359@04)))
(push) ; 14
(assert (not (ite
  (and
    (<
      (inv@357@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@359@04))
      V@15@04)
    (<=
      0
      (inv@357@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@359@04))))
  (< $Perm.No $k@356@04)
  false)))
(check-sat)
; unsat
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               555025
;  :arith-add-rows          253366
;  :arith-assert-diseq      4895
;  :arith-assert-lower      94836
;  :arith-assert-upper      80073
;  :arith-bound-prop        14348
;  :arith-conflicts         523
;  :arith-eq-adapter        72366
;  :arith-fixed-eqs         79104
;  :arith-offset-eqs        47124
;  :arith-pivots            50725
;  :conflicts               1816
;  :datatype-accessor-ax    257
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               29149
;  :del-clause              1747159
;  :final-checks            5
;  :max-generation          12
;  :max-memory              83.11
;  :memory                  77.25
;  :minimized-lits          228
;  :mk-bool-var             1648629
;  :mk-clause               1748985
;  :num-allocs              5259693
;  :num-checks              346
;  :propagations            381801
;  :quant-instantiations    608226
;  :restarts                2
;  :rlimit-count            18557550)
; [eval] (None(): option[array])
(pop) ; 13
(push) ; 13
; [else-branch: 193 | !(i1@359@04 < V@15@04 && 0 <= i1@359@04)]
(assert (not (and (< i1@359@04 V@15@04) (<= 0 i1@359@04))))
(pop) ; 13
(pop) ; 12
; Joined path conditions
(assert (implies
  (and (< i1@359@04 V@15@04) (<= 0 i1@359@04))
  (and
    (< i1@359@04 V@15@04)
    (<= 0 i1@359@04)
    (< i1@359@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@358@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@359@04)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@359@04)))))
; Joined path conditions
(pop) ; 11
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@359@04 Int)) (!
  (implies
    (and (< i1@359@04 V@15@04) (<= 0 i1@359@04))
    (and
      (< i1@359@04 V@15@04)
      (<= 0 i1@359@04)
      (< i1@359@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@358@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@359@04)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@359@04))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@359@04))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(assert (forall ((i1@359@04 Int)) (!
  (implies
    (and (< i1@359@04 V@15@04) (<= 0 i1@359@04))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@358@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@359@04))
        (as None<option<array>>  option<array>))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@359@04))
  :qid |prog.l<no position>|)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04)))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04)))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))))
  $Snap.unit))
; [eval] (forall i1: Int :: { alen(opt_get1(aloc(opt_get1(G), i1).option$array$)) } 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(G), i1).option$array$)) == V)
(declare-const i1@360@04 Int)
(push) ; 11
; [eval] 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(G), i1).option$array$)) == V
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 12
; [then-branch: 194 | 0 <= i1@360@04 | live]
; [else-branch: 194 | !(0 <= i1@360@04) | live]
(push) ; 13
; [then-branch: 194 | 0 <= i1@360@04]
(assert (<= 0 i1@360@04))
; [eval] i1 < V
(pop) ; 13
(push) ; 13
; [else-branch: 194 | !(0 <= i1@360@04)]
(assert (not (<= 0 i1@360@04)))
(pop) ; 13
(pop) ; 12
; Joined path conditions
; Joined path conditions
(push) ; 12
; [then-branch: 195 | i1@360@04 < V@15@04 && 0 <= i1@360@04 | live]
; [else-branch: 195 | !(i1@360@04 < V@15@04 && 0 <= i1@360@04) | live]
(push) ; 13
; [then-branch: 195 | i1@360@04 < V@15@04 && 0 <= i1@360@04]
(assert (and (< i1@360@04 V@15@04) (<= 0 i1@360@04)))
; [eval] alen(opt_get1(aloc(opt_get1(G), i1).option$array$)) == V
; [eval] alen(opt_get1(aloc(opt_get1(G), i1).option$array$))
; [eval] opt_get1(aloc(opt_get1(G), i1).option$array$)
; [eval] aloc(opt_get1(G), i1)
; [eval] opt_get1(G)
(push) ; 14
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 14
; Joined path conditions
(push) ; 14
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 15
(assert (not (< i1@360@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))))
(check-sat)
; unsat
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               555031
;  :arith-add-rows          253378
;  :arith-assert-diseq      4895
;  :arith-assert-lower      94838
;  :arith-assert-upper      80073
;  :arith-bound-prop        14348
;  :arith-conflicts         523
;  :arith-eq-adapter        72366
;  :arith-fixed-eqs         79104
;  :arith-offset-eqs        47124
;  :arith-pivots            50740
;  :conflicts               1816
;  :datatype-accessor-ax    258
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               29149
;  :del-clause              1747484
;  :final-checks            5
;  :max-generation          12
;  :max-memory              83.11
;  :memory                  77.22
;  :minimized-lits          228
;  :mk-bool-var             1648635
;  :mk-clause               1748985
;  :num-allocs              5260240
;  :num-checks              347
;  :propagations            381801
;  :quant-instantiations    608226
;  :restarts                2
;  :rlimit-count            18558974)
(assert (< i1@360@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(pop) ; 14
; Joined path conditions
(assert (< i1@360@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@358@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@360@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@360@04)))
(push) ; 14
(assert (not (ite
  (and
    (<
      (inv@357@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@360@04))
      V@15@04)
    (<=
      0
      (inv@357@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@360@04))))
  (< $Perm.No $k@356@04)
  false)))
(check-sat)
; unsat
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               555138
;  :arith-add-rows          253424
;  :arith-assert-diseq      4895
;  :arith-assert-lower      94856
;  :arith-assert-upper      80088
;  :arith-bound-prop        14358
;  :arith-conflicts         524
;  :arith-eq-adapter        72380
;  :arith-fixed-eqs         79118
;  :arith-offset-eqs        47124
;  :arith-pivots            50755
;  :conflicts               1817
;  :datatype-accessor-ax    258
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               29149
;  :del-clause              1747484
;  :final-checks            5
;  :max-generation          12
;  :max-memory              83.11
;  :memory                  77.24
;  :minimized-lits          228
;  :mk-bool-var             1649126
;  :mk-clause               1749310
;  :num-allocs              5262344
;  :num-checks              348
;  :propagations            381806
;  :quant-instantiations    608416
;  :restarts                2
;  :rlimit-count            18567837)
(push) ; 14
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 15
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@358@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@360@04))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               555138
;  :arith-add-rows          253424
;  :arith-assert-diseq      4895
;  :arith-assert-lower      94856
;  :arith-assert-upper      80088
;  :arith-bound-prop        14358
;  :arith-conflicts         524
;  :arith-eq-adapter        72380
;  :arith-fixed-eqs         79118
;  :arith-offset-eqs        47124
;  :arith-pivots            50755
;  :conflicts               1818
;  :datatype-accessor-ax    258
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               29149
;  :del-clause              1747484
;  :final-checks            5
;  :max-generation          12
;  :max-memory              83.11
;  :memory                  77.24
;  :minimized-lits          228
;  :mk-bool-var             1649126
;  :mk-clause               1749310
;  :num-allocs              5262434
;  :num-checks              349
;  :propagations            381806
;  :quant-instantiations    608416
;  :restarts                2
;  :rlimit-count            18567932)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@358@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@360@04))
    (as None<option<array>>  option<array>))))
(pop) ; 14
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@358@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@360@04))
    (as None<option<array>>  option<array>))))
(pop) ; 13
(push) ; 13
; [else-branch: 195 | !(i1@360@04 < V@15@04 && 0 <= i1@360@04)]
(assert (not (and (< i1@360@04 V@15@04) (<= 0 i1@360@04))))
(pop) ; 13
(pop) ; 12
; Joined path conditions
(assert (implies
  (and (< i1@360@04 V@15@04) (<= 0 i1@360@04))
  (and
    (< i1@360@04 V@15@04)
    (<= 0 i1@360@04)
    (< i1@360@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@358@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@360@04)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@360@04))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@358@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@360@04))
        (as None<option<array>>  option<array>))))))
; Joined path conditions
(pop) ; 11
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@360@04 Int)) (!
  (implies
    (and (< i1@360@04 V@15@04) (<= 0 i1@360@04))
    (and
      (< i1@360@04 V@15@04)
      (<= 0 i1@360@04)
      (< i1@360@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@358@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@360@04)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@360@04))
      (not
        (=
          ($FVF.lookup_option$array$ (as sm@358@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@360@04))
          (as None<option<array>>  option<array>)))))
  :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@358@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@360@04)))))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(assert (forall ((i1@360@04 Int)) (!
  (implies
    (and (< i1@360@04 V@15@04) (<= 0 i1@360@04))
    (=
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@358@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@360@04))))
      V@15@04))
  :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@358@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@360@04)))))
  :qid |prog.l<no position>|)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04)))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04)))))))))
  $Snap.unit))
; [eval] (forall i1: Int :: { aloc(opt_get1(G), i1) } (forall i2: Int :: { aloc(opt_get1(G), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(G), i1).option$array$ == aloc(opt_get1(G), i2).option$array$ ==> i1 == i2))
(declare-const i1@361@04 Int)
(push) ; 11
; [eval] (forall i2: Int :: { aloc(opt_get1(G), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(G), i1).option$array$ == aloc(opt_get1(G), i2).option$array$ ==> i1 == i2)
(declare-const i2@362@04 Int)
(push) ; 12
; [eval] 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(G), i1).option$array$ == aloc(opt_get1(G), i2).option$array$ ==> i1 == i2
; [eval] 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(G), i1).option$array$ == aloc(opt_get1(G), i2).option$array$
; [eval] 0 <= i1
(push) ; 13
; [then-branch: 196 | 0 <= i1@361@04 | live]
; [else-branch: 196 | !(0 <= i1@361@04) | live]
(push) ; 14
; [then-branch: 196 | 0 <= i1@361@04]
(assert (<= 0 i1@361@04))
; [eval] i1 < V
(push) ; 15
; [then-branch: 197 | i1@361@04 < V@15@04 | live]
; [else-branch: 197 | !(i1@361@04 < V@15@04) | live]
(push) ; 16
; [then-branch: 197 | i1@361@04 < V@15@04]
(assert (< i1@361@04 V@15@04))
; [eval] 0 <= i2
(push) ; 17
; [then-branch: 198 | 0 <= i2@362@04 | live]
; [else-branch: 198 | !(0 <= i2@362@04) | live]
(push) ; 18
; [then-branch: 198 | 0 <= i2@362@04]
(assert (<= 0 i2@362@04))
; [eval] i2 < V
(push) ; 19
; [then-branch: 199 | i2@362@04 < V@15@04 | live]
; [else-branch: 199 | !(i2@362@04 < V@15@04) | live]
(push) ; 20
; [then-branch: 199 | i2@362@04 < V@15@04]
(assert (< i2@362@04 V@15@04))
; [eval] aloc(opt_get1(G), i1).option$array$ == aloc(opt_get1(G), i2).option$array$
; [eval] aloc(opt_get1(G), i1)
; [eval] opt_get1(G)
(push) ; 21
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 21
; Joined path conditions
(push) ; 21
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 22
(assert (not (< i1@361@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))))
(check-sat)
; unsat
(pop) ; 22
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               555144
;  :arith-add-rows          253437
;  :arith-assert-diseq      4895
;  :arith-assert-lower      94860
;  :arith-assert-upper      80088
;  :arith-bound-prop        14358
;  :arith-conflicts         524
;  :arith-eq-adapter        72380
;  :arith-fixed-eqs         79118
;  :arith-offset-eqs        47124
;  :arith-pivots            50771
;  :conflicts               1818
;  :datatype-accessor-ax    259
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               29149
;  :del-clause              1747809
;  :final-checks            5
;  :max-generation          12
;  :max-memory              83.11
;  :memory                  77.22
;  :minimized-lits          228
;  :mk-bool-var             1649134
;  :mk-clause               1749310
;  :num-allocs              5263173
;  :num-checks              350
;  :propagations            381806
;  :quant-instantiations    608416
;  :restarts                2
;  :rlimit-count            18569719)
(assert (< i1@361@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(pop) ; 21
; Joined path conditions
(assert (< i1@361@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@358@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@361@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@361@04)))
(push) ; 21
(assert (not (ite
  (and
    (<
      (inv@357@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@361@04))
      V@15@04)
    (<=
      0
      (inv@357@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@361@04))))
  (< $Perm.No $k@356@04)
  false)))
(check-sat)
; unsat
(pop) ; 21
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               555276
;  :arith-add-rows          253494
;  :arith-assert-diseq      4895
;  :arith-assert-lower      94878
;  :arith-assert-upper      80103
;  :arith-bound-prop        14369
;  :arith-conflicts         525
;  :arith-eq-adapter        72394
;  :arith-fixed-eqs         79132
;  :arith-offset-eqs        47145
;  :arith-pivots            50786
;  :conflicts               1819
;  :datatype-accessor-ax    259
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               29149
;  :del-clause              1747809
;  :final-checks            5
;  :max-generation          12
;  :max-memory              83.11
;  :memory                  77.24
;  :minimized-lits          228
;  :mk-bool-var             1649626
;  :mk-clause               1749635
;  :num-allocs              5265284
;  :num-checks              351
;  :propagations            381814
;  :quant-instantiations    608606
;  :restarts                2
;  :rlimit-count            18578676)
; [eval] aloc(opt_get1(G), i2)
; [eval] opt_get1(G)
(push) ; 21
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 21
; Joined path conditions
(push) ; 21
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 22
(assert (not (< i2@362@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))))
(check-sat)
; unsat
(pop) ; 22
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               555276
;  :arith-add-rows          253494
;  :arith-assert-diseq      4895
;  :arith-assert-lower      94878
;  :arith-assert-upper      80103
;  :arith-bound-prop        14369
;  :arith-conflicts         525
;  :arith-eq-adapter        72394
;  :arith-fixed-eqs         79132
;  :arith-offset-eqs        47145
;  :arith-pivots            50786
;  :conflicts               1819
;  :datatype-accessor-ax    259
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               29149
;  :del-clause              1747809
;  :final-checks            5
;  :max-generation          12
;  :max-memory              83.11
;  :memory                  77.24
;  :minimized-lits          228
;  :mk-bool-var             1649626
;  :mk-clause               1749635
;  :num-allocs              5265310
;  :num-checks              352
;  :propagations            381814
;  :quant-instantiations    608606
;  :restarts                2
;  :rlimit-count            18578706)
(assert (< i2@362@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(pop) ; 21
; Joined path conditions
(assert (< i2@362@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@358@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@362@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@362@04)))
(push) ; 21
(assert (not (ite
  (and
    (<
      (inv@357@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@362@04))
      V@15@04)
    (<=
      0
      (inv@357@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@362@04))))
  (< $Perm.No $k@356@04)
  false)))
(check-sat)
; unsat
(pop) ; 21
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               555377
;  :arith-add-rows          253542
;  :arith-assert-diseq      4895
;  :arith-assert-lower      94896
;  :arith-assert-upper      80118
;  :arith-bound-prop        14379
;  :arith-conflicts         526
;  :arith-eq-adapter        72409
;  :arith-fixed-eqs         79146
;  :arith-offset-eqs        47145
;  :arith-pivots            50801
;  :conflicts               1820
;  :datatype-accessor-ax    259
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               29149
;  :del-clause              1747809
;  :final-checks            5
;  :max-generation          12
;  :max-memory              83.11
;  :memory                  77.27
;  :minimized-lits          228
;  :mk-bool-var             1649965
;  :mk-clause               1749862
;  :num-allocs              5267203
;  :num-checks              353
;  :propagations            381843
;  :quant-instantiations    608776
;  :restarts                2
;  :rlimit-count            18586788)
(pop) ; 20
(push) ; 20
; [else-branch: 199 | !(i2@362@04 < V@15@04)]
(assert (not (< i2@362@04 V@15@04)))
(pop) ; 20
(pop) ; 19
; Joined path conditions
(assert (implies
  (< i2@362@04 V@15@04)
  (and
    (< i2@362@04 V@15@04)
    (< i1@361@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@358@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@361@04)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@361@04))
    (< i2@362@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@358@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@362@04)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@362@04)))))
; Joined path conditions
(pop) ; 18
(push) ; 18
; [else-branch: 198 | !(0 <= i2@362@04)]
(assert (not (<= 0 i2@362@04)))
(pop) ; 18
(pop) ; 17
; Joined path conditions
(assert (implies
  (<= 0 i2@362@04)
  (and
    (<= 0 i2@362@04)
    (implies
      (< i2@362@04 V@15@04)
      (and
        (< i2@362@04 V@15@04)
        (< i1@361@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@358@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@361@04)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@361@04))
        (< i2@362@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@358@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@362@04)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@362@04)))))))
; Joined path conditions
(pop) ; 16
(push) ; 16
; [else-branch: 197 | !(i1@361@04 < V@15@04)]
(assert (not (< i1@361@04 V@15@04)))
(pop) ; 16
(pop) ; 15
; Joined path conditions
(assert (implies
  (< i1@361@04 V@15@04)
  (and
    (< i1@361@04 V@15@04)
    (implies
      (<= 0 i2@362@04)
      (and
        (<= 0 i2@362@04)
        (implies
          (< i2@362@04 V@15@04)
          (and
            (< i2@362@04 V@15@04)
            (< i1@361@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@358@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@361@04)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@361@04))
            (< i2@362@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@358@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@362@04)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@362@04)))))))))
; Joined path conditions
(pop) ; 14
(push) ; 14
; [else-branch: 196 | !(0 <= i1@361@04)]
(assert (not (<= 0 i1@361@04)))
(pop) ; 14
(pop) ; 13
; Joined path conditions
(assert (implies
  (<= 0 i1@361@04)
  (and
    (<= 0 i1@361@04)
    (implies
      (< i1@361@04 V@15@04)
      (and
        (< i1@361@04 V@15@04)
        (implies
          (<= 0 i2@362@04)
          (and
            (<= 0 i2@362@04)
            (implies
              (< i2@362@04 V@15@04)
              (and
                (< i2@362@04 V@15@04)
                (< i1@361@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@358@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@361@04)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@361@04))
                (< i2@362@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@358@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@362@04)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@362@04)))))))))))
; Joined path conditions
(push) ; 13
; [then-branch: 200 | Lookup(option$array$,sm@358@04,aloc((_, _), opt_get1(_, G@11@04), i1@361@04)) == Lookup(option$array$,sm@358@04,aloc((_, _), opt_get1(_, G@11@04), i2@362@04)) && i2@362@04 < V@15@04 && 0 <= i2@362@04 && i1@361@04 < V@15@04 && 0 <= i1@361@04 | live]
; [else-branch: 200 | !(Lookup(option$array$,sm@358@04,aloc((_, _), opt_get1(_, G@11@04), i1@361@04)) == Lookup(option$array$,sm@358@04,aloc((_, _), opt_get1(_, G@11@04), i2@362@04)) && i2@362@04 < V@15@04 && 0 <= i2@362@04 && i1@361@04 < V@15@04 && 0 <= i1@361@04) | live]
(push) ; 14
; [then-branch: 200 | Lookup(option$array$,sm@358@04,aloc((_, _), opt_get1(_, G@11@04), i1@361@04)) == Lookup(option$array$,sm@358@04,aloc((_, _), opt_get1(_, G@11@04), i2@362@04)) && i2@362@04 < V@15@04 && 0 <= i2@362@04 && i1@361@04 < V@15@04 && 0 <= i1@361@04]
(assert (and
  (and
    (and
      (and
        (=
          ($FVF.lookup_option$array$ (as sm@358@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@361@04))
          ($FVF.lookup_option$array$ (as sm@358@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@362@04)))
        (< i2@362@04 V@15@04))
      (<= 0 i2@362@04))
    (< i1@361@04 V@15@04))
  (<= 0 i1@361@04)))
; [eval] i1 == i2
(pop) ; 14
(push) ; 14
; [else-branch: 200 | !(Lookup(option$array$,sm@358@04,aloc((_, _), opt_get1(_, G@11@04), i1@361@04)) == Lookup(option$array$,sm@358@04,aloc((_, _), opt_get1(_, G@11@04), i2@362@04)) && i2@362@04 < V@15@04 && 0 <= i2@362@04 && i1@361@04 < V@15@04 && 0 <= i1@361@04)]
(assert (not
  (and
    (and
      (and
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@358@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@361@04))
            ($FVF.lookup_option$array$ (as sm@358@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@362@04)))
          (< i2@362@04 V@15@04))
        (<= 0 i2@362@04))
      (< i1@361@04 V@15@04))
    (<= 0 i1@361@04))))
(pop) ; 14
(pop) ; 13
; Joined path conditions
(assert (implies
  (and
    (and
      (and
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@358@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@361@04))
            ($FVF.lookup_option$array$ (as sm@358@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@362@04)))
          (< i2@362@04 V@15@04))
        (<= 0 i2@362@04))
      (< i1@361@04 V@15@04))
    (<= 0 i1@361@04))
  (and
    (=
      ($FVF.lookup_option$array$ (as sm@358@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@361@04))
      ($FVF.lookup_option$array$ (as sm@358@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@362@04)))
    (< i2@362@04 V@15@04)
    (<= 0 i2@362@04)
    (< i1@361@04 V@15@04)
    (<= 0 i1@361@04))))
; Joined path conditions
(pop) ; 12
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i2@362@04 Int)) (!
  (and
    (implies
      (<= 0 i1@361@04)
      (and
        (<= 0 i1@361@04)
        (implies
          (< i1@361@04 V@15@04)
          (and
            (< i1@361@04 V@15@04)
            (implies
              (<= 0 i2@362@04)
              (and
                (<= 0 i2@362@04)
                (implies
                  (< i2@362@04 V@15@04)
                  (and
                    (< i2@362@04 V@15@04)
                    (< i1@361@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
                    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@358@04  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@361@04)) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@361@04))
                    (< i2@362@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
                    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@358@04  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@362@04)) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@362@04))))))))))
    (implies
      (and
        (and
          (and
            (and
              (=
                ($FVF.lookup_option$array$ (as sm@358@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@361@04))
                ($FVF.lookup_option$array$ (as sm@358@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@362@04)))
              (< i2@362@04 V@15@04))
            (<= 0 i2@362@04))
          (< i1@361@04 V@15@04))
        (<= 0 i1@361@04))
      (and
        (=
          ($FVF.lookup_option$array$ (as sm@358@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@361@04))
          ($FVF.lookup_option$array$ (as sm@358@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@362@04)))
        (< i2@362@04 V@15@04)
        (<= 0 i2@362@04)
        (< i1@361@04 V@15@04)
        (<= 0 i1@361@04))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@362@04))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 11
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@361@04 Int)) (!
  (forall ((i2@362@04 Int)) (!
    (and
      (implies
        (<= 0 i1@361@04)
        (and
          (<= 0 i1@361@04)
          (implies
            (< i1@361@04 V@15@04)
            (and
              (< i1@361@04 V@15@04)
              (implies
                (<= 0 i2@362@04)
                (and
                  (<= 0 i2@362@04)
                  (implies
                    (< i2@362@04 V@15@04)
                    (and
                      (< i2@362@04 V@15@04)
                      (< i1@361@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
                      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@358@04  $FVF<option<array>>) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@361@04)) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@361@04))
                      (< i2@362@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
                      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@358@04  $FVF<option<array>>) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@362@04)) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@362@04))))))))))
      (implies
        (and
          (and
            (and
              (and
                (=
                  ($FVF.lookup_option$array$ (as sm@358@04  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@361@04))
                  ($FVF.lookup_option$array$ (as sm@358@04  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@362@04)))
                (< i2@362@04 V@15@04))
              (<= 0 i2@362@04))
            (< i1@361@04 V@15@04))
          (<= 0 i1@361@04))
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@358@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@361@04))
            ($FVF.lookup_option$array$ (as sm@358@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@362@04)))
          (< i2@362@04 V@15@04)
          (<= 0 i2@362@04)
          (< i1@361@04 V@15@04)
          (<= 0 i1@361@04))))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@362@04))
    :qid |prog.l<no position>-aux|))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@361@04))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(assert (forall ((i1@361@04 Int)) (!
  (forall ((i2@362@04 Int)) (!
    (implies
      (and
        (and
          (and
            (and
              (=
                ($FVF.lookup_option$array$ (as sm@358@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@361@04))
                ($FVF.lookup_option$array$ (as sm@358@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@362@04)))
              (< i2@362@04 V@15@04))
            (<= 0 i2@362@04))
          (< i1@361@04 V@15@04))
        (<= 0 i1@361@04))
      (= i1@361@04 i2@362@04))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@362@04))
    :qid |prog.l<no position>|))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@361@04))
  :qid |prog.l<no position>|)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04)))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04)))))))))))))
(declare-const i1@363@04 Int)
(declare-const j@364@04 Int)
(push) ; 11
; [eval] 0 <= i1 && i1 < V && (0 <= j && j < V)
; [eval] 0 <= i1
(push) ; 12
; [then-branch: 201 | 0 <= i1@363@04 | live]
; [else-branch: 201 | !(0 <= i1@363@04) | live]
(push) ; 13
; [then-branch: 201 | 0 <= i1@363@04]
(assert (<= 0 i1@363@04))
; [eval] i1 < V
(push) ; 14
; [then-branch: 202 | i1@363@04 < V@15@04 | live]
; [else-branch: 202 | !(i1@363@04 < V@15@04) | live]
(push) ; 15
; [then-branch: 202 | i1@363@04 < V@15@04]
(assert (< i1@363@04 V@15@04))
; [eval] 0 <= j
(push) ; 16
; [then-branch: 203 | 0 <= j@364@04 | live]
; [else-branch: 203 | !(0 <= j@364@04) | live]
(push) ; 17
; [then-branch: 203 | 0 <= j@364@04]
(assert (<= 0 j@364@04))
; [eval] j < V
(pop) ; 17
(push) ; 17
; [else-branch: 203 | !(0 <= j@364@04)]
(assert (not (<= 0 j@364@04)))
(pop) ; 17
(pop) ; 16
; Joined path conditions
; Joined path conditions
(pop) ; 15
(push) ; 15
; [else-branch: 202 | !(i1@363@04 < V@15@04)]
(assert (not (< i1@363@04 V@15@04)))
(pop) ; 15
(pop) ; 14
; Joined path conditions
; Joined path conditions
(pop) ; 13
(push) ; 13
; [else-branch: 201 | !(0 <= i1@363@04)]
(assert (not (<= 0 i1@363@04)))
(pop) ; 13
(pop) ; 12
; Joined path conditions
; Joined path conditions
(assert (and
  (and (and (< j@364@04 V@15@04) (<= 0 j@364@04)) (< i1@363@04 V@15@04))
  (<= 0 i1@363@04)))
; [eval] aloc(opt_get1(aloc(opt_get1(G), i1).option$array$), j)
; [eval] opt_get1(aloc(opt_get1(G), i1).option$array$)
; [eval] aloc(opt_get1(G), i1)
; [eval] opt_get1(G)
(push) ; 12
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 12
; Joined path conditions
(push) ; 12
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 13
(assert (not (< i1@363@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))))
(check-sat)
; unsat
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               555382
;  :arith-add-rows          253569
;  :arith-assert-diseq      4895
;  :arith-assert-lower      94902
;  :arith-assert-upper      80118
;  :arith-bound-prop        14379
;  :arith-conflicts         526
;  :arith-eq-adapter        72409
;  :arith-fixed-eqs         79146
;  :arith-offset-eqs        47145
;  :arith-pivots            50835
;  :conflicts               1820
;  :datatype-accessor-ax    260
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               29149
;  :del-clause              1748385
;  :final-checks            5
;  :max-generation          12
;  :max-memory              83.11
;  :memory                  77.22
;  :minimized-lits          228
;  :mk-bool-var             1649987
;  :mk-clause               1749886
;  :num-allocs              5268377
;  :num-checks              354
;  :propagations            381843
;  :quant-instantiations    608776
;  :restarts                2
;  :rlimit-count            18590298)
(assert (< i1@363@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(pop) ; 12
; Joined path conditions
(assert (< i1@363@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@358@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@363@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@363@04)))
(push) ; 12
(assert (not (ite
  (and
    (<
      (inv@357@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@363@04))
      V@15@04)
    (<=
      0
      (inv@357@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@363@04))))
  (< $Perm.No $k@356@04)
  false)))
(check-sat)
; unsat
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               555513
;  :arith-add-rows          253626
;  :arith-assert-diseq      4895
;  :arith-assert-lower      94920
;  :arith-assert-upper      80133
;  :arith-bound-prop        14390
;  :arith-conflicts         527
;  :arith-eq-adapter        72423
;  :arith-fixed-eqs         79160
;  :arith-offset-eqs        47166
;  :arith-pivots            50850
;  :conflicts               1821
;  :datatype-accessor-ax    260
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               29149
;  :del-clause              1748385
;  :final-checks            5
;  :max-generation          12
;  :max-memory              83.11
;  :memory                  77.25
;  :minimized-lits          228
;  :mk-bool-var             1650487
;  :mk-clause               1750211
;  :num-allocs              5270551
;  :num-checks              355
;  :propagations            381851
;  :quant-instantiations    608969
;  :restarts                2
;  :rlimit-count            18599568)
(push) ; 12
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 13
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@358@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@363@04))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               555513
;  :arith-add-rows          253626
;  :arith-assert-diseq      4895
;  :arith-assert-lower      94920
;  :arith-assert-upper      80133
;  :arith-bound-prop        14390
;  :arith-conflicts         527
;  :arith-eq-adapter        72423
;  :arith-fixed-eqs         79160
;  :arith-offset-eqs        47166
;  :arith-pivots            50850
;  :conflicts               1822
;  :datatype-accessor-ax    260
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               29149
;  :del-clause              1748385
;  :final-checks            5
;  :max-generation          12
;  :max-memory              83.11
;  :memory                  77.25
;  :minimized-lits          228
;  :mk-bool-var             1650487
;  :mk-clause               1750211
;  :num-allocs              5270641
;  :num-checks              356
;  :propagations            381851
;  :quant-instantiations    608969
;  :restarts                2
;  :rlimit-count            18599663)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@358@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@363@04))
    (as None<option<array>>  option<array>))))
(pop) ; 12
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@358@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@363@04))
    (as None<option<array>>  option<array>))))
(push) ; 12
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 13
(assert (not (<
  j@364@04
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@358@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@363@04)))))))
(check-sat)
; unsat
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               555517
;  :arith-add-rows          253629
;  :arith-assert-diseq      4895
;  :arith-assert-lower      94922
;  :arith-assert-upper      80133
;  :arith-bound-prop        14392
;  :arith-conflicts         527
;  :arith-eq-adapter        72424
;  :arith-fixed-eqs         79160
;  :arith-offset-eqs        47166
;  :arith-pivots            50852
;  :conflicts               1823
;  :datatype-accessor-ax    260
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               29149
;  :del-clause              1748391
;  :final-checks            5
;  :max-generation          12
;  :max-memory              83.11
;  :memory                  77.25
;  :minimized-lits          228
;  :mk-bool-var             1650498
;  :mk-clause               1750217
;  :num-allocs              5270843
;  :num-checks              357
;  :propagations            381851
;  :quant-instantiations    608976
;  :restarts                2
;  :rlimit-count            18600085)
(assert (<
  j@364@04
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@358@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@363@04))))))
(pop) ; 12
; Joined path conditions
(assert (<
  j@364@04
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@358@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@363@04))))))
(pop) ; 11
(declare-fun inv@365@04 ($Ref) Int)
(declare-fun inv@366@04 ($Ref) Int)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(assert (forall ((i1@363@04 Int) (j@364@04 Int)) (!
  (and
    (< i1@363@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@358@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@363@04)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@363@04))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@358@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@363@04))
        (as None<option<array>>  option<array>)))
    (<
      j@364@04
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@358@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@363@04))))))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@358@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@363@04))) j@364@04))
  :qid |int-aux|)))
; Check receiver injectivity
(push) ; 11
(assert (not (forall ((i11@363@04 Int) (j1@364@04 Int) (i12@363@04 Int) (j2@364@04 Int)) (!
  (implies
    (and
      (and
        (and (and (< j1@364@04 V@15@04) (<= 0 j1@364@04)) (< i11@363@04 V@15@04))
        (<= 0 i11@363@04))
      (and
        (and (and (< j2@364@04 V@15@04) (<= 0 j2@364@04)) (< i12@363@04 V@15@04))
        (<= 0 i12@363@04))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@358@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i11@363@04))) j1@364@04)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@358@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i12@363@04))) j2@364@04)))
    (and (= i11@363@04 i12@363@04) (= j1@364@04 j2@364@04)))
  
  :qid |int-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 11
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               555659
;  :arith-add-rows          253683
;  :arith-assert-diseq      4895
;  :arith-assert-lower      94943
;  :arith-assert-upper      80136
;  :arith-bound-prop        14394
;  :arith-conflicts         527
;  :arith-eq-adapter        72456
;  :arith-fixed-eqs         79162
;  :arith-offset-eqs        47166
;  :arith-pivots            50876
;  :conflicts               1824
;  :datatype-accessor-ax    260
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               29149
;  :del-clause              1749117
;  :final-checks            5
;  :max-generation          12
;  :max-memory              83.11
;  :memory                  77.22
;  :minimized-lits          228
;  :mk-bool-var             1651239
;  :mk-clause               1750618
;  :num-allocs              5274756
;  :num-checks              358
;  :propagations            381881
;  :quant-instantiations    609331
;  :restarts                2
;  :rlimit-count            18615841
;  :time                    0.01)
; Definitional axioms for inverse functions
(assert (forall ((i1@363@04 Int) (j@364@04 Int)) (!
  (implies
    (and
      (and (and (< j@364@04 V@15@04) (<= 0 j@364@04)) (< i1@363@04 V@15@04))
      (<= 0 i1@363@04))
    (and
      (=
        (inv@365@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@358@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@363@04))) j@364@04))
        i1@363@04)
      (=
        (inv@366@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@358@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@363@04))) j@364@04))
        j@364@04)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@358@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@363@04))) j@364@04))
  )))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@366@04 r) V@15@04) (<= 0 (inv@366@04 r)))
        (< (inv@365@04 r) V@15@04))
      (<= 0 (inv@365@04 r)))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@358@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) (inv@365@04 r)))) (inv@366@04 r))
      r))
  :pattern ((inv@365@04 r))
  :pattern ((inv@366@04 r))
  :qid |int-fctOfInv|)))
; Permissions are non-negative
; Field permissions are at most one
; Permission implies non-null receiver
(assert (forall ((i1@363@04 Int) (j@364@04 Int)) (!
  (implies
    (and
      (and (and (< j@364@04 V@15@04) (<= 0 j@364@04)) (< i1@363@04 V@15@04))
      (<= 0 i1@363@04))
    (not
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@358@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@363@04))) j@364@04)
        $Ref.null)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@358@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@363@04))) j@364@04))
  :qid |int-permImpliesNonNull|)))
(declare-const sm@367@04 $FVF<Int>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@366@04 r) V@15@04) (<= 0 (inv@366@04 r)))
        (< (inv@365@04 r) V@15@04))
      (<= 0 (inv@365@04 r)))
    (=
      ($FVF.lookup_int (as sm@367@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@367@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))))))) r))
  :qid |qp.fvfValDef263|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))))))) r) r)
  :pattern (($FVF.lookup_int (as sm@367@04  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef264|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@366@04 r) V@15@04) (<= 0 (inv@366@04 r)))
        (< (inv@365@04 r) V@15@04))
      (<= 0 (inv@365@04 r)))
    ($FVF.loc_int ($FVF.lookup_int (as sm@367@04  $FVF<Int>) r) r))
  :pattern ((inv@365@04 r) (inv@366@04 r))
  )))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04)))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04)))))))))))
  $Snap.unit))
; [eval] P != (None(): option[array])
; [eval] (None(): option[array])
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04)))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04)))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))))))))
  $Snap.unit))
; [eval] alen(opt_get1(P)) == V
; [eval] alen(opt_get1(P))
; [eval] opt_get1(P)
(push) ; 11
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 11
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04)))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))))))))))))
(declare-const i1@368@04 Int)
(push) ; 11
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 12
; [then-branch: 204 | 0 <= i1@368@04 | live]
; [else-branch: 204 | !(0 <= i1@368@04) | live]
(push) ; 13
; [then-branch: 204 | 0 <= i1@368@04]
(assert (<= 0 i1@368@04))
; [eval] i1 < V
(pop) ; 13
(push) ; 13
; [else-branch: 204 | !(0 <= i1@368@04)]
(assert (not (<= 0 i1@368@04)))
(pop) ; 13
(pop) ; 12
; Joined path conditions
; Joined path conditions
(assert (and (< i1@368@04 V@15@04) (<= 0 i1@368@04)))
; [eval] aloc(opt_get1(P), i1)
; [eval] opt_get1(P)
(push) ; 12
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 12
; Joined path conditions
(push) ; 12
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 13
(assert (not (< i1@368@04 (alen<Int> (opt_get1 $Snap.unit P@14@04)))))
(check-sat)
; unsat
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               555676
;  :arith-add-rows          253684
;  :arith-assert-diseq      4895
;  :arith-assert-lower      94945
;  :arith-assert-upper      80136
;  :arith-bound-prop        14394
;  :arith-conflicts         527
;  :arith-eq-adapter        72456
;  :arith-fixed-eqs         79162
;  :arith-offset-eqs        47166
;  :arith-pivots            50876
;  :conflicts               1824
;  :datatype-accessor-ax    263
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               29149
;  :del-clause              1749117
;  :final-checks            5
;  :max-generation          12
;  :max-memory              83.11
;  :memory                  77.22
;  :minimized-lits          228
;  :mk-bool-var             1651252
;  :mk-clause               1750618
;  :num-allocs              5276064
;  :num-checks              359
;  :propagations            381881
;  :quant-instantiations    609331
;  :restarts                2
;  :rlimit-count            18619435)
(assert (< i1@368@04 (alen<Int> (opt_get1 $Snap.unit P@14@04))))
(pop) ; 12
; Joined path conditions
(assert (< i1@368@04 (alen<Int> (opt_get1 $Snap.unit P@14@04))))
(pop) ; 11
(declare-fun inv@369@04 ($Ref) Int)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(assert (forall ((i1@368@04 Int)) (!
  (< i1@368@04 (alen<Int> (opt_get1 $Snap.unit P@14@04)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i1@368@04))
  :qid |int-aux|)))
; Check receiver injectivity
(push) ; 11
(assert (not (forall ((i11@368@04 Int) (i12@368@04 Int)) (!
  (implies
    (and
      (and (< i11@368@04 V@15@04) (<= 0 i11@368@04))
      (and (< i12@368@04 V@15@04) (<= 0 i12@368@04))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i11@368@04)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i12@368@04)))
    (= i11@368@04 i12@368@04))
  
  :qid |int-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               555716
;  :arith-add-rows          253690
;  :arith-assert-diseq      4896
;  :arith-assert-lower      94949
;  :arith-assert-upper      80136
;  :arith-bound-prop        14394
;  :arith-conflicts         527
;  :arith-eq-adapter        72457
;  :arith-fixed-eqs         79162
;  :arith-offset-eqs        47166
;  :arith-pivots            50878
;  :conflicts               1825
;  :datatype-accessor-ax    263
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               29149
;  :del-clause              1749123
;  :final-checks            5
;  :max-generation          12
;  :max-memory              83.11
;  :memory                  77.22
;  :minimized-lits          228
;  :mk-bool-var             1651303
;  :mk-clause               1750624
;  :num-allocs              5276758
;  :num-checks              360
;  :propagations            381881
;  :quant-instantiations    609392
;  :restarts                2
;  :rlimit-count            18621304
;  :time                    0.00)
; Definitional axioms for inverse functions
(assert (forall ((i1@368@04 Int)) (!
  (implies
    (and (< i1@368@04 V@15@04) (<= 0 i1@368@04))
    (=
      (inv@369@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i1@368@04))
      i1@368@04))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i1@368@04))
  )))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@369@04 r) V@15@04) (<= 0 (inv@369@04 r)))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) (inv@369@04 r))
      r))
  :pattern ((inv@369@04 r))
  :qid |int-fctOfInv|)))
; Permissions are non-negative
; Field permissions are at most one
; Permission implies non-null receiver
(assert (forall ((i1@368@04 Int)) (!
  (implies
    (and (< i1@368@04 V@15@04) (<= 0 i1@368@04))
    (not
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i1@368@04)
        $Ref.null)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i1@368@04))
  :qid |int-permImpliesNonNull|)))
(declare-const sm@370@04 $FVF<Int>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@369@04 r) V@15@04) (<= 0 (inv@369@04 r)))
    (=
      ($FVF.lookup_int (as sm@370@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04)))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@370@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04)))))))))))))) r))
  :qid |qp.fvfValDef265|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@366@04 r) V@15@04) (<= 0 (inv@366@04 r)))
        (< (inv@365@04 r) V@15@04))
      (<= 0 (inv@365@04 r)))
    (=
      ($FVF.lookup_int (as sm@370@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@370@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))))))) r))
  :qid |qp.fvfValDef266|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04)))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@370@04  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef267|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@369@04 r) V@15@04) (<= 0 (inv@369@04 r)))
    ($FVF.loc_int ($FVF.lookup_int (as sm@370@04  $FVF<Int>) r) r))
  :pattern ((inv@369@04 r))
  )))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04)))))))))))))
  $Snap.unit))
; [eval] valid_graph_vertices(this, P, V)
(push) ; 11
; [eval] this != null
; [eval] p != (None(): option[array])
; [eval] (None(): option[array])
; [eval] alen(opt_get1(p)) == V
; [eval] alen(opt_get1(p))
; [eval] opt_get1(p)
(push) ; 12
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 12
; Joined path conditions
(declare-const i1@371@04 Int)
(push) ; 12
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 13
; [then-branch: 205 | 0 <= i1@371@04 | live]
; [else-branch: 205 | !(0 <= i1@371@04) | live]
(push) ; 14
; [then-branch: 205 | 0 <= i1@371@04]
(assert (<= 0 i1@371@04))
; [eval] i1 < V
(pop) ; 14
(push) ; 14
; [else-branch: 205 | !(0 <= i1@371@04)]
(assert (not (<= 0 i1@371@04)))
(pop) ; 14
(pop) ; 13
; Joined path conditions
; Joined path conditions
(assert (and (< i1@371@04 V@15@04) (<= 0 i1@371@04)))
(declare-const $k@372@04 $Perm)
(assert ($Perm.isReadVar $k@372@04 $Perm.Write))
; [eval] aloc(opt_get1(p), i1)
; [eval] opt_get1(p)
(push) ; 13
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 13
; Joined path conditions
(push) ; 13
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 14
(assert (not (< i1@371@04 (alen<Int> (opt_get1 $Snap.unit P@14@04)))))
(check-sat)
; unsat
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               555717
;  :arith-add-rows          253691
;  :arith-assert-diseq      4897
;  :arith-assert-lower      94953
;  :arith-assert-upper      80137
;  :arith-bound-prop        14394
;  :arith-conflicts         527
;  :arith-eq-adapter        72458
;  :arith-fixed-eqs         79162
;  :arith-offset-eqs        47166
;  :arith-pivots            50878
;  :conflicts               1825
;  :datatype-accessor-ax    263
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               29149
;  :del-clause              1749123
;  :final-checks            5
;  :max-generation          12
;  :max-memory              83.11
;  :memory                  77.22
;  :minimized-lits          228
;  :mk-bool-var             1651317
;  :mk-clause               1750626
;  :num-allocs              5277984
;  :num-checks              361
;  :propagations            381882
;  :quant-instantiations    609392
;  :restarts                2
;  :rlimit-count            18624403)
(assert (< i1@371@04 (alen<Int> (opt_get1 $Snap.unit P@14@04))))
(pop) ; 13
; Joined path conditions
(assert (< i1@371@04 (alen<Int> (opt_get1 $Snap.unit P@14@04))))
(pop) ; 12
(declare-fun inv@373@04 ($Ref) Int)
; Nested auxiliary terms: globals
(assert ($Perm.isReadVar $k@372@04 $Perm.Write))
; Nested auxiliary terms: non-globals
(assert (forall ((i1@371@04 Int)) (!
  (< i1@371@04 (alen<Int> (opt_get1 $Snap.unit P@14@04)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i1@371@04))
  :qid |int-aux|)))
(push) ; 12
(assert (not (forall ((i1@371@04 Int)) (!
  (implies
    (and (< i1@371@04 V@15@04) (<= 0 i1@371@04))
    (or (= $k@372@04 $Perm.No) (< $Perm.No $k@372@04)))
  
  ))))
(check-sat)
; unsat
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               555717
;  :arith-add-rows          253692
;  :arith-assert-diseq      4898
;  :arith-assert-lower      94955
;  :arith-assert-upper      80138
;  :arith-bound-prop        14394
;  :arith-conflicts         527
;  :arith-eq-adapter        72459
;  :arith-fixed-eqs         79162
;  :arith-offset-eqs        47166
;  :arith-pivots            50878
;  :conflicts               1826
;  :datatype-accessor-ax    263
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               29149
;  :del-clause              1749125
;  :final-checks            5
;  :max-generation          12
;  :max-memory              83.11
;  :memory                  77.22
;  :minimized-lits          228
;  :mk-bool-var             1651324
;  :mk-clause               1750628
;  :num-allocs              5278414
;  :num-checks              362
;  :propagations            381883
;  :quant-instantiations    609392
;  :restarts                2
;  :rlimit-count            18624950)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 12
(assert (not (forall ((i11@371@04 Int) (i12@371@04 Int)) (!
  (implies
    (and
      (and
        (and
          (and (< i11@371@04 V@15@04) (<= 0 i11@371@04))
          ($FVF.loc_int ($FVF.lookup_int (as sm@370@04  $FVF<Int>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit P@14@04) i11@371@04)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit P@14@04) i11@371@04)))
        (< $Perm.No $k@372@04))
      (and
        (and
          (and (< i12@371@04 V@15@04) (<= 0 i12@371@04))
          ($FVF.loc_int ($FVF.lookup_int (as sm@370@04  $FVF<Int>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit P@14@04) i12@371@04)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit P@14@04) i12@371@04)))
        (< $Perm.No $k@372@04))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i11@371@04)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i12@371@04)))
    (= i11@371@04 i12@371@04))
  
  :qid |int-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               555760
;  :arith-add-rows          253703
;  :arith-assert-diseq      4899
;  :arith-assert-lower      94959
;  :arith-assert-upper      80138
;  :arith-bound-prop        14394
;  :arith-conflicts         527
;  :arith-eq-adapter        72460
;  :arith-fixed-eqs         79162
;  :arith-offset-eqs        47166
;  :arith-pivots            50882
;  :conflicts               1827
;  :datatype-accessor-ax    263
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               29149
;  :del-clause              1749136
;  :final-checks            5
;  :max-generation          12
;  :max-memory              83.11
;  :memory                  77.22
;  :minimized-lits          228
;  :mk-bool-var             1651388
;  :mk-clause               1750639
;  :num-allocs              5279040
;  :num-checks              363
;  :propagations            381885
;  :quant-instantiations    609460
;  :restarts                2
;  :rlimit-count            18627043)
; Definitional axioms for inverse functions
(assert (forall ((i1@371@04 Int)) (!
  (implies
    (and (and (< i1@371@04 V@15@04) (<= 0 i1@371@04)) (< $Perm.No $k@372@04))
    (=
      (inv@373@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i1@371@04))
      i1@371@04))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i1@371@04))
  :qid |int-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and (< (inv@373@04 r) V@15@04) (<= 0 (inv@373@04 r)))
      (< $Perm.No $k@372@04))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) (inv@373@04 r))
      r))
  :pattern ((inv@373@04 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@373@04 r) V@15@04) (<= 0 (inv@373@04 r)))
    ($FVF.loc_int ($FVF.lookup_int (as sm@370@04  $FVF<Int>) r) r))
  :pattern ((inv@373@04 r))
  )))
; Precomputing data for removing quantified permissions
(define-fun pTaken@374@04 ((r $Ref)) $Perm
  (ite
    (and (< (inv@373@04 r) V@15@04) (<= 0 (inv@373@04 r)))
    ($Perm.min
      (ite
        (and (< (inv@369@04 r) V@15@04) (<= 0 (inv@369@04 r)))
        $Perm.Write
        $Perm.No)
      $k@372@04)
    $Perm.No))
(define-fun pTaken@375@04 ((r $Ref)) $Perm
  (ite
    (and (< (inv@373@04 r) V@15@04) (<= 0 (inv@373@04 r)))
    ($Perm.min
      (ite
        (and
          (and
            (and (< (inv@366@04 r) V@15@04) (<= 0 (inv@366@04 r)))
            (< (inv@365@04 r) V@15@04))
          (<= 0 (inv@365@04 r)))
        $Perm.Write
        $Perm.No)
      (- $k@372@04 (pTaken@374@04 r)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Constrain original permissions $k@372@04
(assert (forall ((r $Ref)) (!
  (implies
    (not
      (=
        (ite
          (and (< (inv@369@04 r) V@15@04) (<= 0 (inv@369@04 r)))
          $Perm.Write
          $Perm.No)
        $Perm.No))
    (ite
      (and (< (inv@369@04 r) V@15@04) (<= 0 (inv@369@04 r)))
      (<
        (ite
          (and (< (inv@373@04 r) V@15@04) (<= 0 (inv@373@04 r)))
          $k@372@04
          $Perm.No)
        $Perm.Write)
      (<
        (ite
          (and (< (inv@373@04 r) V@15@04) (<= 0 (inv@373@04 r)))
          $k@372@04
          $Perm.No)
        $Perm.No)))
  :pattern ((inv@369@04 r))
  :pattern ((inv@373@04 r))
  :qid |qp.srp268|)))
; Intermediate check if already taken enough permissions
(set-option :timeout 500)
(push) ; 12
(assert (not (forall ((r $Ref)) (!
  (implies
    (and (< (inv@373@04 r) V@15@04) (<= 0 (inv@373@04 r)))
    (= (- $k@372@04 (pTaken@374@04 r)) $Perm.No))
  
  ))))
(check-sat)
; unsat
(pop) ; 12
; 0.02s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               556594
;  :arith-add-rows          254618
;  :arith-assert-diseq      4924
;  :arith-assert-lower      95114
;  :arith-assert-upper      80254
;  :arith-bound-prop        14409
;  :arith-conflicts         530
;  :arith-eq-adapter        72573
;  :arith-fixed-eqs         79293
;  :arith-offset-eqs        47203
;  :arith-pivots            50957
;  :conflicts               1848
;  :datatype-accessor-ax    263
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               29405
;  :del-clause              1758062
;  :final-checks            5
;  :max-generation          12
;  :max-memory              83.11
;  :memory                  77.27
;  :minimized-lits          229
;  :mk-bool-var             1658035
;  :mk-clause               1759565
;  :num-allocs              5298088
;  :num-checks              365
;  :propagations            382977
;  :quant-instantiations    611119
;  :restarts                2
;  :rlimit-count            18714501
;  :time                    0.02)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@376@04 $FVF<Int>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (iff
    (Set_in r ($FVF.domain_int (as sm@376@04  $FVF<Int>)))
    (and
      (and (< (inv@373@04 r) V@15@04) (<= 0 (inv@373@04 r)))
      (< $Perm.No $k@372@04)))
  :pattern ((Set_in r ($FVF.domain_int (as sm@376@04  $FVF<Int>))))
  :qid |qp.fvfDomDef272|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@373@04 r) V@15@04) (<= 0 (inv@373@04 r)))
        (< $Perm.No $k@372@04))
      (and (< (inv@369@04 r) V@15@04) (<= 0 (inv@369@04 r))))
    (=
      ($FVF.lookup_int (as sm@376@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04)))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@376@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04)))))))))))))) r))
  :qid |qp.fvfValDef269|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@373@04 r) V@15@04) (<= 0 (inv@373@04 r)))
        (< $Perm.No $k@372@04))
      (and
        (and
          (and (< (inv@366@04 r) V@15@04) (<= 0 (inv@366@04 r)))
          (< (inv@365@04 r) V@15@04))
        (<= 0 (inv@365@04 r))))
    (=
      ($FVF.lookup_int (as sm@376@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@376@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))))))) r))
  :qid |qp.fvfValDef270|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04)))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@376@04  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef271|)))
(pop) ; 11
; Joined path conditions
(assert ($Perm.isReadVar $k@372@04 $Perm.Write))
(assert (forall ((i1@371@04 Int)) (!
  (implies
    (and (and (< i1@371@04 V@15@04) (<= 0 i1@371@04)) (< $Perm.No $k@372@04))
    (=
      (inv@373@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i1@371@04))
      i1@371@04))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i1@371@04))
  :qid |int-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and (< (inv@373@04 r) V@15@04) (<= 0 (inv@373@04 r)))
      (< $Perm.No $k@372@04))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) (inv@373@04 r))
      r))
  :pattern ((inv@373@04 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (iff
    (Set_in r ($FVF.domain_int (as sm@376@04  $FVF<Int>)))
    (and
      (and (< (inv@373@04 r) V@15@04) (<= 0 (inv@373@04 r)))
      (< $Perm.No $k@372@04)))
  :pattern ((Set_in r ($FVF.domain_int (as sm@376@04  $FVF<Int>))))
  :qid |qp.fvfDomDef272|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@373@04 r) V@15@04) (<= 0 (inv@373@04 r)))
        (< $Perm.No $k@372@04))
      (and (< (inv@369@04 r) V@15@04) (<= 0 (inv@369@04 r))))
    (=
      ($FVF.lookup_int (as sm@376@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04)))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@376@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04)))))))))))))) r))
  :qid |qp.fvfValDef269|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@373@04 r) V@15@04) (<= 0 (inv@373@04 r)))
        (< $Perm.No $k@372@04))
      (and
        (and
          (and (< (inv@366@04 r) V@15@04) (<= 0 (inv@366@04 r)))
          (< (inv@365@04 r) V@15@04))
        (<= 0 (inv@365@04 r))))
    (=
      ($FVF.lookup_int (as sm@376@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@376@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))))))) r))
  :qid |qp.fvfValDef270|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04)))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@376@04  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef271|)))
(assert (and
  (forall ((i1@371@04 Int)) (!
    (< i1@371@04 (alen<Int> (opt_get1 $Snap.unit P@14@04)))
    :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i1@371@04))
    :qid |int-aux|))
  (forall ((r $Ref)) (!
    (implies
      (and (< (inv@373@04 r) V@15@04) (<= 0 (inv@373@04 r)))
      ($FVF.loc_int ($FVF.lookup_int (as sm@370@04  $FVF<Int>) r) r))
    :pattern ((inv@373@04 r))
    ))
  (forall ((r $Ref)) (!
    (implies
      (not
        (=
          (ite
            (and (< (inv@369@04 r) V@15@04) (<= 0 (inv@369@04 r)))
            $Perm.Write
            $Perm.No)
          $Perm.No))
      (ite
        (and (< (inv@369@04 r) V@15@04) (<= 0 (inv@369@04 r)))
        (<
          (ite
            (and (< (inv@373@04 r) V@15@04) (<= 0 (inv@373@04 r)))
            $k@372@04
            $Perm.No)
          $Perm.Write)
        (<
          (ite
            (and (< (inv@373@04 r) V@15@04) (<= 0 (inv@373@04 r)))
            $k@372@04
            $Perm.No)
          $Perm.No)))
    :pattern ((inv@369@04 r))
    :pattern ((inv@373@04 r))
    :qid |qp.srp268|))))
(assert (valid_graph_vertices ($Snap.combine
  $Snap.unit
  ($Snap.combine
    $Snap.unit
    ($Snap.combine
      $Snap.unit
      ($SortWrappers.$FVF<Int>To$Snap (as sm@376@04  $FVF<Int>))))) this@9@04 P@14@04 V@15@04))
; Loop head block: Check well-definedness of edge conditions
(push) ; 11
; [eval] v != s
(pop) ; 11
(push) ; 11
; [eval] !(v != s)
; [eval] v != s
(pop) ; 11
(pop) ; 10
(push) ; 10
; Loop head block: Establish invariant
; [eval] exc == excBeforeLoop1
; [eval] 0 <= v
; [eval] v < V
; [eval] G != (None(): option[array])
; [eval] (None(): option[array])
; [eval] alen(opt_get1(G)) == V
; [eval] alen(opt_get1(G))
; [eval] opt_get1(G)
(push) ; 11
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 11
; Joined path conditions
(declare-const i1@377@04 Int)
(push) ; 11
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 12
; [then-branch: 206 | 0 <= i1@377@04 | live]
; [else-branch: 206 | !(0 <= i1@377@04) | live]
(push) ; 13
; [then-branch: 206 | 0 <= i1@377@04]
(assert (<= 0 i1@377@04))
; [eval] i1 < V
(pop) ; 13
(push) ; 13
; [else-branch: 206 | !(0 <= i1@377@04)]
(assert (not (<= 0 i1@377@04)))
(pop) ; 13
(pop) ; 12
; Joined path conditions
; Joined path conditions
(assert (and (< i1@377@04 V@15@04) (<= 0 i1@377@04)))
(declare-const $k@378@04 $Perm)
(assert ($Perm.isReadVar $k@378@04 $Perm.Write))
; [eval] aloc(opt_get1(G), i1)
; [eval] opt_get1(G)
(push) ; 12
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 12
; Joined path conditions
(push) ; 12
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 13
(assert (not (< i1@377@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))))
(check-sat)
; unsat
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               556615
;  :arith-add-rows          254622
;  :arith-assert-diseq      4926
;  :arith-assert-lower      95120
;  :arith-assert-upper      80256
;  :arith-bound-prop        14409
;  :arith-conflicts         530
;  :arith-eq-adapter        72575
;  :arith-fixed-eqs         79293
;  :arith-offset-eqs        47203
;  :arith-pivots            50960
;  :conflicts               1848
;  :datatype-accessor-ax    266
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               29405
;  :del-clause              1758197
;  :final-checks            5
;  :max-generation          12
;  :max-memory              83.11
;  :memory                  77.27
;  :minimized-lits          229
;  :mk-bool-var             1658208
;  :mk-clause               1759698
;  :num-allocs              5300345
;  :num-checks              366
;  :propagations            382990
;  :quant-instantiations    611148
;  :restarts                2
;  :rlimit-count            18721044)
(assert (< i1@377@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(pop) ; 12
; Joined path conditions
(assert (< i1@377@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(pop) ; 11
(declare-fun inv@379@04 ($Ref) Int)
; Nested auxiliary terms: globals
(assert ($Perm.isReadVar $k@378@04 $Perm.Write))
; Nested auxiliary terms: non-globals
(assert (forall ((i1@377@04 Int)) (!
  (< i1@377@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@377@04))
  :qid |option$array$-aux|)))
(push) ; 11
(assert (not (forall ((i1@377@04 Int)) (!
  (implies
    (and (< i1@377@04 V@15@04) (<= 0 i1@377@04))
    (or (= $k@378@04 $Perm.No) (< $Perm.No $k@378@04)))
  
  ))))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               556615
;  :arith-add-rows          254623
;  :arith-assert-diseq      4927
;  :arith-assert-lower      95122
;  :arith-assert-upper      80257
;  :arith-bound-prop        14409
;  :arith-conflicts         530
;  :arith-eq-adapter        72576
;  :arith-fixed-eqs         79293
;  :arith-offset-eqs        47203
;  :arith-pivots            50960
;  :conflicts               1849
;  :datatype-accessor-ax    266
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               29405
;  :del-clause              1758199
;  :final-checks            5
;  :max-generation          12
;  :max-memory              83.11
;  :memory                  77.26
;  :minimized-lits          229
;  :mk-bool-var             1658215
;  :mk-clause               1759700
;  :num-allocs              5300773
;  :num-checks              367
;  :propagations            382991
;  :quant-instantiations    611148
;  :restarts                2
;  :rlimit-count            18721590)
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 11
(assert (not (forall ((i11@377@04 Int) (i12@377@04 Int)) (!
  (implies
    (and
      (and
        (and
          (and (< i11@377@04 V@15@04) (<= 0 i11@377@04))
          ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@297@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i11@377@04)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i11@377@04)))
        (< $Perm.No $k@378@04))
      (and
        (and
          (and (< i12@377@04 V@15@04) (<= 0 i12@377@04))
          ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@297@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i12@377@04)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i12@377@04)))
        (< $Perm.No $k@378@04))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i11@377@04)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i12@377@04)))
    (= i11@377@04 i12@377@04))
  
  :qid |option$array$-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               556661
;  :arith-add-rows          254632
;  :arith-assert-diseq      4928
;  :arith-assert-lower      95126
;  :arith-assert-upper      80257
;  :arith-bound-prop        14409
;  :arith-conflicts         530
;  :arith-eq-adapter        72577
;  :arith-fixed-eqs         79293
;  :arith-offset-eqs        47203
;  :arith-pivots            50964
;  :conflicts               1850
;  :datatype-accessor-ax    266
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               29405
;  :del-clause              1758206
;  :final-checks            5
;  :max-generation          12
;  :max-memory              83.11
;  :memory                  77.26
;  :minimized-lits          229
;  :mk-bool-var             1658287
;  :mk-clause               1759707
;  :num-allocs              5301659
;  :num-checks              368
;  :propagations            382991
;  :quant-instantiations    611225
;  :restarts                2
;  :rlimit-count            18724443
;  :time                    0.00)
; Definitional axioms for inverse functions
(assert (forall ((i1@377@04 Int)) (!
  (implies
    (and (and (< i1@377@04 V@15@04) (<= 0 i1@377@04)) (< $Perm.No $k@378@04))
    (=
      (inv@379@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@377@04))
      i1@377@04))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@377@04))
  :qid |option$array$-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and (< (inv@379@04 r) V@15@04) (<= 0 (inv@379@04 r)))
      (< $Perm.No $k@378@04))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) (inv@379@04 r))
      r))
  :pattern ((inv@379@04 r))
  :qid |option$array$-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@379@04 r) V@15@04) (<= 0 (inv@379@04 r)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@297@04  $FVF<option<array>>) r) r))
  :pattern ((inv@379@04 r))
  )))
; Precomputing data for removing quantified permissions
(define-fun pTaken@380@04 ((r $Ref)) $Perm
  (ite
    (and (< (inv@379@04 r) V@15@04) (<= 0 (inv@379@04 r)))
    ($Perm.min
      (ite
        (and (< (inv@296@04 r) V@15@04) (<= 0 (inv@296@04 r)))
        $k@295@04
        $Perm.No)
      $k@378@04)
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Constrain original permissions $k@378@04
(assert (forall ((r $Ref)) (!
  (implies
    (not
      (=
        (ite
          (and (< (inv@296@04 r) V@15@04) (<= 0 (inv@296@04 r)))
          $k@295@04
          $Perm.No)
        $Perm.No))
    (ite
      (and (< (inv@296@04 r) V@15@04) (<= 0 (inv@296@04 r)))
      (<
        (ite
          (and (< (inv@379@04 r) V@15@04) (<= 0 (inv@379@04 r)))
          $k@378@04
          $Perm.No)
        $k@295@04)
      (<
        (ite
          (and (< (inv@379@04 r) V@15@04) (<= 0 (inv@379@04 r)))
          $k@378@04
          $Perm.No)
        $Perm.No)))
  :pattern ((inv@296@04 r))
  :pattern ((inv@379@04 r))
  :qid |qp.srp273|)))
; Intermediate check if already taken enough permissions
(set-option :timeout 500)
(push) ; 11
(assert (not (forall ((r $Ref)) (!
  (implies
    (and (< (inv@379@04 r) V@15@04) (<= 0 (inv@379@04 r)))
    (= (- $k@378@04 (pTaken@380@04 r)) $Perm.No))
  
  ))))
(check-sat)
; unsat
(pop) ; 11
; 0.03s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               557850
;  :arith-add-rows          255924
;  :arith-assert-diseq      4957
;  :arith-assert-lower      95310
;  :arith-assert-upper      80378
;  :arith-bound-prop        14442
;  :arith-conflicts         532
;  :arith-eq-adapter        72720
;  :arith-fixed-eqs         79433
;  :arith-offset-eqs        47309
;  :arith-pivots            51056
;  :conflicts               1870
;  :datatype-accessor-ax    266
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               29696
;  :del-clause              1768139
;  :final-checks            5
;  :max-generation          12
;  :max-memory              83.11
;  :memory                  77.27
;  :minimized-lits          230
;  :mk-bool-var             1665760
;  :mk-clause               1769640
;  :num-allocs              5322296
;  :num-checks              370
;  :propagations            384466
;  :quant-instantiations    613053
;  :restarts                2
;  :rlimit-count            18816015
;  :time                    0.02)
; Final check if taken enough permissions
; Done removing quantified permissions
; Definitional axioms for snapshot map values
; [eval] (forall i1: Int :: { aloc(opt_get1(G), i1) } 0 <= i1 && i1 < V ==> aloc(opt_get1(G), i1).option$array$ != (None(): option[array]))
(declare-const i1@381@04 Int)
(push) ; 11
; [eval] 0 <= i1 && i1 < V ==> aloc(opt_get1(G), i1).option$array$ != (None(): option[array])
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 12
; [then-branch: 207 | 0 <= i1@381@04 | live]
; [else-branch: 207 | !(0 <= i1@381@04) | live]
(push) ; 13
; [then-branch: 207 | 0 <= i1@381@04]
(assert (<= 0 i1@381@04))
; [eval] i1 < V
(pop) ; 13
(push) ; 13
; [else-branch: 207 | !(0 <= i1@381@04)]
(assert (not (<= 0 i1@381@04)))
(pop) ; 13
(pop) ; 12
; Joined path conditions
; Joined path conditions
(push) ; 12
; [then-branch: 208 | i1@381@04 < V@15@04 && 0 <= i1@381@04 | live]
; [else-branch: 208 | !(i1@381@04 < V@15@04 && 0 <= i1@381@04) | live]
(push) ; 13
; [then-branch: 208 | i1@381@04 < V@15@04 && 0 <= i1@381@04]
(assert (and (< i1@381@04 V@15@04) (<= 0 i1@381@04)))
; [eval] aloc(opt_get1(G), i1).option$array$ != (None(): option[array])
; [eval] aloc(opt_get1(G), i1)
; [eval] opt_get1(G)
(push) ; 14
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 14
; Joined path conditions
(push) ; 14
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 15
(assert (not (< i1@381@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))))
(check-sat)
; unsat
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               557850
;  :arith-add-rows          255925
;  :arith-assert-diseq      4957
;  :arith-assert-lower      95312
;  :arith-assert-upper      80378
;  :arith-bound-prop        14442
;  :arith-conflicts         532
;  :arith-eq-adapter        72720
;  :arith-fixed-eqs         79433
;  :arith-offset-eqs        47309
;  :arith-pivots            51056
;  :conflicts               1870
;  :datatype-accessor-ax    266
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               29696
;  :del-clause              1768139
;  :final-checks            5
;  :max-generation          12
;  :max-memory              83.11
;  :memory                  77.27
;  :minimized-lits          230
;  :mk-bool-var             1665762
;  :mk-clause               1769640
;  :num-allocs              5322405
;  :num-checks              371
;  :propagations            384466
;  :quant-instantiations    613053
;  :restarts                2
;  :rlimit-count            18816206)
(assert (< i1@381@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(pop) ; 14
; Joined path conditions
(assert (< i1@381@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@297@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@381@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@381@04)))
(push) ; 14
(assert (not (ite
  (and
    (<
      (inv@296@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@381@04))
      V@15@04)
    (<=
      0
      (inv@296@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@381@04))))
  (< $Perm.No $k@295@04)
  false)))
(check-sat)
; unsat
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               557951
;  :arith-add-rows          255976
;  :arith-assert-diseq      4957
;  :arith-assert-lower      95331
;  :arith-assert-upper      80394
;  :arith-bound-prop        14453
;  :arith-conflicts         533
;  :arith-eq-adapter        72735
;  :arith-fixed-eqs         79448
;  :arith-offset-eqs        47309
;  :arith-pivots            51072
;  :conflicts               1871
;  :datatype-accessor-ax    266
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               29696
;  :del-clause              1768139
;  :final-checks            5
;  :max-generation          12
;  :max-memory              83.11
;  :memory                  77.30
;  :minimized-lits          230
;  :mk-bool-var             1666191
;  :mk-clause               1769921
;  :num-allocs              5324383
;  :num-checks              372
;  :propagations            384470
;  :quant-instantiations    613224
;  :restarts                2
;  :rlimit-count            18823586)
; [eval] (None(): option[array])
(pop) ; 13
(push) ; 13
; [else-branch: 208 | !(i1@381@04 < V@15@04 && 0 <= i1@381@04)]
(assert (not (and (< i1@381@04 V@15@04) (<= 0 i1@381@04))))
(pop) ; 13
(pop) ; 12
; Joined path conditions
(assert (implies
  (and (< i1@381@04 V@15@04) (<= 0 i1@381@04))
  (and
    (< i1@381@04 V@15@04)
    (<= 0 i1@381@04)
    (< i1@381@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@297@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@381@04)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@381@04)))))
; Joined path conditions
(pop) ; 11
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@381@04 Int)) (!
  (implies
    (and (< i1@381@04 V@15@04) (<= 0 i1@381@04))
    (and
      (< i1@381@04 V@15@04)
      (<= 0 i1@381@04)
      (< i1@381@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@297@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@381@04)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@381@04))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@381@04))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(push) ; 11
(assert (not (forall ((i1@381@04 Int)) (!
  (implies
    (and (< i1@381@04 V@15@04) (<= 0 i1@381@04))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@297@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@381@04))
        (as None<option<array>>  option<array>))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@381@04))
  :qid |prog.l<no position>|))))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               557975
;  :arith-add-rows          256001
;  :arith-assert-diseq      4957
;  :arith-assert-lower      95333
;  :arith-assert-upper      80394
;  :arith-bound-prop        14453
;  :arith-conflicts         533
;  :arith-eq-adapter        72736
;  :arith-fixed-eqs         79448
;  :arith-offset-eqs        47309
;  :arith-pivots            51088
;  :conflicts               1872
;  :datatype-accessor-ax    266
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               29696
;  :del-clause              1768545
;  :final-checks            5
;  :max-generation          12
;  :max-memory              83.11
;  :memory                  77.27
;  :minimized-lits          230
;  :mk-bool-var             1666363
;  :mk-clause               1770046
;  :num-allocs              5325847
;  :num-checks              373
;  :propagations            384470
;  :quant-instantiations    613329
;  :restarts                2
;  :rlimit-count            18828801
;  :time                    0.00)
(assert (forall ((i1@381@04 Int)) (!
  (implies
    (and (< i1@381@04 V@15@04) (<= 0 i1@381@04))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@297@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@381@04))
        (as None<option<array>>  option<array>))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@381@04))
  :qid |prog.l<no position>|)))
; [eval] (forall i1: Int :: { alen(opt_get1(aloc(opt_get1(G), i1).option$array$)) } 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(G), i1).option$array$)) == V)
(declare-const i1@382@04 Int)
(push) ; 11
; [eval] 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(G), i1).option$array$)) == V
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 12
; [then-branch: 209 | 0 <= i1@382@04 | live]
; [else-branch: 209 | !(0 <= i1@382@04) | live]
(push) ; 13
; [then-branch: 209 | 0 <= i1@382@04]
(assert (<= 0 i1@382@04))
; [eval] i1 < V
(pop) ; 13
(push) ; 13
; [else-branch: 209 | !(0 <= i1@382@04)]
(assert (not (<= 0 i1@382@04)))
(pop) ; 13
(pop) ; 12
; Joined path conditions
; Joined path conditions
(push) ; 12
; [then-branch: 210 | i1@382@04 < V@15@04 && 0 <= i1@382@04 | live]
; [else-branch: 210 | !(i1@382@04 < V@15@04 && 0 <= i1@382@04) | live]
(push) ; 13
; [then-branch: 210 | i1@382@04 < V@15@04 && 0 <= i1@382@04]
(assert (and (< i1@382@04 V@15@04) (<= 0 i1@382@04)))
; [eval] alen(opt_get1(aloc(opt_get1(G), i1).option$array$)) == V
; [eval] alen(opt_get1(aloc(opt_get1(G), i1).option$array$))
; [eval] opt_get1(aloc(opt_get1(G), i1).option$array$)
; [eval] aloc(opt_get1(G), i1)
; [eval] opt_get1(G)
(push) ; 14
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 14
; Joined path conditions
(push) ; 14
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 15
(assert (not (< i1@382@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))))
(check-sat)
; unsat
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               557975
;  :arith-add-rows          256002
;  :arith-assert-diseq      4957
;  :arith-assert-lower      95335
;  :arith-assert-upper      80394
;  :arith-bound-prop        14453
;  :arith-conflicts         533
;  :arith-eq-adapter        72736
;  :arith-fixed-eqs         79448
;  :arith-offset-eqs        47309
;  :arith-pivots            51088
;  :conflicts               1872
;  :datatype-accessor-ax    266
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               29696
;  :del-clause              1768545
;  :final-checks            5
;  :max-generation          12
;  :max-memory              83.11
;  :memory                  77.27
;  :minimized-lits          230
;  :mk-bool-var             1666366
;  :mk-clause               1770046
;  :num-allocs              5326147
;  :num-checks              374
;  :propagations            384470
;  :quant-instantiations    613329
;  :restarts                2
;  :rlimit-count            18829301)
(assert (< i1@382@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(pop) ; 14
; Joined path conditions
(assert (< i1@382@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@297@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@382@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@382@04)))
(push) ; 14
(assert (not (ite
  (and
    (<
      (inv@296@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@382@04))
      V@15@04)
    (<=
      0
      (inv@296@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@382@04))))
  (< $Perm.No $k@295@04)
  false)))
(check-sat)
; unsat
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               558075
;  :arith-add-rows          256053
;  :arith-assert-diseq      4957
;  :arith-assert-lower      95354
;  :arith-assert-upper      80410
;  :arith-bound-prop        14464
;  :arith-conflicts         534
;  :arith-eq-adapter        72751
;  :arith-fixed-eqs         79463
;  :arith-offset-eqs        47309
;  :arith-pivots            51104
;  :conflicts               1873
;  :datatype-accessor-ax    266
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               29696
;  :del-clause              1768545
;  :final-checks            5
;  :max-generation          12
;  :max-memory              83.11
;  :memory                  77.28
;  :minimized-lits          230
;  :mk-bool-var             1666794
;  :mk-clause               1770327
;  :num-allocs              5328158
;  :num-checks              375
;  :propagations            384474
;  :quant-instantiations    613501
;  :restarts                2
;  :rlimit-count            18837565)
(push) ; 14
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 15
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@297@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@382@04))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               558075
;  :arith-add-rows          256053
;  :arith-assert-diseq      4957
;  :arith-assert-lower      95354
;  :arith-assert-upper      80410
;  :arith-bound-prop        14464
;  :arith-conflicts         534
;  :arith-eq-adapter        72751
;  :arith-fixed-eqs         79463
;  :arith-offset-eqs        47309
;  :arith-pivots            51104
;  :conflicts               1874
;  :datatype-accessor-ax    266
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               29696
;  :del-clause              1768545
;  :final-checks            5
;  :max-generation          12
;  :max-memory              83.11
;  :memory                  77.28
;  :minimized-lits          230
;  :mk-bool-var             1666794
;  :mk-clause               1770327
;  :num-allocs              5328248
;  :num-checks              376
;  :propagations            384474
;  :quant-instantiations    613501
;  :restarts                2
;  :rlimit-count            18837660)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@297@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@382@04))
    (as None<option<array>>  option<array>))))
(pop) ; 14
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@297@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@382@04))
    (as None<option<array>>  option<array>))))
(pop) ; 13
(push) ; 13
; [else-branch: 210 | !(i1@382@04 < V@15@04 && 0 <= i1@382@04)]
(assert (not (and (< i1@382@04 V@15@04) (<= 0 i1@382@04))))
(pop) ; 13
(pop) ; 12
; Joined path conditions
(assert (implies
  (and (< i1@382@04 V@15@04) (<= 0 i1@382@04))
  (and
    (< i1@382@04 V@15@04)
    (<= 0 i1@382@04)
    (< i1@382@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@297@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@382@04)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@382@04))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@297@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@382@04))
        (as None<option<array>>  option<array>))))))
; Joined path conditions
(pop) ; 11
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@382@04 Int)) (!
  (implies
    (and (< i1@382@04 V@15@04) (<= 0 i1@382@04))
    (and
      (< i1@382@04 V@15@04)
      (<= 0 i1@382@04)
      (< i1@382@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@297@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@382@04)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@382@04))
      (not
        (=
          ($FVF.lookup_option$array$ (as sm@297@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@382@04))
          (as None<option<array>>  option<array>)))))
  :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@297@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@382@04)))))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(push) ; 11
(assert (not (forall ((i1@382@04 Int)) (!
  (implies
    (and (< i1@382@04 V@15@04) (<= 0 i1@382@04))
    (=
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@297@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@382@04))))
      V@15@04))
  :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@297@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@382@04)))))
  :qid |prog.l<no position>|))))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               558075
;  :arith-add-rows          256070
;  :arith-assert-diseq      4957
;  :arith-assert-lower      95356
;  :arith-assert-upper      80410
;  :arith-bound-prop        14464
;  :arith-conflicts         534
;  :arith-eq-adapter        72752
;  :arith-fixed-eqs         79463
;  :arith-offset-eqs        47309
;  :arith-pivots            51122
;  :conflicts               1875
;  :datatype-accessor-ax    266
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               29696
;  :del-clause              1768836
;  :final-checks            5
;  :max-generation          12
;  :max-memory              83.11
;  :memory                  77.25
;  :minimized-lits          230
;  :mk-bool-var             1666843
;  :mk-clause               1770337
;  :num-allocs              5329021
;  :num-checks              377
;  :propagations            384474
;  :quant-instantiations    613550
;  :restarts                2
;  :rlimit-count            18840188)
(assert (forall ((i1@382@04 Int)) (!
  (implies
    (and (< i1@382@04 V@15@04) (<= 0 i1@382@04))
    (=
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@297@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@382@04))))
      V@15@04))
  :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@297@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@382@04)))))
  :qid |prog.l<no position>|)))
; [eval] (forall i1: Int :: { aloc(opt_get1(G), i1) } (forall i2: Int :: { aloc(opt_get1(G), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(G), i1).option$array$ == aloc(opt_get1(G), i2).option$array$ ==> i1 == i2))
(declare-const i1@383@04 Int)
(push) ; 11
; [eval] (forall i2: Int :: { aloc(opt_get1(G), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(G), i1).option$array$ == aloc(opt_get1(G), i2).option$array$ ==> i1 == i2)
(declare-const i2@384@04 Int)
(push) ; 12
; [eval] 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(G), i1).option$array$ == aloc(opt_get1(G), i2).option$array$ ==> i1 == i2
; [eval] 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(G), i1).option$array$ == aloc(opt_get1(G), i2).option$array$
; [eval] 0 <= i1
(push) ; 13
; [then-branch: 211 | 0 <= i1@383@04 | live]
; [else-branch: 211 | !(0 <= i1@383@04) | live]
(push) ; 14
; [then-branch: 211 | 0 <= i1@383@04]
(assert (<= 0 i1@383@04))
; [eval] i1 < V
(push) ; 15
; [then-branch: 212 | i1@383@04 < V@15@04 | live]
; [else-branch: 212 | !(i1@383@04 < V@15@04) | live]
(push) ; 16
; [then-branch: 212 | i1@383@04 < V@15@04]
(assert (< i1@383@04 V@15@04))
; [eval] 0 <= i2
(push) ; 17
; [then-branch: 213 | 0 <= i2@384@04 | live]
; [else-branch: 213 | !(0 <= i2@384@04) | live]
(push) ; 18
; [then-branch: 213 | 0 <= i2@384@04]
(assert (<= 0 i2@384@04))
; [eval] i2 < V
(push) ; 19
; [then-branch: 214 | i2@384@04 < V@15@04 | live]
; [else-branch: 214 | !(i2@384@04 < V@15@04) | live]
(push) ; 20
; [then-branch: 214 | i2@384@04 < V@15@04]
(assert (< i2@384@04 V@15@04))
; [eval] aloc(opt_get1(G), i1).option$array$ == aloc(opt_get1(G), i2).option$array$
; [eval] aloc(opt_get1(G), i1)
; [eval] opt_get1(G)
(push) ; 21
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 21
; Joined path conditions
(push) ; 21
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 22
(assert (not (< i1@383@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))))
(check-sat)
; unsat
(pop) ; 22
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               558075
;  :arith-add-rows          256072
;  :arith-assert-diseq      4957
;  :arith-assert-lower      95360
;  :arith-assert-upper      80410
;  :arith-bound-prop        14464
;  :arith-conflicts         534
;  :arith-eq-adapter        72752
;  :arith-fixed-eqs         79463
;  :arith-offset-eqs        47309
;  :arith-pivots            51122
;  :conflicts               1875
;  :datatype-accessor-ax    266
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               29696
;  :del-clause              1768836
;  :final-checks            5
;  :max-generation          12
;  :max-memory              83.11
;  :memory                  77.25
;  :minimized-lits          230
;  :mk-bool-var             1666848
;  :mk-clause               1770337
;  :num-allocs              5329498
;  :num-checks              378
;  :propagations            384474
;  :quant-instantiations    613550
;  :restarts                2
;  :rlimit-count            18840833)
(assert (< i1@383@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(pop) ; 21
; Joined path conditions
(assert (< i1@383@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@297@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@383@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@383@04)))
(push) ; 21
(assert (not (ite
  (and
    (<
      (inv@296@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@383@04))
      V@15@04)
    (<=
      0
      (inv@296@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@383@04))))
  (< $Perm.No $k@295@04)
  false)))
(check-sat)
; unsat
(pop) ; 21
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               558175
;  :arith-add-rows          256123
;  :arith-assert-diseq      4957
;  :arith-assert-lower      95379
;  :arith-assert-upper      80426
;  :arith-bound-prop        14475
;  :arith-conflicts         535
;  :arith-eq-adapter        72767
;  :arith-fixed-eqs         79478
;  :arith-offset-eqs        47309
;  :arith-pivots            51138
;  :conflicts               1876
;  :datatype-accessor-ax    266
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               29696
;  :del-clause              1768836
;  :final-checks            5
;  :max-generation          12
;  :max-memory              83.11
;  :memory                  77.26
;  :minimized-lits          230
;  :mk-bool-var             1667276
;  :mk-clause               1770618
;  :num-allocs              5331507
;  :num-checks              379
;  :propagations            384478
;  :quant-instantiations    613722
;  :restarts                2
;  :rlimit-count            18849097)
; [eval] aloc(opt_get1(G), i2)
; [eval] opt_get1(G)
(push) ; 21
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 21
; Joined path conditions
(push) ; 21
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 22
(assert (not (< i2@384@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))))
(check-sat)
; unsat
(pop) ; 22
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               558175
;  :arith-add-rows          256123
;  :arith-assert-diseq      4957
;  :arith-assert-lower      95379
;  :arith-assert-upper      80426
;  :arith-bound-prop        14475
;  :arith-conflicts         535
;  :arith-eq-adapter        72767
;  :arith-fixed-eqs         79478
;  :arith-offset-eqs        47309
;  :arith-pivots            51138
;  :conflicts               1876
;  :datatype-accessor-ax    266
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               29696
;  :del-clause              1768836
;  :final-checks            5
;  :max-generation          12
;  :max-memory              83.11
;  :memory                  77.26
;  :minimized-lits          230
;  :mk-bool-var             1667276
;  :mk-clause               1770618
;  :num-allocs              5331533
;  :num-checks              380
;  :propagations            384478
;  :quant-instantiations    613722
;  :restarts                2
;  :rlimit-count            18849127)
(assert (< i2@384@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(pop) ; 21
; Joined path conditions
(assert (< i2@384@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@297@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@384@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@384@04)))
(push) ; 21
(assert (not (ite
  (and
    (<
      (inv@296@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@384@04))
      V@15@04)
    (<=
      0
      (inv@296@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@384@04))))
  (< $Perm.No $k@295@04)
  false)))
(check-sat)
; unsat
(pop) ; 21
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               558277
;  :arith-add-rows          256176
;  :arith-assert-diseq      4957
;  :arith-assert-lower      95398
;  :arith-assert-upper      80442
;  :arith-bound-prop        14486
;  :arith-conflicts         536
;  :arith-eq-adapter        72783
;  :arith-fixed-eqs         79493
;  :arith-offset-eqs        47309
;  :arith-pivots            51154
;  :conflicts               1877
;  :datatype-accessor-ax    266
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               29696
;  :del-clause              1768836
;  :final-checks            5
;  :max-generation          12
;  :max-memory              83.11
;  :memory                  77.29
;  :minimized-lits          230
;  :mk-bool-var             1667623
;  :mk-clause               1770843
;  :num-allocs              5333458
;  :num-checks              381
;  :propagations            384500
;  :quant-instantiations    613889
;  :restarts                2
;  :rlimit-count            18857293)
(pop) ; 20
(push) ; 20
; [else-branch: 214 | !(i2@384@04 < V@15@04)]
(assert (not (< i2@384@04 V@15@04)))
(pop) ; 20
(pop) ; 19
; Joined path conditions
(assert (implies
  (< i2@384@04 V@15@04)
  (and
    (< i2@384@04 V@15@04)
    (< i1@383@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@297@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@383@04)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@383@04))
    (< i2@384@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@297@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@384@04)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@384@04)))))
; Joined path conditions
(pop) ; 18
(push) ; 18
; [else-branch: 213 | !(0 <= i2@384@04)]
(assert (not (<= 0 i2@384@04)))
(pop) ; 18
(pop) ; 17
; Joined path conditions
(assert (implies
  (<= 0 i2@384@04)
  (and
    (<= 0 i2@384@04)
    (implies
      (< i2@384@04 V@15@04)
      (and
        (< i2@384@04 V@15@04)
        (< i1@383@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@297@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@383@04)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@383@04))
        (< i2@384@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@297@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@384@04)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@384@04)))))))
; Joined path conditions
(pop) ; 16
(push) ; 16
; [else-branch: 212 | !(i1@383@04 < V@15@04)]
(assert (not (< i1@383@04 V@15@04)))
(pop) ; 16
(pop) ; 15
; Joined path conditions
(assert (implies
  (< i1@383@04 V@15@04)
  (and
    (< i1@383@04 V@15@04)
    (implies
      (<= 0 i2@384@04)
      (and
        (<= 0 i2@384@04)
        (implies
          (< i2@384@04 V@15@04)
          (and
            (< i2@384@04 V@15@04)
            (< i1@383@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@297@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@383@04)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@383@04))
            (< i2@384@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@297@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@384@04)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@384@04)))))))))
; Joined path conditions
(pop) ; 14
(push) ; 14
; [else-branch: 211 | !(0 <= i1@383@04)]
(assert (not (<= 0 i1@383@04)))
(pop) ; 14
(pop) ; 13
; Joined path conditions
(assert (implies
  (<= 0 i1@383@04)
  (and
    (<= 0 i1@383@04)
    (implies
      (< i1@383@04 V@15@04)
      (and
        (< i1@383@04 V@15@04)
        (implies
          (<= 0 i2@384@04)
          (and
            (<= 0 i2@384@04)
            (implies
              (< i2@384@04 V@15@04)
              (and
                (< i2@384@04 V@15@04)
                (< i1@383@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@297@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@383@04)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@383@04))
                (< i2@384@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@297@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@384@04)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@384@04)))))))))))
; Joined path conditions
(push) ; 13
; [then-branch: 215 | Lookup(option$array$,sm@297@04,aloc((_, _), opt_get1(_, G@11@04), i1@383@04)) == Lookup(option$array$,sm@297@04,aloc((_, _), opt_get1(_, G@11@04), i2@384@04)) && i2@384@04 < V@15@04 && 0 <= i2@384@04 && i1@383@04 < V@15@04 && 0 <= i1@383@04 | live]
; [else-branch: 215 | !(Lookup(option$array$,sm@297@04,aloc((_, _), opt_get1(_, G@11@04), i1@383@04)) == Lookup(option$array$,sm@297@04,aloc((_, _), opt_get1(_, G@11@04), i2@384@04)) && i2@384@04 < V@15@04 && 0 <= i2@384@04 && i1@383@04 < V@15@04 && 0 <= i1@383@04) | live]
(push) ; 14
; [then-branch: 215 | Lookup(option$array$,sm@297@04,aloc((_, _), opt_get1(_, G@11@04), i1@383@04)) == Lookup(option$array$,sm@297@04,aloc((_, _), opt_get1(_, G@11@04), i2@384@04)) && i2@384@04 < V@15@04 && 0 <= i2@384@04 && i1@383@04 < V@15@04 && 0 <= i1@383@04]
(assert (and
  (and
    (and
      (and
        (=
          ($FVF.lookup_option$array$ (as sm@297@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@383@04))
          ($FVF.lookup_option$array$ (as sm@297@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@384@04)))
        (< i2@384@04 V@15@04))
      (<= 0 i2@384@04))
    (< i1@383@04 V@15@04))
  (<= 0 i1@383@04)))
; [eval] i1 == i2
(pop) ; 14
(push) ; 14
; [else-branch: 215 | !(Lookup(option$array$,sm@297@04,aloc((_, _), opt_get1(_, G@11@04), i1@383@04)) == Lookup(option$array$,sm@297@04,aloc((_, _), opt_get1(_, G@11@04), i2@384@04)) && i2@384@04 < V@15@04 && 0 <= i2@384@04 && i1@383@04 < V@15@04 && 0 <= i1@383@04)]
(assert (not
  (and
    (and
      (and
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@297@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@383@04))
            ($FVF.lookup_option$array$ (as sm@297@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@384@04)))
          (< i2@384@04 V@15@04))
        (<= 0 i2@384@04))
      (< i1@383@04 V@15@04))
    (<= 0 i1@383@04))))
(pop) ; 14
(pop) ; 13
; Joined path conditions
(assert (implies
  (and
    (and
      (and
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@297@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@383@04))
            ($FVF.lookup_option$array$ (as sm@297@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@384@04)))
          (< i2@384@04 V@15@04))
        (<= 0 i2@384@04))
      (< i1@383@04 V@15@04))
    (<= 0 i1@383@04))
  (and
    (=
      ($FVF.lookup_option$array$ (as sm@297@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@383@04))
      ($FVF.lookup_option$array$ (as sm@297@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@384@04)))
    (< i2@384@04 V@15@04)
    (<= 0 i2@384@04)
    (< i1@383@04 V@15@04)
    (<= 0 i1@383@04))))
; Joined path conditions
(pop) ; 12
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i2@384@04 Int)) (!
  (and
    (implies
      (<= 0 i1@383@04)
      (and
        (<= 0 i1@383@04)
        (implies
          (< i1@383@04 V@15@04)
          (and
            (< i1@383@04 V@15@04)
            (implies
              (<= 0 i2@384@04)
              (and
                (<= 0 i2@384@04)
                (implies
                  (< i2@384@04 V@15@04)
                  (and
                    (< i2@384@04 V@15@04)
                    (< i1@383@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
                    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@297@04  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@383@04)) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@383@04))
                    (< i2@384@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
                    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@297@04  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@384@04)) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@384@04))))))))))
    (implies
      (and
        (and
          (and
            (and
              (=
                ($FVF.lookup_option$array$ (as sm@297@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@383@04))
                ($FVF.lookup_option$array$ (as sm@297@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@384@04)))
              (< i2@384@04 V@15@04))
            (<= 0 i2@384@04))
          (< i1@383@04 V@15@04))
        (<= 0 i1@383@04))
      (and
        (=
          ($FVF.lookup_option$array$ (as sm@297@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@383@04))
          ($FVF.lookup_option$array$ (as sm@297@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@384@04)))
        (< i2@384@04 V@15@04)
        (<= 0 i2@384@04)
        (< i1@383@04 V@15@04)
        (<= 0 i1@383@04))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@384@04))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 11
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@383@04 Int)) (!
  (forall ((i2@384@04 Int)) (!
    (and
      (implies
        (<= 0 i1@383@04)
        (and
          (<= 0 i1@383@04)
          (implies
            (< i1@383@04 V@15@04)
            (and
              (< i1@383@04 V@15@04)
              (implies
                (<= 0 i2@384@04)
                (and
                  (<= 0 i2@384@04)
                  (implies
                    (< i2@384@04 V@15@04)
                    (and
                      (< i2@384@04 V@15@04)
                      (< i1@383@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
                      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@297@04  $FVF<option<array>>) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@383@04)) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@383@04))
                      (< i2@384@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
                      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@297@04  $FVF<option<array>>) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@384@04)) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@384@04))))))))))
      (implies
        (and
          (and
            (and
              (and
                (=
                  ($FVF.lookup_option$array$ (as sm@297@04  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@383@04))
                  ($FVF.lookup_option$array$ (as sm@297@04  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@384@04)))
                (< i2@384@04 V@15@04))
              (<= 0 i2@384@04))
            (< i1@383@04 V@15@04))
          (<= 0 i1@383@04))
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@297@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@383@04))
            ($FVF.lookup_option$array$ (as sm@297@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@384@04)))
          (< i2@384@04 V@15@04)
          (<= 0 i2@384@04)
          (< i1@383@04 V@15@04)
          (<= 0 i1@383@04))))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@384@04))
    :qid |prog.l<no position>-aux|))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@383@04))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(push) ; 11
(assert (not (forall ((i1@383@04 Int)) (!
  (forall ((i2@384@04 Int)) (!
    (implies
      (and
        (and
          (and
            (and
              (=
                ($FVF.lookup_option$array$ (as sm@297@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@383@04))
                ($FVF.lookup_option$array$ (as sm@297@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@384@04)))
              (< i2@384@04 V@15@04))
            (<= 0 i2@384@04))
          (< i1@383@04 V@15@04))
        (<= 0 i1@383@04))
      (= i1@383@04 i2@384@04))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@384@04))
    :qid |prog.l<no position>|))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@383@04))
  :qid |prog.l<no position>|))))
(check-sat)
; unsat
(pop) ; 11
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               558392
;  :arith-add-rows          256254
;  :arith-assert-diseq      4959
;  :arith-assert-lower      95412
;  :arith-assert-upper      80444
;  :arith-bound-prop        14489
;  :arith-conflicts         536
;  :arith-eq-adapter        72814
;  :arith-fixed-eqs         79495
;  :arith-offset-eqs        47312
;  :arith-pivots            51192
;  :conflicts               1878
;  :datatype-accessor-ax    266
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               29696
;  :del-clause              1769748
;  :final-checks            5
;  :max-generation          12
;  :max-memory              83.11
;  :memory                  77.24
;  :minimized-lits          230
;  :mk-bool-var             1668305
;  :mk-clause               1771249
;  :num-allocs              5337490
;  :num-checks              382
;  :propagations            384515
;  :quant-instantiations    614209
;  :restarts                2
;  :rlimit-count            18873609
;  :time                    0.01)
(assert (forall ((i1@383@04 Int)) (!
  (forall ((i2@384@04 Int)) (!
    (implies
      (and
        (and
          (and
            (and
              (=
                ($FVF.lookup_option$array$ (as sm@297@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@383@04))
                ($FVF.lookup_option$array$ (as sm@297@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@384@04)))
              (< i2@384@04 V@15@04))
            (<= 0 i2@384@04))
          (< i1@383@04 V@15@04))
        (<= 0 i1@383@04))
      (= i1@383@04 i2@384@04))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@384@04))
    :qid |prog.l<no position>|))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@383@04))
  :qid |prog.l<no position>|)))
(declare-const i1@385@04 Int)
(declare-const j@386@04 Int)
(push) ; 11
; [eval] 0 <= i1 && i1 < V && (0 <= j && j < V)
; [eval] 0 <= i1
(push) ; 12
; [then-branch: 216 | 0 <= i1@385@04 | live]
; [else-branch: 216 | !(0 <= i1@385@04) | live]
(push) ; 13
; [then-branch: 216 | 0 <= i1@385@04]
(assert (<= 0 i1@385@04))
; [eval] i1 < V
(push) ; 14
; [then-branch: 217 | i1@385@04 < V@15@04 | live]
; [else-branch: 217 | !(i1@385@04 < V@15@04) | live]
(push) ; 15
; [then-branch: 217 | i1@385@04 < V@15@04]
(assert (< i1@385@04 V@15@04))
; [eval] 0 <= j
(push) ; 16
; [then-branch: 218 | 0 <= j@386@04 | live]
; [else-branch: 218 | !(0 <= j@386@04) | live]
(push) ; 17
; [then-branch: 218 | 0 <= j@386@04]
(assert (<= 0 j@386@04))
; [eval] j < V
(pop) ; 17
(push) ; 17
; [else-branch: 218 | !(0 <= j@386@04)]
(assert (not (<= 0 j@386@04)))
(pop) ; 17
(pop) ; 16
; Joined path conditions
; Joined path conditions
(pop) ; 15
(push) ; 15
; [else-branch: 217 | !(i1@385@04 < V@15@04)]
(assert (not (< i1@385@04 V@15@04)))
(pop) ; 15
(pop) ; 14
; Joined path conditions
; Joined path conditions
(pop) ; 13
(push) ; 13
; [else-branch: 216 | !(0 <= i1@385@04)]
(assert (not (<= 0 i1@385@04)))
(pop) ; 13
(pop) ; 12
; Joined path conditions
; Joined path conditions
(assert (and
  (and (and (< j@386@04 V@15@04) (<= 0 j@386@04)) (< i1@385@04 V@15@04))
  (<= 0 i1@385@04)))
; [eval] aloc(opt_get1(aloc(opt_get1(G), i1).option$array$), j)
; [eval] opt_get1(aloc(opt_get1(G), i1).option$array$)
; [eval] aloc(opt_get1(G), i1)
; [eval] opt_get1(G)
(push) ; 12
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 12
; Joined path conditions
(push) ; 12
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 13
(assert (not (< i1@385@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))))
(check-sat)
; unsat
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               558392
;  :arith-add-rows          256257
;  :arith-assert-diseq      4959
;  :arith-assert-lower      95418
;  :arith-assert-upper      80444
;  :arith-bound-prop        14489
;  :arith-conflicts         536
;  :arith-eq-adapter        72814
;  :arith-fixed-eqs         79495
;  :arith-offset-eqs        47312
;  :arith-pivots            51194
;  :conflicts               1878
;  :datatype-accessor-ax    266
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               29696
;  :del-clause              1769748
;  :final-checks            5
;  :max-generation          12
;  :max-memory              83.11
;  :memory                  77.24
;  :minimized-lits          230
;  :mk-bool-var             1668312
;  :mk-clause               1771249
;  :num-allocs              5338090
;  :num-checks              383
;  :propagations            384515
;  :quant-instantiations    614209
;  :restarts                2
;  :rlimit-count            18874622)
(assert (< i1@385@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(pop) ; 12
; Joined path conditions
(assert (< i1@385@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@297@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@385@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@385@04)))
(push) ; 12
(assert (not (ite
  (and
    (<
      (inv@296@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@385@04))
      V@15@04)
    (<=
      0
      (inv@296@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@385@04))))
  (< $Perm.No $k@295@04)
  false)))
(check-sat)
; unsat
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               558492
;  :arith-add-rows          256308
;  :arith-assert-diseq      4959
;  :arith-assert-lower      95437
;  :arith-assert-upper      80460
;  :arith-bound-prop        14500
;  :arith-conflicts         537
;  :arith-eq-adapter        72829
;  :arith-fixed-eqs         79510
;  :arith-offset-eqs        47312
;  :arith-pivots            51210
;  :conflicts               1879
;  :datatype-accessor-ax    266
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               29696
;  :del-clause              1769748
;  :final-checks            5
;  :max-generation          12
;  :max-memory              83.11
;  :memory                  77.28
;  :minimized-lits          230
;  :mk-bool-var             1668742
;  :mk-clause               1771530
;  :num-allocs              5340151
;  :num-checks              384
;  :propagations            384519
;  :quant-instantiations    614384
;  :restarts                2
;  :rlimit-count            18882960)
(push) ; 12
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 13
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@297@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@385@04))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               558492
;  :arith-add-rows          256308
;  :arith-assert-diseq      4959
;  :arith-assert-lower      95437
;  :arith-assert-upper      80460
;  :arith-bound-prop        14500
;  :arith-conflicts         537
;  :arith-eq-adapter        72829
;  :arith-fixed-eqs         79510
;  :arith-offset-eqs        47312
;  :arith-pivots            51210
;  :conflicts               1880
;  :datatype-accessor-ax    266
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               29696
;  :del-clause              1769748
;  :final-checks            5
;  :max-generation          12
;  :max-memory              83.11
;  :memory                  77.28
;  :minimized-lits          230
;  :mk-bool-var             1668742
;  :mk-clause               1771530
;  :num-allocs              5340240
;  :num-checks              385
;  :propagations            384519
;  :quant-instantiations    614384
;  :restarts                2
;  :rlimit-count            18883055)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@297@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@385@04))
    (as None<option<array>>  option<array>))))
(pop) ; 12
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@297@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@385@04))
    (as None<option<array>>  option<array>))))
(push) ; 12
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 13
(assert (not (<
  j@386@04
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@297@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@385@04)))))))
(check-sat)
; unsat
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               558498
;  :arith-add-rows          256314
;  :arith-assert-diseq      4959
;  :arith-assert-lower      95439
;  :arith-assert-upper      80462
;  :arith-bound-prop        14500
;  :arith-conflicts         538
;  :arith-eq-adapter        72830
;  :arith-fixed-eqs         79511
;  :arith-offset-eqs        47312
;  :arith-pivots            51214
;  :conflicts               1881
;  :datatype-accessor-ax    266
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               29696
;  :del-clause              1769752
;  :final-checks            5
;  :max-generation          12
;  :max-memory              83.11
;  :memory                  77.28
;  :minimized-lits          230
;  :mk-bool-var             1668753
;  :mk-clause               1771534
;  :num-allocs              5340440
;  :num-checks              386
;  :propagations            384521
;  :quant-instantiations    614393
;  :restarts                2
;  :rlimit-count            18883640)
(assert (<
  j@386@04
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@297@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@385@04))))))
(pop) ; 12
; Joined path conditions
(assert (<
  j@386@04
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@297@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@385@04))))))
(pop) ; 11
(declare-fun inv@387@04 ($Ref) Int)
(declare-fun inv@388@04 ($Ref) Int)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(assert (forall ((i1@385@04 Int) (j@386@04 Int)) (!
  (and
    (< i1@385@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@297@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@385@04)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@385@04))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@297@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@385@04))
        (as None<option<array>>  option<array>)))
    (<
      j@386@04
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@297@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@385@04))))))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@297@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@385@04))) j@386@04))
  :qid |int-aux|)))
(declare-const sm@389@04 $FVF<Int>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@305@04 r) V@15@04) (<= 0 (inv@305@04 r)))
        (< (inv@304@04 r) V@15@04))
      (<= 0 (inv@304@04 r)))
    (=
      ($FVF.lookup_int (as sm@389@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@389@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04))))))))) r))
  :qid |qp.fvfValDef274|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@308@04 r) V@15@04) (<= 0 (inv@308@04 r)))
    (=
      ($FVF.lookup_int (as sm@389@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04)))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@389@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04)))))))))))) r))
  :qid |qp.fvfValDef275|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04)))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@389@04  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef276|)))
; Check receiver injectivity
(push) ; 11
(assert (not (forall ((i11@385@04 Int) (j1@386@04 Int) (i12@385@04 Int) (j2@386@04 Int)) (!
  (implies
    (and
      (and
        (and
          (and
            (and (< j1@386@04 V@15@04) (<= 0 j1@386@04))
            (< i11@385@04 V@15@04))
          (<= 0 i11@385@04))
        ($FVF.loc_int ($FVF.lookup_int (as sm@389@04  $FVF<Int>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@297@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i11@385@04))) j1@386@04)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@297@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i11@385@04))) j1@386@04)))
      (and
        (and
          (and
            (and (< j2@386@04 V@15@04) (<= 0 j2@386@04))
            (< i12@385@04 V@15@04))
          (<= 0 i12@385@04))
        ($FVF.loc_int ($FVF.lookup_int (as sm@389@04  $FVF<Int>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@297@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i12@385@04))) j2@386@04)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@297@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i12@385@04))) j2@386@04)))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@297@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i11@385@04))) j1@386@04)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@297@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i12@385@04))) j2@386@04)))
    (and (= i11@385@04 i12@385@04) (= j1@386@04 j2@386@04)))
  
  :qid |int-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               558593
;  :arith-add-rows          256361
;  :arith-assert-diseq      4959
;  :arith-assert-lower      95449
;  :arith-assert-upper      80462
;  :arith-bound-prop        14501
;  :arith-conflicts         538
;  :arith-eq-adapter        72840
;  :arith-fixed-eqs         79511
;  :arith-offset-eqs        47313
;  :arith-pivots            51236
;  :conflicts               1882
;  :datatype-accessor-ax    266
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               29696
;  :del-clause              1770211
;  :final-checks            5
;  :max-generation          12
;  :max-memory              83.11
;  :memory                  77.24
;  :minimized-lits          230
;  :mk-bool-var             1669065
;  :mk-clause               1771712
;  :num-allocs              5343321
;  :num-checks              387
;  :propagations            384539
;  :quant-instantiations    614579
;  :restarts                2
;  :rlimit-count            18894094
;  :time                    0.00)
; Definitional axioms for inverse functions
(assert (forall ((i1@385@04 Int) (j@386@04 Int)) (!
  (implies
    (and
      (and (and (< j@386@04 V@15@04) (<= 0 j@386@04)) (< i1@385@04 V@15@04))
      (<= 0 i1@385@04))
    (and
      (=
        (inv@387@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@297@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@385@04))) j@386@04))
        i1@385@04)
      (=
        (inv@388@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@297@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@385@04))) j@386@04))
        j@386@04)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@297@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@385@04))) j@386@04))
  :qid |int-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@388@04 r) V@15@04) (<= 0 (inv@388@04 r)))
        (< (inv@387@04 r) V@15@04))
      (<= 0 (inv@387@04 r)))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@297@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) (inv@387@04 r)))) (inv@388@04 r))
      r))
  :pattern ((inv@387@04 r))
  :pattern ((inv@388@04 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@388@04 r) V@15@04) (<= 0 (inv@388@04 r)))
        (< (inv@387@04 r) V@15@04))
      (<= 0 (inv@387@04 r)))
    ($FVF.loc_int ($FVF.lookup_int (as sm@389@04  $FVF<Int>) r) r))
  :pattern ((inv@387@04 r) (inv@388@04 r))
  )))
; Precomputing data for removing quantified permissions
(define-fun pTaken@390@04 ((r $Ref)) $Perm
  (ite
    (and
      (and
        (and (< (inv@388@04 r) V@15@04) (<= 0 (inv@388@04 r)))
        (< (inv@387@04 r) V@15@04))
      (<= 0 (inv@387@04 r)))
    ($Perm.min
      (ite
        (and
          (and
            (and (< (inv@305@04 r) V@15@04) (<= 0 (inv@305@04 r)))
            (< (inv@304@04 r) V@15@04))
          (<= 0 (inv@304@04 r)))
        $Perm.Write
        $Perm.No)
      $Perm.Write)
    $Perm.No))
(define-fun pTaken@391@04 ((r $Ref)) $Perm
  (ite
    (and
      (and
        (and (< (inv@388@04 r) V@15@04) (<= 0 (inv@388@04 r)))
        (< (inv@387@04 r) V@15@04))
      (<= 0 (inv@387@04 r)))
    ($Perm.min
      (ite
        (and (< (inv@308@04 r) V@15@04) (<= 0 (inv@308@04 r)))
        $Perm.Write
        $Perm.No)
      (- $Perm.Write (pTaken@390@04 r)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 500)
(push) ; 11
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and
          (and
            (and (< (inv@305@04 r) V@15@04) (<= 0 (inv@305@04 r)))
            (< (inv@304@04 r) V@15@04))
          (<= 0 (inv@304@04 r)))
        $Perm.Write
        $Perm.No)
      (pTaken@390@04 r))
    $Perm.No)
  
  ))))
(check-sat)
; unsat
(pop) ; 11
; 0.04s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               559616
;  :arith-add-rows          257341
;  :arith-assert-diseq      4982
;  :arith-assert-lower      95662
;  :arith-assert-upper      80614
;  :arith-bound-prop        14527
;  :arith-conflicts         540
;  :arith-eq-adapter        73005
;  :arith-fixed-eqs         79681
;  :arith-offset-eqs        47359
;  :arith-pivots            51380
;  :conflicts               1904
;  :datatype-accessor-ax    266
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               29915
;  :del-clause              1778565
;  :final-checks            5
;  :max-generation          12
;  :max-memory              83.11
;  :memory                  77.28
;  :minimized-lits          231
;  :mk-bool-var             1676629
;  :mk-clause               1780066
;  :num-allocs              5366170
;  :num-checks              389
;  :propagations            385637
;  :quant-instantiations    616510
;  :restarts                2
;  :rlimit-count            18984464
;  :time                    0.04)
; Intermediate check if already taken enough permissions
(push) ; 11
(assert (not (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@388@04 r) V@15@04) (<= 0 (inv@388@04 r)))
        (< (inv@387@04 r) V@15@04))
      (<= 0 (inv@387@04 r)))
    (= (- $Perm.Write (pTaken@390@04 r)) $Perm.No))
  
  ))))
(check-sat)
; unsat
(pop) ; 11
; 0.03s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               560192
;  :arith-add-rows          257986
;  :arith-assert-diseq      4994
;  :arith-assert-lower      95761
;  :arith-assert-upper      80686
;  :arith-bound-prop        14542
;  :arith-conflicts         542
;  :arith-eq-adapter        73067
;  :arith-fixed-eqs         79759
;  :arith-offset-eqs        47377
;  :arith-pivots            51442
;  :conflicts               1922
;  :datatype-accessor-ax    266
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               30092
;  :del-clause              1784778
;  :final-checks            5
;  :max-generation          12
;  :max-memory              83.11
;  :memory                  77.28
;  :minimized-lits          231
;  :mk-bool-var             1681244
;  :mk-clause               1786279
;  :num-allocs              5378252
;  :num-checks              390
;  :propagations            386388
;  :quant-instantiations    617702
;  :restarts                2
;  :rlimit-count            19044726
;  :time                    0.03)
; Final check if taken enough permissions
; Done removing quantified permissions
; Definitional axioms for snapshot map values
; [eval] P != (None(): option[array])
; [eval] (None(): option[array])
; [eval] alen(opt_get1(P)) == V
; [eval] alen(opt_get1(P))
; [eval] opt_get1(P)
(push) ; 11
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 11
; Joined path conditions
(declare-const i1@392@04 Int)
(push) ; 11
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 12
; [then-branch: 219 | 0 <= i1@392@04 | live]
; [else-branch: 219 | !(0 <= i1@392@04) | live]
(push) ; 13
; [then-branch: 219 | 0 <= i1@392@04]
(assert (<= 0 i1@392@04))
; [eval] i1 < V
(pop) ; 13
(push) ; 13
; [else-branch: 219 | !(0 <= i1@392@04)]
(assert (not (<= 0 i1@392@04)))
(pop) ; 13
(pop) ; 12
; Joined path conditions
; Joined path conditions
(assert (and (< i1@392@04 V@15@04) (<= 0 i1@392@04)))
; [eval] aloc(opt_get1(P), i1)
; [eval] opt_get1(P)
(push) ; 12
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 12
; Joined path conditions
(push) ; 12
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 13
(assert (not (< i1@392@04 (alen<Int> (opt_get1 $Snap.unit P@14@04)))))
(check-sat)
; unsat
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               560192
;  :arith-add-rows          257987
;  :arith-assert-diseq      4994
;  :arith-assert-lower      95763
;  :arith-assert-upper      80686
;  :arith-bound-prop        14542
;  :arith-conflicts         542
;  :arith-eq-adapter        73067
;  :arith-fixed-eqs         79759
;  :arith-offset-eqs        47377
;  :arith-pivots            51442
;  :conflicts               1922
;  :datatype-accessor-ax    266
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               30092
;  :del-clause              1784778
;  :final-checks            5
;  :max-generation          12
;  :max-memory              83.11
;  :memory                  77.28
;  :minimized-lits          231
;  :mk-bool-var             1681246
;  :mk-clause               1786279
;  :num-allocs              5378361
;  :num-checks              391
;  :propagations            386388
;  :quant-instantiations    617702
;  :restarts                2
;  :rlimit-count            19044912)
(assert (< i1@392@04 (alen<Int> (opt_get1 $Snap.unit P@14@04))))
(pop) ; 12
; Joined path conditions
(assert (< i1@392@04 (alen<Int> (opt_get1 $Snap.unit P@14@04))))
(pop) ; 11
(declare-fun inv@393@04 ($Ref) Int)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(assert (forall ((i1@392@04 Int)) (!
  (< i1@392@04 (alen<Int> (opt_get1 $Snap.unit P@14@04)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i1@392@04))
  :qid |int-aux|)))
(declare-const sm@394@04 $FVF<Int>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@308@04 r) V@15@04) (<= 0 (inv@308@04 r)))
    (=
      ($FVF.lookup_int (as sm@394@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04)))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@394@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04)))))))))))) r))
  :qid |qp.fvfValDef277|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04)))))))))))) r) r)
  :pattern (($FVF.lookup_int (as sm@394@04  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef278|)))
; Check receiver injectivity
(push) ; 11
(assert (not (forall ((i11@392@04 Int) (i12@392@04 Int)) (!
  (implies
    (and
      (and
        (and (< i11@392@04 V@15@04) (<= 0 i11@392@04))
        ($FVF.loc_int ($FVF.lookup_int (as sm@394@04  $FVF<Int>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit P@14@04) i11@392@04)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit P@14@04) i11@392@04)))
      (and
        (and (< i12@392@04 V@15@04) (<= 0 i12@392@04))
        ($FVF.loc_int ($FVF.lookup_int (as sm@394@04  $FVF<Int>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit P@14@04) i12@392@04)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit P@14@04) i12@392@04)))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i11@392@04)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i12@392@04)))
    (= i11@392@04 i12@392@04))
  
  :qid |int-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               560234
;  :arith-add-rows          257994
;  :arith-assert-diseq      4995
;  :arith-assert-lower      95767
;  :arith-assert-upper      80686
;  :arith-bound-prop        14542
;  :arith-conflicts         542
;  :arith-eq-adapter        73068
;  :arith-fixed-eqs         79759
;  :arith-offset-eqs        47377
;  :arith-pivots            51444
;  :conflicts               1923
;  :datatype-accessor-ax    266
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               30092
;  :del-clause              1784785
;  :final-checks            5
;  :max-generation          12
;  :max-memory              83.11
;  :memory                  77.28
;  :minimized-lits          231
;  :mk-bool-var             1681305
;  :mk-clause               1786286
;  :num-allocs              5379346
;  :num-checks              392
;  :propagations            386388
;  :quant-instantiations    617765
;  :restarts                2
;  :rlimit-count            19047749
;  :time                    0.00)
; Definitional axioms for inverse functions
(assert (forall ((i1@392@04 Int)) (!
  (implies
    (and (< i1@392@04 V@15@04) (<= 0 i1@392@04))
    (=
      (inv@393@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i1@392@04))
      i1@392@04))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i1@392@04))
  :qid |int-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@393@04 r) V@15@04) (<= 0 (inv@393@04 r)))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) (inv@393@04 r))
      r))
  :pattern ((inv@393@04 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@393@04 r) V@15@04) (<= 0 (inv@393@04 r)))
    ($FVF.loc_int ($FVF.lookup_int (as sm@394@04  $FVF<Int>) r) r))
  :pattern ((inv@393@04 r))
  )))
; Precomputing data for removing quantified permissions
(define-fun pTaken@395@04 ((r $Ref)) $Perm
  (ite
    (and (< (inv@393@04 r) V@15@04) (<= 0 (inv@393@04 r)))
    ($Perm.min
      (ite
        (and (< (inv@308@04 r) V@15@04) (<= 0 (inv@308@04 r)))
        $Perm.Write
        $Perm.No)
      $Perm.Write)
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 500)
(push) ; 11
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and (< (inv@308@04 r) V@15@04) (<= 0 (inv@308@04 r)))
        $Perm.Write
        $Perm.No)
      (pTaken@395@04 r))
    $Perm.No)
  
  ))))
(check-sat)
; unsat
(pop) ; 11
; 0.04s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               561501
;  :arith-add-rows          260077
;  :arith-assert-diseq      5018
;  :arith-assert-lower      95980
;  :arith-assert-upper      80835
;  :arith-bound-prop        14577
;  :arith-conflicts         543
;  :arith-eq-adapter        73221
;  :arith-fixed-eqs         79927
;  :arith-offset-eqs        47515
;  :arith-pivots            51592
;  :conflicts               1944
;  :datatype-accessor-ax    266
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               30349
;  :del-clause              1795191
;  :final-checks            5
;  :max-generation          12
;  :max-memory              83.11
;  :memory                  75.54
;  :minimized-lits          231
;  :mk-bool-var             1691018
;  :mk-clause               1796692
;  :num-allocs              5410115
;  :num-checks              394
;  :propagations            387510
;  :quant-instantiations    619914
;  :restarts                2
;  :rlimit-count            19166443
;  :time                    0.04)
; Intermediate check if already taken enough permissions
(push) ; 11
(assert (not (forall ((r $Ref)) (!
  (implies
    (and (< (inv@393@04 r) V@15@04) (<= 0 (inv@393@04 r)))
    (= (- $Perm.Write (pTaken@395@04 r)) $Perm.No))
  
  ))))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               561587
;  :arith-add-rows          260141
;  :arith-assert-diseq      5020
;  :arith-assert-lower      96005
;  :arith-assert-upper      80851
;  :arith-bound-prop        14579
;  :arith-conflicts         544
;  :arith-eq-adapter        73240
;  :arith-fixed-eqs         79939
;  :arith-offset-eqs        47518
;  :arith-pivots            51605
;  :conflicts               1945
;  :datatype-accessor-ax    266
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               30349
;  :del-clause              1795441
;  :final-checks            5
;  :max-generation          12
;  :max-memory              83.11
;  :memory                  75.54
;  :minimized-lits          231
;  :mk-bool-var             1691363
;  :mk-clause               1796942
;  :num-allocs              5411368
;  :num-checks              395
;  :propagations            387520
;  :quant-instantiations    620022
;  :restarts                2
;  :rlimit-count            19171467
;  :time                    0.00)
; Final check if taken enough permissions
; Done removing quantified permissions
; Definitional axioms for snapshot map values
; [eval] valid_graph_vertices(this, P, V)
(push) ; 11
; [eval] this != null
; [eval] p != (None(): option[array])
; [eval] (None(): option[array])
; [eval] alen(opt_get1(p)) == V
; [eval] alen(opt_get1(p))
; [eval] opt_get1(p)
(push) ; 12
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 12
; Joined path conditions
(declare-const i1@396@04 Int)
(push) ; 12
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 13
; [then-branch: 220 | 0 <= i1@396@04 | live]
; [else-branch: 220 | !(0 <= i1@396@04) | live]
(push) ; 14
; [then-branch: 220 | 0 <= i1@396@04]
(assert (<= 0 i1@396@04))
; [eval] i1 < V
(pop) ; 14
(push) ; 14
; [else-branch: 220 | !(0 <= i1@396@04)]
(assert (not (<= 0 i1@396@04)))
(pop) ; 14
(pop) ; 13
; Joined path conditions
; Joined path conditions
(assert (and (< i1@396@04 V@15@04) (<= 0 i1@396@04)))
(declare-const $k@397@04 $Perm)
(assert ($Perm.isReadVar $k@397@04 $Perm.Write))
; [eval] aloc(opt_get1(p), i1)
; [eval] opt_get1(p)
(push) ; 13
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 13
; Joined path conditions
(push) ; 13
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 14
(assert (not (< i1@396@04 (alen<Int> (opt_get1 $Snap.unit P@14@04)))))
(check-sat)
; unsat
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               561587
;  :arith-add-rows          260142
;  :arith-assert-diseq      5021
;  :arith-assert-lower      96009
;  :arith-assert-upper      80852
;  :arith-bound-prop        14579
;  :arith-conflicts         544
;  :arith-eq-adapter        73241
;  :arith-fixed-eqs         79939
;  :arith-offset-eqs        47518
;  :arith-pivots            51606
;  :conflicts               1945
;  :datatype-accessor-ax    266
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               30349
;  :del-clause              1795441
;  :final-checks            5
;  :max-generation          12
;  :max-memory              83.11
;  :memory                  75.55
;  :minimized-lits          231
;  :mk-bool-var             1691369
;  :mk-clause               1796944
;  :num-allocs              5411544
;  :num-checks              396
;  :propagations            387521
;  :quant-instantiations    620022
;  :restarts                2
;  :rlimit-count            19171806)
(assert (< i1@396@04 (alen<Int> (opt_get1 $Snap.unit P@14@04))))
(pop) ; 13
; Joined path conditions
(assert (< i1@396@04 (alen<Int> (opt_get1 $Snap.unit P@14@04))))
(pop) ; 12
(declare-fun inv@398@04 ($Ref) Int)
; Nested auxiliary terms: globals
(assert ($Perm.isReadVar $k@397@04 $Perm.Write))
; Nested auxiliary terms: non-globals
(assert (forall ((i1@396@04 Int)) (!
  (< i1@396@04 (alen<Int> (opt_get1 $Snap.unit P@14@04)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i1@396@04))
  :qid |int-aux|)))
(push) ; 12
(assert (not (forall ((i1@396@04 Int)) (!
  (implies
    (and (< i1@396@04 V@15@04) (<= 0 i1@396@04))
    (or (= $k@397@04 $Perm.No) (< $Perm.No $k@397@04)))
  
  ))))
(check-sat)
; unsat
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               561587
;  :arith-add-rows          260143
;  :arith-assert-diseq      5022
;  :arith-assert-lower      96011
;  :arith-assert-upper      80853
;  :arith-bound-prop        14579
;  :arith-conflicts         544
;  :arith-eq-adapter        73242
;  :arith-fixed-eqs         79939
;  :arith-offset-eqs        47518
;  :arith-pivots            51607
;  :conflicts               1946
;  :datatype-accessor-ax    266
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               30349
;  :del-clause              1795443
;  :final-checks            5
;  :max-generation          12
;  :max-memory              83.11
;  :memory                  75.54
;  :minimized-lits          231
;  :mk-bool-var             1691376
;  :mk-clause               1796946
;  :num-allocs              5411975
;  :num-checks              397
;  :propagations            387522
;  :quant-instantiations    620022
;  :restarts                2
;  :rlimit-count            19172359)
(declare-const sm@399@04 $FVF<Int>)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@308@04 r) V@15@04) (<= 0 (inv@308@04 r)))
    (=
      ($FVF.lookup_int (as sm@399@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04)))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@399@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04)))))))))))) r))
  :qid |qp.fvfValDef279|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@305@04 r) V@15@04) (<= 0 (inv@305@04 r)))
        (< (inv@304@04 r) V@15@04))
      (<= 0 (inv@304@04 r)))
    (=
      ($FVF.lookup_int (as sm@399@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@399@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04))))))))) r))
  :qid |qp.fvfValDef280|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04)))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@399@04  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef281|)))
; Check receiver injectivity
(push) ; 12
(assert (not (forall ((i11@396@04 Int) (i12@396@04 Int)) (!
  (implies
    (and
      (and
        (and
          (and (< i11@396@04 V@15@04) (<= 0 i11@396@04))
          ($FVF.loc_int ($FVF.lookup_int (as sm@399@04  $FVF<Int>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit P@14@04) i11@396@04)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit P@14@04) i11@396@04)))
        (< $Perm.No $k@397@04))
      (and
        (and
          (and (< i12@396@04 V@15@04) (<= 0 i12@396@04))
          ($FVF.loc_int ($FVF.lookup_int (as sm@399@04  $FVF<Int>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit P@14@04) i12@396@04)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit P@14@04) i12@396@04)))
        (< $Perm.No $k@397@04))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i11@396@04)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i12@396@04)))
    (= i11@396@04 i12@396@04))
  
  :qid |int-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               561630
;  :arith-add-rows          260152
;  :arith-assert-diseq      5023
;  :arith-assert-lower      96015
;  :arith-assert-upper      80853
;  :arith-bound-prop        14579
;  :arith-conflicts         544
;  :arith-eq-adapter        73243
;  :arith-fixed-eqs         79939
;  :arith-offset-eqs        47518
;  :arith-pivots            51609
;  :conflicts               1947
;  :datatype-accessor-ax    266
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               30349
;  :del-clause              1795454
;  :final-checks            5
;  :max-generation          12
;  :max-memory              83.11
;  :memory                  75.52
;  :minimized-lits          231
;  :mk-bool-var             1691443
;  :mk-clause               1796957
;  :num-allocs              5413080
;  :num-checks              398
;  :propagations            387524
;  :quant-instantiations    620090
;  :restarts                2
;  :rlimit-count            19175865)
; Definitional axioms for inverse functions
(assert (forall ((i1@396@04 Int)) (!
  (implies
    (and (and (< i1@396@04 V@15@04) (<= 0 i1@396@04)) (< $Perm.No $k@397@04))
    (=
      (inv@398@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i1@396@04))
      i1@396@04))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i1@396@04))
  :qid |int-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and (< (inv@398@04 r) V@15@04) (<= 0 (inv@398@04 r)))
      (< $Perm.No $k@397@04))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) (inv@398@04 r))
      r))
  :pattern ((inv@398@04 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@398@04 r) V@15@04) (<= 0 (inv@398@04 r)))
    ($FVF.loc_int ($FVF.lookup_int (as sm@399@04  $FVF<Int>) r) r))
  :pattern ((inv@398@04 r))
  )))
; Precomputing data for removing quantified permissions
(define-fun pTaken@400@04 ((r $Ref)) $Perm
  (ite
    (and (< (inv@398@04 r) V@15@04) (<= 0 (inv@398@04 r)))
    ($Perm.min
      (ite
        (and (< (inv@308@04 r) V@15@04) (<= 0 (inv@308@04 r)))
        $Perm.Write
        $Perm.No)
      $k@397@04)
    $Perm.No))
(define-fun pTaken@401@04 ((r $Ref)) $Perm
  (ite
    (and (< (inv@398@04 r) V@15@04) (<= 0 (inv@398@04 r)))
    ($Perm.min
      (ite
        (and
          (and
            (and (< (inv@305@04 r) V@15@04) (<= 0 (inv@305@04 r)))
            (< (inv@304@04 r) V@15@04))
          (<= 0 (inv@304@04 r)))
        $Perm.Write
        $Perm.No)
      (- $k@397@04 (pTaken@400@04 r)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Constrain original permissions $k@397@04
(assert (forall ((r $Ref)) (!
  (implies
    (not
      (=
        (ite
          (and (< (inv@308@04 r) V@15@04) (<= 0 (inv@308@04 r)))
          $Perm.Write
          $Perm.No)
        $Perm.No))
    (ite
      (and (< (inv@308@04 r) V@15@04) (<= 0 (inv@308@04 r)))
      (<
        (ite
          (and (< (inv@398@04 r) V@15@04) (<= 0 (inv@398@04 r)))
          $k@397@04
          $Perm.No)
        $Perm.Write)
      (<
        (ite
          (and (< (inv@398@04 r) V@15@04) (<= 0 (inv@398@04 r)))
          $k@397@04
          $Perm.No)
        $Perm.No)))
  :pattern ((inv@308@04 r))
  :pattern ((inv@398@04 r))
  :qid |qp.srp282|)))
; Intermediate check if already taken enough permissions
(set-option :timeout 500)
(push) ; 12
(assert (not (forall ((r $Ref)) (!
  (implies
    (and (< (inv@398@04 r) V@15@04) (<= 0 (inv@398@04 r)))
    (= (- $k@397@04 (pTaken@400@04 r)) $Perm.No))
  
  ))))
(check-sat)
; unsat
(pop) ; 12
; 0.04s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               562661
;  :arith-add-rows          261227
;  :arith-assert-diseq      5048
;  :arith-assert-lower      96190
;  :arith-assert-upper      80974
;  :arith-bound-prop        14612
;  :arith-conflicts         547
;  :arith-eq-adapter        73365
;  :arith-fixed-eqs         80076
;  :arith-offset-eqs        47595
;  :arith-pivots            51692
;  :conflicts               1969
;  :datatype-accessor-ax    266
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               30577
;  :del-clause              1804017
;  :final-checks            5
;  :max-generation          12
;  :max-memory              83.11
;  :memory                  75.54
;  :minimized-lits          231
;  :mk-bool-var             1698379
;  :mk-clause               1805518
;  :num-allocs              5436468
;  :num-checks              400
;  :propagations            388653
;  :quant-instantiations    621832
;  :restarts                2
;  :rlimit-count            19282763
;  :time                    0.04)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@402@04 $FVF<Int>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (iff
    (Set_in r ($FVF.domain_int (as sm@402@04  $FVF<Int>)))
    (and
      (and (< (inv@398@04 r) V@15@04) (<= 0 (inv@398@04 r)))
      (< $Perm.No $k@397@04)))
  :pattern ((Set_in r ($FVF.domain_int (as sm@402@04  $FVF<Int>))))
  :qid |qp.fvfDomDef286|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@398@04 r) V@15@04) (<= 0 (inv@398@04 r)))
        (< $Perm.No $k@397@04))
      (and (< (inv@308@04 r) V@15@04) (<= 0 (inv@308@04 r))))
    (=
      ($FVF.lookup_int (as sm@402@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04)))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@402@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04)))))))))))) r))
  :qid |qp.fvfValDef283|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@398@04 r) V@15@04) (<= 0 (inv@398@04 r)))
        (< $Perm.No $k@397@04))
      (and
        (and
          (and (< (inv@305@04 r) V@15@04) (<= 0 (inv@305@04 r)))
          (< (inv@304@04 r) V@15@04))
        (<= 0 (inv@304@04 r))))
    (=
      ($FVF.lookup_int (as sm@402@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@402@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04))))))))) r))
  :qid |qp.fvfValDef284|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04)))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@402@04  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef285|)))
(pop) ; 11
; Joined path conditions
(assert ($Perm.isReadVar $k@397@04 $Perm.Write))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@308@04 r) V@15@04) (<= 0 (inv@308@04 r)))
    (=
      ($FVF.lookup_int (as sm@399@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04)))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@399@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04)))))))))))) r))
  :qid |qp.fvfValDef279|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@305@04 r) V@15@04) (<= 0 (inv@305@04 r)))
        (< (inv@304@04 r) V@15@04))
      (<= 0 (inv@304@04 r)))
    (=
      ($FVF.lookup_int (as sm@399@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@399@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04))))))))) r))
  :qid |qp.fvfValDef280|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04)))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@399@04  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef281|)))
(assert (forall ((i1@396@04 Int)) (!
  (implies
    (and (and (< i1@396@04 V@15@04) (<= 0 i1@396@04)) (< $Perm.No $k@397@04))
    (=
      (inv@398@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i1@396@04))
      i1@396@04))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i1@396@04))
  :qid |int-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and (< (inv@398@04 r) V@15@04) (<= 0 (inv@398@04 r)))
      (< $Perm.No $k@397@04))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) (inv@398@04 r))
      r))
  :pattern ((inv@398@04 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (iff
    (Set_in r ($FVF.domain_int (as sm@402@04  $FVF<Int>)))
    (and
      (and (< (inv@398@04 r) V@15@04) (<= 0 (inv@398@04 r)))
      (< $Perm.No $k@397@04)))
  :pattern ((Set_in r ($FVF.domain_int (as sm@402@04  $FVF<Int>))))
  :qid |qp.fvfDomDef286|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@398@04 r) V@15@04) (<= 0 (inv@398@04 r)))
        (< $Perm.No $k@397@04))
      (and (< (inv@308@04 r) V@15@04) (<= 0 (inv@308@04 r))))
    (=
      ($FVF.lookup_int (as sm@402@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04)))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@402@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04)))))))))))) r))
  :qid |qp.fvfValDef283|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@398@04 r) V@15@04) (<= 0 (inv@398@04 r)))
        (< $Perm.No $k@397@04))
      (and
        (and
          (and (< (inv@305@04 r) V@15@04) (<= 0 (inv@305@04 r)))
          (< (inv@304@04 r) V@15@04))
        (<= 0 (inv@304@04 r))))
    (=
      ($FVF.lookup_int (as sm@402@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@402@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04))))))))) r))
  :qid |qp.fvfValDef284|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04)))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@402@04  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef285|)))
(assert (and
  (forall ((i1@396@04 Int)) (!
    (< i1@396@04 (alen<Int> (opt_get1 $Snap.unit P@14@04)))
    :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i1@396@04))
    :qid |int-aux|))
  (forall ((r $Ref)) (!
    (implies
      (and (< (inv@398@04 r) V@15@04) (<= 0 (inv@398@04 r)))
      ($FVF.loc_int ($FVF.lookup_int (as sm@399@04  $FVF<Int>) r) r))
    :pattern ((inv@398@04 r))
    ))
  (forall ((r $Ref)) (!
    (implies
      (not
        (=
          (ite
            (and (< (inv@308@04 r) V@15@04) (<= 0 (inv@308@04 r)))
            $Perm.Write
            $Perm.No)
          $Perm.No))
      (ite
        (and (< (inv@308@04 r) V@15@04) (<= 0 (inv@308@04 r)))
        (<
          (ite
            (and (< (inv@398@04 r) V@15@04) (<= 0 (inv@398@04 r)))
            $k@397@04
            $Perm.No)
          $Perm.Write)
        (<
          (ite
            (and (< (inv@398@04 r) V@15@04) (<= 0 (inv@398@04 r)))
            $k@397@04
            $Perm.No)
          $Perm.No)))
    :pattern ((inv@308@04 r))
    :pattern ((inv@398@04 r))
    :qid |qp.srp282|))))
(set-option :timeout 0)
(push) ; 11
(assert (not (valid_graph_vertices ($Snap.combine
  $Snap.unit
  ($Snap.combine
    $Snap.unit
    ($Snap.combine
      $Snap.unit
      ($SortWrappers.$FVF<Int>To$Snap (as sm@402@04  $FVF<Int>))))) this@9@04 P@14@04 V@15@04)))
(check-sat)
; unsat
(pop) ; 11
; 43.49s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1834644
;  :arith-add-rows          575591
;  :arith-assert-diseq      12940
;  :arith-assert-lower      298437
;  :arith-assert-upper      254242
;  :arith-bound-prop        21059
;  :arith-conflicts         663
;  :arith-eq-adapter        219727
;  :arith-fixed-eqs         272802
;  :arith-offset-eqs        205031
;  :arith-pivots            103564
;  :conflicts               2180
;  :datatype-accessor-ax    305
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               75729
;  :del-clause              7568623
;  :final-checks            5
;  :max-generation          13
;  :max-memory              144.52
;  :memory                  139.68
;  :minimized-lits          271
;  :mk-bool-var             7119172
;  :mk-clause               7570126
;  :num-allocs              17640058
;  :num-checks              401
;  :propagations            1987868
;  :quant-instantiations    3048202
;  :restarts                3
;  :rlimit-count            65075211
;  :time                    43.48)
(assert (valid_graph_vertices ($Snap.combine
  $Snap.unit
  ($Snap.combine
    $Snap.unit
    ($Snap.combine
      $Snap.unit
      ($SortWrappers.$FVF<Int>To$Snap (as sm@402@04  $FVF<Int>))))) this@9@04 P@14@04 V@15@04))
; Loop head block: Execute statements of loop head block (in invariant state)
(push) ; 11
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@369@04 r) V@15@04) (<= 0 (inv@369@04 r)))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) (inv@369@04 r))
      r))
  :pattern ((inv@369@04 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@369@04 r) V@15@04) (<= 0 (inv@369@04 r)))
    (=
      ($FVF.lookup_int (as sm@370@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04)))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@370@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04)))))))))))))) r))
  :qid |qp.fvfValDef265|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@366@04 r) V@15@04) (<= 0 (inv@366@04 r)))
        (< (inv@365@04 r) V@15@04))
      (<= 0 (inv@365@04 r)))
    (=
      ($FVF.lookup_int (as sm@370@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@370@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))))))) r))
  :qid |qp.fvfValDef266|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04)))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@370@04  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef267|)))
(assert ($Perm.isReadVar $k@372@04 $Perm.Write))
(assert (forall ((i1@371@04 Int)) (!
  (implies
    (and (and (< i1@371@04 V@15@04) (<= 0 i1@371@04)) (< $Perm.No $k@372@04))
    (=
      (inv@373@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i1@371@04))
      i1@371@04))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i1@371@04))
  :qid |int-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and (< (inv@373@04 r) V@15@04) (<= 0 (inv@373@04 r)))
      (< $Perm.No $k@372@04))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) (inv@373@04 r))
      r))
  :pattern ((inv@373@04 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (iff
    (Set_in r ($FVF.domain_int (as sm@376@04  $FVF<Int>)))
    (and
      (and (< (inv@373@04 r) V@15@04) (<= 0 (inv@373@04 r)))
      (< $Perm.No $k@372@04)))
  :pattern ((Set_in r ($FVF.domain_int (as sm@376@04  $FVF<Int>))))
  :qid |qp.fvfDomDef272|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@373@04 r) V@15@04) (<= 0 (inv@373@04 r)))
        (< $Perm.No $k@372@04))
      (and (< (inv@369@04 r) V@15@04) (<= 0 (inv@369@04 r))))
    (=
      ($FVF.lookup_int (as sm@376@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04)))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@376@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04)))))))))))))) r))
  :qid |qp.fvfValDef269|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@373@04 r) V@15@04) (<= 0 (inv@373@04 r)))
        (< $Perm.No $k@372@04))
      (and
        (and
          (and (< (inv@366@04 r) V@15@04) (<= 0 (inv@366@04 r)))
          (< (inv@365@04 r) V@15@04))
        (<= 0 (inv@365@04 r))))
    (=
      ($FVF.lookup_int (as sm@376@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@376@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))))))) r))
  :qid |qp.fvfValDef270|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04)))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@376@04  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef271|)))
(assert (forall ((i1@368@04 Int)) (!
  (implies
    (and (< i1@368@04 V@15@04) (<= 0 i1@368@04))
    (=
      (inv@369@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i1@368@04))
      i1@368@04))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i1@368@04))
  )))
(assert (forall ((i1@368@04 Int)) (!
  (implies
    (and (< i1@368@04 V@15@04) (<= 0 i1@368@04))
    (not
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i1@368@04)
        $Ref.null)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i1@368@04))
  :qid |int-permImpliesNonNull|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@369@04 r) V@15@04) (<= 0 (inv@369@04 r)))
    ($FVF.loc_int ($FVF.lookup_int (as sm@370@04  $FVF<Int>) r) r))
  :pattern ((inv@369@04 r))
  )))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04)))))))))))))
  $Snap.unit))
(assert (forall ((i1@371@04 Int)) (!
  (< i1@371@04 (alen<Int> (opt_get1 $Snap.unit P@14@04)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i1@371@04))
  :qid |int-aux|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@373@04 r) V@15@04) (<= 0 (inv@373@04 r)))
    ($FVF.loc_int ($FVF.lookup_int (as sm@370@04  $FVF<Int>) r) r))
  :pattern ((inv@373@04 r))
  )))
(assert (forall ((r $Ref)) (!
  (implies
    (not
      (=
        (ite
          (and (< (inv@369@04 r) V@15@04) (<= 0 (inv@369@04 r)))
          $Perm.Write
          $Perm.No)
        $Perm.No))
    (ite
      (and (< (inv@369@04 r) V@15@04) (<= 0 (inv@369@04 r)))
      (<
        (ite
          (and (< (inv@373@04 r) V@15@04) (<= 0 (inv@373@04 r)))
          $k@372@04
          $Perm.No)
        $Perm.Write)
      (<
        (ite
          (and (< (inv@373@04 r) V@15@04) (<= 0 (inv@373@04 r)))
          $k@372@04
          $Perm.No)
        $Perm.No)))
  :pattern ((inv@369@04 r))
  :pattern ((inv@373@04 r))
  :qid |qp.srp268|)))
(assert (valid_graph_vertices ($Snap.combine
  $Snap.unit
  ($Snap.combine
    $Snap.unit
    ($Snap.combine
      $Snap.unit
      ($SortWrappers.$FVF<Int>To$Snap (as sm@376@04  $FVF<Int>))))) this@9@04 P@14@04 V@15@04))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@366@04 r) V@15@04) (<= 0 (inv@366@04 r)))
        (< (inv@365@04 r) V@15@04))
      (<= 0 (inv@365@04 r)))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@358@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) (inv@365@04 r)))) (inv@366@04 r))
      r))
  :pattern ((inv@365@04 r))
  :pattern ((inv@366@04 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@366@04 r) V@15@04) (<= 0 (inv@366@04 r)))
        (< (inv@365@04 r) V@15@04))
      (<= 0 (inv@365@04 r)))
    (=
      ($FVF.lookup_int (as sm@367@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@367@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))))))) r))
  :qid |qp.fvfValDef263|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))))))) r) r)
  :pattern (($FVF.lookup_int (as sm@367@04  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef264|)))
(assert (forall ((i1@363@04 Int) (j@364@04 Int)) (!
  (implies
    (and
      (and (and (< j@364@04 V@15@04) (<= 0 j@364@04)) (< i1@363@04 V@15@04))
      (<= 0 i1@363@04))
    (and
      (=
        (inv@365@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@358@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@363@04))) j@364@04))
        i1@363@04)
      (=
        (inv@366@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@358@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@363@04))) j@364@04))
        j@364@04)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@358@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@363@04))) j@364@04))
  )))
(assert (forall ((i1@363@04 Int) (j@364@04 Int)) (!
  (implies
    (and
      (and (and (< j@364@04 V@15@04) (<= 0 j@364@04)) (< i1@363@04 V@15@04))
      (<= 0 i1@363@04))
    (not
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@358@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@363@04))) j@364@04)
        $Ref.null)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@358@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@363@04))) j@364@04))
  :qid |int-permImpliesNonNull|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@366@04 r) V@15@04) (<= 0 (inv@366@04 r)))
        (< (inv@365@04 r) V@15@04))
      (<= 0 (inv@365@04 r)))
    ($FVF.loc_int ($FVF.lookup_int (as sm@367@04  $FVF<Int>) r) r))
  :pattern ((inv@365@04 r) (inv@366@04 r))
  )))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04)))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04)))))))))))
  $Snap.unit))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04)))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04)))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))))))))
  $Snap.unit))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04)))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))))))))))))
(assert (forall ((i1@368@04 Int)) (!
  (< i1@368@04 (alen<Int> (opt_get1 $Snap.unit P@14@04)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i1@368@04))
  :qid |int-aux|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and (< (inv@357@04 r) V@15@04) (<= 0 (inv@357@04 r)))
      (< $Perm.No $k@356@04))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) (inv@357@04 r))
      r))
  :pattern ((inv@357@04 r))
  :qid |option$array$-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@357@04 r) V@15@04) (<= 0 (inv@357@04 r)))
      (< $Perm.No $k@356@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@358@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@358@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))) r))
  :qid |qp.fvfValDef261|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))) r) r)
  :pattern (($FVF.lookup_option$array$ (as sm@358@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef262|)))
(assert (forall ((i1@355@04 Int)) (!
  (implies
    (and (and (< i1@355@04 V@15@04) (<= 0 i1@355@04)) (< $Perm.No $k@356@04))
    (=
      (inv@357@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@355@04))
      i1@355@04))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@355@04))
  )))
(assert (forall ((i1@355@04 Int)) (!
  (<= $Perm.No $k@356@04)
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@355@04))
  :qid |option$array$-permAtLeastZero|)))
(assert (forall ((i1@355@04 Int)) (!
  (<= $k@356@04 $Perm.Write)
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@355@04))
  :qid |option$array$-permAtMostOne|)))
(assert (forall ((i1@355@04 Int)) (!
  (implies
    (and (and (< i1@355@04 V@15@04) (<= 0 i1@355@04)) (< $Perm.No $k@356@04))
    (not
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@355@04)
        $Ref.null)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@355@04))
  :qid |option$array$-permImpliesNonNull|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@357@04 r) V@15@04) (<= 0 (inv@357@04 r)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@358@04  $FVF<option<array>>) r) r))
  :pattern ((inv@357@04 r))
  )))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04)))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04)))))))
  $Snap.unit))
(assert (forall ((i1@359@04 Int)) (!
  (implies
    (and (< i1@359@04 V@15@04) (<= 0 i1@359@04))
    (and
      (< i1@359@04 V@15@04)
      (<= 0 i1@359@04)
      (< i1@359@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@358@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@359@04)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@359@04))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@359@04))
  :qid |prog.l<no position>-aux|)))
(assert (forall ((i1@359@04 Int)) (!
  (implies
    (and (< i1@359@04 V@15@04) (<= 0 i1@359@04))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@358@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@359@04))
        (as None<option<array>>  option<array>))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@359@04))
  :qid |prog.l<no position>|)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04)))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04)))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))))
  $Snap.unit))
(assert (forall ((i1@360@04 Int)) (!
  (implies
    (and (< i1@360@04 V@15@04) (<= 0 i1@360@04))
    (and
      (< i1@360@04 V@15@04)
      (<= 0 i1@360@04)
      (< i1@360@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@358@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@360@04)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@360@04))
      (not
        (=
          ($FVF.lookup_option$array$ (as sm@358@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@360@04))
          (as None<option<array>>  option<array>)))))
  :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@358@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@360@04)))))
  :qid |prog.l<no position>-aux|)))
(assert (forall ((i1@360@04 Int)) (!
  (implies
    (and (< i1@360@04 V@15@04) (<= 0 i1@360@04))
    (=
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@358@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@360@04))))
      V@15@04))
  :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@358@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@360@04)))))
  :qid |prog.l<no position>|)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04)))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04)))))))))
  $Snap.unit))
(assert (forall ((i1@361@04 Int)) (!
  (forall ((i2@362@04 Int)) (!
    (and
      (implies
        (<= 0 i1@361@04)
        (and
          (<= 0 i1@361@04)
          (implies
            (< i1@361@04 V@15@04)
            (and
              (< i1@361@04 V@15@04)
              (implies
                (<= 0 i2@362@04)
                (and
                  (<= 0 i2@362@04)
                  (implies
                    (< i2@362@04 V@15@04)
                    (and
                      (< i2@362@04 V@15@04)
                      (< i1@361@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
                      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@358@04  $FVF<option<array>>) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@361@04)) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@361@04))
                      (< i2@362@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
                      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@358@04  $FVF<option<array>>) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@362@04)) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@362@04))))))))))
      (implies
        (and
          (and
            (and
              (and
                (=
                  ($FVF.lookup_option$array$ (as sm@358@04  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@361@04))
                  ($FVF.lookup_option$array$ (as sm@358@04  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@362@04)))
                (< i2@362@04 V@15@04))
              (<= 0 i2@362@04))
            (< i1@361@04 V@15@04))
          (<= 0 i1@361@04))
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@358@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@361@04))
            ($FVF.lookup_option$array$ (as sm@358@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@362@04)))
          (< i2@362@04 V@15@04)
          (<= 0 i2@362@04)
          (< i1@361@04 V@15@04)
          (<= 0 i1@361@04))))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@362@04))
    :qid |prog.l<no position>-aux|))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@361@04))
  :qid |prog.l<no position>-aux|)))
(assert (forall ((i1@361@04 Int)) (!
  (forall ((i2@362@04 Int)) (!
    (implies
      (and
        (and
          (and
            (and
              (=
                ($FVF.lookup_option$array$ (as sm@358@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@361@04))
                ($FVF.lookup_option$array$ (as sm@358@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@362@04)))
              (< i2@362@04 V@15@04))
            (<= 0 i2@362@04))
          (< i1@361@04 V@15@04))
        (<= 0 i1@361@04))
      (= i1@361@04 i2@362@04))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@362@04))
    :qid |prog.l<no position>|))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@361@04))
  :qid |prog.l<no position>|)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04)))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04)))))))))))))
(assert (forall ((i1@363@04 Int) (j@364@04 Int)) (!
  (and
    (< i1@363@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@358@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@363@04)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@363@04))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@358@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@363@04))
        (as None<option<array>>  option<array>)))
    (<
      j@364@04
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@358@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@363@04))))))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@358@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@363@04))) j@364@04))
  :qid |int-aux|)))
(assert ($Perm.isReadVar $k@356@04 $Perm.Write))
(assert (= $t@354@04 ($Snap.combine ($Snap.first $t@354@04) ($Snap.second $t@354@04))))
(assert (= ($Snap.first $t@354@04) $Snap.unit))
(assert (=
  ($Snap.second $t@354@04)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@354@04))
    ($Snap.second ($Snap.second $t@354@04)))))
(assert (= ($Snap.first ($Snap.second $t@354@04)) $Snap.unit))
(assert (<= 0 v@353@04))
(assert (=
  ($Snap.second ($Snap.second $t@354@04))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second $t@354@04)))
    ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))
(assert (= ($Snap.first ($Snap.second ($Snap.second $t@354@04))) $Snap.unit))
(assert (< v@353@04 V@15@04))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second $t@354@04)))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@354@04))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04)))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@354@04))))
  $Snap.unit))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04)))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04)))))
  $Snap.unit))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04)))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04)))))))))
(assert (forall ((i1@355@04 Int)) (!
  (< i1@355@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@355@04))
  :qid |option$array$-aux|)))
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
(set-option :timeout 10)
(check-sat)
; unknown
; Loop head block: Follow loop-internal edges
; [eval] v != s
(push) ; 12
(assert (not (= v@353@04 s@12@04)))
(check-sat)
; unknown
(pop) ; 12
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1835249
;  :arith-add-rows          575948
;  :arith-assert-diseq      12959
;  :arith-assert-lower      298557
;  :arith-assert-upper      254327
;  :arith-bound-prop        21061
;  :arith-conflicts         663
;  :arith-eq-adapter        219803
;  :arith-fixed-eqs         272899
;  :arith-offset-eqs        205060
;  :arith-pivots            103593
;  :conflicts               2180
;  :datatype-accessor-ax    324
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               75810
;  :del-clause              7572279
;  :final-checks            5
;  :max-generation          13
;  :max-memory              144.52
;  :memory                  135.67
;  :minimized-lits          271
;  :mk-bool-var             7122587
;  :mk-clause               7574032
;  :num-allocs              17658762
;  :num-checks              404
;  :propagations            1988374
;  :quant-instantiations    3049241
;  :restarts                3
;  :rlimit-count            65148448
;  :time                    0.01)
(push) ; 12
(assert (not (not (= v@353@04 s@12@04))))
(check-sat)
; unknown
(pop) ; 12
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1835474
;  :arith-add-rows          576082
;  :arith-assert-diseq      12965
;  :arith-assert-lower      298619
;  :arith-assert-upper      254372
;  :arith-bound-prop        21061
;  :arith-conflicts         663
;  :arith-eq-adapter        219843
;  :arith-fixed-eqs         272955
;  :arith-offset-eqs        205078
;  :arith-pivots            103603
;  :conflicts               2180
;  :datatype-accessor-ax    324
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               75836
;  :del-clause              7573718
;  :final-checks            5
;  :max-generation          13
;  :max-memory              144.52
;  :memory                  134.92
;  :minimized-lits          271
;  :mk-bool-var             7123898
;  :mk-clause               7575471
;  :num-allocs              17663647
;  :num-checks              405
;  :propagations            1988614
;  :quant-instantiations    3049724
;  :restarts                3
;  :rlimit-count            65170870
;  :time                    0.01)
; [then-branch: 221 | v@353@04 != s@12@04 | live]
; [else-branch: 221 | v@353@04 == s@12@04 | live]
(push) ; 12
; [then-branch: 221 | v@353@04 != s@12@04]
(assert (not (= v@353@04 s@12@04)))
; [exec]
; u := aloc(opt_get1(P), v).int
; [eval] aloc(opt_get1(P), v)
; [eval] opt_get1(P)
(push) ; 13
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 13
; Joined path conditions
(push) ; 13
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 14
(assert (not (< v@353@04 (alen<Int> (opt_get1 $Snap.unit P@14@04)))))
(check-sat)
; unsat
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1835475
;  :arith-add-rows          576083
;  :arith-assert-diseq      12967
;  :arith-assert-lower      298619
;  :arith-assert-upper      254372
;  :arith-bound-prop        21061
;  :arith-conflicts         663
;  :arith-eq-adapter        219844
;  :arith-fixed-eqs         272955
;  :arith-offset-eqs        205078
;  :arith-pivots            103603
;  :conflicts               2180
;  :datatype-accessor-ax    324
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               75836
;  :del-clause              7573718
;  :final-checks            5
;  :max-generation          13
;  :max-memory              144.52
;  :memory                  134.92
;  :minimized-lits          271
;  :mk-bool-var             7123902
;  :mk-clause               7575475
;  :num-allocs              17663741
;  :num-checks              406
;  :propagations            1988614
;  :quant-instantiations    3049724
;  :restarts                3
;  :rlimit-count            65170967)
(assert (< v@353@04 (alen<Int> (opt_get1 $Snap.unit P@14@04))))
(pop) ; 13
; Joined path conditions
(assert (< v@353@04 (alen<Int> (opt_get1 $Snap.unit P@14@04))))
(declare-const sm@403@04 $FVF<Int>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@369@04 r) V@15@04) (<= 0 (inv@369@04 r)))
    (=
      ($FVF.lookup_int (as sm@403@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04)))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@403@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04)))))))))))))) r))
  :qid |qp.fvfValDef287|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@366@04 r) V@15@04) (<= 0 (inv@366@04 r)))
        (< (inv@365@04 r) V@15@04))
      (<= 0 (inv@365@04 r)))
    (=
      ($FVF.lookup_int (as sm@403@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@403@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))))))) r))
  :qid |qp.fvfValDef288|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04)))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@403@04  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef289|)))
(declare-const pm@404@04 $FPM)
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_int (as pm@404@04  $FPM) r)
    (+
      (ite
        (and (< (inv@369@04 r) V@15@04) (<= 0 (inv@369@04 r)))
        $Perm.Write
        $Perm.No)
      (ite
        (and
          (and
            (and (< (inv@366@04 r) V@15@04) (<= 0 (inv@366@04 r)))
            (< (inv@365@04 r) V@15@04))
          (<= 0 (inv@365@04 r)))
        $Perm.Write
        $Perm.No)))
  :pattern (($FVF.perm_int (as pm@404@04  $FPM) r))
  :qid |qp.resPrmSumDef290|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int (as sm@403@04  $FVF<Int>) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04)))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))))))) r) r))
  :pattern (($FVF.perm_int (as pm@404@04  $FPM) r))
  :qid |qp.resTrgDef291|)))
(assert ($FVF.loc_int ($FVF.lookup_int (as sm@403@04  $FVF<Int>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit P@14@04) v@353@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit P@14@04) v@353@04)))
(push) ; 13
(assert (not (<
  $Perm.No
  ($FVF.perm_int (as pm@404@04  $FPM) (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) v@353@04)))))
(check-sat)
; unsat
(pop) ; 13
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1835883
;  :arith-add-rows          576305
;  :arith-assert-diseq      12968
;  :arith-assert-lower      298677
;  :arith-assert-upper      254417
;  :arith-bound-prop        21106
;  :arith-conflicts         665
;  :arith-eq-adapter        219888
;  :arith-fixed-eqs         272990
;  :arith-offset-eqs        205078
;  :arith-pivots            103666
;  :conflicts               2185
;  :datatype-accessor-ax    324
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               75840
;  :del-clause              7574767
;  :final-checks            5
;  :max-generation          13
;  :max-memory              144.52
;  :memory                  134.55
;  :minimized-lits          271
;  :mk-bool-var             7125845
;  :mk-clause               7576953
;  :num-allocs              17669472
;  :num-checks              407
;  :propagations            1988787
;  :quant-instantiations    3050208
;  :restarts                3
;  :rlimit-count            65201508
;  :time                    0.01)
(declare-const u@405@04 Int)
(assert (=
  u@405@04
  ($FVF.lookup_int (as sm@403@04  $FVF<Int>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit P@14@04) v@353@04))))
; [exec]
; bottleneckPathFlow := (bottleneckPathFlow <= aloc(opt_get1(aloc(opt_get1(G), u).option$array$), v).int ? bottleneckPathFlow : aloc(opt_get1(aloc(opt_get1(G), u).option$array$), v).int)
; [eval] (bottleneckPathFlow <= aloc(opt_get1(aloc(opt_get1(G), u).option$array$), v).int ? bottleneckPathFlow : aloc(opt_get1(aloc(opt_get1(G), u).option$array$), v).int)
; [eval] bottleneckPathFlow <= aloc(opt_get1(aloc(opt_get1(G), u).option$array$), v).int
; [eval] aloc(opt_get1(aloc(opt_get1(G), u).option$array$), v)
; [eval] opt_get1(aloc(opt_get1(G), u).option$array$)
; [eval] aloc(opt_get1(G), u)
; [eval] opt_get1(G)
(push) ; 13
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 13
; Joined path conditions
(push) ; 13
; [eval] 0 <= i1
(push) ; 14
(assert (not (<= 0 u@405@04)))
(check-sat)
; unsat
(pop) ; 14
; 0.06s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1837313
;  :arith-add-rows          578473
;  :arith-assert-diseq      12999
;  :arith-assert-lower      298903
;  :arith-assert-upper      254567
;  :arith-bound-prop        21152
;  :arith-conflicts         669
;  :arith-eq-adapter        220006
;  :arith-fixed-eqs         273135
;  :arith-offset-eqs        205167
;  :arith-pivots            103741
;  :conflicts               2194
;  :datatype-accessor-ax    324
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               76438
;  :del-clause              7592802
;  :final-checks            5
;  :max-generation          13
;  :max-memory              144.52
;  :memory                  134.51
;  :minimized-lits          271
;  :mk-bool-var             7138579
;  :mk-clause               7594988
;  :num-allocs              17701388
;  :num-checks              408
;  :propagations            1990951
;  :quant-instantiations    3052989
;  :restarts                3
;  :rlimit-count            65353550
;  :time                    0.06)
(assert (<= 0 u@405@04))
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 14
(assert (not (< u@405@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))))
(check-sat)
; unsat
(pop) ; 14
; 0.07s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1838909
;  :arith-add-rows          580819
;  :arith-assert-diseq      13041
;  :arith-assert-lower      299185
;  :arith-assert-upper      254750
;  :arith-bound-prop        21222
;  :arith-conflicts         674
;  :arith-eq-adapter        220140
;  :arith-fixed-eqs         273297
;  :arith-offset-eqs        205317
;  :arith-pivots            103816
;  :conflicts               2204
;  :datatype-accessor-ax    324
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               77040
;  :del-clause              7610918
;  :final-checks            5
;  :max-generation          13
;  :max-memory              144.52
;  :memory                  134.42
;  :minimized-lits          271
;  :mk-bool-var             7151390
;  :mk-clause               7613104
;  :num-allocs              17729593
;  :num-checks              409
;  :propagations            1993251
;  :quant-instantiations    3055822
;  :restarts                3
;  :rlimit-count            65492984
;  :time                    0.07)
(assert (< u@405@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(pop) ; 13
; Joined path conditions
(assert (and (<= 0 u@405@04) (< u@405@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@358@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) u@405@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) u@405@04)))
(push) ; 13
(assert (not (ite
  (and
    (<
      (inv@357@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) u@405@04))
      V@15@04)
    (<=
      0
      (inv@357@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) u@405@04))))
  (< $Perm.No $k@356@04)
  false)))
(check-sat)
; unsat
(pop) ; 13
; 0.04s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1839870
;  :arith-add-rows          581753
;  :arith-assert-diseq      13062
;  :arith-assert-lower      299344
;  :arith-assert-upper      254850
;  :arith-bound-prop        21271
;  :arith-conflicts         677
;  :arith-eq-adapter        220230
;  :arith-fixed-eqs         273384
;  :arith-offset-eqs        205401
;  :arith-pivots            103862
;  :conflicts               2227
;  :datatype-accessor-ax    324
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               77348
;  :del-clause              7620922
;  :final-checks            5
;  :max-generation          13
;  :max-memory              144.52
;  :memory                  134.43
;  :minimized-lits          271
;  :mk-bool-var             7158815
;  :mk-clause               7623292
;  :num-allocs              17746511
;  :num-checks              410
;  :propagations            1994624
;  :quant-instantiations    3057532
;  :restarts                3
;  :rlimit-count            65581785
;  :time                    0.04)
(push) ; 13
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 14
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@358@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) u@405@04))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1839873
;  :arith-add-rows          581753
;  :arith-assert-diseq      13062
;  :arith-assert-lower      299344
;  :arith-assert-upper      254851
;  :arith-bound-prop        21271
;  :arith-conflicts         678
;  :arith-eq-adapter        220230
;  :arith-fixed-eqs         273384
;  :arith-offset-eqs        205401
;  :arith-pivots            103862
;  :conflicts               2228
;  :datatype-accessor-ax    324
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               77348
;  :del-clause              7620922
;  :final-checks            5
;  :max-generation          13
;  :max-memory              144.52
;  :memory                  134.43
;  :minimized-lits          271
;  :mk-bool-var             7158816
;  :mk-clause               7623292
;  :num-allocs              17746604
;  :num-checks              411
;  :propagations            1994655
;  :quant-instantiations    3057532
;  :restarts                3
;  :rlimit-count            65581926
;  :time                    0.00)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@358@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) u@405@04))
    (as None<option<array>>  option<array>))))
(pop) ; 13
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@358@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) u@405@04))
    (as None<option<array>>  option<array>))))
(push) ; 13
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 14
(assert (not (<
  v@353@04
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@358@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) u@405@04)))))))
(check-sat)
; unsat
(pop) ; 14
; 0.04s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1840954
;  :arith-add-rows          582919
;  :arith-assert-diseq      13081
;  :arith-assert-lower      299533
;  :arith-assert-upper      254969
;  :arith-bound-prop        21324
;  :arith-conflicts         682
;  :arith-eq-adapter        220343
;  :arith-fixed-eqs         273490
;  :arith-offset-eqs        205472
;  :arith-pivots            103943
;  :conflicts               2237
;  :datatype-accessor-ax    324
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               77659
;  :del-clause              7631137
;  :final-checks            5
;  :max-generation          13
;  :max-memory              144.52
;  :memory                  134.43
;  :minimized-lits          271
;  :mk-bool-var             7166403
;  :mk-clause               7633507
;  :num-allocs              17763418
;  :num-checks              412
;  :propagations            1996173
;  :quant-instantiations    3059247
;  :restarts                3
;  :rlimit-count            65673395
;  :time                    0.04)
(assert (<
  v@353@04
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@358@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) u@405@04))))))
(pop) ; 13
; Joined path conditions
(assert (<
  v@353@04
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@358@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) u@405@04))))))
(declare-const sm@406@04 $FVF<Int>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@369@04 r) V@15@04) (<= 0 (inv@369@04 r)))
    (=
      ($FVF.lookup_int (as sm@406@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04)))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@406@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04)))))))))))))) r))
  :qid |qp.fvfValDef292|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@366@04 r) V@15@04) (<= 0 (inv@366@04 r)))
        (< (inv@365@04 r) V@15@04))
      (<= 0 (inv@365@04 r)))
    (=
      ($FVF.lookup_int (as sm@406@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@406@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))))))) r))
  :qid |qp.fvfValDef293|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04)))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@406@04  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef294|)))
(declare-const pm@407@04 $FPM)
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_int (as pm@407@04  $FPM) r)
    (+
      (ite
        (and (< (inv@369@04 r) V@15@04) (<= 0 (inv@369@04 r)))
        $Perm.Write
        $Perm.No)
      (ite
        (and
          (and
            (and (< (inv@366@04 r) V@15@04) (<= 0 (inv@366@04 r)))
            (< (inv@365@04 r) V@15@04))
          (<= 0 (inv@365@04 r)))
        $Perm.Write
        $Perm.No)))
  :pattern (($FVF.perm_int (as pm@407@04  $FPM) r))
  :qid |qp.resPrmSumDef295|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int (as sm@406@04  $FVF<Int>) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04)))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))))))) r) r))
  :pattern (($FVF.perm_int (as pm@407@04  $FPM) r))
  :qid |qp.resTrgDef296|)))
(assert ($FVF.loc_int ($FVF.lookup_int (as sm@406@04  $FVF<Int>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@358@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) u@405@04))) v@353@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@358@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) u@405@04))) v@353@04)))
(push) ; 13
(assert (not (<
  $Perm.No
  ($FVF.perm_int (as pm@407@04  $FPM) (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@358@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) u@405@04))) v@353@04)))))
(check-sat)
; unsat
(pop) ; 13
; 0.07s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1842600
;  :arith-add-rows          584237
;  :arith-assert-diseq      13105
;  :arith-assert-lower      299777
;  :arith-assert-upper      255148
;  :arith-bound-prop        21412
;  :arith-conflicts         690
;  :arith-eq-adapter        220528
;  :arith-fixed-eqs         273633
;  :arith-offset-eqs        205605
;  :arith-pivots            104081
;  :conflicts               2252
;  :datatype-accessor-ax    324
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               78020
;  :del-clause              7642434
;  :final-checks            5
;  :max-generation          13
;  :max-memory              144.52
;  :memory                  134.46
;  :minimized-lits          271
;  :mk-bool-var             7175045
;  :mk-clause               7644835
;  :num-allocs              17783920
;  :num-checks              413
;  :propagations            1998260
;  :quant-instantiations    3061182
;  :restarts                3
;  :rlimit-count            65778613
;  :time                    0.07)
(push) ; 13
(set-option :timeout 10)
(push) ; 14
(assert (not (not
  (<=
    bottleneckPathFlow@352@04
    ($FVF.lookup_int (as sm@406@04  $FVF<Int>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@358@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) u@405@04))) v@353@04))))))
(check-sat)
; unknown
(pop) ; 14
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1842986
;  :arith-add-rows          584398
;  :arith-assert-diseq      13114
;  :arith-assert-lower      299861
;  :arith-assert-upper      255192
;  :arith-bound-prop        21457
;  :arith-conflicts         691
;  :arith-eq-adapter        220555
;  :arith-fixed-eqs         273656
;  :arith-offset-eqs        205658
;  :arith-pivots            104100
;  :conflicts               2257
;  :datatype-accessor-ax    324
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               78071
;  :del-clause              7644298
;  :final-checks            5
;  :max-generation          13
;  :max-memory              144.52
;  :memory                  134.46
;  :minimized-lits          271
;  :mk-bool-var             7176942
;  :mk-clause               7646699
;  :num-allocs              17787747
;  :num-checks              414
;  :propagations            1998461
;  :quant-instantiations    3061598
;  :restarts                3
;  :rlimit-count            65800529
;  :time                    0.01)
(push) ; 14
(assert (not (<=
  bottleneckPathFlow@352@04
  ($FVF.lookup_int (as sm@406@04  $FVF<Int>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@358@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) u@405@04))) v@353@04)))))
(check-sat)
; unknown
(pop) ; 14
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1843434
;  :arith-add-rows          584641
;  :arith-assert-diseq      13125
;  :arith-assert-lower      299956
;  :arith-assert-upper      255242
;  :arith-bound-prop        21502
;  :arith-conflicts         692
;  :arith-eq-adapter        220596
;  :arith-fixed-eqs         273682
;  :arith-offset-eqs        205717
;  :arith-pivots            104123
;  :conflicts               2262
;  :datatype-accessor-ax    324
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               78161
;  :del-clause              7647120
;  :final-checks            5
;  :max-generation          13
;  :max-memory              144.52
;  :memory                  134.41
;  :minimized-lits          271
;  :mk-bool-var             7179421
;  :mk-clause               7649521
;  :num-allocs              17792879
;  :num-checks              415
;  :propagations            1998828
;  :quant-instantiations    3062130
;  :restarts                3
;  :rlimit-count            65829960
;  :time                    0.01)
; [then-branch: 222 | bottleneckPathFlow@352@04 <= Lookup(int,sm@406@04,aloc((_, _), opt_get1(_, Lookup(option$array$,sm@358@04,aloc((_, _), opt_get1(_, G@11@04), u@405@04))), v@353@04)) | live]
; [else-branch: 222 | !(bottleneckPathFlow@352@04 <= Lookup(int,sm@406@04,aloc((_, _), opt_get1(_, Lookup(option$array$,sm@358@04,aloc((_, _), opt_get1(_, G@11@04), u@405@04))), v@353@04))) | live]
(push) ; 14
; [then-branch: 222 | bottleneckPathFlow@352@04 <= Lookup(int,sm@406@04,aloc((_, _), opt_get1(_, Lookup(option$array$,sm@358@04,aloc((_, _), opt_get1(_, G@11@04), u@405@04))), v@353@04))]
(assert (<=
  bottleneckPathFlow@352@04
  ($FVF.lookup_int (as sm@406@04  $FVF<Int>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@358@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) u@405@04))) v@353@04))))
(pop) ; 14
(push) ; 14
; [else-branch: 222 | !(bottleneckPathFlow@352@04 <= Lookup(int,sm@406@04,aloc((_, _), opt_get1(_, Lookup(option$array$,sm@358@04,aloc((_, _), opt_get1(_, G@11@04), u@405@04))), v@353@04)))]
(assert (not
  (<=
    bottleneckPathFlow@352@04
    ($FVF.lookup_int (as sm@406@04  $FVF<Int>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@358@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) u@405@04))) v@353@04)))))
; [eval] aloc(opt_get1(aloc(opt_get1(G), u).option$array$), v)
; [eval] opt_get1(aloc(opt_get1(G), u).option$array$)
; [eval] aloc(opt_get1(G), u)
; [eval] opt_get1(G)
(push) ; 15
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 15
; Joined path conditions
(push) ; 15
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(pop) ; 15
; Joined path conditions
(set-option :timeout 0)
(push) ; 15
(assert (not (ite
  (and
    (<
      (inv@357@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) u@405@04))
      V@15@04)
    (<=
      0
      (inv@357@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) u@405@04))))
  (< $Perm.No $k@356@04)
  false)))
(check-sat)
; unsat
(pop) ; 15
; 0.07s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1844955
;  :arith-add-rows          586271
;  :arith-assert-diseq      13156
;  :arith-assert-lower      300199
;  :arith-assert-upper      255399
;  :arith-bound-prop        21548
;  :arith-conflicts         696
;  :arith-eq-adapter        220752
;  :arith-fixed-eqs         273836
;  :arith-offset-eqs        205807
;  :arith-pivots            104193
;  :conflicts               2287
;  :datatype-accessor-ax    324
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               78699
;  :del-clause              7664820
;  :final-checks            5
;  :max-generation          13
;  :max-memory              144.52
;  :memory                  134.46
;  :minimized-lits          271
;  :mk-bool-var             7191947
;  :mk-clause               7667221
;  :num-allocs              17818449
;  :num-checks              416
;  :propagations            2001098
;  :quant-instantiations    3064968
;  :restarts                3
;  :rlimit-count            65942054
;  :time                    0.07)
(push) ; 15
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 15
; Joined path conditions
(push) ; 15
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(pop) ; 15
; Joined path conditions
(declare-const sm@408@04 $FVF<Int>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@369@04 r) V@15@04) (<= 0 (inv@369@04 r)))
    (=
      ($FVF.lookup_int (as sm@408@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04)))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@408@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04)))))))))))))) r))
  :qid |qp.fvfValDef297|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@366@04 r) V@15@04) (<= 0 (inv@366@04 r)))
        (< (inv@365@04 r) V@15@04))
      (<= 0 (inv@365@04 r)))
    (=
      ($FVF.lookup_int (as sm@408@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@408@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))))))) r))
  :qid |qp.fvfValDef298|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04)))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@408@04  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef299|)))
(declare-const pm@409@04 $FPM)
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_int (as pm@409@04  $FPM) r)
    (+
      (ite
        (and (< (inv@369@04 r) V@15@04) (<= 0 (inv@369@04 r)))
        $Perm.Write
        $Perm.No)
      (ite
        (and
          (and
            (and (< (inv@366@04 r) V@15@04) (<= 0 (inv@366@04 r)))
            (< (inv@365@04 r) V@15@04))
          (<= 0 (inv@365@04 r)))
        $Perm.Write
        $Perm.No)))
  :pattern (($FVF.perm_int (as pm@409@04  $FPM) r))
  :qid |qp.resPrmSumDef300|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int (as sm@408@04  $FVF<Int>) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04)))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))))))) r) r))
  :pattern (($FVF.perm_int (as pm@409@04  $FPM) r))
  :qid |qp.resTrgDef301|)))
(assert ($FVF.loc_int ($FVF.lookup_int (as sm@408@04  $FVF<Int>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@358@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) u@405@04))) v@353@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@358@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) u@405@04))) v@353@04)))
(push) ; 15
(assert (not (<
  $Perm.No
  ($FVF.perm_int (as pm@409@04  $FPM) (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@358@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) u@405@04))) v@353@04)))))
(check-sat)
; unsat
(pop) ; 15
; 0.07s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1847770
;  :arith-add-rows          588831
;  :arith-assert-diseq      13198
;  :arith-assert-lower      300626
;  :arith-assert-upper      255684
;  :arith-bound-prop        21673
;  :arith-conflicts         706
;  :arith-eq-adapter        221013
;  :arith-fixed-eqs         274090
;  :arith-offset-eqs        206075
;  :arith-pivots            104410
;  :conflicts               2321
;  :datatype-accessor-ax    324
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               79374
;  :del-clause              7686287
;  :final-checks            5
;  :max-generation          13
;  :max-memory              144.52
;  :memory                  134.47
;  :minimized-lits          271
;  :mk-bool-var             7208079
;  :mk-clause               7688692
;  :num-allocs              17851434
;  :num-checks              417
;  :propagations            2004611
;  :quant-instantiations    3068620
;  :restarts                3
;  :rlimit-count            66094837
;  :time                    0.07)
(pop) ; 14
(pop) ; 13
; Joined path conditions
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@369@04 r) V@15@04) (<= 0 (inv@369@04 r)))
    (=
      ($FVF.lookup_int (as sm@408@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04)))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@408@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04)))))))))))))) r))
  :qid |qp.fvfValDef297|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@366@04 r) V@15@04) (<= 0 (inv@366@04 r)))
        (< (inv@365@04 r) V@15@04))
      (<= 0 (inv@365@04 r)))
    (=
      ($FVF.lookup_int (as sm@408@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@408@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))))))) r))
  :qid |qp.fvfValDef298|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04)))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@408@04  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef299|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_int (as pm@409@04  $FPM) r)
    (+
      (ite
        (and (< (inv@369@04 r) V@15@04) (<= 0 (inv@369@04 r)))
        $Perm.Write
        $Perm.No)
      (ite
        (and
          (and
            (and (< (inv@366@04 r) V@15@04) (<= 0 (inv@366@04 r)))
            (< (inv@365@04 r) V@15@04))
          (<= 0 (inv@365@04 r)))
        $Perm.Write
        $Perm.No)))
  :pattern (($FVF.perm_int (as pm@409@04  $FPM) r))
  :qid |qp.resPrmSumDef300|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int (as sm@408@04  $FVF<Int>) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04)))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))))))) r) r))
  :pattern (($FVF.perm_int (as pm@409@04  $FPM) r))
  :qid |qp.resTrgDef301|)))
(assert (implies
  (not
    (<=
      bottleneckPathFlow@352@04
      ($FVF.lookup_int (as sm@406@04  $FVF<Int>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@358@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) u@405@04))) v@353@04))))
  (and
    (not
      (<=
        bottleneckPathFlow@352@04
        ($FVF.lookup_int (as sm@406@04  $FVF<Int>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@358@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) u@405@04))) v@353@04))))
    ($FVF.loc_int ($FVF.lookup_int (as sm@408@04  $FVF<Int>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@358@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) u@405@04))) v@353@04)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@358@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) u@405@04))) v@353@04)))))
(declare-const bottleneckPathFlow@410@04 Int)
(assert (=
  bottleneckPathFlow@410@04
  (ite
    (<=
      bottleneckPathFlow@352@04
      ($FVF.lookup_int (as sm@406@04  $FVF<Int>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@358@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) u@405@04))) v@353@04)))
    bottleneckPathFlow@352@04
    ($FVF.lookup_int (as sm@408@04  $FVF<Int>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@358@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) u@405@04))) v@353@04)))))
; [exec]
; v := aloc(opt_get1(P), v).int
; [eval] aloc(opt_get1(P), v)
; [eval] opt_get1(P)
(push) ; 13
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 13
; Joined path conditions
(push) ; 13
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(pop) ; 13
; Joined path conditions
(declare-const sm@411@04 $FVF<Int>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@369@04 r) V@15@04) (<= 0 (inv@369@04 r)))
    (=
      ($FVF.lookup_int (as sm@411@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04)))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@411@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04)))))))))))))) r))
  :qid |qp.fvfValDef302|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@366@04 r) V@15@04) (<= 0 (inv@366@04 r)))
        (< (inv@365@04 r) V@15@04))
      (<= 0 (inv@365@04 r)))
    (=
      ($FVF.lookup_int (as sm@411@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@411@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))))))) r))
  :qid |qp.fvfValDef303|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04)))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@411@04  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef304|)))
(declare-const pm@412@04 $FPM)
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_int (as pm@412@04  $FPM) r)
    (+
      (ite
        (and (< (inv@369@04 r) V@15@04) (<= 0 (inv@369@04 r)))
        $Perm.Write
        $Perm.No)
      (ite
        (and
          (and
            (and (< (inv@366@04 r) V@15@04) (<= 0 (inv@366@04 r)))
            (< (inv@365@04 r) V@15@04))
          (<= 0 (inv@365@04 r)))
        $Perm.Write
        $Perm.No)))
  :pattern (($FVF.perm_int (as pm@412@04  $FPM) r))
  :qid |qp.resPrmSumDef305|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int (as sm@411@04  $FVF<Int>) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04)))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))))))) r) r))
  :pattern (($FVF.perm_int (as pm@412@04  $FPM) r))
  :qid |qp.resTrgDef306|)))
(assert ($FVF.loc_int ($FVF.lookup_int (as sm@411@04  $FVF<Int>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit P@14@04) v@353@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit P@14@04) v@353@04)))
(push) ; 13
(assert (not (<
  $Perm.No
  ($FVF.perm_int (as pm@412@04  $FPM) (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) v@353@04)))))
(check-sat)
; unsat
(pop) ; 13
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1848168
;  :arith-add-rows          588968
;  :arith-assert-diseq      13199
;  :arith-assert-lower      300670
;  :arith-assert-upper      255718
;  :arith-bound-prop        21700
;  :arith-conflicts         709
;  :arith-eq-adapter        221040
;  :arith-fixed-eqs         274109
;  :arith-offset-eqs        206150
;  :arith-pivots            104451
;  :conflicts               2327
;  :datatype-accessor-ax    324
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               79382
;  :del-clause              7687368
;  :final-checks            5
;  :max-generation          13
;  :max-memory              144.52
;  :memory                  134.47
;  :minimized-lits          271
;  :mk-bool-var             7209503
;  :mk-clause               7689783
;  :num-allocs              17856296
;  :num-checks              418
;  :propagations            2004824
;  :quant-instantiations    3068956
;  :restarts                3
;  :rlimit-count            66118727
;  :time                    0.01)
(declare-const v@413@04 Int)
(assert (=
  v@413@04
  ($FVF.lookup_int (as sm@411@04  $FVF<Int>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit P@14@04) v@353@04))))
; Loop head block: Re-establish invariant
; [eval] exc == excBeforeLoop1
; [eval] 0 <= v
(push) ; 13
(assert (not (<= 0 v@413@04)))
(check-sat)
; unsat
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1848334
;  :arith-add-rows          589050
;  :arith-assert-diseq      13200
;  :arith-assert-lower      300712
;  :arith-assert-upper      255731
;  :arith-bound-prop        21718
;  :arith-conflicts         712
;  :arith-eq-adapter        221050
;  :arith-fixed-eqs         274117
;  :arith-offset-eqs        206220
;  :arith-pivots            104454
;  :conflicts               2333
;  :datatype-accessor-ax    324
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               79387
;  :del-clause              7687449
;  :final-checks            5
;  :max-generation          13
;  :max-memory              144.52
;  :memory                  134.42
;  :minimized-lits          271
;  :mk-bool-var             7209682
;  :mk-clause               7689864
;  :num-allocs              17857170
;  :num-checks              419
;  :propagations            2005124
;  :quant-instantiations    3069062
;  :restarts                3
;  :rlimit-count            66122872
;  :time                    0.00)
(assert (<= 0 v@413@04))
; [eval] v < V
(push) ; 13
(assert (not (< v@413@04 V@15@04)))
(check-sat)
; unsat
(pop) ; 13
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1848708
;  :arith-add-rows          589182
;  :arith-assert-diseq      13201
;  :arith-assert-lower      300746
;  :arith-assert-upper      255756
;  :arith-bound-prop        21743
;  :arith-conflicts         715
;  :arith-eq-adapter        221069
;  :arith-fixed-eqs         274133
;  :arith-offset-eqs        206289
;  :arith-pivots            104485
;  :conflicts               2338
;  :datatype-accessor-ax    324
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               79394
;  :del-clause              7688506
;  :final-checks            5
;  :max-generation          13
;  :max-memory              144.52
;  :memory                  134.39
;  :minimized-lits          271
;  :mk-bool-var             7211057
;  :mk-clause               7690921
;  :num-allocs              17860187
;  :num-checks              420
;  :propagations            2005400
;  :quant-instantiations    3069387
;  :restarts                3
;  :rlimit-count            66140638
;  :time                    0.01)
(assert (< v@413@04 V@15@04))
; [eval] G != (None(): option[array])
; [eval] (None(): option[array])
; [eval] alen(opt_get1(G)) == V
; [eval] alen(opt_get1(G))
; [eval] opt_get1(G)
(push) ; 13
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 13
; Joined path conditions
(declare-const i1@414@04 Int)
(push) ; 13
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 14
; [then-branch: 223 | 0 <= i1@414@04 | live]
; [else-branch: 223 | !(0 <= i1@414@04) | live]
(push) ; 15
; [then-branch: 223 | 0 <= i1@414@04]
(assert (<= 0 i1@414@04))
; [eval] i1 < V
(pop) ; 15
(push) ; 15
; [else-branch: 223 | !(0 <= i1@414@04)]
(assert (not (<= 0 i1@414@04)))
(pop) ; 15
(pop) ; 14
; Joined path conditions
; Joined path conditions
(assert (and (< i1@414@04 V@15@04) (<= 0 i1@414@04)))
(declare-const $k@415@04 $Perm)
(assert ($Perm.isReadVar $k@415@04 $Perm.Write))
; [eval] aloc(opt_get1(G), i1)
; [eval] opt_get1(G)
(push) ; 14
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 14
; Joined path conditions
(push) ; 14
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 15
(assert (not (< i1@414@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))))
(check-sat)
; unsat
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1848708
;  :arith-add-rows          589184
;  :arith-assert-diseq      13202
;  :arith-assert-lower      300751
;  :arith-assert-upper      255757
;  :arith-bound-prop        21743
;  :arith-conflicts         715
;  :arith-eq-adapter        221070
;  :arith-fixed-eqs         274133
;  :arith-offset-eqs        206289
;  :arith-pivots            104486
;  :conflicts               2338
;  :datatype-accessor-ax    324
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               79394
;  :del-clause              7688506
;  :final-checks            5
;  :max-generation          13
;  :max-memory              144.52
;  :memory                  134.40
;  :minimized-lits          271
;  :mk-bool-var             7211064
;  :mk-clause               7690923
;  :num-allocs              17860427
;  :num-checks              421
;  :propagations            2005401
;  :quant-instantiations    3069387
;  :restarts                3
;  :rlimit-count            66141064)
(assert (< i1@414@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(pop) ; 14
; Joined path conditions
(assert (< i1@414@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(pop) ; 13
(declare-fun inv@416@04 ($Ref) Int)
; Nested auxiliary terms: globals
(assert ($Perm.isReadVar $k@415@04 $Perm.Write))
; Nested auxiliary terms: non-globals
(assert (forall ((i1@414@04 Int)) (!
  (< i1@414@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@414@04))
  :qid |option$array$-aux|)))
(push) ; 13
(assert (not (forall ((i1@414@04 Int)) (!
  (implies
    (and (< i1@414@04 V@15@04) (<= 0 i1@414@04))
    (or (= $k@415@04 $Perm.No) (< $Perm.No $k@415@04)))
  
  ))))
(check-sat)
; unsat
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1848708
;  :arith-add-rows          589185
;  :arith-assert-diseq      13203
;  :arith-assert-lower      300753
;  :arith-assert-upper      255758
;  :arith-bound-prop        21743
;  :arith-conflicts         715
;  :arith-eq-adapter        221071
;  :arith-fixed-eqs         274133
;  :arith-offset-eqs        206289
;  :arith-pivots            104486
;  :conflicts               2339
;  :datatype-accessor-ax    324
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               79394
;  :del-clause              7688508
;  :final-checks            5
;  :max-generation          13
;  :max-memory              144.52
;  :memory                  134.40
;  :minimized-lits          271
;  :mk-bool-var             7211071
;  :mk-clause               7690925
;  :num-allocs              17860856
;  :num-checks              422
;  :propagations            2005402
;  :quant-instantiations    3069388
;  :restarts                3
;  :rlimit-count            66141622)
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 13
(assert (not (forall ((i11@414@04 Int) (i12@414@04 Int)) (!
  (implies
    (and
      (and
        (and
          (and (< i11@414@04 V@15@04) (<= 0 i11@414@04))
          ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@358@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i11@414@04)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i11@414@04)))
        (< $Perm.No $k@415@04))
      (and
        (and
          (and (< i12@414@04 V@15@04) (<= 0 i12@414@04))
          ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@358@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i12@414@04)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i12@414@04)))
        (< $Perm.No $k@415@04))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i11@414@04)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i12@414@04)))
    (= i11@414@04 i12@414@04))
  
  :qid |option$array$-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1848758
;  :arith-add-rows          589194
;  :arith-assert-diseq      13204
;  :arith-assert-lower      300757
;  :arith-assert-upper      255758
;  :arith-bound-prop        21743
;  :arith-conflicts         715
;  :arith-eq-adapter        221072
;  :arith-fixed-eqs         274133
;  :arith-offset-eqs        206289
;  :arith-pivots            104490
;  :conflicts               2340
;  :datatype-accessor-ax    324
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               79394
;  :del-clause              7688515
;  :final-checks            5
;  :max-generation          13
;  :max-memory              144.52
;  :memory                  134.40
;  :minimized-lits          271
;  :mk-bool-var             7211147
;  :mk-clause               7690932
;  :num-allocs              17861771
;  :num-checks              423
;  :propagations            2005402
;  :quant-instantiations    3069473
;  :restarts                3
;  :rlimit-count            66144613
;  :time                    0.00)
; Definitional axioms for inverse functions
(assert (forall ((i1@414@04 Int)) (!
  (implies
    (and (and (< i1@414@04 V@15@04) (<= 0 i1@414@04)) (< $Perm.No $k@415@04))
    (=
      (inv@416@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@414@04))
      i1@414@04))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@414@04))
  :qid |option$array$-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and (< (inv@416@04 r) V@15@04) (<= 0 (inv@416@04 r)))
      (< $Perm.No $k@415@04))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) (inv@416@04 r))
      r))
  :pattern ((inv@416@04 r))
  :qid |option$array$-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@416@04 r) V@15@04) (<= 0 (inv@416@04 r)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@358@04  $FVF<option<array>>) r) r))
  :pattern ((inv@416@04 r))
  )))
; Precomputing data for removing quantified permissions
(define-fun pTaken@417@04 ((r $Ref)) $Perm
  (ite
    (and (< (inv@416@04 r) V@15@04) (<= 0 (inv@416@04 r)))
    ($Perm.min
      (ite
        (and (< (inv@357@04 r) V@15@04) (<= 0 (inv@357@04 r)))
        $k@356@04
        $Perm.No)
      $k@415@04)
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Constrain original permissions $k@415@04
(assert (forall ((r $Ref)) (!
  (implies
    (not
      (=
        (ite
          (and (< (inv@357@04 r) V@15@04) (<= 0 (inv@357@04 r)))
          $k@356@04
          $Perm.No)
        $Perm.No))
    (ite
      (and (< (inv@357@04 r) V@15@04) (<= 0 (inv@357@04 r)))
      (<
        (ite
          (and (< (inv@416@04 r) V@15@04) (<= 0 (inv@416@04 r)))
          $k@415@04
          $Perm.No)
        $k@356@04)
      (<
        (ite
          (and (< (inv@416@04 r) V@15@04) (<= 0 (inv@416@04 r)))
          $k@415@04
          $Perm.No)
        $Perm.No)))
  :pattern ((inv@357@04 r))
  :pattern ((inv@416@04 r))
  :qid |qp.srp307|)))
; Intermediate check if already taken enough permissions
(set-option :timeout 500)
(push) ; 13
(assert (not (forall ((r $Ref)) (!
  (implies
    (and (< (inv@416@04 r) V@15@04) (<= 0 (inv@416@04 r)))
    (= (- $k@415@04 (pTaken@417@04 r)) $Perm.No))
  
  ))))
(check-sat)
; unsat
(pop) ; 13
; 0.05s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1851211
;  :arith-add-rows          591271
;  :arith-assert-diseq      13245
;  :arith-assert-lower      301133
;  :arith-assert-upper      255996
;  :arith-bound-prop        21868
;  :arith-conflicts         724
;  :arith-eq-adapter        221312
;  :arith-fixed-eqs         274339
;  :arith-offset-eqs        206569
;  :arith-pivots            104693
;  :conflicts               2370
;  :datatype-accessor-ax    324
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               79843
;  :del-clause              7703452
;  :final-checks            5
;  :max-generation          13
;  :max-memory              144.52
;  :memory                  134.80
;  :minimized-lits          272
;  :mk-bool-var             7223250
;  :mk-clause               7705887
;  :num-allocs              17890858
;  :num-checks              425
;  :propagations            2008033
;  :quant-instantiations    3072278
;  :restarts                3
;  :rlimit-count            66295262
;  :time                    0.05)
; Final check if taken enough permissions
; Done removing quantified permissions
; Definitional axioms for snapshot map values
; [eval] (forall i1: Int :: { aloc(opt_get1(G), i1) } 0 <= i1 && i1 < V ==> aloc(opt_get1(G), i1).option$array$ != (None(): option[array]))
(declare-const i1@418@04 Int)
(push) ; 13
; [eval] 0 <= i1 && i1 < V ==> aloc(opt_get1(G), i1).option$array$ != (None(): option[array])
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 14
; [then-branch: 224 | 0 <= i1@418@04 | live]
; [else-branch: 224 | !(0 <= i1@418@04) | live]
(push) ; 15
; [then-branch: 224 | 0 <= i1@418@04]
(assert (<= 0 i1@418@04))
; [eval] i1 < V
(pop) ; 15
(push) ; 15
; [else-branch: 224 | !(0 <= i1@418@04)]
(assert (not (<= 0 i1@418@04)))
(pop) ; 15
(pop) ; 14
; Joined path conditions
; Joined path conditions
(push) ; 14
; [then-branch: 225 | i1@418@04 < V@15@04 && 0 <= i1@418@04 | live]
; [else-branch: 225 | !(i1@418@04 < V@15@04 && 0 <= i1@418@04) | live]
(push) ; 15
; [then-branch: 225 | i1@418@04 < V@15@04 && 0 <= i1@418@04]
(assert (and (< i1@418@04 V@15@04) (<= 0 i1@418@04)))
; [eval] aloc(opt_get1(G), i1).option$array$ != (None(): option[array])
; [eval] aloc(opt_get1(G), i1)
; [eval] opt_get1(G)
(push) ; 16
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 16
; Joined path conditions
(push) ; 16
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 17
(assert (not (< i1@418@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))))
(check-sat)
; unsat
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1851211
;  :arith-add-rows          591272
;  :arith-assert-diseq      13245
;  :arith-assert-lower      301135
;  :arith-assert-upper      255996
;  :arith-bound-prop        21868
;  :arith-conflicts         724
;  :arith-eq-adapter        221312
;  :arith-fixed-eqs         274339
;  :arith-offset-eqs        206569
;  :arith-pivots            104694
;  :conflicts               2370
;  :datatype-accessor-ax    324
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               79843
;  :del-clause              7703452
;  :final-checks            5
;  :max-generation          13
;  :max-memory              144.52
;  :memory                  134.80
;  :minimized-lits          272
;  :mk-bool-var             7223252
;  :mk-clause               7705887
;  :num-allocs              17890967
;  :num-checks              426
;  :propagations            2008033
;  :quant-instantiations    3072278
;  :restarts                3
;  :rlimit-count            66295460)
(assert (< i1@418@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(pop) ; 16
; Joined path conditions
(assert (< i1@418@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@358@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@418@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@418@04)))
(push) ; 16
(assert (not (ite
  (and
    (<
      (inv@357@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@418@04))
      V@15@04)
    (<=
      0
      (inv@357@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@418@04))))
  (< $Perm.No $k@356@04)
  false)))
(check-sat)
; unsat
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1851367
;  :arith-add-rows          591347
;  :arith-assert-diseq      13245
;  :arith-assert-lower      301156
;  :arith-assert-upper      256014
;  :arith-bound-prop        21882
;  :arith-conflicts         725
;  :arith-eq-adapter        221330
;  :arith-fixed-eqs         274356
;  :arith-offset-eqs        206596
;  :arith-pivots            104712
;  :conflicts               2371
;  :datatype-accessor-ax    324
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               79843
;  :del-clause              7703452
;  :final-checks            5
;  :max-generation          13
;  :max-memory              144.52
;  :memory                  134.84
;  :minimized-lits          272
;  :mk-bool-var             7223835
;  :mk-clause               7706380
;  :num-allocs              17893456
;  :num-checks              427
;  :propagations            2008056
;  :quant-instantiations    3072510
;  :restarts                3
;  :rlimit-count            66306036
;  :time                    0.00)
; [eval] (None(): option[array])
(pop) ; 15
(push) ; 15
; [else-branch: 225 | !(i1@418@04 < V@15@04 && 0 <= i1@418@04)]
(assert (not (and (< i1@418@04 V@15@04) (<= 0 i1@418@04))))
(pop) ; 15
(pop) ; 14
; Joined path conditions
(assert (implies
  (and (< i1@418@04 V@15@04) (<= 0 i1@418@04))
  (and
    (< i1@418@04 V@15@04)
    (<= 0 i1@418@04)
    (< i1@418@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@358@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@418@04)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@418@04)))))
; Joined path conditions
(pop) ; 13
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@418@04 Int)) (!
  (implies
    (and (< i1@418@04 V@15@04) (<= 0 i1@418@04))
    (and
      (< i1@418@04 V@15@04)
      (<= 0 i1@418@04)
      (< i1@418@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@358@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@418@04)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@418@04))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@418@04))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(push) ; 13
(assert (not (forall ((i1@418@04 Int)) (!
  (implies
    (and (< i1@418@04 V@15@04) (<= 0 i1@418@04))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@358@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@418@04))
        (as None<option<array>>  option<array>))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@418@04))
  :qid |prog.l<no position>|))))
(check-sat)
; unsat
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1851393
;  :arith-add-rows          591377
;  :arith-assert-diseq      13245
;  :arith-assert-lower      301158
;  :arith-assert-upper      256014
;  :arith-bound-prop        21882
;  :arith-conflicts         725
;  :arith-eq-adapter        221332
;  :arith-fixed-eqs         274356
;  :arith-offset-eqs        206596
;  :arith-pivots            104730
;  :conflicts               2372
;  :datatype-accessor-ax    324
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               79843
;  :del-clause              7704193
;  :final-checks            5
;  :max-generation          13
;  :max-memory              144.52
;  :memory                  134.76
;  :minimized-lits          272
;  :mk-bool-var             7224080
;  :mk-clause               7706629
;  :num-allocs              17895269
;  :num-checks              428
;  :propagations            2008056
;  :quant-instantiations    3072651
;  :restarts                3
;  :rlimit-count            66312918
;  :time                    0.00)
(assert (forall ((i1@418@04 Int)) (!
  (implies
    (and (< i1@418@04 V@15@04) (<= 0 i1@418@04))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@358@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@418@04))
        (as None<option<array>>  option<array>))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@418@04))
  :qid |prog.l<no position>|)))
; [eval] (forall i1: Int :: { alen(opt_get1(aloc(opt_get1(G), i1).option$array$)) } 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(G), i1).option$array$)) == V)
(declare-const i1@419@04 Int)
(push) ; 13
; [eval] 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(G), i1).option$array$)) == V
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 14
; [then-branch: 226 | 0 <= i1@419@04 | live]
; [else-branch: 226 | !(0 <= i1@419@04) | live]
(push) ; 15
; [then-branch: 226 | 0 <= i1@419@04]
(assert (<= 0 i1@419@04))
; [eval] i1 < V
(pop) ; 15
(push) ; 15
; [else-branch: 226 | !(0 <= i1@419@04)]
(assert (not (<= 0 i1@419@04)))
(pop) ; 15
(pop) ; 14
; Joined path conditions
; Joined path conditions
(push) ; 14
; [then-branch: 227 | i1@419@04 < V@15@04 && 0 <= i1@419@04 | live]
; [else-branch: 227 | !(i1@419@04 < V@15@04 && 0 <= i1@419@04) | live]
(push) ; 15
; [then-branch: 227 | i1@419@04 < V@15@04 && 0 <= i1@419@04]
(assert (and (< i1@419@04 V@15@04) (<= 0 i1@419@04)))
; [eval] alen(opt_get1(aloc(opt_get1(G), i1).option$array$)) == V
; [eval] alen(opt_get1(aloc(opt_get1(G), i1).option$array$))
; [eval] opt_get1(aloc(opt_get1(G), i1).option$array$)
; [eval] aloc(opt_get1(G), i1)
; [eval] opt_get1(G)
(push) ; 16
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 16
; Joined path conditions
(push) ; 16
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 17
(assert (not (< i1@419@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))))
(check-sat)
; unsat
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1851393
;  :arith-add-rows          591378
;  :arith-assert-diseq      13245
;  :arith-assert-lower      301160
;  :arith-assert-upper      256014
;  :arith-bound-prop        21882
;  :arith-conflicts         725
;  :arith-eq-adapter        221332
;  :arith-fixed-eqs         274356
;  :arith-offset-eqs        206596
;  :arith-pivots            104731
;  :conflicts               2372
;  :datatype-accessor-ax    324
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               79843
;  :del-clause              7704193
;  :final-checks            5
;  :max-generation          13
;  :max-memory              144.52
;  :memory                  134.76
;  :minimized-lits          272
;  :mk-bool-var             7224083
;  :mk-clause               7706629
;  :num-allocs              17895572
;  :num-checks              429
;  :propagations            2008056
;  :quant-instantiations    3072651
;  :restarts                3
;  :rlimit-count            66313426)
(assert (< i1@419@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(pop) ; 16
; Joined path conditions
(assert (< i1@419@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@358@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@419@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@419@04)))
(push) ; 16
(assert (not (ite
  (and
    (<
      (inv@357@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@419@04))
      V@15@04)
    (<=
      0
      (inv@357@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@419@04))))
  (< $Perm.No $k@356@04)
  false)))
(check-sat)
; unsat
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1851549
;  :arith-add-rows          591453
;  :arith-assert-diseq      13245
;  :arith-assert-lower      301181
;  :arith-assert-upper      256032
;  :arith-bound-prop        21896
;  :arith-conflicts         726
;  :arith-eq-adapter        221350
;  :arith-fixed-eqs         274373
;  :arith-offset-eqs        206623
;  :arith-pivots            104749
;  :conflicts               2373
;  :datatype-accessor-ax    324
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               79843
;  :del-clause              7704193
;  :final-checks            5
;  :max-generation          13
;  :max-memory              144.52
;  :memory                  134.77
;  :minimized-lits          272
;  :mk-bool-var             7224666
;  :mk-clause               7707122
;  :num-allocs              17898105
;  :num-checks              430
;  :propagations            2008079
;  :quant-instantiations    3072884
;  :restarts                3
;  :rlimit-count            66325060)
(push) ; 16
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 17
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@358@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@419@04))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1851549
;  :arith-add-rows          591453
;  :arith-assert-diseq      13245
;  :arith-assert-lower      301181
;  :arith-assert-upper      256032
;  :arith-bound-prop        21896
;  :arith-conflicts         726
;  :arith-eq-adapter        221350
;  :arith-fixed-eqs         274373
;  :arith-offset-eqs        206623
;  :arith-pivots            104749
;  :conflicts               2374
;  :datatype-accessor-ax    324
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               79843
;  :del-clause              7704193
;  :final-checks            5
;  :max-generation          13
;  :max-memory              144.52
;  :memory                  134.77
;  :minimized-lits          272
;  :mk-bool-var             7224666
;  :mk-clause               7707122
;  :num-allocs              17898195
;  :num-checks              431
;  :propagations            2008079
;  :quant-instantiations    3072884
;  :restarts                3
;  :rlimit-count            66325155)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@358@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@419@04))
    (as None<option<array>>  option<array>))))
(pop) ; 16
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@358@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@419@04))
    (as None<option<array>>  option<array>))))
(pop) ; 15
(push) ; 15
; [else-branch: 227 | !(i1@419@04 < V@15@04 && 0 <= i1@419@04)]
(assert (not (and (< i1@419@04 V@15@04) (<= 0 i1@419@04))))
(pop) ; 15
(pop) ; 14
; Joined path conditions
(assert (implies
  (and (< i1@419@04 V@15@04) (<= 0 i1@419@04))
  (and
    (< i1@419@04 V@15@04)
    (<= 0 i1@419@04)
    (< i1@419@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@358@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@419@04)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@419@04))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@358@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@419@04))
        (as None<option<array>>  option<array>))))))
; Joined path conditions
(pop) ; 13
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@419@04 Int)) (!
  (implies
    (and (< i1@419@04 V@15@04) (<= 0 i1@419@04))
    (and
      (< i1@419@04 V@15@04)
      (<= 0 i1@419@04)
      (< i1@419@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@358@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@419@04)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@419@04))
      (not
        (=
          ($FVF.lookup_option$array$ (as sm@358@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@419@04))
          (as None<option<array>>  option<array>)))))
  :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@358@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@419@04)))))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(push) ; 13
(assert (not (forall ((i1@419@04 Int)) (!
  (implies
    (and (< i1@419@04 V@15@04) (<= 0 i1@419@04))
    (=
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@358@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@419@04))))
      V@15@04))
  :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@358@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@419@04)))))
  :qid |prog.l<no position>|))))
(check-sat)
; unsat
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1851549
;  :arith-add-rows          591470
;  :arith-assert-diseq      13245
;  :arith-assert-lower      301183
;  :arith-assert-upper      256032
;  :arith-bound-prop        21896
;  :arith-conflicts         726
;  :arith-eq-adapter        221351
;  :arith-fixed-eqs         274373
;  :arith-offset-eqs        206623
;  :arith-pivots            104767
;  :conflicts               2375
;  :datatype-accessor-ax    324
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               79843
;  :del-clause              7704696
;  :final-checks            5
;  :max-generation          13
;  :max-memory              144.52
;  :memory                  134.72
;  :minimized-lits          272
;  :mk-bool-var             7224716
;  :mk-clause               7707133
;  :num-allocs              17898989
;  :num-checks              432
;  :propagations            2008079
;  :quant-instantiations    3072938
;  :restarts                3
;  :rlimit-count            66327685)
(assert (forall ((i1@419@04 Int)) (!
  (implies
    (and (< i1@419@04 V@15@04) (<= 0 i1@419@04))
    (=
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@358@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@419@04))))
      V@15@04))
  :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@358@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@419@04)))))
  :qid |prog.l<no position>|)))
; [eval] (forall i1: Int :: { aloc(opt_get1(G), i1) } (forall i2: Int :: { aloc(opt_get1(G), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(G), i1).option$array$ == aloc(opt_get1(G), i2).option$array$ ==> i1 == i2))
(declare-const i1@420@04 Int)
(push) ; 13
; [eval] (forall i2: Int :: { aloc(opt_get1(G), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(G), i1).option$array$ == aloc(opt_get1(G), i2).option$array$ ==> i1 == i2)
(declare-const i2@421@04 Int)
(push) ; 14
; [eval] 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(G), i1).option$array$ == aloc(opt_get1(G), i2).option$array$ ==> i1 == i2
; [eval] 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(G), i1).option$array$ == aloc(opt_get1(G), i2).option$array$
; [eval] 0 <= i1
(push) ; 15
; [then-branch: 228 | 0 <= i1@420@04 | live]
; [else-branch: 228 | !(0 <= i1@420@04) | live]
(push) ; 16
; [then-branch: 228 | 0 <= i1@420@04]
(assert (<= 0 i1@420@04))
; [eval] i1 < V
(push) ; 17
; [then-branch: 229 | i1@420@04 < V@15@04 | live]
; [else-branch: 229 | !(i1@420@04 < V@15@04) | live]
(push) ; 18
; [then-branch: 229 | i1@420@04 < V@15@04]
(assert (< i1@420@04 V@15@04))
; [eval] 0 <= i2
(push) ; 19
; [then-branch: 230 | 0 <= i2@421@04 | live]
; [else-branch: 230 | !(0 <= i2@421@04) | live]
(push) ; 20
; [then-branch: 230 | 0 <= i2@421@04]
(assert (<= 0 i2@421@04))
; [eval] i2 < V
(push) ; 21
; [then-branch: 231 | i2@421@04 < V@15@04 | live]
; [else-branch: 231 | !(i2@421@04 < V@15@04) | live]
(push) ; 22
; [then-branch: 231 | i2@421@04 < V@15@04]
(assert (< i2@421@04 V@15@04))
; [eval] aloc(opt_get1(G), i1).option$array$ == aloc(opt_get1(G), i2).option$array$
; [eval] aloc(opt_get1(G), i1)
; [eval] opt_get1(G)
(push) ; 23
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 23
; Joined path conditions
(push) ; 23
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 24
(assert (not (< i1@420@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))))
(check-sat)
; unsat
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1851549
;  :arith-add-rows          591472
;  :arith-assert-diseq      13245
;  :arith-assert-lower      301187
;  :arith-assert-upper      256032
;  :arith-bound-prop        21896
;  :arith-conflicts         726
;  :arith-eq-adapter        221351
;  :arith-fixed-eqs         274373
;  :arith-offset-eqs        206623
;  :arith-pivots            104767
;  :conflicts               2375
;  :datatype-accessor-ax    324
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               79843
;  :del-clause              7704696
;  :final-checks            5
;  :max-generation          13
;  :max-memory              144.52
;  :memory                  134.72
;  :minimized-lits          272
;  :mk-bool-var             7224721
;  :mk-clause               7707134
;  :num-allocs              17899472
;  :num-checks              433
;  :propagations            2008079
;  :quant-instantiations    3072939
;  :restarts                3
;  :rlimit-count            66328354)
(assert (< i1@420@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(pop) ; 23
; Joined path conditions
(assert (< i1@420@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@358@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@420@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@420@04)))
(push) ; 23
(assert (not (ite
  (and
    (<
      (inv@357@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@420@04))
      V@15@04)
    (<=
      0
      (inv@357@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@420@04))))
  (< $Perm.No $k@356@04)
  false)))
(check-sat)
; unsat
(pop) ; 23
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1851676
;  :arith-add-rows          591533
;  :arith-assert-diseq      13245
;  :arith-assert-lower      301208
;  :arith-assert-upper      256050
;  :arith-bound-prop        21909
;  :arith-conflicts         727
;  :arith-eq-adapter        221369
;  :arith-fixed-eqs         274390
;  :arith-offset-eqs        206623
;  :arith-pivots            104785
;  :conflicts               2376
;  :datatype-accessor-ax    324
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               79843
;  :del-clause              7704696
;  :final-checks            5
;  :max-generation          13
;  :max-memory              144.52
;  :memory                  134.80
;  :minimized-lits          272
;  :mk-bool-var             7225305
;  :mk-clause               7707627
;  :num-allocs              17902016
;  :num-checks              434
;  :propagations            2008099
;  :quant-instantiations    3073172
;  :restarts                3
;  :rlimit-count            66339849)
; [eval] aloc(opt_get1(G), i2)
; [eval] opt_get1(G)
(push) ; 23
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 23
; Joined path conditions
(push) ; 23
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 24
(assert (not (< i2@421@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))))
(check-sat)
; unsat
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1851676
;  :arith-add-rows          591533
;  :arith-assert-diseq      13245
;  :arith-assert-lower      301208
;  :arith-assert-upper      256050
;  :arith-bound-prop        21909
;  :arith-conflicts         727
;  :arith-eq-adapter        221369
;  :arith-fixed-eqs         274390
;  :arith-offset-eqs        206623
;  :arith-pivots            104785
;  :conflicts               2376
;  :datatype-accessor-ax    324
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               79843
;  :del-clause              7704696
;  :final-checks            5
;  :max-generation          13
;  :max-memory              144.52
;  :memory                  134.80
;  :minimized-lits          272
;  :mk-bool-var             7225305
;  :mk-clause               7707627
;  :num-allocs              17902042
;  :num-checks              435
;  :propagations            2008099
;  :quant-instantiations    3073172
;  :restarts                3
;  :rlimit-count            66339879)
(assert (< i2@421@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(pop) ; 23
; Joined path conditions
(assert (< i2@421@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@358@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@421@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@421@04)))
(push) ; 23
(assert (not (ite
  (and
    (<
      (inv@357@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@421@04))
      V@15@04)
    (<=
      0
      (inv@357@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@421@04))))
  (< $Perm.No $k@356@04)
  false)))
(check-sat)
; unsat
(pop) ; 23
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1851787
;  :arith-add-rows          591596
;  :arith-assert-diseq      13245
;  :arith-assert-lower      301229
;  :arith-assert-upper      256068
;  :arith-bound-prop        21922
;  :arith-conflicts         728
;  :arith-eq-adapter        221388
;  :arith-fixed-eqs         274407
;  :arith-offset-eqs        206623
;  :arith-pivots            104803
;  :conflicts               2377
;  :datatype-accessor-ax    324
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               79843
;  :del-clause              7704696
;  :final-checks            5
;  :max-generation          13
;  :max-memory              144.52
;  :memory                  134.82
;  :minimized-lits          272
;  :mk-bool-var             7225792
;  :mk-clause               7708058
;  :num-allocs              17904464
;  :num-checks              436
;  :propagations            2008143
;  :quant-instantiations    3073402
;  :restarts                3
;  :rlimit-count            66351358)
(pop) ; 22
(push) ; 22
; [else-branch: 231 | !(i2@421@04 < V@15@04)]
(assert (not (< i2@421@04 V@15@04)))
(pop) ; 22
(pop) ; 21
; Joined path conditions
(assert (implies
  (< i2@421@04 V@15@04)
  (and
    (< i2@421@04 V@15@04)
    (< i1@420@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@358@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@420@04)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@420@04))
    (< i2@421@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@358@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@421@04)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@421@04)))))
; Joined path conditions
(pop) ; 20
(push) ; 20
; [else-branch: 230 | !(0 <= i2@421@04)]
(assert (not (<= 0 i2@421@04)))
(pop) ; 20
(pop) ; 19
; Joined path conditions
(assert (implies
  (<= 0 i2@421@04)
  (and
    (<= 0 i2@421@04)
    (implies
      (< i2@421@04 V@15@04)
      (and
        (< i2@421@04 V@15@04)
        (< i1@420@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@358@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@420@04)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@420@04))
        (< i2@421@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@358@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@421@04)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@421@04)))))))
; Joined path conditions
(pop) ; 18
(push) ; 18
; [else-branch: 229 | !(i1@420@04 < V@15@04)]
(assert (not (< i1@420@04 V@15@04)))
(pop) ; 18
(pop) ; 17
; Joined path conditions
(assert (implies
  (< i1@420@04 V@15@04)
  (and
    (< i1@420@04 V@15@04)
    (implies
      (<= 0 i2@421@04)
      (and
        (<= 0 i2@421@04)
        (implies
          (< i2@421@04 V@15@04)
          (and
            (< i2@421@04 V@15@04)
            (< i1@420@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@358@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@420@04)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@420@04))
            (< i2@421@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@358@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@421@04)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@421@04)))))))))
; Joined path conditions
(pop) ; 16
(push) ; 16
; [else-branch: 228 | !(0 <= i1@420@04)]
(assert (not (<= 0 i1@420@04)))
(pop) ; 16
(pop) ; 15
; Joined path conditions
(assert (implies
  (<= 0 i1@420@04)
  (and
    (<= 0 i1@420@04)
    (implies
      (< i1@420@04 V@15@04)
      (and
        (< i1@420@04 V@15@04)
        (implies
          (<= 0 i2@421@04)
          (and
            (<= 0 i2@421@04)
            (implies
              (< i2@421@04 V@15@04)
              (and
                (< i2@421@04 V@15@04)
                (< i1@420@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@358@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@420@04)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@420@04))
                (< i2@421@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@358@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@421@04)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@421@04)))))))))))
; Joined path conditions
(push) ; 15
; [then-branch: 232 | Lookup(option$array$,sm@358@04,aloc((_, _), opt_get1(_, G@11@04), i1@420@04)) == Lookup(option$array$,sm@358@04,aloc((_, _), opt_get1(_, G@11@04), i2@421@04)) && i2@421@04 < V@15@04 && 0 <= i2@421@04 && i1@420@04 < V@15@04 && 0 <= i1@420@04 | live]
; [else-branch: 232 | !(Lookup(option$array$,sm@358@04,aloc((_, _), opt_get1(_, G@11@04), i1@420@04)) == Lookup(option$array$,sm@358@04,aloc((_, _), opt_get1(_, G@11@04), i2@421@04)) && i2@421@04 < V@15@04 && 0 <= i2@421@04 && i1@420@04 < V@15@04 && 0 <= i1@420@04) | live]
(push) ; 16
; [then-branch: 232 | Lookup(option$array$,sm@358@04,aloc((_, _), opt_get1(_, G@11@04), i1@420@04)) == Lookup(option$array$,sm@358@04,aloc((_, _), opt_get1(_, G@11@04), i2@421@04)) && i2@421@04 < V@15@04 && 0 <= i2@421@04 && i1@420@04 < V@15@04 && 0 <= i1@420@04]
(assert (and
  (and
    (and
      (and
        (=
          ($FVF.lookup_option$array$ (as sm@358@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@420@04))
          ($FVF.lookup_option$array$ (as sm@358@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@421@04)))
        (< i2@421@04 V@15@04))
      (<= 0 i2@421@04))
    (< i1@420@04 V@15@04))
  (<= 0 i1@420@04)))
; [eval] i1 == i2
(pop) ; 16
(push) ; 16
; [else-branch: 232 | !(Lookup(option$array$,sm@358@04,aloc((_, _), opt_get1(_, G@11@04), i1@420@04)) == Lookup(option$array$,sm@358@04,aloc((_, _), opt_get1(_, G@11@04), i2@421@04)) && i2@421@04 < V@15@04 && 0 <= i2@421@04 && i1@420@04 < V@15@04 && 0 <= i1@420@04)]
(assert (not
  (and
    (and
      (and
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@358@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@420@04))
            ($FVF.lookup_option$array$ (as sm@358@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@421@04)))
          (< i2@421@04 V@15@04))
        (<= 0 i2@421@04))
      (< i1@420@04 V@15@04))
    (<= 0 i1@420@04))))
(pop) ; 16
(pop) ; 15
; Joined path conditions
(assert (implies
  (and
    (and
      (and
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@358@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@420@04))
            ($FVF.lookup_option$array$ (as sm@358@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@421@04)))
          (< i2@421@04 V@15@04))
        (<= 0 i2@421@04))
      (< i1@420@04 V@15@04))
    (<= 0 i1@420@04))
  (and
    (=
      ($FVF.lookup_option$array$ (as sm@358@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@420@04))
      ($FVF.lookup_option$array$ (as sm@358@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@421@04)))
    (< i2@421@04 V@15@04)
    (<= 0 i2@421@04)
    (< i1@420@04 V@15@04)
    (<= 0 i1@420@04))))
; Joined path conditions
(pop) ; 14
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i2@421@04 Int)) (!
  (and
    (implies
      (<= 0 i1@420@04)
      (and
        (<= 0 i1@420@04)
        (implies
          (< i1@420@04 V@15@04)
          (and
            (< i1@420@04 V@15@04)
            (implies
              (<= 0 i2@421@04)
              (and
                (<= 0 i2@421@04)
                (implies
                  (< i2@421@04 V@15@04)
                  (and
                    (< i2@421@04 V@15@04)
                    (< i1@420@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
                    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@358@04  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@420@04)) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@420@04))
                    (< i2@421@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
                    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@358@04  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@421@04)) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@421@04))))))))))
    (implies
      (and
        (and
          (and
            (and
              (=
                ($FVF.lookup_option$array$ (as sm@358@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@420@04))
                ($FVF.lookup_option$array$ (as sm@358@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@421@04)))
              (< i2@421@04 V@15@04))
            (<= 0 i2@421@04))
          (< i1@420@04 V@15@04))
        (<= 0 i1@420@04))
      (and
        (=
          ($FVF.lookup_option$array$ (as sm@358@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@420@04))
          ($FVF.lookup_option$array$ (as sm@358@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@421@04)))
        (< i2@421@04 V@15@04)
        (<= 0 i2@421@04)
        (< i1@420@04 V@15@04)
        (<= 0 i1@420@04))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@421@04))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 13
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@420@04 Int)) (!
  (forall ((i2@421@04 Int)) (!
    (and
      (implies
        (<= 0 i1@420@04)
        (and
          (<= 0 i1@420@04)
          (implies
            (< i1@420@04 V@15@04)
            (and
              (< i1@420@04 V@15@04)
              (implies
                (<= 0 i2@421@04)
                (and
                  (<= 0 i2@421@04)
                  (implies
                    (< i2@421@04 V@15@04)
                    (and
                      (< i2@421@04 V@15@04)
                      (< i1@420@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
                      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@358@04  $FVF<option<array>>) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@420@04)) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@420@04))
                      (< i2@421@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
                      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@358@04  $FVF<option<array>>) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@421@04)) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@421@04))))))))))
      (implies
        (and
          (and
            (and
              (and
                (=
                  ($FVF.lookup_option$array$ (as sm@358@04  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@420@04))
                  ($FVF.lookup_option$array$ (as sm@358@04  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@421@04)))
                (< i2@421@04 V@15@04))
              (<= 0 i2@421@04))
            (< i1@420@04 V@15@04))
          (<= 0 i1@420@04))
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@358@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@420@04))
            ($FVF.lookup_option$array$ (as sm@358@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@421@04)))
          (< i2@421@04 V@15@04)
          (<= 0 i2@421@04)
          (< i1@420@04 V@15@04)
          (<= 0 i1@420@04))))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@421@04))
    :qid |prog.l<no position>-aux|))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@420@04))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(push) ; 13
(assert (not (forall ((i1@420@04 Int)) (!
  (forall ((i2@421@04 Int)) (!
    (implies
      (and
        (and
          (and
            (and
              (=
                ($FVF.lookup_option$array$ (as sm@358@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@420@04))
                ($FVF.lookup_option$array$ (as sm@358@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@421@04)))
              (< i2@421@04 V@15@04))
            (<= 0 i2@421@04))
          (< i1@420@04 V@15@04))
        (<= 0 i1@420@04))
      (= i1@420@04 i2@421@04))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@421@04))
    :qid |prog.l<no position>|))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@420@04))
  :qid |prog.l<no position>|))))
(check-sat)
; unsat
(pop) ; 13
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1851920
;  :arith-add-rows          591702
;  :arith-assert-diseq      13247
;  :arith-assert-lower      301243
;  :arith-assert-upper      256070
;  :arith-bound-prop        21926
;  :arith-conflicts         728
;  :arith-eq-adapter        221425
;  :arith-fixed-eqs         274409
;  :arith-offset-eqs        206629
;  :arith-pivots            104847
;  :conflicts               2378
;  :datatype-accessor-ax    324
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               79843
;  :del-clause              7706398
;  :final-checks            5
;  :max-generation          13
;  :max-memory              144.52
;  :memory                  134.78
;  :minimized-lits          272
;  :mk-bool-var             7226700
;  :mk-clause               7708837
;  :num-allocs              17909346
;  :num-checks              437
;  :propagations            2008175
;  :quant-instantiations    3073834
;  :restarts                3
;  :rlimit-count            66373780
;  :time                    0.01)
(assert (forall ((i1@420@04 Int)) (!
  (forall ((i2@421@04 Int)) (!
    (implies
      (and
        (and
          (and
            (and
              (=
                ($FVF.lookup_option$array$ (as sm@358@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@420@04))
                ($FVF.lookup_option$array$ (as sm@358@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@421@04)))
              (< i2@421@04 V@15@04))
            (<= 0 i2@421@04))
          (< i1@420@04 V@15@04))
        (<= 0 i1@420@04))
      (= i1@420@04 i2@421@04))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@421@04))
    :qid |prog.l<no position>|))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@420@04))
  :qid |prog.l<no position>|)))
(declare-const i1@422@04 Int)
(declare-const j@423@04 Int)
(push) ; 13
; [eval] 0 <= i1 && i1 < V && (0 <= j && j < V)
; [eval] 0 <= i1
(push) ; 14
; [then-branch: 233 | 0 <= i1@422@04 | live]
; [else-branch: 233 | !(0 <= i1@422@04) | live]
(push) ; 15
; [then-branch: 233 | 0 <= i1@422@04]
(assert (<= 0 i1@422@04))
; [eval] i1 < V
(push) ; 16
; [then-branch: 234 | i1@422@04 < V@15@04 | live]
; [else-branch: 234 | !(i1@422@04 < V@15@04) | live]
(push) ; 17
; [then-branch: 234 | i1@422@04 < V@15@04]
(assert (< i1@422@04 V@15@04))
; [eval] 0 <= j
(push) ; 18
; [then-branch: 235 | 0 <= j@423@04 | live]
; [else-branch: 235 | !(0 <= j@423@04) | live]
(push) ; 19
; [then-branch: 235 | 0 <= j@423@04]
(assert (<= 0 j@423@04))
; [eval] j < V
(pop) ; 19
(push) ; 19
; [else-branch: 235 | !(0 <= j@423@04)]
(assert (not (<= 0 j@423@04)))
(pop) ; 19
(pop) ; 18
; Joined path conditions
; Joined path conditions
(pop) ; 17
(push) ; 17
; [else-branch: 234 | !(i1@422@04 < V@15@04)]
(assert (not (< i1@422@04 V@15@04)))
(pop) ; 17
(pop) ; 16
; Joined path conditions
; Joined path conditions
(pop) ; 15
(push) ; 15
; [else-branch: 233 | !(0 <= i1@422@04)]
(assert (not (<= 0 i1@422@04)))
(pop) ; 15
(pop) ; 14
; Joined path conditions
; Joined path conditions
(assert (and
  (and (and (< j@423@04 V@15@04) (<= 0 j@423@04)) (< i1@422@04 V@15@04))
  (<= 0 i1@422@04)))
; [eval] aloc(opt_get1(aloc(opt_get1(G), i1).option$array$), j)
; [eval] opt_get1(aloc(opt_get1(G), i1).option$array$)
; [eval] aloc(opt_get1(G), i1)
; [eval] opt_get1(G)
(push) ; 14
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 14
; Joined path conditions
(push) ; 14
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 15
(assert (not (< i1@422@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))))
(check-sat)
; unsat
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1851920
;  :arith-add-rows          591705
;  :arith-assert-diseq      13247
;  :arith-assert-lower      301249
;  :arith-assert-upper      256070
;  :arith-bound-prop        21926
;  :arith-conflicts         728
;  :arith-eq-adapter        221425
;  :arith-fixed-eqs         274409
;  :arith-offset-eqs        206629
;  :arith-pivots            104847
;  :conflicts               2378
;  :datatype-accessor-ax    324
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               79843
;  :del-clause              7706398
;  :final-checks            5
;  :max-generation          13
;  :max-memory              144.52
;  :memory                  134.78
;  :minimized-lits          272
;  :mk-bool-var             7226708
;  :mk-clause               7708837
;  :num-allocs              17909984
;  :num-checks              438
;  :propagations            2008175
;  :quant-instantiations    3073835
;  :restarts                3
;  :rlimit-count            66374875)
(assert (< i1@422@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(pop) ; 14
; Joined path conditions
(assert (< i1@422@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@358@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@422@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@422@04)))
(push) ; 14
(assert (not (ite
  (and
    (<
      (inv@357@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@422@04))
      V@15@04)
    (<=
      0
      (inv@357@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@422@04))))
  (< $Perm.No $k@356@04)
  false)))
(check-sat)
; unsat
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1852047
;  :arith-add-rows          591766
;  :arith-assert-diseq      13247
;  :arith-assert-lower      301270
;  :arith-assert-upper      256088
;  :arith-bound-prop        21939
;  :arith-conflicts         729
;  :arith-eq-adapter        221443
;  :arith-fixed-eqs         274426
;  :arith-offset-eqs        206629
;  :arith-pivots            104865
;  :conflicts               2379
;  :datatype-accessor-ax    324
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               79843
;  :del-clause              7706398
;  :final-checks            5
;  :max-generation          13
;  :max-memory              144.52
;  :memory                  134.81
;  :minimized-lits          272
;  :mk-bool-var             7227294
;  :mk-clause               7709333
;  :num-allocs              17912590
;  :num-checks              439
;  :propagations            2008195
;  :quant-instantiations    3074075
;  :restarts                3
;  :rlimit-count            66386878)
(push) ; 14
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 15
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@358@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@422@04))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1852047
;  :arith-add-rows          591766
;  :arith-assert-diseq      13247
;  :arith-assert-lower      301270
;  :arith-assert-upper      256088
;  :arith-bound-prop        21939
;  :arith-conflicts         729
;  :arith-eq-adapter        221443
;  :arith-fixed-eqs         274426
;  :arith-offset-eqs        206629
;  :arith-pivots            104865
;  :conflicts               2380
;  :datatype-accessor-ax    324
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               79843
;  :del-clause              7706398
;  :final-checks            5
;  :max-generation          13
;  :max-memory              144.52
;  :memory                  134.81
;  :minimized-lits          272
;  :mk-bool-var             7227294
;  :mk-clause               7709333
;  :num-allocs              17912680
;  :num-checks              440
;  :propagations            2008195
;  :quant-instantiations    3074075
;  :restarts                3
;  :rlimit-count            66386973)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@358@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@422@04))
    (as None<option<array>>  option<array>))))
(pop) ; 14
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@358@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@422@04))
    (as None<option<array>>  option<array>))))
(push) ; 14
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 15
(assert (not (<
  j@423@04
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@358@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@422@04)))))))
(check-sat)
; unsat
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1852053
;  :arith-add-rows          591772
;  :arith-assert-diseq      13247
;  :arith-assert-lower      301273
;  :arith-assert-upper      256089
;  :arith-bound-prop        21939
;  :arith-conflicts         730
;  :arith-eq-adapter        221444
;  :arith-fixed-eqs         274427
;  :arith-offset-eqs        206629
;  :arith-pivots            104869
;  :conflicts               2381
;  :datatype-accessor-ax    324
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               79843
;  :del-clause              7706402
;  :final-checks            5
;  :max-generation          13
;  :max-memory              144.52
;  :memory                  134.81
;  :minimized-lits          272
;  :mk-bool-var             7227305
;  :mk-clause               7709337
;  :num-allocs              17912884
;  :num-checks              441
;  :propagations            2008197
;  :quant-instantiations    3074084
;  :restarts                3
;  :rlimit-count            66387562)
(assert (<
  j@423@04
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@358@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@422@04))))))
(pop) ; 14
; Joined path conditions
(assert (<
  j@423@04
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@358@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@422@04))))))
(pop) ; 13
(declare-fun inv@424@04 ($Ref) Int)
(declare-fun inv@425@04 ($Ref) Int)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(assert (forall ((i1@422@04 Int) (j@423@04 Int)) (!
  (and
    (< i1@422@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@358@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@422@04)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@422@04))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@358@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@422@04))
        (as None<option<array>>  option<array>)))
    (<
      j@423@04
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@358@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@422@04))))))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@358@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@422@04))) j@423@04))
  :qid |int-aux|)))
(declare-const sm@426@04 $FVF<Int>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@366@04 r) V@15@04) (<= 0 (inv@366@04 r)))
        (< (inv@365@04 r) V@15@04))
      (<= 0 (inv@365@04 r)))
    (=
      ($FVF.lookup_int (as sm@426@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@426@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))))))) r))
  :qid |qp.fvfValDef308|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@369@04 r) V@15@04) (<= 0 (inv@369@04 r)))
    (=
      ($FVF.lookup_int (as sm@426@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04)))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@426@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04)))))))))))))) r))
  :qid |qp.fvfValDef309|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04)))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@426@04  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef310|)))
; Check receiver injectivity
(push) ; 13
(assert (not (forall ((i11@422@04 Int) (j1@423@04 Int) (i12@422@04 Int) (j2@423@04 Int)) (!
  (implies
    (and
      (and
        (and
          (and
            (and (< j1@423@04 V@15@04) (<= 0 j1@423@04))
            (< i11@422@04 V@15@04))
          (<= 0 i11@422@04))
        ($FVF.loc_int ($FVF.lookup_int (as sm@426@04  $FVF<Int>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@358@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i11@422@04))) j1@423@04)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@358@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i11@422@04))) j1@423@04)))
      (and
        (and
          (and
            (and (< j2@423@04 V@15@04) (<= 0 j2@423@04))
            (< i12@422@04 V@15@04))
          (<= 0 i12@422@04))
        ($FVF.loc_int ($FVF.lookup_int (as sm@426@04  $FVF<Int>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@358@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i12@422@04))) j2@423@04)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@358@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i12@422@04))) j2@423@04)))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@358@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i11@422@04))) j1@423@04)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@358@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i12@422@04))) j2@423@04)))
    (and (= i11@422@04 i12@422@04) (= j1@423@04 j2@423@04)))
  
  :qid |int-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1852153
;  :arith-add-rows          591825
;  :arith-assert-diseq      13247
;  :arith-assert-lower      301281
;  :arith-assert-upper      256091
;  :arith-bound-prop        21940
;  :arith-conflicts         730
;  :arith-eq-adapter        221456
;  :arith-fixed-eqs         274427
;  :arith-offset-eqs        206630
;  :arith-pivots            104893
;  :conflicts               2382
;  :datatype-accessor-ax    324
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               79843
;  :del-clause              7707202
;  :final-checks            5
;  :max-generation          13
;  :max-memory              144.52
;  :memory                  134.85
;  :minimized-lits          272
;  :mk-bool-var             7227707
;  :mk-clause               7709645
;  :num-allocs              17916215
;  :num-checks              442
;  :propagations            2008213
;  :quant-instantiations    3074322
;  :restarts                3
;  :rlimit-count            66400449
;  :time                    0.00)
; Definitional axioms for inverse functions
(assert (forall ((i1@422@04 Int) (j@423@04 Int)) (!
  (implies
    (and
      (and (and (< j@423@04 V@15@04) (<= 0 j@423@04)) (< i1@422@04 V@15@04))
      (<= 0 i1@422@04))
    (and
      (=
        (inv@424@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@358@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@422@04))) j@423@04))
        i1@422@04)
      (=
        (inv@425@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@358@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@422@04))) j@423@04))
        j@423@04)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@358@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@422@04))) j@423@04))
  :qid |int-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@425@04 r) V@15@04) (<= 0 (inv@425@04 r)))
        (< (inv@424@04 r) V@15@04))
      (<= 0 (inv@424@04 r)))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@358@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) (inv@424@04 r)))) (inv@425@04 r))
      r))
  :pattern ((inv@424@04 r))
  :pattern ((inv@425@04 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@425@04 r) V@15@04) (<= 0 (inv@425@04 r)))
        (< (inv@424@04 r) V@15@04))
      (<= 0 (inv@424@04 r)))
    ($FVF.loc_int ($FVF.lookup_int (as sm@426@04  $FVF<Int>) r) r))
  :pattern ((inv@424@04 r) (inv@425@04 r))
  )))
; Precomputing data for removing quantified permissions
(define-fun pTaken@427@04 ((r $Ref)) $Perm
  (ite
    (and
      (and
        (and (< (inv@425@04 r) V@15@04) (<= 0 (inv@425@04 r)))
        (< (inv@424@04 r) V@15@04))
      (<= 0 (inv@424@04 r)))
    ($Perm.min
      (ite
        (and
          (and
            (and (< (inv@366@04 r) V@15@04) (<= 0 (inv@366@04 r)))
            (< (inv@365@04 r) V@15@04))
          (<= 0 (inv@365@04 r)))
        $Perm.Write
        $Perm.No)
      $Perm.Write)
    $Perm.No))
(define-fun pTaken@428@04 ((r $Ref)) $Perm
  (ite
    (and
      (and
        (and (< (inv@425@04 r) V@15@04) (<= 0 (inv@425@04 r)))
        (< (inv@424@04 r) V@15@04))
      (<= 0 (inv@424@04 r)))
    ($Perm.min
      (ite
        (and (< (inv@369@04 r) V@15@04) (<= 0 (inv@369@04 r)))
        $Perm.Write
        $Perm.No)
      (- $Perm.Write (pTaken@427@04 r)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 500)
(push) ; 13
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and
          (and
            (and (< (inv@366@04 r) V@15@04) (<= 0 (inv@366@04 r)))
            (< (inv@365@04 r) V@15@04))
          (<= 0 (inv@365@04 r)))
        $Perm.Write
        $Perm.No)
      (pTaken@427@04 r))
    $Perm.No)
  
  ))))
(check-sat)
; unsat
(pop) ; 13
; 0.06s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1854638
;  :arith-add-rows          594746
;  :arith-assert-diseq      13284
;  :arith-assert-lower      301700
;  :arith-assert-upper      256350
;  :arith-bound-prop        22024
;  :arith-conflicts         738
;  :arith-eq-adapter        221723
;  :arith-fixed-eqs         274666
;  :arith-offset-eqs        206968
;  :arith-pivots            105148
;  :conflicts               2409
;  :datatype-accessor-ax    324
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               80285
;  :del-clause              7722930
;  :final-checks            5
;  :max-generation          13
;  :max-memory              144.52
;  :memory                  134.97
;  :minimized-lits          272
;  :mk-bool-var             7241539
;  :mk-clause               7725378
;  :num-allocs              17952360
;  :num-checks              444
;  :propagations            2010749
;  :quant-instantiations    3077610
;  :restarts                3
;  :rlimit-count            66569666
;  :time                    0.06)
; Intermediate check if already taken enough permissions
(push) ; 13
(assert (not (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@425@04 r) V@15@04) (<= 0 (inv@425@04 r)))
        (< (inv@424@04 r) V@15@04))
      (<= 0 (inv@424@04 r)))
    (= (- $Perm.Write (pTaken@427@04 r)) $Perm.No))
  
  ))))
(check-sat)
; unsat
(pop) ; 13
; 0.05s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1856315
;  :arith-add-rows          596382
;  :arith-assert-diseq      13305
;  :arith-assert-lower      301953
;  :arith-assert-upper      256519
;  :arith-bound-prop        22089
;  :arith-conflicts         746
;  :arith-eq-adapter        221870
;  :arith-fixed-eqs         274821
;  :arith-offset-eqs        207171
;  :arith-pivots            105312
;  :conflicts               2432
;  :datatype-accessor-ax    324
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               80644
;  :del-clause              7734876
;  :final-checks            5
;  :max-generation          13
;  :max-memory              144.52
;  :memory                  134.96
;  :minimized-lits          272
;  :mk-bool-var             7250757
;  :mk-clause               7737324
;  :num-allocs              17974223
;  :num-checks              445
;  :propagations            2012752
;  :quant-instantiations    3079845
;  :restarts                3
;  :rlimit-count            66689720
;  :time                    0.05)
; Final check if taken enough permissions
; Done removing quantified permissions
; Definitional axioms for snapshot map values
; [eval] P != (None(): option[array])
; [eval] (None(): option[array])
; [eval] alen(opt_get1(P)) == V
; [eval] alen(opt_get1(P))
; [eval] opt_get1(P)
(push) ; 13
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 13
; Joined path conditions
(declare-const i1@429@04 Int)
(push) ; 13
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 14
; [then-branch: 236 | 0 <= i1@429@04 | live]
; [else-branch: 236 | !(0 <= i1@429@04) | live]
(push) ; 15
; [then-branch: 236 | 0 <= i1@429@04]
(assert (<= 0 i1@429@04))
; [eval] i1 < V
(pop) ; 15
(push) ; 15
; [else-branch: 236 | !(0 <= i1@429@04)]
(assert (not (<= 0 i1@429@04)))
(pop) ; 15
(pop) ; 14
; Joined path conditions
; Joined path conditions
(assert (and (< i1@429@04 V@15@04) (<= 0 i1@429@04)))
; [eval] aloc(opt_get1(P), i1)
; [eval] opt_get1(P)
(push) ; 14
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 14
; Joined path conditions
(push) ; 14
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 15
(assert (not (< i1@429@04 (alen<Int> (opt_get1 $Snap.unit P@14@04)))))
(check-sat)
; unsat
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1856315
;  :arith-add-rows          596383
;  :arith-assert-diseq      13305
;  :arith-assert-lower      301955
;  :arith-assert-upper      256519
;  :arith-bound-prop        22089
;  :arith-conflicts         746
;  :arith-eq-adapter        221870
;  :arith-fixed-eqs         274821
;  :arith-offset-eqs        207171
;  :arith-pivots            105312
;  :conflicts               2432
;  :datatype-accessor-ax    324
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               80644
;  :del-clause              7734876
;  :final-checks            5
;  :max-generation          13
;  :max-memory              144.52
;  :memory                  134.96
;  :minimized-lits          272
;  :mk-bool-var             7250759
;  :mk-clause               7737324
;  :num-allocs              17974332
;  :num-checks              446
;  :propagations            2012752
;  :quant-instantiations    3079845
;  :restarts                3
;  :rlimit-count            66689906)
(assert (< i1@429@04 (alen<Int> (opt_get1 $Snap.unit P@14@04))))
(pop) ; 14
; Joined path conditions
(assert (< i1@429@04 (alen<Int> (opt_get1 $Snap.unit P@14@04))))
(pop) ; 13
(declare-fun inv@430@04 ($Ref) Int)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(assert (forall ((i1@429@04 Int)) (!
  (< i1@429@04 (alen<Int> (opt_get1 $Snap.unit P@14@04)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i1@429@04))
  :qid |int-aux|)))
(declare-const sm@431@04 $FVF<Int>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@369@04 r) V@15@04) (<= 0 (inv@369@04 r)))
    (=
      ($FVF.lookup_int (as sm@431@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04)))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@431@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04)))))))))))))) r))
  :qid |qp.fvfValDef311|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04)))))))))))))) r) r)
  :pattern (($FVF.lookup_int (as sm@431@04  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef312|)))
; Check receiver injectivity
(push) ; 13
(assert (not (forall ((i11@429@04 Int) (i12@429@04 Int)) (!
  (implies
    (and
      (and
        (and (< i11@429@04 V@15@04) (<= 0 i11@429@04))
        ($FVF.loc_int ($FVF.lookup_int (as sm@431@04  $FVF<Int>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit P@14@04) i11@429@04)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit P@14@04) i11@429@04)))
      (and
        (and (< i12@429@04 V@15@04) (<= 0 i12@429@04))
        ($FVF.loc_int ($FVF.lookup_int (as sm@431@04  $FVF<Int>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit P@14@04) i12@429@04)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit P@14@04) i12@429@04)))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i11@429@04)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i12@429@04)))
    (= i11@429@04 i12@429@04))
  
  :qid |int-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1856368
;  :arith-add-rows          596390
;  :arith-assert-diseq      13306
;  :arith-assert-lower      301959
;  :arith-assert-upper      256519
;  :arith-bound-prop        22089
;  :arith-conflicts         746
;  :arith-eq-adapter        221871
;  :arith-fixed-eqs         274821
;  :arith-offset-eqs        207171
;  :arith-pivots            105314
;  :conflicts               2433
;  :datatype-accessor-ax    324
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               80644
;  :del-clause              7734883
;  :final-checks            5
;  :max-generation          13
;  :max-memory              144.52
;  :memory                  134.96
;  :minimized-lits          272
;  :mk-bool-var             7250831
;  :mk-clause               7737333
;  :num-allocs              17975402
;  :num-checks              447
;  :propagations            2012752
;  :quant-instantiations    3079931
;  :restarts                3
;  :rlimit-count            66693256
;  :time                    0.00)
; Definitional axioms for inverse functions
(assert (forall ((i1@429@04 Int)) (!
  (implies
    (and (< i1@429@04 V@15@04) (<= 0 i1@429@04))
    (=
      (inv@430@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i1@429@04))
      i1@429@04))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i1@429@04))
  :qid |int-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@430@04 r) V@15@04) (<= 0 (inv@430@04 r)))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) (inv@430@04 r))
      r))
  :pattern ((inv@430@04 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@430@04 r) V@15@04) (<= 0 (inv@430@04 r)))
    ($FVF.loc_int ($FVF.lookup_int (as sm@431@04  $FVF<Int>) r) r))
  :pattern ((inv@430@04 r))
  )))
; Precomputing data for removing quantified permissions
(define-fun pTaken@432@04 ((r $Ref)) $Perm
  (ite
    (and (< (inv@430@04 r) V@15@04) (<= 0 (inv@430@04 r)))
    ($Perm.min
      (ite
        (and (< (inv@369@04 r) V@15@04) (<= 0 (inv@369@04 r)))
        $Perm.Write
        $Perm.No)
      $Perm.Write)
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 500)
(push) ; 13
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and (< (inv@369@04 r) V@15@04) (<= 0 (inv@369@04 r)))
        $Perm.Write
        $Perm.No)
      (pTaken@432@04 r))
    $Perm.No)
  
  ))))
(check-sat)
; unsat
(pop) ; 13
; 0.05s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1858617
;  :arith-add-rows          598647
;  :arith-assert-diseq      13345
;  :arith-assert-lower      302355
;  :arith-assert-upper      256756
;  :arith-bound-prop        22182
;  :arith-conflicts         755
;  :arith-eq-adapter        222106
;  :arith-fixed-eqs         275033
;  :arith-offset-eqs        207428
;  :arith-pivots            105541
;  :conflicts               2459
;  :datatype-accessor-ax    324
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               81076
;  :del-clause              7749526
;  :final-checks            5
;  :max-generation          13
;  :max-memory              144.52
;  :memory                  134.97
;  :minimized-lits          272
;  :mk-bool-var             7263547
;  :mk-clause               7751977
;  :num-allocs              18007423
;  :num-checks              449
;  :propagations            2014988
;  :quant-instantiations    3082814
;  :restarts                3
;  :rlimit-count            66844662
;  :time                    0.04)
; Intermediate check if already taken enough permissions
(push) ; 13
(assert (not (forall ((r $Ref)) (!
  (implies
    (and (< (inv@430@04 r) V@15@04) (<= 0 (inv@430@04 r)))
    (= (- $Perm.Write (pTaken@432@04 r)) $Perm.No))
  
  ))))
(check-sat)
; unsat
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1858683
;  :arith-add-rows          599349
;  :arith-assert-diseq      13347
;  :arith-assert-lower      302374
;  :arith-assert-upper      256776
;  :arith-bound-prop        22183
;  :arith-conflicts         756
;  :arith-eq-adapter        222124
;  :arith-fixed-eqs         275049
;  :arith-offset-eqs        207428
;  :arith-pivots            105549
;  :conflicts               2460
;  :datatype-accessor-ax    324
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               81076
;  :del-clause              7749705
;  :final-checks            5
;  :max-generation          13
;  :max-memory              144.52
;  :memory                  134.98
;  :minimized-lits          272
;  :mk-bool-var             7263773
;  :mk-clause               7752156
;  :num-allocs              18008561
;  :num-checks              450
;  :propagations            2014993
;  :quant-instantiations    3082907
;  :restarts                3
;  :rlimit-count            66864175
;  :time                    0.00)
; Final check if taken enough permissions
; Done removing quantified permissions
; Definitional axioms for snapshot map values
; [eval] valid_graph_vertices(this, P, V)
(push) ; 13
; [eval] this != null
; [eval] p != (None(): option[array])
; [eval] (None(): option[array])
; [eval] alen(opt_get1(p)) == V
; [eval] alen(opt_get1(p))
; [eval] opt_get1(p)
(push) ; 14
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 14
; Joined path conditions
(declare-const i1@433@04 Int)
(push) ; 14
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 15
; [then-branch: 237 | 0 <= i1@433@04 | live]
; [else-branch: 237 | !(0 <= i1@433@04) | live]
(push) ; 16
; [then-branch: 237 | 0 <= i1@433@04]
(assert (<= 0 i1@433@04))
; [eval] i1 < V
(pop) ; 16
(push) ; 16
; [else-branch: 237 | !(0 <= i1@433@04)]
(assert (not (<= 0 i1@433@04)))
(pop) ; 16
(pop) ; 15
; Joined path conditions
; Joined path conditions
(assert (and (< i1@433@04 V@15@04) (<= 0 i1@433@04)))
(declare-const $k@434@04 $Perm)
(assert ($Perm.isReadVar $k@434@04 $Perm.Write))
; [eval] aloc(opt_get1(p), i1)
; [eval] opt_get1(p)
(push) ; 15
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 15
; Joined path conditions
(push) ; 15
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 16
(assert (not (< i1@433@04 (alen<Int> (opt_get1 $Snap.unit P@14@04)))))
(check-sat)
; unsat
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1858683
;  :arith-add-rows          599350
;  :arith-assert-diseq      13348
;  :arith-assert-lower      302378
;  :arith-assert-upper      256777
;  :arith-bound-prop        22183
;  :arith-conflicts         756
;  :arith-eq-adapter        222125
;  :arith-fixed-eqs         275049
;  :arith-offset-eqs        207428
;  :arith-pivots            105549
;  :conflicts               2460
;  :datatype-accessor-ax    324
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               81076
;  :del-clause              7749705
;  :final-checks            5
;  :max-generation          13
;  :max-memory              144.52
;  :memory                  134.98
;  :minimized-lits          272
;  :mk-bool-var             7263779
;  :mk-clause               7752158
;  :num-allocs              18008738
;  :num-checks              451
;  :propagations            2014994
;  :quant-instantiations    3082907
;  :restarts                3
;  :rlimit-count            66864507)
(assert (< i1@433@04 (alen<Int> (opt_get1 $Snap.unit P@14@04))))
(pop) ; 15
; Joined path conditions
(assert (< i1@433@04 (alen<Int> (opt_get1 $Snap.unit P@14@04))))
(pop) ; 14
(declare-fun inv@435@04 ($Ref) Int)
; Nested auxiliary terms: globals
(assert ($Perm.isReadVar $k@434@04 $Perm.Write))
; Nested auxiliary terms: non-globals
(assert (forall ((i1@433@04 Int)) (!
  (< i1@433@04 (alen<Int> (opt_get1 $Snap.unit P@14@04)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i1@433@04))
  :qid |int-aux|)))
(push) ; 14
(assert (not (forall ((i1@433@04 Int)) (!
  (implies
    (and (< i1@433@04 V@15@04) (<= 0 i1@433@04))
    (or (= $k@434@04 $Perm.No) (< $Perm.No $k@434@04)))
  
  ))))
(check-sat)
; unsat
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1858683
;  :arith-add-rows          599351
;  :arith-assert-diseq      13349
;  :arith-assert-lower      302380
;  :arith-assert-upper      256778
;  :arith-bound-prop        22183
;  :arith-conflicts         756
;  :arith-eq-adapter        222126
;  :arith-fixed-eqs         275049
;  :arith-offset-eqs        207428
;  :arith-pivots            105549
;  :conflicts               2461
;  :datatype-accessor-ax    324
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               81076
;  :del-clause              7749707
;  :final-checks            5
;  :max-generation          13
;  :max-memory              144.52
;  :memory                  134.98
;  :minimized-lits          272
;  :mk-bool-var             7263786
;  :mk-clause               7752160
;  :num-allocs              18009167
;  :num-checks              452
;  :propagations            2014995
;  :quant-instantiations    3082908
;  :restarts                3
;  :rlimit-count            66865064)
(declare-const sm@436@04 $FVF<Int>)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@369@04 r) V@15@04) (<= 0 (inv@369@04 r)))
    (=
      ($FVF.lookup_int (as sm@436@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04)))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@436@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04)))))))))))))) r))
  :qid |qp.fvfValDef313|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@366@04 r) V@15@04) (<= 0 (inv@366@04 r)))
        (< (inv@365@04 r) V@15@04))
      (<= 0 (inv@365@04 r)))
    (=
      ($FVF.lookup_int (as sm@436@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@436@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))))))) r))
  :qid |qp.fvfValDef314|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04)))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@436@04  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef315|)))
; Check receiver injectivity
(push) ; 14
(assert (not (forall ((i11@433@04 Int) (i12@433@04 Int)) (!
  (implies
    (and
      (and
        (and
          (and (< i11@433@04 V@15@04) (<= 0 i11@433@04))
          ($FVF.loc_int ($FVF.lookup_int (as sm@436@04  $FVF<Int>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit P@14@04) i11@433@04)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit P@14@04) i11@433@04)))
        (< $Perm.No $k@434@04))
      (and
        (and
          (and (< i12@433@04 V@15@04) (<= 0 i12@433@04))
          ($FVF.loc_int ($FVF.lookup_int (as sm@436@04  $FVF<Int>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit P@14@04) i12@433@04)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit P@14@04) i12@433@04)))
        (< $Perm.No $k@434@04))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i11@433@04)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i12@433@04)))
    (= i11@433@04 i12@433@04))
  
  :qid |int-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1858738
;  :arith-add-rows          599358
;  :arith-assert-diseq      13350
;  :arith-assert-lower      302384
;  :arith-assert-upper      256778
;  :arith-bound-prop        22183
;  :arith-conflicts         756
;  :arith-eq-adapter        222127
;  :arith-fixed-eqs         275049
;  :arith-offset-eqs        207428
;  :arith-pivots            105549
;  :conflicts               2462
;  :datatype-accessor-ax    324
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               81076
;  :del-clause              7749718
;  :final-checks            5
;  :max-generation          13
;  :max-memory              144.52
;  :memory                  134.94
;  :minimized-lits          272
;  :mk-bool-var             7263869
;  :mk-clause               7752175
;  :num-allocs              18010375
;  :num-checks              453
;  :propagations            2014997
;  :quant-instantiations    3083000
;  :restarts                3
;  :rlimit-count            66869144)
; Definitional axioms for inverse functions
(assert (forall ((i1@433@04 Int)) (!
  (implies
    (and (and (< i1@433@04 V@15@04) (<= 0 i1@433@04)) (< $Perm.No $k@434@04))
    (=
      (inv@435@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i1@433@04))
      i1@433@04))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i1@433@04))
  :qid |int-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and (< (inv@435@04 r) V@15@04) (<= 0 (inv@435@04 r)))
      (< $Perm.No $k@434@04))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) (inv@435@04 r))
      r))
  :pattern ((inv@435@04 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@435@04 r) V@15@04) (<= 0 (inv@435@04 r)))
    ($FVF.loc_int ($FVF.lookup_int (as sm@436@04  $FVF<Int>) r) r))
  :pattern ((inv@435@04 r))
  )))
; Precomputing data for removing quantified permissions
(define-fun pTaken@437@04 ((r $Ref)) $Perm
  (ite
    (and (< (inv@435@04 r) V@15@04) (<= 0 (inv@435@04 r)))
    ($Perm.min
      (ite
        (and (< (inv@369@04 r) V@15@04) (<= 0 (inv@369@04 r)))
        $Perm.Write
        $Perm.No)
      $k@434@04)
    $Perm.No))
(define-fun pTaken@438@04 ((r $Ref)) $Perm
  (ite
    (and (< (inv@435@04 r) V@15@04) (<= 0 (inv@435@04 r)))
    ($Perm.min
      (ite
        (and
          (and
            (and (< (inv@366@04 r) V@15@04) (<= 0 (inv@366@04 r)))
            (< (inv@365@04 r) V@15@04))
          (<= 0 (inv@365@04 r)))
        $Perm.Write
        $Perm.No)
      (- $k@434@04 (pTaken@437@04 r)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Constrain original permissions $k@434@04
(assert (forall ((r $Ref)) (!
  (implies
    (not
      (=
        (ite
          (and (< (inv@369@04 r) V@15@04) (<= 0 (inv@369@04 r)))
          $Perm.Write
          $Perm.No)
        $Perm.No))
    (ite
      (and (< (inv@369@04 r) V@15@04) (<= 0 (inv@369@04 r)))
      (<
        (ite
          (and (< (inv@435@04 r) V@15@04) (<= 0 (inv@435@04 r)))
          $k@434@04
          $Perm.No)
        $Perm.Write)
      (<
        (ite
          (and (< (inv@435@04 r) V@15@04) (<= 0 (inv@435@04 r)))
          $k@434@04
          $Perm.No)
        $Perm.No)))
  :pattern ((inv@369@04 r))
  :pattern ((inv@435@04 r))
  :qid |qp.srp316|)))
; Intermediate check if already taken enough permissions
(set-option :timeout 500)
(push) ; 14
(assert (not (forall ((r $Ref)) (!
  (implies
    (and (< (inv@435@04 r) V@15@04) (<= 0 (inv@435@04 r)))
    (= (- $k@434@04 (pTaken@437@04 r)) $Perm.No))
  
  ))))
(check-sat)
; unsat
(pop) ; 14
; 0.04s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1860948
;  :arith-add-rows          601061
;  :arith-assert-diseq      13388
;  :arith-assert-lower      302763
;  :arith-assert-upper      256994
;  :arith-bound-prop        22271
;  :arith-conflicts         763
;  :arith-eq-adapter        222350
;  :arith-fixed-eqs         275244
;  :arith-offset-eqs        207610
;  :arith-pivots            105724
;  :conflicts               2487
;  :datatype-accessor-ax    324
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               81521
;  :del-clause              7764838
;  :final-checks            5
;  :max-generation          13
;  :max-memory              144.52
;  :memory                  135.00
;  :minimized-lits          272
;  :mk-bool-var             7275863
;  :mk-clause               7767309
;  :num-allocs              18039031
;  :num-checks              455
;  :propagations            2017507
;  :quant-instantiations    3085929
;  :restarts                3
;  :rlimit-count            67018911
;  :time                    0.04)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@439@04 $FVF<Int>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (iff
    (Set_in r ($FVF.domain_int (as sm@439@04  $FVF<Int>)))
    (and
      (and (< (inv@435@04 r) V@15@04) (<= 0 (inv@435@04 r)))
      (< $Perm.No $k@434@04)))
  :pattern ((Set_in r ($FVF.domain_int (as sm@439@04  $FVF<Int>))))
  :qid |qp.fvfDomDef320|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@435@04 r) V@15@04) (<= 0 (inv@435@04 r)))
        (< $Perm.No $k@434@04))
      (and (< (inv@369@04 r) V@15@04) (<= 0 (inv@369@04 r))))
    (=
      ($FVF.lookup_int (as sm@439@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04)))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@439@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04)))))))))))))) r))
  :qid |qp.fvfValDef317|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@435@04 r) V@15@04) (<= 0 (inv@435@04 r)))
        (< $Perm.No $k@434@04))
      (and
        (and
          (and (< (inv@366@04 r) V@15@04) (<= 0 (inv@366@04 r)))
          (< (inv@365@04 r) V@15@04))
        (<= 0 (inv@365@04 r))))
    (=
      ($FVF.lookup_int (as sm@439@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@439@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))))))) r))
  :qid |qp.fvfValDef318|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04)))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@439@04  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef319|)))
(pop) ; 13
; Joined path conditions
(assert ($Perm.isReadVar $k@434@04 $Perm.Write))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@369@04 r) V@15@04) (<= 0 (inv@369@04 r)))
    (=
      ($FVF.lookup_int (as sm@436@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04)))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@436@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04)))))))))))))) r))
  :qid |qp.fvfValDef313|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@366@04 r) V@15@04) (<= 0 (inv@366@04 r)))
        (< (inv@365@04 r) V@15@04))
      (<= 0 (inv@365@04 r)))
    (=
      ($FVF.lookup_int (as sm@436@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@436@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))))))) r))
  :qid |qp.fvfValDef314|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04)))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@436@04  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef315|)))
(assert (forall ((i1@433@04 Int)) (!
  (implies
    (and (and (< i1@433@04 V@15@04) (<= 0 i1@433@04)) (< $Perm.No $k@434@04))
    (=
      (inv@435@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i1@433@04))
      i1@433@04))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i1@433@04))
  :qid |int-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and (< (inv@435@04 r) V@15@04) (<= 0 (inv@435@04 r)))
      (< $Perm.No $k@434@04))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) (inv@435@04 r))
      r))
  :pattern ((inv@435@04 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (iff
    (Set_in r ($FVF.domain_int (as sm@439@04  $FVF<Int>)))
    (and
      (and (< (inv@435@04 r) V@15@04) (<= 0 (inv@435@04 r)))
      (< $Perm.No $k@434@04)))
  :pattern ((Set_in r ($FVF.domain_int (as sm@439@04  $FVF<Int>))))
  :qid |qp.fvfDomDef320|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@435@04 r) V@15@04) (<= 0 (inv@435@04 r)))
        (< $Perm.No $k@434@04))
      (and (< (inv@369@04 r) V@15@04) (<= 0 (inv@369@04 r))))
    (=
      ($FVF.lookup_int (as sm@439@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04)))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@439@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04)))))))))))))) r))
  :qid |qp.fvfValDef317|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@435@04 r) V@15@04) (<= 0 (inv@435@04 r)))
        (< $Perm.No $k@434@04))
      (and
        (and
          (and (< (inv@366@04 r) V@15@04) (<= 0 (inv@366@04 r)))
          (< (inv@365@04 r) V@15@04))
        (<= 0 (inv@365@04 r))))
    (=
      ($FVF.lookup_int (as sm@439@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@439@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))))))) r))
  :qid |qp.fvfValDef318|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04)))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@439@04  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef319|)))
(assert (and
  (forall ((i1@433@04 Int)) (!
    (< i1@433@04 (alen<Int> (opt_get1 $Snap.unit P@14@04)))
    :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i1@433@04))
    :qid |int-aux|))
  (forall ((r $Ref)) (!
    (implies
      (and (< (inv@435@04 r) V@15@04) (<= 0 (inv@435@04 r)))
      ($FVF.loc_int ($FVF.lookup_int (as sm@436@04  $FVF<Int>) r) r))
    :pattern ((inv@435@04 r))
    ))
  (forall ((r $Ref)) (!
    (implies
      (not
        (=
          (ite
            (and (< (inv@369@04 r) V@15@04) (<= 0 (inv@369@04 r)))
            $Perm.Write
            $Perm.No)
          $Perm.No))
      (ite
        (and (< (inv@369@04 r) V@15@04) (<= 0 (inv@369@04 r)))
        (<
          (ite
            (and (< (inv@435@04 r) V@15@04) (<= 0 (inv@435@04 r)))
            $k@434@04
            $Perm.No)
          $Perm.Write)
        (<
          (ite
            (and (< (inv@435@04 r) V@15@04) (<= 0 (inv@435@04 r)))
            $k@434@04
            $Perm.No)
          $Perm.No)))
    :pattern ((inv@369@04 r))
    :pattern ((inv@435@04 r))
    :qid |qp.srp316|))))
(set-option :timeout 0)
(push) ; 13
(assert (not (valid_graph_vertices ($Snap.combine
  $Snap.unit
  ($Snap.combine
    $Snap.unit
    ($Snap.combine
      $Snap.unit
      ($SortWrappers.$FVF<Int>To$Snap (as sm@439@04  $FVF<Int>))))) this@9@04 P@14@04 V@15@04)))
(check-sat)
; unsat
(pop) ; 13
; 01m:42s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               6384507
;  :arith-add-rows          1483352
;  :arith-assert-diseq      26382
;  :arith-assert-lower      1123689
;  :arith-assert-upper      987786
;  :arith-bound-prop        36401
;  :arith-conflicts         997
;  :arith-eq-adapter        603770
;  :arith-fixed-eqs         1059532
;  :arith-offset-eqs        665203
;  :arith-pivots            226385
;  :conflicts               2873
;  :datatype-accessor-ax    351
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               203188
;  :del-clause              21421523
;  :final-checks            5
;  :max-generation          14
;  :max-memory              266.02
;  :memory                  256.20
;  :minimized-lits          328
;  :mk-bool-var             18570636
;  :mk-clause               21423997
;  :num-allocs              44906831
;  :num-checks              456
;  :propagations            5851640
;  :quant-instantiations    8164705
;  :restarts                5
;  :rlimit-count            172583592
;  :time                    102.12)
(assert (valid_graph_vertices ($Snap.combine
  $Snap.unit
  ($Snap.combine
    $Snap.unit
    ($Snap.combine
      $Snap.unit
      ($SortWrappers.$FVF<Int>To$Snap (as sm@439@04  $FVF<Int>))))) this@9@04 P@14@04 V@15@04))
(pop) ; 12
(push) ; 12
; [else-branch: 221 | v@353@04 == s@12@04]
(assert (= v@353@04 s@12@04))
(pop) ; 12
; [eval] !(v != s)
; [eval] v != s
(set-option :timeout 10)
(push) ; 12
(assert (not (not (= v@353@04 s@12@04))))
(check-sat)
; unknown
(pop) ; 12
; 0.13s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               6384509
;  :arith-add-rows          1483632
;  :arith-assert-diseq      26382
;  :arith-assert-lower      1123689
;  :arith-assert-upper      987786
;  :arith-bound-prop        36401
;  :arith-conflicts         997
;  :arith-eq-adapter        603771
;  :arith-fixed-eqs         1059532
;  :arith-offset-eqs        665203
;  :arith-pivots            226434
;  :conflicts               2873
;  :datatype-accessor-ax    351
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               203188
;  :del-clause              21422248
;  :final-checks            5
;  :max-generation          14
;  :max-memory              266.02
;  :memory                  258.26
;  :minimized-lits          328
;  :mk-bool-var             18570640
;  :mk-clause               21424001
;  :num-allocs              44906929
;  :num-checks              457
;  :propagations            5851640
;  :quant-instantiations    8164705
;  :restarts                5
;  :rlimit-count            172588383
;  :time                    0.13)
(push) ; 12
(assert (not (= v@353@04 s@12@04)))
(check-sat)
; unknown
(pop) ; 12
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               6384846
;  :arith-add-rows          1483963
;  :arith-assert-diseq      26393
;  :arith-assert-lower      1123757
;  :arith-assert-upper      987835
;  :arith-bound-prop        36402
;  :arith-conflicts         997
;  :arith-eq-adapter        603812
;  :arith-fixed-eqs         1059592
;  :arith-offset-eqs        665221
;  :arith-pivots            226452
;  :conflicts               2873
;  :datatype-accessor-ax    351
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               203279
;  :del-clause              21425570
;  :final-checks            5
;  :max-generation          14
;  :max-memory              266.02
;  :memory                  258.13
;  :minimized-lits          328
;  :mk-bool-var             18573152
;  :mk-clause               21427323
;  :num-allocs              44913982
;  :num-checks              458
;  :propagations            5852077
;  :quant-instantiations    8165387
;  :restarts                5
;  :rlimit-count            172621500
;  :time                    0.01)
; [then-branch: 238 | v@353@04 == s@12@04 | live]
; [else-branch: 238 | v@353@04 != s@12@04 | live]
(push) ; 12
; [then-branch: 238 | v@353@04 == s@12@04]
(assert (= v@353@04 s@12@04))
; [exec]
; label loop2
; [exec]
; excBeforeLoop2 := exc
; [exec]
; v1 := t
(declare-const u@440@04 Int)
(declare-const v1@441@04 Int)
(push) ; 13
; Loop head block: Check well-definedness of invariant
(declare-const $t@442@04 $Snap)
(assert (= $t@442@04 ($Snap.combine ($Snap.first $t@442@04) ($Snap.second $t@442@04))))
(assert (= ($Snap.first $t@442@04) $Snap.unit))
; [eval] exc == excBeforeLoop2
(assert (=
  ($Snap.second $t@442@04)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@442@04))
    ($Snap.second ($Snap.second $t@442@04)))))
(assert (= ($Snap.first ($Snap.second $t@442@04)) $Snap.unit))
; [eval] 0 <= v1
(assert (<= 0 v1@441@04))
(assert (=
  ($Snap.second ($Snap.second $t@442@04))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second $t@442@04)))
    ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))
(assert (= ($Snap.first ($Snap.second ($Snap.second $t@442@04))) $Snap.unit))
; [eval] v1 < V
(assert (< v1@441@04 V@15@04))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second $t@442@04)))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@442@04))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04)))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@442@04))))
  $Snap.unit))
; [eval] G != (None(): option[array])
; [eval] (None(): option[array])
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04)))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04)))))
  $Snap.unit))
; [eval] alen(opt_get1(G)) == V
; [eval] alen(opt_get1(G))
; [eval] opt_get1(G)
(push) ; 14
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 14
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04)))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04)))))))))
(declare-const i1@443@04 Int)
(push) ; 14
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 15
; [then-branch: 239 | 0 <= i1@443@04 | live]
; [else-branch: 239 | !(0 <= i1@443@04) | live]
(push) ; 16
; [then-branch: 239 | 0 <= i1@443@04]
(assert (<= 0 i1@443@04))
; [eval] i1 < V
(pop) ; 16
(push) ; 16
; [else-branch: 239 | !(0 <= i1@443@04)]
(assert (not (<= 0 i1@443@04)))
(pop) ; 16
(pop) ; 15
; Joined path conditions
; Joined path conditions
(assert (and (< i1@443@04 V@15@04) (<= 0 i1@443@04)))
; [eval] aloc(opt_get1(G), i1)
; [eval] opt_get1(G)
(push) ; 15
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 15
; Joined path conditions
(push) ; 15
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 16
(assert (not (< i1@443@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))))
(check-sat)
; unsat
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               6384885
;  :arith-add-rows          1483967
;  :arith-assert-diseq      26393
;  :arith-assert-lower      1123762
;  :arith-assert-upper      987836
;  :arith-bound-prop        36402
;  :arith-conflicts         997
;  :arith-eq-adapter        603813
;  :arith-fixed-eqs         1059593
;  :arith-offset-eqs        665221
;  :arith-pivots            226455
;  :conflicts               2873
;  :datatype-accessor-ax    357
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               203279
;  :del-clause              21425570
;  :final-checks            5
;  :max-generation          14
;  :max-memory              266.02
;  :memory                  258.14
;  :minimized-lits          328
;  :mk-bool-var             18573171
;  :mk-clause               21427327
;  :num-allocs              44914532
;  :num-checks              459
;  :propagations            5852079
;  :quant-instantiations    8165387
;  :restarts                5
;  :rlimit-count            172622664)
(assert (< i1@443@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(pop) ; 15
; Joined path conditions
(assert (< i1@443@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(declare-const $k@444@04 $Perm)
(assert ($Perm.isReadVar $k@444@04 $Perm.Write))
(pop) ; 14
(declare-fun inv@445@04 ($Ref) Int)
; Nested auxiliary terms: globals
(assert ($Perm.isReadVar $k@444@04 $Perm.Write))
; Nested auxiliary terms: non-globals
(assert (forall ((i1@443@04 Int)) (!
  (< i1@443@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@443@04))
  :qid |option$array$-aux|)))
(push) ; 14
(assert (not (forall ((i1@443@04 Int)) (!
  (implies
    (and (< i1@443@04 V@15@04) (<= 0 i1@443@04))
    (or (= $k@444@04 $Perm.No) (< $Perm.No $k@444@04)))
  
  ))))
(check-sat)
; unsat
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               6384885
;  :arith-add-rows          1483968
;  :arith-assert-diseq      26394
;  :arith-assert-lower      1123764
;  :arith-assert-upper      987837
;  :arith-bound-prop        36402
;  :arith-conflicts         997
;  :arith-eq-adapter        603814
;  :arith-fixed-eqs         1059593
;  :arith-offset-eqs        665221
;  :arith-pivots            226456
;  :conflicts               2874
;  :datatype-accessor-ax    357
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               203279
;  :del-clause              21425570
;  :final-checks            5
;  :max-generation          14
;  :max-memory              266.02
;  :memory                  258.14
;  :minimized-lits          328
;  :mk-bool-var             18573178
;  :mk-clause               21427329
;  :num-allocs              44914998
;  :num-checks              460
;  :propagations            5852080
;  :quant-instantiations    8165387
;  :restarts                5
;  :rlimit-count            172623240)
; Check receiver injectivity
(push) ; 14
(assert (not (forall ((i11@443@04 Int) (i12@443@04 Int)) (!
  (implies
    (and
      (and (and (< i11@443@04 V@15@04) (<= 0 i11@443@04)) (< $Perm.No $k@444@04))
      (and (and (< i12@443@04 V@15@04) (<= 0 i12@443@04)) (< $Perm.No $k@444@04))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i11@443@04)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i12@443@04)))
    (= i11@443@04 i12@443@04))
  
  :qid |option$array$-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               6384933
;  :arith-add-rows          1483974
;  :arith-assert-diseq      26395
;  :arith-assert-lower      1123768
;  :arith-assert-upper      987837
;  :arith-bound-prop        36402
;  :arith-conflicts         997
;  :arith-eq-adapter        603815
;  :arith-fixed-eqs         1059593
;  :arith-offset-eqs        665221
;  :arith-pivots            226458
;  :conflicts               2875
;  :datatype-accessor-ax    357
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               203279
;  :del-clause              21425576
;  :final-checks            5
;  :max-generation          14
;  :max-memory              266.02
;  :memory                  255.14
;  :minimized-lits          328
;  :mk-bool-var             18573248
;  :mk-clause               21427335
;  :num-allocs              44915883
;  :num-checks              461
;  :propagations            5852080
;  :quant-instantiations    8165470
;  :restarts                5
;  :rlimit-count            172626032
;  :time                    0.00)
; Definitional axioms for inverse functions
(assert (forall ((i1@443@04 Int)) (!
  (implies
    (and (and (< i1@443@04 V@15@04) (<= 0 i1@443@04)) (< $Perm.No $k@444@04))
    (=
      (inv@445@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@443@04))
      i1@443@04))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@443@04))
  )))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and (< (inv@445@04 r) V@15@04) (<= 0 (inv@445@04 r)))
      (< $Perm.No $k@444@04))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) (inv@445@04 r))
      r))
  :pattern ((inv@445@04 r))
  :qid |option$array$-fctOfInv|)))
; Permissions are non-negative
(assert (forall ((i1@443@04 Int)) (!
  (<= $Perm.No $k@444@04)
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@443@04))
  :qid |option$array$-permAtLeastZero|)))
; Field permissions are at most one
(assert (forall ((i1@443@04 Int)) (!
  (<= $k@444@04 $Perm.Write)
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@443@04))
  :qid |option$array$-permAtMostOne|)))
; Permission implies non-null receiver
(assert (forall ((i1@443@04 Int)) (!
  (implies
    (and (and (< i1@443@04 V@15@04) (<= 0 i1@443@04)) (< $Perm.No $k@444@04))
    (not
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@443@04)
        $Ref.null)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@443@04))
  :qid |option$array$-permImpliesNonNull|)))
(declare-const sm@446@04 $FVF<option<array>>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@445@04 r) V@15@04) (<= 0 (inv@445@04 r)))
      (< $Perm.No $k@444@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))) r))
  :qid |qp.fvfValDef321|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))) r) r)
  :pattern (($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef322|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@445@04 r) V@15@04) (<= 0 (inv@445@04 r)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) r) r))
  :pattern ((inv@445@04 r))
  )))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04)))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04)))))))
  $Snap.unit))
; [eval] (forall i1: Int :: { aloc(opt_get1(G), i1) } 0 <= i1 && i1 < V ==> aloc(opt_get1(G), i1).option$array$ != (None(): option[array]))
(declare-const i1@447@04 Int)
(push) ; 14
; [eval] 0 <= i1 && i1 < V ==> aloc(opt_get1(G), i1).option$array$ != (None(): option[array])
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 15
; [then-branch: 240 | 0 <= i1@447@04 | live]
; [else-branch: 240 | !(0 <= i1@447@04) | live]
(push) ; 16
; [then-branch: 240 | 0 <= i1@447@04]
(assert (<= 0 i1@447@04))
; [eval] i1 < V
(pop) ; 16
(push) ; 16
; [else-branch: 240 | !(0 <= i1@447@04)]
(assert (not (<= 0 i1@447@04)))
(pop) ; 16
(pop) ; 15
; Joined path conditions
; Joined path conditions
(push) ; 15
; [then-branch: 241 | i1@447@04 < V@15@04 && 0 <= i1@447@04 | live]
; [else-branch: 241 | !(i1@447@04 < V@15@04 && 0 <= i1@447@04) | live]
(push) ; 16
; [then-branch: 241 | i1@447@04 < V@15@04 && 0 <= i1@447@04]
(assert (and (< i1@447@04 V@15@04) (<= 0 i1@447@04)))
; [eval] aloc(opt_get1(G), i1).option$array$ != (None(): option[array])
; [eval] aloc(opt_get1(G), i1)
; [eval] opt_get1(G)
(push) ; 17
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 17
; Joined path conditions
(push) ; 17
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 18
(assert (not (< i1@447@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))))
(check-sat)
; unsat
(pop) ; 18
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               6384939
;  :arith-add-rows          1483975
;  :arith-assert-diseq      26395
;  :arith-assert-lower      1123770
;  :arith-assert-upper      987838
;  :arith-bound-prop        36402
;  :arith-conflicts         997
;  :arith-eq-adapter        603815
;  :arith-fixed-eqs         1059593
;  :arith-offset-eqs        665221
;  :arith-pivots            226458
;  :conflicts               2875
;  :datatype-accessor-ax    358
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               203279
;  :del-clause              21425576
;  :final-checks            5
;  :max-generation          14
;  :max-memory              266.02
;  :memory                  255.14
;  :minimized-lits          328
;  :mk-bool-var             18573259
;  :mk-clause               21427335
;  :num-allocs              44917087
;  :num-checks              462
;  :propagations            5852080
;  :quant-instantiations    8165470
;  :restarts                5
;  :rlimit-count            172628470)
(assert (< i1@447@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(pop) ; 17
; Joined path conditions
(assert (< i1@447@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@447@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@447@04)))
(push) ; 17
(assert (not (ite
  (and
    (<
      (inv@445@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@447@04))
      V@15@04)
    (<=
      0
      (inv@445@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@447@04))))
  (< $Perm.No $k@444@04)
  false)))
(check-sat)
; unsat
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               6385066
;  :arith-add-rows          1484029
;  :arith-assert-diseq      26395
;  :arith-assert-lower      1123790
;  :arith-assert-upper      987855
;  :arith-bound-prop        36414
;  :arith-conflicts         998
;  :arith-eq-adapter        603831
;  :arith-fixed-eqs         1059609
;  :arith-offset-eqs        665221
;  :arith-pivots            226475
;  :conflicts               2876
;  :datatype-accessor-ax    358
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               203279
;  :del-clause              21425576
;  :final-checks            5
;  :max-generation          14
;  :max-memory              266.02
;  :memory                  253.67
;  :minimized-lits          328
;  :mk-bool-var             18573868
;  :mk-clause               21427746
;  :num-allocs              44919590
;  :num-checks              463
;  :propagations            5852086
;  :quant-instantiations    8165694
;  :restarts                5
;  :rlimit-count            172639152
;  :time                    0.00)
; [eval] (None(): option[array])
(pop) ; 16
(push) ; 16
; [else-branch: 241 | !(i1@447@04 < V@15@04 && 0 <= i1@447@04)]
(assert (not (and (< i1@447@04 V@15@04) (<= 0 i1@447@04))))
(pop) ; 16
(pop) ; 15
; Joined path conditions
(assert (implies
  (and (< i1@447@04 V@15@04) (<= 0 i1@447@04))
  (and
    (< i1@447@04 V@15@04)
    (<= 0 i1@447@04)
    (< i1@447@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@447@04)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@447@04)))))
; Joined path conditions
(pop) ; 14
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@447@04 Int)) (!
  (implies
    (and (< i1@447@04 V@15@04) (<= 0 i1@447@04))
    (and
      (< i1@447@04 V@15@04)
      (<= 0 i1@447@04)
      (< i1@447@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@447@04)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@447@04))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@447@04))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(assert (forall ((i1@447@04 Int)) (!
  (implies
    (and (< i1@447@04 V@15@04) (<= 0 i1@447@04))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@447@04))
        (as None<option<array>>  option<array>))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@447@04))
  :qid |prog.l<no position>|)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04)))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04)))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))))
  $Snap.unit))
; [eval] (forall i1: Int :: { alen(opt_get1(aloc(opt_get1(G), i1).option$array$)) } 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(G), i1).option$array$)) == V)
(declare-const i1@448@04 Int)
(push) ; 14
; [eval] 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(G), i1).option$array$)) == V
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 15
; [then-branch: 242 | 0 <= i1@448@04 | live]
; [else-branch: 242 | !(0 <= i1@448@04) | live]
(push) ; 16
; [then-branch: 242 | 0 <= i1@448@04]
(assert (<= 0 i1@448@04))
; [eval] i1 < V
(pop) ; 16
(push) ; 16
; [else-branch: 242 | !(0 <= i1@448@04)]
(assert (not (<= 0 i1@448@04)))
(pop) ; 16
(pop) ; 15
; Joined path conditions
; Joined path conditions
(push) ; 15
; [then-branch: 243 | i1@448@04 < V@15@04 && 0 <= i1@448@04 | live]
; [else-branch: 243 | !(i1@448@04 < V@15@04 && 0 <= i1@448@04) | live]
(push) ; 16
; [then-branch: 243 | i1@448@04 < V@15@04 && 0 <= i1@448@04]
(assert (and (< i1@448@04 V@15@04) (<= 0 i1@448@04)))
; [eval] alen(opt_get1(aloc(opt_get1(G), i1).option$array$)) == V
; [eval] alen(opt_get1(aloc(opt_get1(G), i1).option$array$))
; [eval] opt_get1(aloc(opt_get1(G), i1).option$array$)
; [eval] aloc(opt_get1(G), i1)
; [eval] opt_get1(G)
(push) ; 17
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 17
; Joined path conditions
(push) ; 17
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 18
(assert (not (< i1@448@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))))
(check-sat)
; unsat
(pop) ; 18
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               6385072
;  :arith-add-rows          1484043
;  :arith-assert-diseq      26395
;  :arith-assert-lower      1123792
;  :arith-assert-upper      987855
;  :arith-bound-prop        36414
;  :arith-conflicts         998
;  :arith-eq-adapter        603831
;  :arith-fixed-eqs         1059609
;  :arith-offset-eqs        665221
;  :arith-pivots            226493
;  :conflicts               2876
;  :datatype-accessor-ax    359
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               203279
;  :del-clause              21425987
;  :final-checks            5
;  :max-generation          14
;  :max-memory              266.02
;  :memory                  253.64
;  :minimized-lits          328
;  :mk-bool-var             18573874
;  :mk-clause               21427746
;  :num-allocs              44920129
;  :num-checks              464
;  :propagations            5852086
;  :quant-instantiations    8165694
;  :restarts                5
;  :rlimit-count            172640631)
(assert (< i1@448@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(pop) ; 17
; Joined path conditions
(assert (< i1@448@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@448@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@448@04)))
(push) ; 17
(assert (not (ite
  (and
    (<
      (inv@445@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@448@04))
      V@15@04)
    (<=
      0
      (inv@445@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@448@04))))
  (< $Perm.No $k@444@04)
  false)))
(check-sat)
; unsat
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               6385226
;  :arith-add-rows          1484110
;  :arith-assert-diseq      26395
;  :arith-assert-lower      1123812
;  :arith-assert-upper      987872
;  :arith-bound-prop        36427
;  :arith-conflicts         999
;  :arith-eq-adapter        603847
;  :arith-fixed-eqs         1059625
;  :arith-offset-eqs        665246
;  :arith-pivots            226510
;  :conflicts               2877
;  :datatype-accessor-ax    359
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               203279
;  :del-clause              21425987
;  :final-checks            5
;  :max-generation          14
;  :max-memory              266.02
;  :memory                  252.92
;  :minimized-lits          328
;  :mk-bool-var             18574484
;  :mk-clause               21428157
;  :num-allocs              44922632
;  :num-checks              465
;  :propagations            5852095
;  :quant-instantiations    8165920
;  :restarts                5
;  :rlimit-count            172651324)
(push) ; 17
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 18
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@448@04))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 18
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               6385226
;  :arith-add-rows          1484110
;  :arith-assert-diseq      26395
;  :arith-assert-lower      1123812
;  :arith-assert-upper      987872
;  :arith-bound-prop        36427
;  :arith-conflicts         999
;  :arith-eq-adapter        603847
;  :arith-fixed-eqs         1059625
;  :arith-offset-eqs        665246
;  :arith-pivots            226510
;  :conflicts               2878
;  :datatype-accessor-ax    359
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               203279
;  :del-clause              21425987
;  :final-checks            5
;  :max-generation          14
;  :max-memory              266.02
;  :memory                  252.92
;  :minimized-lits          328
;  :mk-bool-var             18574484
;  :mk-clause               21428157
;  :num-allocs              44922721
;  :num-checks              466
;  :propagations            5852095
;  :quant-instantiations    8165920
;  :restarts                5
;  :rlimit-count            172651419)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@448@04))
    (as None<option<array>>  option<array>))))
(pop) ; 17
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@448@04))
    (as None<option<array>>  option<array>))))
(pop) ; 16
(push) ; 16
; [else-branch: 243 | !(i1@448@04 < V@15@04 && 0 <= i1@448@04)]
(assert (not (and (< i1@448@04 V@15@04) (<= 0 i1@448@04))))
(pop) ; 16
(pop) ; 15
; Joined path conditions
(assert (implies
  (and (< i1@448@04 V@15@04) (<= 0 i1@448@04))
  (and
    (< i1@448@04 V@15@04)
    (<= 0 i1@448@04)
    (< i1@448@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@448@04)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@448@04))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@448@04))
        (as None<option<array>>  option<array>))))))
; Joined path conditions
(pop) ; 14
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@448@04 Int)) (!
  (implies
    (and (< i1@448@04 V@15@04) (<= 0 i1@448@04))
    (and
      (< i1@448@04 V@15@04)
      (<= 0 i1@448@04)
      (< i1@448@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@448@04)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@448@04))
      (not
        (=
          ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@448@04))
          (as None<option<array>>  option<array>)))))
  :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@448@04)))))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(assert (forall ((i1@448@04 Int)) (!
  (implies
    (and (< i1@448@04 V@15@04) (<= 0 i1@448@04))
    (=
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@448@04))))
      V@15@04))
  :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@448@04)))))
  :qid |prog.l<no position>|)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04)))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04)))))))))
  $Snap.unit))
; [eval] (forall i1: Int :: { aloc(opt_get1(G), i1) } (forall i2: Int :: { aloc(opt_get1(G), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(G), i1).option$array$ == aloc(opt_get1(G), i2).option$array$ ==> i1 == i2))
(declare-const i1@449@04 Int)
(push) ; 14
; [eval] (forall i2: Int :: { aloc(opt_get1(G), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(G), i1).option$array$ == aloc(opt_get1(G), i2).option$array$ ==> i1 == i2)
(declare-const i2@450@04 Int)
(push) ; 15
; [eval] 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(G), i1).option$array$ == aloc(opt_get1(G), i2).option$array$ ==> i1 == i2
; [eval] 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(G), i1).option$array$ == aloc(opt_get1(G), i2).option$array$
; [eval] 0 <= i1
(push) ; 16
; [then-branch: 244 | 0 <= i1@449@04 | live]
; [else-branch: 244 | !(0 <= i1@449@04) | live]
(push) ; 17
; [then-branch: 244 | 0 <= i1@449@04]
(assert (<= 0 i1@449@04))
; [eval] i1 < V
(push) ; 18
; [then-branch: 245 | i1@449@04 < V@15@04 | live]
; [else-branch: 245 | !(i1@449@04 < V@15@04) | live]
(push) ; 19
; [then-branch: 245 | i1@449@04 < V@15@04]
(assert (< i1@449@04 V@15@04))
; [eval] 0 <= i2
(push) ; 20
; [then-branch: 246 | 0 <= i2@450@04 | live]
; [else-branch: 246 | !(0 <= i2@450@04) | live]
(push) ; 21
; [then-branch: 246 | 0 <= i2@450@04]
(assert (<= 0 i2@450@04))
; [eval] i2 < V
(push) ; 22
; [then-branch: 247 | i2@450@04 < V@15@04 | live]
; [else-branch: 247 | !(i2@450@04 < V@15@04) | live]
(push) ; 23
; [then-branch: 247 | i2@450@04 < V@15@04]
(assert (< i2@450@04 V@15@04))
; [eval] aloc(opt_get1(G), i1).option$array$ == aloc(opt_get1(G), i2).option$array$
; [eval] aloc(opt_get1(G), i1)
; [eval] opt_get1(G)
(push) ; 24
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 24
; Joined path conditions
(push) ; 24
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 25
(assert (not (< i1@449@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))))
(check-sat)
; unsat
(pop) ; 25
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               6385232
;  :arith-add-rows          1484125
;  :arith-assert-diseq      26395
;  :arith-assert-lower      1123816
;  :arith-assert-upper      987872
;  :arith-bound-prop        36427
;  :arith-conflicts         999
;  :arith-eq-adapter        603847
;  :arith-fixed-eqs         1059625
;  :arith-offset-eqs        665246
;  :arith-pivots            226528
;  :conflicts               2878
;  :datatype-accessor-ax    360
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               203279
;  :del-clause              21426398
;  :final-checks            5
;  :max-generation          14
;  :max-memory              266.02
;  :memory                  252.89
;  :minimized-lits          328
;  :mk-bool-var             18574492
;  :mk-clause               21428157
;  :num-allocs              44923460
;  :num-checks              467
;  :propagations            5852095
;  :quant-instantiations    8165920
;  :restarts                5
;  :rlimit-count            172653068)
(assert (< i1@449@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(pop) ; 24
; Joined path conditions
(assert (< i1@449@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@449@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@449@04)))
(push) ; 24
(assert (not (ite
  (and
    (<
      (inv@445@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@449@04))
      V@15@04)
    (<=
      0
      (inv@445@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@449@04))))
  (< $Perm.No $k@444@04)
  false)))
(check-sat)
; unsat
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               6385386
;  :arith-add-rows          1484192
;  :arith-assert-diseq      26395
;  :arith-assert-lower      1123836
;  :arith-assert-upper      987889
;  :arith-bound-prop        36440
;  :arith-conflicts         1000
;  :arith-eq-adapter        603863
;  :arith-fixed-eqs         1059641
;  :arith-offset-eqs        665271
;  :arith-pivots            226545
;  :conflicts               2879
;  :datatype-accessor-ax    360
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               203279
;  :del-clause              21426398
;  :final-checks            5
;  :max-generation          14
;  :max-memory              266.02
;  :memory                  252.55
;  :minimized-lits          328
;  :mk-bool-var             18575102
;  :mk-clause               21428568
;  :num-allocs              44925960
;  :num-checks              468
;  :propagations            5852104
;  :quant-instantiations    8166146
;  :restarts                5
;  :rlimit-count            172663763)
; [eval] aloc(opt_get1(G), i2)
; [eval] opt_get1(G)
(push) ; 24
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 24
; Joined path conditions
(push) ; 24
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 25
(assert (not (< i2@450@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))))
(check-sat)
; unsat
(pop) ; 25
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               6385386
;  :arith-add-rows          1484192
;  :arith-assert-diseq      26395
;  :arith-assert-lower      1123836
;  :arith-assert-upper      987889
;  :arith-bound-prop        36440
;  :arith-conflicts         1000
;  :arith-eq-adapter        603863
;  :arith-fixed-eqs         1059641
;  :arith-offset-eqs        665271
;  :arith-pivots            226545
;  :conflicts               2879
;  :datatype-accessor-ax    360
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               203279
;  :del-clause              21426398
;  :final-checks            5
;  :max-generation          14
;  :max-memory              266.02
;  :memory                  252.55
;  :minimized-lits          328
;  :mk-bool-var             18575102
;  :mk-clause               21428568
;  :num-allocs              44925986
;  :num-checks              469
;  :propagations            5852104
;  :quant-instantiations    8166146
;  :restarts                5
;  :rlimit-count            172663793)
(assert (< i2@450@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(pop) ; 24
; Joined path conditions
(assert (< i2@450@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@450@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@450@04)))
(push) ; 24
(assert (not (ite
  (and
    (<
      (inv@445@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@450@04))
      V@15@04)
    (<=
      0
      (inv@445@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@450@04))))
  (< $Perm.No $k@444@04)
  false)))
(check-sat)
; unsat
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               6385498
;  :arith-add-rows          1484248
;  :arith-assert-diseq      26395
;  :arith-assert-lower      1123856
;  :arith-assert-upper      987906
;  :arith-bound-prop        36452
;  :arith-conflicts         1001
;  :arith-eq-adapter        603880
;  :arith-fixed-eqs         1059657
;  :arith-offset-eqs        665271
;  :arith-pivots            226562
;  :conflicts               2880
;  :datatype-accessor-ax    360
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               203279
;  :del-clause              21426398
;  :final-checks            5
;  :max-generation          14
;  :max-memory              266.02
;  :memory                  252.54
;  :minimized-lits          328
;  :mk-bool-var             18575494
;  :mk-clause               21428835
;  :num-allocs              44928177
;  :num-checks              470
;  :propagations            5852140
;  :quant-instantiations    8166343
;  :restarts                5
;  :rlimit-count            172673281)
(pop) ; 23
(push) ; 23
; [else-branch: 247 | !(i2@450@04 < V@15@04)]
(assert (not (< i2@450@04 V@15@04)))
(pop) ; 23
(pop) ; 22
; Joined path conditions
(assert (implies
  (< i2@450@04 V@15@04)
  (and
    (< i2@450@04 V@15@04)
    (< i1@449@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@449@04)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@449@04))
    (< i2@450@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@450@04)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@450@04)))))
; Joined path conditions
(pop) ; 21
(push) ; 21
; [else-branch: 246 | !(0 <= i2@450@04)]
(assert (not (<= 0 i2@450@04)))
(pop) ; 21
(pop) ; 20
; Joined path conditions
(assert (implies
  (<= 0 i2@450@04)
  (and
    (<= 0 i2@450@04)
    (implies
      (< i2@450@04 V@15@04)
      (and
        (< i2@450@04 V@15@04)
        (< i1@449@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@449@04)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@449@04))
        (< i2@450@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@450@04)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@450@04)))))))
; Joined path conditions
(pop) ; 19
(push) ; 19
; [else-branch: 245 | !(i1@449@04 < V@15@04)]
(assert (not (< i1@449@04 V@15@04)))
(pop) ; 19
(pop) ; 18
; Joined path conditions
(assert (implies
  (< i1@449@04 V@15@04)
  (and
    (< i1@449@04 V@15@04)
    (implies
      (<= 0 i2@450@04)
      (and
        (<= 0 i2@450@04)
        (implies
          (< i2@450@04 V@15@04)
          (and
            (< i2@450@04 V@15@04)
            (< i1@449@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@449@04)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@449@04))
            (< i2@450@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@450@04)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@450@04)))))))))
; Joined path conditions
(pop) ; 17
(push) ; 17
; [else-branch: 244 | !(0 <= i1@449@04)]
(assert (not (<= 0 i1@449@04)))
(pop) ; 17
(pop) ; 16
; Joined path conditions
(assert (implies
  (<= 0 i1@449@04)
  (and
    (<= 0 i1@449@04)
    (implies
      (< i1@449@04 V@15@04)
      (and
        (< i1@449@04 V@15@04)
        (implies
          (<= 0 i2@450@04)
          (and
            (<= 0 i2@450@04)
            (implies
              (< i2@450@04 V@15@04)
              (and
                (< i2@450@04 V@15@04)
                (< i1@449@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@449@04)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@449@04))
                (< i2@450@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@450@04)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@450@04)))))))))))
; Joined path conditions
(push) ; 16
; [then-branch: 248 | Lookup(option$array$,sm@446@04,aloc((_, _), opt_get1(_, G@11@04), i1@449@04)) == Lookup(option$array$,sm@446@04,aloc((_, _), opt_get1(_, G@11@04), i2@450@04)) && i2@450@04 < V@15@04 && 0 <= i2@450@04 && i1@449@04 < V@15@04 && 0 <= i1@449@04 | live]
; [else-branch: 248 | !(Lookup(option$array$,sm@446@04,aloc((_, _), opt_get1(_, G@11@04), i1@449@04)) == Lookup(option$array$,sm@446@04,aloc((_, _), opt_get1(_, G@11@04), i2@450@04)) && i2@450@04 < V@15@04 && 0 <= i2@450@04 && i1@449@04 < V@15@04 && 0 <= i1@449@04) | live]
(push) ; 17
; [then-branch: 248 | Lookup(option$array$,sm@446@04,aloc((_, _), opt_get1(_, G@11@04), i1@449@04)) == Lookup(option$array$,sm@446@04,aloc((_, _), opt_get1(_, G@11@04), i2@450@04)) && i2@450@04 < V@15@04 && 0 <= i2@450@04 && i1@449@04 < V@15@04 && 0 <= i1@449@04]
(assert (and
  (and
    (and
      (and
        (=
          ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@449@04))
          ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@450@04)))
        (< i2@450@04 V@15@04))
      (<= 0 i2@450@04))
    (< i1@449@04 V@15@04))
  (<= 0 i1@449@04)))
; [eval] i1 == i2
(pop) ; 17
(push) ; 17
; [else-branch: 248 | !(Lookup(option$array$,sm@446@04,aloc((_, _), opt_get1(_, G@11@04), i1@449@04)) == Lookup(option$array$,sm@446@04,aloc((_, _), opt_get1(_, G@11@04), i2@450@04)) && i2@450@04 < V@15@04 && 0 <= i2@450@04 && i1@449@04 < V@15@04 && 0 <= i1@449@04)]
(assert (not
  (and
    (and
      (and
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@449@04))
            ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@450@04)))
          (< i2@450@04 V@15@04))
        (<= 0 i2@450@04))
      (< i1@449@04 V@15@04))
    (<= 0 i1@449@04))))
(pop) ; 17
(pop) ; 16
; Joined path conditions
(assert (implies
  (and
    (and
      (and
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@449@04))
            ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@450@04)))
          (< i2@450@04 V@15@04))
        (<= 0 i2@450@04))
      (< i1@449@04 V@15@04))
    (<= 0 i1@449@04))
  (and
    (=
      ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@449@04))
      ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@450@04)))
    (< i2@450@04 V@15@04)
    (<= 0 i2@450@04)
    (< i1@449@04 V@15@04)
    (<= 0 i1@449@04))))
; Joined path conditions
(pop) ; 15
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i2@450@04 Int)) (!
  (and
    (implies
      (<= 0 i1@449@04)
      (and
        (<= 0 i1@449@04)
        (implies
          (< i1@449@04 V@15@04)
          (and
            (< i1@449@04 V@15@04)
            (implies
              (<= 0 i2@450@04)
              (and
                (<= 0 i2@450@04)
                (implies
                  (< i2@450@04 V@15@04)
                  (and
                    (< i2@450@04 V@15@04)
                    (< i1@449@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
                    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@449@04)) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@449@04))
                    (< i2@450@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
                    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@450@04)) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@450@04))))))))))
    (implies
      (and
        (and
          (and
            (and
              (=
                ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@449@04))
                ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@450@04)))
              (< i2@450@04 V@15@04))
            (<= 0 i2@450@04))
          (< i1@449@04 V@15@04))
        (<= 0 i1@449@04))
      (and
        (=
          ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@449@04))
          ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@450@04)))
        (< i2@450@04 V@15@04)
        (<= 0 i2@450@04)
        (< i1@449@04 V@15@04)
        (<= 0 i1@449@04))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@450@04))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 14
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@449@04 Int)) (!
  (forall ((i2@450@04 Int)) (!
    (and
      (implies
        (<= 0 i1@449@04)
        (and
          (<= 0 i1@449@04)
          (implies
            (< i1@449@04 V@15@04)
            (and
              (< i1@449@04 V@15@04)
              (implies
                (<= 0 i2@450@04)
                (and
                  (<= 0 i2@450@04)
                  (implies
                    (< i2@450@04 V@15@04)
                    (and
                      (< i2@450@04 V@15@04)
                      (< i1@449@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
                      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@449@04)) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@449@04))
                      (< i2@450@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
                      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@450@04)) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@450@04))))))))))
      (implies
        (and
          (and
            (and
              (and
                (=
                  ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@449@04))
                  ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@450@04)))
                (< i2@450@04 V@15@04))
              (<= 0 i2@450@04))
            (< i1@449@04 V@15@04))
          (<= 0 i1@449@04))
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@449@04))
            ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@450@04)))
          (< i2@450@04 V@15@04)
          (<= 0 i2@450@04)
          (< i1@449@04 V@15@04)
          (<= 0 i1@449@04))))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@450@04))
    :qid |prog.l<no position>-aux|))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@449@04))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(assert (forall ((i1@449@04 Int)) (!
  (forall ((i2@450@04 Int)) (!
    (implies
      (and
        (and
          (and
            (and
              (=
                ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@449@04))
                ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@450@04)))
              (< i2@450@04 V@15@04))
            (<= 0 i2@450@04))
          (< i1@449@04 V@15@04))
        (<= 0 i1@449@04))
      (= i1@449@04 i2@450@04))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@450@04))
    :qid |prog.l<no position>|))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@449@04))
  :qid |prog.l<no position>|)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04)))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04)))))))))))))
(declare-const i1@451@04 Int)
(declare-const j@452@04 Int)
(push) ; 14
; [eval] 0 <= i1 && i1 < V && (0 <= j && j < V)
; [eval] 0 <= i1
(push) ; 15
; [then-branch: 249 | 0 <= i1@451@04 | live]
; [else-branch: 249 | !(0 <= i1@451@04) | live]
(push) ; 16
; [then-branch: 249 | 0 <= i1@451@04]
(assert (<= 0 i1@451@04))
; [eval] i1 < V
(push) ; 17
; [then-branch: 250 | i1@451@04 < V@15@04 | live]
; [else-branch: 250 | !(i1@451@04 < V@15@04) | live]
(push) ; 18
; [then-branch: 250 | i1@451@04 < V@15@04]
(assert (< i1@451@04 V@15@04))
; [eval] 0 <= j
(push) ; 19
; [then-branch: 251 | 0 <= j@452@04 | live]
; [else-branch: 251 | !(0 <= j@452@04) | live]
(push) ; 20
; [then-branch: 251 | 0 <= j@452@04]
(assert (<= 0 j@452@04))
; [eval] j < V
(pop) ; 20
(push) ; 20
; [else-branch: 251 | !(0 <= j@452@04)]
(assert (not (<= 0 j@452@04)))
(pop) ; 20
(pop) ; 19
; Joined path conditions
; Joined path conditions
(pop) ; 18
(push) ; 18
; [else-branch: 250 | !(i1@451@04 < V@15@04)]
(assert (not (< i1@451@04 V@15@04)))
(pop) ; 18
(pop) ; 17
; Joined path conditions
; Joined path conditions
(pop) ; 16
(push) ; 16
; [else-branch: 249 | !(0 <= i1@451@04)]
(assert (not (<= 0 i1@451@04)))
(pop) ; 16
(pop) ; 15
; Joined path conditions
; Joined path conditions
(assert (and
  (and (and (< j@452@04 V@15@04) (<= 0 j@452@04)) (< i1@451@04 V@15@04))
  (<= 0 i1@451@04)))
; [eval] aloc(opt_get1(aloc(opt_get1(G), i1).option$array$), j)
; [eval] opt_get1(aloc(opt_get1(G), i1).option$array$)
; [eval] aloc(opt_get1(G), i1)
; [eval] opt_get1(G)
(push) ; 15
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 15
; Joined path conditions
(push) ; 15
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 16
(assert (not (< i1@451@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))))
(check-sat)
; unsat
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               6385503
;  :arith-add-rows          1484279
;  :arith-assert-diseq      26395
;  :arith-assert-lower      1123862
;  :arith-assert-upper      987906
;  :arith-bound-prop        36452
;  :arith-conflicts         1001
;  :arith-eq-adapter        603880
;  :arith-fixed-eqs         1059657
;  :arith-offset-eqs        665271
;  :arith-pivots            226599
;  :conflicts               2880
;  :datatype-accessor-ax    361
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               203279
;  :del-clause              21427100
;  :final-checks            5
;  :max-generation          14
;  :max-memory              266.02
;  :memory                  252.49
;  :minimized-lits          328
;  :mk-bool-var             18575516
;  :mk-clause               21428859
;  :num-allocs              44929345
;  :num-checks              471
;  :propagations            5852140
;  :quant-instantiations    8166343
;  :restarts                5
;  :rlimit-count            172676692)
(assert (< i1@451@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(pop) ; 15
; Joined path conditions
(assert (< i1@451@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@451@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@451@04)))
(push) ; 15
(assert (not (ite
  (and
    (<
      (inv@445@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@451@04))
      V@15@04)
    (<=
      0
      (inv@445@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@451@04))))
  (< $Perm.No $k@444@04)
  false)))
(check-sat)
; unsat
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               6385629
;  :arith-add-rows          1484333
;  :arith-assert-diseq      26395
;  :arith-assert-lower      1123882
;  :arith-assert-upper      987923
;  :arith-bound-prop        36464
;  :arith-conflicts         1002
;  :arith-eq-adapter        603896
;  :arith-fixed-eqs         1059673
;  :arith-offset-eqs        665271
;  :arith-pivots            226616
;  :conflicts               2881
;  :datatype-accessor-ax    361
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               203279
;  :del-clause              21427100
;  :final-checks            5
;  :max-generation          14
;  :max-memory              266.02
;  :memory                  252.42
;  :minimized-lits          328
;  :mk-bool-var             18576135
;  :mk-clause               21429270
;  :num-allocs              44931926
;  :num-checks              472
;  :propagations            5852146
;  :quant-instantiations    8166572
;  :restarts                5
;  :rlimit-count            172687628)
(push) ; 15
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 16
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@451@04))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               6385629
;  :arith-add-rows          1484333
;  :arith-assert-diseq      26395
;  :arith-assert-lower      1123882
;  :arith-assert-upper      987923
;  :arith-bound-prop        36464
;  :arith-conflicts         1002
;  :arith-eq-adapter        603896
;  :arith-fixed-eqs         1059673
;  :arith-offset-eqs        665271
;  :arith-pivots            226616
;  :conflicts               2882
;  :datatype-accessor-ax    361
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               203279
;  :del-clause              21427100
;  :final-checks            5
;  :max-generation          14
;  :max-memory              266.02
;  :memory                  252.42
;  :minimized-lits          328
;  :mk-bool-var             18576135
;  :mk-clause               21429270
;  :num-allocs              44932015
;  :num-checks              473
;  :propagations            5852146
;  :quant-instantiations    8166572
;  :restarts                5
;  :rlimit-count            172687723)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@451@04))
    (as None<option<array>>  option<array>))))
(pop) ; 15
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@451@04))
    (as None<option<array>>  option<array>))))
(push) ; 15
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 16
(assert (not (<
  j@452@04
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@451@04)))))))
(check-sat)
; unsat
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               6385633
;  :arith-add-rows          1484336
;  :arith-assert-diseq      26395
;  :arith-assert-lower      1123883
;  :arith-assert-upper      987924
;  :arith-bound-prop        36466
;  :arith-conflicts         1002
;  :arith-eq-adapter        603897
;  :arith-fixed-eqs         1059673
;  :arith-offset-eqs        665271
;  :arith-pivots            226618
;  :conflicts               2883
;  :datatype-accessor-ax    361
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               203279
;  :del-clause              21427106
;  :final-checks            5
;  :max-generation          14
;  :max-memory              266.02
;  :memory                  252.42
;  :minimized-lits          328
;  :mk-bool-var             18576146
;  :mk-clause               21429276
;  :num-allocs              44932200
;  :num-checks              474
;  :propagations            5852146
;  :quant-instantiations    8166579
;  :restarts                5
;  :rlimit-count            172688137)
(assert (<
  j@452@04
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@451@04))))))
(pop) ; 15
; Joined path conditions
(assert (<
  j@452@04
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@451@04))))))
(pop) ; 14
(declare-fun inv@453@04 ($Ref) Int)
(declare-fun inv@454@04 ($Ref) Int)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(assert (forall ((i1@451@04 Int) (j@452@04 Int)) (!
  (and
    (< i1@451@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@451@04)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@451@04))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@451@04))
        (as None<option<array>>  option<array>)))
    (<
      j@452@04
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@451@04))))))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@451@04))) j@452@04))
  :qid |int-aux|)))
; Check receiver injectivity
(push) ; 14
(assert (not (forall ((i11@451@04 Int) (j1@452@04 Int) (i12@451@04 Int) (j2@452@04 Int)) (!
  (implies
    (and
      (and
        (and (and (< j1@452@04 V@15@04) (<= 0 j1@452@04)) (< i11@451@04 V@15@04))
        (<= 0 i11@451@04))
      (and
        (and (and (< j2@452@04 V@15@04) (<= 0 j2@452@04)) (< i12@451@04 V@15@04))
        (<= 0 i12@451@04))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i11@451@04))) j1@452@04)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i12@451@04))) j2@452@04)))
    (and (= i11@451@04 i12@451@04) (= j1@452@04 j2@452@04)))
  
  :qid |int-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 14
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               6385790
;  :arith-add-rows          1484411
;  :arith-assert-diseq      26395
;  :arith-assert-lower      1123903
;  :arith-assert-upper      987928
;  :arith-bound-prop        36469
;  :arith-conflicts         1002
;  :arith-eq-adapter        603933
;  :arith-fixed-eqs         1059675
;  :arith-offset-eqs        665274
;  :arith-pivots            226646
;  :conflicts               2884
;  :datatype-accessor-ax    361
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               203279
;  :del-clause              21427966
;  :final-checks            5
;  :max-generation          14
;  :max-memory              266.02
;  :memory                  252.35
;  :minimized-lits          328
;  :mk-bool-var             18576977
;  :mk-clause               21429725
;  :num-allocs              44936560
;  :num-checks              475
;  :propagations            5852181
;  :quant-instantiations    8166978
;  :restarts                5
;  :rlimit-count            172706354
;  :time                    0.01)
; Definitional axioms for inverse functions
(assert (forall ((i1@451@04 Int) (j@452@04 Int)) (!
  (implies
    (and
      (and (and (< j@452@04 V@15@04) (<= 0 j@452@04)) (< i1@451@04 V@15@04))
      (<= 0 i1@451@04))
    (and
      (=
        (inv@453@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@451@04))) j@452@04))
        i1@451@04)
      (=
        (inv@454@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@451@04))) j@452@04))
        j@452@04)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@451@04))) j@452@04))
  )))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@454@04 r) V@15@04) (<= 0 (inv@454@04 r)))
        (< (inv@453@04 r) V@15@04))
      (<= 0 (inv@453@04 r)))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) (inv@453@04 r)))) (inv@454@04 r))
      r))
  :pattern ((inv@453@04 r))
  :pattern ((inv@454@04 r))
  :qid |int-fctOfInv|)))
; Permissions are non-negative
; Field permissions are at most one
; Permission implies non-null receiver
(assert (forall ((i1@451@04 Int) (j@452@04 Int)) (!
  (implies
    (and
      (and (and (< j@452@04 V@15@04) (<= 0 j@452@04)) (< i1@451@04 V@15@04))
      (<= 0 i1@451@04))
    (not
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@451@04))) j@452@04)
        $Ref.null)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@451@04))) j@452@04))
  :qid |int-permImpliesNonNull|)))
(declare-const sm@455@04 $FVF<Int>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@454@04 r) V@15@04) (<= 0 (inv@454@04 r)))
        (< (inv@453@04 r) V@15@04))
      (<= 0 (inv@453@04 r)))
    (=
      ($FVF.lookup_int (as sm@455@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@455@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))))))) r))
  :qid |qp.fvfValDef323|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))))))) r) r)
  :pattern (($FVF.lookup_int (as sm@455@04  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef324|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@454@04 r) V@15@04) (<= 0 (inv@454@04 r)))
        (< (inv@453@04 r) V@15@04))
      (<= 0 (inv@453@04 r)))
    ($FVF.loc_int ($FVF.lookup_int (as sm@455@04  $FVF<Int>) r) r))
  :pattern ((inv@453@04 r) (inv@454@04 r))
  )))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04)))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04)))))))))))
  $Snap.unit))
; [eval] P != (None(): option[array])
; [eval] (None(): option[array])
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04)))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04)))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))))))))
  $Snap.unit))
; [eval] alen(opt_get1(P)) == V
; [eval] alen(opt_get1(P))
; [eval] opt_get1(P)
(push) ; 14
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 14
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04)))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))))))))))))
(declare-const i1@456@04 Int)
(push) ; 14
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 15
; [then-branch: 252 | 0 <= i1@456@04 | live]
; [else-branch: 252 | !(0 <= i1@456@04) | live]
(push) ; 16
; [then-branch: 252 | 0 <= i1@456@04]
(assert (<= 0 i1@456@04))
; [eval] i1 < V
(pop) ; 16
(push) ; 16
; [else-branch: 252 | !(0 <= i1@456@04)]
(assert (not (<= 0 i1@456@04)))
(pop) ; 16
(pop) ; 15
; Joined path conditions
; Joined path conditions
(assert (and (< i1@456@04 V@15@04) (<= 0 i1@456@04)))
; [eval] aloc(opt_get1(P), i1)
; [eval] opt_get1(P)
(push) ; 15
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 15
; Joined path conditions
(push) ; 15
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 16
(assert (not (< i1@456@04 (alen<Int> (opt_get1 $Snap.unit P@14@04)))))
(check-sat)
; unsat
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               6385807
;  :arith-add-rows          1484412
;  :arith-assert-diseq      26395
;  :arith-assert-lower      1123905
;  :arith-assert-upper      987928
;  :arith-bound-prop        36469
;  :arith-conflicts         1002
;  :arith-eq-adapter        603933
;  :arith-fixed-eqs         1059675
;  :arith-offset-eqs        665274
;  :arith-pivots            226647
;  :conflicts               2884
;  :datatype-accessor-ax    364
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               203279
;  :del-clause              21427966
;  :final-checks            5
;  :max-generation          14
;  :max-memory              266.02
;  :memory                  252.35
;  :minimized-lits          328
;  :mk-bool-var             18576990
;  :mk-clause               21429725
;  :num-allocs              44937886
;  :num-checks              476
;  :propagations            5852181
;  :quant-instantiations    8166978
;  :restarts                5
;  :rlimit-count            172709953)
(assert (< i1@456@04 (alen<Int> (opt_get1 $Snap.unit P@14@04))))
(pop) ; 15
; Joined path conditions
(assert (< i1@456@04 (alen<Int> (opt_get1 $Snap.unit P@14@04))))
(pop) ; 14
(declare-fun inv@457@04 ($Ref) Int)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(assert (forall ((i1@456@04 Int)) (!
  (< i1@456@04 (alen<Int> (opt_get1 $Snap.unit P@14@04)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i1@456@04))
  :qid |int-aux|)))
; Check receiver injectivity
(push) ; 14
(assert (not (forall ((i11@456@04 Int) (i12@456@04 Int)) (!
  (implies
    (and
      (and (< i11@456@04 V@15@04) (<= 0 i11@456@04))
      (and (< i12@456@04 V@15@04) (<= 0 i12@456@04))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i11@456@04)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i12@456@04)))
    (= i11@456@04 i12@456@04))
  
  :qid |int-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               6385859
;  :arith-add-rows          1484418
;  :arith-assert-diseq      26396
;  :arith-assert-lower      1123909
;  :arith-assert-upper      987928
;  :arith-bound-prop        36469
;  :arith-conflicts         1002
;  :arith-eq-adapter        603934
;  :arith-fixed-eqs         1059675
;  :arith-offset-eqs        665274
;  :arith-pivots            226650
;  :conflicts               2885
;  :datatype-accessor-ax    364
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               203279
;  :del-clause              21427972
;  :final-checks            5
;  :max-generation          14
;  :max-memory              266.02
;  :memory                  252.33
;  :minimized-lits          328
;  :mk-bool-var             18577053
;  :mk-clause               21429731
;  :num-allocs              44938651
;  :num-checks              477
;  :propagations            5852181
;  :quant-instantiations    8167059
;  :restarts                5
;  :rlimit-count            172712186
;  :time                    0.00)
; Definitional axioms for inverse functions
(assert (forall ((i1@456@04 Int)) (!
  (implies
    (and (< i1@456@04 V@15@04) (<= 0 i1@456@04))
    (=
      (inv@457@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i1@456@04))
      i1@456@04))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i1@456@04))
  )))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@457@04 r) V@15@04) (<= 0 (inv@457@04 r)))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) (inv@457@04 r))
      r))
  :pattern ((inv@457@04 r))
  :qid |int-fctOfInv|)))
; Permissions are non-negative
; Field permissions are at most one
; Permission implies non-null receiver
(assert (forall ((i1@456@04 Int)) (!
  (implies
    (and (< i1@456@04 V@15@04) (<= 0 i1@456@04))
    (not
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i1@456@04)
        $Ref.null)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i1@456@04))
  :qid |int-permImpliesNonNull|)))
(declare-const sm@458@04 $FVF<Int>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@457@04 r) V@15@04) (<= 0 (inv@457@04 r)))
    (=
      ($FVF.lookup_int (as sm@458@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04)))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@458@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04)))))))))))))) r))
  :qid |qp.fvfValDef325|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@454@04 r) V@15@04) (<= 0 (inv@454@04 r)))
        (< (inv@453@04 r) V@15@04))
      (<= 0 (inv@453@04 r)))
    (=
      ($FVF.lookup_int (as sm@458@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@458@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))))))) r))
  :qid |qp.fvfValDef326|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04)))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@458@04  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef327|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@457@04 r) V@15@04) (<= 0 (inv@457@04 r)))
    ($FVF.loc_int ($FVF.lookup_int (as sm@458@04  $FVF<Int>) r) r))
  :pattern ((inv@457@04 r))
  )))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04)))))))))))))
  $Snap.unit))
; [eval] valid_graph_vertices(this, P, V)
(push) ; 14
; [eval] this != null
; [eval] p != (None(): option[array])
; [eval] (None(): option[array])
; [eval] alen(opt_get1(p)) == V
; [eval] alen(opt_get1(p))
; [eval] opt_get1(p)
(push) ; 15
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 15
; Joined path conditions
(declare-const i1@459@04 Int)
(push) ; 15
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 16
; [then-branch: 253 | 0 <= i1@459@04 | live]
; [else-branch: 253 | !(0 <= i1@459@04) | live]
(push) ; 17
; [then-branch: 253 | 0 <= i1@459@04]
(assert (<= 0 i1@459@04))
; [eval] i1 < V
(pop) ; 17
(push) ; 17
; [else-branch: 253 | !(0 <= i1@459@04)]
(assert (not (<= 0 i1@459@04)))
(pop) ; 17
(pop) ; 16
; Joined path conditions
; Joined path conditions
(assert (and (< i1@459@04 V@15@04) (<= 0 i1@459@04)))
(declare-const $k@460@04 $Perm)
(assert ($Perm.isReadVar $k@460@04 $Perm.Write))
; [eval] aloc(opt_get1(p), i1)
; [eval] opt_get1(p)
(push) ; 16
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 16
; Joined path conditions
(push) ; 16
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 17
(assert (not (< i1@459@04 (alen<Int> (opt_get1 $Snap.unit P@14@04)))))
(check-sat)
; unsat
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               6385860
;  :arith-add-rows          1484419
;  :arith-assert-diseq      26397
;  :arith-assert-lower      1123913
;  :arith-assert-upper      987929
;  :arith-bound-prop        36469
;  :arith-conflicts         1002
;  :arith-eq-adapter        603935
;  :arith-fixed-eqs         1059675
;  :arith-offset-eqs        665274
;  :arith-pivots            226650
;  :conflicts               2885
;  :datatype-accessor-ax    364
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               203279
;  :del-clause              21427972
;  :final-checks            5
;  :max-generation          14
;  :max-memory              266.02
;  :memory                  252.33
;  :minimized-lits          328
;  :mk-bool-var             18577067
;  :mk-clause               21429733
;  :num-allocs              44939888
;  :num-checks              478
;  :propagations            5852182
;  :quant-instantiations    8167059
;  :restarts                5
;  :rlimit-count            172715286)
(assert (< i1@459@04 (alen<Int> (opt_get1 $Snap.unit P@14@04))))
(pop) ; 16
; Joined path conditions
(assert (< i1@459@04 (alen<Int> (opt_get1 $Snap.unit P@14@04))))
(pop) ; 15
(declare-fun inv@461@04 ($Ref) Int)
; Nested auxiliary terms: globals
(assert ($Perm.isReadVar $k@460@04 $Perm.Write))
; Nested auxiliary terms: non-globals
(assert (forall ((i1@459@04 Int)) (!
  (< i1@459@04 (alen<Int> (opt_get1 $Snap.unit P@14@04)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i1@459@04))
  :qid |int-aux|)))
(push) ; 15
(assert (not (forall ((i1@459@04 Int)) (!
  (implies
    (and (< i1@459@04 V@15@04) (<= 0 i1@459@04))
    (or (= $k@460@04 $Perm.No) (< $Perm.No $k@460@04)))
  
  ))))
(check-sat)
; unsat
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               6385860
;  :arith-add-rows          1484420
;  :arith-assert-diseq      26398
;  :arith-assert-lower      1123915
;  :arith-assert-upper      987930
;  :arith-bound-prop        36469
;  :arith-conflicts         1002
;  :arith-eq-adapter        603936
;  :arith-fixed-eqs         1059675
;  :arith-offset-eqs        665274
;  :arith-pivots            226650
;  :conflicts               2886
;  :datatype-accessor-ax    364
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               203279
;  :del-clause              21427974
;  :final-checks            5
;  :max-generation          14
;  :max-memory              266.02
;  :memory                  252.33
;  :minimized-lits          328
;  :mk-bool-var             18577074
;  :mk-clause               21429735
;  :num-allocs              44940317
;  :num-checks              479
;  :propagations            5852183
;  :quant-instantiations    8167059
;  :restarts                5
;  :rlimit-count            172715832)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 15
(assert (not (forall ((i11@459@04 Int) (i12@459@04 Int)) (!
  (implies
    (and
      (and
        (and
          (and (< i11@459@04 V@15@04) (<= 0 i11@459@04))
          ($FVF.loc_int ($FVF.lookup_int (as sm@458@04  $FVF<Int>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit P@14@04) i11@459@04)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit P@14@04) i11@459@04)))
        (< $Perm.No $k@460@04))
      (and
        (and
          (and (< i12@459@04 V@15@04) (<= 0 i12@459@04))
          ($FVF.loc_int ($FVF.lookup_int (as sm@458@04  $FVF<Int>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit P@14@04) i12@459@04)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit P@14@04) i12@459@04)))
        (< $Perm.No $k@460@04))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i11@459@04)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i12@459@04)))
    (= i11@459@04 i12@459@04))
  
  :qid |int-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               6385915
;  :arith-add-rows          1484429
;  :arith-assert-diseq      26399
;  :arith-assert-lower      1123919
;  :arith-assert-upper      987930
;  :arith-bound-prop        36469
;  :arith-conflicts         1002
;  :arith-eq-adapter        603937
;  :arith-fixed-eqs         1059675
;  :arith-offset-eqs        665274
;  :arith-pivots            226652
;  :conflicts               2887
;  :datatype-accessor-ax    364
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               203279
;  :del-clause              21427985
;  :final-checks            5
;  :max-generation          14
;  :max-memory              266.02
;  :memory                  252.31
;  :minimized-lits          328
;  :mk-bool-var             18577150
;  :mk-clause               21429746
;  :num-allocs              44941017
;  :num-checks              480
;  :propagations            5852185
;  :quant-instantiations    8167147
;  :restarts                5
;  :rlimit-count            172718255
;  :time                    0.00)
; Definitional axioms for inverse functions
(assert (forall ((i1@459@04 Int)) (!
  (implies
    (and (and (< i1@459@04 V@15@04) (<= 0 i1@459@04)) (< $Perm.No $k@460@04))
    (=
      (inv@461@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i1@459@04))
      i1@459@04))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i1@459@04))
  :qid |int-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and (< (inv@461@04 r) V@15@04) (<= 0 (inv@461@04 r)))
      (< $Perm.No $k@460@04))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) (inv@461@04 r))
      r))
  :pattern ((inv@461@04 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@461@04 r) V@15@04) (<= 0 (inv@461@04 r)))
    ($FVF.loc_int ($FVF.lookup_int (as sm@458@04  $FVF<Int>) r) r))
  :pattern ((inv@461@04 r))
  )))
; Precomputing data for removing quantified permissions
(define-fun pTaken@462@04 ((r $Ref)) $Perm
  (ite
    (and (< (inv@461@04 r) V@15@04) (<= 0 (inv@461@04 r)))
    ($Perm.min
      (ite
        (and (< (inv@457@04 r) V@15@04) (<= 0 (inv@457@04 r)))
        $Perm.Write
        $Perm.No)
      $k@460@04)
    $Perm.No))
(define-fun pTaken@463@04 ((r $Ref)) $Perm
  (ite
    (and (< (inv@461@04 r) V@15@04) (<= 0 (inv@461@04 r)))
    ($Perm.min
      (ite
        (and
          (and
            (and (< (inv@454@04 r) V@15@04) (<= 0 (inv@454@04 r)))
            (< (inv@453@04 r) V@15@04))
          (<= 0 (inv@453@04 r)))
        $Perm.Write
        $Perm.No)
      (- $k@460@04 (pTaken@462@04 r)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Constrain original permissions $k@460@04
(assert (forall ((r $Ref)) (!
  (implies
    (not
      (=
        (ite
          (and (< (inv@457@04 r) V@15@04) (<= 0 (inv@457@04 r)))
          $Perm.Write
          $Perm.No)
        $Perm.No))
    (ite
      (and (< (inv@457@04 r) V@15@04) (<= 0 (inv@457@04 r)))
      (<
        (ite
          (and (< (inv@461@04 r) V@15@04) (<= 0 (inv@461@04 r)))
          $k@460@04
          $Perm.No)
        $Perm.Write)
      (<
        (ite
          (and (< (inv@461@04 r) V@15@04) (<= 0 (inv@461@04 r)))
          $k@460@04
          $Perm.No)
        $Perm.No)))
  :pattern ((inv@457@04 r))
  :pattern ((inv@461@04 r))
  :qid |qp.srp328|)))
; Intermediate check if already taken enough permissions
(set-option :timeout 500)
(push) ; 15
(assert (not (forall ((r $Ref)) (!
  (implies
    (and (< (inv@461@04 r) V@15@04) (<= 0 (inv@461@04 r)))
    (= (- $k@460@04 (pTaken@462@04 r)) $Perm.No))
  
  ))))
(check-sat)
; unsat
(pop) ; 15
; 0.03s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               6386887
;  :arith-add-rows          1485509
;  :arith-assert-diseq      26422
;  :arith-assert-lower      1124088
;  :arith-assert-upper      988054
;  :arith-bound-prop        36506
;  :arith-conflicts         1004
;  :arith-eq-adapter        604064
;  :arith-fixed-eqs         1059817
;  :arith-offset-eqs        665345
;  :arith-pivots            226735
;  :conflicts               2908
;  :datatype-accessor-ax    364
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               203588
;  :del-clause              21438767
;  :final-checks            5
;  :max-generation          14
;  :max-memory              266.02
;  :memory                  252.23
;  :minimized-lits          328
;  :mk-bool-var             18585116
;  :mk-clause               21440529
;  :num-allocs              44961911
;  :num-checks              482
;  :propagations            5853601
;  :quant-instantiations    8169115
;  :restarts                5
;  :rlimit-count            172817982
;  :time                    0.03)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@464@04 $FVF<Int>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (iff
    (Set_in r ($FVF.domain_int (as sm@464@04  $FVF<Int>)))
    (and
      (and (< (inv@461@04 r) V@15@04) (<= 0 (inv@461@04 r)))
      (< $Perm.No $k@460@04)))
  :pattern ((Set_in r ($FVF.domain_int (as sm@464@04  $FVF<Int>))))
  :qid |qp.fvfDomDef332|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@461@04 r) V@15@04) (<= 0 (inv@461@04 r)))
        (< $Perm.No $k@460@04))
      (and (< (inv@457@04 r) V@15@04) (<= 0 (inv@457@04 r))))
    (=
      ($FVF.lookup_int (as sm@464@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04)))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@464@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04)))))))))))))) r))
  :qid |qp.fvfValDef329|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@461@04 r) V@15@04) (<= 0 (inv@461@04 r)))
        (< $Perm.No $k@460@04))
      (and
        (and
          (and (< (inv@454@04 r) V@15@04) (<= 0 (inv@454@04 r)))
          (< (inv@453@04 r) V@15@04))
        (<= 0 (inv@453@04 r))))
    (=
      ($FVF.lookup_int (as sm@464@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@464@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))))))) r))
  :qid |qp.fvfValDef330|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04)))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@464@04  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef331|)))
(pop) ; 14
; Joined path conditions
(assert ($Perm.isReadVar $k@460@04 $Perm.Write))
(assert (forall ((i1@459@04 Int)) (!
  (implies
    (and (and (< i1@459@04 V@15@04) (<= 0 i1@459@04)) (< $Perm.No $k@460@04))
    (=
      (inv@461@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i1@459@04))
      i1@459@04))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i1@459@04))
  :qid |int-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and (< (inv@461@04 r) V@15@04) (<= 0 (inv@461@04 r)))
      (< $Perm.No $k@460@04))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) (inv@461@04 r))
      r))
  :pattern ((inv@461@04 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (iff
    (Set_in r ($FVF.domain_int (as sm@464@04  $FVF<Int>)))
    (and
      (and (< (inv@461@04 r) V@15@04) (<= 0 (inv@461@04 r)))
      (< $Perm.No $k@460@04)))
  :pattern ((Set_in r ($FVF.domain_int (as sm@464@04  $FVF<Int>))))
  :qid |qp.fvfDomDef332|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@461@04 r) V@15@04) (<= 0 (inv@461@04 r)))
        (< $Perm.No $k@460@04))
      (and (< (inv@457@04 r) V@15@04) (<= 0 (inv@457@04 r))))
    (=
      ($FVF.lookup_int (as sm@464@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04)))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@464@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04)))))))))))))) r))
  :qid |qp.fvfValDef329|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@461@04 r) V@15@04) (<= 0 (inv@461@04 r)))
        (< $Perm.No $k@460@04))
      (and
        (and
          (and (< (inv@454@04 r) V@15@04) (<= 0 (inv@454@04 r)))
          (< (inv@453@04 r) V@15@04))
        (<= 0 (inv@453@04 r))))
    (=
      ($FVF.lookup_int (as sm@464@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@464@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))))))) r))
  :qid |qp.fvfValDef330|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04)))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@464@04  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef331|)))
(assert (and
  (forall ((i1@459@04 Int)) (!
    (< i1@459@04 (alen<Int> (opt_get1 $Snap.unit P@14@04)))
    :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i1@459@04))
    :qid |int-aux|))
  (forall ((r $Ref)) (!
    (implies
      (and (< (inv@461@04 r) V@15@04) (<= 0 (inv@461@04 r)))
      ($FVF.loc_int ($FVF.lookup_int (as sm@458@04  $FVF<Int>) r) r))
    :pattern ((inv@461@04 r))
    ))
  (forall ((r $Ref)) (!
    (implies
      (not
        (=
          (ite
            (and (< (inv@457@04 r) V@15@04) (<= 0 (inv@457@04 r)))
            $Perm.Write
            $Perm.No)
          $Perm.No))
      (ite
        (and (< (inv@457@04 r) V@15@04) (<= 0 (inv@457@04 r)))
        (<
          (ite
            (and (< (inv@461@04 r) V@15@04) (<= 0 (inv@461@04 r)))
            $k@460@04
            $Perm.No)
          $Perm.Write)
        (<
          (ite
            (and (< (inv@461@04 r) V@15@04) (<= 0 (inv@461@04 r)))
            $k@460@04
            $Perm.No)
          $Perm.No)))
    :pattern ((inv@457@04 r))
    :pattern ((inv@461@04 r))
    :qid |qp.srp328|))))
(assert (valid_graph_vertices ($Snap.combine
  $Snap.unit
  ($Snap.combine
    $Snap.unit
    ($Snap.combine
      $Snap.unit
      ($SortWrappers.$FVF<Int>To$Snap (as sm@464@04  $FVF<Int>))))) this@9@04 P@14@04 V@15@04))
; Loop head block: Check well-definedness of edge conditions
(push) ; 14
; [eval] v1 != s
(pop) ; 14
(push) ; 14
; [eval] !(v1 != s)
; [eval] v1 != s
(pop) ; 14
(pop) ; 13
(push) ; 13
; Loop head block: Establish invariant
; [eval] exc == excBeforeLoop2
; [eval] 0 <= v1
; [eval] v1 < V
; [eval] G != (None(): option[array])
; [eval] (None(): option[array])
; [eval] alen(opt_get1(G)) == V
; [eval] alen(opt_get1(G))
; [eval] opt_get1(G)
(push) ; 14
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 14
; Joined path conditions
(declare-const i1@465@04 Int)
(push) ; 14
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 15
; [then-branch: 254 | 0 <= i1@465@04 | live]
; [else-branch: 254 | !(0 <= i1@465@04) | live]
(push) ; 16
; [then-branch: 254 | 0 <= i1@465@04]
(assert (<= 0 i1@465@04))
; [eval] i1 < V
(pop) ; 16
(push) ; 16
; [else-branch: 254 | !(0 <= i1@465@04)]
(assert (not (<= 0 i1@465@04)))
(pop) ; 16
(pop) ; 15
; Joined path conditions
; Joined path conditions
(assert (and (< i1@465@04 V@15@04) (<= 0 i1@465@04)))
(declare-const $k@466@04 $Perm)
(assert ($Perm.isReadVar $k@466@04 $Perm.Write))
; [eval] aloc(opt_get1(G), i1)
; [eval] opt_get1(G)
(push) ; 15
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 15
; Joined path conditions
(push) ; 15
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 16
(assert (not (< i1@465@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))))
(check-sat)
; unsat
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               6386910
;  :arith-add-rows          1485513
;  :arith-assert-diseq      26424
;  :arith-assert-lower      1124094
;  :arith-assert-upper      988056
;  :arith-bound-prop        36506
;  :arith-conflicts         1004
;  :arith-eq-adapter        604066
;  :arith-fixed-eqs         1059817
;  :arith-offset-eqs        665345
;  :arith-pivots            226740
;  :conflicts               2908
;  :datatype-accessor-ax    367
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               203588
;  :del-clause              21438920
;  :final-checks            5
;  :max-generation          14
;  :max-memory              266.02
;  :memory                  252.23
;  :minimized-lits          328
;  :mk-bool-var             18585309
;  :mk-clause               21440679
;  :num-allocs              44964220
;  :num-checks              483
;  :propagations            5853614
;  :quant-instantiations    8169148
;  :restarts                5
;  :rlimit-count            172824758)
(assert (< i1@465@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(pop) ; 15
; Joined path conditions
(assert (< i1@465@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(pop) ; 14
(declare-fun inv@467@04 ($Ref) Int)
; Nested auxiliary terms: globals
(assert ($Perm.isReadVar $k@466@04 $Perm.Write))
; Nested auxiliary terms: non-globals
(assert (forall ((i1@465@04 Int)) (!
  (< i1@465@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@465@04))
  :qid |option$array$-aux|)))
(push) ; 14
(assert (not (forall ((i1@465@04 Int)) (!
  (implies
    (and (< i1@465@04 V@15@04) (<= 0 i1@465@04))
    (or (= $k@466@04 $Perm.No) (< $Perm.No $k@466@04)))
  
  ))))
(check-sat)
; unsat
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               6386910
;  :arith-add-rows          1485514
;  :arith-assert-diseq      26425
;  :arith-assert-lower      1124096
;  :arith-assert-upper      988057
;  :arith-bound-prop        36506
;  :arith-conflicts         1004
;  :arith-eq-adapter        604067
;  :arith-fixed-eqs         1059817
;  :arith-offset-eqs        665345
;  :arith-pivots            226741
;  :conflicts               2909
;  :datatype-accessor-ax    367
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               203588
;  :del-clause              21438922
;  :final-checks            5
;  :max-generation          14
;  :max-memory              266.02
;  :memory                  252.23
;  :minimized-lits          328
;  :mk-bool-var             18585316
;  :mk-clause               21440681
;  :num-allocs              44964649
;  :num-checks              484
;  :propagations            5853615
;  :quant-instantiations    8169148
;  :restarts                5
;  :rlimit-count            172825308)
(declare-const sm@468@04 $FVF<option<array>>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (ite
          (and (< (inv@296@04 r) V@15@04) (<= 0 (inv@296@04 r)))
          $k@295@04
          $Perm.No)
        (pTaken@380@04 r)))
    (=
      ($FVF.lookup_option$array$ (as sm@468@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@468@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r))
  :qid |qp.fvfValDef333|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@357@04 r) V@15@04) (<= 0 (inv@357@04 r)))
      (< $Perm.No $k@356@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@468@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@468@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))) r))
  :qid |qp.fvfValDef334|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))) r) r))
  :pattern (($FVF.lookup_option$array$ (as sm@468@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef335|)))
; Check receiver injectivity
(push) ; 14
(assert (not (forall ((i11@465@04 Int) (i12@465@04 Int)) (!
  (implies
    (and
      (and
        (and
          (and (< i11@465@04 V@15@04) (<= 0 i11@465@04))
          ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@468@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i11@465@04)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i11@465@04)))
        (< $Perm.No $k@466@04))
      (and
        (and
          (and (< i12@465@04 V@15@04) (<= 0 i12@465@04))
          ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@468@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i12@465@04)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i12@465@04)))
        (< $Perm.No $k@466@04))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i11@465@04)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i12@465@04)))
    (= i11@465@04 i12@465@04))
  
  :qid |option$array$-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               6386959
;  :arith-add-rows          1485523
;  :arith-assert-diseq      26426
;  :arith-assert-lower      1124100
;  :arith-assert-upper      988057
;  :arith-bound-prop        36506
;  :arith-conflicts         1004
;  :arith-eq-adapter        604068
;  :arith-fixed-eqs         1059817
;  :arith-offset-eqs        665345
;  :arith-pivots            226743
;  :conflicts               2910
;  :datatype-accessor-ax    367
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               203588
;  :del-clause              21438945
;  :final-checks            5
;  :max-generation          14
;  :max-memory              266.02
;  :memory                  252.23
;  :minimized-lits          328
;  :mk-bool-var             18585411
;  :mk-clause               21440704
;  :num-allocs              44966142
;  :num-checks              485
;  :propagations            5853617
;  :quant-instantiations    8169234
;  :restarts                5
;  :rlimit-count            172829875
;  :time                    0.00)
; Definitional axioms for inverse functions
(assert (forall ((i1@465@04 Int)) (!
  (implies
    (and (and (< i1@465@04 V@15@04) (<= 0 i1@465@04)) (< $Perm.No $k@466@04))
    (=
      (inv@467@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@465@04))
      i1@465@04))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@465@04))
  :qid |option$array$-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and (< (inv@467@04 r) V@15@04) (<= 0 (inv@467@04 r)))
      (< $Perm.No $k@466@04))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) (inv@467@04 r))
      r))
  :pattern ((inv@467@04 r))
  :qid |option$array$-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@467@04 r) V@15@04) (<= 0 (inv@467@04 r)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@468@04  $FVF<option<array>>) r) r))
  :pattern ((inv@467@04 r))
  )))
; Precomputing data for removing quantified permissions
(define-fun pTaken@469@04 ((r $Ref)) $Perm
  (ite
    (and (< (inv@467@04 r) V@15@04) (<= 0 (inv@467@04 r)))
    ($Perm.min
      (-
        (ite
          (and (< (inv@296@04 r) V@15@04) (<= 0 (inv@296@04 r)))
          $k@295@04
          $Perm.No)
        (pTaken@380@04 r))
      $k@466@04)
    $Perm.No))
(define-fun pTaken@470@04 ((r $Ref)) $Perm
  (ite
    (and (< (inv@467@04 r) V@15@04) (<= 0 (inv@467@04 r)))
    ($Perm.min
      (ite
        (and (< (inv@357@04 r) V@15@04) (<= 0 (inv@357@04 r)))
        $k@356@04
        $Perm.No)
      (- $k@466@04 (pTaken@469@04 r)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Constrain original permissions $k@466@04
(assert (forall ((r $Ref)) (!
  (implies
    (not
      (=
        (-
          (ite
            (and (< (inv@296@04 r) V@15@04) (<= 0 (inv@296@04 r)))
            $k@295@04
            $Perm.No)
          (pTaken@380@04 r))
        $Perm.No))
    (<
      (ite
        (and (< (inv@467@04 r) V@15@04) (<= 0 (inv@467@04 r)))
        $k@466@04
        $Perm.No)
      (-
        (ite
          (and (< (inv@296@04 r) V@15@04) (<= 0 (inv@296@04 r)))
          $k@295@04
          $Perm.No)
        (pTaken@380@04 r))))
  :pattern ((inv@296@04 r))
  :pattern ((inv@467@04 r))
  :qid |qp.srp336|)))
; Intermediate check if already taken enough permissions
(set-option :timeout 500)
(push) ; 14
(assert (not (forall ((r $Ref)) (!
  (implies
    (and (< (inv@467@04 r) V@15@04) (<= 0 (inv@467@04 r)))
    (= (- $k@466@04 (pTaken@469@04 r)) $Perm.No))
  
  ))))
(check-sat)
; unsat
(pop) ; 14
; 0.03s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               6388174
;  :arith-add-rows          1486986
;  :arith-assert-diseq      26463
;  :arith-assert-lower      1124324
;  :arith-assert-upper      988202
;  :arith-bound-prop        36555
;  :arith-conflicts         1008
;  :arith-eq-adapter        604235
;  :arith-fixed-eqs         1059976
;  :arith-offset-eqs        665470
;  :arith-pivots            226863
;  :conflicts               2932
;  :datatype-accessor-ax    367
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               203903
;  :del-clause              21449719
;  :final-checks            5
;  :max-generation          14
;  :max-memory              266.02
;  :memory                  252.23
;  :minimized-lits          328
;  :mk-bool-var             18593606
;  :mk-clause               21451479
;  :num-allocs              44989311
;  :num-checks              487
;  :propagations            5855219
;  :quant-instantiations    8171262
;  :restarts                5
;  :rlimit-count            172934723
;  :time                    0.03)
; Final check if taken enough permissions
; Done removing quantified permissions
; Definitional axioms for snapshot map values
; [eval] (forall i1: Int :: { aloc(opt_get1(G), i1) } 0 <= i1 && i1 < V ==> aloc(opt_get1(G), i1).option$array$ != (None(): option[array]))
(declare-const i1@471@04 Int)
(push) ; 14
; [eval] 0 <= i1 && i1 < V ==> aloc(opt_get1(G), i1).option$array$ != (None(): option[array])
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 15
; [then-branch: 255 | 0 <= i1@471@04 | live]
; [else-branch: 255 | !(0 <= i1@471@04) | live]
(push) ; 16
; [then-branch: 255 | 0 <= i1@471@04]
(assert (<= 0 i1@471@04))
; [eval] i1 < V
(pop) ; 16
(push) ; 16
; [else-branch: 255 | !(0 <= i1@471@04)]
(assert (not (<= 0 i1@471@04)))
(pop) ; 16
(pop) ; 15
; Joined path conditions
; Joined path conditions
(push) ; 15
; [then-branch: 256 | i1@471@04 < V@15@04 && 0 <= i1@471@04 | live]
; [else-branch: 256 | !(i1@471@04 < V@15@04 && 0 <= i1@471@04) | live]
(push) ; 16
; [then-branch: 256 | i1@471@04 < V@15@04 && 0 <= i1@471@04]
(assert (and (< i1@471@04 V@15@04) (<= 0 i1@471@04)))
; [eval] aloc(opt_get1(G), i1).option$array$ != (None(): option[array])
; [eval] aloc(opt_get1(G), i1)
; [eval] opt_get1(G)
(push) ; 17
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 17
; Joined path conditions
(push) ; 17
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 18
(assert (not (< i1@471@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))))
(check-sat)
; unsat
(pop) ; 18
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               6388174
;  :arith-add-rows          1486987
;  :arith-assert-diseq      26463
;  :arith-assert-lower      1124326
;  :arith-assert-upper      988202
;  :arith-bound-prop        36555
;  :arith-conflicts         1008
;  :arith-eq-adapter        604235
;  :arith-fixed-eqs         1059976
;  :arith-offset-eqs        665470
;  :arith-pivots            226863
;  :conflicts               2932
;  :datatype-accessor-ax    367
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               203903
;  :del-clause              21449719
;  :final-checks            5
;  :max-generation          14
;  :max-memory              266.02
;  :memory                  252.23
;  :minimized-lits          328
;  :mk-bool-var             18593608
;  :mk-clause               21451479
;  :num-allocs              44989420
;  :num-checks              488
;  :propagations            5855219
;  :quant-instantiations    8171262
;  :restarts                5
;  :rlimit-count            172934914)
(assert (< i1@471@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(pop) ; 17
; Joined path conditions
(assert (< i1@471@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@468@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@471@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@471@04)))
(push) ; 17
(assert (not (<
  $Perm.No
  (+
    (-
      (ite
        (and
          (<
            (inv@296@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@471@04))
            V@15@04)
          (<=
            0
            (inv@296@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@471@04))))
        $k@295@04
        $Perm.No)
      (pTaken@380@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@471@04)))
    (ite
      (and
        (<
          (inv@357@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@471@04))
          V@15@04)
        (<=
          0
          (inv@357@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@471@04))))
      $k@356@04
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 17
; 0.03s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               6388939
;  :arith-add-rows          1488036
;  :arith-assert-diseq      26477
;  :arith-assert-lower      1124442
;  :arith-assert-upper      988285
;  :arith-bound-prop        36596
;  :arith-conflicts         1011
;  :arith-eq-adapter        604315
;  :arith-fixed-eqs         1060067
;  :arith-offset-eqs        665531
;  :arith-pivots            226924
;  :conflicts               2951
;  :datatype-accessor-ax    367
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               204135
;  :del-clause              21457079
;  :final-checks            5
;  :max-generation          14
;  :max-memory              266.02
;  :memory                  252.26
;  :minimized-lits          328
;  :mk-bool-var             18599385
;  :mk-clause               21459219
;  :num-allocs              45004540
;  :num-checks              489
;  :propagations            5856228
;  :quant-instantiations    8172623
;  :restarts                5
;  :rlimit-count            173003530
;  :time                    0.03)
; [eval] (None(): option[array])
(pop) ; 16
(push) ; 16
; [else-branch: 256 | !(i1@471@04 < V@15@04 && 0 <= i1@471@04)]
(assert (not (and (< i1@471@04 V@15@04) (<= 0 i1@471@04))))
(pop) ; 16
(pop) ; 15
; Joined path conditions
(assert (implies
  (and (< i1@471@04 V@15@04) (<= 0 i1@471@04))
  (and
    (< i1@471@04 V@15@04)
    (<= 0 i1@471@04)
    (< i1@471@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@468@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@471@04)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@471@04)))))
; Joined path conditions
(pop) ; 14
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@471@04 Int)) (!
  (implies
    (and (< i1@471@04 V@15@04) (<= 0 i1@471@04))
    (and
      (< i1@471@04 V@15@04)
      (<= 0 i1@471@04)
      (< i1@471@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@468@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@471@04)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@471@04))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@471@04))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(push) ; 14
(assert (not (forall ((i1@471@04 Int)) (!
  (implies
    (and (< i1@471@04 V@15@04) (<= 0 i1@471@04))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@468@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@471@04))
        (as None<option<array>>  option<array>))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@471@04))
  :qid |prog.l<no position>|))))
(check-sat)
; unsat
(pop) ; 14
; 0.03s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               6389588
;  :arith-add-rows          1488847
;  :arith-assert-diseq      26487
;  :arith-assert-lower      1124539
;  :arith-assert-upper      988356
;  :arith-bound-prop        36626
;  :arith-conflicts         1012
;  :arith-eq-adapter        604382
;  :arith-fixed-eqs         1060148
;  :arith-offset-eqs        665580
;  :arith-pivots            227003
;  :conflicts               2969
;  :datatype-accessor-ax    367
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               204366
;  :del-clause              21465159
;  :final-checks            5
;  :max-generation          14
;  :max-memory              266.02
;  :memory                  252.23
;  :minimized-lits          328
;  :mk-bool-var             18604816
;  :mk-clause               21466919
;  :num-allocs              45018259
;  :num-checks              490
;  :propagations            5857237
;  :quant-instantiations    8173972
;  :restarts                5
;  :rlimit-count            173072237
;  :time                    0.03)
(assert (forall ((i1@471@04 Int)) (!
  (implies
    (and (< i1@471@04 V@15@04) (<= 0 i1@471@04))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@468@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@471@04))
        (as None<option<array>>  option<array>))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@471@04))
  :qid |prog.l<no position>|)))
; [eval] (forall i1: Int :: { alen(opt_get1(aloc(opt_get1(G), i1).option$array$)) } 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(G), i1).option$array$)) == V)
(declare-const i1@472@04 Int)
(push) ; 14
; [eval] 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(G), i1).option$array$)) == V
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 15
; [then-branch: 257 | 0 <= i1@472@04 | live]
; [else-branch: 257 | !(0 <= i1@472@04) | live]
(push) ; 16
; [then-branch: 257 | 0 <= i1@472@04]
(assert (<= 0 i1@472@04))
; [eval] i1 < V
(pop) ; 16
(push) ; 16
; [else-branch: 257 | !(0 <= i1@472@04)]
(assert (not (<= 0 i1@472@04)))
(pop) ; 16
(pop) ; 15
; Joined path conditions
; Joined path conditions
(push) ; 15
; [then-branch: 258 | i1@472@04 < V@15@04 && 0 <= i1@472@04 | live]
; [else-branch: 258 | !(i1@472@04 < V@15@04 && 0 <= i1@472@04) | live]
(push) ; 16
; [then-branch: 258 | i1@472@04 < V@15@04 && 0 <= i1@472@04]
(assert (and (< i1@472@04 V@15@04) (<= 0 i1@472@04)))
; [eval] alen(opt_get1(aloc(opt_get1(G), i1).option$array$)) == V
; [eval] alen(opt_get1(aloc(opt_get1(G), i1).option$array$))
; [eval] opt_get1(aloc(opt_get1(G), i1).option$array$)
; [eval] aloc(opt_get1(G), i1)
; [eval] opt_get1(G)
(push) ; 17
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 17
; Joined path conditions
(push) ; 17
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 18
(assert (not (< i1@472@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))))
(check-sat)
; unsat
(pop) ; 18
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               6389588
;  :arith-add-rows          1488848
;  :arith-assert-diseq      26487
;  :arith-assert-lower      1124541
;  :arith-assert-upper      988356
;  :arith-bound-prop        36626
;  :arith-conflicts         1012
;  :arith-eq-adapter        604382
;  :arith-fixed-eqs         1060148
;  :arith-offset-eqs        665580
;  :arith-pivots            227003
;  :conflicts               2969
;  :datatype-accessor-ax    367
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               204366
;  :del-clause              21465159
;  :final-checks            5
;  :max-generation          14
;  :max-memory              266.02
;  :memory                  252.23
;  :minimized-lits          328
;  :mk-bool-var             18604819
;  :mk-clause               21466919
;  :num-allocs              45018552
;  :num-checks              491
;  :propagations            5857237
;  :quant-instantiations    8173972
;  :restarts                5
;  :rlimit-count            173072737)
(assert (< i1@472@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(pop) ; 17
; Joined path conditions
(assert (< i1@472@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@468@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@472@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@472@04)))
(push) ; 17
(assert (not (<
  $Perm.No
  (+
    (-
      (ite
        (and
          (<
            (inv@296@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@472@04))
            V@15@04)
          (<=
            0
            (inv@296@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@472@04))))
        $k@295@04
        $Perm.No)
      (pTaken@380@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@472@04)))
    (ite
      (and
        (<
          (inv@357@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@472@04))
          V@15@04)
        (<=
          0
          (inv@357@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@472@04))))
      $k@356@04
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 17
; 0.03s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               6390354
;  :arith-add-rows          1489858
;  :arith-assert-diseq      26501
;  :arith-assert-lower      1124658
;  :arith-assert-upper      988438
;  :arith-bound-prop        36667
;  :arith-conflicts         1015
;  :arith-eq-adapter        604462
;  :arith-fixed-eqs         1060239
;  :arith-offset-eqs        665641
;  :arith-pivots            227061
;  :conflicts               2988
;  :datatype-accessor-ax    367
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               204598
;  :del-clause              21472529
;  :final-checks            5
;  :max-generation          14
;  :max-memory              266.02
;  :memory                  252.27
;  :minimized-lits          328
;  :mk-bool-var             18610604
;  :mk-clause               21474669
;  :num-allocs              45033683
;  :num-checks              492
;  :propagations            5858248
;  :quant-instantiations    8175341
;  :restarts                5
;  :rlimit-count            173141045
;  :time                    0.03)
(push) ; 17
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 18
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@468@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@472@04))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 18
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               6390354
;  :arith-add-rows          1489858
;  :arith-assert-diseq      26501
;  :arith-assert-lower      1124658
;  :arith-assert-upper      988438
;  :arith-bound-prop        36667
;  :arith-conflicts         1015
;  :arith-eq-adapter        604462
;  :arith-fixed-eqs         1060239
;  :arith-offset-eqs        665641
;  :arith-pivots            227061
;  :conflicts               2989
;  :datatype-accessor-ax    367
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               204598
;  :del-clause              21472529
;  :final-checks            5
;  :max-generation          14
;  :max-memory              266.02
;  :memory                  252.27
;  :minimized-lits          328
;  :mk-bool-var             18610604
;  :mk-clause               21474669
;  :num-allocs              45033773
;  :num-checks              493
;  :propagations            5858248
;  :quant-instantiations    8175341
;  :restarts                5
;  :rlimit-count            173141140)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@468@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@472@04))
    (as None<option<array>>  option<array>))))
(pop) ; 17
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@468@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@472@04))
    (as None<option<array>>  option<array>))))
(pop) ; 16
(push) ; 16
; [else-branch: 258 | !(i1@472@04 < V@15@04 && 0 <= i1@472@04)]
(assert (not (and (< i1@472@04 V@15@04) (<= 0 i1@472@04))))
(pop) ; 16
(pop) ; 15
; Joined path conditions
(assert (implies
  (and (< i1@472@04 V@15@04) (<= 0 i1@472@04))
  (and
    (< i1@472@04 V@15@04)
    (<= 0 i1@472@04)
    (< i1@472@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@468@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@472@04)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@472@04))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@468@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@472@04))
        (as None<option<array>>  option<array>))))))
; Joined path conditions
(pop) ; 14
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@472@04 Int)) (!
  (implies
    (and (< i1@472@04 V@15@04) (<= 0 i1@472@04))
    (and
      (< i1@472@04 V@15@04)
      (<= 0 i1@472@04)
      (< i1@472@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@468@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@472@04)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@472@04))
      (not
        (=
          ($FVF.lookup_option$array$ (as sm@468@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@472@04))
          (as None<option<array>>  option<array>)))))
  :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@468@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@472@04)))))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(push) ; 14
(assert (not (forall ((i1@472@04 Int)) (!
  (implies
    (and (< i1@472@04 V@15@04) (<= 0 i1@472@04))
    (=
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@468@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@472@04))))
      V@15@04))
  :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@468@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@472@04)))))
  :qid |prog.l<no position>|))))
(check-sat)
; unsat
(pop) ; 14
; 0.03s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               6391199
;  :arith-add-rows          1490658
;  :arith-assert-diseq      26513
;  :arith-assert-lower      1124761
;  :arith-assert-upper      988509
;  :arith-bound-prop        36697
;  :arith-conflicts         1016
;  :arith-eq-adapter        604530
;  :arith-fixed-eqs         1060320
;  :arith-offset-eqs        665694
;  :arith-pivots            227141
;  :conflicts               3007
;  :datatype-accessor-ax    367
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               204830
;  :del-clause              21480647
;  :final-checks            5
;  :max-generation          14
;  :max-memory              266.02
;  :memory                  252.23
;  :minimized-lits          328
;  :mk-bool-var             18616112
;  :mk-clause               21482407
;  :num-allocs              45047877
;  :num-checks              494
;  :propagations            5859356
;  :quant-instantiations    8176741
;  :restarts                5
;  :rlimit-count            173211356
;  :time                    0.03)
(assert (forall ((i1@472@04 Int)) (!
  (implies
    (and (< i1@472@04 V@15@04) (<= 0 i1@472@04))
    (=
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@468@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@472@04))))
      V@15@04))
  :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@468@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@472@04)))))
  :qid |prog.l<no position>|)))
; [eval] (forall i1: Int :: { aloc(opt_get1(G), i1) } (forall i2: Int :: { aloc(opt_get1(G), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(G), i1).option$array$ == aloc(opt_get1(G), i2).option$array$ ==> i1 == i2))
(declare-const i1@473@04 Int)
(push) ; 14
; [eval] (forall i2: Int :: { aloc(opt_get1(G), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(G), i1).option$array$ == aloc(opt_get1(G), i2).option$array$ ==> i1 == i2)
(declare-const i2@474@04 Int)
(push) ; 15
; [eval] 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(G), i1).option$array$ == aloc(opt_get1(G), i2).option$array$ ==> i1 == i2
; [eval] 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(G), i1).option$array$ == aloc(opt_get1(G), i2).option$array$
; [eval] 0 <= i1
(push) ; 16
; [then-branch: 259 | 0 <= i1@473@04 | live]
; [else-branch: 259 | !(0 <= i1@473@04) | live]
(push) ; 17
; [then-branch: 259 | 0 <= i1@473@04]
(assert (<= 0 i1@473@04))
; [eval] i1 < V
(push) ; 18
; [then-branch: 260 | i1@473@04 < V@15@04 | live]
; [else-branch: 260 | !(i1@473@04 < V@15@04) | live]
(push) ; 19
; [then-branch: 260 | i1@473@04 < V@15@04]
(assert (< i1@473@04 V@15@04))
; [eval] 0 <= i2
(push) ; 20
; [then-branch: 261 | 0 <= i2@474@04 | live]
; [else-branch: 261 | !(0 <= i2@474@04) | live]
(push) ; 21
; [then-branch: 261 | 0 <= i2@474@04]
(assert (<= 0 i2@474@04))
; [eval] i2 < V
(push) ; 22
; [then-branch: 262 | i2@474@04 < V@15@04 | live]
; [else-branch: 262 | !(i2@474@04 < V@15@04) | live]
(push) ; 23
; [then-branch: 262 | i2@474@04 < V@15@04]
(assert (< i2@474@04 V@15@04))
; [eval] aloc(opt_get1(G), i1).option$array$ == aloc(opt_get1(G), i2).option$array$
; [eval] aloc(opt_get1(G), i1)
; [eval] opt_get1(G)
(push) ; 24
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 24
; Joined path conditions
(push) ; 24
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 25
(assert (not (< i1@473@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))))
(check-sat)
; unsat
(pop) ; 25
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               6391199
;  :arith-add-rows          1490660
;  :arith-assert-diseq      26513
;  :arith-assert-lower      1124765
;  :arith-assert-upper      988509
;  :arith-bound-prop        36697
;  :arith-conflicts         1016
;  :arith-eq-adapter        604530
;  :arith-fixed-eqs         1060320
;  :arith-offset-eqs        665694
;  :arith-pivots            227141
;  :conflicts               3007
;  :datatype-accessor-ax    367
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               204830
;  :del-clause              21480647
;  :final-checks            5
;  :max-generation          14
;  :max-memory              266.02
;  :memory                  252.23
;  :minimized-lits          328
;  :mk-bool-var             18616117
;  :mk-clause               21482407
;  :num-allocs              45048354
;  :num-checks              495
;  :propagations            5859356
;  :quant-instantiations    8176741
;  :restarts                5
;  :rlimit-count            173212001)
(assert (< i1@473@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(pop) ; 24
; Joined path conditions
(assert (< i1@473@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@468@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@473@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@473@04)))
(push) ; 24
(assert (not (<
  $Perm.No
  (+
    (-
      (ite
        (and
          (<
            (inv@296@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@473@04))
            V@15@04)
          (<=
            0
            (inv@296@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@473@04))))
        $k@295@04
        $Perm.No)
      (pTaken@380@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@473@04)))
    (ite
      (and
        (<
          (inv@357@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@473@04))
          V@15@04)
        (<=
          0
          (inv@357@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@473@04))))
      $k@356@04
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 24
; 0.02s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               6391964
;  :arith-add-rows          1491650
;  :arith-assert-diseq      26527
;  :arith-assert-lower      1124882
;  :arith-assert-upper      988591
;  :arith-bound-prop        36737
;  :arith-conflicts         1019
;  :arith-eq-adapter        604610
;  :arith-fixed-eqs         1060411
;  :arith-offset-eqs        665755
;  :arith-pivots            227198
;  :conflicts               3026
;  :datatype-accessor-ax    367
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               205062
;  :del-clause              21488017
;  :final-checks            5
;  :max-generation          14
;  :max-memory              266.02
;  :memory                  252.32
;  :minimized-lits          328
;  :mk-bool-var             18621901
;  :mk-clause               21490157
;  :num-allocs              45063512
;  :num-checks              496
;  :propagations            5860367
;  :quant-instantiations    8178110
;  :restarts                5
;  :rlimit-count            173280230
;  :time                    0.02)
; [eval] aloc(opt_get1(G), i2)
; [eval] opt_get1(G)
(push) ; 24
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 24
; Joined path conditions
(push) ; 24
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 25
(assert (not (< i2@474@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))))
(check-sat)
; unsat
(pop) ; 25
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               6391964
;  :arith-add-rows          1491650
;  :arith-assert-diseq      26527
;  :arith-assert-lower      1124882
;  :arith-assert-upper      988591
;  :arith-bound-prop        36737
;  :arith-conflicts         1019
;  :arith-eq-adapter        604610
;  :arith-fixed-eqs         1060411
;  :arith-offset-eqs        665755
;  :arith-pivots            227198
;  :conflicts               3026
;  :datatype-accessor-ax    367
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               205062
;  :del-clause              21488017
;  :final-checks            5
;  :max-generation          14
;  :max-memory              266.02
;  :memory                  252.32
;  :minimized-lits          328
;  :mk-bool-var             18621901
;  :mk-clause               21490157
;  :num-allocs              45063538
;  :num-checks              497
;  :propagations            5860367
;  :quant-instantiations    8178110
;  :restarts                5
;  :rlimit-count            173280260)
(assert (< i2@474@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(pop) ; 24
; Joined path conditions
(assert (< i2@474@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@468@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@474@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@474@04)))
(push) ; 24
(assert (not (<
  $Perm.No
  (+
    (-
      (ite
        (and
          (<
            (inv@296@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@474@04))
            V@15@04)
          (<=
            0
            (inv@296@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@474@04))))
        $k@295@04
        $Perm.No)
      (pTaken@380@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@474@04)))
    (ite
      (and
        (<
          (inv@357@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@474@04))
          V@15@04)
        (<=
          0
          (inv@357@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@474@04))))
      $k@356@04
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 24
; 0.04s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               6393069
;  :arith-add-rows          1493167
;  :arith-assert-diseq      26561
;  :arith-assert-lower      1125104
;  :arith-assert-upper      988714
;  :arith-bound-prop        36816
;  :arith-conflicts         1027
;  :arith-eq-adapter        604736
;  :arith-fixed-eqs         1060526
;  :arith-offset-eqs        665859
;  :arith-pivots            227304
;  :conflicts               3053
;  :datatype-accessor-ax    367
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               205352
;  :del-clause              21496735
;  :final-checks            5
;  :max-generation          14
;  :max-memory              266.02
;  :memory                  252.38
;  :minimized-lits          329
;  :mk-bool-var             18628997
;  :mk-clause               21499175
;  :num-allocs              45082978
;  :num-checks              498
;  :propagations            5861803
;  :quant-instantiations    8179653
;  :restarts                5
;  :rlimit-count            173365258
;  :time                    0.04)
(pop) ; 23
(push) ; 23
; [else-branch: 262 | !(i2@474@04 < V@15@04)]
(assert (not (< i2@474@04 V@15@04)))
(pop) ; 23
(pop) ; 22
; Joined path conditions
(assert (implies
  (< i2@474@04 V@15@04)
  (and
    (< i2@474@04 V@15@04)
    (< i1@473@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@468@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@473@04)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@473@04))
    (< i2@474@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@468@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@474@04)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@474@04)))))
; Joined path conditions
(pop) ; 21
(push) ; 21
; [else-branch: 261 | !(0 <= i2@474@04)]
(assert (not (<= 0 i2@474@04)))
(pop) ; 21
(pop) ; 20
; Joined path conditions
(assert (implies
  (<= 0 i2@474@04)
  (and
    (<= 0 i2@474@04)
    (implies
      (< i2@474@04 V@15@04)
      (and
        (< i2@474@04 V@15@04)
        (< i1@473@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@468@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@473@04)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@473@04))
        (< i2@474@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@468@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@474@04)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@474@04)))))))
; Joined path conditions
(pop) ; 19
(push) ; 19
; [else-branch: 260 | !(i1@473@04 < V@15@04)]
(assert (not (< i1@473@04 V@15@04)))
(pop) ; 19
(pop) ; 18
; Joined path conditions
(assert (implies
  (< i1@473@04 V@15@04)
  (and
    (< i1@473@04 V@15@04)
    (implies
      (<= 0 i2@474@04)
      (and
        (<= 0 i2@474@04)
        (implies
          (< i2@474@04 V@15@04)
          (and
            (< i2@474@04 V@15@04)
            (< i1@473@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@468@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@473@04)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@473@04))
            (< i2@474@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@468@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@474@04)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@474@04)))))))))
; Joined path conditions
(pop) ; 17
(push) ; 17
; [else-branch: 259 | !(0 <= i1@473@04)]
(assert (not (<= 0 i1@473@04)))
(pop) ; 17
(pop) ; 16
; Joined path conditions
(assert (implies
  (<= 0 i1@473@04)
  (and
    (<= 0 i1@473@04)
    (implies
      (< i1@473@04 V@15@04)
      (and
        (< i1@473@04 V@15@04)
        (implies
          (<= 0 i2@474@04)
          (and
            (<= 0 i2@474@04)
            (implies
              (< i2@474@04 V@15@04)
              (and
                (< i2@474@04 V@15@04)
                (< i1@473@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@468@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@473@04)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@473@04))
                (< i2@474@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@468@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@474@04)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@474@04)))))))))))
; Joined path conditions
(push) ; 16
; [then-branch: 263 | Lookup(option$array$,sm@468@04,aloc((_, _), opt_get1(_, G@11@04), i1@473@04)) == Lookup(option$array$,sm@468@04,aloc((_, _), opt_get1(_, G@11@04), i2@474@04)) && i2@474@04 < V@15@04 && 0 <= i2@474@04 && i1@473@04 < V@15@04 && 0 <= i1@473@04 | live]
; [else-branch: 263 | !(Lookup(option$array$,sm@468@04,aloc((_, _), opt_get1(_, G@11@04), i1@473@04)) == Lookup(option$array$,sm@468@04,aloc((_, _), opt_get1(_, G@11@04), i2@474@04)) && i2@474@04 < V@15@04 && 0 <= i2@474@04 && i1@473@04 < V@15@04 && 0 <= i1@473@04) | live]
(push) ; 17
; [then-branch: 263 | Lookup(option$array$,sm@468@04,aloc((_, _), opt_get1(_, G@11@04), i1@473@04)) == Lookup(option$array$,sm@468@04,aloc((_, _), opt_get1(_, G@11@04), i2@474@04)) && i2@474@04 < V@15@04 && 0 <= i2@474@04 && i1@473@04 < V@15@04 && 0 <= i1@473@04]
(assert (and
  (and
    (and
      (and
        (=
          ($FVF.lookup_option$array$ (as sm@468@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@473@04))
          ($FVF.lookup_option$array$ (as sm@468@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@474@04)))
        (< i2@474@04 V@15@04))
      (<= 0 i2@474@04))
    (< i1@473@04 V@15@04))
  (<= 0 i1@473@04)))
; [eval] i1 == i2
(pop) ; 17
(push) ; 17
; [else-branch: 263 | !(Lookup(option$array$,sm@468@04,aloc((_, _), opt_get1(_, G@11@04), i1@473@04)) == Lookup(option$array$,sm@468@04,aloc((_, _), opt_get1(_, G@11@04), i2@474@04)) && i2@474@04 < V@15@04 && 0 <= i2@474@04 && i1@473@04 < V@15@04 && 0 <= i1@473@04)]
(assert (not
  (and
    (and
      (and
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@468@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@473@04))
            ($FVF.lookup_option$array$ (as sm@468@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@474@04)))
          (< i2@474@04 V@15@04))
        (<= 0 i2@474@04))
      (< i1@473@04 V@15@04))
    (<= 0 i1@473@04))))
(pop) ; 17
(pop) ; 16
; Joined path conditions
(assert (implies
  (and
    (and
      (and
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@468@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@473@04))
            ($FVF.lookup_option$array$ (as sm@468@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@474@04)))
          (< i2@474@04 V@15@04))
        (<= 0 i2@474@04))
      (< i1@473@04 V@15@04))
    (<= 0 i1@473@04))
  (and
    (=
      ($FVF.lookup_option$array$ (as sm@468@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@473@04))
      ($FVF.lookup_option$array$ (as sm@468@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@474@04)))
    (< i2@474@04 V@15@04)
    (<= 0 i2@474@04)
    (< i1@473@04 V@15@04)
    (<= 0 i1@473@04))))
; Joined path conditions
(pop) ; 15
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i2@474@04 Int)) (!
  (and
    (implies
      (<= 0 i1@473@04)
      (and
        (<= 0 i1@473@04)
        (implies
          (< i1@473@04 V@15@04)
          (and
            (< i1@473@04 V@15@04)
            (implies
              (<= 0 i2@474@04)
              (and
                (<= 0 i2@474@04)
                (implies
                  (< i2@474@04 V@15@04)
                  (and
                    (< i2@474@04 V@15@04)
                    (< i1@473@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
                    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@468@04  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@473@04)) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@473@04))
                    (< i2@474@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
                    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@468@04  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@474@04)) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@474@04))))))))))
    (implies
      (and
        (and
          (and
            (and
              (=
                ($FVF.lookup_option$array$ (as sm@468@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@473@04))
                ($FVF.lookup_option$array$ (as sm@468@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@474@04)))
              (< i2@474@04 V@15@04))
            (<= 0 i2@474@04))
          (< i1@473@04 V@15@04))
        (<= 0 i1@473@04))
      (and
        (=
          ($FVF.lookup_option$array$ (as sm@468@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@473@04))
          ($FVF.lookup_option$array$ (as sm@468@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@474@04)))
        (< i2@474@04 V@15@04)
        (<= 0 i2@474@04)
        (< i1@473@04 V@15@04)
        (<= 0 i1@473@04))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@474@04))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 14
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@473@04 Int)) (!
  (forall ((i2@474@04 Int)) (!
    (and
      (implies
        (<= 0 i1@473@04)
        (and
          (<= 0 i1@473@04)
          (implies
            (< i1@473@04 V@15@04)
            (and
              (< i1@473@04 V@15@04)
              (implies
                (<= 0 i2@474@04)
                (and
                  (<= 0 i2@474@04)
                  (implies
                    (< i2@474@04 V@15@04)
                    (and
                      (< i2@474@04 V@15@04)
                      (< i1@473@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
                      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@468@04  $FVF<option<array>>) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@473@04)) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@473@04))
                      (< i2@474@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
                      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@468@04  $FVF<option<array>>) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@474@04)) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@474@04))))))))))
      (implies
        (and
          (and
            (and
              (and
                (=
                  ($FVF.lookup_option$array$ (as sm@468@04  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@473@04))
                  ($FVF.lookup_option$array$ (as sm@468@04  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@474@04)))
                (< i2@474@04 V@15@04))
              (<= 0 i2@474@04))
            (< i1@473@04 V@15@04))
          (<= 0 i1@473@04))
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@468@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@473@04))
            ($FVF.lookup_option$array$ (as sm@468@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@474@04)))
          (< i2@474@04 V@15@04)
          (<= 0 i2@474@04)
          (< i1@473@04 V@15@04)
          (<= 0 i1@473@04))))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@474@04))
    :qid |prog.l<no position>-aux|))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@473@04))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(push) ; 14
(assert (not (forall ((i1@473@04 Int)) (!
  (forall ((i2@474@04 Int)) (!
    (implies
      (and
        (and
          (and
            (and
              (=
                ($FVF.lookup_option$array$ (as sm@468@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@473@04))
                ($FVF.lookup_option$array$ (as sm@468@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@474@04)))
              (< i2@474@04 V@15@04))
            (<= 0 i2@474@04))
          (< i1@473@04 V@15@04))
        (<= 0 i1@473@04))
      (= i1@473@04 i2@474@04))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@474@04))
    :qid |prog.l<no position>|))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@473@04))
  :qid |prog.l<no position>|))))
(check-sat)
; unsat
(pop) ; 14
; 0.05s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               6393983
;  :arith-add-rows          1494257
;  :arith-assert-diseq      26573
;  :arith-assert-lower      1125235
;  :arith-assert-upper      988811
;  :arith-bound-prop        36882
;  :arith-conflicts         1029
;  :arith-eq-adapter        604832
;  :arith-fixed-eqs         1060632
;  :arith-offset-eqs        665939
;  :arith-pivots            227464
;  :conflicts               3071
;  :datatype-accessor-ax    367
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               205586
;  :del-clause              21505686
;  :final-checks            5
;  :max-generation          14
;  :max-memory              266.02
;  :memory                  252.31
;  :minimized-lits          329
;  :mk-bool-var             18635384
;  :mk-clause               21507446
;  :num-allocs              45100630
;  :num-checks              499
;  :propagations            5862997
;  :quant-instantiations    8181305
;  :restarts                5
;  :rlimit-count            173453729
;  :time                    0.05)
(assert (forall ((i1@473@04 Int)) (!
  (forall ((i2@474@04 Int)) (!
    (implies
      (and
        (and
          (and
            (and
              (=
                ($FVF.lookup_option$array$ (as sm@468@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@473@04))
                ($FVF.lookup_option$array$ (as sm@468@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@474@04)))
              (< i2@474@04 V@15@04))
            (<= 0 i2@474@04))
          (< i1@473@04 V@15@04))
        (<= 0 i1@473@04))
      (= i1@473@04 i2@474@04))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@474@04))
    :qid |prog.l<no position>|))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@473@04))
  :qid |prog.l<no position>|)))
(declare-const i1@475@04 Int)
(declare-const j@476@04 Int)
(push) ; 14
; [eval] 0 <= i1 && i1 < V && (0 <= j && j < V)
; [eval] 0 <= i1
(push) ; 15
; [then-branch: 264 | 0 <= i1@475@04 | live]
; [else-branch: 264 | !(0 <= i1@475@04) | live]
(push) ; 16
; [then-branch: 264 | 0 <= i1@475@04]
(assert (<= 0 i1@475@04))
; [eval] i1 < V
(push) ; 17
; [then-branch: 265 | i1@475@04 < V@15@04 | live]
; [else-branch: 265 | !(i1@475@04 < V@15@04) | live]
(push) ; 18
; [then-branch: 265 | i1@475@04 < V@15@04]
(assert (< i1@475@04 V@15@04))
; [eval] 0 <= j
(push) ; 19
; [then-branch: 266 | 0 <= j@476@04 | live]
; [else-branch: 266 | !(0 <= j@476@04) | live]
(push) ; 20
; [then-branch: 266 | 0 <= j@476@04]
(assert (<= 0 j@476@04))
; [eval] j < V
(pop) ; 20
(push) ; 20
; [else-branch: 266 | !(0 <= j@476@04)]
(assert (not (<= 0 j@476@04)))
(pop) ; 20
(pop) ; 19
; Joined path conditions
; Joined path conditions
(pop) ; 18
(push) ; 18
; [else-branch: 265 | !(i1@475@04 < V@15@04)]
(assert (not (< i1@475@04 V@15@04)))
(pop) ; 18
(pop) ; 17
; Joined path conditions
; Joined path conditions
(pop) ; 16
(push) ; 16
; [else-branch: 264 | !(0 <= i1@475@04)]
(assert (not (<= 0 i1@475@04)))
(pop) ; 16
(pop) ; 15
; Joined path conditions
; Joined path conditions
(assert (and
  (and (and (< j@476@04 V@15@04) (<= 0 j@476@04)) (< i1@475@04 V@15@04))
  (<= 0 i1@475@04)))
; [eval] aloc(opt_get1(aloc(opt_get1(G), i1).option$array$), j)
; [eval] opt_get1(aloc(opt_get1(G), i1).option$array$)
; [eval] aloc(opt_get1(G), i1)
; [eval] opt_get1(G)
(push) ; 15
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 15
; Joined path conditions
(push) ; 15
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 16
(assert (not (< i1@475@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))))
(check-sat)
; unsat
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               6393983
;  :arith-add-rows          1494260
;  :arith-assert-diseq      26573
;  :arith-assert-lower      1125241
;  :arith-assert-upper      988811
;  :arith-bound-prop        36882
;  :arith-conflicts         1029
;  :arith-eq-adapter        604832
;  :arith-fixed-eqs         1060632
;  :arith-offset-eqs        665939
;  :arith-pivots            227467
;  :conflicts               3071
;  :datatype-accessor-ax    367
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               205586
;  :del-clause              21505686
;  :final-checks            5
;  :max-generation          14
;  :max-memory              266.02
;  :memory                  252.31
;  :minimized-lits          329
;  :mk-bool-var             18635391
;  :mk-clause               21507446
;  :num-allocs              45101229
;  :num-checks              500
;  :propagations            5862997
;  :quant-instantiations    8181305
;  :restarts                5
;  :rlimit-count            173454743)
(assert (< i1@475@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(pop) ; 15
; Joined path conditions
(assert (< i1@475@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@468@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@475@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@475@04)))
(push) ; 15
(assert (not (<
  $Perm.No
  (+
    (-
      (ite
        (and
          (<
            (inv@296@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@475@04))
            V@15@04)
          (<=
            0
            (inv@296@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@475@04))))
        $k@295@04
        $Perm.No)
      (pTaken@380@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@475@04)))
    (ite
      (and
        (<
          (inv@357@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@475@04))
          V@15@04)
        (<=
          0
          (inv@357@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@475@04))))
      $k@356@04
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 15
; 0.05s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               6394751
;  :arith-add-rows          1495282
;  :arith-assert-diseq      26587
;  :arith-assert-lower      1125358
;  :arith-assert-upper      988893
;  :arith-bound-prop        36923
;  :arith-conflicts         1032
;  :arith-eq-adapter        604912
;  :arith-fixed-eqs         1060723
;  :arith-offset-eqs        666000
;  :arith-pivots            227525
;  :conflicts               3090
;  :datatype-accessor-ax    367
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               205818
;  :del-clause              21513104
;  :final-checks            5
;  :max-generation          14
;  :max-memory              266.02
;  :memory                  252.35
;  :minimized-lits          329
;  :mk-bool-var             18641247
;  :mk-clause               21515244
;  :num-allocs              45116632
;  :num-checks              501
;  :propagations            5864026
;  :quant-instantiations    8182695
;  :restarts                5
;  :rlimit-count            173525128
;  :time                    0.05)
(push) ; 15
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 16
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@468@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@475@04))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               6394751
;  :arith-add-rows          1495282
;  :arith-assert-diseq      26587
;  :arith-assert-lower      1125358
;  :arith-assert-upper      988893
;  :arith-bound-prop        36923
;  :arith-conflicts         1032
;  :arith-eq-adapter        604912
;  :arith-fixed-eqs         1060723
;  :arith-offset-eqs        666000
;  :arith-pivots            227525
;  :conflicts               3091
;  :datatype-accessor-ax    367
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               205818
;  :del-clause              21513104
;  :final-checks            5
;  :max-generation          14
;  :max-memory              266.02
;  :memory                  252.35
;  :minimized-lits          329
;  :mk-bool-var             18641247
;  :mk-clause               21515244
;  :num-allocs              45116721
;  :num-checks              502
;  :propagations            5864026
;  :quant-instantiations    8182695
;  :restarts                5
;  :rlimit-count            173525223)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@468@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@475@04))
    (as None<option<array>>  option<array>))))
(pop) ; 15
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@468@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@475@04))
    (as None<option<array>>  option<array>))))
(push) ; 15
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 16
(assert (not (<
  j@476@04
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@468@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@475@04)))))))
(check-sat)
; unsat
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               6394757
;  :arith-add-rows          1495286
;  :arith-assert-diseq      26587
;  :arith-assert-lower      1125361
;  :arith-assert-upper      988894
;  :arith-bound-prop        36923
;  :arith-conflicts         1033
;  :arith-eq-adapter        604913
;  :arith-fixed-eqs         1060724
;  :arith-offset-eqs        666000
;  :arith-pivots            227527
;  :conflicts               3092
;  :datatype-accessor-ax    367
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               205818
;  :del-clause              21513108
;  :final-checks            5
;  :max-generation          14
;  :max-memory              266.02
;  :memory                  252.35
;  :minimized-lits          329
;  :mk-bool-var             18641258
;  :mk-clause               21515248
;  :num-allocs              45116910
;  :num-checks              503
;  :propagations            5864028
;  :quant-instantiations    8182702
;  :restarts                5
;  :rlimit-count            173525685
;  :time                    0.00)
(assert (<
  j@476@04
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@468@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@475@04))))))
(pop) ; 15
; Joined path conditions
(assert (<
  j@476@04
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@468@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@475@04))))))
(pop) ; 14
(declare-fun inv@477@04 ($Ref) Int)
(declare-fun inv@478@04 ($Ref) Int)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(assert (forall ((i1@475@04 Int) (j@476@04 Int)) (!
  (and
    (< i1@475@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@468@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@475@04)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@475@04))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@468@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@475@04))
        (as None<option<array>>  option<array>)))
    (<
      j@476@04
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@468@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@475@04))))))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@468@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@475@04))) j@476@04))
  :qid |int-aux|)))
(declare-const sm@479@04 $FVF<Int>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@369@04 r) V@15@04) (<= 0 (inv@369@04 r)))
    (=
      ($FVF.lookup_int (as sm@479@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04)))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@479@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04)))))))))))))) r))
  :qid |qp.fvfValDef337|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@366@04 r) V@15@04) (<= 0 (inv@366@04 r)))
        (< (inv@365@04 r) V@15@04))
      (<= 0 (inv@365@04 r)))
    (=
      ($FVF.lookup_int (as sm@479@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@479@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))))))) r))
  :qid |qp.fvfValDef338|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04)))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@479@04  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef339|)))
; Check receiver injectivity
(push) ; 14
(assert (not (forall ((i11@475@04 Int) (j1@476@04 Int) (i12@475@04 Int) (j2@476@04 Int)) (!
  (implies
    (and
      (and
        (and
          (and
            (and (< j1@476@04 V@15@04) (<= 0 j1@476@04))
            (< i11@475@04 V@15@04))
          (<= 0 i11@475@04))
        ($FVF.loc_int ($FVF.lookup_int (as sm@479@04  $FVF<Int>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@468@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i11@475@04))) j1@476@04)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@468@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i11@475@04))) j1@476@04)))
      (and
        (and
          (and
            (and (< j2@476@04 V@15@04) (<= 0 j2@476@04))
            (< i12@475@04 V@15@04))
          (<= 0 i12@475@04))
        ($FVF.loc_int ($FVF.lookup_int (as sm@479@04  $FVF<Int>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@468@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i12@475@04))) j2@476@04)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@468@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i12@475@04))) j2@476@04)))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@468@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i11@475@04))) j1@476@04)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@468@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i12@475@04))) j2@476@04)))
    (and (= i11@475@04 i12@475@04) (= j1@476@04 j2@476@04)))
  
  :qid |int-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 14
; 0.06s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               6394930
;  :arith-add-rows          1495393
;  :arith-assert-diseq      26587
;  :arith-assert-lower      1125387
;  :arith-assert-upper      988900
;  :arith-bound-prop        36930
;  :arith-conflicts         1033
;  :arith-eq-adapter        604960
;  :arith-fixed-eqs         1060730
;  :arith-offset-eqs        666007
;  :arith-pivots            227567
;  :conflicts               3093
;  :datatype-accessor-ax    367
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               205818
;  :del-clause              21514308
;  :final-checks            5
;  :max-generation          14
;  :max-memory              266.02
;  :memory                  252.27
;  :minimized-lits          329
;  :mk-bool-var             18642562
;  :mk-clause               21516068
;  :num-allocs              45122793
;  :num-checks              504
;  :propagations            5864069
;  :quant-instantiations    8183184
;  :restarts                5
;  :rlimit-count            173550601
;  :time                    0.06)
; Definitional axioms for inverse functions
(assert (forall ((i1@475@04 Int) (j@476@04 Int)) (!
  (implies
    (and
      (and (and (< j@476@04 V@15@04) (<= 0 j@476@04)) (< i1@475@04 V@15@04))
      (<= 0 i1@475@04))
    (and
      (=
        (inv@477@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@468@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@475@04))) j@476@04))
        i1@475@04)
      (=
        (inv@478@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@468@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@475@04))) j@476@04))
        j@476@04)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@468@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@475@04))) j@476@04))
  :qid |int-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@478@04 r) V@15@04) (<= 0 (inv@478@04 r)))
        (< (inv@477@04 r) V@15@04))
      (<= 0 (inv@477@04 r)))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@468@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) (inv@477@04 r)))) (inv@478@04 r))
      r))
  :pattern ((inv@477@04 r))
  :pattern ((inv@478@04 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@478@04 r) V@15@04) (<= 0 (inv@478@04 r)))
        (< (inv@477@04 r) V@15@04))
      (<= 0 (inv@477@04 r)))
    ($FVF.loc_int ($FVF.lookup_int (as sm@479@04  $FVF<Int>) r) r))
  :pattern ((inv@477@04 r) (inv@478@04 r))
  )))
; Precomputing data for removing quantified permissions
(define-fun pTaken@480@04 ((r $Ref)) $Perm
  (ite
    (and
      (and
        (and (< (inv@478@04 r) V@15@04) (<= 0 (inv@478@04 r)))
        (< (inv@477@04 r) V@15@04))
      (<= 0 (inv@477@04 r)))
    ($Perm.min
      (ite
        (and (< (inv@369@04 r) V@15@04) (<= 0 (inv@369@04 r)))
        $Perm.Write
        $Perm.No)
      $Perm.Write)
    $Perm.No))
(define-fun pTaken@481@04 ((r $Ref)) $Perm
  (ite
    (and
      (and
        (and (< (inv@478@04 r) V@15@04) (<= 0 (inv@478@04 r)))
        (< (inv@477@04 r) V@15@04))
      (<= 0 (inv@477@04 r)))
    ($Perm.min
      (ite
        (and
          (and
            (and (< (inv@366@04 r) V@15@04) (<= 0 (inv@366@04 r)))
            (< (inv@365@04 r) V@15@04))
          (<= 0 (inv@365@04 r)))
        $Perm.Write
        $Perm.No)
      (- $Perm.Write (pTaken@480@04 r)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 500)
(push) ; 14
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and (< (inv@369@04 r) V@15@04) (<= 0 (inv@369@04 r)))
        $Perm.Write
        $Perm.No)
      (pTaken@480@04 r))
    $Perm.No)
  
  ))))
(check-sat)
; unknown
(pop) ; 14
; 0.50s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               6397659
;  :arith-add-rows          1497133
;  :arith-assert-diseq      26606
;  :arith-assert-lower      1125869
;  :arith-assert-upper      989256
;  :arith-bound-prop        37081
;  :arith-conflicts         1033
;  :arith-eq-adapter        605324
;  :arith-fixed-eqs         1061085
;  :arith-offset-eqs        666309
;  :arith-pivots            227983
;  :conflicts               3095
;  :datatype-accessor-ax    367
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               206085
;  :del-clause              21529980
;  :final-checks            5
;  :max-generation          14
;  :max-memory              266.02
;  :memory                  252.45
;  :minimized-lits          330
;  :mk-bool-var             18657432
;  :mk-clause               21531740
;  :num-allocs              45165793
;  :num-checks              506
;  :propagations            5866322
;  :quant-instantiations    8187839
;  :restarts                5
;  :rlimit-count            173760648
;  :time                    0.50)
; Intermediate check if already taken enough permissions
(push) ; 14
(assert (not (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@478@04 r) V@15@04) (<= 0 (inv@478@04 r)))
        (< (inv@477@04 r) V@15@04))
      (<= 0 (inv@477@04 r)))
    (= (- $Perm.Write (pTaken@480@04 r)) $Perm.No))
  
  ))))
(check-sat)
; unknown
(pop) ; 14
; 0.64s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               6400635
;  :arith-add-rows          1499092
;  :arith-assert-diseq      26644
;  :arith-assert-lower      1126406
;  :arith-assert-upper      989616
;  :arith-bound-prop        37261
;  :arith-conflicts         1038
;  :arith-eq-adapter        605709
;  :arith-fixed-eqs         1061430
;  :arith-offset-eqs        666552
;  :arith-pivots            228384
;  :conflicts               3103
;  :datatype-accessor-ax    367
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               206456
;  :del-clause              21546781
;  :final-checks            5
;  :max-generation          14
;  :max-memory              266.02
;  :memory                  247.44
;  :minimized-lits          330
;  :mk-bool-var             18672389
;  :mk-clause               21548541
;  :num-allocs              45208255
;  :num-checks              507
;  :propagations            5869340
;  :quant-instantiations    8192500
;  :restarts                5
;  :rlimit-count            173991935
;  :time                    0.64)
; Chunk depleted?
(push) ; 14
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and
          (and
            (and (< (inv@366@04 r) V@15@04) (<= 0 (inv@366@04 r)))
            (< (inv@365@04 r) V@15@04))
          (<= 0 (inv@365@04 r)))
        $Perm.Write
        $Perm.No)
      (pTaken@481@04 r))
    $Perm.No)
  
  ))))
(check-sat)
; unknown
(pop) ; 14
; 0.52s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               6407196
;  :arith-add-rows          1506886
;  :arith-assert-diseq      26791
;  :arith-assert-lower      1127573
;  :arith-assert-upper      990319
;  :arith-bound-prop        37389
;  :arith-conflicts         1043
;  :arith-eq-adapter        606384
;  :arith-fixed-eqs         1062217
;  :arith-offset-eqs        666913
;  :arith-pivots            228752
;  :conflicts               3114
;  :datatype-accessor-ax    367
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               209121
;  :del-clause              21628762
;  :final-checks            5
;  :max-generation          14
;  :max-memory              266.02
;  :memory                  247.45
;  :minimized-lits          330
;  :mk-bool-var             18729380
;  :mk-clause               21630522
;  :num-allocs              45335390
;  :num-checks              508
;  :propagations            5880151
;  :quant-instantiations    8205691
;  :restarts                5
;  :rlimit-count            174458847
;  :time                    0.50)
; Intermediate check if already taken enough permissions
(push) ; 14
(assert (not (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@478@04 r) V@15@04) (<= 0 (inv@478@04 r)))
        (< (inv@477@04 r) V@15@04))
      (<= 0 (inv@477@04 r)))
    (= (- (- $Perm.Write (pTaken@480@04 r)) (pTaken@481@04 r)) $Perm.No))
  
  ))))
(check-sat)
; unsat
(pop) ; 14
; 0.06s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               6408371
;  :arith-add-rows          1507989
;  :arith-assert-diseq      26819
;  :arith-assert-lower      1127750
;  :arith-assert-upper      990459
;  :arith-bound-prop        37439
;  :arith-conflicts         1051
;  :arith-eq-adapter        606513
;  :arith-fixed-eqs         1062340
;  :arith-offset-eqs        667010
;  :arith-pivots            228881
;  :conflicts               3125
;  :datatype-accessor-ax    367
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               209365
;  :del-clause              21636985
;  :final-checks            5
;  :max-generation          14
;  :max-memory              266.02
;  :memory                  247.59
;  :minimized-lits          330
;  :mk-bool-var             18735605
;  :mk-clause               21638745
;  :num-allocs              45355550
;  :num-checks              509
;  :propagations            5881408
;  :quant-instantiations    8207228
;  :restarts                5
;  :rlimit-count            174560552
;  :time                    0.06)
; Final check if taken enough permissions
; Done removing quantified permissions
; Definitional axioms for snapshot map values
; [eval] P != (None(): option[array])
; [eval] (None(): option[array])
; [eval] alen(opt_get1(P)) == V
; [eval] alen(opt_get1(P))
; [eval] opt_get1(P)
(push) ; 14
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 14
; Joined path conditions
(declare-const i1@482@04 Int)
(push) ; 14
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 15
; [then-branch: 267 | 0 <= i1@482@04 | live]
; [else-branch: 267 | !(0 <= i1@482@04) | live]
(push) ; 16
; [then-branch: 267 | 0 <= i1@482@04]
(assert (<= 0 i1@482@04))
; [eval] i1 < V
(pop) ; 16
(push) ; 16
; [else-branch: 267 | !(0 <= i1@482@04)]
(assert (not (<= 0 i1@482@04)))
(pop) ; 16
(pop) ; 15
; Joined path conditions
; Joined path conditions
(assert (and (< i1@482@04 V@15@04) (<= 0 i1@482@04)))
; [eval] aloc(opt_get1(P), i1)
; [eval] opt_get1(P)
(push) ; 15
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 15
; Joined path conditions
(push) ; 15
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 16
(assert (not (< i1@482@04 (alen<Int> (opt_get1 $Snap.unit P@14@04)))))
(check-sat)
; unsat
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               6408371
;  :arith-add-rows          1507990
;  :arith-assert-diseq      26819
;  :arith-assert-lower      1127752
;  :arith-assert-upper      990459
;  :arith-bound-prop        37439
;  :arith-conflicts         1051
;  :arith-eq-adapter        606513
;  :arith-fixed-eqs         1062340
;  :arith-offset-eqs        667010
;  :arith-pivots            228882
;  :conflicts               3125
;  :datatype-accessor-ax    367
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               209365
;  :del-clause              21636985
;  :final-checks            5
;  :max-generation          14
;  :max-memory              266.02
;  :memory                  247.59
;  :minimized-lits          330
;  :mk-bool-var             18735607
;  :mk-clause               21638745
;  :num-allocs              45355659
;  :num-checks              510
;  :propagations            5881408
;  :quant-instantiations    8207228
;  :restarts                5
;  :rlimit-count            174560743)
(assert (< i1@482@04 (alen<Int> (opt_get1 $Snap.unit P@14@04))))
(pop) ; 15
; Joined path conditions
(assert (< i1@482@04 (alen<Int> (opt_get1 $Snap.unit P@14@04))))
(pop) ; 14
(declare-fun inv@483@04 ($Ref) Int)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(assert (forall ((i1@482@04 Int)) (!
  (< i1@482@04 (alen<Int> (opt_get1 $Snap.unit P@14@04)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i1@482@04))
  :qid |int-aux|)))
(declare-const sm@484@04 $FVF<Int>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (ite
          (and
            (and
              (and (< (inv@366@04 r) V@15@04) (<= 0 (inv@366@04 r)))
              (< (inv@365@04 r) V@15@04))
            (<= 0 (inv@365@04 r)))
          $Perm.Write
          $Perm.No)
        (pTaken@481@04 r)))
    (=
      ($FVF.lookup_int (as sm@484@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@484@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))))))) r))
  :qid |qp.fvfValDef340|)))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (ite
          (and (< (inv@369@04 r) V@15@04) (<= 0 (inv@369@04 r)))
          $Perm.Write
          $Perm.No)
        (pTaken@480@04 r)))
    (=
      ($FVF.lookup_int (as sm@484@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04)))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@484@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04)))))))))))))) r))
  :qid |qp.fvfValDef341|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04)))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@484@04  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef342|)))
; Check receiver injectivity
(push) ; 14
(assert (not (forall ((i11@482@04 Int) (i12@482@04 Int)) (!
  (implies
    (and
      (and
        (and (< i11@482@04 V@15@04) (<= 0 i11@482@04))
        ($FVF.loc_int ($FVF.lookup_int (as sm@484@04  $FVF<Int>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit P@14@04) i11@482@04)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit P@14@04) i11@482@04)))
      (and
        (and (< i12@482@04 V@15@04) (<= 0 i12@482@04))
        ($FVF.loc_int ($FVF.lookup_int (as sm@484@04  $FVF<Int>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit P@14@04) i12@482@04)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit P@14@04) i12@482@04)))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i11@482@04)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i12@482@04)))
    (= i11@482@04 i12@482@04))
  
  :qid |int-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               6408425
;  :arith-add-rows          1507999
;  :arith-assert-diseq      26820
;  :arith-assert-lower      1127756
;  :arith-assert-upper      990459
;  :arith-bound-prop        37439
;  :arith-conflicts         1051
;  :arith-eq-adapter        606514
;  :arith-fixed-eqs         1062340
;  :arith-offset-eqs        667010
;  :arith-pivots            228883
;  :conflicts               3126
;  :datatype-accessor-ax    367
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               209365
;  :del-clause              21637021
;  :final-checks            5
;  :max-generation          14
;  :max-memory              266.02
;  :memory                  247.50
;  :minimized-lits          330
;  :mk-bool-var             18735709
;  :mk-clause               21638781
;  :num-allocs              45357169
;  :num-checks              511
;  :propagations            5881410
;  :quant-instantiations    8207312
;  :restarts                5
;  :rlimit-count            174566099
;  :time                    0.00)
; Definitional axioms for inverse functions
(assert (forall ((i1@482@04 Int)) (!
  (implies
    (and (< i1@482@04 V@15@04) (<= 0 i1@482@04))
    (=
      (inv@483@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i1@482@04))
      i1@482@04))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i1@482@04))
  :qid |int-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@483@04 r) V@15@04) (<= 0 (inv@483@04 r)))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) (inv@483@04 r))
      r))
  :pattern ((inv@483@04 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@483@04 r) V@15@04) (<= 0 (inv@483@04 r)))
    ($FVF.loc_int ($FVF.lookup_int (as sm@484@04  $FVF<Int>) r) r))
  :pattern ((inv@483@04 r))
  )))
; Precomputing data for removing quantified permissions
(define-fun pTaken@485@04 ((r $Ref)) $Perm
  (ite
    (and (< (inv@483@04 r) V@15@04) (<= 0 (inv@483@04 r)))
    ($Perm.min
      (-
        (ite
          (and
            (and
              (and (< (inv@366@04 r) V@15@04) (<= 0 (inv@366@04 r)))
              (< (inv@365@04 r) V@15@04))
            (<= 0 (inv@365@04 r)))
          $Perm.Write
          $Perm.No)
        (pTaken@481@04 r))
      $Perm.Write)
    $Perm.No))
(define-fun pTaken@486@04 ((r $Ref)) $Perm
  (ite
    (and (< (inv@483@04 r) V@15@04) (<= 0 (inv@483@04 r)))
    ($Perm.min
      (-
        (ite
          (and (< (inv@369@04 r) V@15@04) (<= 0 (inv@369@04 r)))
          $Perm.Write
          $Perm.No)
        (pTaken@480@04 r))
      (- $Perm.Write (pTaken@485@04 r)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 500)
(push) ; 14
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (-
        (ite
          (and
            (and
              (and (< (inv@366@04 r) V@15@04) (<= 0 (inv@366@04 r)))
              (< (inv@365@04 r) V@15@04))
            (<= 0 (inv@365@04 r)))
          $Perm.Write
          $Perm.No)
        (pTaken@481@04 r))
      (pTaken@485@04 r))
    $Perm.No)
  
  ))))
(check-sat)
; unknown
(pop) ; 14
; 0.50s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               6422437
;  :arith-add-rows          1516127
;  :arith-assert-diseq      26937
;  :arith-assert-lower      1130171
;  :arith-assert-upper      992314
;  :arith-bound-prop        38044
;  :arith-conflicts         1064
;  :arith-eq-adapter        608599
;  :arith-fixed-eqs         1064195
;  :arith-offset-eqs        668574
;  :arith-pivots            230856
;  :conflicts               3150
;  :datatype-accessor-ax    367
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               210443
;  :del-clause              21720189
;  :final-checks            5
;  :max-generation          14
;  :max-memory              266.02
;  :memory                  247.73
;  :minimized-lits          339
;  :mk-bool-var             18814355
;  :mk-clause               21721949
;  :num-allocs              45566414
;  :num-checks              513
;  :propagations            5897649
;  :quant-instantiations    8234041
;  :restarts                5
;  :rlimit-count            175452721
;  :time                    0.50)
; Intermediate check if already taken enough permissions
(push) ; 14
(assert (not (forall ((r $Ref)) (!
  (implies
    (and (< (inv@483@04 r) V@15@04) (<= 0 (inv@483@04 r)))
    (= (- $Perm.Write (pTaken@485@04 r)) $Perm.No))
  
  ))))
(check-sat)
; unknown
(pop) ; 14
; 0.50s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               6435693
;  :arith-add-rows          1526793
;  :arith-assert-diseq      27048
;  :arith-assert-lower      1132322
;  :arith-assert-upper      993911
;  :arith-bound-prop        38593
;  :arith-conflicts         1074
;  :arith-eq-adapter        610343
;  :arith-fixed-eqs         1065763
;  :arith-offset-eqs        669985
;  :arith-pivots            232567
;  :conflicts               3167
;  :datatype-accessor-ax    367
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               213106
;  :del-clause              21823375
;  :final-checks            5
;  :max-generation          14
;  :max-memory              266.02
;  :memory                  247.77
;  :minimized-lits          339
;  :mk-bool-var             18898223
;  :mk-clause               21825135
;  :num-allocs              45783123
;  :num-checks              514
;  :propagations            5914966
;  :quant-instantiations    8258612
;  :restarts                5
;  :rlimit-count            176391222
;  :time                    0.50)
; Chunk depleted?
(push) ; 14
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (-
        (ite
          (and (< (inv@369@04 r) V@15@04) (<= 0 (inv@369@04 r)))
          $Perm.Write
          $Perm.No)
        (pTaken@480@04 r))
      (pTaken@486@04 r))
    $Perm.No)
  
  ))))
(check-sat)
; unsat
(pop) ; 14
; 0.31s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               6440960
;  :arith-add-rows          1532605
;  :arith-assert-diseq      27149
;  :arith-assert-lower      1133291
;  :arith-assert-upper      994577
;  :arith-bound-prop        38743
;  :arith-conflicts         1084
;  :arith-eq-adapter        610952
;  :arith-fixed-eqs         1066520
;  :arith-offset-eqs        670139
;  :arith-pivots            233039
;  :conflicts               3187
;  :datatype-accessor-ax    367
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               214882
;  :del-clause              21879885
;  :final-checks            5
;  :max-generation          14
;  :max-memory              266.02
;  :memory                  248.04
;  :minimized-lits          343
;  :mk-bool-var             18939243
;  :mk-clause               21881645
;  :num-allocs              45889593
;  :num-checks              515
;  :propagations            5922638
;  :quant-instantiations    8268561
;  :restarts                5
;  :rlimit-count            176813939
;  :time                    0.31)
; Intermediate check if already taken enough permissions
(push) ; 14
(assert (not (forall ((r $Ref)) (!
  (implies
    (and (< (inv@483@04 r) V@15@04) (<= 0 (inv@483@04 r)))
    (= (- (- $Perm.Write (pTaken@485@04 r)) (pTaken@486@04 r)) $Perm.No))
  
  ))))
(check-sat)
; unknown
(pop) ; 14
; 0.51s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               6456385
;  :arith-add-rows          1541293
;  :arith-assert-diseq      27306
;  :arith-assert-lower      1135951
;  :arith-assert-upper      996615
;  :arith-bound-prop        39316
;  :arith-conflicts         1095
;  :arith-eq-adapter        613137
;  :arith-fixed-eqs         1068504
;  :arith-offset-eqs        671687
;  :arith-pivots            234856
;  :conflicts               3213
;  :datatype-accessor-ax    367
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               217184
;  :del-clause              21987782
;  :final-checks            5
;  :max-generation          14
;  :max-memory              266.02
;  :memory                  248.43
;  :minimized-lits          349
;  :mk-bool-var             19031572
;  :mk-clause               21989542
;  :num-allocs              46126456
;  :num-checks              516
;  :propagations            5945630
;  :quant-instantiations    8299439
;  :restarts                5
;  :rlimit-count            177853363
;  :time                    0.51)
; Final check if taken enough permissions
(set-option :timeout 0)
(push) ; 14
(assert (not (forall ((r $Ref)) (!
  (implies
    (and (< (inv@483@04 r) V@15@04) (<= 0 (inv@483@04 r)))
    (= (- (- $Perm.Write (pTaken@485@04 r)) (pTaken@486@04 r)) $Perm.No))
  
  ))))
(check-sat)
; unsat
(pop) ; 14
; 8.38s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               6664888
;  :arith-add-rows          1647241
;  :arith-assert-diseq      30235
;  :arith-assert-lower      1170099
;  :arith-assert-upper      1027622
;  :arith-bound-prop        43089
;  :arith-conflicts         1164
;  :arith-eq-adapter        640834
;  :arith-fixed-eqs         1098751
;  :arith-offset-eqs        690128
;  :arith-pivots            249984
;  :conflicts               3342
;  :datatype-accessor-ax    387
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               244303
;  :del-clause              23465018
;  :final-checks            5
;  :max-generation          14
;  :max-memory              266.02
;  :memory                  253.51
;  :minimized-lits          387
;  :mk-bool-var             20230470
;  :mk-clause               23466778
;  :num-allocs              48814964
;  :num-checks              517
;  :propagations            6282127
;  :quant-instantiations    8722573
;  :restarts                6
;  :rlimit-count            189305154
;  :time                    8.38)
; Done removing quantified permissions
; Definitional axioms for snapshot map values
; [eval] valid_graph_vertices(this, P, V)
(push) ; 14
; [eval] this != null
; [eval] p != (None(): option[array])
; [eval] (None(): option[array])
; [eval] alen(opt_get1(p)) == V
; [eval] alen(opt_get1(p))
; [eval] opt_get1(p)
(push) ; 15
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 15
; Joined path conditions
(declare-const i1@487@04 Int)
(push) ; 15
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 16
; [then-branch: 268 | 0 <= i1@487@04 | live]
; [else-branch: 268 | !(0 <= i1@487@04) | live]
(push) ; 17
; [then-branch: 268 | 0 <= i1@487@04]
(assert (<= 0 i1@487@04))
; [eval] i1 < V
(pop) ; 17
(push) ; 17
; [else-branch: 268 | !(0 <= i1@487@04)]
(assert (not (<= 0 i1@487@04)))
(pop) ; 17
(pop) ; 16
; Joined path conditions
; Joined path conditions
(assert (and (< i1@487@04 V@15@04) (<= 0 i1@487@04)))
(declare-const $k@488@04 $Perm)
(assert ($Perm.isReadVar $k@488@04 $Perm.Write))
; [eval] aloc(opt_get1(p), i1)
; [eval] opt_get1(p)
(push) ; 16
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 16
; Joined path conditions
(push) ; 16
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 17
(assert (not (< i1@487@04 (alen<Int> (opt_get1 $Snap.unit P@14@04)))))
(check-sat)
; unsat
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               6664888
;  :arith-add-rows          1647242
;  :arith-assert-diseq      30236
;  :arith-assert-lower      1170103
;  :arith-assert-upper      1027623
;  :arith-bound-prop        43089
;  :arith-conflicts         1164
;  :arith-eq-adapter        640835
;  :arith-fixed-eqs         1098751
;  :arith-offset-eqs        690128
;  :arith-pivots            249985
;  :conflicts               3342
;  :datatype-accessor-ax    387
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               244303
;  :del-clause              23465018
;  :final-checks            5
;  :max-generation          14
;  :max-memory              266.02
;  :memory                  253.51
;  :minimized-lits          387
;  :mk-bool-var             20230476
;  :mk-clause               23466780
;  :num-allocs              48815138
;  :num-checks              518
;  :propagations            6282128
;  :quant-instantiations    8722573
;  :restarts                6
;  :rlimit-count            189305491)
(assert (< i1@487@04 (alen<Int> (opt_get1 $Snap.unit P@14@04))))
(pop) ; 16
; Joined path conditions
(assert (< i1@487@04 (alen<Int> (opt_get1 $Snap.unit P@14@04))))
(pop) ; 15
(declare-fun inv@489@04 ($Ref) Int)
; Nested auxiliary terms: globals
(assert ($Perm.isReadVar $k@488@04 $Perm.Write))
; Nested auxiliary terms: non-globals
(assert (forall ((i1@487@04 Int)) (!
  (< i1@487@04 (alen<Int> (opt_get1 $Snap.unit P@14@04)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i1@487@04))
  :qid |int-aux|)))
(push) ; 15
(assert (not (forall ((i1@487@04 Int)) (!
  (implies
    (and (< i1@487@04 V@15@04) (<= 0 i1@487@04))
    (or (= $k@488@04 $Perm.No) (< $Perm.No $k@488@04)))
  
  ))))
(check-sat)
; unsat
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               6664888
;  :arith-add-rows          1647243
;  :arith-assert-diseq      30237
;  :arith-assert-lower      1170105
;  :arith-assert-upper      1027624
;  :arith-bound-prop        43089
;  :arith-conflicts         1164
;  :arith-eq-adapter        640836
;  :arith-fixed-eqs         1098751
;  :arith-offset-eqs        690128
;  :arith-pivots            249986
;  :conflicts               3343
;  :datatype-accessor-ax    387
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               244303
;  :del-clause              23465020
;  :final-checks            5
;  :max-generation          14
;  :max-memory              266.02
;  :memory                  253.51
;  :minimized-lits          387
;  :mk-bool-var             20230483
;  :mk-clause               23466782
;  :num-allocs              48815569
;  :num-checks              519
;  :propagations            6282129
;  :quant-instantiations    8722573
;  :restarts                6
;  :rlimit-count            189306042)
(declare-const sm@490@04 $FVF<Int>)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@366@04 r) V@15@04) (<= 0 (inv@366@04 r)))
        (< (inv@365@04 r) V@15@04))
      (<= 0 (inv@365@04 r)))
    (=
      ($FVF.lookup_int (as sm@490@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@490@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))))))) r))
  :qid |qp.fvfValDef343|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@369@04 r) V@15@04) (<= 0 (inv@369@04 r)))
    (=
      ($FVF.lookup_int (as sm@490@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04)))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@490@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04)))))))))))))) r))
  :qid |qp.fvfValDef344|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04)))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@490@04  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef345|)))
; Check receiver injectivity
(push) ; 15
(assert (not (forall ((i11@487@04 Int) (i12@487@04 Int)) (!
  (implies
    (and
      (and
        (and
          (and (< i11@487@04 V@15@04) (<= 0 i11@487@04))
          ($FVF.loc_int ($FVF.lookup_int (as sm@490@04  $FVF<Int>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit P@14@04) i11@487@04)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit P@14@04) i11@487@04)))
        (< $Perm.No $k@488@04))
      (and
        (and
          (and (< i12@487@04 V@15@04) (<= 0 i12@487@04))
          ($FVF.loc_int ($FVF.lookup_int (as sm@490@04  $FVF<Int>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit P@14@04) i12@487@04)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit P@14@04) i12@487@04)))
        (< $Perm.No $k@488@04))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i11@487@04)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i12@487@04)))
    (= i11@487@04 i12@487@04))
  
  :qid |int-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 15
; 0.07s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               6664943
;  :arith-add-rows          1647254
;  :arith-assert-diseq      30238
;  :arith-assert-lower      1170109
;  :arith-assert-upper      1027624
;  :arith-bound-prop        43089
;  :arith-conflicts         1164
;  :arith-eq-adapter        640837
;  :arith-fixed-eqs         1098751
;  :arith-offset-eqs        690128
;  :arith-pivots            249990
;  :conflicts               3344
;  :datatype-accessor-ax    387
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               244303
;  :del-clause              23465031
;  :final-checks            5
;  :max-generation          14
;  :max-memory              266.02
;  :memory                  253.51
;  :minimized-lits          387
;  :mk-bool-var             20230562
;  :mk-clause               23466793
;  :num-allocs              48816755
;  :num-checks              520
;  :propagations            6282131
;  :quant-instantiations    8722661
;  :restarts                6
;  :rlimit-count            189310042
;  :time                    0.07)
; Definitional axioms for inverse functions
(assert (forall ((i1@487@04 Int)) (!
  (implies
    (and (and (< i1@487@04 V@15@04) (<= 0 i1@487@04)) (< $Perm.No $k@488@04))
    (=
      (inv@489@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i1@487@04))
      i1@487@04))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i1@487@04))
  :qid |int-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and (< (inv@489@04 r) V@15@04) (<= 0 (inv@489@04 r)))
      (< $Perm.No $k@488@04))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) (inv@489@04 r))
      r))
  :pattern ((inv@489@04 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@489@04 r) V@15@04) (<= 0 (inv@489@04 r)))
    ($FVF.loc_int ($FVF.lookup_int (as sm@490@04  $FVF<Int>) r) r))
  :pattern ((inv@489@04 r))
  )))
; Precomputing data for removing quantified permissions
(define-fun pTaken@491@04 ((r $Ref)) $Perm
  (ite
    (and (< (inv@489@04 r) V@15@04) (<= 0 (inv@489@04 r)))
    ($Perm.min
      (ite
        (and
          (and
            (and (< (inv@366@04 r) V@15@04) (<= 0 (inv@366@04 r)))
            (< (inv@365@04 r) V@15@04))
          (<= 0 (inv@365@04 r)))
        $Perm.Write
        $Perm.No)
      $k@488@04)
    $Perm.No))
(define-fun pTaken@492@04 ((r $Ref)) $Perm
  (ite
    (and (< (inv@489@04 r) V@15@04) (<= 0 (inv@489@04 r)))
    ($Perm.min
      (ite
        (and (< (inv@369@04 r) V@15@04) (<= 0 (inv@369@04 r)))
        $Perm.Write
        $Perm.No)
      (- $k@488@04 (pTaken@491@04 r)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Constrain original permissions $k@488@04
(assert (forall ((r $Ref)) (!
  (implies
    (not
      (=
        (ite
          (and
            (and
              (and (< (inv@366@04 r) V@15@04) (<= 0 (inv@366@04 r)))
              (< (inv@365@04 r) V@15@04))
            (<= 0 (inv@365@04 r)))
          $Perm.Write
          $Perm.No)
        $Perm.No))
    (ite
      (and
        (and
          (and (< (inv@366@04 r) V@15@04) (<= 0 (inv@366@04 r)))
          (< (inv@365@04 r) V@15@04))
        (<= 0 (inv@365@04 r)))
      (<
        (ite
          (and (< (inv@489@04 r) V@15@04) (<= 0 (inv@489@04 r)))
          $k@488@04
          $Perm.No)
        $Perm.Write)
      (<
        (ite
          (and (< (inv@489@04 r) V@15@04) (<= 0 (inv@489@04 r)))
          $k@488@04
          $Perm.No)
        $Perm.No)))
  :pattern ((inv@366@04 r))
  :pattern ((inv@365@04 r))
  :pattern ((inv@489@04 r))
  :qid |qp.srp346|)))
; Intermediate check if already taken enough permissions
(set-option :timeout 500)
(push) ; 15
(assert (not (forall ((r $Ref)) (!
  (implies
    (and (< (inv@489@04 r) V@15@04) (<= 0 (inv@489@04 r)))
    (= (- $k@488@04 (pTaken@491@04 r)) $Perm.No))
  
  ))))
(check-sat)
; unknown
(pop) ; 15
; 0.51s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               6682503
;  :arith-add-rows          1660076
;  :arith-assert-diseq      30404
;  :arith-assert-lower      1173033
;  :arith-assert-upper      1029894
;  :arith-bound-prop        43654
;  :arith-conflicts         1173
;  :arith-eq-adapter        643178
;  :arith-fixed-eqs         1101002
;  :arith-offset-eqs        691867
;  :arith-pivots            251710
;  :conflicts               3362
;  :datatype-accessor-ax    391
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               247288
;  :del-clause              23598239
;  :final-checks            5
;  :max-generation          14
;  :max-memory              266.02
;  :memory                  251.33
;  :minimized-lits          391
;  :mk-bool-var             20339609
;  :mk-clause               23600001
;  :num-allocs              49091105
;  :num-checks              522
;  :propagations            6309371
;  :quant-instantiations    8758773
;  :restarts                6
;  :rlimit-count            190505506
;  :time                    0.51)
; Constrain original permissions $k@488@04
(assert (forall ((r $Ref)) (!
  (implies
    (not
      (=
        (ite
          (and (< (inv@369@04 r) V@15@04) (<= 0 (inv@369@04 r)))
          $Perm.Write
          $Perm.No)
        $Perm.No))
    (ite
      (and (< (inv@369@04 r) V@15@04) (<= 0 (inv@369@04 r)))
      (<
        (ite
          (and (< (inv@489@04 r) V@15@04) (<= 0 (inv@489@04 r)))
          $k@488@04
          $Perm.No)
        $Perm.Write)
      (<
        (ite
          (and (< (inv@489@04 r) V@15@04) (<= 0 (inv@489@04 r)))
          $k@488@04
          $Perm.No)
        $Perm.No)))
  :pattern ((inv@369@04 r))
  :pattern ((inv@489@04 r))
  :qid |qp.srp347|)))
; Intermediate check if already taken enough permissions
(push) ; 15
(assert (not (forall ((r $Ref)) (!
  (implies
    (and (< (inv@489@04 r) V@15@04) (<= 0 (inv@489@04 r)))
    (= (- (- $k@488@04 (pTaken@491@04 r)) (pTaken@492@04 r)) $Perm.No))
  
  ))))
(check-sat)
; unsat
(pop) ; 15
; 0.07s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               6683495
;  :arith-add-rows          1661322
;  :arith-assert-diseq      30431
;  :arith-assert-lower      1173181
;  :arith-assert-upper      1029998
;  :arith-bound-prop        43708
;  :arith-conflicts         1179
;  :arith-eq-adapter        643309
;  :arith-fixed-eqs         1101097
;  :arith-offset-eqs        691941
;  :arith-pivots            251800
;  :conflicts               3388
;  :datatype-accessor-ax    391
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               247527
;  :del-clause              23607270
;  :final-checks            5
;  :max-generation          14
;  :max-memory              266.02
;  :memory                  251.27
;  :minimized-lits          393
;  :mk-bool-var             20347049
;  :mk-clause               23609032
;  :num-allocs              49113026
;  :num-checks              523
;  :propagations            6310467
;  :quant-instantiations    8760393
;  :restarts                6
;  :rlimit-count            190599565
;  :time                    0.05)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@493@04 $FVF<Int>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (iff
    (Set_in r ($FVF.domain_int (as sm@493@04  $FVF<Int>)))
    (and
      (and (< (inv@489@04 r) V@15@04) (<= 0 (inv@489@04 r)))
      (< $Perm.No $k@488@04)))
  :pattern ((Set_in r ($FVF.domain_int (as sm@493@04  $FVF<Int>))))
  :qid |qp.fvfDomDef351|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@489@04 r) V@15@04) (<= 0 (inv@489@04 r)))
        (< $Perm.No $k@488@04))
      (and
        (and
          (and (< (inv@366@04 r) V@15@04) (<= 0 (inv@366@04 r)))
          (< (inv@365@04 r) V@15@04))
        (<= 0 (inv@365@04 r))))
    (=
      ($FVF.lookup_int (as sm@493@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@493@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))))))) r))
  :qid |qp.fvfValDef348|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@489@04 r) V@15@04) (<= 0 (inv@489@04 r)))
        (< $Perm.No $k@488@04))
      (and (< (inv@369@04 r) V@15@04) (<= 0 (inv@369@04 r))))
    (=
      ($FVF.lookup_int (as sm@493@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04)))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@493@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04)))))))))))))) r))
  :qid |qp.fvfValDef349|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04)))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@493@04  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef350|)))
(pop) ; 14
; Joined path conditions
(assert ($Perm.isReadVar $k@488@04 $Perm.Write))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@366@04 r) V@15@04) (<= 0 (inv@366@04 r)))
        (< (inv@365@04 r) V@15@04))
      (<= 0 (inv@365@04 r)))
    (=
      ($FVF.lookup_int (as sm@490@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@490@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))))))) r))
  :qid |qp.fvfValDef343|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@369@04 r) V@15@04) (<= 0 (inv@369@04 r)))
    (=
      ($FVF.lookup_int (as sm@490@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04)))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@490@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04)))))))))))))) r))
  :qid |qp.fvfValDef344|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04)))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@490@04  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef345|)))
(assert (forall ((i1@487@04 Int)) (!
  (implies
    (and (and (< i1@487@04 V@15@04) (<= 0 i1@487@04)) (< $Perm.No $k@488@04))
    (=
      (inv@489@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i1@487@04))
      i1@487@04))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i1@487@04))
  :qid |int-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and (< (inv@489@04 r) V@15@04) (<= 0 (inv@489@04 r)))
      (< $Perm.No $k@488@04))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) (inv@489@04 r))
      r))
  :pattern ((inv@489@04 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (iff
    (Set_in r ($FVF.domain_int (as sm@493@04  $FVF<Int>)))
    (and
      (and (< (inv@489@04 r) V@15@04) (<= 0 (inv@489@04 r)))
      (< $Perm.No $k@488@04)))
  :pattern ((Set_in r ($FVF.domain_int (as sm@493@04  $FVF<Int>))))
  :qid |qp.fvfDomDef351|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@489@04 r) V@15@04) (<= 0 (inv@489@04 r)))
        (< $Perm.No $k@488@04))
      (and
        (and
          (and (< (inv@366@04 r) V@15@04) (<= 0 (inv@366@04 r)))
          (< (inv@365@04 r) V@15@04))
        (<= 0 (inv@365@04 r))))
    (=
      ($FVF.lookup_int (as sm@493@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@493@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))))))) r))
  :qid |qp.fvfValDef348|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@489@04 r) V@15@04) (<= 0 (inv@489@04 r)))
        (< $Perm.No $k@488@04))
      (and (< (inv@369@04 r) V@15@04) (<= 0 (inv@369@04 r))))
    (=
      ($FVF.lookup_int (as sm@493@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04)))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@493@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04)))))))))))))) r))
  :qid |qp.fvfValDef349|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04)))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@493@04  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef350|)))
(assert (and
  (forall ((i1@487@04 Int)) (!
    (< i1@487@04 (alen<Int> (opt_get1 $Snap.unit P@14@04)))
    :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i1@487@04))
    :qid |int-aux|))
  (forall ((r $Ref)) (!
    (implies
      (and (< (inv@489@04 r) V@15@04) (<= 0 (inv@489@04 r)))
      ($FVF.loc_int ($FVF.lookup_int (as sm@490@04  $FVF<Int>) r) r))
    :pattern ((inv@489@04 r))
    ))
  (forall ((r $Ref)) (!
    (implies
      (not
        (=
          (ite
            (and
              (and
                (and (< (inv@366@04 r) V@15@04) (<= 0 (inv@366@04 r)))
                (< (inv@365@04 r) V@15@04))
              (<= 0 (inv@365@04 r)))
            $Perm.Write
            $Perm.No)
          $Perm.No))
      (ite
        (and
          (and
            (and (< (inv@366@04 r) V@15@04) (<= 0 (inv@366@04 r)))
            (< (inv@365@04 r) V@15@04))
          (<= 0 (inv@365@04 r)))
        (<
          (ite
            (and (< (inv@489@04 r) V@15@04) (<= 0 (inv@489@04 r)))
            $k@488@04
            $Perm.No)
          $Perm.Write)
        (<
          (ite
            (and (< (inv@489@04 r) V@15@04) (<= 0 (inv@489@04 r)))
            $k@488@04
            $Perm.No)
          $Perm.No)))
    :pattern ((inv@366@04 r))
    :pattern ((inv@365@04 r))
    :pattern ((inv@489@04 r))
    :qid |qp.srp346|))
  (forall ((r $Ref)) (!
    (implies
      (not
        (=
          (ite
            (and (< (inv@369@04 r) V@15@04) (<= 0 (inv@369@04 r)))
            $Perm.Write
            $Perm.No)
          $Perm.No))
      (ite
        (and (< (inv@369@04 r) V@15@04) (<= 0 (inv@369@04 r)))
        (<
          (ite
            (and (< (inv@489@04 r) V@15@04) (<= 0 (inv@489@04 r)))
            $k@488@04
            $Perm.No)
          $Perm.Write)
        (<
          (ite
            (and (< (inv@489@04 r) V@15@04) (<= 0 (inv@489@04 r)))
            $k@488@04
            $Perm.No)
          $Perm.No)))
    :pattern ((inv@369@04 r))
    :pattern ((inv@489@04 r))
    :qid |qp.srp347|))))
(set-option :timeout 0)
(push) ; 14
(assert (not (valid_graph_vertices ($Snap.combine
  $Snap.unit
  ($Snap.combine
    $Snap.unit
    ($Snap.combine
      $Snap.unit
      ($SortWrappers.$FVF<Int>To$Snap (as sm@493@04  $FVF<Int>))))) this@9@04 P@14@04 V@15@04)))
(check-sat)
; unsat
(pop) ; 14
; 40.85s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               10120572
;  :arith-add-rows          2262420
;  :arith-assert-diseq      43953
;  :arith-assert-lower      1801656
;  :arith-assert-upper      1596807
;  :arith-bound-prop        56718
;  :arith-conflicts         1465
;  :arith-eq-adapter        802993
;  :arith-fixed-eqs         1793906
;  :arith-offset-eqs        1124887
;  :arith-pivots            342102
;  :conflicts               3838
;  :datatype-accessor-ax    414
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               352223
;  :del-clause              29374377
;  :final-checks            5
;  :max-generation          14
;  :max-memory              272.27
;  :memory                  264.04
;  :minimized-lits          460
;  :mk-bool-var             25715389
;  :mk-clause               29376139
;  :num-allocs              62342461
;  :num-checks              524
;  :propagations            8360634
;  :quant-instantiations    11045189
;  :restarts                8
;  :rlimit-count            241336898
;  :time                    40.84)
(assert (valid_graph_vertices ($Snap.combine
  $Snap.unit
  ($Snap.combine
    $Snap.unit
    ($Snap.combine
      $Snap.unit
      ($SortWrappers.$FVF<Int>To$Snap (as sm@493@04  $FVF<Int>))))) this@9@04 P@14@04 V@15@04))
; Loop head block: Execute statements of loop head block (in invariant state)
(push) ; 14
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@457@04 r) V@15@04) (<= 0 (inv@457@04 r)))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) (inv@457@04 r))
      r))
  :pattern ((inv@457@04 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@457@04 r) V@15@04) (<= 0 (inv@457@04 r)))
    (=
      ($FVF.lookup_int (as sm@458@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04)))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@458@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04)))))))))))))) r))
  :qid |qp.fvfValDef325|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@454@04 r) V@15@04) (<= 0 (inv@454@04 r)))
        (< (inv@453@04 r) V@15@04))
      (<= 0 (inv@453@04 r)))
    (=
      ($FVF.lookup_int (as sm@458@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@458@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))))))) r))
  :qid |qp.fvfValDef326|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04)))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@458@04  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef327|)))
(assert ($Perm.isReadVar $k@460@04 $Perm.Write))
(assert (forall ((i1@459@04 Int)) (!
  (implies
    (and (and (< i1@459@04 V@15@04) (<= 0 i1@459@04)) (< $Perm.No $k@460@04))
    (=
      (inv@461@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i1@459@04))
      i1@459@04))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i1@459@04))
  :qid |int-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and (< (inv@461@04 r) V@15@04) (<= 0 (inv@461@04 r)))
      (< $Perm.No $k@460@04))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) (inv@461@04 r))
      r))
  :pattern ((inv@461@04 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (iff
    (Set_in r ($FVF.domain_int (as sm@464@04  $FVF<Int>)))
    (and
      (and (< (inv@461@04 r) V@15@04) (<= 0 (inv@461@04 r)))
      (< $Perm.No $k@460@04)))
  :pattern ((Set_in r ($FVF.domain_int (as sm@464@04  $FVF<Int>))))
  :qid |qp.fvfDomDef332|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@461@04 r) V@15@04) (<= 0 (inv@461@04 r)))
        (< $Perm.No $k@460@04))
      (and (< (inv@457@04 r) V@15@04) (<= 0 (inv@457@04 r))))
    (=
      ($FVF.lookup_int (as sm@464@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04)))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@464@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04)))))))))))))) r))
  :qid |qp.fvfValDef329|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@461@04 r) V@15@04) (<= 0 (inv@461@04 r)))
        (< $Perm.No $k@460@04))
      (and
        (and
          (and (< (inv@454@04 r) V@15@04) (<= 0 (inv@454@04 r)))
          (< (inv@453@04 r) V@15@04))
        (<= 0 (inv@453@04 r))))
    (=
      ($FVF.lookup_int (as sm@464@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@464@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))))))) r))
  :qid |qp.fvfValDef330|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04)))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@464@04  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef331|)))
(assert (forall ((i1@456@04 Int)) (!
  (implies
    (and (< i1@456@04 V@15@04) (<= 0 i1@456@04))
    (=
      (inv@457@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i1@456@04))
      i1@456@04))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i1@456@04))
  )))
(assert (forall ((i1@456@04 Int)) (!
  (implies
    (and (< i1@456@04 V@15@04) (<= 0 i1@456@04))
    (not
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i1@456@04)
        $Ref.null)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i1@456@04))
  :qid |int-permImpliesNonNull|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@457@04 r) V@15@04) (<= 0 (inv@457@04 r)))
    ($FVF.loc_int ($FVF.lookup_int (as sm@458@04  $FVF<Int>) r) r))
  :pattern ((inv@457@04 r))
  )))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04)))))))))))))
  $Snap.unit))
(assert (forall ((i1@459@04 Int)) (!
  (< i1@459@04 (alen<Int> (opt_get1 $Snap.unit P@14@04)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i1@459@04))
  :qid |int-aux|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@461@04 r) V@15@04) (<= 0 (inv@461@04 r)))
    ($FVF.loc_int ($FVF.lookup_int (as sm@458@04  $FVF<Int>) r) r))
  :pattern ((inv@461@04 r))
  )))
(assert (forall ((r $Ref)) (!
  (implies
    (not
      (=
        (ite
          (and (< (inv@457@04 r) V@15@04) (<= 0 (inv@457@04 r)))
          $Perm.Write
          $Perm.No)
        $Perm.No))
    (ite
      (and (< (inv@457@04 r) V@15@04) (<= 0 (inv@457@04 r)))
      (<
        (ite
          (and (< (inv@461@04 r) V@15@04) (<= 0 (inv@461@04 r)))
          $k@460@04
          $Perm.No)
        $Perm.Write)
      (<
        (ite
          (and (< (inv@461@04 r) V@15@04) (<= 0 (inv@461@04 r)))
          $k@460@04
          $Perm.No)
        $Perm.No)))
  :pattern ((inv@457@04 r))
  :pattern ((inv@461@04 r))
  :qid |qp.srp328|)))
(assert (valid_graph_vertices ($Snap.combine
  $Snap.unit
  ($Snap.combine
    $Snap.unit
    ($Snap.combine
      $Snap.unit
      ($SortWrappers.$FVF<Int>To$Snap (as sm@464@04  $FVF<Int>))))) this@9@04 P@14@04 V@15@04))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@454@04 r) V@15@04) (<= 0 (inv@454@04 r)))
        (< (inv@453@04 r) V@15@04))
      (<= 0 (inv@453@04 r)))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) (inv@453@04 r)))) (inv@454@04 r))
      r))
  :pattern ((inv@453@04 r))
  :pattern ((inv@454@04 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@454@04 r) V@15@04) (<= 0 (inv@454@04 r)))
        (< (inv@453@04 r) V@15@04))
      (<= 0 (inv@453@04 r)))
    (=
      ($FVF.lookup_int (as sm@455@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@455@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))))))) r))
  :qid |qp.fvfValDef323|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))))))) r) r)
  :pattern (($FVF.lookup_int (as sm@455@04  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef324|)))
(assert (forall ((i1@451@04 Int) (j@452@04 Int)) (!
  (implies
    (and
      (and (and (< j@452@04 V@15@04) (<= 0 j@452@04)) (< i1@451@04 V@15@04))
      (<= 0 i1@451@04))
    (and
      (=
        (inv@453@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@451@04))) j@452@04))
        i1@451@04)
      (=
        (inv@454@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@451@04))) j@452@04))
        j@452@04)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@451@04))) j@452@04))
  )))
(assert (forall ((i1@451@04 Int) (j@452@04 Int)) (!
  (implies
    (and
      (and (and (< j@452@04 V@15@04) (<= 0 j@452@04)) (< i1@451@04 V@15@04))
      (<= 0 i1@451@04))
    (not
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@451@04))) j@452@04)
        $Ref.null)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@451@04))) j@452@04))
  :qid |int-permImpliesNonNull|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@454@04 r) V@15@04) (<= 0 (inv@454@04 r)))
        (< (inv@453@04 r) V@15@04))
      (<= 0 (inv@453@04 r)))
    ($FVF.loc_int ($FVF.lookup_int (as sm@455@04  $FVF<Int>) r) r))
  :pattern ((inv@453@04 r) (inv@454@04 r))
  )))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04)))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04)))))))))))
  $Snap.unit))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04)))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04)))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))))))))
  $Snap.unit))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04)))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))))))))))))
(assert (forall ((i1@456@04 Int)) (!
  (< i1@456@04 (alen<Int> (opt_get1 $Snap.unit P@14@04)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i1@456@04))
  :qid |int-aux|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and (< (inv@445@04 r) V@15@04) (<= 0 (inv@445@04 r)))
      (< $Perm.No $k@444@04))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) (inv@445@04 r))
      r))
  :pattern ((inv@445@04 r))
  :qid |option$array$-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@445@04 r) V@15@04) (<= 0 (inv@445@04 r)))
      (< $Perm.No $k@444@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))) r))
  :qid |qp.fvfValDef321|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))) r) r)
  :pattern (($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef322|)))
(assert (forall ((i1@443@04 Int)) (!
  (implies
    (and (and (< i1@443@04 V@15@04) (<= 0 i1@443@04)) (< $Perm.No $k@444@04))
    (=
      (inv@445@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@443@04))
      i1@443@04))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@443@04))
  )))
(assert (forall ((i1@443@04 Int)) (!
  (<= $Perm.No $k@444@04)
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@443@04))
  :qid |option$array$-permAtLeastZero|)))
(assert (forall ((i1@443@04 Int)) (!
  (<= $k@444@04 $Perm.Write)
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@443@04))
  :qid |option$array$-permAtMostOne|)))
(assert (forall ((i1@443@04 Int)) (!
  (implies
    (and (and (< i1@443@04 V@15@04) (<= 0 i1@443@04)) (< $Perm.No $k@444@04))
    (not
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@443@04)
        $Ref.null)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@443@04))
  :qid |option$array$-permImpliesNonNull|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@445@04 r) V@15@04) (<= 0 (inv@445@04 r)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) r) r))
  :pattern ((inv@445@04 r))
  )))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04)))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04)))))))
  $Snap.unit))
(assert (forall ((i1@447@04 Int)) (!
  (implies
    (and (< i1@447@04 V@15@04) (<= 0 i1@447@04))
    (and
      (< i1@447@04 V@15@04)
      (<= 0 i1@447@04)
      (< i1@447@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@447@04)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@447@04))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@447@04))
  :qid |prog.l<no position>-aux|)))
(assert (forall ((i1@447@04 Int)) (!
  (implies
    (and (< i1@447@04 V@15@04) (<= 0 i1@447@04))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@447@04))
        (as None<option<array>>  option<array>))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@447@04))
  :qid |prog.l<no position>|)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04)))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04)))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))))
  $Snap.unit))
(assert (forall ((i1@448@04 Int)) (!
  (implies
    (and (< i1@448@04 V@15@04) (<= 0 i1@448@04))
    (and
      (< i1@448@04 V@15@04)
      (<= 0 i1@448@04)
      (< i1@448@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@448@04)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@448@04))
      (not
        (=
          ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@448@04))
          (as None<option<array>>  option<array>)))))
  :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@448@04)))))
  :qid |prog.l<no position>-aux|)))
(assert (forall ((i1@448@04 Int)) (!
  (implies
    (and (< i1@448@04 V@15@04) (<= 0 i1@448@04))
    (=
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@448@04))))
      V@15@04))
  :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@448@04)))))
  :qid |prog.l<no position>|)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04)))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04)))))))))
  $Snap.unit))
(assert (forall ((i1@449@04 Int)) (!
  (forall ((i2@450@04 Int)) (!
    (and
      (implies
        (<= 0 i1@449@04)
        (and
          (<= 0 i1@449@04)
          (implies
            (< i1@449@04 V@15@04)
            (and
              (< i1@449@04 V@15@04)
              (implies
                (<= 0 i2@450@04)
                (and
                  (<= 0 i2@450@04)
                  (implies
                    (< i2@450@04 V@15@04)
                    (and
                      (< i2@450@04 V@15@04)
                      (< i1@449@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
                      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@449@04)) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@449@04))
                      (< i2@450@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
                      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@450@04)) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@450@04))))))))))
      (implies
        (and
          (and
            (and
              (and
                (=
                  ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@449@04))
                  ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@450@04)))
                (< i2@450@04 V@15@04))
              (<= 0 i2@450@04))
            (< i1@449@04 V@15@04))
          (<= 0 i1@449@04))
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@449@04))
            ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@450@04)))
          (< i2@450@04 V@15@04)
          (<= 0 i2@450@04)
          (< i1@449@04 V@15@04)
          (<= 0 i1@449@04))))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@450@04))
    :qid |prog.l<no position>-aux|))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@449@04))
  :qid |prog.l<no position>-aux|)))
(assert (forall ((i1@449@04 Int)) (!
  (forall ((i2@450@04 Int)) (!
    (implies
      (and
        (and
          (and
            (and
              (=
                ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@449@04))
                ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@450@04)))
              (< i2@450@04 V@15@04))
            (<= 0 i2@450@04))
          (< i1@449@04 V@15@04))
        (<= 0 i1@449@04))
      (= i1@449@04 i2@450@04))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@450@04))
    :qid |prog.l<no position>|))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@449@04))
  :qid |prog.l<no position>|)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04)))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04)))))))))))))
(assert (forall ((i1@451@04 Int) (j@452@04 Int)) (!
  (and
    (< i1@451@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@451@04)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@451@04))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@451@04))
        (as None<option<array>>  option<array>)))
    (<
      j@452@04
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@451@04))))))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@451@04))) j@452@04))
  :qid |int-aux|)))
(assert ($Perm.isReadVar $k@444@04 $Perm.Write))
(assert (= $t@442@04 ($Snap.combine ($Snap.first $t@442@04) ($Snap.second $t@442@04))))
(assert (= ($Snap.first $t@442@04) $Snap.unit))
(assert (=
  ($Snap.second $t@442@04)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@442@04))
    ($Snap.second ($Snap.second $t@442@04)))))
(assert (= ($Snap.first ($Snap.second $t@442@04)) $Snap.unit))
(assert (<= 0 v1@441@04))
(assert (=
  ($Snap.second ($Snap.second $t@442@04))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second $t@442@04)))
    ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))
(assert (= ($Snap.first ($Snap.second ($Snap.second $t@442@04))) $Snap.unit))
(assert (< v1@441@04 V@15@04))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second $t@442@04)))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@442@04))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04)))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@442@04))))
  $Snap.unit))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04)))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04)))))
  $Snap.unit))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04)))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04)))))))))
(assert (forall ((i1@443@04 Int)) (!
  (< i1@443@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@443@04))
  :qid |option$array$-aux|)))
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
(set-option :timeout 10)
(check-sat)
; unknown
; Loop head block: Follow loop-internal edges
; [eval] v1 != s
(push) ; 15
(assert (not (= v1@441@04 s@12@04)))
(check-sat)
; unknown
(pop) ; 15
; 0.04s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               10121342
;  :arith-add-rows          2262936
;  :arith-assert-diseq      43975
;  :arith-assert-lower      1801806
;  :arith-assert-upper      1596916
;  :arith-bound-prop        56720
;  :arith-conflicts         1465
;  :arith-eq-adapter        803088
;  :arith-fixed-eqs         1794034
;  :arith-offset-eqs        1124923
;  :arith-pivots            342143
;  :conflicts               3838
;  :datatype-accessor-ax    433
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               352336
;  :del-clause              29379309
;  :final-checks            5
;  :max-generation          14
;  :max-memory              272.27
;  :memory                  255.94
;  :minimized-lits          460
;  :mk-bool-var             25719975
;  :mk-clause               29381355
;  :num-allocs              62364467
;  :num-checks              527
;  :propagations            8361378
;  :quant-instantiations    11046544
;  :restarts                8
;  :rlimit-count            241423643
;  :time                    0.04)
(push) ; 15
(assert (not (not (= v1@441@04 s@12@04))))
(check-sat)
; unknown
(pop) ; 15
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               10121592
;  :arith-add-rows          2263079
;  :arith-assert-diseq      43981
;  :arith-assert-lower      1801873
;  :arith-assert-upper      1596966
;  :arith-bound-prop        56720
;  :arith-conflicts         1465
;  :arith-eq-adapter        803134
;  :arith-fixed-eqs         1794088
;  :arith-offset-eqs        1124934
;  :arith-pivots            342153
;  :conflicts               3838
;  :datatype-accessor-ax    433
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               352362
;  :del-clause              29380866
;  :final-checks            5
;  :max-generation          14
;  :max-memory              272.27
;  :memory                  254.52
;  :minimized-lits          460
;  :mk-bool-var             25721362
;  :mk-clause               29382912
;  :num-allocs              62369983
;  :num-checks              528
;  :propagations            8361649
;  :quant-instantiations    11047032
;  :restarts                8
;  :rlimit-count            241450275
;  :time                    0.01)
; [then-branch: 269 | v1@441@04 != s@12@04 | live]
; [else-branch: 269 | v1@441@04 == s@12@04 | live]
(push) ; 15
; [then-branch: 269 | v1@441@04 != s@12@04]
(assert (not (= v1@441@04 s@12@04)))
; [exec]
; u := aloc(opt_get1(P), v1).int
; [eval] aloc(opt_get1(P), v1)
; [eval] opt_get1(P)
(push) ; 16
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 16
; Joined path conditions
(push) ; 16
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 17
(assert (not (< v1@441@04 (alen<Int> (opt_get1 $Snap.unit P@14@04)))))
(check-sat)
; unsat
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               10121593
;  :arith-add-rows          2263080
;  :arith-assert-diseq      43983
;  :arith-assert-lower      1801873
;  :arith-assert-upper      1596966
;  :arith-bound-prop        56720
;  :arith-conflicts         1465
;  :arith-eq-adapter        803135
;  :arith-fixed-eqs         1794088
;  :arith-offset-eqs        1124934
;  :arith-pivots            342153
;  :conflicts               3838
;  :datatype-accessor-ax    433
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               352362
;  :del-clause              29380866
;  :final-checks            5
;  :max-generation          14
;  :max-memory              272.27
;  :memory                  254.52
;  :minimized-lits          460
;  :mk-bool-var             25721366
;  :mk-clause               29382916
;  :num-allocs              62370078
;  :num-checks              529
;  :propagations            8361649
;  :quant-instantiations    11047032
;  :restarts                8
;  :rlimit-count            241450372)
(assert (< v1@441@04 (alen<Int> (opt_get1 $Snap.unit P@14@04))))
(pop) ; 16
; Joined path conditions
(assert (< v1@441@04 (alen<Int> (opt_get1 $Snap.unit P@14@04))))
(declare-const sm@494@04 $FVF<Int>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@457@04 r) V@15@04) (<= 0 (inv@457@04 r)))
    (=
      ($FVF.lookup_int (as sm@494@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04)))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@494@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04)))))))))))))) r))
  :qid |qp.fvfValDef352|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@454@04 r) V@15@04) (<= 0 (inv@454@04 r)))
        (< (inv@453@04 r) V@15@04))
      (<= 0 (inv@453@04 r)))
    (=
      ($FVF.lookup_int (as sm@494@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@494@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))))))) r))
  :qid |qp.fvfValDef353|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04)))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@494@04  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef354|)))
(declare-const pm@495@04 $FPM)
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_int (as pm@495@04  $FPM) r)
    (+
      (ite
        (and (< (inv@457@04 r) V@15@04) (<= 0 (inv@457@04 r)))
        $Perm.Write
        $Perm.No)
      (ite
        (and
          (and
            (and (< (inv@454@04 r) V@15@04) (<= 0 (inv@454@04 r)))
            (< (inv@453@04 r) V@15@04))
          (<= 0 (inv@453@04 r)))
        $Perm.Write
        $Perm.No)))
  :pattern (($FVF.perm_int (as pm@495@04  $FPM) r))
  :qid |qp.resPrmSumDef355|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int (as sm@494@04  $FVF<Int>) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04)))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))))))) r) r))
  :pattern (($FVF.perm_int (as pm@495@04  $FPM) r))
  :qid |qp.resTrgDef356|)))
(assert ($FVF.loc_int ($FVF.lookup_int (as sm@494@04  $FVF<Int>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit P@14@04) v1@441@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit P@14@04) v1@441@04)))
(push) ; 16
(assert (not (<
  $Perm.No
  ($FVF.perm_int (as pm@495@04  $FPM) (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) v1@441@04)))))
(check-sat)
; unsat
(pop) ; 16
; 0.09s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               10124542
;  :arith-add-rows          2265935
;  :arith-assert-diseq      44045
;  :arith-assert-lower      1802358
;  :arith-assert-upper      1597266
;  :arith-bound-prop        56800
;  :arith-conflicts         1467
;  :arith-eq-adapter        803394
;  :arith-fixed-eqs         1794365
;  :arith-offset-eqs        1124998
;  :arith-pivots            342322
;  :conflicts               3848
;  :datatype-accessor-ax    433
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               353269
;  :del-clause              29412879
;  :final-checks            5
;  :max-generation          14
;  :max-memory              272.27
;  :memory                  253.96
;  :minimized-lits          460
;  :mk-bool-var             25746545
;  :mk-clause               29415441
;  :num-allocs              62431061
;  :num-checks              530
;  :propagations            8365263
;  :quant-instantiations    11052716
;  :restarts                8
;  :rlimit-count            241687625
;  :time                    0.09)
(declare-const u@496@04 Int)
(assert (=
  u@496@04
  ($FVF.lookup_int (as sm@494@04  $FVF<Int>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit P@14@04) v1@441@04))))
; [exec]
; aloc(opt_get1(aloc(opt_get1(G), u).option$array$), v1).int := aloc(opt_get1(aloc(opt_get1(G), u).option$array$), v1).int - bottleneckPathFlow
; [eval] aloc(opt_get1(aloc(opt_get1(G), u).option$array$), v1)
; [eval] opt_get1(aloc(opt_get1(G), u).option$array$)
; [eval] aloc(opt_get1(G), u)
; [eval] opt_get1(G)
(push) ; 16
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 16
; Joined path conditions
(push) ; 16
; [eval] 0 <= i1
(push) ; 17
(assert (not (<= 0 u@496@04)))
(check-sat)
; unsat
(pop) ; 17
; 0.28s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               10133792
;  :arith-add-rows          2278120
;  :arith-assert-diseq      44105
;  :arith-assert-lower      1803965
;  :arith-assert-upper      1598398
;  :arith-bound-prop        57252
;  :arith-conflicts         1472
;  :arith-eq-adapter        804792
;  :arith-fixed-eqs         1795394
;  :arith-offset-eqs        1126139
;  :arith-pivots            343796
;  :conflicts               3874
;  :datatype-accessor-ax    433
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               354342
;  :del-clause              29472343
;  :final-checks            5
;  :max-generation          14
;  :max-memory              272.27
;  :memory                  253.99
;  :minimized-lits          461
;  :mk-bool-var             25808843
;  :mk-clause               29474905
;  :num-allocs              62618855
;  :num-checks              531
;  :propagations            8375938
;  :quant-instantiations    11068959
;  :restarts                8
;  :rlimit-count            242354373
;  :time                    0.28)
(assert (<= 0 u@496@04))
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 17
(assert (not (< u@496@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))))
(check-sat)
; unsat
(pop) ; 17
; 01m:16s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               15862738
;  :arith-add-rows          3435998
;  :arith-assert-diseq      81988
;  :arith-assert-lower      3006134
;  :arith-assert-upper      2635310
;  :arith-bound-prop        75381
;  :arith-conflicts         1938
;  :arith-eq-adapter        1145090
;  :arith-fixed-eqs         2851925
;  :arith-offset-eqs        1731454
;  :arith-pivots            484186
;  :conflicts               4626
;  :datatype-accessor-ax    461
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               596458
;  :del-clause              40778725
;  :final-checks            5
;  :max-generation          14
;  :max-memory              290.14
;  :memory                  276.43
;  :minimized-lits          605
;  :mk-bool-var             35323646
;  :mk-clause               40781287
;  :num-allocs              85478042
;  :num-checks              532
;  :propagations            11762919
;  :quant-instantiations    14853587
;  :restarts                11
;  :rlimit-count            329136872
;  :time                    76.29)
(assert (< u@496@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(pop) ; 16
; Joined path conditions
(assert (and (<= 0 u@496@04) (< u@496@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) u@496@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) u@496@04)))
(push) ; 16
(assert (not (ite
  (and
    (<
      (inv@445@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) u@496@04))
      V@15@04)
    (<=
      0
      (inv@445@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) u@496@04))))
  (< $Perm.No $k@444@04)
  false)))
(check-sat)
; unsat
(pop) ; 16
; 0.14s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               15862874
;  :arith-add-rows          3436077
;  :arith-assert-diseq      81988
;  :arith-assert-lower      3006159
;  :arith-assert-upper      2635330
;  :arith-bound-prop        75396
;  :arith-conflicts         1939
;  :arith-eq-adapter        1145109
;  :arith-fixed-eqs         2851943
;  :arith-offset-eqs        1731455
;  :arith-pivots            484206
;  :conflicts               4627
;  :datatype-accessor-ax    461
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               596458
;  :del-clause              40778725
;  :final-checks            5
;  :max-generation          14
;  :max-memory              290.14
;  :memory                  276.47
;  :minimized-lits          605
;  :mk-bool-var             35324301
;  :mk-clause               40781857
;  :num-allocs              85480806
;  :num-checks              533
;  :propagations            11763008
;  :quant-instantiations    14853823
;  :restarts                11
;  :rlimit-count            329147259
;  :time                    0.14)
(push) ; 16
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 17
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) u@496@04))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               15862875
;  :arith-add-rows          3436077
;  :arith-assert-diseq      81988
;  :arith-assert-lower      3006159
;  :arith-assert-upper      2635330
;  :arith-bound-prop        75396
;  :arith-conflicts         1939
;  :arith-eq-adapter        1145109
;  :arith-fixed-eqs         2851943
;  :arith-offset-eqs        1731455
;  :arith-pivots            484206
;  :conflicts               4628
;  :datatype-accessor-ax    461
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               596458
;  :del-clause              40778725
;  :final-checks            5
;  :max-generation          14
;  :max-memory              290.14
;  :memory                  276.47
;  :minimized-lits          605
;  :mk-bool-var             35324302
;  :mk-clause               40781857
;  :num-allocs              85480902
;  :num-checks              534
;  :propagations            11763008
;  :quant-instantiations    14853823
;  :restarts                11
;  :rlimit-count            329147356)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) u@496@04))
    (as None<option<array>>  option<array>))))
(pop) ; 16
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) u@496@04))
    (as None<option<array>>  option<array>))))
(push) ; 16
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 17
(assert (not (<
  v1@441@04
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) u@496@04)))))))
(check-sat)
; unsat
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               15862883
;  :arith-add-rows          3436178
;  :arith-assert-diseq      81988
;  :arith-assert-lower      3006161
;  :arith-assert-upper      2635332
;  :arith-bound-prop        75396
;  :arith-conflicts         1940
;  :arith-eq-adapter        1145110
;  :arith-fixed-eqs         2851944
;  :arith-offset-eqs        1731455
;  :arith-pivots            484211
;  :conflicts               4629
;  :datatype-accessor-ax    461
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               596458
;  :del-clause              40778726
;  :final-checks            5
;  :max-generation          14
;  :max-memory              290.14
;  :memory                  276.47
;  :minimized-lits          605
;  :mk-bool-var             35324314
;  :mk-clause               40781858
;  :num-allocs              85481105
;  :num-checks              535
;  :propagations            11763008
;  :quant-instantiations    14853830
;  :restarts                11
;  :rlimit-count            329149349)
(assert (<
  v1@441@04
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) u@496@04))))))
(pop) ; 16
; Joined path conditions
(assert (<
  v1@441@04
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) u@496@04))))))
; [eval] aloc(opt_get1(aloc(opt_get1(G), u).option$array$), v1).int - bottleneckPathFlow
; [eval] aloc(opt_get1(aloc(opt_get1(G), u).option$array$), v1)
; [eval] opt_get1(aloc(opt_get1(G), u).option$array$)
; [eval] aloc(opt_get1(G), u)
; [eval] opt_get1(G)
(push) ; 16
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 16
; Joined path conditions
(push) ; 16
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(pop) ; 16
; Joined path conditions
(push) ; 16
(assert (not (ite
  (and
    (<
      (inv@445@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) u@496@04))
      V@15@04)
    (<=
      0
      (inv@445@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) u@496@04))))
  (< $Perm.No $k@444@04)
  false)))
(check-sat)
; unsat
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               15862893
;  :arith-add-rows          3436182
;  :arith-assert-diseq      81988
;  :arith-assert-lower      3006164
;  :arith-assert-upper      2635334
;  :arith-bound-prop        75396
;  :arith-conflicts         1941
;  :arith-eq-adapter        1145111
;  :arith-fixed-eqs         2851945
;  :arith-offset-eqs        1731457
;  :arith-pivots            484213
;  :conflicts               4630
;  :datatype-accessor-ax    461
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               596458
;  :del-clause              40778726
;  :final-checks            5
;  :max-generation          14
;  :max-memory              290.14
;  :memory                  273.47
;  :minimized-lits          605
;  :mk-bool-var             35324325
;  :mk-clause               40781858
;  :num-allocs              85481323
;  :num-checks              536
;  :propagations            11763008
;  :quant-instantiations    14853837
;  :restarts                11
;  :rlimit-count            329149828)
(push) ; 16
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 16
; Joined path conditions
(push) ; 16
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(pop) ; 16
; Joined path conditions
(declare-const sm@497@04 $FVF<Int>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@457@04 r) V@15@04) (<= 0 (inv@457@04 r)))
    (=
      ($FVF.lookup_int (as sm@497@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04)))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@497@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04)))))))))))))) r))
  :qid |qp.fvfValDef357|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@454@04 r) V@15@04) (<= 0 (inv@454@04 r)))
        (< (inv@453@04 r) V@15@04))
      (<= 0 (inv@453@04 r)))
    (=
      ($FVF.lookup_int (as sm@497@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@497@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))))))) r))
  :qid |qp.fvfValDef358|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04)))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@497@04  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef359|)))
(declare-const pm@498@04 $FPM)
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_int (as pm@498@04  $FPM) r)
    (+
      (ite
        (and (< (inv@457@04 r) V@15@04) (<= 0 (inv@457@04 r)))
        $Perm.Write
        $Perm.No)
      (ite
        (and
          (and
            (and (< (inv@454@04 r) V@15@04) (<= 0 (inv@454@04 r)))
            (< (inv@453@04 r) V@15@04))
          (<= 0 (inv@453@04 r)))
        $Perm.Write
        $Perm.No)))
  :pattern (($FVF.perm_int (as pm@498@04  $FPM) r))
  :qid |qp.resPrmSumDef360|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int (as sm@497@04  $FVF<Int>) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04)))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))))))) r) r))
  :pattern (($FVF.perm_int (as pm@498@04  $FPM) r))
  :qid |qp.resTrgDef361|)))
(assert ($FVF.loc_int ($FVF.lookup_int (as sm@497@04  $FVF<Int>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) u@496@04))) v1@441@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) u@496@04))) v1@441@04)))
(push) ; 16
(assert (not (<
  $Perm.No
  ($FVF.perm_int (as pm@498@04  $FPM) (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) u@496@04))) v1@441@04)))))
(check-sat)
; unsat
(pop) ; 16
; 0.05s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               15864515
;  :arith-add-rows          3437773
;  :arith-assert-diseq      82031
;  :arith-assert-lower      3006449
;  :arith-assert-upper      2635505
;  :arith-bound-prop        75509
;  :arith-conflicts         1948
;  :arith-eq-adapter        1145259
;  :arith-fixed-eqs         2852073
;  :arith-offset-eqs        1731606
;  :arith-pivots            484309
;  :conflicts               4660
;  :datatype-accessor-ax    461
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               596973
;  :del-clause              40793285
;  :final-checks            5
;  :max-generation          14
;  :max-memory              290.14
;  :memory                  271.64
;  :minimized-lits          605
;  :mk-bool-var             35335600
;  :mk-clause               40796445
;  :num-allocs              85512995
;  :num-checks              537
;  :propagations            11765062
;  :quant-instantiations    14856122
;  :restarts                11
;  :rlimit-count            329293806
;  :time                    0.05)
(declare-const sm@499@04 $FVF<Int>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@457@04 r) V@15@04) (<= 0 (inv@457@04 r)))
    (=
      ($FVF.lookup_int (as sm@499@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04)))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@499@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04)))))))))))))) r))
  :qid |qp.fvfValDef362|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@454@04 r) V@15@04) (<= 0 (inv@454@04 r)))
        (< (inv@453@04 r) V@15@04))
      (<= 0 (inv@453@04 r)))
    (=
      ($FVF.lookup_int (as sm@499@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@499@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))))))) r))
  :qid |qp.fvfValDef363|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04)))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@499@04  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef364|)))
(assert ($FVF.loc_int ($FVF.lookup_int (as sm@499@04  $FVF<Int>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) u@496@04))) v1@441@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) u@496@04))) v1@441@04)))
; Precomputing data for removing quantified permissions
(define-fun pTaken@500@04 ((r $Ref)) $Perm
  (ite
    (=
      r
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) u@496@04))) v1@441@04))
    ($Perm.min
      (ite
        (and (< (inv@457@04 r) V@15@04) (<= 0 (inv@457@04 r)))
        $Perm.Write
        $Perm.No)
      $Perm.Write)
    $Perm.No))
(define-fun pTaken@501@04 ((r $Ref)) $Perm
  (ite
    (=
      r
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) u@496@04))) v1@441@04))
    ($Perm.min
      (ite
        (and
          (and
            (and (< (inv@454@04 r) V@15@04) (<= 0 (inv@454@04 r)))
            (< (inv@453@04 r) V@15@04))
          (<= 0 (inv@453@04 r)))
        $Perm.Write
        $Perm.No)
      (- $Perm.Write (pTaken@500@04 r)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 500)
(push) ; 16
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and (< (inv@457@04 r) V@15@04) (<= 0 (inv@457@04 r)))
        $Perm.Write
        $Perm.No)
      (pTaken@500@04 r))
    $Perm.No)
  
  ))))
(check-sat)
; unknown
(pop) ; 16
; 0.53s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               15884136
;  :arith-add-rows          3450004
;  :arith-assert-diseq      82225
;  :arith-assert-lower      3009740
;  :arith-assert-upper      2637923
;  :arith-bound-prop        76167
;  :arith-conflicts         1958
;  :arith-eq-adapter        1147820
;  :arith-fixed-eqs         2854388
;  :arith-offset-eqs        1733763
;  :arith-pivots            486451
;  :conflicts               4685
;  :datatype-accessor-ax    465
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               600370
;  :del-clause              40936983
;  :final-checks            5
;  :max-generation          14
;  :max-memory              290.14
;  :memory                  265.65
;  :minimized-lits          606
;  :mk-bool-var             35453830
;  :mk-clause               40939898
;  :num-allocs              85788540
;  :num-checks              539
;  :propagations            11793914
;  :quant-instantiations    14892878
;  :restarts                11
;  :rlimit-count            330501693
;  :time                    0.53)
; Intermediate check if already taken enough permissions
(push) ; 16
(assert (not (forall ((r $Ref)) (!
  (implies
    (=
      r
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) u@496@04))) v1@441@04))
    (= (- $Perm.Write (pTaken@500@04 r)) $Perm.No))
  
  ))))
(check-sat)
; unknown
(pop) ; 16
; 0.50s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               15902589
;  :arith-add-rows          3460703
;  :arith-assert-diseq      82430
;  :arith-assert-lower      3012868
;  :arith-assert-upper      2640198
;  :arith-bound-prop        76810
;  :arith-conflicts         1966
;  :arith-eq-adapter        1150244
;  :arith-fixed-eqs         2856558
;  :arith-offset-eqs        1735511
;  :arith-pivots            488473
;  :conflicts               4703
;  :datatype-accessor-ax    469
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               603414
;  :del-clause              41069712
;  :final-checks            5
;  :max-generation          14
;  :max-memory              290.14
;  :memory                  266.26
;  :minimized-lits          606
;  :mk-bool-var             35564498
;  :mk-clause               41072627
;  :num-allocs              86066853
;  :num-checks              540
;  :propagations            11821634
;  :quant-instantiations    14927749
;  :restarts                11
;  :rlimit-count            331761701
;  :time                    0.50)
; Chunk depleted?
(push) ; 16
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and
          (and
            (and (< (inv@454@04 r) V@15@04) (<= 0 (inv@454@04 r)))
            (< (inv@453@04 r) V@15@04))
          (<= 0 (inv@453@04 r)))
        $Perm.Write
        $Perm.No)
      (pTaken@501@04 r))
    $Perm.No)
  
  ))))
(check-sat)
; unknown
(pop) ; 16
; 0.52s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               15921014
;  :arith-add-rows          3471370
;  :arith-assert-diseq      82604
;  :arith-assert-lower      3015878
;  :arith-assert-upper      2642444
;  :arith-bound-prop        77448
;  :arith-conflicts         1976
;  :arith-eq-adapter        1152663
;  :arith-fixed-eqs         2858701
;  :arith-offset-eqs        1737223
;  :arith-pivots            490494
;  :conflicts               4727
;  :datatype-accessor-ax    469
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               606387
;  :del-clause              41204878
;  :final-checks            5
;  :max-generation          14
;  :max-memory              290.14
;  :memory                  266.28
;  :minimized-lits          607
;  :mk-bool-var             35678631
;  :mk-clause               41207793
;  :num-allocs              86342979
;  :num-checks              541
;  :propagations            11850762
;  :quant-instantiations    14964321
;  :restarts                11
;  :rlimit-count            333006859
;  :time                    0.52)
; Intermediate check if already taken enough permissions
(push) ; 16
(assert (not (forall ((r $Ref)) (!
  (implies
    (=
      r
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) u@496@04))) v1@441@04))
    (= (- (- $Perm.Write (pTaken@500@04 r)) (pTaken@501@04 r)) $Perm.No))
  
  ))))
(check-sat)
; unsat
(pop) ; 16
; 0.10s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               15922625
;  :arith-add-rows          3473252
;  :arith-assert-diseq      82665
;  :arith-assert-lower      3016182
;  :arith-assert-upper      2642644
;  :arith-bound-prop        77582
;  :arith-conflicts         1982
;  :arith-eq-adapter        1152861
;  :arith-fixed-eqs         2858840
;  :arith-offset-eqs        1737364
;  :arith-pivots            490567
;  :conflicts               4758
;  :datatype-accessor-ax    469
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               606904
;  :del-clause              41219976
;  :final-checks            5
;  :max-generation          14
;  :max-memory              290.14
;  :memory                  266.24
;  :minimized-lits          610
;  :mk-bool-var             35690824
;  :mk-clause               41222891
;  :num-allocs              86377521
;  :num-checks              542
;  :propagations            11852874
;  :quant-instantiations    14966586
;  :restarts                11
;  :rlimit-count            333153249
;  :time                    0.10)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@502@04 $FVF<Int>)
; Definitional axioms for singleton-FVF's value
(assert (=
  ($FVF.lookup_int (as sm@502@04  $FVF<Int>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) u@496@04))) v1@441@04))
  (-
    ($FVF.lookup_int (as sm@497@04  $FVF<Int>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) u@496@04))) v1@441@04))
    bottleneckPathFlow@352@04)))
(assert ($FVF.loc_int ($FVF.lookup_int (as sm@502@04  $FVF<Int>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) u@496@04))) v1@441@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) u@496@04))) v1@441@04)))
; [exec]
; aloc(opt_get1(aloc(opt_get1(G), v1).option$array$), u).int := aloc(opt_get1(aloc(opt_get1(G), v1).option$array$), u).int + bottleneckPathFlow
; [eval] aloc(opt_get1(aloc(opt_get1(G), v1).option$array$), u)
; [eval] opt_get1(aloc(opt_get1(G), v1).option$array$)
; [eval] aloc(opt_get1(G), v1)
; [eval] opt_get1(G)
(push) ; 16
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 16
; Joined path conditions
(push) ; 16
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 17
(assert (not (< v1@441@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))))
(check-sat)
; unsat
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               15922626
;  :arith-add-rows          3473252
;  :arith-assert-diseq      82665
;  :arith-assert-lower      3016183
;  :arith-assert-upper      2642645
;  :arith-bound-prop        77582
;  :arith-conflicts         1982
;  :arith-eq-adapter        1152862
;  :arith-fixed-eqs         2858840
;  :arith-offset-eqs        1737364
;  :arith-pivots            490568
;  :conflicts               4758
;  :datatype-accessor-ax    469
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               606904
;  :del-clause              41219976
;  :final-checks            5
;  :max-generation          14
;  :max-memory              290.14
;  :memory                  266.24
;  :minimized-lits          610
;  :mk-bool-var             35690828
;  :mk-clause               41222894
;  :num-allocs              86377659
;  :num-checks              543
;  :propagations            11852876
;  :quant-instantiations    14966586
;  :restarts                11
;  :rlimit-count            333153488)
(assert (< v1@441@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(pop) ; 16
; Joined path conditions
(assert (< v1@441@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) v1@441@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) v1@441@04)))
(push) ; 16
(assert (not (ite
  (and
    (<
      (inv@445@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) v1@441@04))
      V@15@04)
    (<=
      0
      (inv@445@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) v1@441@04))))
  (< $Perm.No $k@444@04)
  false)))
(check-sat)
; unsat
(pop) ; 16
; 0.05s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               15923421
;  :arith-add-rows          3474326
;  :arith-assert-diseq      82675
;  :arith-assert-lower      3016298
;  :arith-assert-upper      2642717
;  :arith-bound-prop        77617
;  :arith-conflicts         1984
;  :arith-eq-adapter        1152940
;  :arith-fixed-eqs         2858921
;  :arith-offset-eqs        1737456
;  :arith-pivots            490603
;  :conflicts               4776
;  :datatype-accessor-ax    469
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               607198
;  :del-clause              41229394
;  :final-checks            5
;  :max-generation          14
;  :max-memory              290.14
;  :memory                  266.08
;  :minimized-lits          610
;  :mk-bool-var             35697637
;  :mk-clause               41232604
;  :num-allocs              86399204
;  :num-checks              544
;  :propagations            11854292
;  :quant-instantiations    14968291
;  :restarts                11
;  :rlimit-count            333257397
;  :time                    0.04)
(push) ; 16
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 17
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) v1@441@04))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               15923421
;  :arith-add-rows          3474326
;  :arith-assert-diseq      82675
;  :arith-assert-lower      3016298
;  :arith-assert-upper      2642717
;  :arith-bound-prop        77617
;  :arith-conflicts         1984
;  :arith-eq-adapter        1152940
;  :arith-fixed-eqs         2858921
;  :arith-offset-eqs        1737456
;  :arith-pivots            490603
;  :conflicts               4777
;  :datatype-accessor-ax    469
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               607198
;  :del-clause              41229394
;  :final-checks            5
;  :max-generation          14
;  :max-memory              290.14
;  :memory                  266.08
;  :minimized-lits          610
;  :mk-bool-var             35697637
;  :mk-clause               41232604
;  :num-allocs              86399294
;  :num-checks              545
;  :propagations            11854292
;  :quant-instantiations    14968291
;  :restarts                11
;  :rlimit-count            333257492)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) v1@441@04))
    (as None<option<array>>  option<array>))))
(pop) ; 16
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) v1@441@04))
    (as None<option<array>>  option<array>))))
(push) ; 16
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 17
(assert (not (<
  u@496@04
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) v1@441@04)))))))
(check-sat)
; unsat
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               15923427
;  :arith-add-rows          3474435
;  :arith-assert-diseq      82675
;  :arith-assert-lower      3016301
;  :arith-assert-upper      2642718
;  :arith-bound-prop        77617
;  :arith-conflicts         1985
;  :arith-eq-adapter        1152941
;  :arith-fixed-eqs         2858922
;  :arith-offset-eqs        1737456
;  :arith-pivots            490607
;  :conflicts               4778
;  :datatype-accessor-ax    469
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               607198
;  :del-clause              41229398
;  :final-checks            5
;  :max-generation          14
;  :max-memory              290.14
;  :memory                  265.99
;  :minimized-lits          610
;  :mk-bool-var             35697648
;  :mk-clause               41232608
;  :num-allocs              86399506
;  :num-checks              546
;  :propagations            11854294
;  :quant-instantiations    14968298
;  :restarts                11
;  :rlimit-count            333260312
;  :time                    0.00)
(assert (<
  u@496@04
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) v1@441@04))))))
(pop) ; 16
; Joined path conditions
(assert (<
  u@496@04
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) v1@441@04))))))
; [eval] aloc(opt_get1(aloc(opt_get1(G), v1).option$array$), u).int + bottleneckPathFlow
; [eval] aloc(opt_get1(aloc(opt_get1(G), v1).option$array$), u)
; [eval] opt_get1(aloc(opt_get1(G), v1).option$array$)
; [eval] aloc(opt_get1(G), v1)
; [eval] opt_get1(G)
(push) ; 16
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 16
; Joined path conditions
(push) ; 16
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(pop) ; 16
; Joined path conditions
(push) ; 16
(assert (not (ite
  (and
    (<
      (inv@445@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) v1@441@04))
      V@15@04)
    (<=
      0
      (inv@445@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) v1@441@04))))
  (< $Perm.No $k@444@04)
  false)))
(check-sat)
; unsat
(pop) ; 16
; 0.04s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               15924110
;  :arith-add-rows          3475465
;  :arith-assert-diseq      82685
;  :arith-assert-lower      3016397
;  :arith-assert-upper      2642775
;  :arith-bound-prop        77653
;  :arith-conflicts         1987
;  :arith-eq-adapter        1153000
;  :arith-fixed-eqs         2858987
;  :arith-offset-eqs        1737548
;  :arith-pivots            490626
;  :conflicts               4796
;  :datatype-accessor-ax    469
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               607492
;  :del-clause              41238812
;  :final-checks            5
;  :max-generation          14
;  :max-memory              290.14
;  :memory                  265.94
;  :minimized-lits          610
;  :mk-bool-var             35704001
;  :mk-clause               41242027
;  :num-allocs              86418797
;  :num-checks              547
;  :propagations            11855672
;  :quant-instantiations    14969791
;  :restarts                11
;  :rlimit-count            333354004
;  :time                    0.04)
(push) ; 16
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 16
; Joined path conditions
(push) ; 16
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(pop) ; 16
; Joined path conditions
(declare-const sm@503@04 $FVF<Int>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (=
      r
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) u@496@04))) v1@441@04))
    (=
      ($FVF.lookup_int (as sm@503@04  $FVF<Int>) r)
      ($FVF.lookup_int (as sm@502@04  $FVF<Int>) r)))
  :pattern (($FVF.lookup_int (as sm@503@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int (as sm@502@04  $FVF<Int>) r))
  :qid |qp.fvfValDef365|)))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (ite
          (and
            (and
              (and (< (inv@454@04 r) V@15@04) (<= 0 (inv@454@04 r)))
              (< (inv@453@04 r) V@15@04))
            (<= 0 (inv@453@04 r)))
          $Perm.Write
          $Perm.No)
        (pTaken@501@04 r)))
    (=
      ($FVF.lookup_int (as sm@503@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@503@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))))))) r))
  :qid |qp.fvfValDef366|)))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (ite
          (and (< (inv@457@04 r) V@15@04) (<= 0 (inv@457@04 r)))
          $Perm.Write
          $Perm.No)
        (pTaken@500@04 r)))
    (=
      ($FVF.lookup_int (as sm@503@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04)))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@503@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04)))))))))))))) r))
  :qid |qp.fvfValDef367|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int (as sm@502@04  $FVF<Int>) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04)))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@503@04  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef368|)))
(declare-const pm@504@04 $FPM)
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_int (as pm@504@04  $FPM) r)
    (+
      (+
        (ite
          (=
            r
            (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) u@496@04))) v1@441@04))
          $Perm.Write
          $Perm.No)
        (-
          (ite
            (and
              (and
                (and (< (inv@454@04 r) V@15@04) (<= 0 (inv@454@04 r)))
                (< (inv@453@04 r) V@15@04))
              (<= 0 (inv@453@04 r)))
            $Perm.Write
            $Perm.No)
          (pTaken@501@04 r)))
      (-
        (ite
          (and (< (inv@457@04 r) V@15@04) (<= 0 (inv@457@04 r)))
          $Perm.Write
          $Perm.No)
        (pTaken@500@04 r))))
  :pattern (($FVF.perm_int (as pm@504@04  $FPM) r))
  :qid |qp.resPrmSumDef369|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int (as sm@503@04  $FVF<Int>) r) r)
    ($FVF.loc_int ($FVF.lookup_int (as sm@502@04  $FVF<Int>) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04)))))))))))))) r) r))
  :pattern (($FVF.perm_int (as pm@504@04  $FPM) r))
  :qid |qp.resTrgDef370|)))
(assert ($FVF.loc_int ($FVF.lookup_int (as sm@503@04  $FVF<Int>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) v1@441@04))) u@496@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) v1@441@04))) u@496@04)))
(push) ; 16
(assert (not (<
  $Perm.No
  ($FVF.perm_int (as pm@504@04  $FPM) (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) v1@441@04))) u@496@04)))))
(check-sat)
; unsat
(pop) ; 16
; 0.11s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               15927657
;  :arith-add-rows          3478291
;  :arith-assert-diseq      82822
;  :arith-assert-lower      3017161
;  :arith-assert-upper      2643169
;  :arith-bound-prop        77847
;  :arith-conflicts         1996
;  :arith-eq-adapter        1153394
;  :arith-fixed-eqs         2859287
;  :arith-offset-eqs        1737746
;  :arith-pivots            490814
;  :conflicts               4840
;  :datatype-accessor-ax    469
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               608419
;  :del-clause              41266371
;  :final-checks            5
;  :max-generation          14
;  :max-memory              290.14
;  :memory                  266.01
;  :minimized-lits          615
;  :mk-bool-var             35724852
;  :mk-clause               41269671
;  :num-allocs              86470219
;  :num-checks              548
;  :propagations            11860188
;  :quant-instantiations    14974285
;  :restarts                11
;  :rlimit-count            333579887
;  :time                    0.11)
(declare-const sm@505@04 $FVF<Int>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (=
      r
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) u@496@04))) v1@441@04))
    (=
      ($FVF.lookup_int (as sm@505@04  $FVF<Int>) r)
      ($FVF.lookup_int (as sm@502@04  $FVF<Int>) r)))
  :pattern (($FVF.lookup_int (as sm@505@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int (as sm@502@04  $FVF<Int>) r))
  :qid |qp.fvfValDef371|)))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (ite
          (and
            (and
              (and (< (inv@454@04 r) V@15@04) (<= 0 (inv@454@04 r)))
              (< (inv@453@04 r) V@15@04))
            (<= 0 (inv@453@04 r)))
          $Perm.Write
          $Perm.No)
        (pTaken@501@04 r)))
    (=
      ($FVF.lookup_int (as sm@505@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@505@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))))))) r))
  :qid |qp.fvfValDef372|)))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (ite
          (and (< (inv@457@04 r) V@15@04) (<= 0 (inv@457@04 r)))
          $Perm.Write
          $Perm.No)
        (pTaken@500@04 r)))
    (=
      ($FVF.lookup_int (as sm@505@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04)))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@505@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04)))))))))))))) r))
  :qid |qp.fvfValDef373|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int (as sm@502@04  $FVF<Int>) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04)))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@505@04  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef374|)))
(assert ($FVF.loc_int ($FVF.lookup_int (as sm@505@04  $FVF<Int>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) v1@441@04))) u@496@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) v1@441@04))) u@496@04)))
; Precomputing data for removing quantified permissions
(define-fun pTaken@506@04 ((r $Ref)) $Perm
  (ite
    (=
      r
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) v1@441@04))) u@496@04))
    ($Perm.min
      (ite
        (=
          r
          (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) u@496@04))) v1@441@04))
        $Perm.Write
        $Perm.No)
      $Perm.Write)
    $Perm.No))
(define-fun pTaken@507@04 ((r $Ref)) $Perm
  (ite
    (=
      r
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) v1@441@04))) u@496@04))
    ($Perm.min
      (-
        (ite
          (and
            (and
              (and (< (inv@454@04 r) V@15@04) (<= 0 (inv@454@04 r)))
              (< (inv@453@04 r) V@15@04))
            (<= 0 (inv@453@04 r)))
          $Perm.Write
          $Perm.No)
        (pTaken@501@04 r))
      (- $Perm.Write (pTaken@506@04 r)))
    $Perm.No))
(define-fun pTaken@508@04 ((r $Ref)) $Perm
  (ite
    (=
      r
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) v1@441@04))) u@496@04))
    ($Perm.min
      (-
        (ite
          (and (< (inv@457@04 r) V@15@04) (<= 0 (inv@457@04 r)))
          $Perm.Write
          $Perm.No)
        (pTaken@500@04 r))
      (- (- $Perm.Write (pTaken@506@04 r)) (pTaken@507@04 r)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 500)
(push) ; 16
(assert (not (=
  (-
    (ite
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) u@496@04))) v1@441@04)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) u@496@04))) v1@441@04))
      $Perm.Write
      $Perm.No)
    (pTaken@506@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) u@496@04))) v1@441@04)))
  $Perm.No)))
(check-sat)
; unknown
(pop) ; 16
; 0.51s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               15940999
;  :arith-add-rows          3490387
;  :arith-assert-diseq      83073
;  :arith-assert-lower      3019562
;  :arith-assert-upper      2644771
;  :arith-bound-prop        78409
;  :arith-conflicts         2014
;  :arith-eq-adapter        1155289
;  :arith-fixed-eqs         2860634
;  :arith-offset-eqs        1738800
;  :arith-pivots            492370
;  :conflicts               4875
;  :datatype-accessor-ax    469
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               610718
;  :del-clause              41358431
;  :final-checks            5
;  :max-generation          14
;  :max-memory              290.14
;  :memory                  265.78
;  :minimized-lits          618
;  :mk-bool-var             35801628
;  :mk-clause               41361620
;  :num-allocs              86661926
;  :num-checks              550
;  :propagations            11878631
;  :quant-instantiations    14997095
;  :restarts                11
;  :rlimit-count            334556100
;  :time                    0.51)
; Intermediate check if already taken enough permissions
(push) ; 16
(assert (not (forall ((r $Ref)) (!
  (implies
    (=
      r
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) v1@441@04))) u@496@04))
    (= (- $Perm.Write (pTaken@506@04 r)) $Perm.No))
  
  ))))
(check-sat)
; unknown
(pop) ; 16
; 0.50s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               15952873
;  :arith-add-rows          3498593
;  :arith-assert-diseq      83306
;  :arith-assert-lower      3021737
;  :arith-assert-upper      2646199
;  :arith-bound-prop        78977
;  :arith-conflicts         2029
;  :arith-eq-adapter        1156989
;  :arith-fixed-eqs         2861826
;  :arith-offset-eqs        1739760
;  :arith-pivots            493869
;  :conflicts               4907
;  :datatype-accessor-ax    469
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               612575
;  :del-clause              41436677
;  :final-checks            5
;  :max-generation          14
;  :max-memory              290.14
;  :memory                  266.41
;  :minimized-lits          621
;  :mk-bool-var             35868664
;  :mk-clause               41439866
;  :num-allocs              86841501
;  :num-checks              551
;  :propagations            11895007
;  :quant-instantiations    15017313
;  :restarts                11
;  :rlimit-count            335450661
;  :time                    0.50)
; Chunk depleted?
(push) ; 16
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (-
        (ite
          (and
            (and
              (and (< (inv@454@04 r) V@15@04) (<= 0 (inv@454@04 r)))
              (< (inv@453@04 r) V@15@04))
            (<= 0 (inv@453@04 r)))
          $Perm.Write
          $Perm.No)
        (pTaken@501@04 r))
      (pTaken@507@04 r))
    $Perm.No)
  
  ))))
(check-sat)
; unknown
(pop) ; 16
; 0.53s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               15964724
;  :arith-add-rows          3506424
;  :arith-assert-diseq      83536
;  :arith-assert-lower      3023933
;  :arith-assert-upper      2647641
;  :arith-bound-prop        79527
;  :arith-conflicts         2044
;  :arith-eq-adapter        1158590
;  :arith-fixed-eqs         2863031
;  :arith-offset-eqs        1740680
;  :arith-pivots            495397
;  :conflicts               4939
;  :datatype-accessor-ax    469
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               614454
;  :del-clause              41516971
;  :final-checks            5
;  :max-generation          14
;  :max-memory              290.14
;  :memory                  266.44
;  :minimized-lits          623
;  :mk-bool-var             35937387
;  :mk-clause               41520160
;  :num-allocs              87021741
;  :num-checks              552
;  :propagations            11912151
;  :quant-instantiations    15038434
;  :restarts                11
;  :rlimit-count            336340028
;  :time                    0.53)
; Intermediate check if already taken enough permissions
(push) ; 16
(assert (not (forall ((r $Ref)) (!
  (implies
    (=
      r
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) v1@441@04))) u@496@04))
    (= (- (- $Perm.Write (pTaken@506@04 r)) (pTaken@507@04 r)) $Perm.No))
  
  ))))
(check-sat)
; unsat
(pop) ; 16
; 0.15s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               15968252
;  :arith-add-rows          3509360
;  :arith-assert-diseq      83689
;  :arith-assert-lower      3024721
;  :arith-assert-upper      2648071
;  :arith-bound-prop        79717
;  :arith-conflicts         2056
;  :arith-eq-adapter        1158998
;  :arith-fixed-eqs         2863339
;  :arith-offset-eqs        1740881
;  :arith-pivots            495549
;  :conflicts               4973
;  :datatype-accessor-ax    469
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               615403
;  :del-clause              41544571
;  :final-checks            5
;  :max-generation          14
;  :max-memory              290.14
;  :memory                  266.39
;  :minimized-lits          625
;  :mk-bool-var             35958139
;  :mk-clause               41547760
;  :num-allocs              87072396
;  :num-checks              553
;  :propagations            11916569
;  :quant-instantiations    15042960
;  :restarts                11
;  :rlimit-count            336570802
;  :time                    0.15)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@509@04 $FVF<Int>)
; Definitional axioms for singleton-FVF's value
(assert (=
  ($FVF.lookup_int (as sm@509@04  $FVF<Int>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) v1@441@04))) u@496@04))
  (+
    ($FVF.lookup_int (as sm@503@04  $FVF<Int>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) v1@441@04))) u@496@04))
    bottleneckPathFlow@352@04)))
(assert ($FVF.loc_int ($FVF.lookup_int (as sm@509@04  $FVF<Int>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) v1@441@04))) u@496@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) v1@441@04))) u@496@04)))
; [exec]
; v1 := aloc(opt_get1(P), v1).int
; [eval] aloc(opt_get1(P), v1)
; [eval] opt_get1(P)
(push) ; 16
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 16
; Joined path conditions
(push) ; 16
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(pop) ; 16
; Joined path conditions
(declare-const sm@510@04 $FVF<Int>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (=
      r
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) v1@441@04))) u@496@04))
    (=
      ($FVF.lookup_int (as sm@510@04  $FVF<Int>) r)
      ($FVF.lookup_int (as sm@509@04  $FVF<Int>) r)))
  :pattern (($FVF.lookup_int (as sm@510@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int (as sm@509@04  $FVF<Int>) r))
  :qid |qp.fvfValDef375|)))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (ite
          (and (< (inv@457@04 r) V@15@04) (<= 0 (inv@457@04 r)))
          $Perm.Write
          $Perm.No)
        (pTaken@500@04 r)))
    (=
      ($FVF.lookup_int (as sm@510@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04)))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@510@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04)))))))))))))) r))
  :qid |qp.fvfValDef376|)))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (-
          (ite
            (and
              (and
                (and (< (inv@454@04 r) V@15@04) (<= 0 (inv@454@04 r)))
                (< (inv@453@04 r) V@15@04))
              (<= 0 (inv@453@04 r)))
            $Perm.Write
            $Perm.No)
          (pTaken@501@04 r))
        (pTaken@507@04 r)))
    (=
      ($FVF.lookup_int (as sm@510@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@510@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))))))) r))
  :qid |qp.fvfValDef377|)))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (ite
          (=
            r
            (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) u@496@04))) v1@441@04))
          $Perm.Write
          $Perm.No)
        (pTaken@506@04 r)))
    (=
      ($FVF.lookup_int (as sm@510@04  $FVF<Int>) r)
      ($FVF.lookup_int (as sm@502@04  $FVF<Int>) r)))
  :pattern (($FVF.lookup_int (as sm@510@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int (as sm@502@04  $FVF<Int>) r))
  :qid |qp.fvfValDef378|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int (as sm@509@04  $FVF<Int>) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04)))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int (as sm@502@04  $FVF<Int>) r) r))
  :pattern (($FVF.lookup_int (as sm@510@04  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef379|)))
(declare-const pm@511@04 $FPM)
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_int (as pm@511@04  $FPM) r)
    (+
      (+
        (+
          (ite
            (=
              r
              (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit G@11@04) v1@441@04))) u@496@04))
            $Perm.Write
            $Perm.No)
          (-
            (ite
              (and (< (inv@457@04 r) V@15@04) (<= 0 (inv@457@04 r)))
              $Perm.Write
              $Perm.No)
            (pTaken@500@04 r)))
        (-
          (-
            (ite
              (and
                (and
                  (and (< (inv@454@04 r) V@15@04) (<= 0 (inv@454@04 r)))
                  (< (inv@453@04 r) V@15@04))
                (<= 0 (inv@453@04 r)))
              $Perm.Write
              $Perm.No)
            (pTaken@501@04 r))
          (pTaken@507@04 r)))
      (-
        (ite
          (=
            r
            (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) u@496@04))) v1@441@04))
          $Perm.Write
          $Perm.No)
        (pTaken@506@04 r))))
  :pattern (($FVF.perm_int (as pm@511@04  $FPM) r))
  :qid |qp.resPrmSumDef380|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int (as sm@510@04  $FVF<Int>) r) r)
    ($FVF.loc_int ($FVF.lookup_int (as sm@509@04  $FVF<Int>) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04)))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int (as sm@502@04  $FVF<Int>) r) r))
  :pattern (($FVF.perm_int (as pm@511@04  $FPM) r))
  :qid |qp.resTrgDef381|)))
(assert ($FVF.loc_int ($FVF.lookup_int (as sm@510@04  $FVF<Int>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit P@14@04) v1@441@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit P@14@04) v1@441@04)))
(set-option :timeout 0)
(push) ; 16
(assert (not (<
  $Perm.No
  ($FVF.perm_int (as pm@511@04  $FPM) (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) v1@441@04)))))
(check-sat)
; unsat
(pop) ; 16
; 0.04s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               15970628
;  :arith-add-rows          3510098
;  :arith-assert-diseq      83696
;  :arith-assert-lower      3024978
;  :arith-assert-upper      2648247
;  :arith-bound-prop        79878
;  :arith-conflicts         2063
;  :arith-eq-adapter        1159167
;  :arith-fixed-eqs         2863497
;  :arith-offset-eqs        1741396
;  :arith-pivots            495792
;  :conflicts               4982
;  :datatype-accessor-ax    469
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               615411
;  :del-clause              41550258
;  :final-checks            5
;  :max-generation          14
;  :max-memory              290.14
;  :memory                  266.22
;  :minimized-lits          627
;  :mk-bool-var             35965163
;  :mk-clause               41553491
;  :num-allocs              87089269
;  :num-checks              554
;  :propagations            11917225
;  :quant-instantiations    15044616
;  :restarts                11
;  :rlimit-count            336651009
;  :time                    0.04)
(declare-const v1@512@04 Int)
(assert (=
  v1@512@04
  ($FVF.lookup_int (as sm@510@04  $FVF<Int>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit P@14@04) v1@441@04))))
; Loop head block: Re-establish invariant
; [eval] exc == excBeforeLoop2
; [eval] 0 <= v1
(push) ; 16
(assert (not (<= 0 v1@512@04)))
(check-sat)
; unsat
(pop) ; 16
; 0.09s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               15974525
;  :arith-add-rows          3519315
;  :arith-assert-diseq      83856
;  :arith-assert-lower      3025885
;  :arith-assert-upper      2648647
;  :arith-bound-prop        80081
;  :arith-conflicts         2078
;  :arith-eq-adapter        1159676
;  :arith-fixed-eqs         2863779
;  :arith-offset-eqs        1741709
;  :arith-pivots            495970
;  :conflicts               5026
;  :datatype-accessor-ax    469
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               615931
;  :del-clause              41565516
;  :final-checks            5
;  :max-generation          14
;  :max-memory              290.14
;  :memory                  266.48
;  :minimized-lits          628
;  :mk-bool-var             35978635
;  :mk-clause               41568749
;  :num-allocs              87127040
;  :num-checks              555
;  :propagations            11920992
;  :quant-instantiations    15047030
;  :restarts                11
;  :rlimit-count            337065772
;  :time                    0.09)
(assert (<= 0 v1@512@04))
; [eval] v1 < V
(push) ; 16
(assert (not (< v1@512@04 V@15@04)))
(check-sat)
; unsat
(pop) ; 16
; 0.09s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               15979322
;  :arith-add-rows          3532028
;  :arith-assert-diseq      84047
;  :arith-assert-lower      3026950
;  :arith-assert-upper      2649121
;  :arith-bound-prop        80298
;  :arith-conflicts         2094
;  :arith-eq-adapter        1160247
;  :arith-fixed-eqs         2864138
;  :arith-offset-eqs        1742074
;  :arith-pivots            496198
;  :conflicts               5071
;  :datatype-accessor-ax    469
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               616449
;  :del-clause              41582401
;  :final-checks            5
;  :max-generation          14
;  :max-memory              290.14
;  :memory                  266.52
;  :minimized-lits          629
;  :mk-bool-var             35994290
;  :mk-clause               41585634
;  :num-allocs              87168287
;  :num-checks              556
;  :propagations            11924976
;  :quant-instantiations    15049964
;  :restarts                11
;  :rlimit-count            337531624
;  :time                    0.09)
(assert (< v1@512@04 V@15@04))
; [eval] G != (None(): option[array])
; [eval] (None(): option[array])
; [eval] alen(opt_get1(G)) == V
; [eval] alen(opt_get1(G))
; [eval] opt_get1(G)
(push) ; 16
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 16
; Joined path conditions
(declare-const i1@513@04 Int)
(push) ; 16
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 17
; [then-branch: 270 | 0 <= i1@513@04 | live]
; [else-branch: 270 | !(0 <= i1@513@04) | live]
(push) ; 18
; [then-branch: 270 | 0 <= i1@513@04]
(assert (<= 0 i1@513@04))
; [eval] i1 < V
(pop) ; 18
(push) ; 18
; [else-branch: 270 | !(0 <= i1@513@04)]
(assert (not (<= 0 i1@513@04)))
(pop) ; 18
(pop) ; 17
; Joined path conditions
; Joined path conditions
(assert (and (< i1@513@04 V@15@04) (<= 0 i1@513@04)))
(declare-const $k@514@04 $Perm)
(assert ($Perm.isReadVar $k@514@04 $Perm.Write))
; [eval] aloc(opt_get1(G), i1)
; [eval] opt_get1(G)
(push) ; 17
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 17
; Joined path conditions
(push) ; 17
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 18
(assert (not (< i1@513@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))))
(check-sat)
; unsat
(pop) ; 18
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               15979322
;  :arith-add-rows          3532030
;  :arith-assert-diseq      84048
;  :arith-assert-lower      3026955
;  :arith-assert-upper      2649122
;  :arith-bound-prop        80298
;  :arith-conflicts         2094
;  :arith-eq-adapter        1160248
;  :arith-fixed-eqs         2864138
;  :arith-offset-eqs        1742074
;  :arith-pivots            496199
;  :conflicts               5071
;  :datatype-accessor-ax    469
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               616449
;  :del-clause              41582401
;  :final-checks            5
;  :max-generation          14
;  :max-memory              290.14
;  :memory                  266.52
;  :minimized-lits          629
;  :mk-bool-var             35994297
;  :mk-clause               41585636
;  :num-allocs              87168527
;  :num-checks              557
;  :propagations            11924977
;  :quant-instantiations    15049964
;  :restarts                11
;  :rlimit-count            337532050)
(assert (< i1@513@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(pop) ; 17
; Joined path conditions
(assert (< i1@513@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(pop) ; 16
(declare-fun inv@515@04 ($Ref) Int)
; Nested auxiliary terms: globals
(assert ($Perm.isReadVar $k@514@04 $Perm.Write))
; Nested auxiliary terms: non-globals
(assert (forall ((i1@513@04 Int)) (!
  (< i1@513@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@513@04))
  :qid |option$array$-aux|)))
(push) ; 16
(assert (not (forall ((i1@513@04 Int)) (!
  (implies
    (and (< i1@513@04 V@15@04) (<= 0 i1@513@04))
    (or (= $k@514@04 $Perm.No) (< $Perm.No $k@514@04)))
  
  ))))
(check-sat)
; unsat
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               15979322
;  :arith-add-rows          3532031
;  :arith-assert-diseq      84049
;  :arith-assert-lower      3026957
;  :arith-assert-upper      2649123
;  :arith-bound-prop        80298
;  :arith-conflicts         2094
;  :arith-eq-adapter        1160249
;  :arith-fixed-eqs         2864138
;  :arith-offset-eqs        1742074
;  :arith-pivots            496199
;  :conflicts               5072
;  :datatype-accessor-ax    469
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               616449
;  :del-clause              41582403
;  :final-checks            5
;  :max-generation          14
;  :max-memory              290.14
;  :memory                  266.52
;  :minimized-lits          629
;  :mk-bool-var             35994304
;  :mk-clause               41585638
;  :num-allocs              87168960
;  :num-checks              558
;  :propagations            11924978
;  :quant-instantiations    15049966
;  :restarts                11
;  :rlimit-count            337532618)
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 16
(assert (not (forall ((i11@513@04 Int) (i12@513@04 Int)) (!
  (implies
    (and
      (and
        (and
          (and (< i11@513@04 V@15@04) (<= 0 i11@513@04))
          ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i11@513@04)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i11@513@04)))
        (< $Perm.No $k@514@04))
      (and
        (and
          (and (< i12@513@04 V@15@04) (<= 0 i12@513@04))
          ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i12@513@04)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i12@513@04)))
        (< $Perm.No $k@514@04))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i11@513@04)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i12@513@04)))
    (= i11@513@04 i12@513@04))
  
  :qid |option$array$-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               15979375
;  :arith-add-rows          3532038
;  :arith-assert-diseq      84050
;  :arith-assert-lower      3026961
;  :arith-assert-upper      2649123
;  :arith-bound-prop        80298
;  :arith-conflicts         2094
;  :arith-eq-adapter        1160250
;  :arith-fixed-eqs         2864138
;  :arith-offset-eqs        1742074
;  :arith-pivots            496201
;  :conflicts               5073
;  :datatype-accessor-ax    469
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               616449
;  :del-clause              41582410
;  :final-checks            5
;  :max-generation          14
;  :max-memory              290.14
;  :memory                  266.52
;  :minimized-lits          629
;  :mk-bool-var             35994383
;  :mk-clause               41585645
;  :num-allocs              87169898
;  :num-checks              559
;  :propagations            11924978
;  :quant-instantiations    15050059
;  :restarts                11
;  :rlimit-count            337535715
;  :time                    0.00)
; Definitional axioms for inverse functions
(assert (forall ((i1@513@04 Int)) (!
  (implies
    (and (and (< i1@513@04 V@15@04) (<= 0 i1@513@04)) (< $Perm.No $k@514@04))
    (=
      (inv@515@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@513@04))
      i1@513@04))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@513@04))
  :qid |option$array$-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and (< (inv@515@04 r) V@15@04) (<= 0 (inv@515@04 r)))
      (< $Perm.No $k@514@04))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) (inv@515@04 r))
      r))
  :pattern ((inv@515@04 r))
  :qid |option$array$-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@515@04 r) V@15@04) (<= 0 (inv@515@04 r)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) r) r))
  :pattern ((inv@515@04 r))
  )))
; Precomputing data for removing quantified permissions
(define-fun pTaken@516@04 ((r $Ref)) $Perm
  (ite
    (and (< (inv@515@04 r) V@15@04) (<= 0 (inv@515@04 r)))
    ($Perm.min
      (ite
        (and (< (inv@445@04 r) V@15@04) (<= 0 (inv@445@04 r)))
        $k@444@04
        $Perm.No)
      $k@514@04)
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Constrain original permissions $k@514@04
(assert (forall ((r $Ref)) (!
  (implies
    (not
      (=
        (ite
          (and (< (inv@445@04 r) V@15@04) (<= 0 (inv@445@04 r)))
          $k@444@04
          $Perm.No)
        $Perm.No))
    (ite
      (and (< (inv@445@04 r) V@15@04) (<= 0 (inv@445@04 r)))
      (<
        (ite
          (and (< (inv@515@04 r) V@15@04) (<= 0 (inv@515@04 r)))
          $k@514@04
          $Perm.No)
        $k@444@04)
      (<
        (ite
          (and (< (inv@515@04 r) V@15@04) (<= 0 (inv@515@04 r)))
          $k@514@04
          $Perm.No)
        $Perm.No)))
  :pattern ((inv@445@04 r))
  :pattern ((inv@515@04 r))
  :qid |qp.srp382|)))
; Intermediate check if already taken enough permissions
(set-option :timeout 500)
(push) ; 16
(assert (not (forall ((r $Ref)) (!
  (implies
    (and (< (inv@515@04 r) V@15@04) (<= 0 (inv@515@04 r)))
    (= (- $k@514@04 (pTaken@516@04 r)) $Perm.No))
  
  ))))
(check-sat)
; unsat
(pop) ; 16
; 0.06s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               15981964
;  :arith-add-rows          3537198
;  :arith-assert-diseq      84170
;  :arith-assert-lower      3027540
;  :arith-assert-upper      2649456
;  :arith-bound-prop        80524
;  :arith-conflicts         2106
;  :arith-eq-adapter        1160596
;  :arith-fixed-eqs         2864388
;  :arith-offset-eqs        1742278
;  :arith-pivots            496354
;  :conflicts               5110
;  :datatype-accessor-ax    469
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               617101
;  :del-clause              41600832
;  :final-checks            5
;  :max-generation          14
;  :max-memory              290.14
;  :memory                  266.25
;  :minimized-lits          633
;  :mk-bool-var             36008413
;  :mk-clause               41604087
;  :num-allocs              87209939
;  :num-checks              561
;  :propagations            11928011
;  :quant-instantiations    15053442
;  :restarts                11
;  :rlimit-count            337831920
;  :time                    0.06)
; Final check if taken enough permissions
; Done removing quantified permissions
; Definitional axioms for snapshot map values
; [eval] (forall i1: Int :: { aloc(opt_get1(G), i1) } 0 <= i1 && i1 < V ==> aloc(opt_get1(G), i1).option$array$ != (None(): option[array]))
(declare-const i1@517@04 Int)
(push) ; 16
; [eval] 0 <= i1 && i1 < V ==> aloc(opt_get1(G), i1).option$array$ != (None(): option[array])
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 17
; [then-branch: 271 | 0 <= i1@517@04 | live]
; [else-branch: 271 | !(0 <= i1@517@04) | live]
(push) ; 18
; [then-branch: 271 | 0 <= i1@517@04]
(assert (<= 0 i1@517@04))
; [eval] i1 < V
(pop) ; 18
(push) ; 18
; [else-branch: 271 | !(0 <= i1@517@04)]
(assert (not (<= 0 i1@517@04)))
(pop) ; 18
(pop) ; 17
; Joined path conditions
; Joined path conditions
(push) ; 17
; [then-branch: 272 | i1@517@04 < V@15@04 && 0 <= i1@517@04 | live]
; [else-branch: 272 | !(i1@517@04 < V@15@04 && 0 <= i1@517@04) | live]
(push) ; 18
; [then-branch: 272 | i1@517@04 < V@15@04 && 0 <= i1@517@04]
(assert (and (< i1@517@04 V@15@04) (<= 0 i1@517@04)))
; [eval] aloc(opt_get1(G), i1).option$array$ != (None(): option[array])
; [eval] aloc(opt_get1(G), i1)
; [eval] opt_get1(G)
(push) ; 19
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 19
; Joined path conditions
(push) ; 19
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 20
(assert (not (< i1@517@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))))
(check-sat)
; unsat
(pop) ; 20
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               15981964
;  :arith-add-rows          3537199
;  :arith-assert-diseq      84170
;  :arith-assert-lower      3027542
;  :arith-assert-upper      2649456
;  :arith-bound-prop        80524
;  :arith-conflicts         2106
;  :arith-eq-adapter        1160596
;  :arith-fixed-eqs         2864388
;  :arith-offset-eqs        1742278
;  :arith-pivots            496355
;  :conflicts               5110
;  :datatype-accessor-ax    469
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               617101
;  :del-clause              41600832
;  :final-checks            5
;  :max-generation          14
;  :max-memory              290.14
;  :memory                  266.25
;  :minimized-lits          633
;  :mk-bool-var             36008415
;  :mk-clause               41604087
;  :num-allocs              87210048
;  :num-checks              562
;  :propagations            11928011
;  :quant-instantiations    15053442
;  :restarts                11
;  :rlimit-count            337832116)
(assert (< i1@517@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(pop) ; 19
; Joined path conditions
(assert (< i1@517@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@517@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@517@04)))
(push) ; 19
(assert (not (ite
  (and
    (<
      (inv@445@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@517@04))
      V@15@04)
    (<=
      0
      (inv@445@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@517@04))))
  (< $Perm.No $k@444@04)
  false)))
(check-sat)
; unsat
(pop) ; 19
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               15982125
;  :arith-add-rows          3537288
;  :arith-assert-diseq      84170
;  :arith-assert-lower      3027565
;  :arith-assert-upper      2649476
;  :arith-bound-prop        80540
;  :arith-conflicts         2107
;  :arith-eq-adapter        1160618
;  :arith-fixed-eqs         2864407
;  :arith-offset-eqs        1742309
;  :arith-pivots            496375
;  :conflicts               5111
;  :datatype-accessor-ax    469
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               617101
;  :del-clause              41600832
;  :final-checks            5
;  :max-generation          14
;  :max-memory              290.14
;  :memory                  266.28
;  :minimized-lits          633
;  :mk-bool-var             36009016
;  :mk-clause               41604523
;  :num-allocs              87212824
;  :num-checks              563
;  :propagations            11928093
;  :quant-instantiations    15053708
;  :restarts                11
;  :rlimit-count            337845670
;  :time                    0.00)
; [eval] (None(): option[array])
(pop) ; 18
(push) ; 18
; [else-branch: 272 | !(i1@517@04 < V@15@04 && 0 <= i1@517@04)]
(assert (not (and (< i1@517@04 V@15@04) (<= 0 i1@517@04))))
(pop) ; 18
(pop) ; 17
; Joined path conditions
(assert (implies
  (and (< i1@517@04 V@15@04) (<= 0 i1@517@04))
  (and
    (< i1@517@04 V@15@04)
    (<= 0 i1@517@04)
    (< i1@517@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@517@04)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@517@04)))))
; Joined path conditions
(pop) ; 16
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@517@04 Int)) (!
  (implies
    (and (< i1@517@04 V@15@04) (<= 0 i1@517@04))
    (and
      (< i1@517@04 V@15@04)
      (<= 0 i1@517@04)
      (< i1@517@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@517@04)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@517@04))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@517@04))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(push) ; 16
(assert (not (forall ((i1@517@04 Int)) (!
  (implies
    (and (< i1@517@04 V@15@04) (<= 0 i1@517@04))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@517@04))
        (as None<option<array>>  option<array>))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@517@04))
  :qid |prog.l<no position>|))))
(check-sat)
; unsat
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               15982152
;  :arith-add-rows          3537326
;  :arith-assert-diseq      84170
;  :arith-assert-lower      3027568
;  :arith-assert-upper      2649477
;  :arith-bound-prop        80541
;  :arith-conflicts         2107
;  :arith-eq-adapter        1160622
;  :arith-fixed-eqs         2864408
;  :arith-offset-eqs        1742309
;  :arith-pivots            496397
;  :conflicts               5112
;  :datatype-accessor-ax    469
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               617101
;  :del-clause              41601669
;  :final-checks            5
;  :max-generation          14
;  :max-memory              290.14
;  :memory                  266.21
;  :minimized-lits          633
;  :mk-bool-var             36009373
;  :mk-clause               41604924
;  :num-allocs              87215001
;  :num-checks              564
;  :propagations            11928095
;  :quant-instantiations    15053894
;  :restarts                11
;  :rlimit-count            337854751
;  :time                    0.00)
(assert (forall ((i1@517@04 Int)) (!
  (implies
    (and (< i1@517@04 V@15@04) (<= 0 i1@517@04))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@517@04))
        (as None<option<array>>  option<array>))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@517@04))
  :qid |prog.l<no position>|)))
; [eval] (forall i1: Int :: { alen(opt_get1(aloc(opt_get1(G), i1).option$array$)) } 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(G), i1).option$array$)) == V)
(declare-const i1@518@04 Int)
(push) ; 16
; [eval] 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(G), i1).option$array$)) == V
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 17
; [then-branch: 273 | 0 <= i1@518@04 | live]
; [else-branch: 273 | !(0 <= i1@518@04) | live]
(push) ; 18
; [then-branch: 273 | 0 <= i1@518@04]
(assert (<= 0 i1@518@04))
; [eval] i1 < V
(pop) ; 18
(push) ; 18
; [else-branch: 273 | !(0 <= i1@518@04)]
(assert (not (<= 0 i1@518@04)))
(pop) ; 18
(pop) ; 17
; Joined path conditions
; Joined path conditions
(push) ; 17
; [then-branch: 274 | i1@518@04 < V@15@04 && 0 <= i1@518@04 | live]
; [else-branch: 274 | !(i1@518@04 < V@15@04 && 0 <= i1@518@04) | live]
(push) ; 18
; [then-branch: 274 | i1@518@04 < V@15@04 && 0 <= i1@518@04]
(assert (and (< i1@518@04 V@15@04) (<= 0 i1@518@04)))
; [eval] alen(opt_get1(aloc(opt_get1(G), i1).option$array$)) == V
; [eval] alen(opt_get1(aloc(opt_get1(G), i1).option$array$))
; [eval] opt_get1(aloc(opt_get1(G), i1).option$array$)
; [eval] aloc(opt_get1(G), i1)
; [eval] opt_get1(G)
(push) ; 19
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 19
; Joined path conditions
(push) ; 19
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 20
(assert (not (< i1@518@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))))
(check-sat)
; unsat
(pop) ; 20
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               15982152
;  :arith-add-rows          3537327
;  :arith-assert-diseq      84170
;  :arith-assert-lower      3027570
;  :arith-assert-upper      2649477
;  :arith-bound-prop        80541
;  :arith-conflicts         2107
;  :arith-eq-adapter        1160622
;  :arith-fixed-eqs         2864408
;  :arith-offset-eqs        1742309
;  :arith-pivots            496398
;  :conflicts               5112
;  :datatype-accessor-ax    469
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               617101
;  :del-clause              41601669
;  :final-checks            5
;  :max-generation          14
;  :max-memory              290.14
;  :memory                  266.21
;  :minimized-lits          633
;  :mk-bool-var             36009376
;  :mk-clause               41604924
;  :num-allocs              87215302
;  :num-checks              565
;  :propagations            11928095
;  :quant-instantiations    15053894
;  :restarts                11
;  :rlimit-count            337855258)
(assert (< i1@518@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(pop) ; 19
; Joined path conditions
(assert (< i1@518@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@518@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@518@04)))
(push) ; 19
(assert (not (ite
  (and
    (<
      (inv@445@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@518@04))
      V@15@04)
    (<=
      0
      (inv@445@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@518@04))))
  (< $Perm.No $k@444@04)
  false)))
(check-sat)
; unsat
(pop) ; 19
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               15982313
;  :arith-add-rows          3537416
;  :arith-assert-diseq      84170
;  :arith-assert-lower      3027593
;  :arith-assert-upper      2649497
;  :arith-bound-prop        80557
;  :arith-conflicts         2108
;  :arith-eq-adapter        1160644
;  :arith-fixed-eqs         2864427
;  :arith-offset-eqs        1742340
;  :arith-pivots            496418
;  :conflicts               5113
;  :datatype-accessor-ax    469
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               617101
;  :del-clause              41601669
;  :final-checks            5
;  :max-generation          14
;  :max-memory              290.14
;  :memory                  266.21
;  :minimized-lits          633
;  :mk-bool-var             36009977
;  :mk-clause               41605360
;  :num-allocs              87218109
;  :num-checks              566
;  :propagations            11928177
;  :quant-instantiations    15054161
;  :restarts                11
;  :rlimit-count            337868840)
(push) ; 19
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 20
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@518@04))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 20
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               15982313
;  :arith-add-rows          3537416
;  :arith-assert-diseq      84170
;  :arith-assert-lower      3027593
;  :arith-assert-upper      2649497
;  :arith-bound-prop        80557
;  :arith-conflicts         2108
;  :arith-eq-adapter        1160644
;  :arith-fixed-eqs         2864427
;  :arith-offset-eqs        1742340
;  :arith-pivots            496418
;  :conflicts               5114
;  :datatype-accessor-ax    469
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               617101
;  :del-clause              41601669
;  :final-checks            5
;  :max-generation          14
;  :max-memory              290.14
;  :memory                  266.21
;  :minimized-lits          633
;  :mk-bool-var             36009977
;  :mk-clause               41605360
;  :num-allocs              87218200
;  :num-checks              567
;  :propagations            11928177
;  :quant-instantiations    15054161
;  :restarts                11
;  :rlimit-count            337868935)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@518@04))
    (as None<option<array>>  option<array>))))
(pop) ; 19
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@518@04))
    (as None<option<array>>  option<array>))))
(pop) ; 18
(push) ; 18
; [else-branch: 274 | !(i1@518@04 < V@15@04 && 0 <= i1@518@04)]
(assert (not (and (< i1@518@04 V@15@04) (<= 0 i1@518@04))))
(pop) ; 18
(pop) ; 17
; Joined path conditions
(assert (implies
  (and (< i1@518@04 V@15@04) (<= 0 i1@518@04))
  (and
    (< i1@518@04 V@15@04)
    (<= 0 i1@518@04)
    (< i1@518@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@518@04)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@518@04))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@518@04))
        (as None<option<array>>  option<array>))))))
; Joined path conditions
(pop) ; 16
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@518@04 Int)) (!
  (implies
    (and (< i1@518@04 V@15@04) (<= 0 i1@518@04))
    (and
      (< i1@518@04 V@15@04)
      (<= 0 i1@518@04)
      (< i1@518@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@518@04)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@518@04))
      (not
        (=
          ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@518@04))
          (as None<option<array>>  option<array>)))))
  :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@518@04)))))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(push) ; 16
(assert (not (forall ((i1@518@04 Int)) (!
  (implies
    (and (< i1@518@04 V@15@04) (<= 0 i1@518@04))
    (=
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@518@04))))
      V@15@04))
  :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@518@04)))))
  :qid |prog.l<no position>|))))
(check-sat)
; unsat
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               15982313
;  :arith-add-rows          3537435
;  :arith-assert-diseq      84170
;  :arith-assert-lower      3027595
;  :arith-assert-upper      2649497
;  :arith-bound-prop        80557
;  :arith-conflicts         2108
;  :arith-eq-adapter        1160645
;  :arith-fixed-eqs         2864427
;  :arith-offset-eqs        1742340
;  :arith-pivots            496438
;  :conflicts               5115
;  :datatype-accessor-ax    469
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               617101
;  :del-clause              41602115
;  :final-checks            5
;  :max-generation          14
;  :max-memory              290.14
;  :memory                  266.17
;  :minimized-lits          633
;  :mk-bool-var             36010030
;  :mk-clause               41605370
;  :num-allocs              87219002
;  :num-checks              568
;  :propagations            11928177
;  :quant-instantiations    15054220
;  :restarts                11
;  :rlimit-count            337871533)
(assert (forall ((i1@518@04 Int)) (!
  (implies
    (and (< i1@518@04 V@15@04) (<= 0 i1@518@04))
    (=
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@518@04))))
      V@15@04))
  :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@518@04)))))
  :qid |prog.l<no position>|)))
; [eval] (forall i1: Int :: { aloc(opt_get1(G), i1) } (forall i2: Int :: { aloc(opt_get1(G), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(G), i1).option$array$ == aloc(opt_get1(G), i2).option$array$ ==> i1 == i2))
(declare-const i1@519@04 Int)
(push) ; 16
; [eval] (forall i2: Int :: { aloc(opt_get1(G), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(G), i1).option$array$ == aloc(opt_get1(G), i2).option$array$ ==> i1 == i2)
(declare-const i2@520@04 Int)
(push) ; 17
; [eval] 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(G), i1).option$array$ == aloc(opt_get1(G), i2).option$array$ ==> i1 == i2
; [eval] 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(G), i1).option$array$ == aloc(opt_get1(G), i2).option$array$
; [eval] 0 <= i1
(push) ; 18
; [then-branch: 275 | 0 <= i1@519@04 | live]
; [else-branch: 275 | !(0 <= i1@519@04) | live]
(push) ; 19
; [then-branch: 275 | 0 <= i1@519@04]
(assert (<= 0 i1@519@04))
; [eval] i1 < V
(push) ; 20
; [then-branch: 276 | i1@519@04 < V@15@04 | live]
; [else-branch: 276 | !(i1@519@04 < V@15@04) | live]
(push) ; 21
; [then-branch: 276 | i1@519@04 < V@15@04]
(assert (< i1@519@04 V@15@04))
; [eval] 0 <= i2
(push) ; 22
; [then-branch: 277 | 0 <= i2@520@04 | live]
; [else-branch: 277 | !(0 <= i2@520@04) | live]
(push) ; 23
; [then-branch: 277 | 0 <= i2@520@04]
(assert (<= 0 i2@520@04))
; [eval] i2 < V
(push) ; 24
; [then-branch: 278 | i2@520@04 < V@15@04 | live]
; [else-branch: 278 | !(i2@520@04 < V@15@04) | live]
(push) ; 25
; [then-branch: 278 | i2@520@04 < V@15@04]
(assert (< i2@520@04 V@15@04))
; [eval] aloc(opt_get1(G), i1).option$array$ == aloc(opt_get1(G), i2).option$array$
; [eval] aloc(opt_get1(G), i1)
; [eval] opt_get1(G)
(push) ; 26
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 26
; Joined path conditions
(push) ; 26
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 27
(assert (not (< i1@519@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))))
(check-sat)
; unsat
(pop) ; 27
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               15982313
;  :arith-add-rows          3537437
;  :arith-assert-diseq      84170
;  :arith-assert-lower      3027599
;  :arith-assert-upper      2649497
;  :arith-bound-prop        80557
;  :arith-conflicts         2108
;  :arith-eq-adapter        1160645
;  :arith-fixed-eqs         2864427
;  :arith-offset-eqs        1742340
;  :arith-pivots            496438
;  :conflicts               5115
;  :datatype-accessor-ax    469
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               617101
;  :del-clause              41602115
;  :final-checks            5
;  :max-generation          14
;  :max-memory              290.14
;  :memory                  266.17
;  :minimized-lits          633
;  :mk-bool-var             36010035
;  :mk-clause               41605370
;  :num-allocs              87219485
;  :num-checks              569
;  :propagations            11928177
;  :quant-instantiations    15054220
;  :restarts                11
;  :rlimit-count            337872181)
(assert (< i1@519@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(pop) ; 26
; Joined path conditions
(assert (< i1@519@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@519@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@519@04)))
(push) ; 26
(assert (not (ite
  (and
    (<
      (inv@445@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@519@04))
      V@15@04)
    (<=
      0
      (inv@445@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@519@04))))
  (< $Perm.No $k@444@04)
  false)))
(check-sat)
; unsat
(pop) ; 26
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               15982441
;  :arith-add-rows          3537509
;  :arith-assert-diseq      84170
;  :arith-assert-lower      3027622
;  :arith-assert-upper      2649517
;  :arith-bound-prop        80572
;  :arith-conflicts         2109
;  :arith-eq-adapter        1160667
;  :arith-fixed-eqs         2864446
;  :arith-offset-eqs        1742340
;  :arith-pivots            496458
;  :conflicts               5116
;  :datatype-accessor-ax    469
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               617101
;  :del-clause              41602115
;  :final-checks            5
;  :max-generation          14
;  :max-memory              290.14
;  :memory                  266.20
;  :minimized-lits          633
;  :mk-bool-var             36010637
;  :mk-clause               41605806
;  :num-allocs              87222278
;  :num-checks              570
;  :propagations            11928256
;  :quant-instantiations    15054487
;  :restarts                11
;  :rlimit-count            337885669)
; [eval] aloc(opt_get1(G), i2)
; [eval] opt_get1(G)
(push) ; 26
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 26
; Joined path conditions
(push) ; 26
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 27
(assert (not (< i2@520@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))))
(check-sat)
; unsat
(pop) ; 27
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               15982441
;  :arith-add-rows          3537509
;  :arith-assert-diseq      84170
;  :arith-assert-lower      3027622
;  :arith-assert-upper      2649517
;  :arith-bound-prop        80572
;  :arith-conflicts         2109
;  :arith-eq-adapter        1160667
;  :arith-fixed-eqs         2864446
;  :arith-offset-eqs        1742340
;  :arith-pivots            496458
;  :conflicts               5116
;  :datatype-accessor-ax    469
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               617101
;  :del-clause              41602115
;  :final-checks            5
;  :max-generation          14
;  :max-memory              290.14
;  :memory                  266.20
;  :minimized-lits          633
;  :mk-bool-var             36010637
;  :mk-clause               41605806
;  :num-allocs              87222304
;  :num-checks              571
;  :propagations            11928256
;  :quant-instantiations    15054487
;  :restarts                11
;  :rlimit-count            337885699)
(assert (< i2@520@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(pop) ; 26
; Joined path conditions
(assert (< i2@520@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@520@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@520@04)))
(push) ; 26
(assert (not (ite
  (and
    (<
      (inv@445@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@520@04))
      V@15@04)
    (<=
      0
      (inv@445@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@520@04))))
  (< $Perm.No $k@444@04)
  false)))
(check-sat)
; unsat
(pop) ; 26
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               15982576
;  :arith-add-rows          3537583
;  :arith-assert-diseq      84170
;  :arith-assert-lower      3027645
;  :arith-assert-upper      2649537
;  :arith-bound-prop        80587
;  :arith-conflicts         2110
;  :arith-eq-adapter        1160690
;  :arith-fixed-eqs         2864465
;  :arith-offset-eqs        1742340
;  :arith-pivots            496478
;  :conflicts               5117
;  :datatype-accessor-ax    469
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               617101
;  :del-clause              41602115
;  :final-checks            5
;  :max-generation          14
;  :max-memory              290.14
;  :memory                  266.24
;  :minimized-lits          633
;  :mk-bool-var             36011355
;  :mk-clause               41606356
;  :num-allocs              87225350
;  :num-checks              572
;  :propagations            11928371
;  :quant-instantiations    15054798
;  :restarts                11
;  :rlimit-count            337901393)
(pop) ; 25
(push) ; 25
; [else-branch: 278 | !(i2@520@04 < V@15@04)]
(assert (not (< i2@520@04 V@15@04)))
(pop) ; 25
(pop) ; 24
; Joined path conditions
(assert (implies
  (< i2@520@04 V@15@04)
  (and
    (< i2@520@04 V@15@04)
    (< i1@519@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@519@04)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@519@04))
    (< i2@520@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@520@04)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@520@04)))))
; Joined path conditions
(pop) ; 23
(push) ; 23
; [else-branch: 277 | !(0 <= i2@520@04)]
(assert (not (<= 0 i2@520@04)))
(pop) ; 23
(pop) ; 22
; Joined path conditions
(assert (implies
  (<= 0 i2@520@04)
  (and
    (<= 0 i2@520@04)
    (implies
      (< i2@520@04 V@15@04)
      (and
        (< i2@520@04 V@15@04)
        (< i1@519@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@519@04)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@519@04))
        (< i2@520@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@520@04)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@520@04)))))))
; Joined path conditions
(pop) ; 21
(push) ; 21
; [else-branch: 276 | !(i1@519@04 < V@15@04)]
(assert (not (< i1@519@04 V@15@04)))
(pop) ; 21
(pop) ; 20
; Joined path conditions
(assert (implies
  (< i1@519@04 V@15@04)
  (and
    (< i1@519@04 V@15@04)
    (implies
      (<= 0 i2@520@04)
      (and
        (<= 0 i2@520@04)
        (implies
          (< i2@520@04 V@15@04)
          (and
            (< i2@520@04 V@15@04)
            (< i1@519@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@519@04)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@519@04))
            (< i2@520@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@520@04)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@520@04)))))))))
; Joined path conditions
(pop) ; 19
(push) ; 19
; [else-branch: 275 | !(0 <= i1@519@04)]
(assert (not (<= 0 i1@519@04)))
(pop) ; 19
(pop) ; 18
; Joined path conditions
(assert (implies
  (<= 0 i1@519@04)
  (and
    (<= 0 i1@519@04)
    (implies
      (< i1@519@04 V@15@04)
      (and
        (< i1@519@04 V@15@04)
        (implies
          (<= 0 i2@520@04)
          (and
            (<= 0 i2@520@04)
            (implies
              (< i2@520@04 V@15@04)
              (and
                (< i2@520@04 V@15@04)
                (< i1@519@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@519@04)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@519@04))
                (< i2@520@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@520@04)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@520@04)))))))))))
; Joined path conditions
(push) ; 18
; [then-branch: 279 | Lookup(option$array$,sm@446@04,aloc((_, _), opt_get1(_, G@11@04), i1@519@04)) == Lookup(option$array$,sm@446@04,aloc((_, _), opt_get1(_, G@11@04), i2@520@04)) && i2@520@04 < V@15@04 && 0 <= i2@520@04 && i1@519@04 < V@15@04 && 0 <= i1@519@04 | live]
; [else-branch: 279 | !(Lookup(option$array$,sm@446@04,aloc((_, _), opt_get1(_, G@11@04), i1@519@04)) == Lookup(option$array$,sm@446@04,aloc((_, _), opt_get1(_, G@11@04), i2@520@04)) && i2@520@04 < V@15@04 && 0 <= i2@520@04 && i1@519@04 < V@15@04 && 0 <= i1@519@04) | live]
(push) ; 19
; [then-branch: 279 | Lookup(option$array$,sm@446@04,aloc((_, _), opt_get1(_, G@11@04), i1@519@04)) == Lookup(option$array$,sm@446@04,aloc((_, _), opt_get1(_, G@11@04), i2@520@04)) && i2@520@04 < V@15@04 && 0 <= i2@520@04 && i1@519@04 < V@15@04 && 0 <= i1@519@04]
(assert (and
  (and
    (and
      (and
        (=
          ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@519@04))
          ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@520@04)))
        (< i2@520@04 V@15@04))
      (<= 0 i2@520@04))
    (< i1@519@04 V@15@04))
  (<= 0 i1@519@04)))
; [eval] i1 == i2
(pop) ; 19
(push) ; 19
; [else-branch: 279 | !(Lookup(option$array$,sm@446@04,aloc((_, _), opt_get1(_, G@11@04), i1@519@04)) == Lookup(option$array$,sm@446@04,aloc((_, _), opt_get1(_, G@11@04), i2@520@04)) && i2@520@04 < V@15@04 && 0 <= i2@520@04 && i1@519@04 < V@15@04 && 0 <= i1@519@04)]
(assert (not
  (and
    (and
      (and
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@519@04))
            ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@520@04)))
          (< i2@520@04 V@15@04))
        (<= 0 i2@520@04))
      (< i1@519@04 V@15@04))
    (<= 0 i1@519@04))))
(pop) ; 19
(pop) ; 18
; Joined path conditions
(assert (implies
  (and
    (and
      (and
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@519@04))
            ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@520@04)))
          (< i2@520@04 V@15@04))
        (<= 0 i2@520@04))
      (< i1@519@04 V@15@04))
    (<= 0 i1@519@04))
  (and
    (=
      ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@519@04))
      ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@520@04)))
    (< i2@520@04 V@15@04)
    (<= 0 i2@520@04)
    (< i1@519@04 V@15@04)
    (<= 0 i1@519@04))))
; Joined path conditions
(pop) ; 17
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i2@520@04 Int)) (!
  (and
    (implies
      (<= 0 i1@519@04)
      (and
        (<= 0 i1@519@04)
        (implies
          (< i1@519@04 V@15@04)
          (and
            (< i1@519@04 V@15@04)
            (implies
              (<= 0 i2@520@04)
              (and
                (<= 0 i2@520@04)
                (implies
                  (< i2@520@04 V@15@04)
                  (and
                    (< i2@520@04 V@15@04)
                    (< i1@519@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
                    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@519@04)) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@519@04))
                    (< i2@520@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
                    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@520@04)) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@520@04))))))))))
    (implies
      (and
        (and
          (and
            (and
              (=
                ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@519@04))
                ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@520@04)))
              (< i2@520@04 V@15@04))
            (<= 0 i2@520@04))
          (< i1@519@04 V@15@04))
        (<= 0 i1@519@04))
      (and
        (=
          ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@519@04))
          ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@520@04)))
        (< i2@520@04 V@15@04)
        (<= 0 i2@520@04)
        (< i1@519@04 V@15@04)
        (<= 0 i1@519@04))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@520@04))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 16
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@519@04 Int)) (!
  (forall ((i2@520@04 Int)) (!
    (and
      (implies
        (<= 0 i1@519@04)
        (and
          (<= 0 i1@519@04)
          (implies
            (< i1@519@04 V@15@04)
            (and
              (< i1@519@04 V@15@04)
              (implies
                (<= 0 i2@520@04)
                (and
                  (<= 0 i2@520@04)
                  (implies
                    (< i2@520@04 V@15@04)
                    (and
                      (< i2@520@04 V@15@04)
                      (< i1@519@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
                      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@519@04)) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@519@04))
                      (< i2@520@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
                      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@520@04)) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@520@04))))))))))
      (implies
        (and
          (and
            (and
              (and
                (=
                  ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@519@04))
                  ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@520@04)))
                (< i2@520@04 V@15@04))
              (<= 0 i2@520@04))
            (< i1@519@04 V@15@04))
          (<= 0 i1@519@04))
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@519@04))
            ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@520@04)))
          (< i2@520@04 V@15@04)
          (<= 0 i2@520@04)
          (< i1@519@04 V@15@04)
          (<= 0 i1@519@04))))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@520@04))
    :qid |prog.l<no position>-aux|))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@519@04))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(push) ; 16
(assert (not (forall ((i1@519@04 Int)) (!
  (forall ((i2@520@04 Int)) (!
    (implies
      (and
        (and
          (and
            (and
              (=
                ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@519@04))
                ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@520@04)))
              (< i2@520@04 V@15@04))
            (<= 0 i2@520@04))
          (< i1@519@04 V@15@04))
        (<= 0 i1@519@04))
      (= i1@519@04 i2@520@04))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@520@04))
    :qid |prog.l<no position>|))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@519@04))
  :qid |prog.l<no position>|))))
(check-sat)
; unsat
(pop) ; 16
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               15982729
;  :arith-add-rows          3537707
;  :arith-assert-diseq      84172
;  :arith-assert-lower      3027659
;  :arith-assert-upper      2649539
;  :arith-bound-prop        80591
;  :arith-conflicts         2110
;  :arith-eq-adapter        1160735
;  :arith-fixed-eqs         2864467
;  :arith-offset-eqs        1742346
;  :arith-pivots            496526
;  :conflicts               5118
;  :datatype-accessor-ax    469
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               617101
;  :del-clause              41604081
;  :final-checks            5
;  :max-generation          14
;  :max-memory              290.14
;  :memory                  266.19
;  :minimized-lits          633
;  :mk-bool-var             36012692
;  :mk-clause               41607336
;  :num-allocs              87231383
;  :num-checks              573
;  :propagations            11928563
;  :quant-instantiations    15055389
;  :restarts                11
;  :rlimit-count            337932046
;  :time                    0.01)
(assert (forall ((i1@519@04 Int)) (!
  (forall ((i2@520@04 Int)) (!
    (implies
      (and
        (and
          (and
            (and
              (=
                ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@519@04))
                ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@520@04)))
              (< i2@520@04 V@15@04))
            (<= 0 i2@520@04))
          (< i1@519@04 V@15@04))
        (<= 0 i1@519@04))
      (= i1@519@04 i2@520@04))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@520@04))
    :qid |prog.l<no position>|))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@519@04))
  :qid |prog.l<no position>|)))
(declare-const i1@521@04 Int)
(declare-const j@522@04 Int)
(push) ; 16
; [eval] 0 <= i1 && i1 < V && (0 <= j && j < V)
; [eval] 0 <= i1
(push) ; 17
; [then-branch: 280 | 0 <= i1@521@04 | live]
; [else-branch: 280 | !(0 <= i1@521@04) | live]
(push) ; 18
; [then-branch: 280 | 0 <= i1@521@04]
(assert (<= 0 i1@521@04))
; [eval] i1 < V
(push) ; 19
; [then-branch: 281 | i1@521@04 < V@15@04 | live]
; [else-branch: 281 | !(i1@521@04 < V@15@04) | live]
(push) ; 20
; [then-branch: 281 | i1@521@04 < V@15@04]
(assert (< i1@521@04 V@15@04))
; [eval] 0 <= j
(push) ; 21
; [then-branch: 282 | 0 <= j@522@04 | live]
; [else-branch: 282 | !(0 <= j@522@04) | live]
(push) ; 22
; [then-branch: 282 | 0 <= j@522@04]
(assert (<= 0 j@522@04))
; [eval] j < V
(pop) ; 22
(push) ; 22
; [else-branch: 282 | !(0 <= j@522@04)]
(assert (not (<= 0 j@522@04)))
(pop) ; 22
(pop) ; 21
; Joined path conditions
; Joined path conditions
(pop) ; 20
(push) ; 20
; [else-branch: 281 | !(i1@521@04 < V@15@04)]
(assert (not (< i1@521@04 V@15@04)))
(pop) ; 20
(pop) ; 19
; Joined path conditions
; Joined path conditions
(pop) ; 18
(push) ; 18
; [else-branch: 280 | !(0 <= i1@521@04)]
(assert (not (<= 0 i1@521@04)))
(pop) ; 18
(pop) ; 17
; Joined path conditions
; Joined path conditions
(assert (and
  (and (and (< j@522@04 V@15@04) (<= 0 j@522@04)) (< i1@521@04 V@15@04))
  (<= 0 i1@521@04)))
; [eval] aloc(opt_get1(aloc(opt_get1(G), i1).option$array$), j)
; [eval] opt_get1(aloc(opt_get1(G), i1).option$array$)
; [eval] aloc(opt_get1(G), i1)
; [eval] opt_get1(G)
(push) ; 17
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 17
; Joined path conditions
(push) ; 17
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 18
(assert (not (< i1@521@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))))
(check-sat)
; unsat
(pop) ; 18
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               15982729
;  :arith-add-rows          3537710
;  :arith-assert-diseq      84172
;  :arith-assert-lower      3027665
;  :arith-assert-upper      2649539
;  :arith-bound-prop        80591
;  :arith-conflicts         2110
;  :arith-eq-adapter        1160735
;  :arith-fixed-eqs         2864467
;  :arith-offset-eqs        1742346
;  :arith-pivots            496527
;  :conflicts               5118
;  :datatype-accessor-ax    469
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               617101
;  :del-clause              41604081
;  :final-checks            5
;  :max-generation          14
;  :max-memory              290.14
;  :memory                  266.19
;  :minimized-lits          633
;  :mk-bool-var             36012701
;  :mk-clause               41607338
;  :num-allocs              87232060
;  :num-checks              574
;  :propagations            11928563
;  :quant-instantiations    15055393
;  :restarts                11
;  :rlimit-count            337933291)
(assert (< i1@521@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(pop) ; 17
; Joined path conditions
(assert (< i1@521@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@521@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@521@04)))
(push) ; 17
(assert (not (ite
  (and
    (<
      (inv@445@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@521@04))
      V@15@04)
    (<=
      0
      (inv@445@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@521@04))))
  (< $Perm.No $k@444@04)
  false)))
(check-sat)
; unsat
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               15982890
;  :arith-add-rows          3537799
;  :arith-assert-diseq      84172
;  :arith-assert-lower      3027688
;  :arith-assert-upper      2649559
;  :arith-bound-prop        80607
;  :arith-conflicts         2111
;  :arith-eq-adapter        1160757
;  :arith-fixed-eqs         2864486
;  :arith-offset-eqs        1742377
;  :arith-pivots            496547
;  :conflicts               5119
;  :datatype-accessor-ax    469
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               617101
;  :del-clause              41604081
;  :final-checks            5
;  :max-generation          14
;  :max-memory              290.14
;  :memory                  266.24
;  :minimized-lits          633
;  :mk-bool-var             36013304
;  :mk-clause               41607778
;  :num-allocs              87234961
;  :num-checks              575
;  :propagations            11928645
;  :quant-instantiations    15055671
;  :restarts                11
;  :rlimit-count            337947585)
(push) ; 17
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 18
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@521@04))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 18
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               15982890
;  :arith-add-rows          3537799
;  :arith-assert-diseq      84172
;  :arith-assert-lower      3027688
;  :arith-assert-upper      2649559
;  :arith-bound-prop        80607
;  :arith-conflicts         2111
;  :arith-eq-adapter        1160757
;  :arith-fixed-eqs         2864486
;  :arith-offset-eqs        1742377
;  :arith-pivots            496547
;  :conflicts               5120
;  :datatype-accessor-ax    469
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               617101
;  :del-clause              41604081
;  :final-checks            5
;  :max-generation          14
;  :max-memory              290.14
;  :memory                  266.24
;  :minimized-lits          633
;  :mk-bool-var             36013304
;  :mk-clause               41607778
;  :num-allocs              87235050
;  :num-checks              576
;  :propagations            11928645
;  :quant-instantiations    15055671
;  :restarts                11
;  :rlimit-count            337947680)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@521@04))
    (as None<option<array>>  option<array>))))
(pop) ; 17
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@521@04))
    (as None<option<array>>  option<array>))))
(push) ; 17
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 18
(assert (not (<
  j@522@04
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@521@04)))))))
(check-sat)
; unsat
(pop) ; 18
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               15982896
;  :arith-add-rows          3537805
;  :arith-assert-diseq      84172
;  :arith-assert-lower      3027690
;  :arith-assert-upper      2649561
;  :arith-bound-prop        80607
;  :arith-conflicts         2112
;  :arith-eq-adapter        1160758
;  :arith-fixed-eqs         2864487
;  :arith-offset-eqs        1742377
;  :arith-pivots            496551
;  :conflicts               5121
;  :datatype-accessor-ax    469
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               617101
;  :del-clause              41604085
;  :final-checks            5
;  :max-generation          14
;  :max-memory              290.14
;  :memory                  266.24
;  :minimized-lits          633
;  :mk-bool-var             36013315
;  :mk-clause               41607782
;  :num-allocs              87235249
;  :num-checks              577
;  :propagations            11928647
;  :quant-instantiations    15055680
;  :restarts                11
;  :rlimit-count            337948251)
(assert (<
  j@522@04
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@521@04))))))
(pop) ; 17
; Joined path conditions
(assert (<
  j@522@04
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@521@04))))))
(pop) ; 16
(declare-fun inv@523@04 ($Ref) Int)
(declare-fun inv@524@04 ($Ref) Int)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(assert (forall ((i1@521@04 Int) (j@522@04 Int)) (!
  (and
    (< i1@521@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@521@04)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@521@04))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@521@04))
        (as None<option<array>>  option<array>)))
    (<
      j@522@04
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@521@04))))))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@521@04))) j@522@04))
  :qid |int-aux|)))
(declare-const sm@525@04 $FVF<Int>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (ite
          (=
            r
            (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) u@496@04))) v1@441@04))
          $Perm.Write
          $Perm.No)
        (pTaken@506@04 r)))
    (=
      ($FVF.lookup_int (as sm@525@04  $FVF<Int>) r)
      ($FVF.lookup_int (as sm@502@04  $FVF<Int>) r)))
  :pattern (($FVF.lookup_int (as sm@525@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int (as sm@502@04  $FVF<Int>) r))
  :qid |qp.fvfValDef383|)))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (-
          (ite
            (and
              (and
                (and (< (inv@454@04 r) V@15@04) (<= 0 (inv@454@04 r)))
                (< (inv@453@04 r) V@15@04))
              (<= 0 (inv@453@04 r)))
            $Perm.Write
            $Perm.No)
          (pTaken@501@04 r))
        (pTaken@507@04 r)))
    (=
      ($FVF.lookup_int (as sm@525@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@525@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))))))) r))
  :qid |qp.fvfValDef384|)))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (ite
          (and (< (inv@457@04 r) V@15@04) (<= 0 (inv@457@04 r)))
          $Perm.Write
          $Perm.No)
        (pTaken@500@04 r)))
    (=
      ($FVF.lookup_int (as sm@525@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04)))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@525@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04)))))))))))))) r))
  :qid |qp.fvfValDef385|)))
(assert (forall ((r $Ref)) (!
  (implies
    (=
      r
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) v1@441@04))) u@496@04))
    (=
      ($FVF.lookup_int (as sm@525@04  $FVF<Int>) r)
      ($FVF.lookup_int (as sm@509@04  $FVF<Int>) r)))
  :pattern (($FVF.lookup_int (as sm@525@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int (as sm@509@04  $FVF<Int>) r))
  :qid |qp.fvfValDef386|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int (as sm@502@04  $FVF<Int>) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04)))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int (as sm@509@04  $FVF<Int>) r) r))
  :pattern (($FVF.lookup_int (as sm@525@04  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef387|)))
; Check receiver injectivity
(push) ; 16
(assert (not (forall ((i11@521@04 Int) (j1@522@04 Int) (i12@521@04 Int) (j2@522@04 Int)) (!
  (implies
    (and
      (and
        (and
          (and
            (and (< j1@522@04 V@15@04) (<= 0 j1@522@04))
            (< i11@521@04 V@15@04))
          (<= 0 i11@521@04))
        ($FVF.loc_int ($FVF.lookup_int (as sm@525@04  $FVF<Int>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i11@521@04))) j1@522@04)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i11@521@04))) j1@522@04)))
      (and
        (and
          (and
            (and (< j2@522@04 V@15@04) (<= 0 j2@522@04))
            (< i12@521@04 V@15@04))
          (<= 0 i12@521@04))
        ($FVF.loc_int ($FVF.lookup_int (as sm@525@04  $FVF<Int>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i12@521@04))) j2@522@04)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i12@521@04))) j2@522@04)))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i11@521@04))) j1@522@04)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i12@521@04))) j2@522@04)))
    (and (= i11@521@04 i12@521@04) (= j1@522@04 j2@522@04)))
  
  :qid |int-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               15983003
;  :arith-add-rows          3537865
;  :arith-assert-diseq      84172
;  :arith-assert-lower      3027698
;  :arith-assert-upper      2649563
;  :arith-bound-prop        80608
;  :arith-conflicts         2112
;  :arith-eq-adapter        1160773
;  :arith-fixed-eqs         2864487
;  :arith-offset-eqs        1742378
;  :arith-pivots            496577
;  :conflicts               5122
;  :datatype-accessor-ax    469
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               617101
;  :del-clause              41605046
;  :final-checks            5
;  :max-generation          14
;  :max-memory              290.14
;  :memory                  266.19
;  :minimized-lits          633
;  :mk-bool-var             36013925
;  :mk-clause               41608313
;  :num-allocs              87239860
;  :num-checks              578
;  :propagations            11928667
;  :quant-instantiations    15055991
;  :restarts                11
;  :rlimit-count            337967073
;  :time                    0.00)
; Definitional axioms for inverse functions
(assert (forall ((i1@521@04 Int) (j@522@04 Int)) (!
  (implies
    (and
      (and (and (< j@522@04 V@15@04) (<= 0 j@522@04)) (< i1@521@04 V@15@04))
      (<= 0 i1@521@04))
    (and
      (=
        (inv@523@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@521@04))) j@522@04))
        i1@521@04)
      (=
        (inv@524@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@521@04))) j@522@04))
        j@522@04)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@521@04))) j@522@04))
  :qid |int-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@524@04 r) V@15@04) (<= 0 (inv@524@04 r)))
        (< (inv@523@04 r) V@15@04))
      (<= 0 (inv@523@04 r)))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) (inv@523@04 r)))) (inv@524@04 r))
      r))
  :pattern ((inv@523@04 r))
  :pattern ((inv@524@04 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@524@04 r) V@15@04) (<= 0 (inv@524@04 r)))
        (< (inv@523@04 r) V@15@04))
      (<= 0 (inv@523@04 r)))
    ($FVF.loc_int ($FVF.lookup_int (as sm@525@04  $FVF<Int>) r) r))
  :pattern ((inv@523@04 r) (inv@524@04 r))
  )))
; Precomputing data for removing quantified permissions
(define-fun pTaken@526@04 ((r $Ref)) $Perm
  (ite
    (and
      (and
        (and (< (inv@524@04 r) V@15@04) (<= 0 (inv@524@04 r)))
        (< (inv@523@04 r) V@15@04))
      (<= 0 (inv@523@04 r)))
    ($Perm.min
      (-
        (ite
          (=
            r
            (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) u@496@04))) v1@441@04))
          $Perm.Write
          $Perm.No)
        (pTaken@506@04 r))
      $Perm.Write)
    $Perm.No))
(define-fun pTaken@527@04 ((r $Ref)) $Perm
  (ite
    (and
      (and
        (and (< (inv@524@04 r) V@15@04) (<= 0 (inv@524@04 r)))
        (< (inv@523@04 r) V@15@04))
      (<= 0 (inv@523@04 r)))
    ($Perm.min
      (-
        (-
          (ite
            (and
              (and
                (and (< (inv@454@04 r) V@15@04) (<= 0 (inv@454@04 r)))
                (< (inv@453@04 r) V@15@04))
              (<= 0 (inv@453@04 r)))
            $Perm.Write
            $Perm.No)
          (pTaken@501@04 r))
        (pTaken@507@04 r))
      (- $Perm.Write (pTaken@526@04 r)))
    $Perm.No))
(define-fun pTaken@528@04 ((r $Ref)) $Perm
  (ite
    (and
      (and
        (and (< (inv@524@04 r) V@15@04) (<= 0 (inv@524@04 r)))
        (< (inv@523@04 r) V@15@04))
      (<= 0 (inv@523@04 r)))
    ($Perm.min
      (-
        (ite
          (and (< (inv@457@04 r) V@15@04) (<= 0 (inv@457@04 r)))
          $Perm.Write
          $Perm.No)
        (pTaken@500@04 r))
      (- (- $Perm.Write (pTaken@526@04 r)) (pTaken@527@04 r)))
    $Perm.No))
(define-fun pTaken@529@04 ((r $Ref)) $Perm
  (ite
    (and
      (and
        (and (< (inv@524@04 r) V@15@04) (<= 0 (inv@524@04 r)))
        (< (inv@523@04 r) V@15@04))
      (<= 0 (inv@523@04 r)))
    ($Perm.min
      (ite
        (=
          r
          (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) v1@441@04))) u@496@04))
        $Perm.Write
        $Perm.No)
      (-
        (- (- $Perm.Write (pTaken@526@04 r)) (pTaken@527@04 r))
        (pTaken@528@04 r)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 500)
(push) ; 16
(assert (not (=
  (-
    (-
      (ite
        (=
          (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) u@496@04))) v1@441@04)
          (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) u@496@04))) v1@441@04))
        $Perm.Write
        $Perm.No)
      (pTaken@506@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) u@496@04))) v1@441@04)))
    (pTaken@526@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) u@496@04))) v1@441@04)))
  $Perm.No)))
(check-sat)
; unsat
(pop) ; 16
; 0.05s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               15985256
;  :arith-add-rows          3539315
;  :arith-assert-diseq      84244
;  :arith-assert-lower      3028199
;  :arith-assert-upper      2649785
;  :arith-bound-prop        80802
;  :arith-conflicts         2116
;  :arith-eq-adapter        1161016
;  :arith-fixed-eqs         2864669
;  :arith-offset-eqs        1742629
;  :arith-pivots            496640
;  :conflicts               5140
;  :datatype-accessor-ax    469
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               617562
;  :del-clause              41618220
;  :final-checks            5
;  :max-generation          14
;  :max-memory              290.14
;  :memory                  266.34
;  :minimized-lits          634
;  :mk-bool-var             36025030
;  :mk-clause               41623188
;  :num-allocs              87272552
;  :num-checks              580
;  :propagations            11931158
;  :quant-instantiations    15058555
;  :restarts                11
;  :rlimit-count            338135190
;  :time                    0.05)
; Intermediate check if already taken enough permissions
(push) ; 16
(assert (not (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@524@04 r) V@15@04) (<= 0 (inv@524@04 r)))
        (< (inv@523@04 r) V@15@04))
      (<= 0 (inv@523@04 r)))
    (= (- $Perm.Write (pTaken@526@04 r)) $Perm.No))
  
  ))))
(check-sat)
; unknown
(pop) ; 16
; 0.50s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               15999409
;  :arith-add-rows          3551872
;  :arith-assert-diseq      84551
;  :arith-assert-lower      3030853
;  :arith-assert-upper      2651554
;  :arith-bound-prop        81451
;  :arith-conflicts         2129
;  :arith-eq-adapter        1163098
;  :arith-fixed-eqs         2866140
;  :arith-offset-eqs        1743413
;  :arith-pivots            498412
;  :conflicts               5173
;  :datatype-accessor-ax    469
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               621165
;  :del-clause              41737538
;  :final-checks            5
;  :max-generation          14
;  :max-memory              290.14
;  :memory                  267.42
;  :minimized-lits          642
;  :mk-bool-var             36120076
;  :mk-clause               41742506
;  :num-allocs              87515585
;  :num-checks              581
;  :propagations            11955075
;  :quant-instantiations    15086815
;  :restarts                11
;  :rlimit-count            339420409
;  :time                    0.50)
; Chunk depleted?
(push) ; 16
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (-
        (-
          (ite
            (and
              (and
                (and (< (inv@454@04 r) V@15@04) (<= 0 (inv@454@04 r)))
                (< (inv@453@04 r) V@15@04))
              (<= 0 (inv@453@04 r)))
            $Perm.Write
            $Perm.No)
          (pTaken@501@04 r))
        (pTaken@507@04 r))
      (pTaken@527@04 r))
    $Perm.No)
  
  ))))
(check-sat)
; unknown
(pop) ; 16
; 0.51s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               16020504
;  :arith-add-rows          3572919
;  :arith-assert-diseq      84998
;  :arith-assert-lower      3034894
;  :arith-assert-upper      2654324
;  :arith-bound-prop        82535
;  :arith-conflicts         2157
;  :arith-eq-adapter        1166080
;  :arith-fixed-eqs         2868765
;  :arith-offset-eqs        1745279
;  :arith-pivots            500945
;  :conflicts               5247
;  :datatype-accessor-ax    469
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               626907
;  :del-clause              41883093
;  :final-checks            5
;  :max-generation          14
;  :max-memory              290.14
;  :memory                  266.88
;  :minimized-lits          657
;  :mk-bool-var             36233358
;  :mk-clause               41888061
;  :num-allocs              87790039
;  :num-checks              582
;  :propagations            11984178
;  :quant-instantiations    15115784
;  :restarts                11
;  :rlimit-count            340949862
;  :time                    0.51)
; Intermediate check if already taken enough permissions
(push) ; 16
(assert (not (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@524@04 r) V@15@04) (<= 0 (inv@524@04 r)))
        (< (inv@523@04 r) V@15@04))
      (<= 0 (inv@523@04 r)))
    (= (- (- $Perm.Write (pTaken@526@04 r)) (pTaken@527@04 r)) $Perm.No))
  
  ))))
(check-sat)
; unknown
(pop) ; 16
; 0.52s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               16037745
;  :arith-add-rows          3587823
;  :arith-assert-diseq      85363
;  :arith-assert-lower      3037939
;  :arith-assert-upper      2656394
;  :arith-bound-prop        83104
;  :arith-conflicts         2175
;  :arith-eq-adapter        1168196
;  :arith-fixed-eqs         2870552
;  :arith-offset-eqs        1746209
;  :arith-pivots            502643
;  :conflicts               5289
;  :datatype-accessor-ax    469
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               632104
;  :del-clause              42037762
;  :final-checks            5
;  :max-generation          14
;  :max-memory              290.14
;  :memory                  267.55
;  :minimized-lits          663
;  :mk-bool-var             36349986
;  :mk-clause               42042730
;  :num-allocs              88069767
;  :num-checks              583
;  :propagations            12013666
;  :quant-instantiations    15147974
;  :restarts                11
;  :rlimit-count            342358891
;  :time                    0.52)
; Chunk depleted?
(push) ; 16
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (-
        (ite
          (and (< (inv@457@04 r) V@15@04) (<= 0 (inv@457@04 r)))
          $Perm.Write
          $Perm.No)
        (pTaken@500@04 r))
      (pTaken@528@04 r))
    $Perm.No)
  
  ))))
(check-sat)
; unknown
(pop) ; 16
; 0.50s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               16056728
;  :arith-add-rows          3603241
;  :arith-assert-diseq      85652
;  :arith-assert-lower      3041466
;  :arith-assert-upper      2658784
;  :arith-bound-prop        84012
;  :arith-conflicts         2194
;  :arith-eq-adapter        1170989
;  :arith-fixed-eqs         2872716
;  :arith-offset-eqs        1748043
;  :arith-pivots            505541
;  :conflicts               5334
;  :datatype-accessor-ax    469
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               635715
;  :del-clause              42170428
;  :final-checks            5
;  :max-generation          14
;  :max-memory              290.14
;  :memory                  266.93
;  :minimized-lits          669
;  :mk-bool-var             36460559
;  :mk-clause               42175396
;  :num-allocs              88348366
;  :num-checks              584
;  :propagations            12041444
;  :quant-instantiations    15182646
;  :restarts                11
;  :rlimit-count            343784865
;  :time                    0.50)
; Intermediate check if already taken enough permissions
(push) ; 16
(assert (not (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@524@04 r) V@15@04) (<= 0 (inv@524@04 r)))
        (< (inv@523@04 r) V@15@04))
      (<= 0 (inv@523@04 r)))
    (=
      (-
        (- (- $Perm.Write (pTaken@526@04 r)) (pTaken@527@04 r))
        (pTaken@528@04 r))
      $Perm.No))
  
  ))))
(check-sat)
; unknown
(pop) ; 16
; 0.50s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               16074881
;  :arith-add-rows          3618876
;  :arith-assert-diseq      86018
;  :arith-assert-lower      3044302
;  :arith-assert-upper      2660818
;  :arith-bound-prop        84740
;  :arith-conflicts         2217
;  :arith-eq-adapter        1173227
;  :arith-fixed-eqs         2874500
;  :arith-offset-eqs        1748993
;  :arith-pivots            507370
;  :conflicts               5387
;  :datatype-accessor-ax    469
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               640664
;  :del-clause              42322084
;  :final-checks            5
;  :max-generation          14
;  :max-memory              290.14
;  :memory                  266.99
;  :minimized-lits          691
;  :mk-bool-var             36576257
;  :mk-clause               42327052
;  :num-allocs              88626846
;  :num-checks              585
;  :propagations            12070526
;  :quant-instantiations    15214903
;  :restarts                11
;  :rlimit-count            345227253
;  :time                    0.50)
; Chunk depleted?
(push) ; 16
(assert (not (=
  (-
    (ite
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) v1@441@04))) u@496@04)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) v1@441@04))) u@496@04))
      $Perm.Write
      $Perm.No)
    (pTaken@529@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) v1@441@04))) u@496@04)))
  $Perm.No)))
(check-sat)
; unknown
(pop) ; 16
; 0.50s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               16092109
;  :arith-add-rows          3635563
;  :arith-assert-diseq      86381
;  :arith-assert-lower      3047332
;  :arith-assert-upper      2662929
;  :arith-bound-prop        85468
;  :arith-conflicts         2235
;  :arith-eq-adapter        1175558
;  :arith-fixed-eqs         2876375
;  :arith-offset-eqs        1750032
;  :arith-pivots            509334
;  :conflicts               5430
;  :datatype-accessor-ax    469
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               645708
;  :del-clause              42474759
;  :final-checks            5
;  :max-generation          14
;  :max-memory              290.14
;  :memory                  267.11
;  :minimized-lits          698
;  :mk-bool-var             36693853
;  :mk-clause               42479727
;  :num-allocs              88904089
;  :num-checks              586
;  :propagations            12099190
;  :quant-instantiations    15247288
;  :restarts                11
;  :rlimit-count            346614458
;  :time                    0.50)
; Intermediate check if already taken enough permissions
(push) ; 16
(assert (not (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@524@04 r) V@15@04) (<= 0 (inv@524@04 r)))
        (< (inv@523@04 r) V@15@04))
      (<= 0 (inv@523@04 r)))
    (=
      (-
        (-
          (- (- $Perm.Write (pTaken@526@04 r)) (pTaken@527@04 r))
          (pTaken@528@04 r))
        (pTaken@529@04 r))
      $Perm.No))
  
  ))))
(check-sat)
; unsat
(pop) ; 16
; 0.33s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               16104679
;  :arith-add-rows          3646049
;  :arith-assert-diseq      86731
;  :arith-assert-lower      3049389
;  :arith-assert-upper      2664166
;  :arith-bound-prop        85777
;  :arith-conflicts         2257
;  :arith-eq-adapter        1176913
;  :arith-fixed-eqs         2877371
;  :arith-offset-eqs        1750939
;  :arith-pivots            509926
;  :conflicts               5487
;  :datatype-accessor-ax    469
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               649963
;  :del-clause              42583688
;  :final-checks            5
;  :max-generation          14
;  :max-memory              290.14
;  :memory                  267.63
;  :minimized-lits          710
;  :mk-bool-var             36768860
;  :mk-clause               42588656
;  :num-allocs              89075849
;  :num-checks              587
;  :propagations            12117013
;  :quant-instantiations    15263658
;  :restarts                11
;  :rlimit-count            347369379
;  :time                    0.33)
; Final check if taken enough permissions
; Done removing quantified permissions
; Definitional axioms for snapshot map values
; [eval] P != (None(): option[array])
; [eval] (None(): option[array])
; [eval] alen(opt_get1(P)) == V
; [eval] alen(opt_get1(P))
; [eval] opt_get1(P)
(push) ; 16
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 16
; Joined path conditions
(declare-const i1@530@04 Int)
(push) ; 16
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 17
; [then-branch: 283 | 0 <= i1@530@04 | live]
; [else-branch: 283 | !(0 <= i1@530@04) | live]
(push) ; 18
; [then-branch: 283 | 0 <= i1@530@04]
(assert (<= 0 i1@530@04))
; [eval] i1 < V
(pop) ; 18
(push) ; 18
; [else-branch: 283 | !(0 <= i1@530@04)]
(assert (not (<= 0 i1@530@04)))
(pop) ; 18
(pop) ; 17
; Joined path conditions
; Joined path conditions
(assert (and (< i1@530@04 V@15@04) (<= 0 i1@530@04)))
; [eval] aloc(opt_get1(P), i1)
; [eval] opt_get1(P)
(push) ; 17
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 17
; Joined path conditions
(push) ; 17
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 18
(assert (not (< i1@530@04 (alen<Int> (opt_get1 $Snap.unit P@14@04)))))
(check-sat)
; unsat
(pop) ; 18
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               16104679
;  :arith-add-rows          3646050
;  :arith-assert-diseq      86731
;  :arith-assert-lower      3049391
;  :arith-assert-upper      2664166
;  :arith-bound-prop        85777
;  :arith-conflicts         2257
;  :arith-eq-adapter        1176913
;  :arith-fixed-eqs         2877371
;  :arith-offset-eqs        1750939
;  :arith-pivots            509927
;  :conflicts               5487
;  :datatype-accessor-ax    469
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               649963
;  :del-clause              42583688
;  :final-checks            5
;  :max-generation          14
;  :max-memory              290.14
;  :memory                  267.63
;  :minimized-lits          710
;  :mk-bool-var             36768862
;  :mk-clause               42588656
;  :num-allocs              89075959
;  :num-checks              588
;  :propagations            12117013
;  :quant-instantiations    15263658
;  :restarts                11
;  :rlimit-count            347369570)
(assert (< i1@530@04 (alen<Int> (opt_get1 $Snap.unit P@14@04))))
(pop) ; 17
; Joined path conditions
(assert (< i1@530@04 (alen<Int> (opt_get1 $Snap.unit P@14@04))))
(pop) ; 16
(declare-fun inv@531@04 ($Ref) Int)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(assert (forall ((i1@530@04 Int)) (!
  (< i1@530@04 (alen<Int> (opt_get1 $Snap.unit P@14@04)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i1@530@04))
  :qid |int-aux|)))
(declare-const sm@532@04 $FVF<Int>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (ite
          (=
            r
            (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) v1@441@04))) u@496@04))
          $Perm.Write
          $Perm.No)
        (pTaken@529@04 r)))
    (=
      ($FVF.lookup_int (as sm@532@04  $FVF<Int>) r)
      ($FVF.lookup_int (as sm@509@04  $FVF<Int>) r)))
  :pattern (($FVF.lookup_int (as sm@532@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int (as sm@509@04  $FVF<Int>) r))
  :qid |qp.fvfValDef388|)))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (-
          (ite
            (and (< (inv@457@04 r) V@15@04) (<= 0 (inv@457@04 r)))
            $Perm.Write
            $Perm.No)
          (pTaken@500@04 r))
        (pTaken@528@04 r)))
    (=
      ($FVF.lookup_int (as sm@532@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04)))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@532@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04)))))))))))))) r))
  :qid |qp.fvfValDef389|)))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (-
          (-
            (ite
              (and
                (and
                  (and (< (inv@454@04 r) V@15@04) (<= 0 (inv@454@04 r)))
                  (< (inv@453@04 r) V@15@04))
                (<= 0 (inv@453@04 r)))
              $Perm.Write
              $Perm.No)
            (pTaken@501@04 r))
          (pTaken@507@04 r))
        (pTaken@527@04 r)))
    (=
      ($FVF.lookup_int (as sm@532@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@532@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))))))) r))
  :qid |qp.fvfValDef390|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int (as sm@509@04  $FVF<Int>) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04)))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@532@04  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef391|)))
; Check receiver injectivity
(push) ; 16
(assert (not (forall ((i11@530@04 Int) (i12@530@04 Int)) (!
  (implies
    (and
      (and
        (and (< i11@530@04 V@15@04) (<= 0 i11@530@04))
        ($FVF.loc_int ($FVF.lookup_int (as sm@532@04  $FVF<Int>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit P@14@04) i11@530@04)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit P@14@04) i11@530@04)))
      (and
        (and (< i12@530@04 V@15@04) (<= 0 i12@530@04))
        ($FVF.loc_int ($FVF.lookup_int (as sm@532@04  $FVF<Int>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit P@14@04) i12@530@04)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit P@14@04) i12@530@04)))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i11@530@04)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i12@530@04)))
    (= i11@530@04 i12@530@04))
  
  :qid |int-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 16
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               16104752
;  :arith-add-rows          3646081
;  :arith-assert-diseq      86732
;  :arith-assert-lower      3049397
;  :arith-assert-upper      2664168
;  :arith-bound-prop        85778
;  :arith-conflicts         2257
;  :arith-eq-adapter        1176916
;  :arith-fixed-eqs         2877373
;  :arith-offset-eqs        1750941
;  :arith-pivots            509932
;  :conflicts               5488
;  :datatype-accessor-ax    469
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               649963
;  :del-clause              42583754
;  :final-checks            5
;  :max-generation          14
;  :max-memory              290.14
;  :memory                  267.28
;  :minimized-lits          710
;  :mk-bool-var             36769107
;  :mk-clause               42588792
;  :num-allocs              89078845
;  :num-checks              589
;  :propagations            12117016
;  :quant-instantiations    15263772
;  :restarts                11
;  :rlimit-count            347381875
;  :time                    0.01)
; Definitional axioms for inverse functions
(assert (forall ((i1@530@04 Int)) (!
  (implies
    (and (< i1@530@04 V@15@04) (<= 0 i1@530@04))
    (=
      (inv@531@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i1@530@04))
      i1@530@04))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i1@530@04))
  :qid |int-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@531@04 r) V@15@04) (<= 0 (inv@531@04 r)))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) (inv@531@04 r))
      r))
  :pattern ((inv@531@04 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@531@04 r) V@15@04) (<= 0 (inv@531@04 r)))
    ($FVF.loc_int ($FVF.lookup_int (as sm@532@04  $FVF<Int>) r) r))
  :pattern ((inv@531@04 r))
  )))
; Precomputing data for removing quantified permissions
(define-fun pTaken@533@04 ((r $Ref)) $Perm
  (ite
    (and (< (inv@531@04 r) V@15@04) (<= 0 (inv@531@04 r)))
    ($Perm.min
      (-
        (ite
          (=
            r
            (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) v1@441@04))) u@496@04))
          $Perm.Write
          $Perm.No)
        (pTaken@529@04 r))
      $Perm.Write)
    $Perm.No))
(define-fun pTaken@534@04 ((r $Ref)) $Perm
  (ite
    (and (< (inv@531@04 r) V@15@04) (<= 0 (inv@531@04 r)))
    ($Perm.min
      (-
        (-
          (ite
            (and (< (inv@457@04 r) V@15@04) (<= 0 (inv@457@04 r)))
            $Perm.Write
            $Perm.No)
          (pTaken@500@04 r))
        (pTaken@528@04 r))
      (- $Perm.Write (pTaken@533@04 r)))
    $Perm.No))
(define-fun pTaken@535@04 ((r $Ref)) $Perm
  (ite
    (and (< (inv@531@04 r) V@15@04) (<= 0 (inv@531@04 r)))
    ($Perm.min
      (-
        (-
          (-
            (ite
              (and
                (and
                  (and (< (inv@454@04 r) V@15@04) (<= 0 (inv@454@04 r)))
                  (< (inv@453@04 r) V@15@04))
                (<= 0 (inv@453@04 r)))
              $Perm.Write
              $Perm.No)
            (pTaken@501@04 r))
          (pTaken@507@04 r))
        (pTaken@527@04 r))
      (- (- $Perm.Write (pTaken@533@04 r)) (pTaken@534@04 r)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 500)
(push) ; 16
(assert (not (=
  (-
    (-
      (ite
        (=
          (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) v1@441@04))) u@496@04)
          (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) v1@441@04))) u@496@04))
        $Perm.Write
        $Perm.No)
      (pTaken@529@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) v1@441@04))) u@496@04)))
    (pTaken@533@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) v1@441@04))) u@496@04)))
  $Perm.No)))
(check-sat)
; unsat
(pop) ; 16
; 0.14s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               16113794
;  :arith-add-rows          3666900
;  :arith-assert-diseq      87056
;  :arith-assert-lower      3051277
;  :arith-assert-upper      2665297
;  :arith-bound-prop        86090
;  :arith-conflicts         2284
;  :arith-eq-adapter        1178144
;  :arith-fixed-eqs         2878208
;  :arith-offset-eqs        1751924
;  :arith-pivots            510546
;  :conflicts               5550
;  :datatype-accessor-ax    469
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               652132
;  :del-clause              42630895
;  :final-checks            5
;  :max-generation          14
;  :max-memory              290.14
;  :memory                  267.14
;  :minimized-lits          717
;  :mk-bool-var             36803929
;  :mk-clause               42635359
;  :num-allocs              89157721
;  :num-checks              591
;  :propagations            12126280
;  :quant-instantiations    15271112
;  :restarts                11
;  :rlimit-count            348191702
;  :time                    0.14)
; Intermediate check if already taken enough permissions
(push) ; 16
(assert (not (forall ((r $Ref)) (!
  (implies
    (and (< (inv@531@04 r) V@15@04) (<= 0 (inv@531@04 r)))
    (= (- $Perm.Write (pTaken@533@04 r)) $Perm.No))
  
  ))))
(check-sat)
; unknown
(pop) ; 16
; 0.51s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               16132839
;  :arith-add-rows          3686287
;  :arith-assert-diseq      87479
;  :arith-assert-lower      3054738
;  :arith-assert-upper      2667671
;  :arith-bound-prop        86781
;  :arith-conflicts         2310
;  :arith-eq-adapter        1180761
;  :arith-fixed-eqs         2880030
;  :arith-offset-eqs        1753100
;  :arith-pivots            512549
;  :conflicts               5605
;  :datatype-accessor-ax    469
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               658187
;  :del-clause              42790670
;  :final-checks            5
;  :max-generation          14
;  :max-memory              290.14
;  :memory                  267.19
;  :minimized-lits          723
;  :mk-bool-var             36926584
;  :mk-clause               42795134
;  :num-allocs              89408845
;  :num-checks              592
;  :propagations            12156876
;  :quant-instantiations    15303696
;  :restarts                11
;  :rlimit-count            349601897
;  :time                    0.51)
; Chunk depleted?
(push) ; 16
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (-
        (-
          (ite
            (and (< (inv@457@04 r) V@15@04) (<= 0 (inv@457@04 r)))
            $Perm.Write
            $Perm.No)
          (pTaken@500@04 r))
        (pTaken@528@04 r))
      (pTaken@534@04 r))
    $Perm.No)
  
  ))))
(check-sat)
; unsat
(pop) ; 16
; 0.04s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               16136249
;  :arith-add-rows          3689607
;  :arith-assert-diseq      87549
;  :arith-assert-lower      3055219
;  :arith-assert-upper      2668088
;  :arith-bound-prop        87042
;  :arith-conflicts         2326
;  :arith-eq-adapter        1181214
;  :arith-fixed-eqs         2880411
;  :arith-offset-eqs        1753740
;  :arith-pivots            513039
;  :conflicts               5645
;  :datatype-accessor-ax    469
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               658230
;  :del-clause              42793227
;  :final-checks            5
;  :max-generation          14
;  :max-memory              290.14
;  :memory                  267.23
;  :minimized-lits          727
;  :mk-bool-var             36930525
;  :mk-clause               42797691
;  :num-allocs              89424733
;  :num-checks              593
;  :propagations            12157909
;  :quant-instantiations    15304641
;  :restarts                11
;  :rlimit-count            349716977
;  :time                    0.04)
; Intermediate check if already taken enough permissions
(push) ; 16
(assert (not (forall ((r $Ref)) (!
  (implies
    (and (< (inv@531@04 r) V@15@04) (<= 0 (inv@531@04 r)))
    (= (- (- $Perm.Write (pTaken@533@04 r)) (pTaken@534@04 r)) $Perm.No))
  
  ))))
(check-sat)
; unknown
(pop) ; 16
; 0.50s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               16158979
;  :arith-add-rows          3717112
;  :arith-assert-diseq      88278
;  :arith-assert-lower      3059229
;  :arith-assert-upper      2670981
;  :arith-bound-prop        87678
;  :arith-conflicts         2361
;  :arith-eq-adapter        1183853
;  :arith-fixed-eqs         2882565
;  :arith-offset-eqs        1754914
;  :arith-pivots            514287
;  :conflicts               5725
;  :datatype-accessor-ax    469
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               667932
;  :del-clause              42982130
;  :final-checks            5
;  :max-generation          14
;  :max-memory              290.14
;  :memory                  267.53
;  :minimized-lits          747
;  :mk-bool-var             37063751
;  :mk-clause               42986594
;  :num-allocs              89706676
;  :num-checks              594
;  :propagations            12193654
;  :quant-instantiations    15332100
;  :restarts                11
;  :rlimit-count            351504026
;  :time                    0.50)
; Chunk depleted?
(push) ; 16
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (-
        (-
          (-
            (ite
              (and
                (and
                  (and (< (inv@454@04 r) V@15@04) (<= 0 (inv@454@04 r)))
                  (< (inv@453@04 r) V@15@04))
                (<= 0 (inv@453@04 r)))
              $Perm.Write
              $Perm.No)
            (pTaken@501@04 r))
          (pTaken@507@04 r))
        (pTaken@527@04 r))
      (pTaken@535@04 r))
    $Perm.No)
  
  ))))
(check-sat)
; unsat
(pop) ; 16
; 0.07s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               16162686
;  :arith-add-rows          3722703
;  :arith-assert-diseq      88440
;  :arith-assert-lower      3060202
;  :arith-assert-upper      2671629
;  :arith-bound-prop        87991
;  :arith-conflicts         2377
;  :arith-eq-adapter        1184529
;  :arith-fixed-eqs         2883171
;  :arith-offset-eqs        1755507
;  :arith-pivots            514773
;  :conflicts               5771
;  :datatype-accessor-ax    469
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               668413
;  :del-clause              42997157
;  :final-checks            5
;  :max-generation          14
;  :max-memory              290.14
;  :memory                  267.52
;  :minimized-lits          749
;  :mk-bool-var             37076206
;  :mk-clause               43001621
;  :num-allocs              89747531
;  :num-checks              595
;  :propagations            12196798
;  :quant-instantiations    15335036
;  :restarts                11
;  :rlimit-count            351766281
;  :time                    0.07)
; Intermediate check if already taken enough permissions
(push) ; 16
(assert (not (forall ((r $Ref)) (!
  (implies
    (and (< (inv@531@04 r) V@15@04) (<= 0 (inv@531@04 r)))
    (=
      (-
        (- (- $Perm.Write (pTaken@533@04 r)) (pTaken@534@04 r))
        (pTaken@535@04 r))
      $Perm.No))
  
  ))))
(check-sat)
; unknown
(pop) ; 16
; 0.50s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               16183815
;  :arith-add-rows          3752350
;  :arith-assert-diseq      89031
;  :arith-assert-lower      3063989
;  :arith-assert-upper      2674419
;  :arith-bound-prop        88448
;  :arith-conflicts         2411
;  :arith-eq-adapter        1187142
;  :arith-fixed-eqs         2885511
;  :arith-offset-eqs        1756515
;  :arith-pivots            515915
;  :conflicts               5849
;  :datatype-accessor-ax    469
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               677855
;  :del-clause              43183042
;  :final-checks            5
;  :max-generation          14
;  :max-memory              290.14
;  :memory                  267.51
;  :minimized-lits          769
;  :mk-bool-var             37210396
;  :mk-clause               43187506
;  :num-allocs              89973404
;  :num-checks              596
;  :propagations            12232831
;  :quant-instantiations    15364699
;  :restarts                11
;  :rlimit-count            353371790
;  :time                    0.50)
; Final check if taken enough permissions
(set-option :timeout 0)
(push) ; 16
(assert (not (forall ((r $Ref)) (!
  (implies
    (and (< (inv@531@04 r) V@15@04) (<= 0 (inv@531@04 r)))
    (=
      (-
        (- (- $Perm.Write (pTaken@533@04 r)) (pTaken@534@04 r))
        (pTaken@535@04 r))
      $Perm.No))
  
  ))))
(check-sat)
; unsat
(pop) ; 16
; 0.57s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               16218609
;  :arith-add-rows          3778767
;  :arith-assert-diseq      89765
;  :arith-assert-lower      3069849
;  :arith-assert-upper      2679015
;  :arith-bound-prop        89380
;  :arith-conflicts         2465
;  :arith-eq-adapter        1191146
;  :arith-fixed-eqs         2889930
;  :arith-offset-eqs        1759545
;  :arith-pivots            517565
;  :conflicts               5966
;  :datatype-accessor-ax    469
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               686701
;  :del-clause              43370891
;  :final-checks            5
;  :max-generation          14
;  :max-memory              290.14
;  :memory                  268.16
;  :minimized-lits          804
;  :mk-bool-var             37348261
;  :mk-clause               43375355
;  :num-allocs              90203555
;  :num-checks              597
;  :propagations            12272944
;  :quant-instantiations    15396273
;  :restarts                12
;  :rlimit-count            354738977
;  :time                    0.57)
; Done removing quantified permissions
; Definitional axioms for snapshot map values
; [eval] valid_graph_vertices(this, P, V)
(push) ; 16
; [eval] this != null
; [eval] p != (None(): option[array])
; [eval] (None(): option[array])
; [eval] alen(opt_get1(p)) == V
; [eval] alen(opt_get1(p))
; [eval] opt_get1(p)
(push) ; 17
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 17
; Joined path conditions
(declare-const i1@536@04 Int)
(push) ; 17
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 18
; [then-branch: 284 | 0 <= i1@536@04 | live]
; [else-branch: 284 | !(0 <= i1@536@04) | live]
(push) ; 19
; [then-branch: 284 | 0 <= i1@536@04]
(assert (<= 0 i1@536@04))
; [eval] i1 < V
(pop) ; 19
(push) ; 19
; [else-branch: 284 | !(0 <= i1@536@04)]
(assert (not (<= 0 i1@536@04)))
(pop) ; 19
(pop) ; 18
; Joined path conditions
; Joined path conditions
(assert (and (< i1@536@04 V@15@04) (<= 0 i1@536@04)))
(declare-const $k@537@04 $Perm)
(assert ($Perm.isReadVar $k@537@04 $Perm.Write))
; [eval] aloc(opt_get1(p), i1)
; [eval] opt_get1(p)
(push) ; 18
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 18
; Joined path conditions
(push) ; 18
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 19
(assert (not (< i1@536@04 (alen<Int> (opt_get1 $Snap.unit P@14@04)))))
(check-sat)
; unsat
(pop) ; 19
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               16218609
;  :arith-add-rows          3778768
;  :arith-assert-diseq      89766
;  :arith-assert-lower      3069853
;  :arith-assert-upper      2679016
;  :arith-bound-prop        89380
;  :arith-conflicts         2465
;  :arith-eq-adapter        1191147
;  :arith-fixed-eqs         2889930
;  :arith-offset-eqs        1759545
;  :arith-pivots            517566
;  :conflicts               5966
;  :datatype-accessor-ax    469
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               686701
;  :del-clause              43370891
;  :final-checks            5
;  :max-generation          14
;  :max-memory              290.14
;  :memory                  268.16
;  :minimized-lits          804
;  :mk-bool-var             37348267
;  :mk-clause               43375357
;  :num-allocs              90203730
;  :num-checks              598
;  :propagations            12272945
;  :quant-instantiations    15396273
;  :restarts                12
;  :rlimit-count            354739315)
(assert (< i1@536@04 (alen<Int> (opt_get1 $Snap.unit P@14@04))))
(pop) ; 18
; Joined path conditions
(assert (< i1@536@04 (alen<Int> (opt_get1 $Snap.unit P@14@04))))
(pop) ; 17
(declare-fun inv@538@04 ($Ref) Int)
; Nested auxiliary terms: globals
(assert ($Perm.isReadVar $k@537@04 $Perm.Write))
; Nested auxiliary terms: non-globals
(assert (forall ((i1@536@04 Int)) (!
  (< i1@536@04 (alen<Int> (opt_get1 $Snap.unit P@14@04)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i1@536@04))
  :qid |int-aux|)))
(push) ; 17
(assert (not (forall ((i1@536@04 Int)) (!
  (implies
    (and (< i1@536@04 V@15@04) (<= 0 i1@536@04))
    (or (= $k@537@04 $Perm.No) (< $Perm.No $k@537@04)))
  
  ))))
(check-sat)
; unsat
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               16218609
;  :arith-add-rows          3778769
;  :arith-assert-diseq      89767
;  :arith-assert-lower      3069855
;  :arith-assert-upper      2679017
;  :arith-bound-prop        89380
;  :arith-conflicts         2465
;  :arith-eq-adapter        1191148
;  :arith-fixed-eqs         2889930
;  :arith-offset-eqs        1759545
;  :arith-pivots            517567
;  :conflicts               5967
;  :datatype-accessor-ax    469
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               686701
;  :del-clause              43370893
;  :final-checks            5
;  :max-generation          14
;  :max-memory              290.14
;  :memory                  268.16
;  :minimized-lits          804
;  :mk-bool-var             37348274
;  :mk-clause               43375359
;  :num-allocs              90204161
;  :num-checks              599
;  :propagations            12272946
;  :quant-instantiations    15396274
;  :restarts                12
;  :rlimit-count            354739875)
(declare-const sm@539@04 $FVF<Int>)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (=
      r
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) v1@441@04))) u@496@04))
    (=
      ($FVF.lookup_int (as sm@539@04  $FVF<Int>) r)
      ($FVF.lookup_int (as sm@509@04  $FVF<Int>) r)))
  :pattern (($FVF.lookup_int (as sm@539@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int (as sm@509@04  $FVF<Int>) r))
  :qid |qp.fvfValDef392|)))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (ite
          (and (< (inv@457@04 r) V@15@04) (<= 0 (inv@457@04 r)))
          $Perm.Write
          $Perm.No)
        (pTaken@500@04 r)))
    (=
      ($FVF.lookup_int (as sm@539@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04)))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@539@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04)))))))))))))) r))
  :qid |qp.fvfValDef393|)))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (-
          (ite
            (and
              (and
                (and (< (inv@454@04 r) V@15@04) (<= 0 (inv@454@04 r)))
                (< (inv@453@04 r) V@15@04))
              (<= 0 (inv@453@04 r)))
            $Perm.Write
            $Perm.No)
          (pTaken@501@04 r))
        (pTaken@507@04 r)))
    (=
      ($FVF.lookup_int (as sm@539@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@539@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))))))) r))
  :qid |qp.fvfValDef394|)))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (ite
          (=
            r
            (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) u@496@04))) v1@441@04))
          $Perm.Write
          $Perm.No)
        (pTaken@506@04 r)))
    (=
      ($FVF.lookup_int (as sm@539@04  $FVF<Int>) r)
      ($FVF.lookup_int (as sm@502@04  $FVF<Int>) r)))
  :pattern (($FVF.lookup_int (as sm@539@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int (as sm@502@04  $FVF<Int>) r))
  :qid |qp.fvfValDef395|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int (as sm@509@04  $FVF<Int>) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04)))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int (as sm@502@04  $FVF<Int>) r) r))
  :pattern (($FVF.lookup_int (as sm@539@04  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef396|)))
; Check receiver injectivity
(push) ; 17
(assert (not (forall ((i11@536@04 Int) (i12@536@04 Int)) (!
  (implies
    (and
      (and
        (and
          (and (< i11@536@04 V@15@04) (<= 0 i11@536@04))
          ($FVF.loc_int ($FVF.lookup_int (as sm@539@04  $FVF<Int>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit P@14@04) i11@536@04)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit P@14@04) i11@536@04)))
        (< $Perm.No $k@537@04))
      (and
        (and
          (and (< i12@536@04 V@15@04) (<= 0 i12@536@04))
          ($FVF.loc_int ($FVF.lookup_int (as sm@539@04  $FVF<Int>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit P@14@04) i12@536@04)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit P@14@04) i12@536@04)))
        (< $Perm.No $k@537@04))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i11@536@04)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i12@536@04)))
    (= i11@536@04 i12@536@04))
  
  :qid |int-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 17
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               16218680
;  :arith-add-rows          3778778
;  :arith-assert-diseq      89768
;  :arith-assert-lower      3069859
;  :arith-assert-upper      2679017
;  :arith-bound-prop        89380
;  :arith-conflicts         2465
;  :arith-eq-adapter        1191149
;  :arith-fixed-eqs         2889930
;  :arith-offset-eqs        1759545
;  :arith-pivots            517569
;  :conflicts               5968
;  :datatype-accessor-ax    469
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               686701
;  :del-clause              43370938
;  :final-checks            5
;  :max-generation          14
;  :max-memory              290.14
;  :memory                  268.16
;  :minimized-lits          804
;  :mk-bool-var             37348415
;  :mk-clause               43375414
;  :num-allocs              90206149
;  :num-checks              600
;  :propagations            12272950
;  :quant-instantiations    15396395
;  :restarts                12
;  :rlimit-count            354747366
;  :time                    0.01)
; Definitional axioms for inverse functions
(assert (forall ((i1@536@04 Int)) (!
  (implies
    (and (and (< i1@536@04 V@15@04) (<= 0 i1@536@04)) (< $Perm.No $k@537@04))
    (=
      (inv@538@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i1@536@04))
      i1@536@04))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i1@536@04))
  :qid |int-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and (< (inv@538@04 r) V@15@04) (<= 0 (inv@538@04 r)))
      (< $Perm.No $k@537@04))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) (inv@538@04 r))
      r))
  :pattern ((inv@538@04 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@538@04 r) V@15@04) (<= 0 (inv@538@04 r)))
    ($FVF.loc_int ($FVF.lookup_int (as sm@539@04  $FVF<Int>) r) r))
  :pattern ((inv@538@04 r))
  )))
; Precomputing data for removing quantified permissions
(define-fun pTaken@540@04 ((r $Ref)) $Perm
  (ite
    (and (< (inv@538@04 r) V@15@04) (<= 0 (inv@538@04 r)))
    ($Perm.min
      (ite
        (=
          r
          (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) v1@441@04))) u@496@04))
        $Perm.Write
        $Perm.No)
      $k@537@04)
    $Perm.No))
(define-fun pTaken@541@04 ((r $Ref)) $Perm
  (ite
    (and (< (inv@538@04 r) V@15@04) (<= 0 (inv@538@04 r)))
    ($Perm.min
      (-
        (ite
          (and (< (inv@457@04 r) V@15@04) (<= 0 (inv@457@04 r)))
          $Perm.Write
          $Perm.No)
        (pTaken@500@04 r))
      (- $k@537@04 (pTaken@540@04 r)))
    $Perm.No))
(define-fun pTaken@542@04 ((r $Ref)) $Perm
  (ite
    (and (< (inv@538@04 r) V@15@04) (<= 0 (inv@538@04 r)))
    ($Perm.min
      (-
        (-
          (ite
            (and
              (and
                (and (< (inv@454@04 r) V@15@04) (<= 0 (inv@454@04 r)))
                (< (inv@453@04 r) V@15@04))
              (<= 0 (inv@453@04 r)))
            $Perm.Write
            $Perm.No)
          (pTaken@501@04 r))
        (pTaken@507@04 r))
      (- (- $k@537@04 (pTaken@540@04 r)) (pTaken@541@04 r)))
    $Perm.No))
(define-fun pTaken@543@04 ((r $Ref)) $Perm
  (ite
    (and (< (inv@538@04 r) V@15@04) (<= 0 (inv@538@04 r)))
    ($Perm.min
      (-
        (ite
          (=
            r
            (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) u@496@04))) v1@441@04))
          $Perm.Write
          $Perm.No)
        (pTaken@506@04 r))
      (- (- (- $k@537@04 (pTaken@540@04 r)) (pTaken@541@04 r)) (pTaken@542@04 r)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Constrain original permissions $k@537@04
(assert (implies
  (not
    (=
      (ite
        (=
          (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) v1@441@04))) u@496@04)
          (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) v1@441@04))) u@496@04))
        $Perm.Write
        $Perm.No)
      $Perm.No))
  (ite
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) v1@441@04))) u@496@04)
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) v1@441@04))) u@496@04))
    (<
      (ite
        (and
          (<
            (inv@538@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) v1@441@04))) u@496@04))
            V@15@04)
          (<=
            0
            (inv@538@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) v1@441@04))) u@496@04))))
        $k@537@04
        $Perm.No)
      $Perm.Write)
    (<
      (ite
        (and
          (<
            (inv@538@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) v1@441@04))) u@496@04))
            V@15@04)
          (<=
            0
            (inv@538@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) v1@441@04))) u@496@04))))
        $k@537@04
        $Perm.No)
      $Perm.No))))
; Intermediate check if already taken enough permissions
(set-option :timeout 500)
(push) ; 17
(assert (not (forall ((r $Ref)) (!
  (implies
    (and (< (inv@538@04 r) V@15@04) (<= 0 (inv@538@04 r)))
    (= (- $k@537@04 (pTaken@540@04 r)) $Perm.No))
  
  ))))
(check-sat)
; unknown
(pop) ; 17
; 0.51s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               16238306
;  :arith-add-rows          3794528
;  :arith-assert-diseq      90153
;  :arith-assert-lower      3073698
;  :arith-assert-upper      2681643
;  :arith-bound-prop        90126
;  :arith-conflicts         2481
;  :arith-eq-adapter        1194052
;  :arith-fixed-eqs         2892154
;  :arith-offset-eqs        1761327
;  :arith-pivots            519836
;  :conflicts               6009
;  :datatype-accessor-ax    469
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               690928
;  :del-clause              43516826
;  :final-checks            5
;  :max-generation          14
;  :max-memory              290.14
;  :memory                  267.63
;  :minimized-lits          809
;  :mk-bool-var             37466095
;  :mk-clause               43521306
;  :num-allocs              90471008
;  :num-checks              602
;  :propagations            12302844
;  :quant-instantiations    15432814
;  :restarts                12
;  :rlimit-count            356114652
;  :time                    0.51)
; Constrain original permissions $k@537@04
(assert (forall ((r $Ref)) (!
  (implies
    (not
      (=
        (-
          (ite
            (and (< (inv@457@04 r) V@15@04) (<= 0 (inv@457@04 r)))
            $Perm.Write
            $Perm.No)
          (pTaken@500@04 r))
        $Perm.No))
    (<
      (ite
        (and (< (inv@538@04 r) V@15@04) (<= 0 (inv@538@04 r)))
        $k@537@04
        $Perm.No)
      (-
        (ite
          (and (< (inv@457@04 r) V@15@04) (<= 0 (inv@457@04 r)))
          $Perm.Write
          $Perm.No)
        (pTaken@500@04 r))))
  :pattern ((inv@457@04 r))
  :pattern ((inv@538@04 r))
  :qid |qp.srp398|)))
; Intermediate check if already taken enough permissions
(push) ; 17
(assert (not (forall ((r $Ref)) (!
  (implies
    (and (< (inv@538@04 r) V@15@04) (<= 0 (inv@538@04 r)))
    (= (- (- $k@537@04 (pTaken@540@04 r)) (pTaken@541@04 r)) $Perm.No))
  
  ))))
(check-sat)
; unknown
(pop) ; 17
; 0.50s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               16258190
;  :arith-add-rows          3823516
;  :arith-assert-diseq      90502
;  :arith-assert-lower      3077154
;  :arith-assert-upper      2684151
;  :arith-bound-prop        90896
;  :arith-conflicts         2504
;  :arith-eq-adapter        1196764
;  :arith-fixed-eqs         2894295
;  :arith-offset-eqs        1762882
;  :arith-pivots            521934
;  :conflicts               6060
;  :datatype-accessor-ax    469
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               695824
;  :del-clause              43669941
;  :final-checks            5
;  :max-generation          14
;  :max-memory              290.14
;  :memory                  267.67
;  :minimized-lits          815
;  :mk-bool-var             37584947
;  :mk-clause               43674429
;  :num-allocs              90750283
;  :num-checks              603
;  :propagations            12331977
;  :quant-instantiations    15466307
;  :restarts                12
;  :rlimit-count            357782620
;  :time                    0.50)
; Constrain original permissions $k@537@04
(assert (forall ((r $Ref)) (!
  (implies
    (not
      (=
        (-
          (-
            (ite
              (and
                (and
                  (and (< (inv@454@04 r) V@15@04) (<= 0 (inv@454@04 r)))
                  (< (inv@453@04 r) V@15@04))
                (<= 0 (inv@453@04 r)))
              $Perm.Write
              $Perm.No)
            (pTaken@501@04 r))
          (pTaken@507@04 r))
        $Perm.No))
    (<
      (ite
        (and (< (inv@538@04 r) V@15@04) (<= 0 (inv@538@04 r)))
        $k@537@04
        $Perm.No)
      (-
        (-
          (ite
            (and
              (and
                (and (< (inv@454@04 r) V@15@04) (<= 0 (inv@454@04 r)))
                (< (inv@453@04 r) V@15@04))
              (<= 0 (inv@453@04 r)))
            $Perm.Write
            $Perm.No)
          (pTaken@501@04 r))
        (pTaken@507@04 r))))
  :pattern ((inv@454@04 r))
  :pattern ((inv@453@04 r))
  :pattern ((inv@538@04 r))
  :qid |qp.srp399|)))
; Intermediate check if already taken enough permissions
(push) ; 17
(assert (not (forall ((r $Ref)) (!
  (implies
    (and (< (inv@538@04 r) V@15@04) (<= 0 (inv@538@04 r)))
    (=
      (- (- (- $k@537@04 (pTaken@540@04 r)) (pTaken@541@04 r)) (pTaken@542@04 r))
      $Perm.No))
  
  ))))
(check-sat)
; unsat
(pop) ; 17
; 0.29s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               16270209
;  :arith-add-rows          3833899
;  :arith-assert-diseq      90963
;  :arith-assert-lower      3079534
;  :arith-assert-upper      2685580
;  :arith-bound-prop        91227
;  :arith-conflicts         2529
;  :arith-eq-adapter        1198278
;  :arith-fixed-eqs         2895322
;  :arith-offset-eqs        1763326
;  :arith-pivots            522383
;  :conflicts               6123
;  :datatype-accessor-ax    469
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               700486
;  :del-clause              43776852
;  :final-checks            5
;  :max-generation          14
;  :max-memory              290.14
;  :memory                  267.94
;  :minimized-lits          839
;  :mk-bool-var             37657618
;  :mk-clause               43781365
;  :num-allocs              90916310
;  :num-checks              604
;  :propagations            12349356
;  :quant-instantiations    15480562
;  :restarts                12
;  :rlimit-count            358515246
;  :time                    0.29)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@544@04 $FVF<Int>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (iff
    (Set_in r ($FVF.domain_int (as sm@544@04  $FVF<Int>)))
    (and
      (and (< (inv@538@04 r) V@15@04) (<= 0 (inv@538@04 r)))
      (< $Perm.No $k@537@04)))
  :pattern ((Set_in r ($FVF.domain_int (as sm@544@04  $FVF<Int>))))
  :qid |qp.fvfDomDef405|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@538@04 r) V@15@04) (<= 0 (inv@538@04 r)))
        (< $Perm.No $k@537@04))
      (=
        r
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) v1@441@04))) u@496@04)))
    (=
      ($FVF.lookup_int (as sm@544@04  $FVF<Int>) r)
      ($FVF.lookup_int (as sm@509@04  $FVF<Int>) r)))
  :pattern (($FVF.lookup_int (as sm@544@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int (as sm@509@04  $FVF<Int>) r))
  :qid |qp.fvfValDef400|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@538@04 r) V@15@04) (<= 0 (inv@538@04 r)))
        (< $Perm.No $k@537@04))
      (<
        $Perm.No
        (-
          (ite
            (and (< (inv@457@04 r) V@15@04) (<= 0 (inv@457@04 r)))
            $Perm.Write
            $Perm.No)
          (pTaken@500@04 r))))
    (=
      ($FVF.lookup_int (as sm@544@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04)))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@544@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04)))))))))))))) r))
  :qid |qp.fvfValDef401|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@538@04 r) V@15@04) (<= 0 (inv@538@04 r)))
        (< $Perm.No $k@537@04))
      (<
        $Perm.No
        (-
          (-
            (ite
              (and
                (and
                  (and (< (inv@454@04 r) V@15@04) (<= 0 (inv@454@04 r)))
                  (< (inv@453@04 r) V@15@04))
                (<= 0 (inv@453@04 r)))
              $Perm.Write
              $Perm.No)
            (pTaken@501@04 r))
          (pTaken@507@04 r))))
    (=
      ($FVF.lookup_int (as sm@544@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@544@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))))))) r))
  :qid |qp.fvfValDef402|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@538@04 r) V@15@04) (<= 0 (inv@538@04 r)))
        (< $Perm.No $k@537@04))
      (<
        $Perm.No
        (-
          (ite
            (=
              r
              (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit G@11@04) u@496@04))) v1@441@04))
            $Perm.Write
            $Perm.No)
          (pTaken@506@04 r))))
    (=
      ($FVF.lookup_int (as sm@544@04  $FVF<Int>) r)
      ($FVF.lookup_int (as sm@502@04  $FVF<Int>) r)))
  :pattern (($FVF.lookup_int (as sm@544@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int (as sm@502@04  $FVF<Int>) r))
  :qid |qp.fvfValDef403|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int (as sm@509@04  $FVF<Int>) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04)))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int (as sm@502@04  $FVF<Int>) r) r))
  :pattern (($FVF.lookup_int (as sm@544@04  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef404|)))
(pop) ; 16
; Joined path conditions
(assert ($Perm.isReadVar $k@537@04 $Perm.Write))
(assert (forall ((r $Ref)) (!
  (implies
    (=
      r
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) v1@441@04))) u@496@04))
    (=
      ($FVF.lookup_int (as sm@539@04  $FVF<Int>) r)
      ($FVF.lookup_int (as sm@509@04  $FVF<Int>) r)))
  :pattern (($FVF.lookup_int (as sm@539@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int (as sm@509@04  $FVF<Int>) r))
  :qid |qp.fvfValDef392|)))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (ite
          (and (< (inv@457@04 r) V@15@04) (<= 0 (inv@457@04 r)))
          $Perm.Write
          $Perm.No)
        (pTaken@500@04 r)))
    (=
      ($FVF.lookup_int (as sm@539@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04)))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@539@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04)))))))))))))) r))
  :qid |qp.fvfValDef393|)))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (-
          (ite
            (and
              (and
                (and (< (inv@454@04 r) V@15@04) (<= 0 (inv@454@04 r)))
                (< (inv@453@04 r) V@15@04))
              (<= 0 (inv@453@04 r)))
            $Perm.Write
            $Perm.No)
          (pTaken@501@04 r))
        (pTaken@507@04 r)))
    (=
      ($FVF.lookup_int (as sm@539@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@539@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))))))) r))
  :qid |qp.fvfValDef394|)))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (ite
          (=
            r
            (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) u@496@04))) v1@441@04))
          $Perm.Write
          $Perm.No)
        (pTaken@506@04 r)))
    (=
      ($FVF.lookup_int (as sm@539@04  $FVF<Int>) r)
      ($FVF.lookup_int (as sm@502@04  $FVF<Int>) r)))
  :pattern (($FVF.lookup_int (as sm@539@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int (as sm@502@04  $FVF<Int>) r))
  :qid |qp.fvfValDef395|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int (as sm@509@04  $FVF<Int>) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04)))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int (as sm@502@04  $FVF<Int>) r) r))
  :pattern (($FVF.lookup_int (as sm@539@04  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef396|)))
(assert (forall ((i1@536@04 Int)) (!
  (implies
    (and (and (< i1@536@04 V@15@04) (<= 0 i1@536@04)) (< $Perm.No $k@537@04))
    (=
      (inv@538@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i1@536@04))
      i1@536@04))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i1@536@04))
  :qid |int-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and (< (inv@538@04 r) V@15@04) (<= 0 (inv@538@04 r)))
      (< $Perm.No $k@537@04))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) (inv@538@04 r))
      r))
  :pattern ((inv@538@04 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (iff
    (Set_in r ($FVF.domain_int (as sm@544@04  $FVF<Int>)))
    (and
      (and (< (inv@538@04 r) V@15@04) (<= 0 (inv@538@04 r)))
      (< $Perm.No $k@537@04)))
  :pattern ((Set_in r ($FVF.domain_int (as sm@544@04  $FVF<Int>))))
  :qid |qp.fvfDomDef405|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@538@04 r) V@15@04) (<= 0 (inv@538@04 r)))
        (< $Perm.No $k@537@04))
      (=
        r
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) v1@441@04))) u@496@04)))
    (=
      ($FVF.lookup_int (as sm@544@04  $FVF<Int>) r)
      ($FVF.lookup_int (as sm@509@04  $FVF<Int>) r)))
  :pattern (($FVF.lookup_int (as sm@544@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int (as sm@509@04  $FVF<Int>) r))
  :qid |qp.fvfValDef400|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@538@04 r) V@15@04) (<= 0 (inv@538@04 r)))
        (< $Perm.No $k@537@04))
      (<
        $Perm.No
        (-
          (ite
            (and (< (inv@457@04 r) V@15@04) (<= 0 (inv@457@04 r)))
            $Perm.Write
            $Perm.No)
          (pTaken@500@04 r))))
    (=
      ($FVF.lookup_int (as sm@544@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04)))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@544@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04)))))))))))))) r))
  :qid |qp.fvfValDef401|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@538@04 r) V@15@04) (<= 0 (inv@538@04 r)))
        (< $Perm.No $k@537@04))
      (<
        $Perm.No
        (-
          (-
            (ite
              (and
                (and
                  (and (< (inv@454@04 r) V@15@04) (<= 0 (inv@454@04 r)))
                  (< (inv@453@04 r) V@15@04))
                (<= 0 (inv@453@04 r)))
              $Perm.Write
              $Perm.No)
            (pTaken@501@04 r))
          (pTaken@507@04 r))))
    (=
      ($FVF.lookup_int (as sm@544@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@544@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))))))) r))
  :qid |qp.fvfValDef402|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@538@04 r) V@15@04) (<= 0 (inv@538@04 r)))
        (< $Perm.No $k@537@04))
      (<
        $Perm.No
        (-
          (ite
            (=
              r
              (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit G@11@04) u@496@04))) v1@441@04))
            $Perm.Write
            $Perm.No)
          (pTaken@506@04 r))))
    (=
      ($FVF.lookup_int (as sm@544@04  $FVF<Int>) r)
      ($FVF.lookup_int (as sm@502@04  $FVF<Int>) r)))
  :pattern (($FVF.lookup_int (as sm@544@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int (as sm@502@04  $FVF<Int>) r))
  :qid |qp.fvfValDef403|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int (as sm@509@04  $FVF<Int>) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04)))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int (as sm@502@04  $FVF<Int>) r) r))
  :pattern (($FVF.lookup_int (as sm@544@04  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef404|)))
(assert (and
  (forall ((i1@536@04 Int)) (!
    (< i1@536@04 (alen<Int> (opt_get1 $Snap.unit P@14@04)))
    :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i1@536@04))
    :qid |int-aux|))
  (forall ((r $Ref)) (!
    (implies
      (and (< (inv@538@04 r) V@15@04) (<= 0 (inv@538@04 r)))
      ($FVF.loc_int ($FVF.lookup_int (as sm@539@04  $FVF<Int>) r) r))
    :pattern ((inv@538@04 r))
    ))
  (implies
    (not
      (=
        (ite
          (=
            (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) v1@441@04))) u@496@04)
            (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) v1@441@04))) u@496@04))
          $Perm.Write
          $Perm.No)
        $Perm.No))
    (ite
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) v1@441@04))) u@496@04)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) v1@441@04))) u@496@04))
      (<
        (ite
          (and
            (<
              (inv@538@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit G@11@04) v1@441@04))) u@496@04))
              V@15@04)
            (<=
              0
              (inv@538@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit G@11@04) v1@441@04))) u@496@04))))
          $k@537@04
          $Perm.No)
        $Perm.Write)
      (<
        (ite
          (and
            (<
              (inv@538@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit G@11@04) v1@441@04))) u@496@04))
              V@15@04)
            (<=
              0
              (inv@538@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@446@04  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit G@11@04) v1@441@04))) u@496@04))))
          $k@537@04
          $Perm.No)
        $Perm.No)))
  (forall ((r $Ref)) (!
    (implies
      (not
        (=
          (-
            (ite
              (and (< (inv@457@04 r) V@15@04) (<= 0 (inv@457@04 r)))
              $Perm.Write
              $Perm.No)
            (pTaken@500@04 r))
          $Perm.No))
      (<
        (ite
          (and (< (inv@538@04 r) V@15@04) (<= 0 (inv@538@04 r)))
          $k@537@04
          $Perm.No)
        (-
          (ite
            (and (< (inv@457@04 r) V@15@04) (<= 0 (inv@457@04 r)))
            $Perm.Write
            $Perm.No)
          (pTaken@500@04 r))))
    :pattern ((inv@457@04 r))
    :pattern ((inv@538@04 r))
    :qid |qp.srp398|))
  (forall ((r $Ref)) (!
    (implies
      (not
        (=
          (-
            (-
              (ite
                (and
                  (and
                    (and (< (inv@454@04 r) V@15@04) (<= 0 (inv@454@04 r)))
                    (< (inv@453@04 r) V@15@04))
                  (<= 0 (inv@453@04 r)))
                $Perm.Write
                $Perm.No)
              (pTaken@501@04 r))
            (pTaken@507@04 r))
          $Perm.No))
      (<
        (ite
          (and (< (inv@538@04 r) V@15@04) (<= 0 (inv@538@04 r)))
          $k@537@04
          $Perm.No)
        (-
          (-
            (ite
              (and
                (and
                  (and (< (inv@454@04 r) V@15@04) (<= 0 (inv@454@04 r)))
                  (< (inv@453@04 r) V@15@04))
                (<= 0 (inv@453@04 r)))
              $Perm.Write
              $Perm.No)
            (pTaken@501@04 r))
          (pTaken@507@04 r))))
    :pattern ((inv@454@04 r))
    :pattern ((inv@453@04 r))
    :pattern ((inv@538@04 r))
    :qid |qp.srp399|))))
(set-option :timeout 0)
(push) ; 16
(assert (not (valid_graph_vertices ($Snap.combine
  $Snap.unit
  ($Snap.combine
    $Snap.unit
    ($Snap.combine
      $Snap.unit
      ($SortWrappers.$FVF<Int>To$Snap (as sm@544@04  $FVF<Int>))))) this@9@04 P@14@04 V@15@04)))
(check-sat)
; unsat
(pop) ; 16
; 02m:26s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               24149631
;  :arith-add-rows          5065542
;  :arith-assert-diseq      164768
;  :arith-assert-lower      4368425
;  :arith-assert-upper      3758982
;  :arith-bound-prop        113589
;  :arith-conflicts         2976
;  :arith-eq-adapter        1671350
;  :arith-fixed-eqs         3921954
;  :arith-offset-eqs        2298969
;  :arith-pivots            708714
;  :conflicts               6920
;  :datatype-accessor-ax    508
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1013531
;  :del-clause              62904967
;  :final-checks            5
;  :max-generation          14
;  :max-memory              517.91
;  :memory                  503.66
;  :minimized-lits          1062
;  :mk-bool-var             54142389
;  :mk-clause               62909496
;  :num-allocs              128034483
;  :num-checks              605
;  :propagations            18664737
;  :quant-instantiations    22725090
;  :restarts                15
;  :rlimit-count            505817824
;  :time                    146.14)
(assert (valid_graph_vertices ($Snap.combine
  $Snap.unit
  ($Snap.combine
    $Snap.unit
    ($Snap.combine
      $Snap.unit
      ($SortWrappers.$FVF<Int>To$Snap (as sm@544@04  $FVF<Int>))))) this@9@04 P@14@04 V@15@04))
(pop) ; 15
(push) ; 15
; [else-branch: 269 | v1@441@04 == s@12@04]
(assert (= v1@441@04 s@12@04))
(pop) ; 15
; [eval] !(v1 != s)
; [eval] v1 != s
(set-option :timeout 10)
(push) ; 15
(assert (not (not (= v1@441@04 s@12@04))))
(check-sat)
; unknown
(pop) ; 15
; 0.23s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               24149633
;  :arith-add-rows          5065746
;  :arith-assert-diseq      164768
;  :arith-assert-lower      4368425
;  :arith-assert-upper      3758982
;  :arith-bound-prop        113589
;  :arith-conflicts         2976
;  :arith-eq-adapter        1671351
;  :arith-fixed-eqs         3921954
;  :arith-offset-eqs        2298969
;  :arith-pivots            708881
;  :conflicts               6920
;  :datatype-accessor-ax    508
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1013531
;  :del-clause              62907454
;  :final-checks            5
;  :max-generation          14
;  :max-memory              517.91
;  :memory                  503.71
;  :minimized-lits          1062
;  :mk-bool-var             54142393
;  :mk-clause               62909500
;  :num-allocs              128034601
;  :num-checks              606
;  :propagations            18664737
;  :quant-instantiations    22725090
;  :restarts                15
;  :rlimit-count            505822407
;  :time                    0.23)
(push) ; 15
(assert (not (= v1@441@04 s@12@04)))
(check-sat)
; unknown
(pop) ; 15
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               24149984
;  :arith-add-rows          5066050
;  :arith-assert-diseq      164779
;  :arith-assert-lower      4368497
;  :arith-assert-upper      3759035
;  :arith-bound-prop        113589
;  :arith-conflicts         2976
;  :arith-eq-adapter        1671398
;  :arith-fixed-eqs         3922018
;  :arith-offset-eqs        2298987
;  :arith-pivots            708897
;  :conflicts               6920
;  :datatype-accessor-ax    508
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1013609
;  :del-clause              62910587
;  :final-checks            5
;  :max-generation          14
;  :max-memory              517.91
;  :memory                  503.71
;  :minimized-lits          1062
;  :mk-bool-var             54144891
;  :mk-clause               62912633
;  :num-allocs              128043374
;  :num-checks              607
;  :propagations            18665166
;  :quant-instantiations    22725804
;  :restarts                15
;  :rlimit-count            505861464
;  :time                    0.01)
; [then-branch: 285 | v1@441@04 == s@12@04 | live]
; [else-branch: 285 | v1@441@04 != s@12@04 | live]
(push) ; 15
; [then-branch: 285 | v1@441@04 == s@12@04]
(assert (= v1@441@04 s@12@04))
; [exec]
; Gf_seq := matrixValues(this, G, V)
; [eval] matrixValues(this, G, V)
(push) ; 16
; [eval] this != null
; [eval] a2 != (None(): option[array])
; [eval] (None(): option[array])
; [eval] alen(opt_get1(a2)) == V
; [eval] alen(opt_get1(a2))
; [eval] opt_get1(a2)
(push) ; 17
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 17
; Joined path conditions
(declare-const i1@545@04 Int)
(push) ; 17
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 18
; [then-branch: 286 | 0 <= i1@545@04 | live]
; [else-branch: 286 | !(0 <= i1@545@04) | live]
(push) ; 19
; [then-branch: 286 | 0 <= i1@545@04]
(assert (<= 0 i1@545@04))
; [eval] i1 < V
(pop) ; 19
(push) ; 19
; [else-branch: 286 | !(0 <= i1@545@04)]
(assert (not (<= 0 i1@545@04)))
(pop) ; 19
(pop) ; 18
; Joined path conditions
; Joined path conditions
(assert (and (< i1@545@04 V@15@04) (<= 0 i1@545@04)))
(declare-const $k@546@04 $Perm)
(assert ($Perm.isReadVar $k@546@04 $Perm.Write))
; [eval] aloc(opt_get1(a2), i1)
; [eval] opt_get1(a2)
(push) ; 18
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 18
; Joined path conditions
(push) ; 18
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 19
(assert (not (< i1@545@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))))
(check-sat)
; unsat
(pop) ; 19
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               24149988
;  :arith-add-rows          5066052
;  :arith-assert-diseq      164780
;  :arith-assert-lower      4368502
;  :arith-assert-upper      3759037
;  :arith-bound-prop        113589
;  :arith-conflicts         2976
;  :arith-eq-adapter        1671400
;  :arith-fixed-eqs         3922019
;  :arith-offset-eqs        2298987
;  :arith-pivots            708898
;  :conflicts               6920
;  :datatype-accessor-ax    508
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1013609
;  :del-clause              62910587
;  :final-checks            5
;  :max-generation          14
;  :max-memory              517.91
;  :memory                  503.71
;  :minimized-lits          1062
;  :mk-bool-var             54144901
;  :mk-clause               62912639
;  :num-allocs              128043624
;  :num-checks              608
;  :propagations            18665169
;  :quant-instantiations    22725804
;  :restarts                15
;  :rlimit-count            505861871)
(assert (< i1@545@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(pop) ; 18
; Joined path conditions
(assert (< i1@545@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(pop) ; 17
(declare-fun inv@547@04 ($Ref) Int)
; Nested auxiliary terms: globals
(assert ($Perm.isReadVar $k@546@04 $Perm.Write))
; Nested auxiliary terms: non-globals
(assert (forall ((i1@545@04 Int)) (!
  (< i1@545@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@545@04))
  :qid |option$array$-aux|)))
(push) ; 17
(assert (not (forall ((i1@545@04 Int)) (!
  (implies
    (and (< i1@545@04 V@15@04) (<= 0 i1@545@04))
    (or (= $k@546@04 $Perm.No) (< $Perm.No $k@546@04)))
  
  ))))
(check-sat)
; unsat
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               24149988
;  :arith-add-rows          5066053
;  :arith-assert-diseq      164781
;  :arith-assert-lower      4368504
;  :arith-assert-upper      3759038
;  :arith-bound-prop        113589
;  :arith-conflicts         2976
;  :arith-eq-adapter        1671401
;  :arith-fixed-eqs         3922019
;  :arith-offset-eqs        2298987
;  :arith-pivots            708898
;  :conflicts               6921
;  :datatype-accessor-ax    508
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1013609
;  :del-clause              62910589
;  :final-checks            5
;  :max-generation          14
;  :max-memory              517.91
;  :memory                  503.71
;  :minimized-lits          1062
;  :mk-bool-var             54144908
;  :mk-clause               62912641
;  :num-allocs              128044052
;  :num-checks              609
;  :propagations            18665170
;  :quant-instantiations    22725804
;  :restarts                15
;  :rlimit-count            505862418)
(declare-const sm@548@04 $FVF<option<array>>)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (-
          (ite
            (and (< (inv@296@04 r) V@15@04) (<= 0 (inv@296@04 r)))
            $k@295@04
            $Perm.No)
          (pTaken@380@04 r))
        (pTaken@469@04 r)))
    (=
      ($FVF.lookup_option$array$ (as sm@548@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@548@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r))
  :qid |qp.fvfValDef406|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@357@04 r) V@15@04) (<= 0 (inv@357@04 r)))
      (< $Perm.No $k@356@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@548@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@548@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))) r))
  :qid |qp.fvfValDef407|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@445@04 r) V@15@04) (<= 0 (inv@445@04 r)))
      (< $Perm.No $k@444@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@548@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@548@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))) r))
  :qid |qp.fvfValDef408|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))) r) r))
  :pattern (($FVF.lookup_option$array$ (as sm@548@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef409|)))
; Check receiver injectivity
(push) ; 17
(assert (not (forall ((i11@545@04 Int) (i12@545@04 Int)) (!
  (implies
    (and
      (and
        (and
          (and (< i11@545@04 V@15@04) (<= 0 i11@545@04))
          ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@548@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i11@545@04)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i11@545@04)))
        (< $Perm.No $k@546@04))
      (and
        (and
          (and (< i12@545@04 V@15@04) (<= 0 i12@545@04))
          ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@548@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i12@545@04)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i12@545@04)))
        (< $Perm.No $k@546@04))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i11@545@04)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i12@545@04)))
    (= i11@545@04 i12@545@04))
  
  :qid |option$array$-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               24150041
;  :arith-add-rows          5066064
;  :arith-assert-diseq      164782
;  :arith-assert-lower      4368508
;  :arith-assert-upper      3759038
;  :arith-bound-prop        113589
;  :arith-conflicts         2976
;  :arith-eq-adapter        1671402
;  :arith-fixed-eqs         3922019
;  :arith-offset-eqs        2298987
;  :arith-pivots            708900
;  :conflicts               6922
;  :datatype-accessor-ax    508
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1013609
;  :del-clause              62910621
;  :final-checks            5
;  :max-generation          14
;  :max-memory              517.91
;  :memory                  497.72
;  :minimized-lits          1062
;  :mk-bool-var             54145020
;  :mk-clause               62912673
;  :num-allocs              128045844
;  :num-checks              610
;  :propagations            18665173
;  :quant-instantiations    22725899
;  :restarts                15
;  :rlimit-count            505868096
;  :time                    0.00)
; Definitional axioms for inverse functions
(assert (forall ((i1@545@04 Int)) (!
  (implies
    (and (and (< i1@545@04 V@15@04) (<= 0 i1@545@04)) (< $Perm.No $k@546@04))
    (=
      (inv@547@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@545@04))
      i1@545@04))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@545@04))
  :qid |option$array$-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and (< (inv@547@04 r) V@15@04) (<= 0 (inv@547@04 r)))
      (< $Perm.No $k@546@04))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) (inv@547@04 r))
      r))
  :pattern ((inv@547@04 r))
  :qid |option$array$-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@547@04 r) V@15@04) (<= 0 (inv@547@04 r)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@548@04  $FVF<option<array>>) r) r))
  :pattern ((inv@547@04 r))
  )))
; Precomputing data for removing quantified permissions
(define-fun pTaken@549@04 ((r $Ref)) $Perm
  (ite
    (and (< (inv@547@04 r) V@15@04) (<= 0 (inv@547@04 r)))
    ($Perm.min
      (-
        (-
          (ite
            (and (< (inv@296@04 r) V@15@04) (<= 0 (inv@296@04 r)))
            $k@295@04
            $Perm.No)
          (pTaken@380@04 r))
        (pTaken@469@04 r))
      $k@546@04)
    $Perm.No))
(define-fun pTaken@550@04 ((r $Ref)) $Perm
  (ite
    (and (< (inv@547@04 r) V@15@04) (<= 0 (inv@547@04 r)))
    ($Perm.min
      (ite
        (and (< (inv@357@04 r) V@15@04) (<= 0 (inv@357@04 r)))
        $k@356@04
        $Perm.No)
      (- $k@546@04 (pTaken@549@04 r)))
    $Perm.No))
(define-fun pTaken@551@04 ((r $Ref)) $Perm
  (ite
    (and (< (inv@547@04 r) V@15@04) (<= 0 (inv@547@04 r)))
    ($Perm.min
      (ite
        (and (< (inv@445@04 r) V@15@04) (<= 0 (inv@445@04 r)))
        $k@444@04
        $Perm.No)
      (- (- $k@546@04 (pTaken@549@04 r)) (pTaken@550@04 r)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Constrain original permissions $k@546@04
(assert (forall ((r $Ref)) (!
  (implies
    (not
      (=
        (-
          (-
            (ite
              (and (< (inv@296@04 r) V@15@04) (<= 0 (inv@296@04 r)))
              $k@295@04
              $Perm.No)
            (pTaken@380@04 r))
          (pTaken@469@04 r))
        $Perm.No))
    (<
      (ite
        (and (< (inv@547@04 r) V@15@04) (<= 0 (inv@547@04 r)))
        $k@546@04
        $Perm.No)
      (-
        (-
          (ite
            (and (< (inv@296@04 r) V@15@04) (<= 0 (inv@296@04 r)))
            $k@295@04
            $Perm.No)
          (pTaken@380@04 r))
        (pTaken@469@04 r))))
  :pattern ((inv@296@04 r))
  :pattern ((inv@547@04 r))
  :qid |qp.srp410|)))
; Intermediate check if already taken enough permissions
(set-option :timeout 500)
(push) ; 17
(assert (not (forall ((r $Ref)) (!
  (implies
    (and (< (inv@547@04 r) V@15@04) (<= 0 (inv@547@04 r)))
    (= (- $k@546@04 (pTaken@549@04 r)) $Perm.No))
  
  ))))
(check-sat)
; unsat
(pop) ; 17
; 0.04s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               24151648
;  :arith-add-rows          5067565
;  :arith-assert-diseq      164826
;  :arith-assert-lower      4368760
;  :arith-assert-upper      3759211
;  :arith-bound-prop        113651
;  :arith-conflicts         2982
;  :arith-eq-adapter        1671614
;  :arith-fixed-eqs         3922184
;  :arith-offset-eqs        2299059
;  :arith-pivots            709051
;  :conflicts               6946
;  :datatype-accessor-ax    508
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1013941
;  :del-clause              62922144
;  :final-checks            5
;  :max-generation          14
;  :max-memory              517.91
;  :memory                  492.23
;  :minimized-lits          1063
;  :mk-bool-var             54153892
;  :mk-clause               62924195
;  :num-allocs              128073878
;  :num-checks              612
;  :propagations            18667039
;  :quant-instantiations    22728079
;  :restarts                15
;  :rlimit-count            505990732
;  :time                    0.04)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@552@04 $FVF<option<array>>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (iff
    (Set_in r ($FVF.domain_option$array$ (as sm@552@04  $FVF<option<array>>)))
    (and
      (and (< (inv@547@04 r) V@15@04) (<= 0 (inv@547@04 r)))
      (< $Perm.No $k@546@04)))
  :pattern ((Set_in r ($FVF.domain_option$array$ (as sm@552@04  $FVF<option<array>>))))
  :qid |qp.fvfDomDef415|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@547@04 r) V@15@04) (<= 0 (inv@547@04 r)))
        (< $Perm.No $k@546@04))
      (<
        $Perm.No
        (-
          (-
            (ite
              (and (< (inv@296@04 r) V@15@04) (<= 0 (inv@296@04 r)))
              $k@295@04
              $Perm.No)
            (pTaken@380@04 r))
          (pTaken@469@04 r))))
    (=
      ($FVF.lookup_option$array$ (as sm@552@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@552@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r))
  :qid |qp.fvfValDef411|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@547@04 r) V@15@04) (<= 0 (inv@547@04 r)))
        (< $Perm.No $k@546@04))
      (ite
        (and (< (inv@357@04 r) V@15@04) (<= 0 (inv@357@04 r)))
        (< $Perm.No $k@356@04)
        false))
    (=
      ($FVF.lookup_option$array$ (as sm@552@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@552@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))) r))
  :qid |qp.fvfValDef412|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@547@04 r) V@15@04) (<= 0 (inv@547@04 r)))
        (< $Perm.No $k@546@04))
      (ite
        (and (< (inv@445@04 r) V@15@04) (<= 0 (inv@445@04 r)))
        (< $Perm.No $k@444@04)
        false))
    (=
      ($FVF.lookup_option$array$ (as sm@552@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@552@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))) r))
  :qid |qp.fvfValDef413|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))) r) r))
  :pattern (($FVF.lookup_option$array$ (as sm@552@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef414|)))
; [eval] (forall i1: Int :: 0 <= i1 && i1 < V ==> aloc(opt_get1(a2), i1).option$array$ != (None(): option[array]))
(declare-const i1@553@04 Int)
(push) ; 17
; [eval] 0 <= i1 && i1 < V ==> aloc(opt_get1(a2), i1).option$array$ != (None(): option[array])
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 18
; [then-branch: 287 | 0 <= i1@553@04 | live]
; [else-branch: 287 | !(0 <= i1@553@04) | live]
(push) ; 19
; [then-branch: 287 | 0 <= i1@553@04]
(assert (<= 0 i1@553@04))
; [eval] i1 < V
(pop) ; 19
(push) ; 19
; [else-branch: 287 | !(0 <= i1@553@04)]
(assert (not (<= 0 i1@553@04)))
(pop) ; 19
(pop) ; 18
; Joined path conditions
; Joined path conditions
(push) ; 18
; [then-branch: 288 | i1@553@04 < V@15@04 && 0 <= i1@553@04 | live]
; [else-branch: 288 | !(i1@553@04 < V@15@04 && 0 <= i1@553@04) | live]
(push) ; 19
; [then-branch: 288 | i1@553@04 < V@15@04 && 0 <= i1@553@04]
(assert (and (< i1@553@04 V@15@04) (<= 0 i1@553@04)))
; [eval] aloc(opt_get1(a2), i1).option$array$ != (None(): option[array])
; [eval] aloc(opt_get1(a2), i1)
; [eval] opt_get1(a2)
(push) ; 20
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 20
; Joined path conditions
(push) ; 20
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 21
(assert (not (< i1@553@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))))
(check-sat)
; unsat
(pop) ; 21
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               24151648
;  :arith-add-rows          5067566
;  :arith-assert-diseq      164826
;  :arith-assert-lower      4368762
;  :arith-assert-upper      3759211
;  :arith-bound-prop        113651
;  :arith-conflicts         2982
;  :arith-eq-adapter        1671614
;  :arith-fixed-eqs         3922184
;  :arith-offset-eqs        2299059
;  :arith-pivots            709051
;  :conflicts               6946
;  :datatype-accessor-ax    508
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1013941
;  :del-clause              62922144
;  :final-checks            5
;  :max-generation          14
;  :max-memory              517.91
;  :memory                  492.23
;  :minimized-lits          1063
;  :mk-bool-var             54153899
;  :mk-clause               62924195
;  :num-allocs              128074976
;  :num-checks              613
;  :propagations            18667039
;  :quant-instantiations    22728079
;  :restarts                15
;  :rlimit-count            505994021)
(assert (< i1@553@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(pop) ; 20
; Joined path conditions
(assert (< i1@553@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(declare-const sm@554@04 $FVF<option<array>>)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (-
          (ite
            (and (< (inv@296@04 r) V@15@04) (<= 0 (inv@296@04 r)))
            $k@295@04
            $Perm.No)
          (pTaken@380@04 r))
        (pTaken@469@04 r)))
    (=
      ($FVF.lookup_option$array$ (as sm@554@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@554@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r))
  :qid |qp.fvfValDef416|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@357@04 r) V@15@04) (<= 0 (inv@357@04 r)))
      (< $Perm.No $k@356@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@554@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@554@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))) r))
  :qid |qp.fvfValDef417|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@445@04 r) V@15@04) (<= 0 (inv@445@04 r)))
      (< $Perm.No $k@444@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@554@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@554@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))) r))
  :qid |qp.fvfValDef418|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))) r) r))
  :pattern (($FVF.lookup_option$array$ (as sm@554@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef419|)))
(declare-const pm@555@04 $FPM)
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@555@04  $FPM) r)
    (+
      (+
        (-
          (-
            (ite
              (and (< (inv@296@04 r) V@15@04) (<= 0 (inv@296@04 r)))
              $k@295@04
              $Perm.No)
            (pTaken@380@04 r))
          (pTaken@469@04 r))
        (ite
          (and (< (inv@357@04 r) V@15@04) (<= 0 (inv@357@04 r)))
          $k@356@04
          $Perm.No))
      (ite
        (and (< (inv@445@04 r) V@15@04) (<= 0 (inv@445@04 r)))
        $k@444@04
        $Perm.No)))
  :pattern (($FVF.perm_option$array$ (as pm@555@04  $FPM) r))
  :qid |qp.resPrmSumDef420|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@554@04  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@555@04  $FPM) r))
  :qid |qp.resTrgDef421|)))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@554@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@553@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@553@04)))
(push) ; 20
(assert (not (<
  $Perm.No
  ($FVF.perm_option$array$ (as pm@555@04  $FPM) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@553@04)))))
(check-sat)
; unsat
(pop) ; 20
; 0.04s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               24152749
;  :arith-add-rows          5068645
;  :arith-assert-diseq      164844
;  :arith-assert-lower      4368905
;  :arith-assert-upper      3759305
;  :arith-bound-prop        113695
;  :arith-conflicts         2986
;  :arith-eq-adapter        1671724
;  :arith-fixed-eqs         3922283
;  :arith-offset-eqs        2299120
;  :arith-pivots            709119
;  :conflicts               6952
;  :datatype-accessor-ax    508
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1014239
;  :del-clause              62931429
;  :final-checks            5
;  :max-generation          14
;  :max-memory              517.91
;  :memory                  491.52
;  :minimized-lits          1063
;  :mk-bool-var             54160915
;  :mk-clause               62933967
;  :num-allocs              128097191
;  :num-checks              614
;  :propagations            18668521
;  :quant-instantiations    22729772
;  :restarts                15
;  :rlimit-count            506095323
;  :time                    0.04)
; [eval] (None(): option[array])
(pop) ; 19
(push) ; 19
; [else-branch: 288 | !(i1@553@04 < V@15@04 && 0 <= i1@553@04)]
(assert (not (and (< i1@553@04 V@15@04) (<= 0 i1@553@04))))
(pop) ; 19
(pop) ; 18
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (-
          (ite
            (and (< (inv@296@04 r) V@15@04) (<= 0 (inv@296@04 r)))
            $k@295@04
            $Perm.No)
          (pTaken@380@04 r))
        (pTaken@469@04 r)))
    (=
      ($FVF.lookup_option$array$ (as sm@554@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@554@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r))
  :qid |qp.fvfValDef416|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@357@04 r) V@15@04) (<= 0 (inv@357@04 r)))
      (< $Perm.No $k@356@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@554@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@554@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))) r))
  :qid |qp.fvfValDef417|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@445@04 r) V@15@04) (<= 0 (inv@445@04 r)))
      (< $Perm.No $k@444@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@554@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@554@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))) r))
  :qid |qp.fvfValDef418|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))) r) r))
  :pattern (($FVF.lookup_option$array$ (as sm@554@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef419|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@555@04  $FPM) r)
    (+
      (+
        (-
          (-
            (ite
              (and (< (inv@296@04 r) V@15@04) (<= 0 (inv@296@04 r)))
              $k@295@04
              $Perm.No)
            (pTaken@380@04 r))
          (pTaken@469@04 r))
        (ite
          (and (< (inv@357@04 r) V@15@04) (<= 0 (inv@357@04 r)))
          $k@356@04
          $Perm.No))
      (ite
        (and (< (inv@445@04 r) V@15@04) (<= 0 (inv@445@04 r)))
        $k@444@04
        $Perm.No)))
  :pattern (($FVF.perm_option$array$ (as pm@555@04  $FPM) r))
  :qid |qp.resPrmSumDef420|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@554@04  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@555@04  $FPM) r))
  :qid |qp.resTrgDef421|)))
(assert (implies
  (and (< i1@553@04 V@15@04) (<= 0 i1@553@04))
  (and
    (< i1@553@04 V@15@04)
    (<= 0 i1@553@04)
    (< i1@553@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@554@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@553@04)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@553@04)))))
; Joined path conditions
(pop) ; 17
; Nested auxiliary terms: globals (aux)
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (-
          (ite
            (and (< (inv@296@04 r) V@15@04) (<= 0 (inv@296@04 r)))
            $k@295@04
            $Perm.No)
          (pTaken@380@04 r))
        (pTaken@469@04 r)))
    (=
      ($FVF.lookup_option$array$ (as sm@554@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@554@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r))
  :qid |qp.fvfValDef416|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@357@04 r) V@15@04) (<= 0 (inv@357@04 r)))
      (< $Perm.No $k@356@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@554@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@554@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))) r))
  :qid |qp.fvfValDef417|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@445@04 r) V@15@04) (<= 0 (inv@445@04 r)))
      (< $Perm.No $k@444@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@554@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@554@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))) r))
  :qid |qp.fvfValDef418|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))) r) r))
  :pattern (($FVF.lookup_option$array$ (as sm@554@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef419|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@555@04  $FPM) r)
    (+
      (+
        (-
          (-
            (ite
              (and (< (inv@296@04 r) V@15@04) (<= 0 (inv@296@04 r)))
              $k@295@04
              $Perm.No)
            (pTaken@380@04 r))
          (pTaken@469@04 r))
        (ite
          (and (< (inv@357@04 r) V@15@04) (<= 0 (inv@357@04 r)))
          $k@356@04
          $Perm.No))
      (ite
        (and (< (inv@445@04 r) V@15@04) (<= 0 (inv@445@04 r)))
        $k@444@04
        $Perm.No)))
  :pattern (($FVF.perm_option$array$ (as pm@555@04  $FPM) r))
  :qid |qp.resPrmSumDef420|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@554@04  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@555@04  $FPM) r))
  :qid |qp.resTrgDef421|)))
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
; Nested auxiliary terms: non-globals (tlq)
(push) ; 17
(assert (not (forall ((i1@553@04 Int)) (!
  (implies
    (and (< i1@553@04 V@15@04) (<= 0 i1@553@04))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@554@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@553@04))
        (as None<option<array>>  option<array>))))
  
  :qid |prog.l<no position>|))))
(check-sat)
; unsat
(pop) ; 17
; 0.04s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               24153511
;  :arith-add-rows          5069661
;  :arith-assert-diseq      164854
;  :arith-assert-lower      4369010
;  :arith-assert-upper      3759384
;  :arith-bound-prop        113734
;  :arith-conflicts         2987
;  :arith-eq-adapter        1671801
;  :arith-fixed-eqs         3922372
;  :arith-offset-eqs        2299177
;  :arith-pivots            709216
;  :conflicts               6970
;  :datatype-accessor-ax    508
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1014532
;  :del-clause              62941621
;  :final-checks            5
;  :max-generation          14
;  :max-memory              517.91
;  :memory                  491.10
;  :minimized-lits          1063
;  :mk-bool-var             54167746
;  :mk-clause               62943672
;  :num-allocs              128118831
;  :num-checks              615
;  :propagations            18669704
;  :quant-instantiations    22731428
;  :restarts                15
;  :rlimit-count            506194922
;  :time                    0.04)
(assert (forall ((i1@553@04 Int)) (!
  (implies
    (and (< i1@553@04 V@15@04) (<= 0 i1@553@04))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@554@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@553@04))
        (as None<option<array>>  option<array>))))
  
  :qid |prog.l<no position>|)))
; [eval] (forall i1: Int :: 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(a2), i1).option$array$)) == V)
(declare-const i1@556@04 Int)
(push) ; 17
; [eval] 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(a2), i1).option$array$)) == V
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 18
; [then-branch: 289 | 0 <= i1@556@04 | live]
; [else-branch: 289 | !(0 <= i1@556@04) | live]
(push) ; 19
; [then-branch: 289 | 0 <= i1@556@04]
(assert (<= 0 i1@556@04))
; [eval] i1 < V
(pop) ; 19
(push) ; 19
; [else-branch: 289 | !(0 <= i1@556@04)]
(assert (not (<= 0 i1@556@04)))
(pop) ; 19
(pop) ; 18
; Joined path conditions
; Joined path conditions
(push) ; 18
; [then-branch: 290 | i1@556@04 < V@15@04 && 0 <= i1@556@04 | live]
; [else-branch: 290 | !(i1@556@04 < V@15@04 && 0 <= i1@556@04) | live]
(push) ; 19
; [then-branch: 290 | i1@556@04 < V@15@04 && 0 <= i1@556@04]
(assert (and (< i1@556@04 V@15@04) (<= 0 i1@556@04)))
; [eval] alen(opt_get1(aloc(opt_get1(a2), i1).option$array$)) == V
; [eval] alen(opt_get1(aloc(opt_get1(a2), i1).option$array$))
; [eval] opt_get1(aloc(opt_get1(a2), i1).option$array$)
; [eval] aloc(opt_get1(a2), i1)
; [eval] opt_get1(a2)
(push) ; 20
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 20
; Joined path conditions
(push) ; 20
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 21
(assert (not (< i1@556@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))))
(check-sat)
; unsat
(pop) ; 21
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               24153511
;  :arith-add-rows          5069662
;  :arith-assert-diseq      164854
;  :arith-assert-lower      4369012
;  :arith-assert-upper      3759384
;  :arith-bound-prop        113734
;  :arith-conflicts         2987
;  :arith-eq-adapter        1671801
;  :arith-fixed-eqs         3922372
;  :arith-offset-eqs        2299177
;  :arith-pivots            709217
;  :conflicts               6970
;  :datatype-accessor-ax    508
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1014532
;  :del-clause              62941621
;  :final-checks            5
;  :max-generation          14
;  :max-memory              517.91
;  :memory                  500.01
;  :minimized-lits          1063
;  :mk-bool-var             54167749
;  :mk-clause               62943672
;  :num-allocs              128119158
;  :num-checks              616
;  :propagations            18669704
;  :quant-instantiations    22731428
;  :restarts                15
;  :rlimit-count            506195397)
(assert (< i1@556@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(pop) ; 20
; Joined path conditions
(assert (< i1@556@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(declare-const sm@557@04 $FVF<option<array>>)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (-
          (ite
            (and (< (inv@296@04 r) V@15@04) (<= 0 (inv@296@04 r)))
            $k@295@04
            $Perm.No)
          (pTaken@380@04 r))
        (pTaken@469@04 r)))
    (=
      ($FVF.lookup_option$array$ (as sm@557@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@557@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r))
  :qid |qp.fvfValDef422|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@357@04 r) V@15@04) (<= 0 (inv@357@04 r)))
      (< $Perm.No $k@356@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@557@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@557@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))) r))
  :qid |qp.fvfValDef423|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@445@04 r) V@15@04) (<= 0 (inv@445@04 r)))
      (< $Perm.No $k@444@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@557@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@557@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))) r))
  :qid |qp.fvfValDef424|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))) r) r))
  :pattern (($FVF.lookup_option$array$ (as sm@557@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef425|)))
(declare-const pm@558@04 $FPM)
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@558@04  $FPM) r)
    (+
      (+
        (-
          (-
            (ite
              (and (< (inv@296@04 r) V@15@04) (<= 0 (inv@296@04 r)))
              $k@295@04
              $Perm.No)
            (pTaken@380@04 r))
          (pTaken@469@04 r))
        (ite
          (and (< (inv@357@04 r) V@15@04) (<= 0 (inv@357@04 r)))
          $k@356@04
          $Perm.No))
      (ite
        (and (< (inv@445@04 r) V@15@04) (<= 0 (inv@445@04 r)))
        $k@444@04
        $Perm.No)))
  :pattern (($FVF.perm_option$array$ (as pm@558@04  $FPM) r))
  :qid |qp.resPrmSumDef426|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@557@04  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@558@04  $FPM) r))
  :qid |qp.resTrgDef427|)))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@557@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@556@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@556@04)))
(push) ; 20
(assert (not (<
  $Perm.No
  ($FVF.perm_option$array$ (as pm@558@04  $FPM) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@556@04)))))
(check-sat)
; unsat
(pop) ; 20
; 0.03s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               24154647
;  :arith-add-rows          5070730
;  :arith-assert-diseq      164875
;  :arith-assert-lower      4369163
;  :arith-assert-upper      3759482
;  :arith-bound-prop        113783
;  :arith-conflicts         2990
;  :arith-eq-adapter        1671915
;  :arith-fixed-eqs         3922472
;  :arith-offset-eqs        2299236
;  :arith-pivots            709289
;  :conflicts               6979
;  :datatype-accessor-ax    508
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1014842
;  :del-clause              62950943
;  :final-checks            5
;  :max-generation          14
;  :max-memory              517.91
;  :memory                  499.87
;  :minimized-lits          1063
;  :mk-bool-var             54174847
;  :mk-clause               62953484
;  :num-allocs              128141608
;  :num-checks              617
;  :propagations            18671162
;  :quant-instantiations    22733144
;  :restarts                15
;  :rlimit-count            506296323
;  :time                    0.03)
(push) ; 20
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 21
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@557@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@556@04))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 21
; 0.03s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               24155221
;  :arith-add-rows          5071575
;  :arith-assert-diseq      164885
;  :arith-assert-lower      4369239
;  :arith-assert-upper      3759538
;  :arith-bound-prop        113802
;  :arith-conflicts         2991
;  :arith-eq-adapter        1671967
;  :arith-fixed-eqs         3922538
;  :arith-offset-eqs        2299254
;  :arith-pivots            709307
;  :conflicts               6997
;  :datatype-accessor-ax    508
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1015135
;  :del-clause              62960131
;  :final-checks            5
;  :max-generation          14
;  :max-memory              517.91
;  :memory                  499.78
;  :minimized-lits          1063
;  :mk-bool-var             54180957
;  :mk-clause               62962672
;  :num-allocs              128158851
;  :num-checks              618
;  :propagations            18672328
;  :quant-instantiations    22734550
;  :restarts                15
;  :rlimit-count            506376752
;  :time                    0.03)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@557@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@556@04))
    (as None<option<array>>  option<array>))))
(pop) ; 20
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@557@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@556@04))
    (as None<option<array>>  option<array>))))
(pop) ; 19
(push) ; 19
; [else-branch: 290 | !(i1@556@04 < V@15@04 && 0 <= i1@556@04)]
(assert (not (and (< i1@556@04 V@15@04) (<= 0 i1@556@04))))
(pop) ; 19
(pop) ; 18
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (-
          (ite
            (and (< (inv@296@04 r) V@15@04) (<= 0 (inv@296@04 r)))
            $k@295@04
            $Perm.No)
          (pTaken@380@04 r))
        (pTaken@469@04 r)))
    (=
      ($FVF.lookup_option$array$ (as sm@557@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@557@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r))
  :qid |qp.fvfValDef422|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@357@04 r) V@15@04) (<= 0 (inv@357@04 r)))
      (< $Perm.No $k@356@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@557@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@557@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))) r))
  :qid |qp.fvfValDef423|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@445@04 r) V@15@04) (<= 0 (inv@445@04 r)))
      (< $Perm.No $k@444@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@557@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@557@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))) r))
  :qid |qp.fvfValDef424|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))) r) r))
  :pattern (($FVF.lookup_option$array$ (as sm@557@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef425|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@558@04  $FPM) r)
    (+
      (+
        (-
          (-
            (ite
              (and (< (inv@296@04 r) V@15@04) (<= 0 (inv@296@04 r)))
              $k@295@04
              $Perm.No)
            (pTaken@380@04 r))
          (pTaken@469@04 r))
        (ite
          (and (< (inv@357@04 r) V@15@04) (<= 0 (inv@357@04 r)))
          $k@356@04
          $Perm.No))
      (ite
        (and (< (inv@445@04 r) V@15@04) (<= 0 (inv@445@04 r)))
        $k@444@04
        $Perm.No)))
  :pattern (($FVF.perm_option$array$ (as pm@558@04  $FPM) r))
  :qid |qp.resPrmSumDef426|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@557@04  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@558@04  $FPM) r))
  :qid |qp.resTrgDef427|)))
(assert (implies
  (and (< i1@556@04 V@15@04) (<= 0 i1@556@04))
  (and
    (< i1@556@04 V@15@04)
    (<= 0 i1@556@04)
    (< i1@556@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@557@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@556@04)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@556@04))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@557@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@556@04))
        (as None<option<array>>  option<array>))))))
; Joined path conditions
(pop) ; 17
; Nested auxiliary terms: globals (aux)
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (-
          (ite
            (and (< (inv@296@04 r) V@15@04) (<= 0 (inv@296@04 r)))
            $k@295@04
            $Perm.No)
          (pTaken@380@04 r))
        (pTaken@469@04 r)))
    (=
      ($FVF.lookup_option$array$ (as sm@557@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@557@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r))
  :qid |qp.fvfValDef422|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@357@04 r) V@15@04) (<= 0 (inv@357@04 r)))
      (< $Perm.No $k@356@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@557@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@557@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))) r))
  :qid |qp.fvfValDef423|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@445@04 r) V@15@04) (<= 0 (inv@445@04 r)))
      (< $Perm.No $k@444@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@557@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@557@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))) r))
  :qid |qp.fvfValDef424|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))) r) r))
  :pattern (($FVF.lookup_option$array$ (as sm@557@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef425|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@558@04  $FPM) r)
    (+
      (+
        (-
          (-
            (ite
              (and (< (inv@296@04 r) V@15@04) (<= 0 (inv@296@04 r)))
              $k@295@04
              $Perm.No)
            (pTaken@380@04 r))
          (pTaken@469@04 r))
        (ite
          (and (< (inv@357@04 r) V@15@04) (<= 0 (inv@357@04 r)))
          $k@356@04
          $Perm.No))
      (ite
        (and (< (inv@445@04 r) V@15@04) (<= 0 (inv@445@04 r)))
        $k@444@04
        $Perm.No)))
  :pattern (($FVF.perm_option$array$ (as pm@558@04  $FPM) r))
  :qid |qp.resPrmSumDef426|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@557@04  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@558@04  $FPM) r))
  :qid |qp.resTrgDef427|)))
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
; Nested auxiliary terms: non-globals (tlq)
(push) ; 17
(assert (not (forall ((i1@556@04 Int)) (!
  (implies
    (and (< i1@556@04 V@15@04) (<= 0 i1@556@04))
    (=
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@557@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@556@04))))
      V@15@04))
  
  :qid |prog.l<no position>|))))
(check-sat)
; unsat
(pop) ; 17
; 0.04s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               24156064
;  :arith-add-rows          5072563
;  :arith-assert-diseq      164897
;  :arith-assert-lower      4369345
;  :arith-assert-upper      3759617
;  :arith-bound-prop        113841
;  :arith-conflicts         2992
;  :arith-eq-adapter        1672045
;  :arith-fixed-eqs         3922627
;  :arith-offset-eqs        2299311
;  :arith-pivots            709400
;  :conflicts               7015
;  :datatype-accessor-ax    508
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1015429
;  :del-clause              62970360
;  :final-checks            5
;  :max-generation          14
;  :max-memory              517.91
;  :memory                  499.73
;  :minimized-lits          1063
;  :mk-bool-var             54187844
;  :mk-clause               62972411
;  :num-allocs              128180832
;  :num-checks              619
;  :propagations            18673624
;  :quant-instantiations    22736241
;  :restarts                15
;  :rlimit-count            506477550
;  :time                    0.04)
(assert (forall ((i1@556@04 Int)) (!
  (implies
    (and (< i1@556@04 V@15@04) (<= 0 i1@556@04))
    (=
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@557@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@556@04))))
      V@15@04))
  
  :qid |prog.l<no position>|)))
; [eval] (forall i1: Int :: (forall i2: Int :: { aloc(opt_get1(a2), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(a2), i1).option$array$ == aloc(opt_get1(a2), i2).option$array$ ==> i1 == i2))
(declare-const i1@559@04 Int)
(push) ; 17
; [eval] (forall i2: Int :: { aloc(opt_get1(a2), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(a2), i1).option$array$ == aloc(opt_get1(a2), i2).option$array$ ==> i1 == i2)
(declare-const i2@560@04 Int)
(push) ; 18
; [eval] 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(a2), i1).option$array$ == aloc(opt_get1(a2), i2).option$array$ ==> i1 == i2
; [eval] 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(a2), i1).option$array$ == aloc(opt_get1(a2), i2).option$array$
; [eval] 0 <= i1
(push) ; 19
; [then-branch: 291 | 0 <= i1@559@04 | live]
; [else-branch: 291 | !(0 <= i1@559@04) | live]
(push) ; 20
; [then-branch: 291 | 0 <= i1@559@04]
(assert (<= 0 i1@559@04))
; [eval] i1 < V
(push) ; 21
; [then-branch: 292 | i1@559@04 < V@15@04 | live]
; [else-branch: 292 | !(i1@559@04 < V@15@04) | live]
(push) ; 22
; [then-branch: 292 | i1@559@04 < V@15@04]
(assert (< i1@559@04 V@15@04))
; [eval] 0 <= i2
(push) ; 23
; [then-branch: 293 | 0 <= i2@560@04 | live]
; [else-branch: 293 | !(0 <= i2@560@04) | live]
(push) ; 24
; [then-branch: 293 | 0 <= i2@560@04]
(assert (<= 0 i2@560@04))
; [eval] i2 < V
(push) ; 25
; [then-branch: 294 | i2@560@04 < V@15@04 | live]
; [else-branch: 294 | !(i2@560@04 < V@15@04) | live]
(push) ; 26
; [then-branch: 294 | i2@560@04 < V@15@04]
(assert (< i2@560@04 V@15@04))
; [eval] aloc(opt_get1(a2), i1).option$array$ == aloc(opt_get1(a2), i2).option$array$
; [eval] aloc(opt_get1(a2), i1)
; [eval] opt_get1(a2)
(push) ; 27
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 27
; Joined path conditions
(push) ; 27
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 28
(assert (not (< i1@559@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))))
(check-sat)
; unsat
(pop) ; 28
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               24156064
;  :arith-add-rows          5072565
;  :arith-assert-diseq      164897
;  :arith-assert-lower      4369349
;  :arith-assert-upper      3759617
;  :arith-bound-prop        113841
;  :arith-conflicts         2992
;  :arith-eq-adapter        1672045
;  :arith-fixed-eqs         3922627
;  :arith-offset-eqs        2299311
;  :arith-pivots            709401
;  :conflicts               7015
;  :datatype-accessor-ax    508
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1015429
;  :del-clause              62970360
;  :final-checks            5
;  :max-generation          14
;  :max-memory              517.91
;  :memory                  499.73
;  :minimized-lits          1063
;  :mk-bool-var             54187849
;  :mk-clause               62972411
;  :num-allocs              128181356
;  :num-checks              620
;  :propagations            18673624
;  :quant-instantiations    22736241
;  :restarts                15
;  :rlimit-count            506478189)
(assert (< i1@559@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(pop) ; 27
; Joined path conditions
(assert (< i1@559@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(declare-const sm@561@04 $FVF<option<array>>)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (-
          (ite
            (and (< (inv@296@04 r) V@15@04) (<= 0 (inv@296@04 r)))
            $k@295@04
            $Perm.No)
          (pTaken@380@04 r))
        (pTaken@469@04 r)))
    (=
      ($FVF.lookup_option$array$ (as sm@561@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@561@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r))
  :qid |qp.fvfValDef428|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@357@04 r) V@15@04) (<= 0 (inv@357@04 r)))
      (< $Perm.No $k@356@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@561@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@561@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))) r))
  :qid |qp.fvfValDef429|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@445@04 r) V@15@04) (<= 0 (inv@445@04 r)))
      (< $Perm.No $k@444@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@561@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@561@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))) r))
  :qid |qp.fvfValDef430|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))) r) r))
  :pattern (($FVF.lookup_option$array$ (as sm@561@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef431|)))
(declare-const pm@562@04 $FPM)
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@562@04  $FPM) r)
    (+
      (+
        (-
          (-
            (ite
              (and (< (inv@296@04 r) V@15@04) (<= 0 (inv@296@04 r)))
              $k@295@04
              $Perm.No)
            (pTaken@380@04 r))
          (pTaken@469@04 r))
        (ite
          (and (< (inv@357@04 r) V@15@04) (<= 0 (inv@357@04 r)))
          $k@356@04
          $Perm.No))
      (ite
        (and (< (inv@445@04 r) V@15@04) (<= 0 (inv@445@04 r)))
        $k@444@04
        $Perm.No)))
  :pattern (($FVF.perm_option$array$ (as pm@562@04  $FPM) r))
  :qid |qp.resPrmSumDef432|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@561@04  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@562@04  $FPM) r))
  :qid |qp.resTrgDef433|)))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@561@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@559@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@559@04)))
(push) ; 27
(assert (not (<
  $Perm.No
  ($FVF.perm_option$array$ (as pm@562@04  $FPM) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@559@04)))))
(check-sat)
; unsat
(pop) ; 27
; 0.04s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               24157212
;  :arith-add-rows          5073642
;  :arith-assert-diseq      164915
;  :arith-assert-lower      4369498
;  :arith-assert-upper      3759714
;  :arith-bound-prop        113885
;  :arith-conflicts         2996
;  :arith-eq-adapter        1672158
;  :arith-fixed-eqs         3922729
;  :arith-offset-eqs        2299372
;  :arith-pivots            709473
;  :conflicts               7021
;  :datatype-accessor-ax    508
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1015727
;  :del-clause              62979664
;  :final-checks            5
;  :max-generation          14
;  :max-memory              517.91
;  :memory                  499.78
;  :minimized-lits          1063
;  :mk-bool-var             54194918
;  :mk-clause               62982210
;  :num-allocs              128203881
;  :num-checks              621
;  :propagations            18675128
;  :quant-instantiations    22737975
;  :restarts                15
;  :rlimit-count            506580618
;  :time                    0.04)
; [eval] aloc(opt_get1(a2), i2)
; [eval] opt_get1(a2)
(push) ; 27
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 27
; Joined path conditions
(push) ; 27
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 28
(assert (not (< i2@560@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))))
(check-sat)
; unsat
(pop) ; 28
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               24157212
;  :arith-add-rows          5073642
;  :arith-assert-diseq      164915
;  :arith-assert-lower      4369498
;  :arith-assert-upper      3759714
;  :arith-bound-prop        113885
;  :arith-conflicts         2996
;  :arith-eq-adapter        1672158
;  :arith-fixed-eqs         3922729
;  :arith-offset-eqs        2299372
;  :arith-pivots            709473
;  :conflicts               7021
;  :datatype-accessor-ax    508
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1015727
;  :del-clause              62979664
;  :final-checks            5
;  :max-generation          14
;  :max-memory              517.91
;  :memory                  499.78
;  :minimized-lits          1063
;  :mk-bool-var             54194918
;  :mk-clause               62982210
;  :num-allocs              128203907
;  :num-checks              622
;  :propagations            18675128
;  :quant-instantiations    22737975
;  :restarts                15
;  :rlimit-count            506580648)
(assert (< i2@560@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(pop) ; 27
; Joined path conditions
(assert (< i2@560@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(declare-const sm@563@04 $FVF<option<array>>)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (-
          (ite
            (and (< (inv@296@04 r) V@15@04) (<= 0 (inv@296@04 r)))
            $k@295@04
            $Perm.No)
          (pTaken@380@04 r))
        (pTaken@469@04 r)))
    (=
      ($FVF.lookup_option$array$ (as sm@563@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@563@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r))
  :qid |qp.fvfValDef434|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@357@04 r) V@15@04) (<= 0 (inv@357@04 r)))
      (< $Perm.No $k@356@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@563@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@563@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))) r))
  :qid |qp.fvfValDef435|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@445@04 r) V@15@04) (<= 0 (inv@445@04 r)))
      (< $Perm.No $k@444@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@563@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@563@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))) r))
  :qid |qp.fvfValDef436|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))) r) r))
  :pattern (($FVF.lookup_option$array$ (as sm@563@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef437|)))
(declare-const pm@564@04 $FPM)
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@564@04  $FPM) r)
    (+
      (+
        (-
          (-
            (ite
              (and (< (inv@296@04 r) V@15@04) (<= 0 (inv@296@04 r)))
              $k@295@04
              $Perm.No)
            (pTaken@380@04 r))
          (pTaken@469@04 r))
        (ite
          (and (< (inv@357@04 r) V@15@04) (<= 0 (inv@357@04 r)))
          $k@356@04
          $Perm.No))
      (ite
        (and (< (inv@445@04 r) V@15@04) (<= 0 (inv@445@04 r)))
        $k@444@04
        $Perm.No)))
  :pattern (($FVF.perm_option$array$ (as pm@564@04  $FPM) r))
  :qid |qp.resPrmSumDef438|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@563@04  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@564@04  $FPM) r))
  :qid |qp.resTrgDef439|)))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@563@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@560@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@560@04)))
(push) ; 27
(assert (not (<
  $Perm.No
  ($FVF.perm_option$array$ (as pm@564@04  $FPM) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@560@04)))))
(check-sat)
; unsat
(pop) ; 27
; 0.04s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               24159058
;  :arith-add-rows          5075171
;  :arith-assert-diseq      164961
;  :arith-assert-lower      4369805
;  :arith-assert-upper      3759863
;  :arith-bound-prop        113976
;  :arith-conflicts         3008
;  :arith-eq-adapter        1672355
;  :arith-fixed-eqs         3922866
;  :arith-offset-eqs        2299498
;  :arith-pivots            709609
;  :conflicts               7038
;  :datatype-accessor-ax    508
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1016101
;  :del-clause              62990576
;  :final-checks            5
;  :max-generation          14
;  :max-memory              517.91
;  :memory                  499.83
;  :minimized-lits          1063
;  :mk-bool-var             54203151
;  :mk-clause               62993511
;  :num-allocs              128229229
;  :num-checks              623
;  :propagations            18677364
;  :quant-instantiations    22739959
;  :restarts                15
;  :rlimit-count            506706930
;  :time                    0.04)
(pop) ; 26
(push) ; 26
; [else-branch: 294 | !(i2@560@04 < V@15@04)]
(assert (not (< i2@560@04 V@15@04)))
(pop) ; 26
(pop) ; 25
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (-
          (ite
            (and (< (inv@296@04 r) V@15@04) (<= 0 (inv@296@04 r)))
            $k@295@04
            $Perm.No)
          (pTaken@380@04 r))
        (pTaken@469@04 r)))
    (=
      ($FVF.lookup_option$array$ (as sm@561@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@561@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r))
  :qid |qp.fvfValDef428|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@357@04 r) V@15@04) (<= 0 (inv@357@04 r)))
      (< $Perm.No $k@356@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@561@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@561@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))) r))
  :qid |qp.fvfValDef429|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@445@04 r) V@15@04) (<= 0 (inv@445@04 r)))
      (< $Perm.No $k@444@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@561@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@561@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))) r))
  :qid |qp.fvfValDef430|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))) r) r))
  :pattern (($FVF.lookup_option$array$ (as sm@561@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef431|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@562@04  $FPM) r)
    (+
      (+
        (-
          (-
            (ite
              (and (< (inv@296@04 r) V@15@04) (<= 0 (inv@296@04 r)))
              $k@295@04
              $Perm.No)
            (pTaken@380@04 r))
          (pTaken@469@04 r))
        (ite
          (and (< (inv@357@04 r) V@15@04) (<= 0 (inv@357@04 r)))
          $k@356@04
          $Perm.No))
      (ite
        (and (< (inv@445@04 r) V@15@04) (<= 0 (inv@445@04 r)))
        $k@444@04
        $Perm.No)))
  :pattern (($FVF.perm_option$array$ (as pm@562@04  $FPM) r))
  :qid |qp.resPrmSumDef432|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@561@04  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@562@04  $FPM) r))
  :qid |qp.resTrgDef433|)))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (-
          (ite
            (and (< (inv@296@04 r) V@15@04) (<= 0 (inv@296@04 r)))
            $k@295@04
            $Perm.No)
          (pTaken@380@04 r))
        (pTaken@469@04 r)))
    (=
      ($FVF.lookup_option$array$ (as sm@563@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@563@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r))
  :qid |qp.fvfValDef434|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@357@04 r) V@15@04) (<= 0 (inv@357@04 r)))
      (< $Perm.No $k@356@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@563@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@563@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))) r))
  :qid |qp.fvfValDef435|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@445@04 r) V@15@04) (<= 0 (inv@445@04 r)))
      (< $Perm.No $k@444@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@563@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@563@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))) r))
  :qid |qp.fvfValDef436|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))) r) r))
  :pattern (($FVF.lookup_option$array$ (as sm@563@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef437|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@564@04  $FPM) r)
    (+
      (+
        (-
          (-
            (ite
              (and (< (inv@296@04 r) V@15@04) (<= 0 (inv@296@04 r)))
              $k@295@04
              $Perm.No)
            (pTaken@380@04 r))
          (pTaken@469@04 r))
        (ite
          (and (< (inv@357@04 r) V@15@04) (<= 0 (inv@357@04 r)))
          $k@356@04
          $Perm.No))
      (ite
        (and (< (inv@445@04 r) V@15@04) (<= 0 (inv@445@04 r)))
        $k@444@04
        $Perm.No)))
  :pattern (($FVF.perm_option$array$ (as pm@564@04  $FPM) r))
  :qid |qp.resPrmSumDef438|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@563@04  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@564@04  $FPM) r))
  :qid |qp.resTrgDef439|)))
(assert (implies
  (< i2@560@04 V@15@04)
  (and
    (< i2@560@04 V@15@04)
    (< i1@559@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@561@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@559@04)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@559@04))
    (< i2@560@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@563@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@560@04)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@560@04)))))
; Joined path conditions
(pop) ; 24
(push) ; 24
; [else-branch: 293 | !(0 <= i2@560@04)]
(assert (not (<= 0 i2@560@04)))
(pop) ; 24
(pop) ; 23
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (-
          (ite
            (and (< (inv@296@04 r) V@15@04) (<= 0 (inv@296@04 r)))
            $k@295@04
            $Perm.No)
          (pTaken@380@04 r))
        (pTaken@469@04 r)))
    (=
      ($FVF.lookup_option$array$ (as sm@561@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@561@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r))
  :qid |qp.fvfValDef428|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@357@04 r) V@15@04) (<= 0 (inv@357@04 r)))
      (< $Perm.No $k@356@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@561@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@561@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))) r))
  :qid |qp.fvfValDef429|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@445@04 r) V@15@04) (<= 0 (inv@445@04 r)))
      (< $Perm.No $k@444@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@561@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@561@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))) r))
  :qid |qp.fvfValDef430|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))) r) r))
  :pattern (($FVF.lookup_option$array$ (as sm@561@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef431|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@562@04  $FPM) r)
    (+
      (+
        (-
          (-
            (ite
              (and (< (inv@296@04 r) V@15@04) (<= 0 (inv@296@04 r)))
              $k@295@04
              $Perm.No)
            (pTaken@380@04 r))
          (pTaken@469@04 r))
        (ite
          (and (< (inv@357@04 r) V@15@04) (<= 0 (inv@357@04 r)))
          $k@356@04
          $Perm.No))
      (ite
        (and (< (inv@445@04 r) V@15@04) (<= 0 (inv@445@04 r)))
        $k@444@04
        $Perm.No)))
  :pattern (($FVF.perm_option$array$ (as pm@562@04  $FPM) r))
  :qid |qp.resPrmSumDef432|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@561@04  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@562@04  $FPM) r))
  :qid |qp.resTrgDef433|)))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (-
          (ite
            (and (< (inv@296@04 r) V@15@04) (<= 0 (inv@296@04 r)))
            $k@295@04
            $Perm.No)
          (pTaken@380@04 r))
        (pTaken@469@04 r)))
    (=
      ($FVF.lookup_option$array$ (as sm@563@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@563@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r))
  :qid |qp.fvfValDef434|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@357@04 r) V@15@04) (<= 0 (inv@357@04 r)))
      (< $Perm.No $k@356@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@563@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@563@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))) r))
  :qid |qp.fvfValDef435|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@445@04 r) V@15@04) (<= 0 (inv@445@04 r)))
      (< $Perm.No $k@444@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@563@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@563@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))) r))
  :qid |qp.fvfValDef436|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))) r) r))
  :pattern (($FVF.lookup_option$array$ (as sm@563@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef437|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@564@04  $FPM) r)
    (+
      (+
        (-
          (-
            (ite
              (and (< (inv@296@04 r) V@15@04) (<= 0 (inv@296@04 r)))
              $k@295@04
              $Perm.No)
            (pTaken@380@04 r))
          (pTaken@469@04 r))
        (ite
          (and (< (inv@357@04 r) V@15@04) (<= 0 (inv@357@04 r)))
          $k@356@04
          $Perm.No))
      (ite
        (and (< (inv@445@04 r) V@15@04) (<= 0 (inv@445@04 r)))
        $k@444@04
        $Perm.No)))
  :pattern (($FVF.perm_option$array$ (as pm@564@04  $FPM) r))
  :qid |qp.resPrmSumDef438|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@563@04  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@564@04  $FPM) r))
  :qid |qp.resTrgDef439|)))
(assert (implies
  (<= 0 i2@560@04)
  (and
    (<= 0 i2@560@04)
    (implies
      (< i2@560@04 V@15@04)
      (and
        (< i2@560@04 V@15@04)
        (< i1@559@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@561@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@559@04)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@559@04))
        (< i2@560@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@563@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@560@04)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@560@04)))))))
; Joined path conditions
(pop) ; 22
(push) ; 22
; [else-branch: 292 | !(i1@559@04 < V@15@04)]
(assert (not (< i1@559@04 V@15@04)))
(pop) ; 22
(pop) ; 21
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (-
          (ite
            (and (< (inv@296@04 r) V@15@04) (<= 0 (inv@296@04 r)))
            $k@295@04
            $Perm.No)
          (pTaken@380@04 r))
        (pTaken@469@04 r)))
    (=
      ($FVF.lookup_option$array$ (as sm@561@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@561@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r))
  :qid |qp.fvfValDef428|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@357@04 r) V@15@04) (<= 0 (inv@357@04 r)))
      (< $Perm.No $k@356@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@561@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@561@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))) r))
  :qid |qp.fvfValDef429|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@445@04 r) V@15@04) (<= 0 (inv@445@04 r)))
      (< $Perm.No $k@444@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@561@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@561@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))) r))
  :qid |qp.fvfValDef430|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))) r) r))
  :pattern (($FVF.lookup_option$array$ (as sm@561@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef431|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@562@04  $FPM) r)
    (+
      (+
        (-
          (-
            (ite
              (and (< (inv@296@04 r) V@15@04) (<= 0 (inv@296@04 r)))
              $k@295@04
              $Perm.No)
            (pTaken@380@04 r))
          (pTaken@469@04 r))
        (ite
          (and (< (inv@357@04 r) V@15@04) (<= 0 (inv@357@04 r)))
          $k@356@04
          $Perm.No))
      (ite
        (and (< (inv@445@04 r) V@15@04) (<= 0 (inv@445@04 r)))
        $k@444@04
        $Perm.No)))
  :pattern (($FVF.perm_option$array$ (as pm@562@04  $FPM) r))
  :qid |qp.resPrmSumDef432|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@561@04  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@562@04  $FPM) r))
  :qid |qp.resTrgDef433|)))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (-
          (ite
            (and (< (inv@296@04 r) V@15@04) (<= 0 (inv@296@04 r)))
            $k@295@04
            $Perm.No)
          (pTaken@380@04 r))
        (pTaken@469@04 r)))
    (=
      ($FVF.lookup_option$array$ (as sm@563@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@563@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r))
  :qid |qp.fvfValDef434|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@357@04 r) V@15@04) (<= 0 (inv@357@04 r)))
      (< $Perm.No $k@356@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@563@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@563@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))) r))
  :qid |qp.fvfValDef435|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@445@04 r) V@15@04) (<= 0 (inv@445@04 r)))
      (< $Perm.No $k@444@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@563@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@563@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))) r))
  :qid |qp.fvfValDef436|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))) r) r))
  :pattern (($FVF.lookup_option$array$ (as sm@563@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef437|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@564@04  $FPM) r)
    (+
      (+
        (-
          (-
            (ite
              (and (< (inv@296@04 r) V@15@04) (<= 0 (inv@296@04 r)))
              $k@295@04
              $Perm.No)
            (pTaken@380@04 r))
          (pTaken@469@04 r))
        (ite
          (and (< (inv@357@04 r) V@15@04) (<= 0 (inv@357@04 r)))
          $k@356@04
          $Perm.No))
      (ite
        (and (< (inv@445@04 r) V@15@04) (<= 0 (inv@445@04 r)))
        $k@444@04
        $Perm.No)))
  :pattern (($FVF.perm_option$array$ (as pm@564@04  $FPM) r))
  :qid |qp.resPrmSumDef438|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@563@04  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@564@04  $FPM) r))
  :qid |qp.resTrgDef439|)))
(assert (implies
  (< i1@559@04 V@15@04)
  (and
    (< i1@559@04 V@15@04)
    (implies
      (<= 0 i2@560@04)
      (and
        (<= 0 i2@560@04)
        (implies
          (< i2@560@04 V@15@04)
          (and
            (< i2@560@04 V@15@04)
            (< i1@559@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@561@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@559@04)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@559@04))
            (< i2@560@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@563@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@560@04)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@560@04)))))))))
; Joined path conditions
(pop) ; 20
(push) ; 20
; [else-branch: 291 | !(0 <= i1@559@04)]
(assert (not (<= 0 i1@559@04)))
(pop) ; 20
(pop) ; 19
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (-
          (ite
            (and (< (inv@296@04 r) V@15@04) (<= 0 (inv@296@04 r)))
            $k@295@04
            $Perm.No)
          (pTaken@380@04 r))
        (pTaken@469@04 r)))
    (=
      ($FVF.lookup_option$array$ (as sm@561@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@561@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r))
  :qid |qp.fvfValDef428|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@357@04 r) V@15@04) (<= 0 (inv@357@04 r)))
      (< $Perm.No $k@356@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@561@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@561@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))) r))
  :qid |qp.fvfValDef429|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@445@04 r) V@15@04) (<= 0 (inv@445@04 r)))
      (< $Perm.No $k@444@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@561@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@561@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))) r))
  :qid |qp.fvfValDef430|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))) r) r))
  :pattern (($FVF.lookup_option$array$ (as sm@561@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef431|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@562@04  $FPM) r)
    (+
      (+
        (-
          (-
            (ite
              (and (< (inv@296@04 r) V@15@04) (<= 0 (inv@296@04 r)))
              $k@295@04
              $Perm.No)
            (pTaken@380@04 r))
          (pTaken@469@04 r))
        (ite
          (and (< (inv@357@04 r) V@15@04) (<= 0 (inv@357@04 r)))
          $k@356@04
          $Perm.No))
      (ite
        (and (< (inv@445@04 r) V@15@04) (<= 0 (inv@445@04 r)))
        $k@444@04
        $Perm.No)))
  :pattern (($FVF.perm_option$array$ (as pm@562@04  $FPM) r))
  :qid |qp.resPrmSumDef432|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@561@04  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@562@04  $FPM) r))
  :qid |qp.resTrgDef433|)))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (-
          (ite
            (and (< (inv@296@04 r) V@15@04) (<= 0 (inv@296@04 r)))
            $k@295@04
            $Perm.No)
          (pTaken@380@04 r))
        (pTaken@469@04 r)))
    (=
      ($FVF.lookup_option$array$ (as sm@563@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@563@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r))
  :qid |qp.fvfValDef434|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@357@04 r) V@15@04) (<= 0 (inv@357@04 r)))
      (< $Perm.No $k@356@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@563@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@563@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))) r))
  :qid |qp.fvfValDef435|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@445@04 r) V@15@04) (<= 0 (inv@445@04 r)))
      (< $Perm.No $k@444@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@563@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@563@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))) r))
  :qid |qp.fvfValDef436|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))) r) r))
  :pattern (($FVF.lookup_option$array$ (as sm@563@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef437|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@564@04  $FPM) r)
    (+
      (+
        (-
          (-
            (ite
              (and (< (inv@296@04 r) V@15@04) (<= 0 (inv@296@04 r)))
              $k@295@04
              $Perm.No)
            (pTaken@380@04 r))
          (pTaken@469@04 r))
        (ite
          (and (< (inv@357@04 r) V@15@04) (<= 0 (inv@357@04 r)))
          $k@356@04
          $Perm.No))
      (ite
        (and (< (inv@445@04 r) V@15@04) (<= 0 (inv@445@04 r)))
        $k@444@04
        $Perm.No)))
  :pattern (($FVF.perm_option$array$ (as pm@564@04  $FPM) r))
  :qid |qp.resPrmSumDef438|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@563@04  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@564@04  $FPM) r))
  :qid |qp.resTrgDef439|)))
(assert (implies
  (<= 0 i1@559@04)
  (and
    (<= 0 i1@559@04)
    (implies
      (< i1@559@04 V@15@04)
      (and
        (< i1@559@04 V@15@04)
        (implies
          (<= 0 i2@560@04)
          (and
            (<= 0 i2@560@04)
            (implies
              (< i2@560@04 V@15@04)
              (and
                (< i2@560@04 V@15@04)
                (< i1@559@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@561@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@559@04)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@559@04))
                (< i2@560@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@563@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@560@04)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@560@04)))))))))))
; Joined path conditions
(push) ; 19
; [then-branch: 295 | Lookup(option$array$,sm@561@04,aloc((_, _), opt_get1(_, G@11@04), i1@559@04)) == Lookup(option$array$,sm@563@04,aloc((_, _), opt_get1(_, G@11@04), i2@560@04)) && i2@560@04 < V@15@04 && 0 <= i2@560@04 && i1@559@04 < V@15@04 && 0 <= i1@559@04 | live]
; [else-branch: 295 | !(Lookup(option$array$,sm@561@04,aloc((_, _), opt_get1(_, G@11@04), i1@559@04)) == Lookup(option$array$,sm@563@04,aloc((_, _), opt_get1(_, G@11@04), i2@560@04)) && i2@560@04 < V@15@04 && 0 <= i2@560@04 && i1@559@04 < V@15@04 && 0 <= i1@559@04) | live]
(push) ; 20
; [then-branch: 295 | Lookup(option$array$,sm@561@04,aloc((_, _), opt_get1(_, G@11@04), i1@559@04)) == Lookup(option$array$,sm@563@04,aloc((_, _), opt_get1(_, G@11@04), i2@560@04)) && i2@560@04 < V@15@04 && 0 <= i2@560@04 && i1@559@04 < V@15@04 && 0 <= i1@559@04]
(assert (and
  (and
    (and
      (and
        (=
          ($FVF.lookup_option$array$ (as sm@561@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@559@04))
          ($FVF.lookup_option$array$ (as sm@563@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@560@04)))
        (< i2@560@04 V@15@04))
      (<= 0 i2@560@04))
    (< i1@559@04 V@15@04))
  (<= 0 i1@559@04)))
; [eval] i1 == i2
(pop) ; 20
(push) ; 20
; [else-branch: 295 | !(Lookup(option$array$,sm@561@04,aloc((_, _), opt_get1(_, G@11@04), i1@559@04)) == Lookup(option$array$,sm@563@04,aloc((_, _), opt_get1(_, G@11@04), i2@560@04)) && i2@560@04 < V@15@04 && 0 <= i2@560@04 && i1@559@04 < V@15@04 && 0 <= i1@559@04)]
(assert (not
  (and
    (and
      (and
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@561@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@559@04))
            ($FVF.lookup_option$array$ (as sm@563@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@560@04)))
          (< i2@560@04 V@15@04))
        (<= 0 i2@560@04))
      (< i1@559@04 V@15@04))
    (<= 0 i1@559@04))))
(pop) ; 20
(pop) ; 19
; Joined path conditions
(assert (implies
  (and
    (and
      (and
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@561@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@559@04))
            ($FVF.lookup_option$array$ (as sm@563@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@560@04)))
          (< i2@560@04 V@15@04))
        (<= 0 i2@560@04))
      (< i1@559@04 V@15@04))
    (<= 0 i1@559@04))
  (and
    (=
      ($FVF.lookup_option$array$ (as sm@561@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@559@04))
      ($FVF.lookup_option$array$ (as sm@563@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@560@04)))
    (< i2@560@04 V@15@04)
    (<= 0 i2@560@04)
    (< i1@559@04 V@15@04)
    (<= 0 i1@559@04))))
; Joined path conditions
(pop) ; 18
; Nested auxiliary terms: globals (aux)
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (-
          (ite
            (and (< (inv@296@04 r) V@15@04) (<= 0 (inv@296@04 r)))
            $k@295@04
            $Perm.No)
          (pTaken@380@04 r))
        (pTaken@469@04 r)))
    (=
      ($FVF.lookup_option$array$ (as sm@561@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@561@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r))
  :qid |qp.fvfValDef428|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@357@04 r) V@15@04) (<= 0 (inv@357@04 r)))
      (< $Perm.No $k@356@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@561@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@561@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))) r))
  :qid |qp.fvfValDef429|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@445@04 r) V@15@04) (<= 0 (inv@445@04 r)))
      (< $Perm.No $k@444@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@561@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@561@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))) r))
  :qid |qp.fvfValDef430|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))) r) r))
  :pattern (($FVF.lookup_option$array$ (as sm@561@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef431|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@562@04  $FPM) r)
    (+
      (+
        (-
          (-
            (ite
              (and (< (inv@296@04 r) V@15@04) (<= 0 (inv@296@04 r)))
              $k@295@04
              $Perm.No)
            (pTaken@380@04 r))
          (pTaken@469@04 r))
        (ite
          (and (< (inv@357@04 r) V@15@04) (<= 0 (inv@357@04 r)))
          $k@356@04
          $Perm.No))
      (ite
        (and (< (inv@445@04 r) V@15@04) (<= 0 (inv@445@04 r)))
        $k@444@04
        $Perm.No)))
  :pattern (($FVF.perm_option$array$ (as pm@562@04  $FPM) r))
  :qid |qp.resPrmSumDef432|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@561@04  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@562@04  $FPM) r))
  :qid |qp.resTrgDef433|)))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (-
          (ite
            (and (< (inv@296@04 r) V@15@04) (<= 0 (inv@296@04 r)))
            $k@295@04
            $Perm.No)
          (pTaken@380@04 r))
        (pTaken@469@04 r)))
    (=
      ($FVF.lookup_option$array$ (as sm@563@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@563@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r))
  :qid |qp.fvfValDef434|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@357@04 r) V@15@04) (<= 0 (inv@357@04 r)))
      (< $Perm.No $k@356@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@563@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@563@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))) r))
  :qid |qp.fvfValDef435|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@445@04 r) V@15@04) (<= 0 (inv@445@04 r)))
      (< $Perm.No $k@444@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@563@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@563@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))) r))
  :qid |qp.fvfValDef436|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))) r) r))
  :pattern (($FVF.lookup_option$array$ (as sm@563@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef437|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@564@04  $FPM) r)
    (+
      (+
        (-
          (-
            (ite
              (and (< (inv@296@04 r) V@15@04) (<= 0 (inv@296@04 r)))
              $k@295@04
              $Perm.No)
            (pTaken@380@04 r))
          (pTaken@469@04 r))
        (ite
          (and (< (inv@357@04 r) V@15@04) (<= 0 (inv@357@04 r)))
          $k@356@04
          $Perm.No))
      (ite
        (and (< (inv@445@04 r) V@15@04) (<= 0 (inv@445@04 r)))
        $k@444@04
        $Perm.No)))
  :pattern (($FVF.perm_option$array$ (as pm@564@04  $FPM) r))
  :qid |qp.resPrmSumDef438|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@563@04  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@564@04  $FPM) r))
  :qid |qp.resTrgDef439|)))
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i2@560@04 Int)) (!
  (and
    (implies
      (<= 0 i1@559@04)
      (and
        (<= 0 i1@559@04)
        (implies
          (< i1@559@04 V@15@04)
          (and
            (< i1@559@04 V@15@04)
            (implies
              (<= 0 i2@560@04)
              (and
                (<= 0 i2@560@04)
                (implies
                  (< i2@560@04 V@15@04)
                  (and
                    (< i2@560@04 V@15@04)
                    (< i1@559@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
                    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@561@04  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@559@04)) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@559@04))
                    (< i2@560@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
                    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@563@04  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@560@04)) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@560@04))))))))))
    (implies
      (and
        (and
          (and
            (and
              (=
                ($FVF.lookup_option$array$ (as sm@561@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@559@04))
                ($FVF.lookup_option$array$ (as sm@563@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@560@04)))
              (< i2@560@04 V@15@04))
            (<= 0 i2@560@04))
          (< i1@559@04 V@15@04))
        (<= 0 i1@559@04))
      (and
        (=
          ($FVF.lookup_option$array$ (as sm@561@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@559@04))
          ($FVF.lookup_option$array$ (as sm@563@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@560@04)))
        (< i2@560@04 V@15@04)
        (<= 0 i2@560@04)
        (< i1@559@04 V@15@04)
        (<= 0 i1@559@04))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@560@04))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 17
; Nested auxiliary terms: globals (aux)
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (-
          (ite
            (and (< (inv@296@04 r) V@15@04) (<= 0 (inv@296@04 r)))
            $k@295@04
            $Perm.No)
          (pTaken@380@04 r))
        (pTaken@469@04 r)))
    (=
      ($FVF.lookup_option$array$ (as sm@561@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@561@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r))
  :qid |qp.fvfValDef428|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@357@04 r) V@15@04) (<= 0 (inv@357@04 r)))
      (< $Perm.No $k@356@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@561@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@561@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))) r))
  :qid |qp.fvfValDef429|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@445@04 r) V@15@04) (<= 0 (inv@445@04 r)))
      (< $Perm.No $k@444@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@561@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@561@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))) r))
  :qid |qp.fvfValDef430|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))) r) r))
  :pattern (($FVF.lookup_option$array$ (as sm@561@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef431|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@562@04  $FPM) r)
    (+
      (+
        (-
          (-
            (ite
              (and (< (inv@296@04 r) V@15@04) (<= 0 (inv@296@04 r)))
              $k@295@04
              $Perm.No)
            (pTaken@380@04 r))
          (pTaken@469@04 r))
        (ite
          (and (< (inv@357@04 r) V@15@04) (<= 0 (inv@357@04 r)))
          $k@356@04
          $Perm.No))
      (ite
        (and (< (inv@445@04 r) V@15@04) (<= 0 (inv@445@04 r)))
        $k@444@04
        $Perm.No)))
  :pattern (($FVF.perm_option$array$ (as pm@562@04  $FPM) r))
  :qid |qp.resPrmSumDef432|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@561@04  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@562@04  $FPM) r))
  :qid |qp.resTrgDef433|)))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (-
          (ite
            (and (< (inv@296@04 r) V@15@04) (<= 0 (inv@296@04 r)))
            $k@295@04
            $Perm.No)
          (pTaken@380@04 r))
        (pTaken@469@04 r)))
    (=
      ($FVF.lookup_option$array$ (as sm@563@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@563@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r))
  :qid |qp.fvfValDef434|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@357@04 r) V@15@04) (<= 0 (inv@357@04 r)))
      (< $Perm.No $k@356@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@563@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@563@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))) r))
  :qid |qp.fvfValDef435|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@445@04 r) V@15@04) (<= 0 (inv@445@04 r)))
      (< $Perm.No $k@444@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@563@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@563@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))) r))
  :qid |qp.fvfValDef436|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))) r) r))
  :pattern (($FVF.lookup_option$array$ (as sm@563@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef437|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@564@04  $FPM) r)
    (+
      (+
        (-
          (-
            (ite
              (and (< (inv@296@04 r) V@15@04) (<= 0 (inv@296@04 r)))
              $k@295@04
              $Perm.No)
            (pTaken@380@04 r))
          (pTaken@469@04 r))
        (ite
          (and (< (inv@357@04 r) V@15@04) (<= 0 (inv@357@04 r)))
          $k@356@04
          $Perm.No))
      (ite
        (and (< (inv@445@04 r) V@15@04) (<= 0 (inv@445@04 r)))
        $k@444@04
        $Perm.No)))
  :pattern (($FVF.perm_option$array$ (as pm@564@04  $FPM) r))
  :qid |qp.resPrmSumDef438|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@563@04  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@564@04  $FPM) r))
  :qid |qp.resTrgDef439|)))
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
; Nested auxiliary terms: non-globals (tlq)
(push) ; 17
(assert (not (forall ((i1@559@04 Int)) (!
  (forall ((i2@560@04 Int)) (!
    (implies
      (and
        (and
          (and
            (and
              (=
                ($FVF.lookup_option$array$ (as sm@561@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@559@04))
                ($FVF.lookup_option$array$ (as sm@563@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@560@04)))
              (< i2@560@04 V@15@04))
            (<= 0 i2@560@04))
          (< i1@559@04 V@15@04))
        (<= 0 i1@559@04))
      (= i1@559@04 i2@560@04))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@560@04))
    :qid |prog.l<no position>|))
  
  :qid |prog.l<no position>|))))
(check-sat)
; unsat
(pop) ; 17
; 0.04s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               24160178
;  :arith-add-rows          5076644
;  :arith-assert-diseq      164973
;  :arith-assert-lower      4369955
;  :arith-assert-upper      3759975
;  :arith-bound-prop        114060
;  :arith-conflicts         3009
;  :arith-eq-adapter        1672470
;  :arith-fixed-eqs         3922988
;  :arith-offset-eqs        2299606
;  :arith-pivots            709810
;  :conflicts               7056
;  :datatype-accessor-ax    508
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1016395
;  :del-clause              63001836
;  :final-checks            5
;  :max-generation          14
;  :max-memory              517.91
;  :memory                  499.74
;  :minimized-lits          1063
;  :mk-bool-var             54211105
;  :mk-clause               63003887
;  :num-allocs              128262238
;  :num-checks              624
;  :propagations            18678758
;  :quant-instantiations    22742006
;  :restarts                15
;  :rlimit-count            506846812
;  :time                    0.04)
(assert (forall ((i1@559@04 Int)) (!
  (forall ((i2@560@04 Int)) (!
    (implies
      (and
        (and
          (and
            (and
              (=
                ($FVF.lookup_option$array$ (as sm@561@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@559@04))
                ($FVF.lookup_option$array$ (as sm@563@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@560@04)))
              (< i2@560@04 V@15@04))
            (<= 0 i2@560@04))
          (< i1@559@04 V@15@04))
        (<= 0 i1@559@04))
      (= i1@559@04 i2@560@04))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@560@04))
    :qid |prog.l<no position>|))
  
  :qid |prog.l<no position>|)))
(declare-const i1@565@04 Int)
(declare-const j@566@04 Int)
(push) ; 17
; [eval] 0 <= i1 && i1 < V && (0 <= j && j < V)
; [eval] 0 <= i1
(push) ; 18
; [then-branch: 296 | 0 <= i1@565@04 | live]
; [else-branch: 296 | !(0 <= i1@565@04) | live]
(push) ; 19
; [then-branch: 296 | 0 <= i1@565@04]
(assert (<= 0 i1@565@04))
; [eval] i1 < V
(push) ; 20
; [then-branch: 297 | i1@565@04 < V@15@04 | live]
; [else-branch: 297 | !(i1@565@04 < V@15@04) | live]
(push) ; 21
; [then-branch: 297 | i1@565@04 < V@15@04]
(assert (< i1@565@04 V@15@04))
; [eval] 0 <= j
(push) ; 22
; [then-branch: 298 | 0 <= j@566@04 | live]
; [else-branch: 298 | !(0 <= j@566@04) | live]
(push) ; 23
; [then-branch: 298 | 0 <= j@566@04]
(assert (<= 0 j@566@04))
; [eval] j < V
(pop) ; 23
(push) ; 23
; [else-branch: 298 | !(0 <= j@566@04)]
(assert (not (<= 0 j@566@04)))
(pop) ; 23
(pop) ; 22
; Joined path conditions
; Joined path conditions
(pop) ; 21
(push) ; 21
; [else-branch: 297 | !(i1@565@04 < V@15@04)]
(assert (not (< i1@565@04 V@15@04)))
(pop) ; 21
(pop) ; 20
; Joined path conditions
; Joined path conditions
(pop) ; 19
(push) ; 19
; [else-branch: 296 | !(0 <= i1@565@04)]
(assert (not (<= 0 i1@565@04)))
(pop) ; 19
(pop) ; 18
; Joined path conditions
; Joined path conditions
(assert (and
  (and (and (< j@566@04 V@15@04) (<= 0 j@566@04)) (< i1@565@04 V@15@04))
  (<= 0 i1@565@04)))
(declare-const $k@567@04 $Perm)
(assert ($Perm.isReadVar $k@567@04 $Perm.Write))
; [eval] aloc(opt_get1(aloc(opt_get1(a2), i1).option$array$), j)
; [eval] opt_get1(aloc(opt_get1(a2), i1).option$array$)
; [eval] aloc(opt_get1(a2), i1)
; [eval] opt_get1(a2)
(push) ; 18
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 18
; Joined path conditions
(push) ; 18
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 19
(assert (not (< i1@565@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))))
(check-sat)
; unsat
(pop) ; 19
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               24160178
;  :arith-add-rows          5076647
;  :arith-assert-diseq      164974
;  :arith-assert-lower      4369963
;  :arith-assert-upper      3759976
;  :arith-bound-prop        114060
;  :arith-conflicts         3009
;  :arith-eq-adapter        1672471
;  :arith-fixed-eqs         3922988
;  :arith-offset-eqs        2299606
;  :arith-pivots            709812
;  :conflicts               7056
;  :datatype-accessor-ax    508
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1016395
;  :del-clause              63001836
;  :final-checks            5
;  :max-generation          14
;  :max-memory              517.91
;  :memory                  499.74
;  :minimized-lits          1063
;  :mk-bool-var             54211116
;  :mk-clause               63003889
;  :num-allocs              128262909
;  :num-checks              625
;  :propagations            18678759
;  :quant-instantiations    22742006
;  :restarts                15
;  :rlimit-count            506847914)
(assert (< i1@565@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(pop) ; 18
; Joined path conditions
(assert (< i1@565@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(declare-const sm@568@04 $FVF<option<array>>)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (-
          (ite
            (and (< (inv@296@04 r) V@15@04) (<= 0 (inv@296@04 r)))
            $k@295@04
            $Perm.No)
          (pTaken@380@04 r))
        (pTaken@469@04 r)))
    (=
      ($FVF.lookup_option$array$ (as sm@568@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@568@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r))
  :qid |qp.fvfValDef440|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@357@04 r) V@15@04) (<= 0 (inv@357@04 r)))
      (< $Perm.No $k@356@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@568@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@568@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))) r))
  :qid |qp.fvfValDef441|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@445@04 r) V@15@04) (<= 0 (inv@445@04 r)))
      (< $Perm.No $k@444@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@568@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@568@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))) r))
  :qid |qp.fvfValDef442|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))) r) r))
  :pattern (($FVF.lookup_option$array$ (as sm@568@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef443|)))
(declare-const pm@569@04 $FPM)
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@569@04  $FPM) r)
    (+
      (+
        (-
          (-
            (ite
              (and (< (inv@296@04 r) V@15@04) (<= 0 (inv@296@04 r)))
              $k@295@04
              $Perm.No)
            (pTaken@380@04 r))
          (pTaken@469@04 r))
        (ite
          (and (< (inv@357@04 r) V@15@04) (<= 0 (inv@357@04 r)))
          $k@356@04
          $Perm.No))
      (ite
        (and (< (inv@445@04 r) V@15@04) (<= 0 (inv@445@04 r)))
        $k@444@04
        $Perm.No)))
  :pattern (($FVF.perm_option$array$ (as pm@569@04  $FPM) r))
  :qid |qp.resPrmSumDef444|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@568@04  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@569@04  $FPM) r))
  :qid |qp.resTrgDef445|)))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@568@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@565@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@565@04)))
(push) ; 18
(assert (not (<
  $Perm.No
  ($FVF.perm_option$array$ (as pm@569@04  $FPM) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@565@04)))))
(check-sat)
; unsat
(pop) ; 18
; 0.03s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               24161340
;  :arith-add-rows          5077741
;  :arith-assert-diseq      164992
;  :arith-assert-lower      4370112
;  :arith-assert-upper      3760073
;  :arith-bound-prop        114104
;  :arith-conflicts         3013
;  :arith-eq-adapter        1672584
;  :arith-fixed-eqs         3923090
;  :arith-offset-eqs        2299663
;  :arith-pivots            709885
;  :conflicts               7063
;  :datatype-accessor-ax    508
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1016693
;  :del-clause              63011158
;  :final-checks            5
;  :max-generation          14
;  :max-memory              517.91
;  :memory                  499.79
;  :minimized-lits          1063
;  :mk-bool-var             54218214
;  :mk-clause               63013712
;  :num-allocs              128285738
;  :num-checks              626
;  :propagations            18680262
;  :quant-instantiations    22743767
;  :restarts                15
;  :rlimit-count            506951648
;  :time                    0.03)
(push) ; 18
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 19
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@568@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@565@04))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 19
; 0.04s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               24161916
;  :arith-add-rows          5078627
;  :arith-assert-diseq      165002
;  :arith-assert-lower      4370192
;  :arith-assert-upper      3760131
;  :arith-bound-prop        114123
;  :arith-conflicts         3014
;  :arith-eq-adapter        1672638
;  :arith-fixed-eqs         3923158
;  :arith-offset-eqs        2299681
;  :arith-pivots            709908
;  :conflicts               7081
;  :datatype-accessor-ax    508
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1016986
;  :del-clause              63020376
;  :final-checks            5
;  :max-generation          14
;  :max-memory              517.91
;  :memory                  499.79
;  :minimized-lits          1063
;  :mk-bool-var             54224370
;  :mk-clause               63022930
;  :num-allocs              128303270
;  :num-checks              627
;  :propagations            18681425
;  :quant-instantiations    22745213
;  :restarts                15
;  :rlimit-count            507034350
;  :time                    0.03)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@568@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@565@04))
    (as None<option<array>>  option<array>))))
(pop) ; 18
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@568@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@565@04))
    (as None<option<array>>  option<array>))))
(push) ; 18
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 19
(assert (not (<
  j@566@04
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@568@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@565@04)))))))
(check-sat)
; unsat
(pop) ; 19
; 0.03s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               24162741
;  :arith-add-rows          5079504
;  :arith-assert-diseq      165012
;  :arith-assert-lower      4370275
;  :arith-assert-upper      3760190
;  :arith-bound-prop        114142
;  :arith-conflicts         3016
;  :arith-eq-adapter        1672700
;  :arith-fixed-eqs         3923227
;  :arith-offset-eqs        2299699
;  :arith-pivots            709932
;  :conflicts               7099
;  :datatype-accessor-ax    508
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1017279
;  :del-clause              63029617
;  :final-checks            5
;  :max-generation          14
;  :max-memory              517.91
;  :memory                  499.79
;  :minimized-lits          1063
;  :mk-bool-var             54230604
;  :mk-clause               63032171
;  :num-allocs              128321188
;  :num-checks              628
;  :propagations            18682783
;  :quant-instantiations    22746685
;  :restarts                15
;  :rlimit-count            507117957
;  :time                    0.03)
(assert (<
  j@566@04
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@568@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@565@04))))))
(pop) ; 18
; Joined path conditions
(assert (<
  j@566@04
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@568@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@565@04))))))
(pop) ; 17
(declare-fun inv@570@04 ($Ref) Int)
(declare-fun inv@571@04 ($Ref) Int)
; Nested auxiliary terms: globals
(assert ($Perm.isReadVar $k@567@04 $Perm.Write))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (-
          (ite
            (and (< (inv@296@04 r) V@15@04) (<= 0 (inv@296@04 r)))
            $k@295@04
            $Perm.No)
          (pTaken@380@04 r))
        (pTaken@469@04 r)))
    (=
      ($FVF.lookup_option$array$ (as sm@568@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@568@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r))
  :qid |qp.fvfValDef440|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@357@04 r) V@15@04) (<= 0 (inv@357@04 r)))
      (< $Perm.No $k@356@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@568@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@568@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))) r))
  :qid |qp.fvfValDef441|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@445@04 r) V@15@04) (<= 0 (inv@445@04 r)))
      (< $Perm.No $k@444@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@568@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@568@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))) r))
  :qid |qp.fvfValDef442|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))) r) r))
  :pattern (($FVF.lookup_option$array$ (as sm@568@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef443|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@569@04  $FPM) r)
    (+
      (+
        (-
          (-
            (ite
              (and (< (inv@296@04 r) V@15@04) (<= 0 (inv@296@04 r)))
              $k@295@04
              $Perm.No)
            (pTaken@380@04 r))
          (pTaken@469@04 r))
        (ite
          (and (< (inv@357@04 r) V@15@04) (<= 0 (inv@357@04 r)))
          $k@356@04
          $Perm.No))
      (ite
        (and (< (inv@445@04 r) V@15@04) (<= 0 (inv@445@04 r)))
        $k@444@04
        $Perm.No)))
  :pattern (($FVF.perm_option$array$ (as pm@569@04  $FPM) r))
  :qid |qp.resPrmSumDef444|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@568@04  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@569@04  $FPM) r))
  :qid |qp.resTrgDef445|)))
; Nested auxiliary terms: non-globals
(assert (forall ((i1@565@04 Int) (j@566@04 Int)) (!
  (and
    (< i1@565@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@568@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@565@04)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@565@04))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@568@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@565@04))
        (as None<option<array>>  option<array>)))
    (<
      j@566@04
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@568@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@565@04))))))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@568@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@565@04))) j@566@04))
  :qid |int-aux|)))
(push) ; 17
(assert (not (forall ((i1@565@04 Int) (j@566@04 Int)) (!
  (implies
    (and
      (and (and (< j@566@04 V@15@04) (<= 0 j@566@04)) (< i1@565@04 V@15@04))
      (<= 0 i1@565@04))
    (or (= $k@567@04 $Perm.No) (< $Perm.No $k@567@04)))
  
  ))))
(check-sat)
; unsat
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               24162741
;  :arith-add-rows          5079527
;  :arith-assert-diseq      165013
;  :arith-assert-lower      4370277
;  :arith-assert-upper      3760191
;  :arith-bound-prop        114142
;  :arith-conflicts         3016
;  :arith-eq-adapter        1672701
;  :arith-fixed-eqs         3923227
;  :arith-offset-eqs        2299699
;  :arith-pivots            709960
;  :conflicts               7100
;  :datatype-accessor-ax    508
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1017279
;  :del-clause              63030120
;  :final-checks            5
;  :max-generation          14
;  :max-memory              517.91
;  :memory                  499.74
;  :minimized-lits          1063
;  :mk-bool-var             54230619
;  :mk-clause               63032173
;  :num-allocs              128322829
;  :num-checks              629
;  :propagations            18682784
;  :quant-instantiations    22746685
;  :restarts                15
;  :rlimit-count            507123369)
(declare-const sm@572@04 $FVF<Int>)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@457@04 r) V@15@04) (<= 0 (inv@457@04 r)))
    (=
      ($FVF.lookup_int (as sm@572@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04)))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@572@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04)))))))))))))) r))
  :qid |qp.fvfValDef446|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@454@04 r) V@15@04) (<= 0 (inv@454@04 r)))
        (< (inv@453@04 r) V@15@04))
      (<= 0 (inv@453@04 r)))
    (=
      ($FVF.lookup_int (as sm@572@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@572@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))))))) r))
  :qid |qp.fvfValDef447|)))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (-
          (ite
            (and
              (and
                (and (< (inv@366@04 r) V@15@04) (<= 0 (inv@366@04 r)))
                (< (inv@365@04 r) V@15@04))
              (<= 0 (inv@365@04 r)))
            $Perm.Write
            $Perm.No)
          (pTaken@481@04 r))
        (pTaken@485@04 r)))
    (=
      ($FVF.lookup_int (as sm@572@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@572@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))))))) r))
  :qid |qp.fvfValDef448|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04)))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@572@04  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef449|)))
; Check receiver injectivity
(push) ; 17
(assert (not (forall ((i11@565@04 Int) (j1@566@04 Int) (i12@565@04 Int) (j2@566@04 Int)) (!
  (implies
    (and
      (and
        (and
          (and
            (and
              (and (< j1@566@04 V@15@04) (<= 0 j1@566@04))
              (< i11@565@04 V@15@04))
            (<= 0 i11@565@04))
          ($FVF.loc_int ($FVF.lookup_int (as sm@572@04  $FVF<Int>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@568@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i11@565@04))) j1@566@04)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@568@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i11@565@04))) j1@566@04)))
        (< $Perm.No $k@567@04))
      (and
        (and
          (and
            (and
              (and (< j2@566@04 V@15@04) (<= 0 j2@566@04))
              (< i12@565@04 V@15@04))
            (<= 0 i12@565@04))
          ($FVF.loc_int ($FVF.lookup_int (as sm@572@04  $FVF<Int>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@568@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i12@565@04))) j2@566@04)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@568@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i12@565@04))) j2@566@04)))
        (< $Perm.No $k@567@04))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@568@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i11@565@04))) j1@566@04)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@568@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i12@565@04))) j2@566@04)))
    (and (= i11@565@04 i12@565@04) (= j1@566@04 j2@566@04)))
  
  :qid |int-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 17
; 0.04s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               24164030
;  :arith-add-rows          5081083
;  :arith-assert-diseq      165025
;  :arith-assert-lower      4370456
;  :arith-assert-upper      3760324
;  :arith-bound-prop        114237
;  :arith-conflicts         3018
;  :arith-eq-adapter        1672836
;  :arith-fixed-eqs         3923367
;  :arith-offset-eqs        2299838
;  :arith-pivots            710135
;  :conflicts               7118
;  :datatype-accessor-ax    508
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1017574
;  :del-clause              63041087
;  :final-checks            5
;  :max-generation          14
;  :max-memory              517.91
;  :memory                  499.74
;  :minimized-lits          1063
;  :mk-bool-var             54239426
;  :mk-clause               63043140
;  :num-allocs              128350451
;  :num-checks              630
;  :propagations            18684290
;  :quant-instantiations    22748929
;  :restarts                15
;  :rlimit-count            507255821
;  :time                    0.04)
; Definitional axioms for inverse functions
(assert (forall ((i1@565@04 Int) (j@566@04 Int)) (!
  (implies
    (and
      (and
        (and (and (< j@566@04 V@15@04) (<= 0 j@566@04)) (< i1@565@04 V@15@04))
        (<= 0 i1@565@04))
      (< $Perm.No $k@567@04))
    (and
      (=
        (inv@570@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@568@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@565@04))) j@566@04))
        i1@565@04)
      (=
        (inv@571@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@568@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@565@04))) j@566@04))
        j@566@04)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@568@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@565@04))) j@566@04))
  :qid |int-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and
          (and (< (inv@571@04 r) V@15@04) (<= 0 (inv@571@04 r)))
          (< (inv@570@04 r) V@15@04))
        (<= 0 (inv@570@04 r)))
      (< $Perm.No $k@567@04))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@568@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) (inv@570@04 r)))) (inv@571@04 r))
      r))
  :pattern ((inv@570@04 r))
  :pattern ((inv@571@04 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@571@04 r) V@15@04) (<= 0 (inv@571@04 r)))
        (< (inv@570@04 r) V@15@04))
      (<= 0 (inv@570@04 r)))
    ($FVF.loc_int ($FVF.lookup_int (as sm@572@04  $FVF<Int>) r) r))
  :pattern ((inv@570@04 r) (inv@571@04 r))
  )))
; Precomputing data for removing quantified permissions
(define-fun pTaken@573@04 ((r $Ref)) $Perm
  (ite
    (and
      (and
        (and (< (inv@571@04 r) V@15@04) (<= 0 (inv@571@04 r)))
        (< (inv@570@04 r) V@15@04))
      (<= 0 (inv@570@04 r)))
    ($Perm.min
      (ite
        (and (< (inv@457@04 r) V@15@04) (<= 0 (inv@457@04 r)))
        $Perm.Write
        $Perm.No)
      $k@567@04)
    $Perm.No))
(define-fun pTaken@574@04 ((r $Ref)) $Perm
  (ite
    (and
      (and
        (and (< (inv@571@04 r) V@15@04) (<= 0 (inv@571@04 r)))
        (< (inv@570@04 r) V@15@04))
      (<= 0 (inv@570@04 r)))
    ($Perm.min
      (ite
        (and
          (and
            (and (< (inv@454@04 r) V@15@04) (<= 0 (inv@454@04 r)))
            (< (inv@453@04 r) V@15@04))
          (<= 0 (inv@453@04 r)))
        $Perm.Write
        $Perm.No)
      (- $k@567@04 (pTaken@573@04 r)))
    $Perm.No))
(define-fun pTaken@575@04 ((r $Ref)) $Perm
  (ite
    (and
      (and
        (and (< (inv@571@04 r) V@15@04) (<= 0 (inv@571@04 r)))
        (< (inv@570@04 r) V@15@04))
      (<= 0 (inv@570@04 r)))
    ($Perm.min
      (-
        (-
          (ite
            (and
              (and
                (and (< (inv@366@04 r) V@15@04) (<= 0 (inv@366@04 r)))
                (< (inv@365@04 r) V@15@04))
              (<= 0 (inv@365@04 r)))
            $Perm.Write
            $Perm.No)
          (pTaken@481@04 r))
        (pTaken@485@04 r))
      (- (- $k@567@04 (pTaken@573@04 r)) (pTaken@574@04 r)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Constrain original permissions $k@567@04
(assert (forall ((r $Ref)) (!
  (implies
    (not
      (=
        (ite
          (and (< (inv@457@04 r) V@15@04) (<= 0 (inv@457@04 r)))
          $Perm.Write
          $Perm.No)
        $Perm.No))
    (ite
      (and (< (inv@457@04 r) V@15@04) (<= 0 (inv@457@04 r)))
      (<
        (ite
          (and
            (and
              (and (< (inv@571@04 r) V@15@04) (<= 0 (inv@571@04 r)))
              (< (inv@570@04 r) V@15@04))
            (<= 0 (inv@570@04 r)))
          $k@567@04
          $Perm.No)
        $Perm.Write)
      (<
        (ite
          (and
            (and
              (and (< (inv@571@04 r) V@15@04) (<= 0 (inv@571@04 r)))
              (< (inv@570@04 r) V@15@04))
            (<= 0 (inv@570@04 r)))
          $k@567@04
          $Perm.No)
        $Perm.No)))
  :pattern ((inv@457@04 r))
  :pattern ((inv@571@04 r))
  :pattern ((inv@570@04 r))
  :qid |qp.srp450|)))
; Intermediate check if already taken enough permissions
(set-option :timeout 500)
(push) ; 17
(assert (not (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@571@04 r) V@15@04) (<= 0 (inv@571@04 r)))
        (< (inv@570@04 r) V@15@04))
      (<= 0 (inv@570@04 r)))
    (= (- $k@567@04 (pTaken@573@04 r)) $Perm.No))
  
  ))))
(check-sat)
; unknown
(pop) ; 17
; 0.54s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               24185440
;  :arith-add-rows          5093022
;  :arith-assert-diseq      165196
;  :arith-assert-lower      4373976
;  :arith-assert-upper      3762905
;  :arith-bound-prop        114941
;  :arith-conflicts         3027
;  :arith-eq-adapter        1675613
;  :arith-fixed-eqs         3925929
;  :arith-offset-eqs        2302448
;  :arith-pivots            712694
;  :conflicts               7134
;  :datatype-accessor-ax    508
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1020169
;  :del-clause              63177430
;  :final-checks            5
;  :max-generation          14
;  :max-memory              517.91
;  :memory                  493.14
;  :minimized-lits          1063
;  :mk-bool-var             54357169
;  :mk-clause               63179482
;  :num-allocs              128637820
;  :num-checks              632
;  :propagations            18711142
;  :quant-instantiations    22787741
;  :restarts                15
;  :rlimit-count            508484447
;  :time                    0.54)
; Constrain original permissions $k@567@04
(assert (forall ((r $Ref)) (!
  (implies
    (not
      (=
        (ite
          (and
            (and
              (and (< (inv@454@04 r) V@15@04) (<= 0 (inv@454@04 r)))
              (< (inv@453@04 r) V@15@04))
            (<= 0 (inv@453@04 r)))
          $Perm.Write
          $Perm.No)
        $Perm.No))
    (ite
      (and
        (and
          (and (< (inv@454@04 r) V@15@04) (<= 0 (inv@454@04 r)))
          (< (inv@453@04 r) V@15@04))
        (<= 0 (inv@453@04 r)))
      (<
        (ite
          (and
            (and
              (and (< (inv@571@04 r) V@15@04) (<= 0 (inv@571@04 r)))
              (< (inv@570@04 r) V@15@04))
            (<= 0 (inv@570@04 r)))
          $k@567@04
          $Perm.No)
        $Perm.Write)
      (<
        (ite
          (and
            (and
              (and (< (inv@571@04 r) V@15@04) (<= 0 (inv@571@04 r)))
              (< (inv@570@04 r) V@15@04))
            (<= 0 (inv@570@04 r)))
          $k@567@04
          $Perm.No)
        $Perm.No)))
  :pattern ((inv@454@04 r))
  :pattern ((inv@453@04 r))
  :pattern ((inv@571@04 r))
  :pattern ((inv@570@04 r))
  :qid |qp.srp451|)))
; Intermediate check if already taken enough permissions
(push) ; 17
(assert (not (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@571@04 r) V@15@04) (<= 0 (inv@571@04 r)))
        (< (inv@570@04 r) V@15@04))
      (<= 0 (inv@570@04 r)))
    (= (- (- $k@567@04 (pTaken@573@04 r)) (pTaken@574@04 r)) $Perm.No))
  
  ))))
(check-sat)
; unsat
(pop) ; 17
; 0.06s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               24186948
;  :arith-add-rows          5094428
;  :arith-assert-diseq      165219
;  :arith-assert-lower      4374177
;  :arith-assert-upper      3763060
;  :arith-bound-prop        115004
;  :arith-conflicts         3032
;  :arith-eq-adapter        1675769
;  :arith-fixed-eqs         3926075
;  :arith-offset-eqs        2302522
;  :arith-pivots            712864
;  :conflicts               7145
;  :datatype-accessor-ax    508
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1020470
;  :del-clause              63187987
;  :final-checks            5
;  :max-generation          14
;  :max-memory              517.91
;  :memory                  493.37
;  :minimized-lits          1063
;  :mk-bool-var             54365168
;  :mk-clause               63190039
;  :num-allocs              128663389
;  :num-checks              633
;  :propagations            18712783
;  :quant-instantiations    22789704
;  :restarts                15
;  :rlimit-count            508616254
;  :time                    0.06)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@576@04 $FVF<Int>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (iff
    (Set_in r ($FVF.domain_int (as sm@576@04  $FVF<Int>)))
    (and
      (and
        (and
          (and (< (inv@571@04 r) V@15@04) (<= 0 (inv@571@04 r)))
          (< (inv@570@04 r) V@15@04))
        (<= 0 (inv@570@04 r)))
      (< $Perm.No $k@567@04)))
  :pattern ((Set_in r ($FVF.domain_int (as sm@576@04  $FVF<Int>))))
  :qid |qp.fvfDomDef456|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and
          (and
            (and (< (inv@571@04 r) V@15@04) (<= 0 (inv@571@04 r)))
            (< (inv@570@04 r) V@15@04))
          (<= 0 (inv@570@04 r)))
        (< $Perm.No $k@567@04))
      (and (< (inv@457@04 r) V@15@04) (<= 0 (inv@457@04 r))))
    (=
      ($FVF.lookup_int (as sm@576@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04)))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@576@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04)))))))))))))) r))
  :qid |qp.fvfValDef452|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and
          (and
            (and (< (inv@571@04 r) V@15@04) (<= 0 (inv@571@04 r)))
            (< (inv@570@04 r) V@15@04))
          (<= 0 (inv@570@04 r)))
        (< $Perm.No $k@567@04))
      (and
        (and
          (and (< (inv@454@04 r) V@15@04) (<= 0 (inv@454@04 r)))
          (< (inv@453@04 r) V@15@04))
        (<= 0 (inv@453@04 r))))
    (=
      ($FVF.lookup_int (as sm@576@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@576@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))))))) r))
  :qid |qp.fvfValDef453|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and
          (and
            (and (< (inv@571@04 r) V@15@04) (<= 0 (inv@571@04 r)))
            (< (inv@570@04 r) V@15@04))
          (<= 0 (inv@570@04 r)))
        (< $Perm.No $k@567@04))
      (<
        $Perm.No
        (-
          (-
            (ite
              (and
                (and
                  (and (< (inv@366@04 r) V@15@04) (<= 0 (inv@366@04 r)))
                  (< (inv@365@04 r) V@15@04))
                (<= 0 (inv@365@04 r)))
              $Perm.Write
              $Perm.No)
            (pTaken@481@04 r))
          (pTaken@485@04 r))))
    (=
      ($FVF.lookup_int (as sm@576@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@576@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))))))) r))
  :qid |qp.fvfValDef454|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04)))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@576@04  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef455|)))
(pop) ; 16
; Joined path conditions
(assert ($Perm.isReadVar $k@546@04 $Perm.Write))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (-
          (ite
            (and (< (inv@296@04 r) V@15@04) (<= 0 (inv@296@04 r)))
            $k@295@04
            $Perm.No)
          (pTaken@380@04 r))
        (pTaken@469@04 r)))
    (=
      ($FVF.lookup_option$array$ (as sm@548@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@548@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r))
  :qid |qp.fvfValDef406|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@357@04 r) V@15@04) (<= 0 (inv@357@04 r)))
      (< $Perm.No $k@356@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@548@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@548@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))) r))
  :qid |qp.fvfValDef407|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@445@04 r) V@15@04) (<= 0 (inv@445@04 r)))
      (< $Perm.No $k@444@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@548@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@548@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))) r))
  :qid |qp.fvfValDef408|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))) r) r))
  :pattern (($FVF.lookup_option$array$ (as sm@548@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef409|)))
(assert (forall ((i1@545@04 Int)) (!
  (implies
    (and (and (< i1@545@04 V@15@04) (<= 0 i1@545@04)) (< $Perm.No $k@546@04))
    (=
      (inv@547@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@545@04))
      i1@545@04))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@545@04))
  :qid |option$array$-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and (< (inv@547@04 r) V@15@04) (<= 0 (inv@547@04 r)))
      (< $Perm.No $k@546@04))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) (inv@547@04 r))
      r))
  :pattern ((inv@547@04 r))
  :qid |option$array$-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (iff
    (Set_in r ($FVF.domain_option$array$ (as sm@552@04  $FVF<option<array>>)))
    (and
      (and (< (inv@547@04 r) V@15@04) (<= 0 (inv@547@04 r)))
      (< $Perm.No $k@546@04)))
  :pattern ((Set_in r ($FVF.domain_option$array$ (as sm@552@04  $FVF<option<array>>))))
  :qid |qp.fvfDomDef415|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@547@04 r) V@15@04) (<= 0 (inv@547@04 r)))
        (< $Perm.No $k@546@04))
      (<
        $Perm.No
        (-
          (-
            (ite
              (and (< (inv@296@04 r) V@15@04) (<= 0 (inv@296@04 r)))
              $k@295@04
              $Perm.No)
            (pTaken@380@04 r))
          (pTaken@469@04 r))))
    (=
      ($FVF.lookup_option$array$ (as sm@552@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@552@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r))
  :qid |qp.fvfValDef411|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@547@04 r) V@15@04) (<= 0 (inv@547@04 r)))
        (< $Perm.No $k@546@04))
      (ite
        (and (< (inv@357@04 r) V@15@04) (<= 0 (inv@357@04 r)))
        (< $Perm.No $k@356@04)
        false))
    (=
      ($FVF.lookup_option$array$ (as sm@552@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@552@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))) r))
  :qid |qp.fvfValDef412|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@547@04 r) V@15@04) (<= 0 (inv@547@04 r)))
        (< $Perm.No $k@546@04))
      (ite
        (and (< (inv@445@04 r) V@15@04) (<= 0 (inv@445@04 r)))
        (< $Perm.No $k@444@04)
        false))
    (=
      ($FVF.lookup_option$array$ (as sm@552@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@552@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))) r))
  :qid |qp.fvfValDef413|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))) r) r))
  :pattern (($FVF.lookup_option$array$ (as sm@552@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef414|)))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (-
          (ite
            (and (< (inv@296@04 r) V@15@04) (<= 0 (inv@296@04 r)))
            $k@295@04
            $Perm.No)
          (pTaken@380@04 r))
        (pTaken@469@04 r)))
    (=
      ($FVF.lookup_option$array$ (as sm@554@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@554@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r))
  :qid |qp.fvfValDef416|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@357@04 r) V@15@04) (<= 0 (inv@357@04 r)))
      (< $Perm.No $k@356@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@554@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@554@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))) r))
  :qid |qp.fvfValDef417|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@445@04 r) V@15@04) (<= 0 (inv@445@04 r)))
      (< $Perm.No $k@444@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@554@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@554@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))) r))
  :qid |qp.fvfValDef418|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))) r) r))
  :pattern (($FVF.lookup_option$array$ (as sm@554@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef419|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@555@04  $FPM) r)
    (+
      (+
        (-
          (-
            (ite
              (and (< (inv@296@04 r) V@15@04) (<= 0 (inv@296@04 r)))
              $k@295@04
              $Perm.No)
            (pTaken@380@04 r))
          (pTaken@469@04 r))
        (ite
          (and (< (inv@357@04 r) V@15@04) (<= 0 (inv@357@04 r)))
          $k@356@04
          $Perm.No))
      (ite
        (and (< (inv@445@04 r) V@15@04) (<= 0 (inv@445@04 r)))
        $k@444@04
        $Perm.No)))
  :pattern (($FVF.perm_option$array$ (as pm@555@04  $FPM) r))
  :qid |qp.resPrmSumDef420|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@554@04  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@555@04  $FPM) r))
  :qid |qp.resTrgDef421|)))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (-
          (ite
            (and (< (inv@296@04 r) V@15@04) (<= 0 (inv@296@04 r)))
            $k@295@04
            $Perm.No)
          (pTaken@380@04 r))
        (pTaken@469@04 r)))
    (=
      ($FVF.lookup_option$array$ (as sm@557@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@557@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r))
  :qid |qp.fvfValDef422|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@357@04 r) V@15@04) (<= 0 (inv@357@04 r)))
      (< $Perm.No $k@356@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@557@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@557@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))) r))
  :qid |qp.fvfValDef423|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@445@04 r) V@15@04) (<= 0 (inv@445@04 r)))
      (< $Perm.No $k@444@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@557@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@557@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))) r))
  :qid |qp.fvfValDef424|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))) r) r))
  :pattern (($FVF.lookup_option$array$ (as sm@557@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef425|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@558@04  $FPM) r)
    (+
      (+
        (-
          (-
            (ite
              (and (< (inv@296@04 r) V@15@04) (<= 0 (inv@296@04 r)))
              $k@295@04
              $Perm.No)
            (pTaken@380@04 r))
          (pTaken@469@04 r))
        (ite
          (and (< (inv@357@04 r) V@15@04) (<= 0 (inv@357@04 r)))
          $k@356@04
          $Perm.No))
      (ite
        (and (< (inv@445@04 r) V@15@04) (<= 0 (inv@445@04 r)))
        $k@444@04
        $Perm.No)))
  :pattern (($FVF.perm_option$array$ (as pm@558@04  $FPM) r))
  :qid |qp.resPrmSumDef426|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@557@04  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@558@04  $FPM) r))
  :qid |qp.resTrgDef427|)))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (-
          (ite
            (and (< (inv@296@04 r) V@15@04) (<= 0 (inv@296@04 r)))
            $k@295@04
            $Perm.No)
          (pTaken@380@04 r))
        (pTaken@469@04 r)))
    (=
      ($FVF.lookup_option$array$ (as sm@561@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@561@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r))
  :qid |qp.fvfValDef428|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@357@04 r) V@15@04) (<= 0 (inv@357@04 r)))
      (< $Perm.No $k@356@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@561@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@561@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))) r))
  :qid |qp.fvfValDef429|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@445@04 r) V@15@04) (<= 0 (inv@445@04 r)))
      (< $Perm.No $k@444@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@561@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@561@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))) r))
  :qid |qp.fvfValDef430|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))) r) r))
  :pattern (($FVF.lookup_option$array$ (as sm@561@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef431|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@562@04  $FPM) r)
    (+
      (+
        (-
          (-
            (ite
              (and (< (inv@296@04 r) V@15@04) (<= 0 (inv@296@04 r)))
              $k@295@04
              $Perm.No)
            (pTaken@380@04 r))
          (pTaken@469@04 r))
        (ite
          (and (< (inv@357@04 r) V@15@04) (<= 0 (inv@357@04 r)))
          $k@356@04
          $Perm.No))
      (ite
        (and (< (inv@445@04 r) V@15@04) (<= 0 (inv@445@04 r)))
        $k@444@04
        $Perm.No)))
  :pattern (($FVF.perm_option$array$ (as pm@562@04  $FPM) r))
  :qid |qp.resPrmSumDef432|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@561@04  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@562@04  $FPM) r))
  :qid |qp.resTrgDef433|)))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (-
          (ite
            (and (< (inv@296@04 r) V@15@04) (<= 0 (inv@296@04 r)))
            $k@295@04
            $Perm.No)
          (pTaken@380@04 r))
        (pTaken@469@04 r)))
    (=
      ($FVF.lookup_option$array$ (as sm@563@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@563@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r))
  :qid |qp.fvfValDef434|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@357@04 r) V@15@04) (<= 0 (inv@357@04 r)))
      (< $Perm.No $k@356@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@563@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@563@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))) r))
  :qid |qp.fvfValDef435|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@445@04 r) V@15@04) (<= 0 (inv@445@04 r)))
      (< $Perm.No $k@444@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@563@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@563@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))) r))
  :qid |qp.fvfValDef436|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))) r) r))
  :pattern (($FVF.lookup_option$array$ (as sm@563@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef437|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@564@04  $FPM) r)
    (+
      (+
        (-
          (-
            (ite
              (and (< (inv@296@04 r) V@15@04) (<= 0 (inv@296@04 r)))
              $k@295@04
              $Perm.No)
            (pTaken@380@04 r))
          (pTaken@469@04 r))
        (ite
          (and (< (inv@357@04 r) V@15@04) (<= 0 (inv@357@04 r)))
          $k@356@04
          $Perm.No))
      (ite
        (and (< (inv@445@04 r) V@15@04) (<= 0 (inv@445@04 r)))
        $k@444@04
        $Perm.No)))
  :pattern (($FVF.perm_option$array$ (as pm@564@04  $FPM) r))
  :qid |qp.resPrmSumDef438|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@563@04  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@564@04  $FPM) r))
  :qid |qp.resTrgDef439|)))
(assert ($Perm.isReadVar $k@567@04 $Perm.Write))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (-
          (ite
            (and (< (inv@296@04 r) V@15@04) (<= 0 (inv@296@04 r)))
            $k@295@04
            $Perm.No)
          (pTaken@380@04 r))
        (pTaken@469@04 r)))
    (=
      ($FVF.lookup_option$array$ (as sm@568@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@568@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r))
  :qid |qp.fvfValDef440|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@357@04 r) V@15@04) (<= 0 (inv@357@04 r)))
      (< $Perm.No $k@356@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@568@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@568@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))) r))
  :qid |qp.fvfValDef441|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@445@04 r) V@15@04) (<= 0 (inv@445@04 r)))
      (< $Perm.No $k@444@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@568@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@568@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))) r))
  :qid |qp.fvfValDef442|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))) r) r))
  :pattern (($FVF.lookup_option$array$ (as sm@568@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef443|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@569@04  $FPM) r)
    (+
      (+
        (-
          (-
            (ite
              (and (< (inv@296@04 r) V@15@04) (<= 0 (inv@296@04 r)))
              $k@295@04
              $Perm.No)
            (pTaken@380@04 r))
          (pTaken@469@04 r))
        (ite
          (and (< (inv@357@04 r) V@15@04) (<= 0 (inv@357@04 r)))
          $k@356@04
          $Perm.No))
      (ite
        (and (< (inv@445@04 r) V@15@04) (<= 0 (inv@445@04 r)))
        $k@444@04
        $Perm.No)))
  :pattern (($FVF.perm_option$array$ (as pm@569@04  $FPM) r))
  :qid |qp.resPrmSumDef444|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@568@04  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@569@04  $FPM) r))
  :qid |qp.resTrgDef445|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@457@04 r) V@15@04) (<= 0 (inv@457@04 r)))
    (=
      ($FVF.lookup_int (as sm@572@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04)))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@572@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04)))))))))))))) r))
  :qid |qp.fvfValDef446|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@454@04 r) V@15@04) (<= 0 (inv@454@04 r)))
        (< (inv@453@04 r) V@15@04))
      (<= 0 (inv@453@04 r)))
    (=
      ($FVF.lookup_int (as sm@572@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@572@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))))))) r))
  :qid |qp.fvfValDef447|)))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (-
          (ite
            (and
              (and
                (and (< (inv@366@04 r) V@15@04) (<= 0 (inv@366@04 r)))
                (< (inv@365@04 r) V@15@04))
              (<= 0 (inv@365@04 r)))
            $Perm.Write
            $Perm.No)
          (pTaken@481@04 r))
        (pTaken@485@04 r)))
    (=
      ($FVF.lookup_int (as sm@572@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@572@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))))))) r))
  :qid |qp.fvfValDef448|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04)))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@572@04  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef449|)))
(assert (forall ((i1@565@04 Int) (j@566@04 Int)) (!
  (implies
    (and
      (and
        (and (and (< j@566@04 V@15@04) (<= 0 j@566@04)) (< i1@565@04 V@15@04))
        (<= 0 i1@565@04))
      (< $Perm.No $k@567@04))
    (and
      (=
        (inv@570@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@568@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@565@04))) j@566@04))
        i1@565@04)
      (=
        (inv@571@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@568@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@565@04))) j@566@04))
        j@566@04)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@568@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@565@04))) j@566@04))
  :qid |int-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and
          (and (< (inv@571@04 r) V@15@04) (<= 0 (inv@571@04 r)))
          (< (inv@570@04 r) V@15@04))
        (<= 0 (inv@570@04 r)))
      (< $Perm.No $k@567@04))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@568@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) (inv@570@04 r)))) (inv@571@04 r))
      r))
  :pattern ((inv@570@04 r))
  :pattern ((inv@571@04 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (iff
    (Set_in r ($FVF.domain_int (as sm@576@04  $FVF<Int>)))
    (and
      (and
        (and
          (and (< (inv@571@04 r) V@15@04) (<= 0 (inv@571@04 r)))
          (< (inv@570@04 r) V@15@04))
        (<= 0 (inv@570@04 r)))
      (< $Perm.No $k@567@04)))
  :pattern ((Set_in r ($FVF.domain_int (as sm@576@04  $FVF<Int>))))
  :qid |qp.fvfDomDef456|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and
          (and
            (and (< (inv@571@04 r) V@15@04) (<= 0 (inv@571@04 r)))
            (< (inv@570@04 r) V@15@04))
          (<= 0 (inv@570@04 r)))
        (< $Perm.No $k@567@04))
      (and (< (inv@457@04 r) V@15@04) (<= 0 (inv@457@04 r))))
    (=
      ($FVF.lookup_int (as sm@576@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04)))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@576@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04)))))))))))))) r))
  :qid |qp.fvfValDef452|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and
          (and
            (and (< (inv@571@04 r) V@15@04) (<= 0 (inv@571@04 r)))
            (< (inv@570@04 r) V@15@04))
          (<= 0 (inv@570@04 r)))
        (< $Perm.No $k@567@04))
      (and
        (and
          (and (< (inv@454@04 r) V@15@04) (<= 0 (inv@454@04 r)))
          (< (inv@453@04 r) V@15@04))
        (<= 0 (inv@453@04 r))))
    (=
      ($FVF.lookup_int (as sm@576@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@576@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))))))) r))
  :qid |qp.fvfValDef453|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and
          (and
            (and (< (inv@571@04 r) V@15@04) (<= 0 (inv@571@04 r)))
            (< (inv@570@04 r) V@15@04))
          (<= 0 (inv@570@04 r)))
        (< $Perm.No $k@567@04))
      (<
        $Perm.No
        (-
          (-
            (ite
              (and
                (and
                  (and (< (inv@366@04 r) V@15@04) (<= 0 (inv@366@04 r)))
                  (< (inv@365@04 r) V@15@04))
                (<= 0 (inv@365@04 r)))
              $Perm.Write
              $Perm.No)
            (pTaken@481@04 r))
          (pTaken@485@04 r))))
    (=
      ($FVF.lookup_int (as sm@576@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@576@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))))))) r))
  :qid |qp.fvfValDef454|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04)))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@576@04  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef455|)))
(assert (and
  (forall ((i1@545@04 Int)) (!
    (< i1@545@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
    :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@545@04))
    :qid |option$array$-aux|))
  (forall ((r $Ref)) (!
    (implies
      (and (< (inv@547@04 r) V@15@04) (<= 0 (inv@547@04 r)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@548@04  $FVF<option<array>>) r) r))
    :pattern ((inv@547@04 r))
    ))
  (forall ((r $Ref)) (!
    (implies
      (not
        (=
          (-
            (-
              (ite
                (and (< (inv@296@04 r) V@15@04) (<= 0 (inv@296@04 r)))
                $k@295@04
                $Perm.No)
              (pTaken@380@04 r))
            (pTaken@469@04 r))
          $Perm.No))
      (<
        (ite
          (and (< (inv@547@04 r) V@15@04) (<= 0 (inv@547@04 r)))
          $k@546@04
          $Perm.No)
        (-
          (-
            (ite
              (and (< (inv@296@04 r) V@15@04) (<= 0 (inv@296@04 r)))
              $k@295@04
              $Perm.No)
            (pTaken@380@04 r))
          (pTaken@469@04 r))))
    :pattern ((inv@296@04 r))
    :pattern ((inv@547@04 r))
    :qid |qp.srp410|))
  (forall ((i1@553@04 Int)) (!
    (implies
      (and (< i1@553@04 V@15@04) (<= 0 i1@553@04))
      (not
        (=
          ($FVF.lookup_option$array$ (as sm@554@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@553@04))
          (as None<option<array>>  option<array>))))
    
    :qid |prog.l<no position>|))
  (forall ((i1@556@04 Int)) (!
    (implies
      (and (< i1@556@04 V@15@04) (<= 0 i1@556@04))
      (=
        (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@557@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@556@04))))
        V@15@04))
    
    :qid |prog.l<no position>|))
  (forall ((i1@559@04 Int)) (!
    (forall ((i2@560@04 Int)) (!
      (implies
        (and
          (and
            (and
              (and
                (=
                  ($FVF.lookup_option$array$ (as sm@561@04  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@559@04))
                  ($FVF.lookup_option$array$ (as sm@563@04  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@560@04)))
                (< i2@560@04 V@15@04))
              (<= 0 i2@560@04))
            (< i1@559@04 V@15@04))
          (<= 0 i1@559@04))
        (= i1@559@04 i2@560@04))
      :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@560@04))
      :qid |prog.l<no position>|))
    
    :qid |prog.l<no position>|))
  (forall ((i1@565@04 Int) (j@566@04 Int)) (!
    (and
      (< i1@565@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@568@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@565@04)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@565@04))
      (not
        (=
          ($FVF.lookup_option$array$ (as sm@568@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@565@04))
          (as None<option<array>>  option<array>)))
      (<
        j@566@04
        (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@568@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@565@04))))))
    :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@568@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@565@04))) j@566@04))
    :qid |int-aux|))
  (forall ((r $Ref)) (!
    (implies
      (and
        (and
          (and (< (inv@571@04 r) V@15@04) (<= 0 (inv@571@04 r)))
          (< (inv@570@04 r) V@15@04))
        (<= 0 (inv@570@04 r)))
      ($FVF.loc_int ($FVF.lookup_int (as sm@572@04  $FVF<Int>) r) r))
    :pattern ((inv@570@04 r) (inv@571@04 r))
    ))
  (forall ((r $Ref)) (!
    (implies
      (not
        (=
          (ite
            (and (< (inv@457@04 r) V@15@04) (<= 0 (inv@457@04 r)))
            $Perm.Write
            $Perm.No)
          $Perm.No))
      (ite
        (and (< (inv@457@04 r) V@15@04) (<= 0 (inv@457@04 r)))
        (<
          (ite
            (and
              (and
                (and (< (inv@571@04 r) V@15@04) (<= 0 (inv@571@04 r)))
                (< (inv@570@04 r) V@15@04))
              (<= 0 (inv@570@04 r)))
            $k@567@04
            $Perm.No)
          $Perm.Write)
        (<
          (ite
            (and
              (and
                (and (< (inv@571@04 r) V@15@04) (<= 0 (inv@571@04 r)))
                (< (inv@570@04 r) V@15@04))
              (<= 0 (inv@570@04 r)))
            $k@567@04
            $Perm.No)
          $Perm.No)))
    :pattern ((inv@457@04 r))
    :pattern ((inv@571@04 r))
    :pattern ((inv@570@04 r))
    :qid |qp.srp450|))
  (forall ((r $Ref)) (!
    (implies
      (not
        (=
          (ite
            (and
              (and
                (and (< (inv@454@04 r) V@15@04) (<= 0 (inv@454@04 r)))
                (< (inv@453@04 r) V@15@04))
              (<= 0 (inv@453@04 r)))
            $Perm.Write
            $Perm.No)
          $Perm.No))
      (ite
        (and
          (and
            (and (< (inv@454@04 r) V@15@04) (<= 0 (inv@454@04 r)))
            (< (inv@453@04 r) V@15@04))
          (<= 0 (inv@453@04 r)))
        (<
          (ite
            (and
              (and
                (and (< (inv@571@04 r) V@15@04) (<= 0 (inv@571@04 r)))
                (< (inv@570@04 r) V@15@04))
              (<= 0 (inv@570@04 r)))
            $k@567@04
            $Perm.No)
          $Perm.Write)
        (<
          (ite
            (and
              (and
                (and (< (inv@571@04 r) V@15@04) (<= 0 (inv@571@04 r)))
                (< (inv@570@04 r) V@15@04))
              (<= 0 (inv@570@04 r)))
            $k@567@04
            $Perm.No)
          $Perm.No)))
    :pattern ((inv@454@04 r))
    :pattern ((inv@453@04 r))
    :pattern ((inv@571@04 r))
    :pattern ((inv@570@04 r))
    :qid |qp.srp451|))))
(declare-const Gf_seq@577@04 Seq<Seq<Int>>)
(assert (Seq_equal
  Gf_seq@577@04
  (matrixValues ($Snap.combine
    $Snap.unit
    ($Snap.combine
      $Snap.unit
      ($Snap.combine
        $Snap.unit
        ($Snap.combine
          ($SortWrappers.$FVF<option<array>>To$Snap (as sm@552@04  $FVF<option<array>>))
          ($Snap.combine
            $Snap.unit
            ($Snap.combine
              $Snap.unit
              ($Snap.combine
                $Snap.unit
                ($SortWrappers.$FVF<Int>To$Snap (as sm@576@04  $FVF<Int>))))))))) this@9@04 G@11@04 V@15@04)))
; [exec]
; maxFlow := maxFlow + bottleneckPathFlow
; [eval] maxFlow + bottleneckPathFlow
(declare-const maxFlow@578@04 Int)
(assert (= maxFlow@578@04 (+ maxFlow@290@04 bottleneckPathFlow@352@04)))
; [exec]
; exc, res1 := hasAugmentingPath(this, tid, G, V, s, t, P)
; [eval] this != null
; [eval] Gf != (None(): option[array])
; [eval] (None(): option[array])
; [eval] alen(opt_get1(Gf)) == V
; [eval] alen(opt_get1(Gf))
; [eval] opt_get1(Gf)
(push) ; 16
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 16
; Joined path conditions
(declare-const i1@579@04 Int)
(push) ; 16
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 17
; [then-branch: 299 | 0 <= i1@579@04 | live]
; [else-branch: 299 | !(0 <= i1@579@04) | live]
(push) ; 18
; [then-branch: 299 | 0 <= i1@579@04]
(assert (<= 0 i1@579@04))
; [eval] i1 < V
(pop) ; 18
(push) ; 18
; [else-branch: 299 | !(0 <= i1@579@04)]
(assert (not (<= 0 i1@579@04)))
(pop) ; 18
(pop) ; 17
; Joined path conditions
; Joined path conditions
(assert (and (< i1@579@04 V@15@04) (<= 0 i1@579@04)))
(declare-const $k@580@04 $Perm)
(assert ($Perm.isReadVar $k@580@04 $Perm.Write))
; [eval] aloc(opt_get1(Gf), i1)
; [eval] opt_get1(Gf)
(push) ; 17
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 17
; Joined path conditions
(push) ; 17
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 18
(assert (not (< i1@579@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))))
(check-sat)
; unsat
(pop) ; 18
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               24187004
;  :arith-add-rows          5094435
;  :arith-assert-diseq      165222
;  :arith-assert-lower      4374189
;  :arith-assert-upper      3763066
;  :arith-bound-prop        115004
;  :arith-conflicts         3032
;  :arith-eq-adapter        1675778
;  :arith-fixed-eqs         3926077
;  :arith-offset-eqs        2302522
;  :arith-pivots            712870
;  :conflicts               7145
;  :datatype-accessor-ax    515
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1020470
;  :del-clause              63187989
;  :final-checks            5
;  :max-generation          14
;  :max-memory              517.91
;  :memory                  493.38
;  :minimized-lits          1063
;  :mk-bool-var             54365525
;  :mk-clause               63190283
;  :num-allocs              128676500
;  :num-checks              634
;  :propagations            18712808
;  :quant-instantiations    22789756
;  :restarts                15
;  :rlimit-count            508661594)
(assert (< i1@579@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(pop) ; 17
; Joined path conditions
(assert (< i1@579@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(pop) ; 16
(declare-fun inv@581@04 ($Ref) Int)
; Nested auxiliary terms: globals
(assert ($Perm.isReadVar $k@580@04 $Perm.Write))
; Nested auxiliary terms: non-globals
(assert (forall ((i1@579@04 Int)) (!
  (< i1@579@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@579@04))
  :qid |option$array$-aux|)))
(push) ; 16
(assert (not (forall ((i1@579@04 Int)) (!
  (implies
    (and (< i1@579@04 V@15@04) (<= 0 i1@579@04))
    (or (= $k@580@04 $Perm.No) (< $Perm.No $k@580@04)))
  
  ))))
(check-sat)
; unsat
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               24187004
;  :arith-add-rows          5094436
;  :arith-assert-diseq      165223
;  :arith-assert-lower      4374191
;  :arith-assert-upper      3763067
;  :arith-bound-prop        115004
;  :arith-conflicts         3032
;  :arith-eq-adapter        1675779
;  :arith-fixed-eqs         3926077
;  :arith-offset-eqs        2302522
;  :arith-pivots            712871
;  :conflicts               7146
;  :datatype-accessor-ax    515
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1020470
;  :del-clause              63187991
;  :final-checks            5
;  :max-generation          14
;  :max-memory              517.91
;  :memory                  493.38
;  :minimized-lits          1063
;  :mk-bool-var             54365532
;  :mk-clause               63190285
;  :num-allocs              128676934
;  :num-checks              635
;  :propagations            18712809
;  :quant-instantiations    22789756
;  :restarts                15
;  :rlimit-count            508662145)
(declare-const sm@582@04 $FVF<option<array>>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (-
          (ite
            (and (< (inv@296@04 r) V@15@04) (<= 0 (inv@296@04 r)))
            $k@295@04
            $Perm.No)
          (pTaken@380@04 r))
        (pTaken@469@04 r)))
    (=
      ($FVF.lookup_option$array$ (as sm@582@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@582@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r))
  :qid |qp.fvfValDef457|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@357@04 r) V@15@04) (<= 0 (inv@357@04 r)))
      (< $Perm.No $k@356@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@582@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@582@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))) r))
  :qid |qp.fvfValDef458|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@445@04 r) V@15@04) (<= 0 (inv@445@04 r)))
      (< $Perm.No $k@444@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@582@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@582@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))) r))
  :qid |qp.fvfValDef459|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))) r) r))
  :pattern (($FVF.lookup_option$array$ (as sm@582@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef460|)))
; Check receiver injectivity
(push) ; 16
(assert (not (forall ((i11@579@04 Int) (i12@579@04 Int)) (!
  (implies
    (and
      (and
        (and
          (and (< i11@579@04 V@15@04) (<= 0 i11@579@04))
          ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@582@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i11@579@04)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i11@579@04)))
        (< $Perm.No $k@580@04))
      (and
        (and
          (and (< i12@579@04 V@15@04) (<= 0 i12@579@04))
          ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@582@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i12@579@04)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i12@579@04)))
        (< $Perm.No $k@580@04))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i11@579@04)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i12@579@04)))
    (= i11@579@04 i12@579@04))
  
  :qid |option$array$-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               24187064
;  :arith-add-rows          5094445
;  :arith-assert-diseq      165224
;  :arith-assert-lower      4374195
;  :arith-assert-upper      3763067
;  :arith-bound-prop        115004
;  :arith-conflicts         3032
;  :arith-eq-adapter        1675780
;  :arith-fixed-eqs         3926077
;  :arith-offset-eqs        2302522
;  :arith-pivots            712871
;  :conflicts               7147
;  :datatype-accessor-ax    515
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1020470
;  :del-clause              63188023
;  :final-checks            5
;  :max-generation          14
;  :max-memory              517.91
;  :memory                  493.19
;  :minimized-lits          1063
;  :mk-bool-var             54365654
;  :mk-clause               63190317
;  :num-allocs              128678836
;  :num-checks              636
;  :propagations            18712812
;  :quant-instantiations    22789862
;  :restarts                15
;  :rlimit-count            508668182
;  :time                    0.00)
; Definitional axioms for inverse functions
(assert (forall ((i1@579@04 Int)) (!
  (implies
    (and (and (< i1@579@04 V@15@04) (<= 0 i1@579@04)) (< $Perm.No $k@580@04))
    (=
      (inv@581@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@579@04))
      i1@579@04))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@579@04))
  :qid |option$array$-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and (< (inv@581@04 r) V@15@04) (<= 0 (inv@581@04 r)))
      (< $Perm.No $k@580@04))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) (inv@581@04 r))
      r))
  :pattern ((inv@581@04 r))
  :qid |option$array$-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@581@04 r) V@15@04) (<= 0 (inv@581@04 r)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@582@04  $FVF<option<array>>) r) r))
  :pattern ((inv@581@04 r))
  )))
; Precomputing data for removing quantified permissions
(define-fun pTaken@583@04 ((r $Ref)) $Perm
  (ite
    (and (< (inv@581@04 r) V@15@04) (<= 0 (inv@581@04 r)))
    ($Perm.min
      (-
        (-
          (ite
            (and (< (inv@296@04 r) V@15@04) (<= 0 (inv@296@04 r)))
            $k@295@04
            $Perm.No)
          (pTaken@380@04 r))
        (pTaken@469@04 r))
      $k@580@04)
    $Perm.No))
(define-fun pTaken@584@04 ((r $Ref)) $Perm
  (ite
    (and (< (inv@581@04 r) V@15@04) (<= 0 (inv@581@04 r)))
    ($Perm.min
      (ite
        (and (< (inv@357@04 r) V@15@04) (<= 0 (inv@357@04 r)))
        $k@356@04
        $Perm.No)
      (- $k@580@04 (pTaken@583@04 r)))
    $Perm.No))
(define-fun pTaken@585@04 ((r $Ref)) $Perm
  (ite
    (and (< (inv@581@04 r) V@15@04) (<= 0 (inv@581@04 r)))
    ($Perm.min
      (ite
        (and (< (inv@445@04 r) V@15@04) (<= 0 (inv@445@04 r)))
        $k@444@04
        $Perm.No)
      (- (- $k@580@04 (pTaken@583@04 r)) (pTaken@584@04 r)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Constrain original permissions $k@580@04
(assert (forall ((r $Ref)) (!
  (implies
    (not
      (=
        (-
          (-
            (ite
              (and (< (inv@296@04 r) V@15@04) (<= 0 (inv@296@04 r)))
              $k@295@04
              $Perm.No)
            (pTaken@380@04 r))
          (pTaken@469@04 r))
        $Perm.No))
    (<
      (ite
        (and (< (inv@581@04 r) V@15@04) (<= 0 (inv@581@04 r)))
        $k@580@04
        $Perm.No)
      (-
        (-
          (ite
            (and (< (inv@296@04 r) V@15@04) (<= 0 (inv@296@04 r)))
            $k@295@04
            $Perm.No)
          (pTaken@380@04 r))
        (pTaken@469@04 r))))
  :pattern ((inv@296@04 r))
  :pattern ((inv@581@04 r))
  :qid |qp.srp461|)))
; Intermediate check if already taken enough permissions
(set-option :timeout 500)
(push) ; 16
(assert (not (forall ((r $Ref)) (!
  (implies
    (and (< (inv@581@04 r) V@15@04) (<= 0 (inv@581@04 r)))
    (= (- $k@580@04 (pTaken@583@04 r)) $Perm.No))
  
  ))))
(check-sat)
; unsat
(pop) ; 16
; 0.04s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               24188295
;  :arith-add-rows          5095946
;  :arith-assert-diseq      165265
;  :arith-assert-lower      4374435
;  :arith-assert-upper      3763233
;  :arith-bound-prop        115037
;  :arith-conflicts         3039
;  :arith-eq-adapter        1675959
;  :arith-fixed-eqs         3926251
;  :arith-offset-eqs        2302568
;  :arith-pivots            713001
;  :conflicts               7173
;  :datatype-accessor-ax    519
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1020856
;  :del-clause              63201556
;  :final-checks            5
;  :max-generation          14
;  :max-memory              517.91
;  :memory                  493.12
;  :minimized-lits          1064
;  :mk-bool-var             54375872
;  :mk-clause               63203800
;  :num-allocs              128713360
;  :num-checks              638
;  :propagations            18714530
;  :quant-instantiations    22792466
;  :restarts                15
;  :rlimit-count            508832084
;  :time                    0.04)
; Final check if taken enough permissions
; Done removing quantified permissions
; Definitional axioms for snapshot map values
; [eval] (forall i1: Int :: { aloc(opt_get1(Gf), i1) } 0 <= i1 && i1 < V ==> aloc(opt_get1(Gf), i1).option$array$ != (None(): option[array]))
(declare-const i1@586@04 Int)
(push) ; 16
; [eval] 0 <= i1 && i1 < V ==> aloc(opt_get1(Gf), i1).option$array$ != (None(): option[array])
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 17
; [then-branch: 300 | 0 <= i1@586@04 | live]
; [else-branch: 300 | !(0 <= i1@586@04) | live]
(push) ; 18
; [then-branch: 300 | 0 <= i1@586@04]
(assert (<= 0 i1@586@04))
; [eval] i1 < V
(pop) ; 18
(push) ; 18
; [else-branch: 300 | !(0 <= i1@586@04)]
(assert (not (<= 0 i1@586@04)))
(pop) ; 18
(pop) ; 17
; Joined path conditions
; Joined path conditions
(push) ; 17
; [then-branch: 301 | i1@586@04 < V@15@04 && 0 <= i1@586@04 | live]
; [else-branch: 301 | !(i1@586@04 < V@15@04 && 0 <= i1@586@04) | live]
(push) ; 18
; [then-branch: 301 | i1@586@04 < V@15@04 && 0 <= i1@586@04]
(assert (and (< i1@586@04 V@15@04) (<= 0 i1@586@04)))
; [eval] aloc(opt_get1(Gf), i1).option$array$ != (None(): option[array])
; [eval] aloc(opt_get1(Gf), i1)
; [eval] opt_get1(Gf)
(push) ; 19
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 19
; Joined path conditions
(push) ; 19
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 20
(assert (not (< i1@586@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))))
(check-sat)
; unsat
(pop) ; 20
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               24188295
;  :arith-add-rows          5095947
;  :arith-assert-diseq      165265
;  :arith-assert-lower      4374437
;  :arith-assert-upper      3763233
;  :arith-bound-prop        115037
;  :arith-conflicts         3039
;  :arith-eq-adapter        1675959
;  :arith-fixed-eqs         3926251
;  :arith-offset-eqs        2302568
;  :arith-pivots            713002
;  :conflicts               7173
;  :datatype-accessor-ax    519
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1020856
;  :del-clause              63201556
;  :final-checks            5
;  :max-generation          14
;  :max-memory              517.91
;  :memory                  493.12
;  :minimized-lits          1064
;  :mk-bool-var             54375874
;  :mk-clause               63203800
;  :num-allocs              128713470
;  :num-checks              639
;  :propagations            18714530
;  :quant-instantiations    22792466
;  :restarts                15
;  :rlimit-count            508832280)
(assert (< i1@586@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(pop) ; 19
; Joined path conditions
(assert (< i1@586@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@582@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@586@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@586@04)))
(push) ; 19
(assert (not (<
  $Perm.No
  (+
    (+
      (-
        (-
          (ite
            (and
              (<
                (inv@296@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@586@04))
                V@15@04)
              (<=
                0
                (inv@296@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@586@04))))
            $k@295@04
            $Perm.No)
          (pTaken@380@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@586@04)))
        (pTaken@469@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@586@04)))
      (ite
        (and
          (<
            (inv@357@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@586@04))
            V@15@04)
          (<=
            0
            (inv@357@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@586@04))))
        $k@356@04
        $Perm.No))
    (ite
      (and
        (<
          (inv@445@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@586@04))
          V@15@04)
        (<=
          0
          (inv@445@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@586@04))))
      $k@444@04
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 19
; 0.04s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               24189348
;  :arith-add-rows          5097258
;  :arith-assert-diseq      165281
;  :arith-assert-lower      4374580
;  :arith-assert-upper      3763336
;  :arith-bound-prop        115095
;  :arith-conflicts         3042
;  :arith-eq-adapter        1676061
;  :arith-fixed-eqs         3926360
;  :arith-offset-eqs        2302628
;  :arith-pivots            713077
;  :conflicts               7192
;  :datatype-accessor-ax    523
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1021195
;  :del-clause              63212353
;  :final-checks            5
;  :max-generation          14
;  :max-memory              517.91
;  :memory                  493.17
;  :minimized-lits          1064
;  :mk-bool-var             54384366
;  :mk-clause               63215148
;  :num-allocs              128740482
;  :num-checks              640
;  :propagations            18715962
;  :quant-instantiations    22794414
;  :restarts                15
;  :rlimit-count            508951637
;  :time                    0.04)
; [eval] (None(): option[array])
(pop) ; 18
(push) ; 18
; [else-branch: 301 | !(i1@586@04 < V@15@04 && 0 <= i1@586@04)]
(assert (not (and (< i1@586@04 V@15@04) (<= 0 i1@586@04))))
(pop) ; 18
(pop) ; 17
; Joined path conditions
(assert (implies
  (and (< i1@586@04 V@15@04) (<= 0 i1@586@04))
  (and
    (< i1@586@04 V@15@04)
    (<= 0 i1@586@04)
    (< i1@586@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@582@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@586@04)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@586@04)))))
; Joined path conditions
(pop) ; 16
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@586@04 Int)) (!
  (implies
    (and (< i1@586@04 V@15@04) (<= 0 i1@586@04))
    (and
      (< i1@586@04 V@15@04)
      (<= 0 i1@586@04)
      (< i1@586@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@582@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@586@04)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@586@04))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@586@04))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(push) ; 16
(assert (not (forall ((i1@586@04 Int)) (!
  (implies
    (and (< i1@586@04 V@15@04) (<= 0 i1@586@04))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@582@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@586@04))
        (as None<option<array>>  option<array>))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@586@04))
  :qid |prog.l<no position>|))))
(check-sat)
; unsat
(pop) ; 16
; 0.04s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               24190252
;  :arith-add-rows          5098459
;  :arith-assert-diseq      165293
;  :arith-assert-lower      4374697
;  :arith-assert-upper      3763425
;  :arith-bound-prop        115139
;  :arith-conflicts         3043
;  :arith-eq-adapter        1676147
;  :arith-fixed-eqs         3926457
;  :arith-offset-eqs        2302688
;  :arith-pivots            713177
;  :conflicts               7210
;  :datatype-accessor-ax    527
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1021531
;  :del-clause              63224194
;  :final-checks            5
;  :max-generation          14
;  :max-memory              517.91
;  :memory                  493.12
;  :minimized-lits          1064
;  :mk-bool-var             54392421
;  :mk-clause               63226438
;  :num-allocs              128765849
;  :num-checks              641
;  :propagations            18717309
;  :quant-instantiations    22796343
;  :restarts                15
;  :rlimit-count            509071473
;  :time                    0.04)
(assert (forall ((i1@586@04 Int)) (!
  (implies
    (and (< i1@586@04 V@15@04) (<= 0 i1@586@04))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@582@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@586@04))
        (as None<option<array>>  option<array>))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@586@04))
  :qid |prog.l<no position>|)))
; [eval] (forall i1: Int :: { alen(opt_get1(aloc(opt_get1(Gf), i1).option$array$)) } 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(Gf), i1).option$array$)) == V)
(declare-const i1@587@04 Int)
(push) ; 16
; [eval] 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(Gf), i1).option$array$)) == V
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 17
; [then-branch: 302 | 0 <= i1@587@04 | live]
; [else-branch: 302 | !(0 <= i1@587@04) | live]
(push) ; 18
; [then-branch: 302 | 0 <= i1@587@04]
(assert (<= 0 i1@587@04))
; [eval] i1 < V
(pop) ; 18
(push) ; 18
; [else-branch: 302 | !(0 <= i1@587@04)]
(assert (not (<= 0 i1@587@04)))
(pop) ; 18
(pop) ; 17
; Joined path conditions
; Joined path conditions
(push) ; 17
; [then-branch: 303 | i1@587@04 < V@15@04 && 0 <= i1@587@04 | live]
; [else-branch: 303 | !(i1@587@04 < V@15@04 && 0 <= i1@587@04) | live]
(push) ; 18
; [then-branch: 303 | i1@587@04 < V@15@04 && 0 <= i1@587@04]
(assert (and (< i1@587@04 V@15@04) (<= 0 i1@587@04)))
; [eval] alen(opt_get1(aloc(opt_get1(Gf), i1).option$array$)) == V
; [eval] alen(opt_get1(aloc(opt_get1(Gf), i1).option$array$))
; [eval] opt_get1(aloc(opt_get1(Gf), i1).option$array$)
; [eval] aloc(opt_get1(Gf), i1)
; [eval] opt_get1(Gf)
(push) ; 19
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 19
; Joined path conditions
(push) ; 19
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 20
(assert (not (< i1@587@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))))
(check-sat)
; unsat
(pop) ; 20
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               24190252
;  :arith-add-rows          5098460
;  :arith-assert-diseq      165293
;  :arith-assert-lower      4374699
;  :arith-assert-upper      3763425
;  :arith-bound-prop        115139
;  :arith-conflicts         3043
;  :arith-eq-adapter        1676147
;  :arith-fixed-eqs         3926457
;  :arith-offset-eqs        2302688
;  :arith-pivots            713177
;  :conflicts               7210
;  :datatype-accessor-ax    527
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1021531
;  :del-clause              63224194
;  :final-checks            5
;  :max-generation          14
;  :max-memory              517.91
;  :memory                  493.12
;  :minimized-lits          1064
;  :mk-bool-var             54392424
;  :mk-clause               63226438
;  :num-allocs              128766148
;  :num-checks              642
;  :propagations            18717309
;  :quant-instantiations    22796343
;  :restarts                15
;  :rlimit-count            509071973)
(assert (< i1@587@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(pop) ; 19
; Joined path conditions
(assert (< i1@587@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@582@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@587@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@587@04)))
(push) ; 19
(assert (not (<
  $Perm.No
  (+
    (+
      (-
        (-
          (ite
            (and
              (<
                (inv@296@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@587@04))
                V@15@04)
              (<=
                0
                (inv@296@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@587@04))))
            $k@295@04
            $Perm.No)
          (pTaken@380@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@587@04)))
        (pTaken@469@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@587@04)))
      (ite
        (and
          (<
            (inv@357@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@587@04))
            V@15@04)
          (<=
            0
            (inv@357@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@587@04))))
        $k@356@04
        $Perm.No))
    (ite
      (and
        (<
          (inv@445@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@587@04))
          V@15@04)
        (<=
          0
          (inv@445@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@587@04))))
      $k@444@04
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 19
; 0.05s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               24191310
;  :arith-add-rows          5099877
;  :arith-assert-diseq      165309
;  :arith-assert-lower      4374845
;  :arith-assert-upper      3763527
;  :arith-bound-prop        115197
;  :arith-conflicts         3046
;  :arith-eq-adapter        1676249
;  :arith-fixed-eqs         3926566
;  :arith-offset-eqs        2302762
;  :arith-pivots            713253
;  :conflicts               7229
;  :datatype-accessor-ax    531
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1021868
;  :del-clause              63234999
;  :final-checks            5
;  :max-generation          14
;  :max-memory              517.91
;  :memory                  493.18
;  :minimized-lits          1064
;  :mk-bool-var             54400932
;  :mk-clause               63237794
;  :num-allocs              128793283
;  :num-checks              643
;  :propagations            18718743
;  :quant-instantiations    22798295
;  :restarts                15
;  :rlimit-count            509191606
;  :time                    0.05)
(push) ; 19
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 20
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@582@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@587@04))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 20
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               24191310
;  :arith-add-rows          5099877
;  :arith-assert-diseq      165309
;  :arith-assert-lower      4374845
;  :arith-assert-upper      3763527
;  :arith-bound-prop        115197
;  :arith-conflicts         3046
;  :arith-eq-adapter        1676249
;  :arith-fixed-eqs         3926566
;  :arith-offset-eqs        2302762
;  :arith-pivots            713253
;  :conflicts               7230
;  :datatype-accessor-ax    531
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1021868
;  :del-clause              63234999
;  :final-checks            5
;  :max-generation          14
;  :max-memory              517.91
;  :memory                  493.18
;  :minimized-lits          1064
;  :mk-bool-var             54400932
;  :mk-clause               63237794
;  :num-allocs              128793374
;  :num-checks              644
;  :propagations            18718743
;  :quant-instantiations    22798295
;  :restarts                15
;  :rlimit-count            509191701)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@582@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@587@04))
    (as None<option<array>>  option<array>))))
(pop) ; 19
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@582@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@587@04))
    (as None<option<array>>  option<array>))))
(pop) ; 18
(push) ; 18
; [else-branch: 303 | !(i1@587@04 < V@15@04 && 0 <= i1@587@04)]
(assert (not (and (< i1@587@04 V@15@04) (<= 0 i1@587@04))))
(pop) ; 18
(pop) ; 17
; Joined path conditions
(assert (implies
  (and (< i1@587@04 V@15@04) (<= 0 i1@587@04))
  (and
    (< i1@587@04 V@15@04)
    (<= 0 i1@587@04)
    (< i1@587@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@582@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@587@04)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@587@04))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@582@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@587@04))
        (as None<option<array>>  option<array>))))))
; Joined path conditions
(pop) ; 16
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@587@04 Int)) (!
  (implies
    (and (< i1@587@04 V@15@04) (<= 0 i1@587@04))
    (and
      (< i1@587@04 V@15@04)
      (<= 0 i1@587@04)
      (< i1@587@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@582@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@587@04)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@587@04))
      (not
        (=
          ($FVF.lookup_option$array$ (as sm@582@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@587@04))
          (as None<option<array>>  option<array>)))))
  :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@582@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@587@04)))))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(push) ; 16
(assert (not (forall ((i1@587@04 Int)) (!
  (implies
    (and (< i1@587@04 V@15@04) (<= 0 i1@587@04))
    (=
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@582@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@587@04))))
      V@15@04))
  :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@582@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@587@04)))))
  :qid |prog.l<no position>|))))
(check-sat)
; unsat
(pop) ; 16
; 0.04s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               24192259
;  :arith-add-rows          5101104
;  :arith-assert-diseq      165323
;  :arith-assert-lower      4374964
;  :arith-assert-upper      3763617
;  :arith-bound-prop        115222
;  :arith-conflicts         3048
;  :arith-eq-adapter        1676336
;  :arith-fixed-eqs         3926663
;  :arith-offset-eqs        2302822
;  :arith-pivots            713356
;  :conflicts               7249
;  :datatype-accessor-ax    535
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1022209
;  :del-clause              63246827
;  :final-checks            5
;  :max-generation          14
;  :max-memory              517.91
;  :memory                  493.13
;  :minimized-lits          1064
;  :mk-bool-var             54408993
;  :mk-clause               63249071
;  :num-allocs              128818669
;  :num-checks              645
;  :propagations            18720109
;  :quant-instantiations    22800230
;  :restarts                15
;  :rlimit-count            509312424
;  :time                    0.04)
(assert (forall ((i1@587@04 Int)) (!
  (implies
    (and (< i1@587@04 V@15@04) (<= 0 i1@587@04))
    (=
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@582@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@587@04))))
      V@15@04))
  :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@582@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@587@04)))))
  :qid |prog.l<no position>|)))
; [eval] (forall i1: Int :: { aloc(opt_get1(Gf), i1) } (forall i2: Int :: { aloc(opt_get1(Gf), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(Gf), i1).option$array$ == aloc(opt_get1(Gf), i2).option$array$ ==> i1 == i2))
(declare-const i1@588@04 Int)
(push) ; 16
; [eval] (forall i2: Int :: { aloc(opt_get1(Gf), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(Gf), i1).option$array$ == aloc(opt_get1(Gf), i2).option$array$ ==> i1 == i2)
(declare-const i2@589@04 Int)
(push) ; 17
; [eval] 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(Gf), i1).option$array$ == aloc(opt_get1(Gf), i2).option$array$ ==> i1 == i2
; [eval] 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(Gf), i1).option$array$ == aloc(opt_get1(Gf), i2).option$array$
; [eval] 0 <= i1
(push) ; 18
; [then-branch: 304 | 0 <= i1@588@04 | live]
; [else-branch: 304 | !(0 <= i1@588@04) | live]
(push) ; 19
; [then-branch: 304 | 0 <= i1@588@04]
(assert (<= 0 i1@588@04))
; [eval] i1 < V
(push) ; 20
; [then-branch: 305 | i1@588@04 < V@15@04 | live]
; [else-branch: 305 | !(i1@588@04 < V@15@04) | live]
(push) ; 21
; [then-branch: 305 | i1@588@04 < V@15@04]
(assert (< i1@588@04 V@15@04))
; [eval] 0 <= i2
(push) ; 22
; [then-branch: 306 | 0 <= i2@589@04 | live]
; [else-branch: 306 | !(0 <= i2@589@04) | live]
(push) ; 23
; [then-branch: 306 | 0 <= i2@589@04]
(assert (<= 0 i2@589@04))
; [eval] i2 < V
(push) ; 24
; [then-branch: 307 | i2@589@04 < V@15@04 | live]
; [else-branch: 307 | !(i2@589@04 < V@15@04) | live]
(push) ; 25
; [then-branch: 307 | i2@589@04 < V@15@04]
(assert (< i2@589@04 V@15@04))
; [eval] aloc(opt_get1(Gf), i1).option$array$ == aloc(opt_get1(Gf), i2).option$array$
; [eval] aloc(opt_get1(Gf), i1)
; [eval] opt_get1(Gf)
(push) ; 26
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 26
; Joined path conditions
(push) ; 26
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 27
(assert (not (< i1@588@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))))
(check-sat)
; unsat
(pop) ; 27
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               24192259
;  :arith-add-rows          5101106
;  :arith-assert-diseq      165323
;  :arith-assert-lower      4374968
;  :arith-assert-upper      3763617
;  :arith-bound-prop        115222
;  :arith-conflicts         3048
;  :arith-eq-adapter        1676336
;  :arith-fixed-eqs         3926663
;  :arith-offset-eqs        2302822
;  :arith-pivots            713357
;  :conflicts               7249
;  :datatype-accessor-ax    535
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1022209
;  :del-clause              63246827
;  :final-checks            5
;  :max-generation          14
;  :max-memory              517.91
;  :memory                  493.13
;  :minimized-lits          1064
;  :mk-bool-var             54408998
;  :mk-clause               63249071
;  :num-allocs              128819150
;  :num-checks              646
;  :propagations            18720109
;  :quant-instantiations    22800230
;  :restarts                15
;  :rlimit-count            509313075)
(assert (< i1@588@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(pop) ; 26
; Joined path conditions
(assert (< i1@588@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@582@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@588@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@588@04)))
(push) ; 26
(assert (not (<
  $Perm.No
  (+
    (+
      (-
        (-
          (ite
            (and
              (<
                (inv@296@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@588@04))
                V@15@04)
              (<=
                0
                (inv@296@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@588@04))))
            $k@295@04
            $Perm.No)
          (pTaken@380@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@588@04)))
        (pTaken@469@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@588@04)))
      (ite
        (and
          (<
            (inv@357@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@588@04))
            V@15@04)
          (<=
            0
            (inv@357@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@588@04))))
        $k@356@04
        $Perm.No))
    (ite
      (and
        (<
          (inv@445@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@588@04))
          V@15@04)
        (<=
          0
          (inv@445@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@588@04))))
      $k@444@04
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 26
; 0.04s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               24193316
;  :arith-add-rows          5102532
;  :arith-assert-diseq      165339
;  :arith-assert-lower      4375114
;  :arith-assert-upper      3763719
;  :arith-bound-prop        115280
;  :arith-conflicts         3051
;  :arith-eq-adapter        1676437
;  :arith-fixed-eqs         3926772
;  :arith-offset-eqs        2302897
;  :arith-pivots            713430
;  :conflicts               7268
;  :datatype-accessor-ax    539
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1022546
;  :del-clause              63257628
;  :final-checks            5
;  :max-generation          14
;  :max-memory              517.91
;  :memory                  493.18
;  :minimized-lits          1064
;  :mk-bool-var             54417503
;  :mk-clause               63260423
;  :num-allocs              128846230
;  :num-checks              647
;  :propagations            18721543
;  :quant-instantiations    22802183
;  :restarts                15
;  :rlimit-count            509432561
;  :time                    0.04)
; [eval] aloc(opt_get1(Gf), i2)
; [eval] opt_get1(Gf)
(push) ; 26
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 26
; Joined path conditions
(push) ; 26
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 27
(assert (not (< i2@589@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))))
(check-sat)
; unsat
(pop) ; 27
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               24193316
;  :arith-add-rows          5102532
;  :arith-assert-diseq      165339
;  :arith-assert-lower      4375114
;  :arith-assert-upper      3763719
;  :arith-bound-prop        115280
;  :arith-conflicts         3051
;  :arith-eq-adapter        1676437
;  :arith-fixed-eqs         3926772
;  :arith-offset-eqs        2302897
;  :arith-pivots            713430
;  :conflicts               7268
;  :datatype-accessor-ax    539
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1022546
;  :del-clause              63257628
;  :final-checks            5
;  :max-generation          14
;  :max-memory              517.91
;  :memory                  493.18
;  :minimized-lits          1064
;  :mk-bool-var             54417503
;  :mk-clause               63260423
;  :num-allocs              128846256
;  :num-checks              648
;  :propagations            18721543
;  :quant-instantiations    22802183
;  :restarts                15
;  :rlimit-count            509432591)
(assert (< i2@589@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(pop) ; 26
; Joined path conditions
(assert (< i2@589@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@582@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@589@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@589@04)))
(push) ; 26
(assert (not (<
  $Perm.No
  (+
    (+
      (-
        (-
          (ite
            (and
              (<
                (inv@296@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@589@04))
                V@15@04)
              (<=
                0
                (inv@296@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@589@04))))
            $k@295@04
            $Perm.No)
          (pTaken@380@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@589@04)))
        (pTaken@469@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@589@04)))
      (ite
        (and
          (<
            (inv@357@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@589@04))
            V@15@04)
          (<=
            0
            (inv@357@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@589@04))))
        $k@356@04
        $Perm.No))
    (ite
      (and
        (<
          (inv@445@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@589@04))
          V@15@04)
        (<=
          0
          (inv@445@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@589@04))))
      $k@444@04
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 26
; 0.05s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               24194786
;  :arith-add-rows          5104081
;  :arith-assert-diseq      165385
;  :arith-assert-lower      4375403
;  :arith-assert-upper      3763881
;  :arith-bound-prop        115389
;  :arith-conflicts         3059
;  :arith-eq-adapter        1676606
;  :arith-fixed-eqs         3926916
;  :arith-offset-eqs        2303016
;  :arith-pivots            713562
;  :conflicts               7293
;  :datatype-accessor-ax    543
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1022967
;  :del-clause              63270133
;  :final-checks            5
;  :max-generation          14
;  :max-memory              517.91
;  :memory                  493.23
;  :minimized-lits          1064
;  :mk-bool-var             54426926
;  :mk-clause               63273329
;  :num-allocs              128876404
;  :num-checks              649
;  :propagations            18723481
;  :quant-instantiations    22804372
;  :restarts                15
;  :rlimit-count            509576067
;  :time                    0.05)
(pop) ; 25
(push) ; 25
; [else-branch: 307 | !(i2@589@04 < V@15@04)]
(assert (not (< i2@589@04 V@15@04)))
(pop) ; 25
(pop) ; 24
; Joined path conditions
(assert (implies
  (< i2@589@04 V@15@04)
  (and
    (< i2@589@04 V@15@04)
    (< i1@588@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@582@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@588@04)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@588@04))
    (< i2@589@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@582@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@589@04)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@589@04)))))
; Joined path conditions
(pop) ; 23
(push) ; 23
; [else-branch: 306 | !(0 <= i2@589@04)]
(assert (not (<= 0 i2@589@04)))
(pop) ; 23
(pop) ; 22
; Joined path conditions
(assert (implies
  (<= 0 i2@589@04)
  (and
    (<= 0 i2@589@04)
    (implies
      (< i2@589@04 V@15@04)
      (and
        (< i2@589@04 V@15@04)
        (< i1@588@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@582@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@588@04)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@588@04))
        (< i2@589@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@582@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@589@04)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@589@04)))))))
; Joined path conditions
(pop) ; 21
(push) ; 21
; [else-branch: 305 | !(i1@588@04 < V@15@04)]
(assert (not (< i1@588@04 V@15@04)))
(pop) ; 21
(pop) ; 20
; Joined path conditions
(assert (implies
  (< i1@588@04 V@15@04)
  (and
    (< i1@588@04 V@15@04)
    (implies
      (<= 0 i2@589@04)
      (and
        (<= 0 i2@589@04)
        (implies
          (< i2@589@04 V@15@04)
          (and
            (< i2@589@04 V@15@04)
            (< i1@588@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@582@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@588@04)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@588@04))
            (< i2@589@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@582@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@589@04)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@589@04)))))))))
; Joined path conditions
(pop) ; 19
(push) ; 19
; [else-branch: 304 | !(0 <= i1@588@04)]
(assert (not (<= 0 i1@588@04)))
(pop) ; 19
(pop) ; 18
; Joined path conditions
(assert (implies
  (<= 0 i1@588@04)
  (and
    (<= 0 i1@588@04)
    (implies
      (< i1@588@04 V@15@04)
      (and
        (< i1@588@04 V@15@04)
        (implies
          (<= 0 i2@589@04)
          (and
            (<= 0 i2@589@04)
            (implies
              (< i2@589@04 V@15@04)
              (and
                (< i2@589@04 V@15@04)
                (< i1@588@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@582@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@588@04)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@588@04))
                (< i2@589@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@582@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@589@04)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@589@04)))))))))))
; Joined path conditions
(push) ; 18
; [then-branch: 308 | Lookup(option$array$,sm@582@04,aloc((_, _), opt_get1(_, G@11@04), i1@588@04)) == Lookup(option$array$,sm@582@04,aloc((_, _), opt_get1(_, G@11@04), i2@589@04)) && i2@589@04 < V@15@04 && 0 <= i2@589@04 && i1@588@04 < V@15@04 && 0 <= i1@588@04 | live]
; [else-branch: 308 | !(Lookup(option$array$,sm@582@04,aloc((_, _), opt_get1(_, G@11@04), i1@588@04)) == Lookup(option$array$,sm@582@04,aloc((_, _), opt_get1(_, G@11@04), i2@589@04)) && i2@589@04 < V@15@04 && 0 <= i2@589@04 && i1@588@04 < V@15@04 && 0 <= i1@588@04) | live]
(push) ; 19
; [then-branch: 308 | Lookup(option$array$,sm@582@04,aloc((_, _), opt_get1(_, G@11@04), i1@588@04)) == Lookup(option$array$,sm@582@04,aloc((_, _), opt_get1(_, G@11@04), i2@589@04)) && i2@589@04 < V@15@04 && 0 <= i2@589@04 && i1@588@04 < V@15@04 && 0 <= i1@588@04]
(assert (and
  (and
    (and
      (and
        (=
          ($FVF.lookup_option$array$ (as sm@582@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@588@04))
          ($FVF.lookup_option$array$ (as sm@582@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@589@04)))
        (< i2@589@04 V@15@04))
      (<= 0 i2@589@04))
    (< i1@588@04 V@15@04))
  (<= 0 i1@588@04)))
; [eval] i1 == i2
(pop) ; 19
(push) ; 19
; [else-branch: 308 | !(Lookup(option$array$,sm@582@04,aloc((_, _), opt_get1(_, G@11@04), i1@588@04)) == Lookup(option$array$,sm@582@04,aloc((_, _), opt_get1(_, G@11@04), i2@589@04)) && i2@589@04 < V@15@04 && 0 <= i2@589@04 && i1@588@04 < V@15@04 && 0 <= i1@588@04)]
(assert (not
  (and
    (and
      (and
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@582@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@588@04))
            ($FVF.lookup_option$array$ (as sm@582@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@589@04)))
          (< i2@589@04 V@15@04))
        (<= 0 i2@589@04))
      (< i1@588@04 V@15@04))
    (<= 0 i1@588@04))))
(pop) ; 19
(pop) ; 18
; Joined path conditions
(assert (implies
  (and
    (and
      (and
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@582@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@588@04))
            ($FVF.lookup_option$array$ (as sm@582@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@589@04)))
          (< i2@589@04 V@15@04))
        (<= 0 i2@589@04))
      (< i1@588@04 V@15@04))
    (<= 0 i1@588@04))
  (and
    (=
      ($FVF.lookup_option$array$ (as sm@582@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@588@04))
      ($FVF.lookup_option$array$ (as sm@582@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@589@04)))
    (< i2@589@04 V@15@04)
    (<= 0 i2@589@04)
    (< i1@588@04 V@15@04)
    (<= 0 i1@588@04))))
; Joined path conditions
(pop) ; 17
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i2@589@04 Int)) (!
  (and
    (implies
      (<= 0 i1@588@04)
      (and
        (<= 0 i1@588@04)
        (implies
          (< i1@588@04 V@15@04)
          (and
            (< i1@588@04 V@15@04)
            (implies
              (<= 0 i2@589@04)
              (and
                (<= 0 i2@589@04)
                (implies
                  (< i2@589@04 V@15@04)
                  (and
                    (< i2@589@04 V@15@04)
                    (< i1@588@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
                    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@582@04  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@588@04)) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@588@04))
                    (< i2@589@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
                    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@582@04  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@589@04)) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@589@04))))))))))
    (implies
      (and
        (and
          (and
            (and
              (=
                ($FVF.lookup_option$array$ (as sm@582@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@588@04))
                ($FVF.lookup_option$array$ (as sm@582@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@589@04)))
              (< i2@589@04 V@15@04))
            (<= 0 i2@589@04))
          (< i1@588@04 V@15@04))
        (<= 0 i1@588@04))
      (and
        (=
          ($FVF.lookup_option$array$ (as sm@582@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@588@04))
          ($FVF.lookup_option$array$ (as sm@582@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@589@04)))
        (< i2@589@04 V@15@04)
        (<= 0 i2@589@04)
        (< i1@588@04 V@15@04)
        (<= 0 i1@588@04))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@589@04))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 16
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@588@04 Int)) (!
  (forall ((i2@589@04 Int)) (!
    (and
      (implies
        (<= 0 i1@588@04)
        (and
          (<= 0 i1@588@04)
          (implies
            (< i1@588@04 V@15@04)
            (and
              (< i1@588@04 V@15@04)
              (implies
                (<= 0 i2@589@04)
                (and
                  (<= 0 i2@589@04)
                  (implies
                    (< i2@589@04 V@15@04)
                    (and
                      (< i2@589@04 V@15@04)
                      (< i1@588@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
                      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@582@04  $FVF<option<array>>) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@588@04)) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@588@04))
                      (< i2@589@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
                      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@582@04  $FVF<option<array>>) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@589@04)) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@589@04))))))))))
      (implies
        (and
          (and
            (and
              (and
                (=
                  ($FVF.lookup_option$array$ (as sm@582@04  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@588@04))
                  ($FVF.lookup_option$array$ (as sm@582@04  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@589@04)))
                (< i2@589@04 V@15@04))
              (<= 0 i2@589@04))
            (< i1@588@04 V@15@04))
          (<= 0 i1@588@04))
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@582@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@588@04))
            ($FVF.lookup_option$array$ (as sm@582@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@589@04)))
          (< i2@589@04 V@15@04)
          (<= 0 i2@589@04)
          (< i1@588@04 V@15@04)
          (<= 0 i1@588@04))))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@589@04))
    :qid |prog.l<no position>-aux|))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@588@04))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(push) ; 16
(assert (not (forall ((i1@588@04 Int)) (!
  (forall ((i2@589@04 Int)) (!
    (implies
      (and
        (and
          (and
            (and
              (=
                ($FVF.lookup_option$array$ (as sm@582@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@588@04))
                ($FVF.lookup_option$array$ (as sm@582@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@589@04)))
              (< i2@589@04 V@15@04))
            (<= 0 i2@589@04))
          (< i1@588@04 V@15@04))
        (<= 0 i1@588@04))
      (= i1@588@04 i2@589@04))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@589@04))
    :qid |prog.l<no position>|))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@588@04))
  :qid |prog.l<no position>|))))
(check-sat)
; unsat
(pop) ; 16
; 0.05s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               24196039
;  :arith-add-rows          5105749
;  :arith-assert-diseq      165399
;  :arith-assert-lower      4375561
;  :arith-assert-upper      3764002
;  :arith-bound-prop        115481
;  :arith-conflicts         3060
;  :arith-eq-adapter        1676729
;  :arith-fixed-eqs         3927045
;  :arith-offset-eqs        2303131
;  :arith-pivots            713763
;  :conflicts               7311
;  :datatype-accessor-ax    547
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1023304
;  :del-clause              63283106
;  :final-checks            5
;  :max-generation          14
;  :max-memory              517.91
;  :memory                  493.13
;  :minimized-lits          1064
;  :mk-bool-var             54436199
;  :mk-clause               63285350
;  :num-allocs              128906733
;  :num-checks              650
;  :propagations            18725067
;  :quant-instantiations    22806692
;  :restarts                15
;  :rlimit-count            509721285
;  :time                    0.05)
(assert (forall ((i1@588@04 Int)) (!
  (forall ((i2@589@04 Int)) (!
    (implies
      (and
        (and
          (and
            (and
              (=
                ($FVF.lookup_option$array$ (as sm@582@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@588@04))
                ($FVF.lookup_option$array$ (as sm@582@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@589@04)))
              (< i2@589@04 V@15@04))
            (<= 0 i2@589@04))
          (< i1@588@04 V@15@04))
        (<= 0 i1@588@04))
      (= i1@588@04 i2@589@04))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@589@04))
    :qid |prog.l<no position>|))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@588@04))
  :qid |prog.l<no position>|)))
; [eval] p != (None(): option[array])
; [eval] (None(): option[array])
; [eval] alen(opt_get1(p)) == V
; [eval] alen(opt_get1(p))
; [eval] opt_get1(p)
(push) ; 16
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 16
; Joined path conditions
; [eval] 0 <= s
; [eval] s < V
; [eval] 0 <= t
; [eval] t < V
(declare-const i1@590@04 Int)
(declare-const j1@591@04 Int)
(push) ; 16
; [eval] 0 <= i1 && i1 < V && (0 <= j1 && j1 < V)
; [eval] 0 <= i1
(push) ; 17
; [then-branch: 309 | 0 <= i1@590@04 | live]
; [else-branch: 309 | !(0 <= i1@590@04) | live]
(push) ; 18
; [then-branch: 309 | 0 <= i1@590@04]
(assert (<= 0 i1@590@04))
; [eval] i1 < V
(push) ; 19
; [then-branch: 310 | i1@590@04 < V@15@04 | live]
; [else-branch: 310 | !(i1@590@04 < V@15@04) | live]
(push) ; 20
; [then-branch: 310 | i1@590@04 < V@15@04]
(assert (< i1@590@04 V@15@04))
; [eval] 0 <= j1
(push) ; 21
; [then-branch: 311 | 0 <= j1@591@04 | live]
; [else-branch: 311 | !(0 <= j1@591@04) | live]
(push) ; 22
; [then-branch: 311 | 0 <= j1@591@04]
(assert (<= 0 j1@591@04))
; [eval] j1 < V
(pop) ; 22
(push) ; 22
; [else-branch: 311 | !(0 <= j1@591@04)]
(assert (not (<= 0 j1@591@04)))
(pop) ; 22
(pop) ; 21
; Joined path conditions
; Joined path conditions
(pop) ; 20
(push) ; 20
; [else-branch: 310 | !(i1@590@04 < V@15@04)]
(assert (not (< i1@590@04 V@15@04)))
(pop) ; 20
(pop) ; 19
; Joined path conditions
; Joined path conditions
(pop) ; 18
(push) ; 18
; [else-branch: 309 | !(0 <= i1@590@04)]
(assert (not (<= 0 i1@590@04)))
(pop) ; 18
(pop) ; 17
; Joined path conditions
; Joined path conditions
(assert (and
  (and (and (< j1@591@04 V@15@04) (<= 0 j1@591@04)) (< i1@590@04 V@15@04))
  (<= 0 i1@590@04)))
; [eval] aloc(opt_get1(aloc(opt_get1(Gf), i1).option$array$), j1)
; [eval] opt_get1(aloc(opt_get1(Gf), i1).option$array$)
; [eval] aloc(opt_get1(Gf), i1)
; [eval] opt_get1(Gf)
(push) ; 17
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 17
; Joined path conditions
(push) ; 17
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 18
(assert (not (< i1@590@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))))
(check-sat)
; unsat
(pop) ; 18
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               24196039
;  :arith-add-rows          5105752
;  :arith-assert-diseq      165399
;  :arith-assert-lower      4375567
;  :arith-assert-upper      3764002
;  :arith-bound-prop        115481
;  :arith-conflicts         3060
;  :arith-eq-adapter        1676729
;  :arith-fixed-eqs         3927045
;  :arith-offset-eqs        2303131
;  :arith-pivots            713763
;  :conflicts               7311
;  :datatype-accessor-ax    547
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1023304
;  :del-clause              63283106
;  :final-checks            5
;  :max-generation          14
;  :max-memory              517.91
;  :memory                  493.17
;  :minimized-lits          1064
;  :mk-bool-var             54436206
;  :mk-clause               63285350
;  :num-allocs              128907338
;  :num-checks              651
;  :propagations            18725067
;  :quant-instantiations    22806692
;  :restarts                15
;  :rlimit-count            509722289)
(assert (< i1@590@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(pop) ; 17
; Joined path conditions
(assert (< i1@590@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@582@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@590@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@590@04)))
(push) ; 17
(assert (not (<
  $Perm.No
  (+
    (+
      (-
        (-
          (ite
            (and
              (<
                (inv@296@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@590@04))
                V@15@04)
              (<=
                0
                (inv@296@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@590@04))))
            $k@295@04
            $Perm.No)
          (pTaken@380@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@590@04)))
        (pTaken@469@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@590@04)))
      (ite
        (and
          (<
            (inv@357@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@590@04))
            V@15@04)
          (<=
            0
            (inv@357@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@590@04))))
        $k@356@04
        $Perm.No))
    (ite
      (and
        (<
          (inv@445@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@590@04))
          V@15@04)
        (<=
          0
          (inv@445@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@590@04))))
      $k@444@04
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 17
; 0.04s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               24197096
;  :arith-add-rows          5107163
;  :arith-assert-diseq      165415
;  :arith-assert-lower      4375713
;  :arith-assert-upper      3764104
;  :arith-bound-prop        115539
;  :arith-conflicts         3063
;  :arith-eq-adapter        1676831
;  :arith-fixed-eqs         3927154
;  :arith-offset-eqs        2303205
;  :arith-pivots            713836
;  :conflicts               7330
;  :datatype-accessor-ax    551
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1023641
;  :del-clause              63293959
;  :final-checks            5
;  :max-generation          14
;  :max-memory              517.91
;  :memory                  493.22
;  :minimized-lits          1064
;  :mk-bool-var             54444783
;  :mk-clause               63296754
;  :num-allocs              128934756
;  :num-checks              652
;  :propagations            18726519
;  :quant-instantiations    22808666
;  :restarts                15
;  :rlimit-count            509843410
;  :time                    0.04)
(push) ; 17
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 18
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@582@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@590@04))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 18
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               24197096
;  :arith-add-rows          5107163
;  :arith-assert-diseq      165415
;  :arith-assert-lower      4375713
;  :arith-assert-upper      3764104
;  :arith-bound-prop        115539
;  :arith-conflicts         3063
;  :arith-eq-adapter        1676831
;  :arith-fixed-eqs         3927154
;  :arith-offset-eqs        2303205
;  :arith-pivots            713836
;  :conflicts               7331
;  :datatype-accessor-ax    551
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1023641
;  :del-clause              63293959
;  :final-checks            5
;  :max-generation          14
;  :max-memory              517.91
;  :memory                  493.22
;  :minimized-lits          1064
;  :mk-bool-var             54444783
;  :mk-clause               63296754
;  :num-allocs              128934847
;  :num-checks              653
;  :propagations            18726519
;  :quant-instantiations    22808666
;  :restarts                15
;  :rlimit-count            509843505)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@582@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@590@04))
    (as None<option<array>>  option<array>))))
(pop) ; 17
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@582@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@590@04))
    (as None<option<array>>  option<array>))))
(push) ; 17
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 18
(assert (not (<
  j1@591@04
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@582@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@590@04)))))))
(check-sat)
; unsat
(pop) ; 18
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               24197102
;  :arith-add-rows          5107169
;  :arith-assert-diseq      165415
;  :arith-assert-lower      4375715
;  :arith-assert-upper      3764106
;  :arith-bound-prop        115539
;  :arith-conflicts         3064
;  :arith-eq-adapter        1676832
;  :arith-fixed-eqs         3927155
;  :arith-offset-eqs        2303205
;  :arith-pivots            713840
;  :conflicts               7332
;  :datatype-accessor-ax    551
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1023641
;  :del-clause              63293963
;  :final-checks            5
;  :max-generation          14
;  :max-memory              517.91
;  :memory                  493.22
;  :minimized-lits          1064
;  :mk-bool-var             54444794
;  :mk-clause               63296758
;  :num-allocs              128935039
;  :num-checks              654
;  :propagations            18726521
;  :quant-instantiations    22808673
;  :restarts                15
;  :rlimit-count            509844008
;  :time                    0.00)
(assert (<
  j1@591@04
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@582@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@590@04))))))
(pop) ; 17
; Joined path conditions
(assert (<
  j1@591@04
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@582@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@590@04))))))
(pop) ; 16
(declare-fun inv@592@04 ($Ref) Int)
(declare-fun inv@593@04 ($Ref) Int)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(assert (forall ((i1@590@04 Int) (j1@591@04 Int)) (!
  (and
    (< i1@590@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@582@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@590@04)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@590@04))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@582@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@590@04))
        (as None<option<array>>  option<array>)))
    (<
      j1@591@04
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@582@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@590@04))))))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@582@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@590@04))) j1@591@04))
  :qid |int-aux|)))
(declare-const sm@594@04 $FVF<Int>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@457@04 r) V@15@04) (<= 0 (inv@457@04 r)))
    (=
      ($FVF.lookup_int (as sm@594@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04)))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@594@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04)))))))))))))) r))
  :qid |qp.fvfValDef462|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@454@04 r) V@15@04) (<= 0 (inv@454@04 r)))
        (< (inv@453@04 r) V@15@04))
      (<= 0 (inv@453@04 r)))
    (=
      ($FVF.lookup_int (as sm@594@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@594@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))))))) r))
  :qid |qp.fvfValDef463|)))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (-
          (ite
            (and
              (and
                (and (< (inv@366@04 r) V@15@04) (<= 0 (inv@366@04 r)))
                (< (inv@365@04 r) V@15@04))
              (<= 0 (inv@365@04 r)))
            $Perm.Write
            $Perm.No)
          (pTaken@481@04 r))
        (pTaken@485@04 r)))
    (=
      ($FVF.lookup_int (as sm@594@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@594@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))))))) r))
  :qid |qp.fvfValDef464|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04)))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@594@04  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef465|)))
; Check receiver injectivity
(push) ; 16
(assert (not (forall ((i11@590@04 Int) (j11@591@04 Int) (i12@590@04 Int) (j12@591@04 Int)) (!
  (implies
    (and
      (and
        (and
          (and
            (and (< j11@591@04 V@15@04) (<= 0 j11@591@04))
            (< i11@590@04 V@15@04))
          (<= 0 i11@590@04))
        ($FVF.loc_int ($FVF.lookup_int (as sm@594@04  $FVF<Int>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@582@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i11@590@04))) j11@591@04)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@582@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i11@590@04))) j11@591@04)))
      (and
        (and
          (and
            (and (< j12@591@04 V@15@04) (<= 0 j12@591@04))
            (< i12@590@04 V@15@04))
          (<= 0 i12@590@04))
        ($FVF.loc_int ($FVF.lookup_int (as sm@594@04  $FVF<Int>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@582@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i12@590@04))) j12@591@04)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@582@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i12@590@04))) j12@591@04)))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@582@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i11@590@04))) j11@591@04)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@582@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i12@590@04))) j12@591@04)))
    (and (= i11@590@04 i12@590@04) (= j11@591@04 j12@591@04)))
  
  :qid |int-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 16
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               24197326
;  :arith-add-rows          5107323
;  :arith-assert-diseq      165415
;  :arith-assert-lower      4375745
;  :arith-assert-upper      3764118
;  :arith-bound-prop        115550
;  :arith-conflicts         3064
;  :arith-eq-adapter        1676899
;  :arith-fixed-eqs         3927165
;  :arith-offset-eqs        2303216
;  :arith-pivots            713895
;  :conflicts               7333
;  :datatype-accessor-ax    551
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1023641
;  :del-clause              63295846
;  :final-checks            5
;  :max-generation          14
;  :max-memory              517.91
;  :memory                  493.12
;  :minimized-lits          1064
;  :mk-bool-var             54446831
;  :mk-clause               63298090
;  :num-allocs              128943445
;  :num-checks              655
;  :propagations            18726571
;  :quant-instantiations    22809361
;  :restarts                15
;  :rlimit-count            509882305
;  :time                    0.01)
; Definitional axioms for inverse functions
(assert (forall ((i1@590@04 Int) (j1@591@04 Int)) (!
  (implies
    (and
      (and (and (< j1@591@04 V@15@04) (<= 0 j1@591@04)) (< i1@590@04 V@15@04))
      (<= 0 i1@590@04))
    (and
      (=
        (inv@592@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@582@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@590@04))) j1@591@04))
        i1@590@04)
      (=
        (inv@593@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@582@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@590@04))) j1@591@04))
        j1@591@04)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@582@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@590@04))) j1@591@04))
  :qid |int-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@593@04 r) V@15@04) (<= 0 (inv@593@04 r)))
        (< (inv@592@04 r) V@15@04))
      (<= 0 (inv@592@04 r)))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@582@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) (inv@592@04 r)))) (inv@593@04 r))
      r))
  :pattern ((inv@592@04 r))
  :pattern ((inv@593@04 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@593@04 r) V@15@04) (<= 0 (inv@593@04 r)))
        (< (inv@592@04 r) V@15@04))
      (<= 0 (inv@592@04 r)))
    ($FVF.loc_int ($FVF.lookup_int (as sm@594@04  $FVF<Int>) r) r))
  :pattern ((inv@592@04 r) (inv@593@04 r))
  )))
; Precomputing data for removing quantified permissions
(define-fun pTaken@595@04 ((r $Ref)) $Perm
  (ite
    (and
      (and
        (and (< (inv@593@04 r) V@15@04) (<= 0 (inv@593@04 r)))
        (< (inv@592@04 r) V@15@04))
      (<= 0 (inv@592@04 r)))
    ($Perm.min
      (ite
        (and (< (inv@457@04 r) V@15@04) (<= 0 (inv@457@04 r)))
        $Perm.Write
        $Perm.No)
      $Perm.Write)
    $Perm.No))
(define-fun pTaken@596@04 ((r $Ref)) $Perm
  (ite
    (and
      (and
        (and (< (inv@593@04 r) V@15@04) (<= 0 (inv@593@04 r)))
        (< (inv@592@04 r) V@15@04))
      (<= 0 (inv@592@04 r)))
    ($Perm.min
      (ite
        (and
          (and
            (and (< (inv@454@04 r) V@15@04) (<= 0 (inv@454@04 r)))
            (< (inv@453@04 r) V@15@04))
          (<= 0 (inv@453@04 r)))
        $Perm.Write
        $Perm.No)
      (- $Perm.Write (pTaken@595@04 r)))
    $Perm.No))
(define-fun pTaken@597@04 ((r $Ref)) $Perm
  (ite
    (and
      (and
        (and (< (inv@593@04 r) V@15@04) (<= 0 (inv@593@04 r)))
        (< (inv@592@04 r) V@15@04))
      (<= 0 (inv@592@04 r)))
    ($Perm.min
      (-
        (-
          (ite
            (and
              (and
                (and (< (inv@366@04 r) V@15@04) (<= 0 (inv@366@04 r)))
                (< (inv@365@04 r) V@15@04))
              (<= 0 (inv@365@04 r)))
            $Perm.Write
            $Perm.No)
          (pTaken@481@04 r))
        (pTaken@485@04 r))
      (- (- $Perm.Write (pTaken@595@04 r)) (pTaken@596@04 r)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 500)
(push) ; 16
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and (< (inv@457@04 r) V@15@04) (<= 0 (inv@457@04 r)))
        $Perm.Write
        $Perm.No)
      (pTaken@595@04 r))
    $Perm.No)
  
  ))))
(check-sat)
; unknown
(pop) ; 16
; 0.52s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               24215190
;  :arith-add-rows          5117272
;  :arith-assert-diseq      165493
;  :arith-assert-lower      4378822
;  :arith-assert-upper      3766500
;  :arith-bound-prop        116199
;  :arith-conflicts         3068
;  :arith-eq-adapter        1679463
;  :arith-fixed-eqs         3929616
;  :arith-offset-eqs        2305230
;  :arith-pivots            716459
;  :conflicts               7343
;  :datatype-accessor-ax    567
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1025110
;  :del-clause              63407801
;  :final-checks            5
;  :max-generation          14
;  :max-memory              517.91
;  :memory                  493.89
;  :minimized-lits          1064
;  :mk-bool-var             54546714
;  :mk-clause               63410045
;  :num-allocs              129207171
;  :num-checks              657
;  :propagations            18747286
;  :quant-instantiations    22843617
;  :restarts                15
;  :rlimit-count            511005830
;  :time                    0.52)
; Intermediate check if already taken enough permissions
(push) ; 16
(assert (not (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@593@04 r) V@15@04) (<= 0 (inv@593@04 r)))
        (< (inv@592@04 r) V@15@04))
      (<= 0 (inv@592@04 r)))
    (= (- $Perm.Write (pTaken@595@04 r)) $Perm.No))
  
  ))))
(check-sat)
; unknown
(pop) ; 16
; 0.50s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               24229199
;  :arith-add-rows          5125515
;  :arith-assert-diseq      165590
;  :arith-assert-lower      4381152
;  :arith-assert-upper      3768178
;  :arith-bound-prop        116781
;  :arith-conflicts         3072
;  :arith-eq-adapter        1681368
;  :arith-fixed-eqs         3931273
;  :arith-offset-eqs        2306478
;  :arith-pivots            718468
;  :conflicts               7351
;  :datatype-accessor-ax    579
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1026763
;  :del-clause              63504253
;  :final-checks            5
;  :max-generation          14
;  :max-memory              517.91
;  :memory                  493.25
;  :minimized-lits          1064
;  :mk-bool-var             54631192
;  :mk-clause               63506497
;  :num-allocs              129423692
;  :num-checks              658
;  :propagations            18766053
;  :quant-instantiations    22871139
;  :restarts                15
;  :rlimit-count            511969027
;  :time                    0.50)
; Chunk depleted?
(push) ; 16
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and
          (and
            (and (< (inv@454@04 r) V@15@04) (<= 0 (inv@454@04 r)))
            (< (inv@453@04 r) V@15@04))
          (<= 0 (inv@453@04 r)))
        $Perm.Write
        $Perm.No)
      (pTaken@596@04 r))
    $Perm.No)
  
  ))))
(check-sat)
; unknown
(pop) ; 16
; 0.50s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               24241789
;  :arith-add-rows          5141476
;  :arith-assert-diseq      165844
;  :arith-assert-lower      4383080
;  :arith-assert-upper      3769370
;  :arith-bound-prop        116953
;  :arith-conflicts         3079
;  :arith-eq-adapter        1682523
;  :arith-fixed-eqs         3932531
;  :arith-offset-eqs        2307003
;  :arith-pivots            719084
;  :conflicts               7366
;  :datatype-accessor-ax    635
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1032652
;  :del-clause              63679343
;  :final-checks            5
;  :max-generation          14
;  :max-memory              517.91
;  :memory                  493.22
;  :minimized-lits          1064
;  :mk-bool-var             54751372
;  :mk-clause               63681587
;  :num-allocs              129684994
;  :num-checks              659
;  :propagations            18788475
;  :quant-instantiations    22897836
;  :restarts                15
;  :rlimit-count            512911244
;  :time                    0.50)
; Intermediate check if already taken enough permissions
(push) ; 16
(assert (not (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@593@04 r) V@15@04) (<= 0 (inv@593@04 r)))
        (< (inv@592@04 r) V@15@04))
      (<= 0 (inv@592@04 r)))
    (= (- (- $Perm.Write (pTaken@595@04 r)) (pTaken@596@04 r)) $Perm.No))
  
  ))))
(check-sat)
; unsat
(pop) ; 16
; 0.06s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               24243460
;  :arith-add-rows          5143057
;  :arith-assert-diseq      165870
;  :arith-assert-lower      4383283
;  :arith-assert-upper      3769551
;  :arith-bound-prop        117015
;  :arith-conflicts         3086
;  :arith-eq-adapter        1682691
;  :arith-fixed-eqs         3932693
;  :arith-offset-eqs        2307085
;  :arith-pivots            719261
;  :conflicts               7376
;  :datatype-accessor-ax    639
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1032997
;  :del-clause              63691567
;  :final-checks            5
;  :max-generation          14
;  :max-memory              517.91
;  :memory                  493.32
;  :minimized-lits          1064
;  :mk-bool-var             54760687
;  :mk-clause               63693811
;  :num-allocs              129713676
;  :num-checks              660
;  :propagations            18790248
;  :quant-instantiations    22900059
;  :restarts                15
;  :rlimit-count            513059552
;  :time                    0.06)
; Final check if taken enough permissions
; Done removing quantified permissions
; Definitional axioms for snapshot map values
(declare-const i1@598@04 Int)
(push) ; 16
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 17
; [then-branch: 312 | 0 <= i1@598@04 | live]
; [else-branch: 312 | !(0 <= i1@598@04) | live]
(push) ; 18
; [then-branch: 312 | 0 <= i1@598@04]
(assert (<= 0 i1@598@04))
; [eval] i1 < V
(pop) ; 18
(push) ; 18
; [else-branch: 312 | !(0 <= i1@598@04)]
(assert (not (<= 0 i1@598@04)))
(pop) ; 18
(pop) ; 17
; Joined path conditions
; Joined path conditions
(assert (and (< i1@598@04 V@15@04) (<= 0 i1@598@04)))
; [eval] aloc(opt_get1(p), i1)
; [eval] opt_get1(p)
(push) ; 17
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 17
; Joined path conditions
(push) ; 17
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 18
(assert (not (< i1@598@04 (alen<Int> (opt_get1 $Snap.unit P@14@04)))))
(check-sat)
; unsat
(pop) ; 18
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               24243460
;  :arith-add-rows          5143058
;  :arith-assert-diseq      165870
;  :arith-assert-lower      4383285
;  :arith-assert-upper      3769551
;  :arith-bound-prop        117015
;  :arith-conflicts         3086
;  :arith-eq-adapter        1682691
;  :arith-fixed-eqs         3932693
;  :arith-offset-eqs        2307085
;  :arith-pivots            719262
;  :conflicts               7376
;  :datatype-accessor-ax    639
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1032997
;  :del-clause              63691567
;  :final-checks            5
;  :max-generation          14
;  :max-memory              517.91
;  :memory                  493.32
;  :minimized-lits          1064
;  :mk-bool-var             54760689
;  :mk-clause               63693811
;  :num-allocs              129713786
;  :num-checks              661
;  :propagations            18790248
;  :quant-instantiations    22900059
;  :restarts                15
;  :rlimit-count            513059738)
(assert (< i1@598@04 (alen<Int> (opt_get1 $Snap.unit P@14@04))))
(pop) ; 17
; Joined path conditions
(assert (< i1@598@04 (alen<Int> (opt_get1 $Snap.unit P@14@04))))
(pop) ; 16
(declare-fun inv@599@04 ($Ref) Int)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(assert (forall ((i1@598@04 Int)) (!
  (< i1@598@04 (alen<Int> (opt_get1 $Snap.unit P@14@04)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i1@598@04))
  :qid |int-aux|)))
(declare-const sm@600@04 $FVF<Int>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (-
          (ite
            (and
              (and
                (and (< (inv@366@04 r) V@15@04) (<= 0 (inv@366@04 r)))
                (< (inv@365@04 r) V@15@04))
              (<= 0 (inv@365@04 r)))
            $Perm.Write
            $Perm.No)
          (pTaken@481@04 r))
        (pTaken@485@04 r)))
    (=
      ($FVF.lookup_int (as sm@600@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@600@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))))))) r))
  :qid |qp.fvfValDef466|)))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (ite
          (and
            (and
              (and (< (inv@454@04 r) V@15@04) (<= 0 (inv@454@04 r)))
              (< (inv@453@04 r) V@15@04))
            (<= 0 (inv@453@04 r)))
          $Perm.Write
          $Perm.No)
        (pTaken@596@04 r)))
    (=
      ($FVF.lookup_int (as sm@600@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@600@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))))))) r))
  :qid |qp.fvfValDef467|)))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (ite
          (and (< (inv@457@04 r) V@15@04) (<= 0 (inv@457@04 r)))
          $Perm.Write
          $Perm.No)
        (pTaken@595@04 r)))
    (=
      ($FVF.lookup_int (as sm@600@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04)))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@600@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04)))))))))))))) r))
  :qid |qp.fvfValDef468|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04)))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@600@04  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef469|)))
; Check receiver injectivity
(push) ; 16
(assert (not (forall ((i11@598@04 Int) (i12@598@04 Int)) (!
  (implies
    (and
      (and
        (and (< i11@598@04 V@15@04) (<= 0 i11@598@04))
        ($FVF.loc_int ($FVF.lookup_int (as sm@600@04  $FVF<Int>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit P@14@04) i11@598@04)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit P@14@04) i11@598@04)))
      (and
        (and (< i12@598@04 V@15@04) (<= 0 i12@598@04))
        ($FVF.loc_int ($FVF.lookup_int (as sm@600@04  $FVF<Int>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit P@14@04) i12@598@04)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit P@14@04) i12@598@04)))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i11@598@04)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i12@598@04)))
    (= i11@598@04 i12@598@04))
  
  :qid |int-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               24243526
;  :arith-add-rows          5143077
;  :arith-assert-diseq      165871
;  :arith-assert-lower      4383289
;  :arith-assert-upper      3769551
;  :arith-bound-prop        117015
;  :arith-conflicts         3086
;  :arith-eq-adapter        1682692
;  :arith-fixed-eqs         3932693
;  :arith-offset-eqs        2307085
;  :arith-pivots            719267
;  :conflicts               7377
;  :datatype-accessor-ax    639
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1032997
;  :del-clause              63691637
;  :final-checks            5
;  :max-generation          14
;  :max-memory              517.91
;  :memory                  493.32
;  :minimized-lits          1064
;  :mk-bool-var             54760842
;  :mk-clause               63693881
;  :num-allocs              129715810
;  :num-checks              662
;  :propagations            18790251
;  :quant-instantiations    22900164
;  :restarts                15
;  :rlimit-count            513067631
;  :time                    0.01)
; Definitional axioms for inverse functions
(assert (forall ((i1@598@04 Int)) (!
  (implies
    (and (< i1@598@04 V@15@04) (<= 0 i1@598@04))
    (=
      (inv@599@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i1@598@04))
      i1@598@04))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i1@598@04))
  :qid |int-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@599@04 r) V@15@04) (<= 0 (inv@599@04 r)))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) (inv@599@04 r))
      r))
  :pattern ((inv@599@04 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@599@04 r) V@15@04) (<= 0 (inv@599@04 r)))
    ($FVF.loc_int ($FVF.lookup_int (as sm@600@04  $FVF<Int>) r) r))
  :pattern ((inv@599@04 r))
  )))
; Precomputing data for removing quantified permissions
(define-fun pTaken@601@04 ((r $Ref)) $Perm
  (ite
    (and (< (inv@599@04 r) V@15@04) (<= 0 (inv@599@04 r)))
    ($Perm.min
      (-
        (-
          (ite
            (and
              (and
                (and (< (inv@366@04 r) V@15@04) (<= 0 (inv@366@04 r)))
                (< (inv@365@04 r) V@15@04))
              (<= 0 (inv@365@04 r)))
            $Perm.Write
            $Perm.No)
          (pTaken@481@04 r))
        (pTaken@485@04 r))
      $Perm.Write)
    $Perm.No))
(define-fun pTaken@602@04 ((r $Ref)) $Perm
  (ite
    (and (< (inv@599@04 r) V@15@04) (<= 0 (inv@599@04 r)))
    ($Perm.min
      (-
        (ite
          (and
            (and
              (and (< (inv@454@04 r) V@15@04) (<= 0 (inv@454@04 r)))
              (< (inv@453@04 r) V@15@04))
            (<= 0 (inv@453@04 r)))
          $Perm.Write
          $Perm.No)
        (pTaken@596@04 r))
      (- $Perm.Write (pTaken@601@04 r)))
    $Perm.No))
(define-fun pTaken@603@04 ((r $Ref)) $Perm
  (ite
    (and (< (inv@599@04 r) V@15@04) (<= 0 (inv@599@04 r)))
    ($Perm.min
      (-
        (ite
          (and (< (inv@457@04 r) V@15@04) (<= 0 (inv@457@04 r)))
          $Perm.Write
          $Perm.No)
        (pTaken@595@04 r))
      (- (- $Perm.Write (pTaken@601@04 r)) (pTaken@602@04 r)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 500)
(push) ; 16
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (-
        (-
          (ite
            (and
              (and
                (and (< (inv@366@04 r) V@15@04) (<= 0 (inv@366@04 r)))
                (< (inv@365@04 r) V@15@04))
              (<= 0 (inv@365@04 r)))
            $Perm.Write
            $Perm.No)
          (pTaken@481@04 r))
        (pTaken@485@04 r))
      (pTaken@601@04 r))
    $Perm.No)
  
  ))))
(check-sat)
; unknown
(pop) ; 16
; 0.50s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               24259114
;  :arith-add-rows          5151788
;  :arith-assert-diseq      165977
;  :arith-assert-lower      4385761
;  :arith-assert-upper      3771535
;  :arith-bound-prop        117702
;  :arith-conflicts         3097
;  :arith-eq-adapter        1685000
;  :arith-fixed-eqs         3934618
;  :arith-offset-eqs        2308411
;  :arith-pivots            721571
;  :conflicts               7400
;  :datatype-accessor-ax    651
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1034144
;  :del-clause              63786121
;  :final-checks            5
;  :max-generation          14
;  :max-memory              517.91
;  :memory                  493.68
;  :minimized-lits          1067
;  :mk-bool-var             54852115
;  :mk-clause               63788365
;  :num-allocs              129957035
;  :num-checks              664
;  :propagations            18807377
;  :quant-instantiations    22930154
;  :restarts                15
;  :rlimit-count            514109095
;  :time                    0.50)
; Intermediate check if already taken enough permissions
(push) ; 16
(assert (not (forall ((r $Ref)) (!
  (implies
    (and (< (inv@599@04 r) V@15@04) (<= 0 (inv@599@04 r)))
    (= (- $Perm.Write (pTaken@601@04 r)) $Perm.No))
  
  ))))
(check-sat)
; unknown
(pop) ; 16
; 0.50s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               24271349
;  :arith-add-rows          5165783
;  :arith-assert-diseq      166172
;  :arith-assert-lower      4387621
;  :arith-assert-upper      3772776
;  :arith-bound-prop        118063
;  :arith-conflicts         3103
;  :arith-eq-adapter        1686203
;  :arith-fixed-eqs         3935833
;  :arith-offset-eqs        2309141
;  :arith-pivots            722497
;  :conflicts               7414
;  :datatype-accessor-ax    691
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1038652
;  :del-clause              63926173
;  :final-checks            5
;  :max-generation          14
;  :max-memory              517.91
;  :memory                  494.26
;  :minimized-lits          1068
;  :mk-bool-var             54952953
;  :mk-clause               63928417
;  :num-allocs              130192744
;  :num-checks              665
;  :propagations            18826591
;  :quant-instantiations    22953902
;  :restarts                15
;  :rlimit-count            515071720
;  :time                    0.50)
; Chunk depleted?
(push) ; 16
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (-
        (ite
          (and
            (and
              (and (< (inv@454@04 r) V@15@04) (<= 0 (inv@454@04 r)))
              (< (inv@453@04 r) V@15@04))
            (<= 0 (inv@453@04 r)))
          $Perm.Write
          $Perm.No)
        (pTaken@596@04 r))
      (pTaken@602@04 r))
    $Perm.No)
  
  ))))
(check-sat)
; unsat
(pop) ; 16
; 0.46s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               24282977
;  :arith-add-rows          5179858
;  :arith-assert-diseq      166554
;  :arith-assert-lower      4389843
;  :arith-assert-upper      3774141
;  :arith-bound-prop        118347
;  :arith-conflicts         3125
;  :arith-eq-adapter        1687537
;  :arith-fixed-eqs         3937128
;  :arith-offset-eqs        2309723
;  :arith-pivots            723202
;  :conflicts               7467
;  :datatype-accessor-ax    739
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1042931
;  :del-clause              64065690
;  :final-checks            5
;  :max-generation          14
;  :max-memory              517.91
;  :memory                  493.86
;  :minimized-lits          1087
;  :mk-bool-var             55052532
;  :mk-clause               64067934
;  :num-allocs              130397220
;  :num-checks              666
;  :propagations            18844618
;  :quant-instantiations    22976919
;  :restarts                15
;  :rlimit-count            515785264
;  :time                    0.46)
; Intermediate check if already taken enough permissions
(push) ; 16
(assert (not (forall ((r $Ref)) (!
  (implies
    (and (< (inv@599@04 r) V@15@04) (<= 0 (inv@599@04 r)))
    (= (- (- $Perm.Write (pTaken@601@04 r)) (pTaken@602@04 r)) $Perm.No))
  
  ))))
(check-sat)
; unknown
(pop) ; 16
; 0.50s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               24299586
;  :arith-add-rows          5188968
;  :arith-assert-diseq      166678
;  :arith-assert-lower      4392932
;  :arith-assert-upper      3776442
;  :arith-bound-prop        119012
;  :arith-conflicts         3140
;  :arith-eq-adapter        1690039
;  :arith-fixed-eqs         3939447
;  :arith-offset-eqs        2311473
;  :arith-pivots            725821
;  :conflicts               7500
;  :datatype-accessor-ax    747
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1044631
;  :del-clause              64160710
;  :final-checks            5
;  :max-generation          14
;  :max-memory              517.91
;  :memory                  494.98
;  :minimized-lits          1103
;  :mk-bool-var             55142022
;  :mk-clause               64162954
;  :num-allocs              130633188
;  :num-checks              667
;  :propagations            18865871
;  :quant-instantiations    23007545
;  :restarts                15
;  :rlimit-count            516881424
;  :time                    0.50)
; Chunk depleted?
(push) ; 16
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (-
        (ite
          (and (< (inv@457@04 r) V@15@04) (<= 0 (inv@457@04 r)))
          $Perm.Write
          $Perm.No)
        (pTaken@595@04 r))
      (pTaken@603@04 r))
    $Perm.No)
  
  ))))
(check-sat)
; unknown
(pop) ; 16
; 0.51s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               24318911
;  :arith-add-rows          5201655
;  :arith-assert-diseq      166933
;  :arith-assert-lower      4396377
;  :arith-assert-upper      3778833
;  :arith-bound-prop        119363
;  :arith-conflicts         3150
;  :arith-eq-adapter        1692412
;  :arith-fixed-eqs         3942186
;  :arith-offset-eqs        2313935
;  :arith-pivots            727736
;  :conflicts               7530
;  :datatype-accessor-ax    775
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1047733
;  :del-clause              64299812
;  :final-checks            5
;  :max-generation          14
;  :max-memory              517.91
;  :memory                  493.75
;  :minimized-lits          1106
;  :mk-bool-var             55247995
;  :mk-clause               64302056
;  :num-allocs              130875850
;  :num-checks              668
;  :propagations            18885882
;  :quant-instantiations    23038019
;  :restarts                15
;  :rlimit-count            517772193
;  :time                    0.51)
; Intermediate check if already taken enough permissions
(push) ; 16
(assert (not (forall ((r $Ref)) (!
  (implies
    (and (< (inv@599@04 r) V@15@04) (<= 0 (inv@599@04 r)))
    (=
      (-
        (- (- $Perm.Write (pTaken@601@04 r)) (pTaken@602@04 r))
        (pTaken@603@04 r))
      $Perm.No))
  
  ))))
(check-sat)
; unsat
(pop) ; 16
; 0.17s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               24326641
;  :arith-add-rows          5206527
;  :arith-assert-diseq      167031
;  :arith-assert-lower      4397829
;  :arith-assert-upper      3779882
;  :arith-bound-prop        119759
;  :arith-conflicts         3168
;  :arith-eq-adapter        1693522
;  :arith-fixed-eqs         3943295
;  :arith-offset-eqs        2314823
;  :arith-pivots            728780
;  :conflicts               7565
;  :datatype-accessor-ax    779
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1048584
;  :del-clause              64339320
;  :final-checks            5
;  :max-generation          14
;  :max-memory              517.91
;  :memory                  494.01
;  :minimized-lits          1108
;  :mk-bool-var             55281598
;  :mk-clause               64341564
;  :num-allocs              130977937
;  :num-checks              669
;  :propagations            18891910
;  :quant-instantiations    23047871
;  :restarts                15
;  :rlimit-count            518240894
;  :time                    0.17)
; Final check if taken enough permissions
; Done removing quantified permissions
; Definitional axioms for snapshot map values
; [eval] valid_graph_vertices(this, p, V)
(push) ; 16
; [eval] this != null
; [eval] p != (None(): option[array])
; [eval] (None(): option[array])
; [eval] alen(opt_get1(p)) == V
; [eval] alen(opt_get1(p))
; [eval] opt_get1(p)
(push) ; 17
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 17
; Joined path conditions
(declare-const i1@604@04 Int)
(push) ; 17
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 18
; [then-branch: 313 | 0 <= i1@604@04 | live]
; [else-branch: 313 | !(0 <= i1@604@04) | live]
(push) ; 19
; [then-branch: 313 | 0 <= i1@604@04]
(assert (<= 0 i1@604@04))
; [eval] i1 < V
(pop) ; 19
(push) ; 19
; [else-branch: 313 | !(0 <= i1@604@04)]
(assert (not (<= 0 i1@604@04)))
(pop) ; 19
(pop) ; 18
; Joined path conditions
; Joined path conditions
(assert (and (< i1@604@04 V@15@04) (<= 0 i1@604@04)))
(declare-const $k@605@04 $Perm)
(assert ($Perm.isReadVar $k@605@04 $Perm.Write))
; [eval] aloc(opt_get1(p), i1)
; [eval] opt_get1(p)
(push) ; 18
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 18
; Joined path conditions
(push) ; 18
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 19
(assert (not (< i1@604@04 (alen<Int> (opt_get1 $Snap.unit P@14@04)))))
(check-sat)
; unsat
(pop) ; 19
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               24326641
;  :arith-add-rows          5206528
;  :arith-assert-diseq      167032
;  :arith-assert-lower      4397833
;  :arith-assert-upper      3779883
;  :arith-bound-prop        119759
;  :arith-conflicts         3168
;  :arith-eq-adapter        1693523
;  :arith-fixed-eqs         3943295
;  :arith-offset-eqs        2314823
;  :arith-pivots            728781
;  :conflicts               7565
;  :datatype-accessor-ax    779
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1048584
;  :del-clause              64339320
;  :final-checks            5
;  :max-generation          14
;  :max-memory              517.91
;  :memory                  494.01
;  :minimized-lits          1108
;  :mk-bool-var             55281604
;  :mk-clause               64341566
;  :num-allocs              130978114
;  :num-checks              670
;  :propagations            18891911
;  :quant-instantiations    23047871
;  :restarts                15
;  :rlimit-count            518241232)
(assert (< i1@604@04 (alen<Int> (opt_get1 $Snap.unit P@14@04))))
(pop) ; 18
; Joined path conditions
(assert (< i1@604@04 (alen<Int> (opt_get1 $Snap.unit P@14@04))))
(pop) ; 17
(declare-fun inv@606@04 ($Ref) Int)
; Nested auxiliary terms: globals
(assert ($Perm.isReadVar $k@605@04 $Perm.Write))
; Nested auxiliary terms: non-globals
(assert (forall ((i1@604@04 Int)) (!
  (< i1@604@04 (alen<Int> (opt_get1 $Snap.unit P@14@04)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i1@604@04))
  :qid |int-aux|)))
(push) ; 17
(assert (not (forall ((i1@604@04 Int)) (!
  (implies
    (and (< i1@604@04 V@15@04) (<= 0 i1@604@04))
    (or (= $k@605@04 $Perm.No) (< $Perm.No $k@605@04)))
  
  ))))
(check-sat)
; unsat
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               24326641
;  :arith-add-rows          5206529
;  :arith-assert-diseq      167033
;  :arith-assert-lower      4397835
;  :arith-assert-upper      3779884
;  :arith-bound-prop        119759
;  :arith-conflicts         3168
;  :arith-eq-adapter        1693524
;  :arith-fixed-eqs         3943295
;  :arith-offset-eqs        2314823
;  :arith-pivots            728782
;  :conflicts               7566
;  :datatype-accessor-ax    779
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1048584
;  :del-clause              64339322
;  :final-checks            5
;  :max-generation          14
;  :max-memory              517.91
;  :memory                  494.01
;  :minimized-lits          1108
;  :mk-bool-var             55281611
;  :mk-clause               64341568
;  :num-allocs              130978545
;  :num-checks              671
;  :propagations            18891912
;  :quant-instantiations    23047871
;  :restarts                15
;  :rlimit-count            518241783)
(declare-const sm@607@04 $FVF<Int>)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (-
          (ite
            (and
              (and
                (and (< (inv@366@04 r) V@15@04) (<= 0 (inv@366@04 r)))
                (< (inv@365@04 r) V@15@04))
              (<= 0 (inv@365@04 r)))
            $Perm.Write
            $Perm.No)
          (pTaken@481@04 r))
        (pTaken@485@04 r)))
    (=
      ($FVF.lookup_int (as sm@607@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@607@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))))))) r))
  :qid |qp.fvfValDef470|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@454@04 r) V@15@04) (<= 0 (inv@454@04 r)))
        (< (inv@453@04 r) V@15@04))
      (<= 0 (inv@453@04 r)))
    (=
      ($FVF.lookup_int (as sm@607@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@607@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))))))) r))
  :qid |qp.fvfValDef471|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@457@04 r) V@15@04) (<= 0 (inv@457@04 r)))
    (=
      ($FVF.lookup_int (as sm@607@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04)))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@607@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04)))))))))))))) r))
  :qid |qp.fvfValDef472|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04)))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@607@04  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef473|)))
; Check receiver injectivity
(push) ; 17
(assert (not (forall ((i11@604@04 Int) (i12@604@04 Int)) (!
  (implies
    (and
      (and
        (and
          (and (< i11@604@04 V@15@04) (<= 0 i11@604@04))
          ($FVF.loc_int ($FVF.lookup_int (as sm@607@04  $FVF<Int>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit P@14@04) i11@604@04)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit P@14@04) i11@604@04)))
        (< $Perm.No $k@605@04))
      (and
        (and
          (and (< i12@604@04 V@15@04) (<= 0 i12@604@04))
          ($FVF.loc_int ($FVF.lookup_int (as sm@607@04  $FVF<Int>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit P@14@04) i12@604@04)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit P@14@04) i12@604@04)))
        (< $Perm.No $k@605@04))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i11@604@04)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i12@604@04)))
    (= i11@604@04 i12@604@04))
  
  :qid |int-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 17
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               24326709
;  :arith-add-rows          5206546
;  :arith-assert-diseq      167034
;  :arith-assert-lower      4397839
;  :arith-assert-upper      3779884
;  :arith-bound-prop        119759
;  :arith-conflicts         3168
;  :arith-eq-adapter        1693525
;  :arith-fixed-eqs         3943295
;  :arith-offset-eqs        2314823
;  :arith-pivots            728786
;  :conflicts               7567
;  :datatype-accessor-ax    779
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1048584
;  :del-clause              64339367
;  :final-checks            5
;  :max-generation          14
;  :max-memory              517.91
;  :memory                  494.01
;  :minimized-lits          1108
;  :mk-bool-var             55281742
;  :mk-clause               64341613
;  :num-allocs              130980264
;  :num-checks              672
;  :propagations            18891915
;  :quant-instantiations    23047980
;  :restarts                15
;  :rlimit-count            518248249
;  :time                    0.01)
; Definitional axioms for inverse functions
(assert (forall ((i1@604@04 Int)) (!
  (implies
    (and (and (< i1@604@04 V@15@04) (<= 0 i1@604@04)) (< $Perm.No $k@605@04))
    (=
      (inv@606@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i1@604@04))
      i1@604@04))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i1@604@04))
  :qid |int-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and (< (inv@606@04 r) V@15@04) (<= 0 (inv@606@04 r)))
      (< $Perm.No $k@605@04))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) (inv@606@04 r))
      r))
  :pattern ((inv@606@04 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@606@04 r) V@15@04) (<= 0 (inv@606@04 r)))
    ($FVF.loc_int ($FVF.lookup_int (as sm@607@04  $FVF<Int>) r) r))
  :pattern ((inv@606@04 r))
  )))
; Precomputing data for removing quantified permissions
(define-fun pTaken@608@04 ((r $Ref)) $Perm
  (ite
    (and (< (inv@606@04 r) V@15@04) (<= 0 (inv@606@04 r)))
    ($Perm.min
      (-
        (-
          (ite
            (and
              (and
                (and (< (inv@366@04 r) V@15@04) (<= 0 (inv@366@04 r)))
                (< (inv@365@04 r) V@15@04))
              (<= 0 (inv@365@04 r)))
            $Perm.Write
            $Perm.No)
          (pTaken@481@04 r))
        (pTaken@485@04 r))
      $k@605@04)
    $Perm.No))
(define-fun pTaken@609@04 ((r $Ref)) $Perm
  (ite
    (and (< (inv@606@04 r) V@15@04) (<= 0 (inv@606@04 r)))
    ($Perm.min
      (ite
        (and
          (and
            (and (< (inv@454@04 r) V@15@04) (<= 0 (inv@454@04 r)))
            (< (inv@453@04 r) V@15@04))
          (<= 0 (inv@453@04 r)))
        $Perm.Write
        $Perm.No)
      (- $k@605@04 (pTaken@608@04 r)))
    $Perm.No))
(define-fun pTaken@610@04 ((r $Ref)) $Perm
  (ite
    (and (< (inv@606@04 r) V@15@04) (<= 0 (inv@606@04 r)))
    ($Perm.min
      (ite
        (and (< (inv@457@04 r) V@15@04) (<= 0 (inv@457@04 r)))
        $Perm.Write
        $Perm.No)
      (- (- $k@605@04 (pTaken@608@04 r)) (pTaken@609@04 r)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Constrain original permissions $k@605@04
(assert (forall ((r $Ref)) (!
  (implies
    (not
      (=
        (-
          (-
            (ite
              (and
                (and
                  (and (< (inv@366@04 r) V@15@04) (<= 0 (inv@366@04 r)))
                  (< (inv@365@04 r) V@15@04))
                (<= 0 (inv@365@04 r)))
              $Perm.Write
              $Perm.No)
            (pTaken@481@04 r))
          (pTaken@485@04 r))
        $Perm.No))
    (<
      (ite
        (and (< (inv@606@04 r) V@15@04) (<= 0 (inv@606@04 r)))
        $k@605@04
        $Perm.No)
      (-
        (-
          (ite
            (and
              (and
                (and (< (inv@366@04 r) V@15@04) (<= 0 (inv@366@04 r)))
                (< (inv@365@04 r) V@15@04))
              (<= 0 (inv@365@04 r)))
            $Perm.Write
            $Perm.No)
          (pTaken@481@04 r))
        (pTaken@485@04 r))))
  :pattern ((inv@366@04 r))
  :pattern ((inv@365@04 r))
  :pattern ((inv@606@04 r))
  :qid |qp.srp474|)))
; Intermediate check if already taken enough permissions
(set-option :timeout 500)
(push) ; 17
(assert (not (forall ((r $Ref)) (!
  (implies
    (and (< (inv@606@04 r) V@15@04) (<= 0 (inv@606@04 r)))
    (= (- $k@605@04 (pTaken@608@04 r)) $Perm.No))
  
  ))))
(check-sat)
; unknown
(pop) ; 17
; 0.50s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               24342547
;  :arith-add-rows          5216049
;  :arith-assert-diseq      167150
;  :arith-assert-lower      4400574
;  :arith-assert-upper      3781938
;  :arith-bound-prop        120468
;  :arith-conflicts         3173
;  :arith-eq-adapter        1695888
;  :arith-fixed-eqs         3945264
;  :arith-offset-eqs        2316365
;  :arith-pivots            731228
;  :conflicts               7583
;  :datatype-accessor-ax    791
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1050441
;  :del-clause              64446518
;  :final-checks            5
;  :max-generation          14
;  :max-memory              517.91
;  :memory                  494.49
;  :minimized-lits          1109
;  :mk-bool-var             55377554
;  :mk-clause               64448764
;  :num-allocs              131240954
;  :num-checks              674
;  :propagations            18913515
;  :quant-instantiations    23079409
;  :restarts                15
;  :rlimit-count            519460345
;  :time                    0.50)
; Constrain original permissions $k@605@04
(assert (forall ((r $Ref)) (!
  (implies
    (not
      (=
        (ite
          (and
            (and
              (and (< (inv@454@04 r) V@15@04) (<= 0 (inv@454@04 r)))
              (< (inv@453@04 r) V@15@04))
            (<= 0 (inv@453@04 r)))
          $Perm.Write
          $Perm.No)
        $Perm.No))
    (ite
      (and
        (and
          (and (< (inv@454@04 r) V@15@04) (<= 0 (inv@454@04 r)))
          (< (inv@453@04 r) V@15@04))
        (<= 0 (inv@453@04 r)))
      (<
        (ite
          (and (< (inv@606@04 r) V@15@04) (<= 0 (inv@606@04 r)))
          $k@605@04
          $Perm.No)
        $Perm.Write)
      (<
        (ite
          (and (< (inv@606@04 r) V@15@04) (<= 0 (inv@606@04 r)))
          $k@605@04
          $Perm.No)
        $Perm.No)))
  :pattern ((inv@454@04 r))
  :pattern ((inv@453@04 r))
  :pattern ((inv@606@04 r))
  :qid |qp.srp475|)))
; Intermediate check if already taken enough permissions
(push) ; 17
(assert (not (forall ((r $Ref)) (!
  (implies
    (and (< (inv@606@04 r) V@15@04) (<= 0 (inv@606@04 r)))
    (= (- (- $k@605@04 (pTaken@608@04 r)) (pTaken@609@04 r)) $Perm.No))
  
  ))))
(check-sat)
; unknown
(pop) ; 17
; 0.51s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               24358117
;  :arith-add-rows          5224629
;  :arith-assert-diseq      167276
;  :arith-assert-lower      4403312
;  :arith-assert-upper      3784028
;  :arith-bound-prop        121220
;  :arith-conflicts         3185
;  :arith-eq-adapter        1698247
;  :arith-fixed-eqs         3947234
;  :arith-offset-eqs        2317592
;  :arith-pivots            733669
;  :conflicts               7606
;  :datatype-accessor-ax    803
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1052255
;  :del-clause              64553395
;  :final-checks            5
;  :max-generation          14
;  :max-memory              517.91
;  :memory                  493.88
;  :minimized-lits          1124
;  :mk-bool-var             55473199
;  :mk-clause               64555641
;  :num-allocs              131494955
;  :num-checks              675
;  :propagations            18934909
;  :quant-instantiations    23110833
;  :restarts                15
;  :rlimit-count            520614068
;  :time                    0.51)
; Constrain original permissions $k@605@04
(assert (forall ((r $Ref)) (!
  (implies
    (not
      (=
        (ite
          (and (< (inv@457@04 r) V@15@04) (<= 0 (inv@457@04 r)))
          $Perm.Write
          $Perm.No)
        $Perm.No))
    (ite
      (and (< (inv@457@04 r) V@15@04) (<= 0 (inv@457@04 r)))
      (<
        (ite
          (and (< (inv@606@04 r) V@15@04) (<= 0 (inv@606@04 r)))
          $k@605@04
          $Perm.No)
        $Perm.Write)
      (<
        (ite
          (and (< (inv@606@04 r) V@15@04) (<= 0 (inv@606@04 r)))
          $k@605@04
          $Perm.No)
        $Perm.No)))
  :pattern ((inv@457@04 r))
  :pattern ((inv@606@04 r))
  :qid |qp.srp476|)))
; Intermediate check if already taken enough permissions
(push) ; 17
(assert (not (forall ((r $Ref)) (!
  (implies
    (and (< (inv@606@04 r) V@15@04) (<= 0 (inv@606@04 r)))
    (=
      (- (- (- $k@605@04 (pTaken@608@04 r)) (pTaken@609@04 r)) (pTaken@610@04 r))
      $Perm.No))
  
  ))))
(check-sat)
; unsat
(pop) ; 17
; 0.08s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               24359744
;  :arith-add-rows          5226275
;  :arith-assert-diseq      167324
;  :arith-assert-lower      4403586
;  :arith-assert-upper      3784231
;  :arith-bound-prop        121340
;  :arith-conflicts         3191
;  :arith-eq-adapter        1698456
;  :arith-fixed-eqs         3947395
;  :arith-offset-eqs        2317710
;  :arith-pivots            733875
;  :conflicts               7625
;  :datatype-accessor-ax    807
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1052607
;  :del-clause              64566919
;  :final-checks            5
;  :max-generation          14
;  :max-memory              517.91
;  :memory                  494.11
;  :minimized-lits          1125
;  :mk-bool-var             55484202
;  :mk-clause               64569165
;  :num-allocs              131531035
;  :num-checks              676
;  :propagations            18936703
;  :quant-instantiations    23113723
;  :restarts                15
;  :rlimit-count            520791235
;  :time                    0.08)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@611@04 $FVF<Int>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (iff
    (Set_in r ($FVF.domain_int (as sm@611@04  $FVF<Int>)))
    (and
      (and (< (inv@606@04 r) V@15@04) (<= 0 (inv@606@04 r)))
      (< $Perm.No $k@605@04)))
  :pattern ((Set_in r ($FVF.domain_int (as sm@611@04  $FVF<Int>))))
  :qid |qp.fvfDomDef481|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@606@04 r) V@15@04) (<= 0 (inv@606@04 r)))
        (< $Perm.No $k@605@04))
      (<
        $Perm.No
        (-
          (-
            (ite
              (and
                (and
                  (and (< (inv@366@04 r) V@15@04) (<= 0 (inv@366@04 r)))
                  (< (inv@365@04 r) V@15@04))
                (<= 0 (inv@365@04 r)))
              $Perm.Write
              $Perm.No)
            (pTaken@481@04 r))
          (pTaken@485@04 r))))
    (=
      ($FVF.lookup_int (as sm@611@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@611@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))))))) r))
  :qid |qp.fvfValDef477|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@606@04 r) V@15@04) (<= 0 (inv@606@04 r)))
        (< $Perm.No $k@605@04))
      (and
        (and
          (and (< (inv@454@04 r) V@15@04) (<= 0 (inv@454@04 r)))
          (< (inv@453@04 r) V@15@04))
        (<= 0 (inv@453@04 r))))
    (=
      ($FVF.lookup_int (as sm@611@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@611@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))))))) r))
  :qid |qp.fvfValDef478|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@606@04 r) V@15@04) (<= 0 (inv@606@04 r)))
        (< $Perm.No $k@605@04))
      (and (< (inv@457@04 r) V@15@04) (<= 0 (inv@457@04 r))))
    (=
      ($FVF.lookup_int (as sm@611@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04)))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@611@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04)))))))))))))) r))
  :qid |qp.fvfValDef479|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04)))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@611@04  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef480|)))
(pop) ; 16
; Joined path conditions
(assert ($Perm.isReadVar $k@605@04 $Perm.Write))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (-
          (ite
            (and
              (and
                (and (< (inv@366@04 r) V@15@04) (<= 0 (inv@366@04 r)))
                (< (inv@365@04 r) V@15@04))
              (<= 0 (inv@365@04 r)))
            $Perm.Write
            $Perm.No)
          (pTaken@481@04 r))
        (pTaken@485@04 r)))
    (=
      ($FVF.lookup_int (as sm@607@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@607@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))))))) r))
  :qid |qp.fvfValDef470|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@454@04 r) V@15@04) (<= 0 (inv@454@04 r)))
        (< (inv@453@04 r) V@15@04))
      (<= 0 (inv@453@04 r)))
    (=
      ($FVF.lookup_int (as sm@607@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@607@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))))))) r))
  :qid |qp.fvfValDef471|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@457@04 r) V@15@04) (<= 0 (inv@457@04 r)))
    (=
      ($FVF.lookup_int (as sm@607@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04)))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@607@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04)))))))))))))) r))
  :qid |qp.fvfValDef472|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04)))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@607@04  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef473|)))
(assert (forall ((i1@604@04 Int)) (!
  (implies
    (and (and (< i1@604@04 V@15@04) (<= 0 i1@604@04)) (< $Perm.No $k@605@04))
    (=
      (inv@606@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i1@604@04))
      i1@604@04))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i1@604@04))
  :qid |int-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and (< (inv@606@04 r) V@15@04) (<= 0 (inv@606@04 r)))
      (< $Perm.No $k@605@04))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) (inv@606@04 r))
      r))
  :pattern ((inv@606@04 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (iff
    (Set_in r ($FVF.domain_int (as sm@611@04  $FVF<Int>)))
    (and
      (and (< (inv@606@04 r) V@15@04) (<= 0 (inv@606@04 r)))
      (< $Perm.No $k@605@04)))
  :pattern ((Set_in r ($FVF.domain_int (as sm@611@04  $FVF<Int>))))
  :qid |qp.fvfDomDef481|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@606@04 r) V@15@04) (<= 0 (inv@606@04 r)))
        (< $Perm.No $k@605@04))
      (<
        $Perm.No
        (-
          (-
            (ite
              (and
                (and
                  (and (< (inv@366@04 r) V@15@04) (<= 0 (inv@366@04 r)))
                  (< (inv@365@04 r) V@15@04))
                (<= 0 (inv@365@04 r)))
              $Perm.Write
              $Perm.No)
            (pTaken@481@04 r))
          (pTaken@485@04 r))))
    (=
      ($FVF.lookup_int (as sm@611@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@611@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))))))) r))
  :qid |qp.fvfValDef477|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@606@04 r) V@15@04) (<= 0 (inv@606@04 r)))
        (< $Perm.No $k@605@04))
      (and
        (and
          (and (< (inv@454@04 r) V@15@04) (<= 0 (inv@454@04 r)))
          (< (inv@453@04 r) V@15@04))
        (<= 0 (inv@453@04 r))))
    (=
      ($FVF.lookup_int (as sm@611@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@611@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))))))) r))
  :qid |qp.fvfValDef478|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@606@04 r) V@15@04) (<= 0 (inv@606@04 r)))
        (< $Perm.No $k@605@04))
      (and (< (inv@457@04 r) V@15@04) (<= 0 (inv@457@04 r))))
    (=
      ($FVF.lookup_int (as sm@611@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04)))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@611@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04)))))))))))))) r))
  :qid |qp.fvfValDef479|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04)))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@611@04  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef480|)))
(assert (and
  (forall ((i1@604@04 Int)) (!
    (< i1@604@04 (alen<Int> (opt_get1 $Snap.unit P@14@04)))
    :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i1@604@04))
    :qid |int-aux|))
  (forall ((r $Ref)) (!
    (implies
      (and (< (inv@606@04 r) V@15@04) (<= 0 (inv@606@04 r)))
      ($FVF.loc_int ($FVF.lookup_int (as sm@607@04  $FVF<Int>) r) r))
    :pattern ((inv@606@04 r))
    ))
  (forall ((r $Ref)) (!
    (implies
      (not
        (=
          (-
            (-
              (ite
                (and
                  (and
                    (and (< (inv@366@04 r) V@15@04) (<= 0 (inv@366@04 r)))
                    (< (inv@365@04 r) V@15@04))
                  (<= 0 (inv@365@04 r)))
                $Perm.Write
                $Perm.No)
              (pTaken@481@04 r))
            (pTaken@485@04 r))
          $Perm.No))
      (<
        (ite
          (and (< (inv@606@04 r) V@15@04) (<= 0 (inv@606@04 r)))
          $k@605@04
          $Perm.No)
        (-
          (-
            (ite
              (and
                (and
                  (and (< (inv@366@04 r) V@15@04) (<= 0 (inv@366@04 r)))
                  (< (inv@365@04 r) V@15@04))
                (<= 0 (inv@365@04 r)))
              $Perm.Write
              $Perm.No)
            (pTaken@481@04 r))
          (pTaken@485@04 r))))
    :pattern ((inv@366@04 r))
    :pattern ((inv@365@04 r))
    :pattern ((inv@606@04 r))
    :qid |qp.srp474|))
  (forall ((r $Ref)) (!
    (implies
      (not
        (=
          (ite
            (and
              (and
                (and (< (inv@454@04 r) V@15@04) (<= 0 (inv@454@04 r)))
                (< (inv@453@04 r) V@15@04))
              (<= 0 (inv@453@04 r)))
            $Perm.Write
            $Perm.No)
          $Perm.No))
      (ite
        (and
          (and
            (and (< (inv@454@04 r) V@15@04) (<= 0 (inv@454@04 r)))
            (< (inv@453@04 r) V@15@04))
          (<= 0 (inv@453@04 r)))
        (<
          (ite
            (and (< (inv@606@04 r) V@15@04) (<= 0 (inv@606@04 r)))
            $k@605@04
            $Perm.No)
          $Perm.Write)
        (<
          (ite
            (and (< (inv@606@04 r) V@15@04) (<= 0 (inv@606@04 r)))
            $k@605@04
            $Perm.No)
          $Perm.No)))
    :pattern ((inv@454@04 r))
    :pattern ((inv@453@04 r))
    :pattern ((inv@606@04 r))
    :qid |qp.srp475|))
  (forall ((r $Ref)) (!
    (implies
      (not
        (=
          (ite
            (and (< (inv@457@04 r) V@15@04) (<= 0 (inv@457@04 r)))
            $Perm.Write
            $Perm.No)
          $Perm.No))
      (ite
        (and (< (inv@457@04 r) V@15@04) (<= 0 (inv@457@04 r)))
        (<
          (ite
            (and (< (inv@606@04 r) V@15@04) (<= 0 (inv@606@04 r)))
            $k@605@04
            $Perm.No)
          $Perm.Write)
        (<
          (ite
            (and (< (inv@606@04 r) V@15@04) (<= 0 (inv@606@04 r)))
            $k@605@04
            $Perm.No)
          $Perm.No)))
    :pattern ((inv@457@04 r))
    :pattern ((inv@606@04 r))
    :qid |qp.srp476|))))
(set-option :timeout 0)
(push) ; 16
(assert (not (valid_graph_vertices ($Snap.combine
  $Snap.unit
  ($Snap.combine
    $Snap.unit
    ($Snap.combine
      $Snap.unit
      ($SortWrappers.$FVF<Int>To$Snap (as sm@611@04  $FVF<Int>))))) this@9@04 P@14@04 V@15@04)))
(check-sat)
; unsat
(pop) ; 16
; 02m:22s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               32101462
;  :arith-add-rows          6480647
;  :arith-assert-diseq      213368
;  :arith-assert-lower      5732008
;  :arith-assert-upper      4973510
;  :arith-bound-prop        142216
;  :arith-conflicts         3616
;  :arith-eq-adapter        2107770
;  :arith-fixed-eqs         5330277
;  :arith-offset-eqs        3361592
;  :arith-pivots            935041
;  :conflicts               8348
;  :datatype-accessor-ax    2718
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1323491
;  :del-clause              81200156
;  :final-checks            5
;  :max-generation          15
;  :max-memory              541.79
;  :memory                  524.82
;  :minimized-lits          1319
;  :mk-bool-var             69046718
;  :mk-clause               81202402
;  :num-allocs              163441659
;  :num-checks              677
;  :propagations            24193367
;  :quant-instantiations    28437691
;  :restarts                18
;  :rlimit-count            643087095
;  :time                    142.08)
(assert (valid_graph_vertices ($Snap.combine
  $Snap.unit
  ($Snap.combine
    $Snap.unit
    ($Snap.combine
      $Snap.unit
      ($SortWrappers.$FVF<Int>To$Snap (as sm@611@04  $FVF<Int>))))) this@9@04 P@14@04 V@15@04))
(declare-const exc@612@04 $Ref)
(declare-const res@613@04 Bool)
(declare-const $t@614@04 $Snap)
(assert (= $t@614@04 ($Snap.combine ($Snap.first $t@614@04) ($Snap.second $t@614@04))))
(assert (= ($Snap.first $t@614@04) $Snap.unit))
; [eval] exc == null
(assert (= exc@612@04 $Ref.null))
(assert (=
  ($Snap.second $t@614@04)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@614@04))
    ($Snap.second ($Snap.second $t@614@04)))))
(assert (= ($Snap.first ($Snap.second $t@614@04)) $Snap.unit))
; [eval] exc == null ==> Gf != (None(): option[array])
; [eval] exc == null
(push) ; 16
(set-option :timeout 10)
(push) ; 17
(assert (not (not (= exc@612@04 $Ref.null))))
(check-sat)
; unknown
(pop) ; 17
; 0.26s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               32101501
;  :arith-add-rows          6480650
;  :arith-assert-diseq      213368
;  :arith-assert-lower      5732008
;  :arith-assert-upper      4973510
;  :arith-bound-prop        142216
;  :arith-conflicts         3616
;  :arith-eq-adapter        2107770
;  :arith-fixed-eqs         5330277
;  :arith-offset-eqs        3361592
;  :arith-pivots            935041
;  :conflicts               8348
;  :datatype-accessor-ax    2723
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1323491
;  :del-clause              81200156
;  :final-checks            5
;  :max-generation          15
;  :max-memory              541.79
;  :memory                  524.83
;  :minimized-lits          1319
;  :mk-bool-var             69046927
;  :mk-clause               81202571
;  :num-allocs              163442293
;  :num-checks              678
;  :propagations            24193378
;  :quant-instantiations    28437730
;  :restarts                18
;  :rlimit-count            643088686
;  :time                    0.26)
; [then-branch: 314 | exc@612@04 == Null | live]
; [else-branch: 314 | exc@612@04 != Null | dead]
(push) ; 17
; [then-branch: 314 | exc@612@04 == Null]
; [eval] Gf != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 17
(pop) ; 16
; Joined path conditions
(assert (implies
  (= exc@612@04 $Ref.null)
  (not (= G@11@04 (as None<option<array>>  option<array>)))))
(assert (=
  ($Snap.second ($Snap.second $t@614@04))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second $t@614@04)))
    ($Snap.second ($Snap.second ($Snap.second $t@614@04))))))
(assert (= ($Snap.first ($Snap.second ($Snap.second $t@614@04))) $Snap.unit))
; [eval] exc == null ==> alen(opt_get1(Gf)) == V
; [eval] exc == null
(push) ; 16
(push) ; 17
(assert (not (not (= exc@612@04 $Ref.null))))
(check-sat)
; unknown
(pop) ; 17
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               32101786
;  :arith-add-rows          6480800
;  :arith-assert-diseq      213376
;  :arith-assert-lower      5732083
;  :arith-assert-upper      4973564
;  :arith-bound-prop        142218
;  :arith-conflicts         3616
;  :arith-eq-adapter        2107823
;  :arith-fixed-eqs         5330342
;  :arith-offset-eqs        3361616
;  :arith-pivots            935051
;  :conflicts               8348
;  :datatype-accessor-ax    2724
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1323517
;  :del-clause              81201921
;  :final-checks            5
;  :max-generation          15
;  :max-memory              541.79
;  :memory                  524.83
;  :minimized-lits          1319
;  :mk-bool-var             69048548
;  :mk-clause               81204336
;  :num-allocs              163448812
;  :num-checks              679
;  :propagations            24193675
;  :quant-instantiations    28438348
;  :restarts                18
;  :rlimit-count            643118729
;  :time                    0.01)
; [then-branch: 315 | exc@612@04 == Null | live]
; [else-branch: 315 | exc@612@04 != Null | dead]
(push) ; 17
; [then-branch: 315 | exc@612@04 == Null]
; [eval] alen(opt_get1(Gf)) == V
; [eval] alen(opt_get1(Gf))
; [eval] opt_get1(Gf)
(push) ; 18
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 18
; Joined path conditions
(pop) ; 17
(pop) ; 16
; Joined path conditions
(assert (implies
  (= exc@612@04 $Ref.null)
  (= (alen<Int> (opt_get1 $Snap.unit G@11@04)) V@15@04)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second $t@614@04)))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@614@04))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@614@04)))))))
; [eval] exc == null
(push) ; 16
(assert (not (not (= exc@612@04 $Ref.null))))
(check-sat)
; unknown
(pop) ; 16
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               32102034
;  :arith-add-rows          6480931
;  :arith-assert-diseq      213384
;  :arith-assert-lower      5732138
;  :arith-assert-upper      4973603
;  :arith-bound-prop        142220
;  :arith-conflicts         3616
;  :arith-eq-adapter        2107869
;  :arith-fixed-eqs         5330385
;  :arith-offset-eqs        3361633
;  :arith-pivots            935061
;  :conflicts               8348
;  :datatype-accessor-ax    2725
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1323543
;  :del-clause              81203365
;  :final-checks            5
;  :max-generation          15
;  :max-memory              541.79
;  :memory                  518.83
;  :minimized-lits          1319
;  :mk-bool-var             69049887
;  :mk-clause               81205780
;  :num-allocs              163453314
;  :num-checks              680
;  :propagations            24193854
;  :quant-instantiations    28438812
;  :restarts                18
;  :rlimit-count            643139521
;  :time                    0.01)
; [then-branch: 316 | exc@612@04 == Null | live]
; [else-branch: 316 | exc@612@04 != Null | dead]
(push) ; 16
; [then-branch: 316 | exc@612@04 == Null]
(declare-const i1@615@04 Int)
(push) ; 17
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 18
; [then-branch: 317 | 0 <= i1@615@04 | live]
; [else-branch: 317 | !(0 <= i1@615@04) | live]
(push) ; 19
; [then-branch: 317 | 0 <= i1@615@04]
(assert (<= 0 i1@615@04))
; [eval] i1 < V
(pop) ; 19
(push) ; 19
; [else-branch: 317 | !(0 <= i1@615@04)]
(assert (not (<= 0 i1@615@04)))
(pop) ; 19
(pop) ; 18
; Joined path conditions
; Joined path conditions
(assert (and (< i1@615@04 V@15@04) (<= 0 i1@615@04)))
; [eval] aloc(opt_get1(Gf), i1)
; [eval] opt_get1(Gf)
(push) ; 18
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 18
; Joined path conditions
(push) ; 18
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 19
(assert (not (< i1@615@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))))
(check-sat)
; unsat
(pop) ; 19
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               32102041
;  :arith-add-rows          6480932
;  :arith-assert-diseq      213386
;  :arith-assert-lower      5732142
;  :arith-assert-upper      4973603
;  :arith-bound-prop        142222
;  :arith-conflicts         3616
;  :arith-eq-adapter        2107869
;  :arith-fixed-eqs         5330385
;  :arith-offset-eqs        3361639
;  :arith-pivots            935061
;  :conflicts               8348
;  :datatype-accessor-ax    2725
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1323543
;  :del-clause              81203365
;  :final-checks            5
;  :max-generation          15
;  :max-memory              541.79
;  :memory                  518.83
;  :minimized-lits          1319
;  :mk-bool-var             69049889
;  :mk-clause               81205782
;  :num-allocs              163453417
;  :num-checks              681
;  :propagations            24193856
;  :quant-instantiations    28438812
;  :restarts                18
;  :rlimit-count            643139728)
(assert (< i1@615@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(pop) ; 18
; Joined path conditions
(assert (< i1@615@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(declare-const $k@616@04 $Perm)
(assert ($Perm.isReadVar $k@616@04 $Perm.Write))
(pop) ; 17
(declare-fun inv@617@04 ($Ref) Int)
; Nested auxiliary terms: globals
(assert ($Perm.isReadVar $k@616@04 $Perm.Write))
; Nested auxiliary terms: non-globals
(assert (forall ((i1@615@04 Int)) (!
  (< i1@615@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@615@04))
  :qid |option$array$-aux|)))
(push) ; 17
(assert (not (forall ((i1@615@04 Int)) (!
  (implies
    (and (< i1@615@04 V@15@04) (<= 0 i1@615@04))
    (or (= $k@616@04 $Perm.No) (< $Perm.No $k@616@04)))
  
  ))))
(check-sat)
; unsat
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               32102041
;  :arith-add-rows          6480933
;  :arith-assert-diseq      213387
;  :arith-assert-lower      5732144
;  :arith-assert-upper      4973604
;  :arith-bound-prop        142222
;  :arith-conflicts         3616
;  :arith-eq-adapter        2107870
;  :arith-fixed-eqs         5330385
;  :arith-offset-eqs        3361639
;  :arith-pivots            935061
;  :conflicts               8349
;  :datatype-accessor-ax    2725
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1323543
;  :del-clause              81203367
;  :final-checks            5
;  :max-generation          15
;  :max-memory              541.79
;  :memory                  518.83
;  :minimized-lits          1319
;  :mk-bool-var             69049896
;  :mk-clause               81205784
;  :num-allocs              163453887
;  :num-checks              682
;  :propagations            24193857
;  :quant-instantiations    28438812
;  :restarts                18
;  :rlimit-count            643140300)
; Check receiver injectivity
(push) ; 17
(assert (not (forall ((i11@615@04 Int) (i12@615@04 Int)) (!
  (implies
    (and
      (and (and (< i11@615@04 V@15@04) (<= 0 i11@615@04)) (< $Perm.No $k@616@04))
      (and (and (< i12@615@04 V@15@04) (<= 0 i12@615@04)) (< $Perm.No $k@616@04))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i11@615@04)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i12@615@04)))
    (= i11@615@04 i12@615@04))
  
  :qid |option$array$-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               32102100
;  :arith-add-rows          6480939
;  :arith-assert-diseq      213388
;  :arith-assert-lower      5732148
;  :arith-assert-upper      4973604
;  :arith-bound-prop        142223
;  :arith-conflicts         3616
;  :arith-eq-adapter        2107871
;  :arith-fixed-eqs         5330385
;  :arith-offset-eqs        3361639
;  :arith-pivots            935063
;  :conflicts               8350
;  :datatype-accessor-ax    2725
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1323543
;  :del-clause              81203374
;  :final-checks            5
;  :max-generation          15
;  :max-memory              541.79
;  :memory                  515.83
;  :minimized-lits          1319
;  :mk-bool-var             69049980
;  :mk-clause               81205791
;  :num-allocs              163454911
;  :num-checks              683
;  :propagations            24193858
;  :quant-instantiations    28438918
;  :restarts                18
;  :rlimit-count            643143692
;  :time                    0.00)
; Definitional axioms for inverse functions
(assert (forall ((i1@615@04 Int)) (!
  (implies
    (and (and (< i1@615@04 V@15@04) (<= 0 i1@615@04)) (< $Perm.No $k@616@04))
    (=
      (inv@617@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@615@04))
      i1@615@04))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@615@04))
  )))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and (< (inv@617@04 r) V@15@04) (<= 0 (inv@617@04 r)))
      (< $Perm.No $k@616@04))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) (inv@617@04 r))
      r))
  :pattern ((inv@617@04 r))
  :qid |option$array$-fctOfInv|)))
; Permissions are non-negative
(assert (forall ((i1@615@04 Int)) (!
  (<= $Perm.No $k@616@04)
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@615@04))
  :qid |option$array$-permAtLeastZero|)))
; Field permissions are at most one
(assert (forall ((i1@615@04 Int)) (!
  (<= $k@616@04 $Perm.Write)
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@615@04))
  :qid |option$array$-permAtMostOne|)))
; Permission implies non-null receiver
(assert (forall ((i1@615@04 Int)) (!
  (implies
    (and (and (< i1@615@04 V@15@04) (<= 0 i1@615@04)) (< $Perm.No $k@616@04))
    (not
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@615@04)
        $Ref.null)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@615@04))
  :qid |option$array$-permImpliesNonNull|)))
(declare-const sm@618@04 $FVF<option<array>>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@617@04 r) V@15@04) (<= 0 (inv@617@04 r)))
      (< $Perm.No $k@616@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@618@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@614@04))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@618@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@614@04))))) r))
  :qid |qp.fvfValDef482|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@445@04 r) V@15@04) (<= 0 (inv@445@04 r)))
      (< $Perm.No $k@444@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@618@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@618@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))) r))
  :qid |qp.fvfValDef483|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@357@04 r) V@15@04) (<= 0 (inv@357@04 r)))
      (< $Perm.No $k@356@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@618@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@618@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))) r))
  :qid |qp.fvfValDef484|)))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (-
          (-
            (ite
              (and (< (inv@296@04 r) V@15@04) (<= 0 (inv@296@04 r)))
              $k@295@04
              $Perm.No)
            (pTaken@380@04 r))
          (pTaken@469@04 r))
        (pTaken@583@04 r)))
    (=
      ($FVF.lookup_option$array$ (as sm@618@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@618@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r))
  :qid |qp.fvfValDef485|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@614@04))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04))))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r) r))
  :pattern (($FVF.lookup_option$array$ (as sm@618@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef486|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@617@04 r) V@15@04) (<= 0 (inv@617@04 r)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@618@04  $FVF<option<array>>) r) r))
  :pattern ((inv@617@04 r))
  )))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@614@04))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@614@04)))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@614@04))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@614@04)))))
  $Snap.unit))
; [eval] exc == null ==> (forall i1: Int :: { aloc(opt_get1(Gf), i1) } 0 <= i1 && i1 < V ==> aloc(opt_get1(Gf), i1).option$array$ != (None(): option[array]))
; [eval] exc == null
(push) ; 17
(set-option :timeout 10)
(push) ; 18
(assert (not (not (= exc@612@04 $Ref.null))))
(check-sat)
; unknown
(pop) ; 18
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               32102353
;  :arith-add-rows          6481074
;  :arith-assert-diseq      213396
;  :arith-assert-lower      5732204
;  :arith-assert-upper      4973645
;  :arith-bound-prop        142226
;  :arith-conflicts         3616
;  :arith-eq-adapter        2107918
;  :arith-fixed-eqs         5330429
;  :arith-offset-eqs        3361656
;  :arith-pivots            935075
;  :conflicts               8350
;  :datatype-accessor-ax    2726
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1323569
;  :del-clause              81204829
;  :final-checks            5
;  :max-generation          15
;  :max-memory              541.79
;  :memory                  514.08
;  :minimized-lits          1319
;  :mk-bool-var             69051352
;  :mk-clause               81207246
;  :num-allocs              163461228
;  :num-checks              684
;  :propagations            24194037
;  :quant-instantiations    28439391
;  :restarts                18
;  :rlimit-count            643169732
;  :time                    0.01)
; [then-branch: 318 | exc@612@04 == Null | live]
; [else-branch: 318 | exc@612@04 != Null | dead]
(push) ; 18
; [then-branch: 318 | exc@612@04 == Null]
; [eval] (forall i1: Int :: { aloc(opt_get1(Gf), i1) } 0 <= i1 && i1 < V ==> aloc(opt_get1(Gf), i1).option$array$ != (None(): option[array]))
(declare-const i1@619@04 Int)
(push) ; 19
; [eval] 0 <= i1 && i1 < V ==> aloc(opt_get1(Gf), i1).option$array$ != (None(): option[array])
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 20
; [then-branch: 319 | 0 <= i1@619@04 | live]
; [else-branch: 319 | !(0 <= i1@619@04) | live]
(push) ; 21
; [then-branch: 319 | 0 <= i1@619@04]
(assert (<= 0 i1@619@04))
; [eval] i1 < V
(pop) ; 21
(push) ; 21
; [else-branch: 319 | !(0 <= i1@619@04)]
(assert (not (<= 0 i1@619@04)))
(pop) ; 21
(pop) ; 20
; Joined path conditions
; Joined path conditions
(push) ; 20
; [then-branch: 320 | i1@619@04 < V@15@04 && 0 <= i1@619@04 | live]
; [else-branch: 320 | !(i1@619@04 < V@15@04 && 0 <= i1@619@04) | live]
(push) ; 21
; [then-branch: 320 | i1@619@04 < V@15@04 && 0 <= i1@619@04]
(assert (and (< i1@619@04 V@15@04) (<= 0 i1@619@04)))
; [eval] aloc(opt_get1(Gf), i1).option$array$ != (None(): option[array])
; [eval] aloc(opt_get1(Gf), i1)
; [eval] opt_get1(Gf)
(push) ; 22
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 22
; Joined path conditions
(push) ; 22
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 23
(assert (not (< i1@619@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))))
(check-sat)
; unsat
(pop) ; 23
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               32102360
;  :arith-add-rows          6481075
;  :arith-assert-diseq      213398
;  :arith-assert-lower      5732208
;  :arith-assert-upper      4973645
;  :arith-bound-prop        142228
;  :arith-conflicts         3616
;  :arith-eq-adapter        2107918
;  :arith-fixed-eqs         5330429
;  :arith-offset-eqs        3361662
;  :arith-pivots            935075
;  :conflicts               8350
;  :datatype-accessor-ax    2726
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1323569
;  :del-clause              81204829
;  :final-checks            5
;  :max-generation          15
;  :max-memory              541.79
;  :memory                  514.08
;  :minimized-lits          1319
;  :mk-bool-var             69051354
;  :mk-clause               81207248
;  :num-allocs              163461332
;  :num-checks              685
;  :propagations            24194039
;  :quant-instantiations    28439391
;  :restarts                18
;  :rlimit-count            643169949)
(assert (< i1@619@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(pop) ; 22
; Joined path conditions
(assert (< i1@619@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@618@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@619@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@619@04)))
(push) ; 22
(assert (not (<
  $Perm.No
  (+
    (+
      (+
        (ite
          (and
            (<
              (inv@617@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@619@04))
              V@15@04)
            (<=
              0
              (inv@617@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@619@04))))
          $k@616@04
          $Perm.No)
        (ite
          (and
            (<
              (inv@445@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@619@04))
              V@15@04)
            (<=
              0
              (inv@445@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@619@04))))
          $k@444@04
          $Perm.No))
      (ite
        (and
          (<
            (inv@357@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@619@04))
            V@15@04)
          (<=
            0
            (inv@357@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@619@04))))
        $k@356@04
        $Perm.No))
    (-
      (-
        (-
          (ite
            (and
              (<
                (inv@296@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@619@04))
                V@15@04)
              (<=
                0
                (inv@296@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@619@04))))
            $k@295@04
            $Perm.No)
          (pTaken@380@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@619@04)))
        (pTaken@469@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@619@04)))
      (pTaken@583@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@619@04)))))))
(check-sat)
; unsat
(pop) ; 22
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               32102918
;  :arith-add-rows          6481393
;  :arith-assert-diseq      213417
;  :arith-assert-lower      5732345
;  :arith-assert-upper      4973701
;  :arith-bound-prop        142311
;  :arith-conflicts         3619
;  :arith-eq-adapter        2107989
;  :arith-fixed-eqs         5330480
;  :arith-offset-eqs        3361719
;  :arith-pivots            935159
;  :conflicts               8369
;  :datatype-accessor-ax    2726
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1323666
;  :del-clause              81206595
;  :final-checks            5
;  :max-generation          15
;  :max-memory              541.79
;  :memory                  513.15
;  :minimized-lits          1319
;  :mk-bool-var             69053519
;  :mk-clause               81209662
;  :num-allocs              163468515
;  :num-checks              686
;  :propagations            24194433
;  :quant-instantiations    28439913
;  :restarts                18
;  :rlimit-count            643204219
;  :time                    0.01)
; [eval] (None(): option[array])
(pop) ; 21
(push) ; 21
; [else-branch: 320 | !(i1@619@04 < V@15@04 && 0 <= i1@619@04)]
(assert (not (and (< i1@619@04 V@15@04) (<= 0 i1@619@04))))
(pop) ; 21
(pop) ; 20
; Joined path conditions
(assert (implies
  (and (< i1@619@04 V@15@04) (<= 0 i1@619@04))
  (and
    (< i1@619@04 V@15@04)
    (<= 0 i1@619@04)
    (< i1@619@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@618@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@619@04)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@619@04)))))
; Joined path conditions
(pop) ; 19
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@619@04 Int)) (!
  (implies
    (and (< i1@619@04 V@15@04) (<= 0 i1@619@04))
    (and
      (< i1@619@04 V@15@04)
      (<= 0 i1@619@04)
      (< i1@619@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@618@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@619@04)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@619@04))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@619@04))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 18
(pop) ; 17
; Joined path conditions
(assert (implies
  (= exc@612@04 $Ref.null)
  (forall ((i1@619@04 Int)) (!
    (implies
      (and (< i1@619@04 V@15@04) (<= 0 i1@619@04))
      (and
        (< i1@619@04 V@15@04)
        (<= 0 i1@619@04)
        (< i1@619@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@618@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@619@04)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@619@04))))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@619@04))
    :qid |prog.l<no position>-aux|))))
(assert (implies
  (= exc@612@04 $Ref.null)
  (forall ((i1@619@04 Int)) (!
    (implies
      (and (< i1@619@04 V@15@04) (<= 0 i1@619@04))
      (not
        (=
          ($FVF.lookup_option$array$ (as sm@618@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@619@04))
          (as None<option<array>>  option<array>))))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@619@04))
    :qid |prog.l<no position>|))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@614@04)))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@614@04))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@614@04)))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@614@04))))))
  $Snap.unit))
; [eval] exc == null ==> (forall i1: Int :: { alen(opt_get1(aloc(opt_get1(Gf), i1).option$array$)) } 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(Gf), i1).option$array$)) == V)
; [eval] exc == null
(push) ; 17
(set-option :timeout 10)
(push) ; 18
(assert (not (not (= exc@612@04 $Ref.null))))
(check-sat)
; unknown
(pop) ; 18
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               32103218
;  :arith-add-rows          6481570
;  :arith-assert-diseq      213425
;  :arith-assert-lower      5732421
;  :arith-assert-upper      4973756
;  :arith-bound-prop        142314
;  :arith-conflicts         3619
;  :arith-eq-adapter        2108044
;  :arith-fixed-eqs         5330546
;  :arith-offset-eqs        3361743
;  :arith-pivots            935202
;  :conflicts               8369
;  :datatype-accessor-ax    2727
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1323692
;  :del-clause              81209135
;  :final-checks            5
;  :max-generation          15
;  :max-memory              541.79
;  :memory                  512.72
;  :minimized-lits          1319
;  :mk-bool-var             69055410
;  :mk-clause               81211552
;  :num-allocs              163475487
;  :num-checks              687
;  :propagations            24194735
;  :quant-instantiations    28440613
;  :restarts                18
;  :rlimit-count            643237756
;  :time                    0.01)
; [then-branch: 321 | exc@612@04 == Null | live]
; [else-branch: 321 | exc@612@04 != Null | dead]
(push) ; 18
; [then-branch: 321 | exc@612@04 == Null]
; [eval] (forall i1: Int :: { alen(opt_get1(aloc(opt_get1(Gf), i1).option$array$)) } 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(Gf), i1).option$array$)) == V)
(declare-const i1@620@04 Int)
(push) ; 19
; [eval] 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(Gf), i1).option$array$)) == V
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 20
; [then-branch: 322 | 0 <= i1@620@04 | live]
; [else-branch: 322 | !(0 <= i1@620@04) | live]
(push) ; 21
; [then-branch: 322 | 0 <= i1@620@04]
(assert (<= 0 i1@620@04))
; [eval] i1 < V
(pop) ; 21
(push) ; 21
; [else-branch: 322 | !(0 <= i1@620@04)]
(assert (not (<= 0 i1@620@04)))
(pop) ; 21
(pop) ; 20
; Joined path conditions
; Joined path conditions
(push) ; 20
; [then-branch: 323 | i1@620@04 < V@15@04 && 0 <= i1@620@04 | live]
; [else-branch: 323 | !(i1@620@04 < V@15@04 && 0 <= i1@620@04) | live]
(push) ; 21
; [then-branch: 323 | i1@620@04 < V@15@04 && 0 <= i1@620@04]
(assert (and (< i1@620@04 V@15@04) (<= 0 i1@620@04)))
; [eval] alen(opt_get1(aloc(opt_get1(Gf), i1).option$array$)) == V
; [eval] alen(opt_get1(aloc(opt_get1(Gf), i1).option$array$))
; [eval] opt_get1(aloc(opt_get1(Gf), i1).option$array$)
; [eval] aloc(opt_get1(Gf), i1)
; [eval] opt_get1(Gf)
(push) ; 22
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 22
; Joined path conditions
(push) ; 22
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 23
(assert (not (< i1@620@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))))
(check-sat)
; unsat
(pop) ; 23
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               32103225
;  :arith-add-rows          6481571
;  :arith-assert-diseq      213427
;  :arith-assert-lower      5732425
;  :arith-assert-upper      4973756
;  :arith-bound-prop        142316
;  :arith-conflicts         3619
;  :arith-eq-adapter        2108044
;  :arith-fixed-eqs         5330546
;  :arith-offset-eqs        3361749
;  :arith-pivots            935203
;  :conflicts               8369
;  :datatype-accessor-ax    2727
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1323692
;  :del-clause              81209135
;  :final-checks            5
;  :max-generation          15
;  :max-memory              541.79
;  :memory                  512.72
;  :minimized-lits          1319
;  :mk-bool-var             69055412
;  :mk-clause               81211554
;  :num-allocs              163475590
;  :num-checks              688
;  :propagations            24194737
;  :quant-instantiations    28440613
;  :restarts                18
;  :rlimit-count            643237979)
(assert (< i1@620@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(pop) ; 22
; Joined path conditions
(assert (< i1@620@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@618@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@620@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@620@04)))
(push) ; 22
(assert (not (<
  $Perm.No
  (+
    (+
      (+
        (ite
          (and
            (<
              (inv@617@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@620@04))
              V@15@04)
            (<=
              0
              (inv@617@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@620@04))))
          $k@616@04
          $Perm.No)
        (ite
          (and
            (<
              (inv@445@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@620@04))
              V@15@04)
            (<=
              0
              (inv@445@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@620@04))))
          $k@444@04
          $Perm.No))
      (ite
        (and
          (<
            (inv@357@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@620@04))
            V@15@04)
          (<=
            0
            (inv@357@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@620@04))))
        $k@356@04
        $Perm.No))
    (-
      (-
        (-
          (ite
            (and
              (<
                (inv@296@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@620@04))
                V@15@04)
              (<=
                0
                (inv@296@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@620@04))))
            $k@295@04
            $Perm.No)
          (pTaken@380@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@620@04)))
        (pTaken@469@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@620@04)))
      (pTaken@583@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@620@04)))))))
(check-sat)
; unsat
(pop) ; 22
; 0.05s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               32104411
;  :arith-add-rows          6483038
;  :arith-assert-diseq      213450
;  :arith-assert-lower      5732606
;  :arith-assert-upper      4973875
;  :arith-bound-prop        142389
;  :arith-conflicts         3623
;  :arith-eq-adapter        2108166
;  :arith-fixed-eqs         5330666
;  :arith-offset-eqs        3361814
;  :arith-pivots            935302
;  :conflicts               8389
;  :datatype-accessor-ax    2731
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1324082
;  :del-clause              81221127
;  :final-checks            5
;  :max-generation          15
;  :max-memory              541.79
;  :memory                  512.59
;  :minimized-lits          1319
;  :mk-bool-var             69064894
;  :mk-clause               81224194
;  :num-allocs              163504664
;  :num-checks              689
;  :propagations            24196323
;  :quant-instantiations    28442748
;  :restarts                18
;  :rlimit-count            643363403
;  :time                    0.05)
(push) ; 22
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 23
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@618@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@620@04))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 23
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               32104411
;  :arith-add-rows          6483038
;  :arith-assert-diseq      213450
;  :arith-assert-lower      5732606
;  :arith-assert-upper      4973875
;  :arith-bound-prop        142389
;  :arith-conflicts         3623
;  :arith-eq-adapter        2108166
;  :arith-fixed-eqs         5330666
;  :arith-offset-eqs        3361814
;  :arith-pivots            935302
;  :conflicts               8390
;  :datatype-accessor-ax    2731
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1324082
;  :del-clause              81221127
;  :final-checks            5
;  :max-generation          15
;  :max-memory              541.79
;  :memory                  512.59
;  :minimized-lits          1319
;  :mk-bool-var             69064894
;  :mk-clause               81224194
;  :num-allocs              163504754
;  :num-checks              690
;  :propagations            24196323
;  :quant-instantiations    28442748
;  :restarts                18
;  :rlimit-count            643363498)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@618@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@620@04))
    (as None<option<array>>  option<array>))))
(pop) ; 22
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@618@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@620@04))
    (as None<option<array>>  option<array>))))
(pop) ; 21
(push) ; 21
; [else-branch: 323 | !(i1@620@04 < V@15@04 && 0 <= i1@620@04)]
(assert (not (and (< i1@620@04 V@15@04) (<= 0 i1@620@04))))
(pop) ; 21
(pop) ; 20
; Joined path conditions
(assert (implies
  (and (< i1@620@04 V@15@04) (<= 0 i1@620@04))
  (and
    (< i1@620@04 V@15@04)
    (<= 0 i1@620@04)
    (< i1@620@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@618@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@620@04)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@620@04))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@618@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@620@04))
        (as None<option<array>>  option<array>))))))
; Joined path conditions
(pop) ; 19
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@620@04 Int)) (!
  (implies
    (and (< i1@620@04 V@15@04) (<= 0 i1@620@04))
    (and
      (< i1@620@04 V@15@04)
      (<= 0 i1@620@04)
      (< i1@620@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@618@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@620@04)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@620@04))
      (not
        (=
          ($FVF.lookup_option$array$ (as sm@618@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@620@04))
          (as None<option<array>>  option<array>)))))
  :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@618@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@620@04)))))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 18
(pop) ; 17
; Joined path conditions
(assert (implies
  (= exc@612@04 $Ref.null)
  (forall ((i1@620@04 Int)) (!
    (implies
      (and (< i1@620@04 V@15@04) (<= 0 i1@620@04))
      (and
        (< i1@620@04 V@15@04)
        (<= 0 i1@620@04)
        (< i1@620@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@618@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@620@04)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@620@04))
        (not
          (=
            ($FVF.lookup_option$array$ (as sm@618@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@620@04))
            (as None<option<array>>  option<array>)))))
    :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@618@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@620@04)))))
    :qid |prog.l<no position>-aux|))))
(assert (implies
  (= exc@612@04 $Ref.null)
  (forall ((i1@620@04 Int)) (!
    (implies
      (and (< i1@620@04 V@15@04) (<= 0 i1@620@04))
      (=
        (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@618@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@620@04))))
        V@15@04))
    :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@618@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@620@04)))))
    :qid |prog.l<no position>|))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@614@04))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@614@04)))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@614@04))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@614@04)))))))
  $Snap.unit))
; [eval] exc == null ==> (forall i1: Int :: { aloc(opt_get1(Gf), i1) } (forall i2: Int :: { aloc(opt_get1(Gf), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(Gf), i1).option$array$ == aloc(opt_get1(Gf), i2).option$array$ ==> i1 == i2))
; [eval] exc == null
(push) ; 17
(set-option :timeout 10)
(push) ; 18
(assert (not (not (= exc@612@04 $Ref.null))))
(check-sat)
; unknown
(pop) ; 18
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               32104675
;  :arith-add-rows          6483257
;  :arith-assert-diseq      213458
;  :arith-assert-lower      5732662
;  :arith-assert-upper      4973915
;  :arith-bound-prop        142392
;  :arith-conflicts         3623
;  :arith-eq-adapter        2108213
;  :arith-fixed-eqs         5330710
;  :arith-offset-eqs        3361831
;  :arith-pivots            935347
;  :conflicts               8390
;  :datatype-accessor-ax    2732
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1324108
;  :del-clause              81223329
;  :final-checks            5
;  :max-generation          15
;  :max-memory              541.79
;  :memory                  512.44
;  :minimized-lits          1319
;  :mk-bool-var             69066390
;  :mk-clause               81225746
;  :num-allocs              163510047
;  :num-checks              691
;  :propagations            24196504
;  :quant-instantiations    28443263
;  :restarts                18
;  :rlimit-count            643388892
;  :time                    0.01)
; [then-branch: 324 | exc@612@04 == Null | live]
; [else-branch: 324 | exc@612@04 != Null | dead]
(push) ; 18
; [then-branch: 324 | exc@612@04 == Null]
; [eval] (forall i1: Int :: { aloc(opt_get1(Gf), i1) } (forall i2: Int :: { aloc(opt_get1(Gf), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(Gf), i1).option$array$ == aloc(opt_get1(Gf), i2).option$array$ ==> i1 == i2))
(declare-const i1@621@04 Int)
(push) ; 19
; [eval] (forall i2: Int :: { aloc(opt_get1(Gf), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(Gf), i1).option$array$ == aloc(opt_get1(Gf), i2).option$array$ ==> i1 == i2)
(declare-const i2@622@04 Int)
(push) ; 20
; [eval] 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(Gf), i1).option$array$ == aloc(opt_get1(Gf), i2).option$array$ ==> i1 == i2
; [eval] 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(Gf), i1).option$array$ == aloc(opt_get1(Gf), i2).option$array$
; [eval] 0 <= i1
(push) ; 21
; [then-branch: 325 | 0 <= i1@621@04 | live]
; [else-branch: 325 | !(0 <= i1@621@04) | live]
(push) ; 22
; [then-branch: 325 | 0 <= i1@621@04]
(assert (<= 0 i1@621@04))
; [eval] i1 < V
(push) ; 23
; [then-branch: 326 | i1@621@04 < V@15@04 | live]
; [else-branch: 326 | !(i1@621@04 < V@15@04) | live]
(push) ; 24
; [then-branch: 326 | i1@621@04 < V@15@04]
(assert (< i1@621@04 V@15@04))
; [eval] 0 <= i2
(push) ; 25
; [then-branch: 327 | 0 <= i2@622@04 | live]
; [else-branch: 327 | !(0 <= i2@622@04) | live]
(push) ; 26
; [then-branch: 327 | 0 <= i2@622@04]
(assert (<= 0 i2@622@04))
; [eval] i2 < V
(push) ; 27
; [then-branch: 328 | i2@622@04 < V@15@04 | live]
; [else-branch: 328 | !(i2@622@04 < V@15@04) | live]
(push) ; 28
; [then-branch: 328 | i2@622@04 < V@15@04]
(assert (< i2@622@04 V@15@04))
; [eval] aloc(opt_get1(Gf), i1).option$array$ == aloc(opt_get1(Gf), i2).option$array$
; [eval] aloc(opt_get1(Gf), i1)
; [eval] opt_get1(Gf)
(push) ; 29
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 29
; Joined path conditions
(push) ; 29
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 30
(assert (not (< i1@621@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))))
(check-sat)
; unsat
(pop) ; 30
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               32104682
;  :arith-add-rows          6483259
;  :arith-assert-diseq      213460
;  :arith-assert-lower      5732668
;  :arith-assert-upper      4973915
;  :arith-bound-prop        142394
;  :arith-conflicts         3623
;  :arith-eq-adapter        2108213
;  :arith-fixed-eqs         5330710
;  :arith-offset-eqs        3361837
;  :arith-pivots            935348
;  :conflicts               8390
;  :datatype-accessor-ax    2732
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1324108
;  :del-clause              81223329
;  :final-checks            5
;  :max-generation          15
;  :max-memory              541.79
;  :memory                  512.44
;  :minimized-lits          1319
;  :mk-bool-var             69066394
;  :mk-clause               81225748
;  :num-allocs              163510328
;  :num-checks              692
;  :propagations            24196506
;  :quant-instantiations    28443263
;  :restarts                18
;  :rlimit-count            643389261)
(assert (< i1@621@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(pop) ; 29
; Joined path conditions
(assert (< i1@621@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@618@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@621@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@621@04)))
(push) ; 29
(assert (not (<
  $Perm.No
  (+
    (+
      (+
        (ite
          (and
            (<
              (inv@617@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@621@04))
              V@15@04)
            (<=
              0
              (inv@617@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@621@04))))
          $k@616@04
          $Perm.No)
        (ite
          (and
            (<
              (inv@445@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@621@04))
              V@15@04)
            (<=
              0
              (inv@445@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@621@04))))
          $k@444@04
          $Perm.No))
      (ite
        (and
          (<
            (inv@357@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@621@04))
            V@15@04)
          (<=
            0
            (inv@357@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@621@04))))
        $k@356@04
        $Perm.No))
    (-
      (-
        (-
          (ite
            (and
              (<
                (inv@296@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@621@04))
                V@15@04)
              (<=
                0
                (inv@296@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@621@04))))
            $k@295@04
            $Perm.No)
          (pTaken@380@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@621@04)))
        (pTaken@469@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@621@04)))
      (pTaken@583@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@621@04)))))))
(check-sat)
; unsat
(pop) ; 29
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               32105300
;  :arith-add-rows          6483596
;  :arith-assert-diseq      213492
;  :arith-assert-lower      5732834
;  :arith-assert-upper      4973989
;  :arith-bound-prop        142474
;  :arith-conflicts         3627
;  :arith-eq-adapter        2108301
;  :arith-fixed-eqs         5330769
;  :arith-offset-eqs        3361899
;  :arith-pivots            935433
;  :conflicts               8399
;  :datatype-accessor-ax    2732
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1324210
;  :del-clause              81225144
;  :final-checks            5
;  :max-generation          15
;  :max-memory              541.79
;  :memory                  512.45
;  :minimized-lits          1319
;  :mk-bool-var             69068697
;  :mk-clause               81228211
;  :num-allocs              163517832
;  :num-checks              693
;  :propagations            24196937
;  :quant-instantiations    28443788
;  :restarts                18
;  :rlimit-count            643422850
;  :time                    0.01)
; [eval] aloc(opt_get1(Gf), i2)
; [eval] opt_get1(Gf)
(push) ; 29
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 29
; Joined path conditions
(push) ; 29
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 30
(assert (not (< i2@622@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))))
(check-sat)
; unsat
(pop) ; 30
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               32105300
;  :arith-add-rows          6483596
;  :arith-assert-diseq      213492
;  :arith-assert-lower      5732834
;  :arith-assert-upper      4973989
;  :arith-bound-prop        142474
;  :arith-conflicts         3627
;  :arith-eq-adapter        2108301
;  :arith-fixed-eqs         5330769
;  :arith-offset-eqs        3361899
;  :arith-pivots            935433
;  :conflicts               8399
;  :datatype-accessor-ax    2732
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1324210
;  :del-clause              81225144
;  :final-checks            5
;  :max-generation          15
;  :max-memory              541.79
;  :memory                  512.45
;  :minimized-lits          1319
;  :mk-bool-var             69068697
;  :mk-clause               81228211
;  :num-allocs              163517858
;  :num-checks              694
;  :propagations            24196937
;  :quant-instantiations    28443788
;  :restarts                18
;  :rlimit-count            643422880)
(assert (< i2@622@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(pop) ; 29
; Joined path conditions
(assert (< i2@622@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@618@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@622@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@622@04)))
(push) ; 29
(assert (not (<
  $Perm.No
  (+
    (+
      (+
        (ite
          (and
            (<
              (inv@617@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@622@04))
              V@15@04)
            (<=
              0
              (inv@617@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@622@04))))
          $k@616@04
          $Perm.No)
        (ite
          (and
            (<
              (inv@445@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@622@04))
              V@15@04)
            (<=
              0
              (inv@445@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@622@04))))
          $k@444@04
          $Perm.No))
      (ite
        (and
          (<
            (inv@357@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@622@04))
            V@15@04)
          (<=
            0
            (inv@357@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@622@04))))
        $k@356@04
        $Perm.No))
    (-
      (-
        (-
          (ite
            (and
              (<
                (inv@296@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@622@04))
                V@15@04)
              (<=
                0
                (inv@296@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@622@04))))
            $k@295@04
            $Perm.No)
          (pTaken@380@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@622@04)))
        (pTaken@469@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@622@04)))
      (pTaken@583@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@622@04)))))))
(check-sat)
; unsat
(pop) ; 29
; 0.08s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               32107443
;  :arith-add-rows          6485784
;  :arith-assert-diseq      213564
;  :arith-assert-lower      5733199
;  :arith-assert-upper      4974189
;  :arith-bound-prop        142590
;  :arith-conflicts         3639
;  :arith-eq-adapter        2108503
;  :arith-fixed-eqs         5330928
;  :arith-offset-eqs        3362013
;  :arith-pivots            935561
;  :conflicts               8428
;  :datatype-accessor-ax    2736
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1325240
;  :del-clause              81248799
;  :final-checks            5
;  :max-generation          15
;  :max-memory              541.79
;  :memory                  512.55
;  :minimized-lits          1320
;  :mk-bool-var             69085578
;  :mk-clause               81252300
;  :num-allocs              163554336
;  :num-checks              695
;  :propagations            24200587
;  :quant-instantiations    28447236
;  :restarts                18
;  :rlimit-count            643600535
;  :time                    0.08)
(pop) ; 28
(push) ; 28
; [else-branch: 328 | !(i2@622@04 < V@15@04)]
(assert (not (< i2@622@04 V@15@04)))
(pop) ; 28
(pop) ; 27
; Joined path conditions
(assert (implies
  (< i2@622@04 V@15@04)
  (and
    (< i2@622@04 V@15@04)
    (< i1@621@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@618@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@621@04)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@621@04))
    (< i2@622@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@618@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@622@04)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@622@04)))))
; Joined path conditions
(pop) ; 26
(push) ; 26
; [else-branch: 327 | !(0 <= i2@622@04)]
(assert (not (<= 0 i2@622@04)))
(pop) ; 26
(pop) ; 25
; Joined path conditions
(assert (implies
  (<= 0 i2@622@04)
  (and
    (<= 0 i2@622@04)
    (implies
      (< i2@622@04 V@15@04)
      (and
        (< i2@622@04 V@15@04)
        (< i1@621@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@618@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@621@04)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@621@04))
        (< i2@622@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@618@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@622@04)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@622@04)))))))
; Joined path conditions
(pop) ; 24
(push) ; 24
; [else-branch: 326 | !(i1@621@04 < V@15@04)]
(assert (not (< i1@621@04 V@15@04)))
(pop) ; 24
(pop) ; 23
; Joined path conditions
(assert (implies
  (< i1@621@04 V@15@04)
  (and
    (< i1@621@04 V@15@04)
    (implies
      (<= 0 i2@622@04)
      (and
        (<= 0 i2@622@04)
        (implies
          (< i2@622@04 V@15@04)
          (and
            (< i2@622@04 V@15@04)
            (< i1@621@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@618@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@621@04)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@621@04))
            (< i2@622@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@618@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@622@04)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@622@04)))))))))
; Joined path conditions
(pop) ; 22
(push) ; 22
; [else-branch: 325 | !(0 <= i1@621@04)]
(assert (not (<= 0 i1@621@04)))
(pop) ; 22
(pop) ; 21
; Joined path conditions
(assert (implies
  (<= 0 i1@621@04)
  (and
    (<= 0 i1@621@04)
    (implies
      (< i1@621@04 V@15@04)
      (and
        (< i1@621@04 V@15@04)
        (implies
          (<= 0 i2@622@04)
          (and
            (<= 0 i2@622@04)
            (implies
              (< i2@622@04 V@15@04)
              (and
                (< i2@622@04 V@15@04)
                (< i1@621@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@618@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@621@04)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@621@04))
                (< i2@622@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@618@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@622@04)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@622@04)))))))))))
; Joined path conditions
(push) ; 21
; [then-branch: 329 | Lookup(option$array$,sm@618@04,aloc((_, _), opt_get1(_, G@11@04), i1@621@04)) == Lookup(option$array$,sm@618@04,aloc((_, _), opt_get1(_, G@11@04), i2@622@04)) && i2@622@04 < V@15@04 && 0 <= i2@622@04 && i1@621@04 < V@15@04 && 0 <= i1@621@04 | live]
; [else-branch: 329 | !(Lookup(option$array$,sm@618@04,aloc((_, _), opt_get1(_, G@11@04), i1@621@04)) == Lookup(option$array$,sm@618@04,aloc((_, _), opt_get1(_, G@11@04), i2@622@04)) && i2@622@04 < V@15@04 && 0 <= i2@622@04 && i1@621@04 < V@15@04 && 0 <= i1@621@04) | live]
(push) ; 22
; [then-branch: 329 | Lookup(option$array$,sm@618@04,aloc((_, _), opt_get1(_, G@11@04), i1@621@04)) == Lookup(option$array$,sm@618@04,aloc((_, _), opt_get1(_, G@11@04), i2@622@04)) && i2@622@04 < V@15@04 && 0 <= i2@622@04 && i1@621@04 < V@15@04 && 0 <= i1@621@04]
(assert (and
  (and
    (and
      (and
        (=
          ($FVF.lookup_option$array$ (as sm@618@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@621@04))
          ($FVF.lookup_option$array$ (as sm@618@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@622@04)))
        (< i2@622@04 V@15@04))
      (<= 0 i2@622@04))
    (< i1@621@04 V@15@04))
  (<= 0 i1@621@04)))
; [eval] i1 == i2
(pop) ; 22
(push) ; 22
; [else-branch: 329 | !(Lookup(option$array$,sm@618@04,aloc((_, _), opt_get1(_, G@11@04), i1@621@04)) == Lookup(option$array$,sm@618@04,aloc((_, _), opt_get1(_, G@11@04), i2@622@04)) && i2@622@04 < V@15@04 && 0 <= i2@622@04 && i1@621@04 < V@15@04 && 0 <= i1@621@04)]
(assert (not
  (and
    (and
      (and
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@618@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@621@04))
            ($FVF.lookup_option$array$ (as sm@618@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@622@04)))
          (< i2@622@04 V@15@04))
        (<= 0 i2@622@04))
      (< i1@621@04 V@15@04))
    (<= 0 i1@621@04))))
(pop) ; 22
(pop) ; 21
; Joined path conditions
(assert (implies
  (and
    (and
      (and
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@618@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@621@04))
            ($FVF.lookup_option$array$ (as sm@618@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@622@04)))
          (< i2@622@04 V@15@04))
        (<= 0 i2@622@04))
      (< i1@621@04 V@15@04))
    (<= 0 i1@621@04))
  (and
    (=
      ($FVF.lookup_option$array$ (as sm@618@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@621@04))
      ($FVF.lookup_option$array$ (as sm@618@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@622@04)))
    (< i2@622@04 V@15@04)
    (<= 0 i2@622@04)
    (< i1@621@04 V@15@04)
    (<= 0 i1@621@04))))
; Joined path conditions
(pop) ; 20
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i2@622@04 Int)) (!
  (and
    (implies
      (<= 0 i1@621@04)
      (and
        (<= 0 i1@621@04)
        (implies
          (< i1@621@04 V@15@04)
          (and
            (< i1@621@04 V@15@04)
            (implies
              (<= 0 i2@622@04)
              (and
                (<= 0 i2@622@04)
                (implies
                  (< i2@622@04 V@15@04)
                  (and
                    (< i2@622@04 V@15@04)
                    (< i1@621@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
                    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@618@04  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@621@04)) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@621@04))
                    (< i2@622@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
                    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@618@04  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@622@04)) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@622@04))))))))))
    (implies
      (and
        (and
          (and
            (and
              (=
                ($FVF.lookup_option$array$ (as sm@618@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@621@04))
                ($FVF.lookup_option$array$ (as sm@618@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@622@04)))
              (< i2@622@04 V@15@04))
            (<= 0 i2@622@04))
          (< i1@621@04 V@15@04))
        (<= 0 i1@621@04))
      (and
        (=
          ($FVF.lookup_option$array$ (as sm@618@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@621@04))
          ($FVF.lookup_option$array$ (as sm@618@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@622@04)))
        (< i2@622@04 V@15@04)
        (<= 0 i2@622@04)
        (< i1@621@04 V@15@04)
        (<= 0 i1@621@04))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@622@04))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 19
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@621@04 Int)) (!
  (forall ((i2@622@04 Int)) (!
    (and
      (implies
        (<= 0 i1@621@04)
        (and
          (<= 0 i1@621@04)
          (implies
            (< i1@621@04 V@15@04)
            (and
              (< i1@621@04 V@15@04)
              (implies
                (<= 0 i2@622@04)
                (and
                  (<= 0 i2@622@04)
                  (implies
                    (< i2@622@04 V@15@04)
                    (and
                      (< i2@622@04 V@15@04)
                      (< i1@621@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
                      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@618@04  $FVF<option<array>>) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@621@04)) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@621@04))
                      (< i2@622@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
                      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@618@04  $FVF<option<array>>) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@622@04)) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@622@04))))))))))
      (implies
        (and
          (and
            (and
              (and
                (=
                  ($FVF.lookup_option$array$ (as sm@618@04  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@621@04))
                  ($FVF.lookup_option$array$ (as sm@618@04  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@622@04)))
                (< i2@622@04 V@15@04))
              (<= 0 i2@622@04))
            (< i1@621@04 V@15@04))
          (<= 0 i1@621@04))
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@618@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@621@04))
            ($FVF.lookup_option$array$ (as sm@618@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@622@04)))
          (< i2@622@04 V@15@04)
          (<= 0 i2@622@04)
          (< i1@621@04 V@15@04)
          (<= 0 i1@621@04))))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@622@04))
    :qid |prog.l<no position>-aux|))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@621@04))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 18
(pop) ; 17
; Joined path conditions
(assert (implies
  (= exc@612@04 $Ref.null)
  (forall ((i1@621@04 Int)) (!
    (forall ((i2@622@04 Int)) (!
      (and
        (implies
          (<= 0 i1@621@04)
          (and
            (<= 0 i1@621@04)
            (implies
              (< i1@621@04 V@15@04)
              (and
                (< i1@621@04 V@15@04)
                (implies
                  (<= 0 i2@622@04)
                  (and
                    (<= 0 i2@622@04)
                    (implies
                      (< i2@622@04 V@15@04)
                      (and
                        (< i2@622@04 V@15@04)
                        (< i1@621@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
                        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@618@04  $FVF<option<array>>) (aloc ($Snap.combine
                          $Snap.unit
                          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@621@04)) (aloc ($Snap.combine
                          $Snap.unit
                          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@621@04))
                        (< i2@622@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
                        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@618@04  $FVF<option<array>>) (aloc ($Snap.combine
                          $Snap.unit
                          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@622@04)) (aloc ($Snap.combine
                          $Snap.unit
                          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@622@04))))))))))
        (implies
          (and
            (and
              (and
                (and
                  (=
                    ($FVF.lookup_option$array$ (as sm@618@04  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@621@04))
                    ($FVF.lookup_option$array$ (as sm@618@04  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@622@04)))
                  (< i2@622@04 V@15@04))
                (<= 0 i2@622@04))
              (< i1@621@04 V@15@04))
            (<= 0 i1@621@04))
          (and
            (=
              ($FVF.lookup_option$array$ (as sm@618@04  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@621@04))
              ($FVF.lookup_option$array$ (as sm@618@04  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@622@04)))
            (< i2@622@04 V@15@04)
            (<= 0 i2@622@04)
            (< i1@621@04 V@15@04)
            (<= 0 i1@621@04))))
      :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@622@04))
      :qid |prog.l<no position>-aux|))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@621@04))
    :qid |prog.l<no position>-aux|))))
(assert (implies
  (= exc@612@04 $Ref.null)
  (forall ((i1@621@04 Int)) (!
    (forall ((i2@622@04 Int)) (!
      (implies
        (and
          (and
            (and
              (and
                (=
                  ($FVF.lookup_option$array$ (as sm@618@04  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@621@04))
                  ($FVF.lookup_option$array$ (as sm@618@04  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@622@04)))
                (< i2@622@04 V@15@04))
              (<= 0 i2@622@04))
            (< i1@621@04 V@15@04))
          (<= 0 i1@621@04))
        (= i1@621@04 i2@622@04))
      :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@622@04))
      :qid |prog.l<no position>|))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@621@04))
    :qid |prog.l<no position>|))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@614@04)))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@614@04))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@614@04)))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@614@04))))))))
  $Snap.unit))
; [eval] exc == null ==> p != (None(): option[array])
; [eval] exc == null
(push) ; 17
(set-option :timeout 10)
(push) ; 18
(assert (not (not (= exc@612@04 $Ref.null))))
(check-sat)
; unknown
(pop) ; 18
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               32107707
;  :arith-add-rows          6485960
;  :arith-assert-diseq      213572
;  :arith-assert-lower      5733255
;  :arith-assert-upper      4974229
;  :arith-bound-prop        142593
;  :arith-conflicts         3639
;  :arith-eq-adapter        2108549
;  :arith-fixed-eqs         5330972
;  :arith-offset-eqs        3362030
;  :arith-pivots            935636
;  :conflicts               8428
;  :datatype-accessor-ax    2737
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1325266
;  :del-clause              81251404
;  :final-checks            5
;  :max-generation          15
;  :max-memory              541.79
;  :memory                  512.44
;  :minimized-lits          1320
;  :mk-bool-var             69087025
;  :mk-clause               81253821
;  :num-allocs              163559979
;  :num-checks              696
;  :propagations            24200768
;  :quant-instantiations    28447720
;  :restarts                18
;  :rlimit-count            643626383
;  :time                    0.01)
; [then-branch: 330 | exc@612@04 == Null | live]
; [else-branch: 330 | exc@612@04 != Null | dead]
(push) ; 18
; [then-branch: 330 | exc@612@04 == Null]
; [eval] p != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 18
(pop) ; 17
; Joined path conditions
(assert (implies
  (= exc@612@04 $Ref.null)
  (not (= P@14@04 (as None<option<array>>  option<array>)))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@614@04))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@614@04)))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@614@04))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@614@04)))))))))
  $Snap.unit))
; [eval] exc == null ==> alen(opt_get1(p)) == V
; [eval] exc == null
(push) ; 17
(push) ; 18
(assert (not (not (= exc@612@04 $Ref.null))))
(check-sat)
; unknown
(pop) ; 18
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               32107971
;  :arith-add-rows          6486103
;  :arith-assert-diseq      213580
;  :arith-assert-lower      5733311
;  :arith-assert-upper      4974269
;  :arith-bound-prop        142596
;  :arith-conflicts         3639
;  :arith-eq-adapter        2108597
;  :arith-fixed-eqs         5331016
;  :arith-offset-eqs        3362047
;  :arith-pivots            935648
;  :conflicts               8428
;  :datatype-accessor-ax    2738
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1325292
;  :del-clause              81253009
;  :final-checks            5
;  :max-generation          15
;  :max-memory              541.79
;  :memory                  512.39
;  :minimized-lits          1320
;  :mk-bool-var             69088567
;  :mk-clause               81255426
;  :num-allocs              163565075
;  :num-checks              697
;  :propagations            24200949
;  :quant-instantiations    28448251
;  :restarts                18
;  :rlimit-count            643649788
;  :time                    0.01)
; [then-branch: 331 | exc@612@04 == Null | live]
; [else-branch: 331 | exc@612@04 != Null | dead]
(push) ; 18
; [then-branch: 331 | exc@612@04 == Null]
; [eval] alen(opt_get1(p)) == V
; [eval] alen(opt_get1(p))
; [eval] opt_get1(p)
(push) ; 19
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 19
; Joined path conditions
(pop) ; 18
(pop) ; 17
; Joined path conditions
(assert (implies
  (= exc@612@04 $Ref.null)
  (= (alen<Int> (opt_get1 $Snap.unit P@14@04)) V@15@04)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@614@04)))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@614@04))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@614@04)))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@614@04))))))))))
  $Snap.unit))
; [eval] exc == null ==> 0 <= s
; [eval] exc == null
(push) ; 17
(push) ; 18
(assert (not (not (= exc@612@04 $Ref.null))))
(check-sat)
; unknown
(pop) ; 18
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               32108271
;  :arith-add-rows          6486257
;  :arith-assert-diseq      213588
;  :arith-assert-lower      5733387
;  :arith-assert-upper      4974324
;  :arith-bound-prop        142599
;  :arith-conflicts         3639
;  :arith-eq-adapter        2108652
;  :arith-fixed-eqs         5331082
;  :arith-offset-eqs        3362071
;  :arith-pivots            935660
;  :conflicts               8428
;  :datatype-accessor-ax    2739
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1325318
;  :del-clause              81254892
;  :final-checks            5
;  :max-generation          15
;  :max-memory              541.79
;  :memory                  512.40
;  :minimized-lits          1320
;  :mk-bool-var             69090346
;  :mk-clause               81257309
;  :num-allocs              163571638
;  :num-checks              698
;  :propagations            24201255
;  :quant-instantiations    28448913
;  :restarts                18
;  :rlimit-count            643680432
;  :time                    0.01)
; [then-branch: 332 | exc@612@04 == Null | live]
; [else-branch: 332 | exc@612@04 != Null | dead]
(push) ; 18
; [then-branch: 332 | exc@612@04 == Null]
; [eval] 0 <= s
(pop) ; 18
(pop) ; 17
; Joined path conditions
(assert (implies (= exc@612@04 $Ref.null) (<= 0 s@12@04)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@614@04))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@614@04)))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@614@04))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@614@04)))))))))))
  $Snap.unit))
; [eval] exc == null ==> s < V
; [eval] exc == null
(push) ; 17
(push) ; 18
(assert (not (not (= exc@612@04 $Ref.null))))
(check-sat)
; unknown
(pop) ; 18
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               32108571
;  :arith-add-rows          6486411
;  :arith-assert-diseq      213596
;  :arith-assert-lower      5733463
;  :arith-assert-upper      4974379
;  :arith-bound-prop        142602
;  :arith-conflicts         3639
;  :arith-eq-adapter        2108707
;  :arith-fixed-eqs         5331148
;  :arith-offset-eqs        3362095
;  :arith-pivots            935672
;  :conflicts               8428
;  :datatype-accessor-ax    2740
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1325344
;  :del-clause              81256730
;  :final-checks            5
;  :max-generation          15
;  :max-memory              541.79
;  :memory                  512.40
;  :minimized-lits          1320
;  :mk-bool-var             69092078
;  :mk-clause               81259147
;  :num-allocs              163577954
;  :num-checks              699
;  :propagations            24201561
;  :quant-instantiations    28449534
;  :restarts                18
;  :rlimit-count            643709666
;  :time                    0.01)
; [then-branch: 333 | exc@612@04 == Null | live]
; [else-branch: 333 | exc@612@04 != Null | dead]
(push) ; 18
; [then-branch: 333 | exc@612@04 == Null]
; [eval] s < V
(pop) ; 18
(pop) ; 17
; Joined path conditions
(assert (implies (= exc@612@04 $Ref.null) (< s@12@04 V@15@04)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@614@04)))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@614@04))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@614@04)))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@614@04))))))))))))
  $Snap.unit))
; [eval] exc == null ==> 0 <= t
; [eval] exc == null
(push) ; 17
(push) ; 18
(assert (not (not (= exc@612@04 $Ref.null))))
(check-sat)
; unknown
(pop) ; 18
; 0.05s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               32108835
;  :arith-add-rows          6486560
;  :arith-assert-diseq      213604
;  :arith-assert-lower      5733519
;  :arith-assert-upper      4974419
;  :arith-bound-prop        142605
;  :arith-conflicts         3639
;  :arith-eq-adapter        2108756
;  :arith-fixed-eqs         5331192
;  :arith-offset-eqs        3362112
;  :arith-pivots            935684
;  :conflicts               8428
;  :datatype-accessor-ax    2741
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1325370
;  :del-clause              81258445
;  :final-checks            5
;  :max-generation          15
;  :max-memory              541.79
;  :memory                  502.40
;  :minimized-lits          1320
;  :mk-bool-var             69093686
;  :mk-clause               81260862
;  :num-allocs              163583209
;  :num-checks              700
;  :propagations            24201742
;  :quant-instantiations    28450084
;  :restarts                18
;  :rlimit-count            643733987
;  :time                    0.05)
; [then-branch: 334 | exc@612@04 == Null | live]
; [else-branch: 334 | exc@612@04 != Null | dead]
(push) ; 18
; [then-branch: 334 | exc@612@04 == Null]
; [eval] 0 <= t
(pop) ; 18
(pop) ; 17
; Joined path conditions
(assert (implies (= exc@612@04 $Ref.null) (<= 0 t@13@04)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@614@04))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@614@04)))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@614@04))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@614@04)))))))))))))
  $Snap.unit))
; [eval] exc == null ==> t < V
; [eval] exc == null
(push) ; 17
(push) ; 18
(assert (not (not (= exc@612@04 $Ref.null))))
(check-sat)
; unknown
(pop) ; 18
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               32109135
;  :arith-add-rows          6486714
;  :arith-assert-diseq      213612
;  :arith-assert-lower      5733595
;  :arith-assert-upper      4974474
;  :arith-bound-prop        142608
;  :arith-conflicts         3639
;  :arith-eq-adapter        2108811
;  :arith-fixed-eqs         5331258
;  :arith-offset-eqs        3362136
;  :arith-pivots            935696
;  :conflicts               8428
;  :datatype-accessor-ax    2742
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1325396
;  :del-clause              81260324
;  :final-checks            5
;  :max-generation          15
;  :max-memory              541.79
;  :memory                  502.55
;  :minimized-lits          1320
;  :mk-bool-var             69095461
;  :mk-clause               81262741
;  :num-allocs              163590390
;  :num-checks              701
;  :propagations            24202048
;  :quant-instantiations    28450742
;  :restarts                18
;  :rlimit-count            643769174
;  :time                    0.01)
; [then-branch: 335 | exc@612@04 == Null | live]
; [else-branch: 335 | exc@612@04 != Null | dead]
(push) ; 18
; [then-branch: 335 | exc@612@04 == Null]
; [eval] t < V
(pop) ; 18
(pop) ; 17
; Joined path conditions
(assert (implies (= exc@612@04 $Ref.null) (< t@13@04 V@15@04)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@614@04)))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@614@04))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@614@04)))))))))))))))))
; [eval] exc == null
(push) ; 17
(assert (not (not (= exc@612@04 $Ref.null))))
(check-sat)
; unknown
(pop) ; 17
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               32109418
;  :arith-add-rows          6486868
;  :arith-assert-diseq      213620
;  :arith-assert-lower      5733656
;  :arith-assert-upper      4974514
;  :arith-bound-prop        142611
;  :arith-conflicts         3639
;  :arith-eq-adapter        2108866
;  :arith-fixed-eqs         5331302
;  :arith-offset-eqs        3362153
;  :arith-pivots            935708
;  :conflicts               8428
;  :datatype-accessor-ax    2743
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1325422
;  :del-clause              81262153
;  :final-checks            5
;  :max-generation          15
;  :max-memory              541.79
;  :memory                  502.56
;  :minimized-lits          1320
;  :mk-bool-var             69097181
;  :mk-clause               81264570
;  :num-allocs              163596743
;  :num-checks              702
;  :propagations            24202354
;  :quant-instantiations    28451358
;  :restarts                18
;  :rlimit-count            643798128
;  :time                    0.01)
; [then-branch: 336 | exc@612@04 == Null | live]
; [else-branch: 336 | exc@612@04 != Null | dead]
(push) ; 17
; [then-branch: 336 | exc@612@04 == Null]
(declare-const i1@623@04 Int)
(declare-const j1@624@04 Int)
(push) ; 18
; [eval] 0 <= i1 && i1 < V && (0 <= j1 && j1 < V)
; [eval] 0 <= i1
(push) ; 19
; [then-branch: 337 | 0 <= i1@623@04 | live]
; [else-branch: 337 | !(0 <= i1@623@04) | live]
(push) ; 20
; [then-branch: 337 | 0 <= i1@623@04]
(assert (<= 0 i1@623@04))
; [eval] i1 < V
(push) ; 21
; [then-branch: 338 | i1@623@04 < V@15@04 | live]
; [else-branch: 338 | !(i1@623@04 < V@15@04) | live]
(push) ; 22
; [then-branch: 338 | i1@623@04 < V@15@04]
(assert (< i1@623@04 V@15@04))
; [eval] 0 <= j1
(push) ; 23
; [then-branch: 339 | 0 <= j1@624@04 | live]
; [else-branch: 339 | !(0 <= j1@624@04) | live]
(push) ; 24
; [then-branch: 339 | 0 <= j1@624@04]
(assert (<= 0 j1@624@04))
; [eval] j1 < V
(pop) ; 24
(push) ; 24
; [else-branch: 339 | !(0 <= j1@624@04)]
(assert (not (<= 0 j1@624@04)))
(pop) ; 24
(pop) ; 23
; Joined path conditions
; Joined path conditions
(pop) ; 22
(push) ; 22
; [else-branch: 338 | !(i1@623@04 < V@15@04)]
(assert (not (< i1@623@04 V@15@04)))
(pop) ; 22
(pop) ; 21
; Joined path conditions
; Joined path conditions
(pop) ; 20
(push) ; 20
; [else-branch: 337 | !(0 <= i1@623@04)]
(assert (not (<= 0 i1@623@04)))
(pop) ; 20
(pop) ; 19
; Joined path conditions
; Joined path conditions
(assert (and
  (and (and (< j1@624@04 V@15@04) (<= 0 j1@624@04)) (< i1@623@04 V@15@04))
  (<= 0 i1@623@04)))
; [eval] aloc(opt_get1(aloc(opt_get1(Gf), i1).option$array$), j1)
; [eval] opt_get1(aloc(opt_get1(Gf), i1).option$array$)
; [eval] aloc(opt_get1(Gf), i1)
; [eval] opt_get1(Gf)
(push) ; 19
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 19
; Joined path conditions
(push) ; 19
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 20
(assert (not (< i1@623@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))))
(check-sat)
; unsat
(pop) ; 20
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               32109432
;  :arith-add-rows          6486871
;  :arith-assert-diseq      213624
;  :arith-assert-lower      5733666
;  :arith-assert-upper      4974514
;  :arith-bound-prop        142615
;  :arith-conflicts         3639
;  :arith-eq-adapter        2108866
;  :arith-fixed-eqs         5331302
;  :arith-offset-eqs        3362165
;  :arith-pivots            935711
;  :conflicts               8428
;  :datatype-accessor-ax    2743
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1325422
;  :del-clause              81262155
;  :final-checks            5
;  :max-generation          15
;  :max-memory              541.79
;  :memory                  502.57
;  :minimized-lits          1320
;  :mk-bool-var             69097187
;  :mk-clause               81264574
;  :num-allocs              163597020
;  :num-checks              703
;  :propagations            24202358
;  :quant-instantiations    28451358
;  :restarts                18
;  :rlimit-count            643798663)
(assert (< i1@623@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(pop) ; 19
; Joined path conditions
(assert (< i1@623@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@618@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@623@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@623@04)))
(push) ; 19
(assert (not (<
  $Perm.No
  (+
    (+
      (+
        (ite
          (and
            (<
              (inv@617@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@623@04))
              V@15@04)
            (<=
              0
              (inv@617@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@623@04))))
          $k@616@04
          $Perm.No)
        (ite
          (and
            (<
              (inv@445@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@623@04))
              V@15@04)
            (<=
              0
              (inv@445@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@623@04))))
          $k@444@04
          $Perm.No))
      (ite
        (and
          (<
            (inv@357@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@623@04))
            V@15@04)
          (<=
            0
            (inv@357@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@623@04))))
        $k@356@04
        $Perm.No))
    (-
      (-
        (-
          (ite
            (and
              (<
                (inv@296@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@623@04))
                V@15@04)
              (<=
                0
                (inv@296@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@623@04))))
            $k@295@04
            $Perm.No)
          (pTaken@380@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@623@04)))
        (pTaken@469@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@623@04)))
      (pTaken@583@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@623@04)))))))
(check-sat)
; unsat
(pop) ; 19
; 0.05s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               32110562
;  :arith-add-rows          6488258
;  :arith-assert-diseq      213639
;  :arith-assert-lower      5733817
;  :arith-assert-upper      4974621
;  :arith-bound-prop        142679
;  :arith-conflicts         3642
;  :arith-eq-adapter        2108973
;  :arith-fixed-eqs         5331415
;  :arith-offset-eqs        3362228
;  :arith-pivots            935790
;  :conflicts               8447
;  :datatype-accessor-ax    2747
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1325794
;  :del-clause              81274110
;  :final-checks            5
;  :max-generation          15
;  :max-memory              541.79
;  :memory                  502.82
;  :minimized-lits          1320
;  :mk-bool-var             69106612
;  :mk-clause               81277177
;  :num-allocs              163626336
;  :num-checks              704
;  :propagations            24203947
;  :quant-instantiations    28453515
;  :restarts                18
;  :rlimit-count            643932509
;  :time                    0.05)
(push) ; 19
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 20
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@618@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@623@04))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 20
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               32110562
;  :arith-add-rows          6488258
;  :arith-assert-diseq      213639
;  :arith-assert-lower      5733817
;  :arith-assert-upper      4974621
;  :arith-bound-prop        142679
;  :arith-conflicts         3642
;  :arith-eq-adapter        2108973
;  :arith-fixed-eqs         5331415
;  :arith-offset-eqs        3362228
;  :arith-pivots            935790
;  :conflicts               8448
;  :datatype-accessor-ax    2747
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1325794
;  :del-clause              81274110
;  :final-checks            5
;  :max-generation          15
;  :max-memory              541.79
;  :memory                  502.82
;  :minimized-lits          1320
;  :mk-bool-var             69106612
;  :mk-clause               81277177
;  :num-allocs              163626427
;  :num-checks              705
;  :propagations            24203947
;  :quant-instantiations    28453515
;  :restarts                18
;  :rlimit-count            643932604)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@618@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@623@04))
    (as None<option<array>>  option<array>))))
(pop) ; 19
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@618@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@623@04))
    (as None<option<array>>  option<array>))))
(push) ; 19
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 20
(assert (not (<
  j1@624@04
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@618@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@623@04)))))))
(check-sat)
; unsat
(pop) ; 20
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               32110568
;  :arith-add-rows          6488264
;  :arith-assert-diseq      213639
;  :arith-assert-lower      5733820
;  :arith-assert-upper      4974622
;  :arith-bound-prop        142679
;  :arith-conflicts         3643
;  :arith-eq-adapter        2108974
;  :arith-fixed-eqs         5331416
;  :arith-offset-eqs        3362228
;  :arith-pivots            935794
;  :conflicts               8449
;  :datatype-accessor-ax    2747
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1325794
;  :del-clause              81274114
;  :final-checks            5
;  :max-generation          15
;  :max-memory              541.79
;  :memory                  502.82
;  :minimized-lits          1320
;  :mk-bool-var             69106623
;  :mk-clause               81277181
;  :num-allocs              163626619
;  :num-checks              706
;  :propagations            24203949
;  :quant-instantiations    28453522
;  :restarts                18
;  :rlimit-count            643933142
;  :time                    0.00)
(assert (<
  j1@624@04
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@618@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@623@04))))))
(pop) ; 19
; Joined path conditions
(assert (<
  j1@624@04
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@618@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@623@04))))))
(pop) ; 18
(declare-fun inv@625@04 ($Ref) Int)
(declare-fun inv@626@04 ($Ref) Int)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(assert (forall ((i1@623@04 Int) (j1@624@04 Int)) (!
  (and
    (< i1@623@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@618@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@623@04)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@623@04))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@618@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@623@04))
        (as None<option<array>>  option<array>)))
    (<
      j1@624@04
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@618@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@623@04))))))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@618@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@623@04))) j1@624@04))
  :qid |int-aux|)))
; Check receiver injectivity
(push) ; 18
(assert (not (forall ((i11@623@04 Int) (j11@624@04 Int) (i12@623@04 Int) (j12@624@04 Int)) (!
  (implies
    (and
      (and
        (and
          (and (< j11@624@04 V@15@04) (<= 0 j11@624@04))
          (< i11@623@04 V@15@04))
        (<= 0 i11@623@04))
      (and
        (and
          (and (< j12@624@04 V@15@04) (<= 0 j12@624@04))
          (< i12@623@04 V@15@04))
        (<= 0 i12@623@04))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@618@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i11@623@04))) j11@624@04)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@618@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i12@623@04))) j12@624@04)))
    (and (= i11@623@04 i12@623@04) (= j11@624@04 j12@624@04)))
  
  :qid |int-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 18
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               32110790
;  :arith-add-rows          6488423
;  :arith-assert-diseq      213641
;  :arith-assert-lower      5733857
;  :arith-assert-upper      4974637
;  :arith-bound-prop        142696
;  :arith-conflicts         3643
;  :arith-eq-adapter        2109036
;  :arith-fixed-eqs         5331430
;  :arith-offset-eqs        3362249
;  :arith-pivots            935862
;  :conflicts               8450
;  :datatype-accessor-ax    2747
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1325794
;  :del-clause              81275647
;  :final-checks            5
;  :max-generation          15
;  :max-memory              541.79
;  :memory                  502.72
;  :minimized-lits          1320
;  :mk-bool-var             69108097
;  :mk-clause               81278064
;  :num-allocs              163633388
;  :num-checks              707
;  :propagations            24204000
;  :quant-instantiations    28454116
;  :restarts                18
;  :rlimit-count            643962883
;  :time                    0.01)
; Definitional axioms for inverse functions
(assert (forall ((i1@623@04 Int) (j1@624@04 Int)) (!
  (implies
    (and
      (and (and (< j1@624@04 V@15@04) (<= 0 j1@624@04)) (< i1@623@04 V@15@04))
      (<= 0 i1@623@04))
    (and
      (=
        (inv@625@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@618@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@623@04))) j1@624@04))
        i1@623@04)
      (=
        (inv@626@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@618@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@623@04))) j1@624@04))
        j1@624@04)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@618@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@623@04))) j1@624@04))
  )))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@626@04 r) V@15@04) (<= 0 (inv@626@04 r)))
        (< (inv@625@04 r) V@15@04))
      (<= 0 (inv@625@04 r)))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@618@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) (inv@625@04 r)))) (inv@626@04 r))
      r))
  :pattern ((inv@625@04 r))
  :pattern ((inv@626@04 r))
  :qid |int-fctOfInv|)))
; Permissions are non-negative
; Field permissions are at most one
; Permission implies non-null receiver
(assert (forall ((i1@623@04 Int) (j1@624@04 Int)) (!
  (implies
    (and
      (and (and (< j1@624@04 V@15@04) (<= 0 j1@624@04)) (< i1@623@04 V@15@04))
      (<= 0 i1@623@04))
    (not
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@618@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@623@04))) j1@624@04)
        $Ref.null)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@618@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@623@04))) j1@624@04))
  :qid |int-permImpliesNonNull|)))
(declare-const sm@627@04 $FVF<Int>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@626@04 r) V@15@04) (<= 0 (inv@626@04 r)))
        (< (inv@625@04 r) V@15@04))
      (<= 0 (inv@625@04 r)))
    (=
      ($FVF.lookup_int (as sm@627@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@614@04))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@627@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@614@04))))))))))))))) r))
  :qid |qp.fvfValDef487|)))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (-
          (ite
            (and (< (inv@457@04 r) V@15@04) (<= 0 (inv@457@04 r)))
            $Perm.Write
            $Perm.No)
          (pTaken@595@04 r))
        (pTaken@603@04 r)))
    (=
      ($FVF.lookup_int (as sm@627@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04)))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@627@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04)))))))))))))) r))
  :qid |qp.fvfValDef488|)))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (-
          (-
            (ite
              (and
                (and
                  (and (< (inv@366@04 r) V@15@04) (<= 0 (inv@366@04 r)))
                  (< (inv@365@04 r) V@15@04))
                (<= 0 (inv@365@04 r)))
              $Perm.Write
              $Perm.No)
            (pTaken@481@04 r))
          (pTaken@485@04 r))
        (pTaken@601@04 r)))
    (=
      ($FVF.lookup_int (as sm@627@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@627@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))))))) r))
  :qid |qp.fvfValDef489|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@614@04))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04)))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@627@04  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef490|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@626@04 r) V@15@04) (<= 0 (inv@626@04 r)))
        (< (inv@625@04 r) V@15@04))
      (<= 0 (inv@625@04 r)))
    ($FVF.loc_int ($FVF.lookup_int (as sm@627@04  $FVF<Int>) r) r))
  :pattern ((inv@625@04 r) (inv@626@04 r))
  )))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@614@04))))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@614@04)))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@614@04))))))))))))))))))
; [eval] exc == null
(set-option :timeout 10)
(push) ; 18
(assert (not (not (= exc@612@04 $Ref.null))))
(check-sat)
; unknown
(pop) ; 18
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               32111053
;  :arith-add-rows          6488570
;  :arith-assert-diseq      213649
;  :arith-assert-lower      5733913
;  :arith-assert-upper      4974677
;  :arith-bound-prop        142699
;  :arith-conflicts         3643
;  :arith-eq-adapter        2109084
;  :arith-fixed-eqs         5331474
;  :arith-offset-eqs        3362266
;  :arith-pivots            935874
;  :conflicts               8450
;  :datatype-accessor-ax    2748
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1325820
;  :del-clause              81277285
;  :final-checks            5
;  :max-generation          15
;  :max-memory              541.79
;  :memory                  502.72
;  :minimized-lits          1320
;  :mk-bool-var             69109669
;  :mk-clause               81279702
;  :num-allocs              163640381
;  :num-checks              708
;  :propagations            24204181
;  :quant-instantiations    28454653
;  :restarts                18
;  :rlimit-count            643994825
;  :time                    0.01)
; [then-branch: 340 | exc@612@04 == Null | live]
; [else-branch: 340 | exc@612@04 != Null | dead]
(push) ; 18
; [then-branch: 340 | exc@612@04 == Null]
(declare-const i1@628@04 Int)
(push) ; 19
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 20
; [then-branch: 341 | 0 <= i1@628@04 | live]
; [else-branch: 341 | !(0 <= i1@628@04) | live]
(push) ; 21
; [then-branch: 341 | 0 <= i1@628@04]
(assert (<= 0 i1@628@04))
; [eval] i1 < V
(pop) ; 21
(push) ; 21
; [else-branch: 341 | !(0 <= i1@628@04)]
(assert (not (<= 0 i1@628@04)))
(pop) ; 21
(pop) ; 20
; Joined path conditions
; Joined path conditions
(assert (and (< i1@628@04 V@15@04) (<= 0 i1@628@04)))
; [eval] aloc(opt_get1(p), i1)
; [eval] opt_get1(p)
(push) ; 20
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 20
; Joined path conditions
(push) ; 20
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 21
(assert (not (< i1@628@04 (alen<Int> (opt_get1 $Snap.unit P@14@04)))))
(check-sat)
; unsat
(pop) ; 21
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               32111060
;  :arith-add-rows          6488571
;  :arith-assert-diseq      213651
;  :arith-assert-lower      5733917
;  :arith-assert-upper      4974677
;  :arith-bound-prop        142701
;  :arith-conflicts         3643
;  :arith-eq-adapter        2109084
;  :arith-fixed-eqs         5331474
;  :arith-offset-eqs        3362272
;  :arith-pivots            935875
;  :conflicts               8450
;  :datatype-accessor-ax    2748
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1325820
;  :del-clause              81277285
;  :final-checks            5
;  :max-generation          15
;  :max-memory              541.79
;  :memory                  502.72
;  :minimized-lits          1320
;  :mk-bool-var             69109671
;  :mk-clause               81279704
;  :num-allocs              163640485
;  :num-checks              709
;  :propagations            24204183
;  :quant-instantiations    28454653
;  :restarts                18
;  :rlimit-count            643995038)
(assert (< i1@628@04 (alen<Int> (opt_get1 $Snap.unit P@14@04))))
(pop) ; 20
; Joined path conditions
(assert (< i1@628@04 (alen<Int> (opt_get1 $Snap.unit P@14@04))))
(pop) ; 19
(declare-fun inv@629@04 ($Ref) Int)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(assert (forall ((i1@628@04 Int)) (!
  (< i1@628@04 (alen<Int> (opt_get1 $Snap.unit P@14@04)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i1@628@04))
  :qid |int-aux|)))
; Check receiver injectivity
(push) ; 19
(assert (not (forall ((i11@628@04 Int) (i12@628@04 Int)) (!
  (implies
    (and
      (and (< i11@628@04 V@15@04) (<= 0 i11@628@04))
      (and (< i12@628@04 V@15@04) (<= 0 i12@628@04))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i11@628@04)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i12@628@04)))
    (= i11@628@04 i12@628@04))
  
  :qid |int-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 19
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               32111130
;  :arith-add-rows          6488579
;  :arith-assert-diseq      213652
;  :arith-assert-lower      5733921
;  :arith-assert-upper      4974677
;  :arith-bound-prop        142702
;  :arith-conflicts         3643
;  :arith-eq-adapter        2109085
;  :arith-fixed-eqs         5331474
;  :arith-offset-eqs        3362272
;  :arith-pivots            935880
;  :conflicts               8451
;  :datatype-accessor-ax    2748
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1325820
;  :del-clause              81277294
;  :final-checks            5
;  :max-generation          15
;  :max-memory              541.79
;  :memory                  502.72
;  :minimized-lits          1320
;  :mk-bool-var             69109752
;  :mk-clause               81279711
;  :num-allocs              163641352
;  :num-checks              710
;  :propagations            24204184
;  :quant-instantiations    28454764
;  :restarts                18
;  :rlimit-count            643997941
;  :time                    0.00)
; Definitional axioms for inverse functions
(assert (forall ((i1@628@04 Int)) (!
  (implies
    (and (< i1@628@04 V@15@04) (<= 0 i1@628@04))
    (=
      (inv@629@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i1@628@04))
      i1@628@04))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i1@628@04))
  )))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@629@04 r) V@15@04) (<= 0 (inv@629@04 r)))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) (inv@629@04 r))
      r))
  :pattern ((inv@629@04 r))
  :qid |int-fctOfInv|)))
; Permissions are non-negative
; Field permissions are at most one
; Permission implies non-null receiver
(assert (forall ((i1@628@04 Int)) (!
  (implies
    (and (< i1@628@04 V@15@04) (<= 0 i1@628@04))
    (not
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i1@628@04)
        $Ref.null)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i1@628@04))
  :qid |int-permImpliesNonNull|)))
(declare-const sm@630@04 $FVF<Int>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@629@04 r) V@15@04) (<= 0 (inv@629@04 r)))
    (=
      ($FVF.lookup_int (as sm@630@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@614@04)))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@630@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@614@04)))))))))))))))) r))
  :qid |qp.fvfValDef491|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@626@04 r) V@15@04) (<= 0 (inv@626@04 r)))
        (< (inv@625@04 r) V@15@04))
      (<= 0 (inv@625@04 r)))
    (=
      ($FVF.lookup_int (as sm@630@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@614@04))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@630@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@614@04))))))))))))))) r))
  :qid |qp.fvfValDef492|)))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (-
          (ite
            (and (< (inv@457@04 r) V@15@04) (<= 0 (inv@457@04 r)))
            $Perm.Write
            $Perm.No)
          (pTaken@595@04 r))
        (pTaken@603@04 r)))
    (=
      ($FVF.lookup_int (as sm@630@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04)))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@630@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04)))))))))))))) r))
  :qid |qp.fvfValDef493|)))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (-
          (-
            (ite
              (and
                (and
                  (and (< (inv@366@04 r) V@15@04) (<= 0 (inv@366@04 r)))
                  (< (inv@365@04 r) V@15@04))
                (<= 0 (inv@365@04 r)))
              $Perm.Write
              $Perm.No)
            (pTaken@481@04 r))
          (pTaken@485@04 r))
        (pTaken@601@04 r)))
    (=
      ($FVF.lookup_int (as sm@630@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@630@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))))))) r))
  :qid |qp.fvfValDef494|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@614@04)))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@614@04))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04)))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@630@04  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef495|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@629@04 r) V@15@04) (<= 0 (inv@629@04 r)))
    ($FVF.loc_int ($FVF.lookup_int (as sm@630@04  $FVF<Int>) r) r))
  :pattern ((inv@629@04 r))
  )))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@614@04)))))))))))))))
  $Snap.unit))
; [eval] exc == null ==> valid_graph_vertices(this, p, V)
; [eval] exc == null
(push) ; 19
(set-option :timeout 10)
(push) ; 20
(assert (not (not (= exc@612@04 $Ref.null))))
(check-sat)
; unknown
(pop) ; 20
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               32111425
;  :arith-add-rows          6488733
;  :arith-assert-diseq      213660
;  :arith-assert-lower      5733997
;  :arith-assert-upper      4974732
;  :arith-bound-prop        142705
;  :arith-conflicts         3643
;  :arith-eq-adapter        2109140
;  :arith-fixed-eqs         5331540
;  :arith-offset-eqs        3362296
;  :arith-pivots            935892
;  :conflicts               8451
;  :datatype-accessor-ax    2748
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1325846
;  :del-clause              81279200
;  :final-checks            5
;  :max-generation          15
;  :max-memory              541.79
;  :memory                  502.70
;  :minimized-lits          1320
;  :mk-bool-var             69111682
;  :mk-clause               81281617
;  :num-allocs              163649978
;  :num-checks              711
;  :propagations            24204492
;  :quant-instantiations    28455474
;  :restarts                18
;  :rlimit-count            644039127
;  :time                    0.01)
; [then-branch: 342 | exc@612@04 == Null | live]
; [else-branch: 342 | exc@612@04 != Null | dead]
(push) ; 20
; [then-branch: 342 | exc@612@04 == Null]
; [eval] valid_graph_vertices(this, p, V)
(push) ; 21
; [eval] this != null
; [eval] p != (None(): option[array])
; [eval] (None(): option[array])
; [eval] alen(opt_get1(p)) == V
; [eval] alen(opt_get1(p))
; [eval] opt_get1(p)
(push) ; 22
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 22
; Joined path conditions
(declare-const i1@631@04 Int)
(push) ; 22
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 23
; [then-branch: 343 | 0 <= i1@631@04 | live]
; [else-branch: 343 | !(0 <= i1@631@04) | live]
(push) ; 24
; [then-branch: 343 | 0 <= i1@631@04]
(assert (<= 0 i1@631@04))
; [eval] i1 < V
(pop) ; 24
(push) ; 24
; [else-branch: 343 | !(0 <= i1@631@04)]
(assert (not (<= 0 i1@631@04)))
(pop) ; 24
(pop) ; 23
; Joined path conditions
; Joined path conditions
(assert (and (< i1@631@04 V@15@04) (<= 0 i1@631@04)))
(declare-const $k@632@04 $Perm)
(assert ($Perm.isReadVar $k@632@04 $Perm.Write))
; [eval] aloc(opt_get1(p), i1)
; [eval] opt_get1(p)
(push) ; 23
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 23
; Joined path conditions
(push) ; 23
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 24
(assert (not (< i1@631@04 (alen<Int> (opt_get1 $Snap.unit P@14@04)))))
(check-sat)
; unsat
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               32111432
;  :arith-add-rows          6488734
;  :arith-assert-diseq      213663
;  :arith-assert-lower      5734003
;  :arith-assert-upper      4974733
;  :arith-bound-prop        142707
;  :arith-conflicts         3643
;  :arith-eq-adapter        2109141
;  :arith-fixed-eqs         5331540
;  :arith-offset-eqs        3362302
;  :arith-pivots            935892
;  :conflicts               8451
;  :datatype-accessor-ax    2748
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1325846
;  :del-clause              81279200
;  :final-checks            5
;  :max-generation          15
;  :max-memory              541.79
;  :memory                  502.70
;  :minimized-lits          1320
;  :mk-bool-var             69111688
;  :mk-clause               81281621
;  :num-allocs              163650149
;  :num-checks              712
;  :propagations            24204495
;  :quant-instantiations    28455474
;  :restarts                18
;  :rlimit-count            644039485)
(assert (< i1@631@04 (alen<Int> (opt_get1 $Snap.unit P@14@04))))
(pop) ; 23
; Joined path conditions
(assert (< i1@631@04 (alen<Int> (opt_get1 $Snap.unit P@14@04))))
(pop) ; 22
(declare-fun inv@633@04 ($Ref) Int)
; Nested auxiliary terms: globals
(assert ($Perm.isReadVar $k@632@04 $Perm.Write))
; Nested auxiliary terms: non-globals
(assert (forall ((i1@631@04 Int)) (!
  (< i1@631@04 (alen<Int> (opt_get1 $Snap.unit P@14@04)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i1@631@04))
  :qid |int-aux|)))
(push) ; 22
(assert (not (forall ((i1@631@04 Int)) (!
  (implies
    (and (< i1@631@04 V@15@04) (<= 0 i1@631@04))
    (or (= $k@632@04 $Perm.No) (< $Perm.No $k@632@04)))
  
  ))))
(check-sat)
; unsat
(pop) ; 22
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               32111432
;  :arith-add-rows          6488735
;  :arith-assert-diseq      213664
;  :arith-assert-lower      5734005
;  :arith-assert-upper      4974734
;  :arith-bound-prop        142707
;  :arith-conflicts         3643
;  :arith-eq-adapter        2109142
;  :arith-fixed-eqs         5331540
;  :arith-offset-eqs        3362302
;  :arith-pivots            935892
;  :conflicts               8452
;  :datatype-accessor-ax    2748
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1325846
;  :del-clause              81279204
;  :final-checks            5
;  :max-generation          15
;  :max-memory              541.79
;  :memory                  502.70
;  :minimized-lits          1320
;  :mk-bool-var             69111695
;  :mk-clause               81281623
;  :num-allocs              163650579
;  :num-checks              713
;  :propagations            24204496
;  :quant-instantiations    28455474
;  :restarts                18
;  :rlimit-count            644040031)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 22
(assert (not (forall ((i11@631@04 Int) (i12@631@04 Int)) (!
  (implies
    (and
      (and
        (and
          (and (< i11@631@04 V@15@04) (<= 0 i11@631@04))
          ($FVF.loc_int ($FVF.lookup_int (as sm@630@04  $FVF<Int>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit P@14@04) i11@631@04)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit P@14@04) i11@631@04)))
        (< $Perm.No $k@632@04))
      (and
        (and
          (and (< i12@631@04 V@15@04) (<= 0 i12@631@04))
          ($FVF.loc_int ($FVF.lookup_int (as sm@630@04  $FVF<Int>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit P@14@04) i12@631@04)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit P@14@04) i12@631@04)))
        (< $Perm.No $k@632@04))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i11@631@04)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i12@631@04)))
    (= i11@631@04 i12@631@04))
  
  :qid |int-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 22
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               32111505
;  :arith-add-rows          6488756
;  :arith-assert-diseq      213665
;  :arith-assert-lower      5734009
;  :arith-assert-upper      4974734
;  :arith-bound-prop        142708
;  :arith-conflicts         3643
;  :arith-eq-adapter        2109143
;  :arith-fixed-eqs         5331540
;  :arith-offset-eqs        3362302
;  :arith-pivots            935894
;  :conflicts               8453
;  :datatype-accessor-ax    2748
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1325846
;  :del-clause              81279292
;  :final-checks            5
;  :max-generation          15
;  :max-memory              541.79
;  :memory                  502.70
;  :minimized-lits          1320
;  :mk-bool-var             69111875
;  :mk-clause               81281711
;  :num-allocs              163651658
;  :num-checks              714
;  :propagations            24204501
;  :quant-instantiations    28455594
;  :restarts                18
;  :rlimit-count            644043815
;  :time                    0.00)
; Definitional axioms for inverse functions
(assert (forall ((i1@631@04 Int)) (!
  (implies
    (and (and (< i1@631@04 V@15@04) (<= 0 i1@631@04)) (< $Perm.No $k@632@04))
    (=
      (inv@633@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i1@631@04))
      i1@631@04))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i1@631@04))
  :qid |int-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and (< (inv@633@04 r) V@15@04) (<= 0 (inv@633@04 r)))
      (< $Perm.No $k@632@04))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) (inv@633@04 r))
      r))
  :pattern ((inv@633@04 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@633@04 r) V@15@04) (<= 0 (inv@633@04 r)))
    ($FVF.loc_int ($FVF.lookup_int (as sm@630@04  $FVF<Int>) r) r))
  :pattern ((inv@633@04 r))
  )))
; Precomputing data for removing quantified permissions
(define-fun pTaken@634@04 ((r $Ref)) $Perm
  (ite
    (and (< (inv@633@04 r) V@15@04) (<= 0 (inv@633@04 r)))
    ($Perm.min
      (ite
        (and (< (inv@629@04 r) V@15@04) (<= 0 (inv@629@04 r)))
        $Perm.Write
        $Perm.No)
      $k@632@04)
    $Perm.No))
(define-fun pTaken@635@04 ((r $Ref)) $Perm
  (ite
    (and (< (inv@633@04 r) V@15@04) (<= 0 (inv@633@04 r)))
    ($Perm.min
      (ite
        (and
          (and
            (and (< (inv@626@04 r) V@15@04) (<= 0 (inv@626@04 r)))
            (< (inv@625@04 r) V@15@04))
          (<= 0 (inv@625@04 r)))
        $Perm.Write
        $Perm.No)
      (- $k@632@04 (pTaken@634@04 r)))
    $Perm.No))
(define-fun pTaken@636@04 ((r $Ref)) $Perm
  (ite
    (and (< (inv@633@04 r) V@15@04) (<= 0 (inv@633@04 r)))
    ($Perm.min
      (-
        (-
          (ite
            (and (< (inv@457@04 r) V@15@04) (<= 0 (inv@457@04 r)))
            $Perm.Write
            $Perm.No)
          (pTaken@595@04 r))
        (pTaken@603@04 r))
      (- (- $k@632@04 (pTaken@634@04 r)) (pTaken@635@04 r)))
    $Perm.No))
(define-fun pTaken@637@04 ((r $Ref)) $Perm
  (ite
    (and (< (inv@633@04 r) V@15@04) (<= 0 (inv@633@04 r)))
    ($Perm.min
      (-
        (-
          (-
            (ite
              (and
                (and
                  (and (< (inv@366@04 r) V@15@04) (<= 0 (inv@366@04 r)))
                  (< (inv@365@04 r) V@15@04))
                (<= 0 (inv@365@04 r)))
              $Perm.Write
              $Perm.No)
            (pTaken@481@04 r))
          (pTaken@485@04 r))
        (pTaken@601@04 r))
      (- (- (- $k@632@04 (pTaken@634@04 r)) (pTaken@635@04 r)) (pTaken@636@04 r)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Constrain original permissions $k@632@04
(assert (forall ((r $Ref)) (!
  (implies
    (not
      (=
        (ite
          (and (< (inv@629@04 r) V@15@04) (<= 0 (inv@629@04 r)))
          $Perm.Write
          $Perm.No)
        $Perm.No))
    (ite
      (and (< (inv@629@04 r) V@15@04) (<= 0 (inv@629@04 r)))
      (<
        (ite
          (and (< (inv@633@04 r) V@15@04) (<= 0 (inv@633@04 r)))
          $k@632@04
          $Perm.No)
        $Perm.Write)
      (<
        (ite
          (and (< (inv@633@04 r) V@15@04) (<= 0 (inv@633@04 r)))
          $k@632@04
          $Perm.No)
        $Perm.No)))
  :pattern ((inv@629@04 r))
  :pattern ((inv@633@04 r))
  :qid |qp.srp496|)))
; Intermediate check if already taken enough permissions
(set-option :timeout 500)
(push) ; 22
(assert (not (forall ((r $Ref)) (!
  (implies
    (and (< (inv@633@04 r) V@15@04) (<= 0 (inv@633@04 r)))
    (= (- $k@632@04 (pTaken@634@04 r)) $Perm.No))
  
  ))))
(check-sat)
; unsat
(pop) ; 22
; 0.05s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               32112717
;  :arith-add-rows          6490127
;  :arith-assert-diseq      213691
;  :arith-assert-lower      5734184
;  :arith-assert-upper      4974868
;  :arith-bound-prop        142738
;  :arith-conflicts         3646
;  :arith-eq-adapter        2109300
;  :arith-fixed-eqs         5331682
;  :arith-offset-eqs        3362343
;  :arith-pivots            935983
;  :conflicts               8474
;  :datatype-accessor-ax    2752
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1326245
;  :del-clause              81294081
;  :final-checks            5
;  :max-generation          15
;  :max-memory              541.79
;  :memory                  502.78
;  :minimized-lits          1321
;  :mk-bool-var             69123009
;  :mk-clause               81296501
;  :num-allocs              163685996
;  :num-checks              716
;  :propagations            24206066
;  :quant-instantiations    28458307
;  :restarts                18
;  :rlimit-count            644203174
;  :time                    0.06)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@638@04 $FVF<Int>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (iff
    (Set_in r ($FVF.domain_int (as sm@638@04  $FVF<Int>)))
    (and
      (and (< (inv@633@04 r) V@15@04) (<= 0 (inv@633@04 r)))
      (< $Perm.No $k@632@04)))
  :pattern ((Set_in r ($FVF.domain_int (as sm@638@04  $FVF<Int>))))
  :qid |qp.fvfDomDef502|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@633@04 r) V@15@04) (<= 0 (inv@633@04 r)))
        (< $Perm.No $k@632@04))
      (and (< (inv@629@04 r) V@15@04) (<= 0 (inv@629@04 r))))
    (=
      ($FVF.lookup_int (as sm@638@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@614@04)))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@638@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@614@04)))))))))))))))) r))
  :qid |qp.fvfValDef497|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@633@04 r) V@15@04) (<= 0 (inv@633@04 r)))
        (< $Perm.No $k@632@04))
      (and
        (and
          (and (< (inv@626@04 r) V@15@04) (<= 0 (inv@626@04 r)))
          (< (inv@625@04 r) V@15@04))
        (<= 0 (inv@625@04 r))))
    (=
      ($FVF.lookup_int (as sm@638@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@614@04))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@638@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@614@04))))))))))))))) r))
  :qid |qp.fvfValDef498|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@633@04 r) V@15@04) (<= 0 (inv@633@04 r)))
        (< $Perm.No $k@632@04))
      (<
        $Perm.No
        (-
          (-
            (ite
              (and (< (inv@457@04 r) V@15@04) (<= 0 (inv@457@04 r)))
              $Perm.Write
              $Perm.No)
            (pTaken@595@04 r))
          (pTaken@603@04 r))))
    (=
      ($FVF.lookup_int (as sm@638@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04)))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@638@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04)))))))))))))) r))
  :qid |qp.fvfValDef499|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@633@04 r) V@15@04) (<= 0 (inv@633@04 r)))
        (< $Perm.No $k@632@04))
      (<
        $Perm.No
        (-
          (-
            (-
              (ite
                (and
                  (and
                    (and (< (inv@366@04 r) V@15@04) (<= 0 (inv@366@04 r)))
                    (< (inv@365@04 r) V@15@04))
                  (<= 0 (inv@365@04 r)))
                $Perm.Write
                $Perm.No)
              (pTaken@481@04 r))
            (pTaken@485@04 r))
          (pTaken@601@04 r))))
    (=
      ($FVF.lookup_int (as sm@638@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@638@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))))))) r))
  :qid |qp.fvfValDef500|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@614@04)))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@614@04))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04)))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@638@04  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef501|)))
(pop) ; 21
; Joined path conditions
(assert ($Perm.isReadVar $k@632@04 $Perm.Write))
(assert (forall ((i1@631@04 Int)) (!
  (implies
    (and (and (< i1@631@04 V@15@04) (<= 0 i1@631@04)) (< $Perm.No $k@632@04))
    (=
      (inv@633@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i1@631@04))
      i1@631@04))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i1@631@04))
  :qid |int-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and (< (inv@633@04 r) V@15@04) (<= 0 (inv@633@04 r)))
      (< $Perm.No $k@632@04))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) (inv@633@04 r))
      r))
  :pattern ((inv@633@04 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (iff
    (Set_in r ($FVF.domain_int (as sm@638@04  $FVF<Int>)))
    (and
      (and (< (inv@633@04 r) V@15@04) (<= 0 (inv@633@04 r)))
      (< $Perm.No $k@632@04)))
  :pattern ((Set_in r ($FVF.domain_int (as sm@638@04  $FVF<Int>))))
  :qid |qp.fvfDomDef502|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@633@04 r) V@15@04) (<= 0 (inv@633@04 r)))
        (< $Perm.No $k@632@04))
      (and (< (inv@629@04 r) V@15@04) (<= 0 (inv@629@04 r))))
    (=
      ($FVF.lookup_int (as sm@638@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@614@04)))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@638@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@614@04)))))))))))))))) r))
  :qid |qp.fvfValDef497|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@633@04 r) V@15@04) (<= 0 (inv@633@04 r)))
        (< $Perm.No $k@632@04))
      (and
        (and
          (and (< (inv@626@04 r) V@15@04) (<= 0 (inv@626@04 r)))
          (< (inv@625@04 r) V@15@04))
        (<= 0 (inv@625@04 r))))
    (=
      ($FVF.lookup_int (as sm@638@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@614@04))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@638@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@614@04))))))))))))))) r))
  :qid |qp.fvfValDef498|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@633@04 r) V@15@04) (<= 0 (inv@633@04 r)))
        (< $Perm.No $k@632@04))
      (<
        $Perm.No
        (-
          (-
            (ite
              (and (< (inv@457@04 r) V@15@04) (<= 0 (inv@457@04 r)))
              $Perm.Write
              $Perm.No)
            (pTaken@595@04 r))
          (pTaken@603@04 r))))
    (=
      ($FVF.lookup_int (as sm@638@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04)))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@638@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04)))))))))))))) r))
  :qid |qp.fvfValDef499|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@633@04 r) V@15@04) (<= 0 (inv@633@04 r)))
        (< $Perm.No $k@632@04))
      (<
        $Perm.No
        (-
          (-
            (-
              (ite
                (and
                  (and
                    (and (< (inv@366@04 r) V@15@04) (<= 0 (inv@366@04 r)))
                    (< (inv@365@04 r) V@15@04))
                  (<= 0 (inv@365@04 r)))
                $Perm.Write
                $Perm.No)
              (pTaken@481@04 r))
            (pTaken@485@04 r))
          (pTaken@601@04 r))))
    (=
      ($FVF.lookup_int (as sm@638@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@638@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))))))) r))
  :qid |qp.fvfValDef500|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@614@04)))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@614@04))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04)))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@638@04  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef501|)))
(assert (and
  (forall ((i1@631@04 Int)) (!
    (< i1@631@04 (alen<Int> (opt_get1 $Snap.unit P@14@04)))
    :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i1@631@04))
    :qid |int-aux|))
  (forall ((r $Ref)) (!
    (implies
      (and (< (inv@633@04 r) V@15@04) (<= 0 (inv@633@04 r)))
      ($FVF.loc_int ($FVF.lookup_int (as sm@630@04  $FVF<Int>) r) r))
    :pattern ((inv@633@04 r))
    ))
  (forall ((r $Ref)) (!
    (implies
      (not
        (=
          (ite
            (and (< (inv@629@04 r) V@15@04) (<= 0 (inv@629@04 r)))
            $Perm.Write
            $Perm.No)
          $Perm.No))
      (ite
        (and (< (inv@629@04 r) V@15@04) (<= 0 (inv@629@04 r)))
        (<
          (ite
            (and (< (inv@633@04 r) V@15@04) (<= 0 (inv@633@04 r)))
            $k@632@04
            $Perm.No)
          $Perm.Write)
        (<
          (ite
            (and (< (inv@633@04 r) V@15@04) (<= 0 (inv@633@04 r)))
            $k@632@04
            $Perm.No)
          $Perm.No)))
    :pattern ((inv@629@04 r))
    :pattern ((inv@633@04 r))
    :qid |qp.srp496|))))
(pop) ; 20
(pop) ; 19
; Joined path conditions
(assert ($Perm.isReadVar $k@632@04 $Perm.Write))
(assert (forall ((i1@631@04 Int)) (!
  (implies
    (and (and (< i1@631@04 V@15@04) (<= 0 i1@631@04)) (< $Perm.No $k@632@04))
    (=
      (inv@633@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i1@631@04))
      i1@631@04))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i1@631@04))
  :qid |int-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and (< (inv@633@04 r) V@15@04) (<= 0 (inv@633@04 r)))
      (< $Perm.No $k@632@04))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) (inv@633@04 r))
      r))
  :pattern ((inv@633@04 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (iff
    (Set_in r ($FVF.domain_int (as sm@638@04  $FVF<Int>)))
    (and
      (and (< (inv@633@04 r) V@15@04) (<= 0 (inv@633@04 r)))
      (< $Perm.No $k@632@04)))
  :pattern ((Set_in r ($FVF.domain_int (as sm@638@04  $FVF<Int>))))
  :qid |qp.fvfDomDef502|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@633@04 r) V@15@04) (<= 0 (inv@633@04 r)))
        (< $Perm.No $k@632@04))
      (and (< (inv@629@04 r) V@15@04) (<= 0 (inv@629@04 r))))
    (=
      ($FVF.lookup_int (as sm@638@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@614@04)))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@638@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@614@04)))))))))))))))) r))
  :qid |qp.fvfValDef497|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@633@04 r) V@15@04) (<= 0 (inv@633@04 r)))
        (< $Perm.No $k@632@04))
      (and
        (and
          (and (< (inv@626@04 r) V@15@04) (<= 0 (inv@626@04 r)))
          (< (inv@625@04 r) V@15@04))
        (<= 0 (inv@625@04 r))))
    (=
      ($FVF.lookup_int (as sm@638@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@614@04))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@638@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@614@04))))))))))))))) r))
  :qid |qp.fvfValDef498|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@633@04 r) V@15@04) (<= 0 (inv@633@04 r)))
        (< $Perm.No $k@632@04))
      (<
        $Perm.No
        (-
          (-
            (ite
              (and (< (inv@457@04 r) V@15@04) (<= 0 (inv@457@04 r)))
              $Perm.Write
              $Perm.No)
            (pTaken@595@04 r))
          (pTaken@603@04 r))))
    (=
      ($FVF.lookup_int (as sm@638@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04)))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@638@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04)))))))))))))) r))
  :qid |qp.fvfValDef499|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@633@04 r) V@15@04) (<= 0 (inv@633@04 r)))
        (< $Perm.No $k@632@04))
      (<
        $Perm.No
        (-
          (-
            (-
              (ite
                (and
                  (and
                    (and (< (inv@366@04 r) V@15@04) (<= 0 (inv@366@04 r)))
                    (< (inv@365@04 r) V@15@04))
                  (<= 0 (inv@365@04 r)))
                $Perm.Write
                $Perm.No)
              (pTaken@481@04 r))
            (pTaken@485@04 r))
          (pTaken@601@04 r))))
    (=
      ($FVF.lookup_int (as sm@638@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@638@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))))))) r))
  :qid |qp.fvfValDef500|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@614@04)))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@614@04))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04)))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@638@04  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef501|)))
(assert (implies
  (= exc@612@04 $Ref.null)
  (and
    (forall ((i1@631@04 Int)) (!
      (< i1@631@04 (alen<Int> (opt_get1 $Snap.unit P@14@04)))
      :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i1@631@04))
      :qid |int-aux|))
    (forall ((r $Ref)) (!
      (implies
        (and (< (inv@633@04 r) V@15@04) (<= 0 (inv@633@04 r)))
        ($FVF.loc_int ($FVF.lookup_int (as sm@630@04  $FVF<Int>) r) r))
      :pattern ((inv@633@04 r))
      ))
    (forall ((r $Ref)) (!
      (implies
        (not
          (=
            (ite
              (and (< (inv@629@04 r) V@15@04) (<= 0 (inv@629@04 r)))
              $Perm.Write
              $Perm.No)
            $Perm.No))
        (ite
          (and (< (inv@629@04 r) V@15@04) (<= 0 (inv@629@04 r)))
          (<
            (ite
              (and (< (inv@633@04 r) V@15@04) (<= 0 (inv@633@04 r)))
              $k@632@04
              $Perm.No)
            $Perm.Write)
          (<
            (ite
              (and (< (inv@633@04 r) V@15@04) (<= 0 (inv@633@04 r)))
              $k@632@04
              $Perm.No)
            $Perm.No)))
      :pattern ((inv@629@04 r))
      :pattern ((inv@633@04 r))
      :qid |qp.srp496|)))))
(assert (implies
  (= exc@612@04 $Ref.null)
  (valid_graph_vertices ($Snap.combine
    $Snap.unit
    ($Snap.combine
      $Snap.unit
      ($Snap.combine
        $Snap.unit
        ($SortWrappers.$FVF<Int>To$Snap (as sm@638@04  $FVF<Int>))))) this@9@04 P@14@04 V@15@04)))
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
; [eval] exc != null
; [then-branch: 344 | exc@612@04 != Null | dead]
; [else-branch: 344 | exc@612@04 == Null | live]
(push) ; 19
; [else-branch: 344 | exc@612@04 == Null]
(pop) ; 19
; [eval] !(exc != null)
; [eval] exc != null
(set-option :timeout 10)
(push) ; 19
(assert (not (not (= exc@612@04 $Ref.null))))
(check-sat)
; unknown
(pop) ; 19
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               32113832
;  :arith-add-rows          6491496
;  :arith-assert-diseq      213712
;  :arith-assert-lower      5734330
;  :arith-assert-upper      4974974
;  :arith-bound-prop        142744
;  :arith-conflicts         3646
;  :arith-eq-adapter        2109422
;  :arith-fixed-eqs         5331800
;  :arith-offset-eqs        3362387
;  :arith-pivots            936019
;  :conflicts               8474
;  :datatype-accessor-ax    2759
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1326679
;  :del-clause              81309081
;  :final-checks            5
;  :max-generation          15
;  :max-memory              541.79
;  :memory                  502.79
;  :minimized-lits          1321
;  :mk-bool-var             69133967
;  :mk-clause               81311664
;  :num-allocs              163722507
;  :num-checks              718
;  :propagations            24207743
;  :quant-instantiations    28460962
;  :restarts                18
;  :rlimit-count            644367113
;  :time                    0.01)
; [then-branch: 345 | exc@612@04 == Null | live]
; [else-branch: 345 | exc@612@04 != Null | dead]
(push) ; 19
; [then-branch: 345 | exc@612@04 == Null]
; Loop head block: Re-establish invariant
; [eval] exc == excBeforeLoop
; [eval] G != (None(): option[array])
; [eval] (None(): option[array])
; [eval] alen(opt_get1(G)) == V
; [eval] alen(opt_get1(G))
; [eval] opt_get1(G)
(push) ; 20
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 20
; Joined path conditions
(declare-const i1@639@04 Int)
(push) ; 20
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 21
; [then-branch: 346 | 0 <= i1@639@04 | live]
; [else-branch: 346 | !(0 <= i1@639@04) | live]
(push) ; 22
; [then-branch: 346 | 0 <= i1@639@04]
(assert (<= 0 i1@639@04))
; [eval] i1 < V
(pop) ; 22
(push) ; 22
; [else-branch: 346 | !(0 <= i1@639@04)]
(assert (not (<= 0 i1@639@04)))
(pop) ; 22
(pop) ; 21
; Joined path conditions
; Joined path conditions
(assert (and (< i1@639@04 V@15@04) (<= 0 i1@639@04)))
(declare-const $k@640@04 $Perm)
(assert ($Perm.isReadVar $k@640@04 $Perm.Write))
; [eval] aloc(opt_get1(G), i1)
; [eval] opt_get1(G)
(push) ; 21
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 21
; Joined path conditions
(push) ; 21
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 22
(assert (not (< i1@639@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))))
(check-sat)
; unsat
(pop) ; 22
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               32113839
;  :arith-add-rows          6491497
;  :arith-assert-diseq      213715
;  :arith-assert-lower      5734336
;  :arith-assert-upper      4974975
;  :arith-bound-prop        142745
;  :arith-conflicts         3646
;  :arith-eq-adapter        2109423
;  :arith-fixed-eqs         5331800
;  :arith-offset-eqs        3362393
;  :arith-pivots            936019
;  :conflicts               8474
;  :datatype-accessor-ax    2759
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1326679
;  :del-clause              81309081
;  :final-checks            5
;  :max-generation          15
;  :max-memory              541.79
;  :memory                  502.79
;  :minimized-lits          1321
;  :mk-bool-var             69133973
;  :mk-clause               81311667
;  :num-allocs              163722678
;  :num-checks              719
;  :propagations            24207748
;  :quant-instantiations    28460962
;  :restarts                18
;  :rlimit-count            644367467)
(assert (< i1@639@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(pop) ; 21
; Joined path conditions
(assert (< i1@639@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(pop) ; 20
(declare-fun inv@641@04 ($Ref) Int)
; Nested auxiliary terms: globals
(assert ($Perm.isReadVar $k@640@04 $Perm.Write))
; Nested auxiliary terms: non-globals
(assert (forall ((i1@639@04 Int)) (!
  (< i1@639@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@639@04))
  :qid |option$array$-aux|)))
(push) ; 20
(assert (not (forall ((i1@639@04 Int)) (!
  (implies
    (and (< i1@639@04 V@15@04) (<= 0 i1@639@04))
    (or (= $k@640@04 $Perm.No) (< $Perm.No $k@640@04)))
  
  ))))
(check-sat)
; unsat
(pop) ; 20
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               32113839
;  :arith-add-rows          6491498
;  :arith-assert-diseq      213716
;  :arith-assert-lower      5734338
;  :arith-assert-upper      4974976
;  :arith-bound-prop        142745
;  :arith-conflicts         3646
;  :arith-eq-adapter        2109424
;  :arith-fixed-eqs         5331800
;  :arith-offset-eqs        3362393
;  :arith-pivots            936019
;  :conflicts               8475
;  :datatype-accessor-ax    2759
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1326679
;  :del-clause              81309084
;  :final-checks            5
;  :max-generation          15
;  :max-memory              541.79
;  :memory                  502.79
;  :minimized-lits          1321
;  :mk-bool-var             69133980
;  :mk-clause               81311669
;  :num-allocs              163723109
;  :num-checks              720
;  :propagations            24207749
;  :quant-instantiations    28460962
;  :restarts                18
;  :rlimit-count            644368014)
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 20
(assert (not (forall ((i11@639@04 Int) (i12@639@04 Int)) (!
  (implies
    (and
      (and
        (and
          (and (< i11@639@04 V@15@04) (<= 0 i11@639@04))
          ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@618@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i11@639@04)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i11@639@04)))
        (< $Perm.No $k@640@04))
      (and
        (and
          (and (< i12@639@04 V@15@04) (<= 0 i12@639@04))
          ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@618@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i12@639@04)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i12@639@04)))
        (< $Perm.No $k@640@04))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i11@639@04)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i12@639@04)))
    (= i11@639@04 i12@639@04))
  
  :qid |option$array$-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 20
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               32113903
;  :arith-add-rows          6491511
;  :arith-assert-diseq      213717
;  :arith-assert-lower      5734342
;  :arith-assert-upper      4974976
;  :arith-bound-prop        142746
;  :arith-conflicts         3646
;  :arith-eq-adapter        2109425
;  :arith-fixed-eqs         5331800
;  :arith-offset-eqs        3362393
;  :arith-pivots            936021
;  :conflicts               8476
;  :datatype-accessor-ax    2759
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1326679
;  :del-clause              81309126
;  :final-checks            5
;  :max-generation          15
;  :max-memory              541.79
;  :memory                  502.74
;  :minimized-lits          1321
;  :mk-bool-var             69134114
;  :mk-clause               81311711
;  :num-allocs              163724290
;  :num-checks              721
;  :propagations            24207757
;  :quant-instantiations    28461077
;  :restarts                18
;  :rlimit-count            644371979
;  :time                    0.00)
; Definitional axioms for inverse functions
(assert (forall ((i1@639@04 Int)) (!
  (implies
    (and (and (< i1@639@04 V@15@04) (<= 0 i1@639@04)) (< $Perm.No $k@640@04))
    (=
      (inv@641@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@639@04))
      i1@639@04))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@639@04))
  :qid |option$array$-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and (< (inv@641@04 r) V@15@04) (<= 0 (inv@641@04 r)))
      (< $Perm.No $k@640@04))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) (inv@641@04 r))
      r))
  :pattern ((inv@641@04 r))
  :qid |option$array$-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@641@04 r) V@15@04) (<= 0 (inv@641@04 r)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@618@04  $FVF<option<array>>) r) r))
  :pattern ((inv@641@04 r))
  )))
; Precomputing data for removing quantified permissions
(define-fun pTaken@642@04 ((r $Ref)) $Perm
  (ite
    (and (< (inv@641@04 r) V@15@04) (<= 0 (inv@641@04 r)))
    ($Perm.min
      (ite
        (and (< (inv@617@04 r) V@15@04) (<= 0 (inv@617@04 r)))
        $k@616@04
        $Perm.No)
      $k@640@04)
    $Perm.No))
(define-fun pTaken@643@04 ((r $Ref)) $Perm
  (ite
    (and (< (inv@641@04 r) V@15@04) (<= 0 (inv@641@04 r)))
    ($Perm.min
      (ite
        (and (< (inv@445@04 r) V@15@04) (<= 0 (inv@445@04 r)))
        $k@444@04
        $Perm.No)
      (- $k@640@04 (pTaken@642@04 r)))
    $Perm.No))
(define-fun pTaken@644@04 ((r $Ref)) $Perm
  (ite
    (and (< (inv@641@04 r) V@15@04) (<= 0 (inv@641@04 r)))
    ($Perm.min
      (ite
        (and (< (inv@357@04 r) V@15@04) (<= 0 (inv@357@04 r)))
        $k@356@04
        $Perm.No)
      (- (- $k@640@04 (pTaken@642@04 r)) (pTaken@643@04 r)))
    $Perm.No))
(define-fun pTaken@645@04 ((r $Ref)) $Perm
  (ite
    (and (< (inv@641@04 r) V@15@04) (<= 0 (inv@641@04 r)))
    ($Perm.min
      (-
        (-
          (-
            (ite
              (and (< (inv@296@04 r) V@15@04) (<= 0 (inv@296@04 r)))
              $k@295@04
              $Perm.No)
            (pTaken@380@04 r))
          (pTaken@469@04 r))
        (pTaken@583@04 r))
      (- (- (- $k@640@04 (pTaken@642@04 r)) (pTaken@643@04 r)) (pTaken@644@04 r)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Constrain original permissions $k@640@04
(assert (forall ((r $Ref)) (!
  (implies
    (not
      (=
        (ite
          (and (< (inv@617@04 r) V@15@04) (<= 0 (inv@617@04 r)))
          $k@616@04
          $Perm.No)
        $Perm.No))
    (ite
      (and (< (inv@617@04 r) V@15@04) (<= 0 (inv@617@04 r)))
      (<
        (ite
          (and (< (inv@641@04 r) V@15@04) (<= 0 (inv@641@04 r)))
          $k@640@04
          $Perm.No)
        $k@616@04)
      (<
        (ite
          (and (< (inv@641@04 r) V@15@04) (<= 0 (inv@641@04 r)))
          $k@640@04
          $Perm.No)
        $Perm.No)))
  :pattern ((inv@617@04 r))
  :pattern ((inv@641@04 r))
  :qid |qp.srp503|)))
; Intermediate check if already taken enough permissions
(set-option :timeout 500)
(push) ; 20
(assert (not (forall ((r $Ref)) (!
  (implies
    (and (< (inv@641@04 r) V@15@04) (<= 0 (inv@641@04 r)))
    (= (- $k@640@04 (pTaken@642@04 r)) $Perm.No))
  
  ))))
(check-sat)
; unsat
(pop) ; 20
; 0.05s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               32115224
;  :arith-add-rows          6492992
;  :arith-assert-diseq      213747
;  :arith-assert-lower      5734554
;  :arith-assert-upper      4975136
;  :arith-bound-prop        142769
;  :arith-conflicts         3649
;  :arith-eq-adapter        2109594
;  :arith-fixed-eqs         5331974
;  :arith-offset-eqs        3362442
;  :arith-pivots            936123
;  :conflicts               8496
;  :datatype-accessor-ax    2763
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1327118
;  :del-clause              81324741
;  :final-checks            5
;  :max-generation          15
;  :max-memory              541.79
;  :memory                  502.79
;  :minimized-lits          1323
;  :mk-bool-var             69145761
;  :mk-clause               81327326
;  :num-allocs              163761355
;  :num-checks              723
;  :propagations            24209700
;  :quant-instantiations    28464056
;  :restarts                18
;  :rlimit-count            644544480
;  :time                    0.05)
; Final check if taken enough permissions
; Done removing quantified permissions
; Definitional axioms for snapshot map values
; [eval] (forall i1: Int :: { aloc(opt_get1(G), i1) } 0 <= i1 && i1 < V ==> aloc(opt_get1(G), i1).option$array$ != (None(): option[array]))
(declare-const i1@646@04 Int)
(push) ; 20
; [eval] 0 <= i1 && i1 < V ==> aloc(opt_get1(G), i1).option$array$ != (None(): option[array])
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 21
; [then-branch: 347 | 0 <= i1@646@04 | live]
; [else-branch: 347 | !(0 <= i1@646@04) | live]
(push) ; 22
; [then-branch: 347 | 0 <= i1@646@04]
(assert (<= 0 i1@646@04))
; [eval] i1 < V
(pop) ; 22
(push) ; 22
; [else-branch: 347 | !(0 <= i1@646@04)]
(assert (not (<= 0 i1@646@04)))
(pop) ; 22
(pop) ; 21
; Joined path conditions
; Joined path conditions
(push) ; 21
; [then-branch: 348 | i1@646@04 < V@15@04 && 0 <= i1@646@04 | live]
; [else-branch: 348 | !(i1@646@04 < V@15@04 && 0 <= i1@646@04) | live]
(push) ; 22
; [then-branch: 348 | i1@646@04 < V@15@04 && 0 <= i1@646@04]
(assert (and (< i1@646@04 V@15@04) (<= 0 i1@646@04)))
; [eval] aloc(opt_get1(G), i1).option$array$ != (None(): option[array])
; [eval] aloc(opt_get1(G), i1)
; [eval] opt_get1(G)
(push) ; 23
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 23
; Joined path conditions
(push) ; 23
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 24
(assert (not (< i1@646@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))))
(check-sat)
; unsat
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               32115231
;  :arith-add-rows          6492993
;  :arith-assert-diseq      213749
;  :arith-assert-lower      5734558
;  :arith-assert-upper      4975136
;  :arith-bound-prop        142770
;  :arith-conflicts         3649
;  :arith-eq-adapter        2109594
;  :arith-fixed-eqs         5331974
;  :arith-offset-eqs        3362448
;  :arith-pivots            936124
;  :conflicts               8496
;  :datatype-accessor-ax    2763
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1327118
;  :del-clause              81324741
;  :final-checks            5
;  :max-generation          15
;  :max-memory              541.79
;  :memory                  502.79
;  :minimized-lits          1323
;  :mk-bool-var             69145763
;  :mk-clause               81327327
;  :num-allocs              163761464
;  :num-checks              724
;  :propagations            24209704
;  :quant-instantiations    28464056
;  :restarts                18
;  :rlimit-count            644544699)
(assert (< i1@646@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(pop) ; 23
; Joined path conditions
(assert (< i1@646@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@618@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@646@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@646@04)))
(push) ; 23
(assert (not (<
  $Perm.No
  (+
    (+
      (+
        (ite
          (and
            (<
              (inv@617@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@646@04))
              V@15@04)
            (<=
              0
              (inv@617@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@646@04))))
          $k@616@04
          $Perm.No)
        (ite
          (and
            (<
              (inv@445@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@646@04))
              V@15@04)
            (<=
              0
              (inv@445@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@646@04))))
          $k@444@04
          $Perm.No))
      (ite
        (and
          (<
            (inv@357@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@646@04))
            V@15@04)
          (<=
            0
            (inv@357@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@646@04))))
        $k@356@04
        $Perm.No))
    (-
      (-
        (-
          (ite
            (and
              (<
                (inv@296@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@646@04))
                V@15@04)
              (<=
                0
                (inv@296@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@646@04))))
            $k@295@04
            $Perm.No)
          (pTaken@380@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@646@04)))
        (pTaken@469@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@646@04)))
      (pTaken@583@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@646@04)))))))
(check-sat)
; unsat
(pop) ; 23
; 0.06s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               32116421
;  :arith-add-rows          6494462
;  :arith-assert-diseq      213764
;  :arith-assert-lower      5734713
;  :arith-assert-upper      4975247
;  :arith-bound-prop        142833
;  :arith-conflicts         3652
;  :arith-eq-adapter        2109705
;  :arith-fixed-eqs         5332091
;  :arith-offset-eqs        3362515
;  :arith-pivots            936201
;  :conflicts               8515
;  :datatype-accessor-ax    2767
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1327528
;  :del-clause              81337800
;  :final-checks            5
;  :max-generation          15
;  :max-memory              541.79
;  :memory                  502.85
;  :minimized-lits          1323
;  :mk-bool-var             69155871
;  :mk-clause               81341051
;  :num-allocs              163792482
;  :num-checks              725
;  :propagations            24211424
;  :quant-instantiations    28466340
;  :restarts                18
;  :rlimit-count            644683323
;  :time                    0.06)
; [eval] (None(): option[array])
(pop) ; 22
(push) ; 22
; [else-branch: 348 | !(i1@646@04 < V@15@04 && 0 <= i1@646@04)]
(assert (not (and (< i1@646@04 V@15@04) (<= 0 i1@646@04))))
(pop) ; 22
(pop) ; 21
; Joined path conditions
(assert (implies
  (and (< i1@646@04 V@15@04) (<= 0 i1@646@04))
  (and
    (< i1@646@04 V@15@04)
    (<= 0 i1@646@04)
    (< i1@646@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@618@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@646@04)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@646@04)))))
; Joined path conditions
(pop) ; 20
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@646@04 Int)) (!
  (implies
    (and (< i1@646@04 V@15@04) (<= 0 i1@646@04))
    (and
      (< i1@646@04 V@15@04)
      (<= 0 i1@646@04)
      (< i1@646@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@618@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@646@04)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@646@04))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@646@04))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(push) ; 20
(assert (not (forall ((i1@646@04 Int)) (!
  (implies
    (and (< i1@646@04 V@15@04) (<= 0 i1@646@04))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@618@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@646@04))
        (as None<option<array>>  option<array>))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@646@04))
  :qid |prog.l<no position>|))))
(check-sat)
; unsat
(pop) ; 20
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               32116454
;  :arith-add-rows          6494541
;  :arith-assert-diseq      213766
;  :arith-assert-lower      5734723
;  :arith-assert-upper      4975253
;  :arith-bound-prop        142841
;  :arith-conflicts         3652
;  :arith-eq-adapter        2109714
;  :arith-fixed-eqs         5332097
;  :arith-offset-eqs        3362534
;  :arith-pivots            936246
;  :conflicts               8516
;  :datatype-accessor-ax    2767
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1327528
;  :del-clause              81338752
;  :final-checks            5
;  :max-generation          15
;  :max-memory              541.79
;  :memory                  502.80
;  :minimized-lits          1323
;  :mk-bool-var             69156227
;  :mk-clause               81341337
;  :num-allocs              163795170
;  :num-checks              726
;  :propagations            24211444
;  :quant-instantiations    28466536
;  :restarts                18
;  :rlimit-count            644693808
;  :time                    0.01)
(assert (forall ((i1@646@04 Int)) (!
  (implies
    (and (< i1@646@04 V@15@04) (<= 0 i1@646@04))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@618@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@646@04))
        (as None<option<array>>  option<array>))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@646@04))
  :qid |prog.l<no position>|)))
; [eval] (forall i1: Int :: { alen(opt_get1(aloc(opt_get1(G), i1).option$array$)) } 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(G), i1).option$array$)) == V)
(declare-const i1@647@04 Int)
(push) ; 20
; [eval] 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(G), i1).option$array$)) == V
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 21
; [then-branch: 349 | 0 <= i1@647@04 | live]
; [else-branch: 349 | !(0 <= i1@647@04) | live]
(push) ; 22
; [then-branch: 349 | 0 <= i1@647@04]
(assert (<= 0 i1@647@04))
; [eval] i1 < V
(pop) ; 22
(push) ; 22
; [else-branch: 349 | !(0 <= i1@647@04)]
(assert (not (<= 0 i1@647@04)))
(pop) ; 22
(pop) ; 21
; Joined path conditions
; Joined path conditions
(push) ; 21
; [then-branch: 350 | i1@647@04 < V@15@04 && 0 <= i1@647@04 | live]
; [else-branch: 350 | !(i1@647@04 < V@15@04 && 0 <= i1@647@04) | live]
(push) ; 22
; [then-branch: 350 | i1@647@04 < V@15@04 && 0 <= i1@647@04]
(assert (and (< i1@647@04 V@15@04) (<= 0 i1@647@04)))
; [eval] alen(opt_get1(aloc(opt_get1(G), i1).option$array$)) == V
; [eval] alen(opt_get1(aloc(opt_get1(G), i1).option$array$))
; [eval] opt_get1(aloc(opt_get1(G), i1).option$array$)
; [eval] aloc(opt_get1(G), i1)
; [eval] opt_get1(G)
(push) ; 23
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 23
; Joined path conditions
(push) ; 23
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 24
(assert (not (< i1@647@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))))
(check-sat)
; unsat
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               32116461
;  :arith-add-rows          6494542
;  :arith-assert-diseq      213768
;  :arith-assert-lower      5734727
;  :arith-assert-upper      4975253
;  :arith-bound-prop        142842
;  :arith-conflicts         3652
;  :arith-eq-adapter        2109714
;  :arith-fixed-eqs         5332097
;  :arith-offset-eqs        3362540
;  :arith-pivots            936247
;  :conflicts               8516
;  :datatype-accessor-ax    2767
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1327528
;  :del-clause              81338752
;  :final-checks            5
;  :max-generation          15
;  :max-memory              541.79
;  :memory                  502.80
;  :minimized-lits          1323
;  :mk-bool-var             69156230
;  :mk-clause               81341338
;  :num-allocs              163795473
;  :num-checks              727
;  :propagations            24211448
;  :quant-instantiations    28466536
;  :restarts                18
;  :rlimit-count            644694336)
(assert (< i1@647@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(pop) ; 23
; Joined path conditions
(assert (< i1@647@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@618@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@647@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@647@04)))
(push) ; 23
(assert (not (<
  $Perm.No
  (+
    (+
      (+
        (ite
          (and
            (<
              (inv@617@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@647@04))
              V@15@04)
            (<=
              0
              (inv@617@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@647@04))))
          $k@616@04
          $Perm.No)
        (ite
          (and
            (<
              (inv@445@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@647@04))
              V@15@04)
            (<=
              0
              (inv@445@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@647@04))))
          $k@444@04
          $Perm.No))
      (ite
        (and
          (<
            (inv@357@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@647@04))
            V@15@04)
          (<=
            0
            (inv@357@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@647@04))))
        $k@356@04
        $Perm.No))
    (-
      (-
        (-
          (ite
            (and
              (<
                (inv@296@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@647@04))
                V@15@04)
              (<=
                0
                (inv@296@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@647@04))))
            $k@295@04
            $Perm.No)
          (pTaken@380@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@647@04)))
        (pTaken@469@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@647@04)))
      (pTaken@583@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@647@04)))))))
(check-sat)
; unsat
(pop) ; 23
; 0.06s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               32117658
;  :arith-add-rows          6496013
;  :arith-assert-diseq      213783
;  :arith-assert-lower      5734882
;  :arith-assert-upper      4975364
;  :arith-bound-prop        142906
;  :arith-conflicts         3655
;  :arith-eq-adapter        2109826
;  :arith-fixed-eqs         5332214
;  :arith-offset-eqs        3362607
;  :arith-pivots            936323
;  :conflicts               8535
;  :datatype-accessor-ax    2771
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1327939
;  :del-clause              81351812
;  :final-checks            5
;  :max-generation          15
;  :max-memory              541.79
;  :memory                  502.86
;  :minimized-lits          1323
;  :mk-bool-var             69166344
;  :mk-clause               81355063
;  :num-allocs              163826705
;  :num-checks              728
;  :propagations            24213165
;  :quant-instantiations    28468823
;  :restarts                18
;  :rlimit-count            644835488
;  :time                    0.06)
(push) ; 23
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 24
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@618@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@647@04))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               32117658
;  :arith-add-rows          6496013
;  :arith-assert-diseq      213783
;  :arith-assert-lower      5734882
;  :arith-assert-upper      4975364
;  :arith-bound-prop        142906
;  :arith-conflicts         3655
;  :arith-eq-adapter        2109826
;  :arith-fixed-eqs         5332214
;  :arith-offset-eqs        3362607
;  :arith-pivots            936323
;  :conflicts               8536
;  :datatype-accessor-ax    2771
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1327939
;  :del-clause              81351812
;  :final-checks            5
;  :max-generation          15
;  :max-memory              541.79
;  :memory                  502.86
;  :minimized-lits          1323
;  :mk-bool-var             69166344
;  :mk-clause               81355063
;  :num-allocs              163826795
;  :num-checks              729
;  :propagations            24213165
;  :quant-instantiations    28468823
;  :restarts                18
;  :rlimit-count            644835583)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@618@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@647@04))
    (as None<option<array>>  option<array>))))
(pop) ; 23
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@618@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@647@04))
    (as None<option<array>>  option<array>))))
(pop) ; 22
(push) ; 22
; [else-branch: 350 | !(i1@647@04 < V@15@04 && 0 <= i1@647@04)]
(assert (not (and (< i1@647@04 V@15@04) (<= 0 i1@647@04))))
(pop) ; 22
(pop) ; 21
; Joined path conditions
(assert (implies
  (and (< i1@647@04 V@15@04) (<= 0 i1@647@04))
  (and
    (< i1@647@04 V@15@04)
    (<= 0 i1@647@04)
    (< i1@647@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@618@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@647@04)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@647@04))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@618@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@647@04))
        (as None<option<array>>  option<array>))))))
; Joined path conditions
(pop) ; 20
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@647@04 Int)) (!
  (implies
    (and (< i1@647@04 V@15@04) (<= 0 i1@647@04))
    (and
      (< i1@647@04 V@15@04)
      (<= 0 i1@647@04)
      (< i1@647@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@618@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@647@04)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@647@04))
      (not
        (=
          ($FVF.lookup_option$array$ (as sm@618@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@647@04))
          (as None<option<array>>  option<array>)))))
  :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@618@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@647@04)))))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(push) ; 20
(assert (not (forall ((i1@647@04 Int)) (!
  (implies
    (and (< i1@647@04 V@15@04) (<= 0 i1@647@04))
    (=
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@618@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@647@04))))
      V@15@04))
  :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@618@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@647@04)))))
  :qid |prog.l<no position>|))))
(check-sat)
; unsat
(pop) ; 20
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               32117658
;  :arith-add-rows          6496047
;  :arith-assert-diseq      213783
;  :arith-assert-lower      5734884
;  :arith-assert-upper      4975364
;  :arith-bound-prop        142907
;  :arith-conflicts         3655
;  :arith-eq-adapter        2109833
;  :arith-fixed-eqs         5332214
;  :arith-offset-eqs        3362607
;  :arith-pivots            936354
;  :conflicts               8537
;  :datatype-accessor-ax    2771
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1327939
;  :del-clause              81352547
;  :final-checks            5
;  :max-generation          15
;  :max-memory              541.79
;  :memory                  502.80
;  :minimized-lits          1323
;  :mk-bool-var             69166462
;  :mk-clause               81355132
;  :num-allocs              163827833
;  :num-checks              730
;  :propagations            24213165
;  :quant-instantiations    28468893
;  :restarts                18
;  :rlimit-count            644838962
;  :time                    0.01)
(assert (forall ((i1@647@04 Int)) (!
  (implies
    (and (< i1@647@04 V@15@04) (<= 0 i1@647@04))
    (=
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@618@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@647@04))))
      V@15@04))
  :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@618@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@647@04)))))
  :qid |prog.l<no position>|)))
; [eval] (forall i1: Int :: { aloc(opt_get1(G), i1) } (forall i2: Int :: { aloc(opt_get1(G), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(G), i1).option$array$ == aloc(opt_get1(G), i2).option$array$ ==> i1 == i2))
(declare-const i1@648@04 Int)
(push) ; 20
; [eval] (forall i2: Int :: { aloc(opt_get1(G), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(G), i1).option$array$ == aloc(opt_get1(G), i2).option$array$ ==> i1 == i2)
(declare-const i2@649@04 Int)
(push) ; 21
; [eval] 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(G), i1).option$array$ == aloc(opt_get1(G), i2).option$array$ ==> i1 == i2
; [eval] 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(G), i1).option$array$ == aloc(opt_get1(G), i2).option$array$
; [eval] 0 <= i1
(push) ; 22
; [then-branch: 351 | 0 <= i1@648@04 | live]
; [else-branch: 351 | !(0 <= i1@648@04) | live]
(push) ; 23
; [then-branch: 351 | 0 <= i1@648@04]
(assert (<= 0 i1@648@04))
; [eval] i1 < V
(push) ; 24
; [then-branch: 352 | i1@648@04 < V@15@04 | live]
; [else-branch: 352 | !(i1@648@04 < V@15@04) | live]
(push) ; 25
; [then-branch: 352 | i1@648@04 < V@15@04]
(assert (< i1@648@04 V@15@04))
; [eval] 0 <= i2
(push) ; 26
; [then-branch: 353 | 0 <= i2@649@04 | live]
; [else-branch: 353 | !(0 <= i2@649@04) | live]
(push) ; 27
; [then-branch: 353 | 0 <= i2@649@04]
(assert (<= 0 i2@649@04))
; [eval] i2 < V
(push) ; 28
; [then-branch: 354 | i2@649@04 < V@15@04 | live]
; [else-branch: 354 | !(i2@649@04 < V@15@04) | live]
(push) ; 29
; [then-branch: 354 | i2@649@04 < V@15@04]
(assert (< i2@649@04 V@15@04))
; [eval] aloc(opt_get1(G), i1).option$array$ == aloc(opt_get1(G), i2).option$array$
; [eval] aloc(opt_get1(G), i1)
; [eval] opt_get1(G)
(push) ; 30
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 30
; Joined path conditions
(push) ; 30
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 31
(assert (not (< i1@648@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))))
(check-sat)
; unsat
(pop) ; 31
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               32117665
;  :arith-add-rows          6496049
;  :arith-assert-diseq      213785
;  :arith-assert-lower      5734890
;  :arith-assert-upper      4975364
;  :arith-bound-prop        142908
;  :arith-conflicts         3655
;  :arith-eq-adapter        2109833
;  :arith-fixed-eqs         5332214
;  :arith-offset-eqs        3362613
;  :arith-pivots            936355
;  :conflicts               8537
;  :datatype-accessor-ax    2771
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1327939
;  :del-clause              81352547
;  :final-checks            5
;  :max-generation          15
;  :max-memory              541.79
;  :memory                  502.80
;  :minimized-lits          1323
;  :mk-bool-var             69166467
;  :mk-clause               81355133
;  :num-allocs              163828313
;  :num-checks              731
;  :propagations            24213169
;  :quant-instantiations    28468893
;  :restarts                18
;  :rlimit-count            644839636)
(assert (< i1@648@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(pop) ; 30
; Joined path conditions
(assert (< i1@648@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@618@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@648@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@648@04)))
(push) ; 30
(assert (not (<
  $Perm.No
  (+
    (+
      (+
        (ite
          (and
            (<
              (inv@617@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@648@04))
              V@15@04)
            (<=
              0
              (inv@617@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@648@04))))
          $k@616@04
          $Perm.No)
        (ite
          (and
            (<
              (inv@445@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@648@04))
              V@15@04)
            (<=
              0
              (inv@445@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@648@04))))
          $k@444@04
          $Perm.No))
      (ite
        (and
          (<
            (inv@357@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@648@04))
            V@15@04)
          (<=
            0
            (inv@357@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@648@04))))
        $k@356@04
        $Perm.No))
    (-
      (-
        (-
          (ite
            (and
              (<
                (inv@296@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@648@04))
                V@15@04)
              (<=
                0
                (inv@296@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@648@04))))
            $k@295@04
            $Perm.No)
          (pTaken@380@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@648@04)))
        (pTaken@469@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@648@04)))
      (pTaken@583@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@648@04)))))))
(check-sat)
; unsat
(pop) ; 30
; 0.06s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               32118856
;  :arith-add-rows          6497627
;  :arith-assert-diseq      213800
;  :arith-assert-lower      5735047
;  :arith-assert-upper      4975475
;  :arith-bound-prop        142972
;  :arith-conflicts         3658
;  :arith-eq-adapter        2109944
;  :arith-fixed-eqs         5332331
;  :arith-offset-eqs        3362694
;  :arith-pivots            936432
;  :conflicts               8556
;  :datatype-accessor-ax    2775
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1328348
;  :del-clause              81365607
;  :final-checks            5
;  :max-generation          15
;  :max-memory              541.79
;  :memory                  503.17
;  :minimized-lits          1323
;  :mk-bool-var             69176572
;  :mk-clause               81368858
;  :num-allocs              163859582
;  :num-checks              732
;  :propagations            24214886
;  :quant-instantiations    28471179
;  :restarts                18
;  :rlimit-count            644980901
;  :time                    0.06)
; [eval] aloc(opt_get1(G), i2)
; [eval] opt_get1(G)
(push) ; 30
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 30
; Joined path conditions
(push) ; 30
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 31
(assert (not (< i2@649@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))))
(check-sat)
; unsat
(pop) ; 31
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               32118856
;  :arith-add-rows          6497627
;  :arith-assert-diseq      213800
;  :arith-assert-lower      5735047
;  :arith-assert-upper      4975475
;  :arith-bound-prop        142972
;  :arith-conflicts         3658
;  :arith-eq-adapter        2109944
;  :arith-fixed-eqs         5332331
;  :arith-offset-eqs        3362694
;  :arith-pivots            936432
;  :conflicts               8556
;  :datatype-accessor-ax    2775
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1328348
;  :del-clause              81365607
;  :final-checks            5
;  :max-generation          15
;  :max-memory              541.79
;  :memory                  503.17
;  :minimized-lits          1323
;  :mk-bool-var             69176572
;  :mk-clause               81368858
;  :num-allocs              163859608
;  :num-checks              733
;  :propagations            24214886
;  :quant-instantiations    28471179
;  :restarts                18
;  :rlimit-count            644980931)
(assert (< i2@649@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(pop) ; 30
; Joined path conditions
(assert (< i2@649@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@618@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@649@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@649@04)))
(push) ; 30
(assert (not (<
  $Perm.No
  (+
    (+
      (+
        (ite
          (and
            (<
              (inv@617@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@649@04))
              V@15@04)
            (<=
              0
              (inv@617@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@649@04))))
          $k@616@04
          $Perm.No)
        (ite
          (and
            (<
              (inv@445@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@649@04))
              V@15@04)
            (<=
              0
              (inv@445@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@649@04))))
          $k@444@04
          $Perm.No))
      (ite
        (and
          (<
            (inv@357@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@649@04))
            V@15@04)
          (<=
            0
            (inv@357@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@649@04))))
        $k@356@04
        $Perm.No))
    (-
      (-
        (-
          (ite
            (and
              (<
                (inv@296@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@649@04))
                V@15@04)
              (<=
                0
                (inv@296@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@649@04))))
            $k@295@04
            $Perm.No)
          (pTaken@380@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@649@04)))
        (pTaken@469@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@649@04)))
      (pTaken@583@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@649@04)))))))
(check-sat)
; unsat
(pop) ; 30
; 0.08s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               32120619
;  :arith-add-rows          6499694
;  :arith-assert-diseq      213866
;  :arith-assert-lower      5735413
;  :arith-assert-upper      4975672
;  :arith-bound-prop        143095
;  :arith-conflicts         3666
;  :arith-eq-adapter        2110174
;  :arith-fixed-eqs         5332500
;  :arith-offset-eqs        3362827
;  :arith-pivots            936573
;  :conflicts               8585
;  :datatype-accessor-ax    2779
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1328869
;  :del-clause              81381054
;  :final-checks            5
;  :max-generation          15
;  :max-memory              541.79
;  :memory                  503.23
;  :minimized-lits          1323
;  :mk-bool-var             69188657
;  :mk-clause               81384758
;  :num-allocs              163897453
;  :num-checks              734
;  :propagations            24217254
;  :quant-instantiations    28473748
;  :restarts                18
;  :rlimit-count            645149416
;  :time                    0.08)
(pop) ; 29
(push) ; 29
; [else-branch: 354 | !(i2@649@04 < V@15@04)]
(assert (not (< i2@649@04 V@15@04)))
(pop) ; 29
(pop) ; 28
; Joined path conditions
(assert (implies
  (< i2@649@04 V@15@04)
  (and
    (< i2@649@04 V@15@04)
    (< i1@648@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@618@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@648@04)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@648@04))
    (< i2@649@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@618@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@649@04)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@649@04)))))
; Joined path conditions
(pop) ; 27
(push) ; 27
; [else-branch: 353 | !(0 <= i2@649@04)]
(assert (not (<= 0 i2@649@04)))
(pop) ; 27
(pop) ; 26
; Joined path conditions
(assert (implies
  (<= 0 i2@649@04)
  (and
    (<= 0 i2@649@04)
    (implies
      (< i2@649@04 V@15@04)
      (and
        (< i2@649@04 V@15@04)
        (< i1@648@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@618@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@648@04)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@648@04))
        (< i2@649@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@618@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@649@04)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@649@04)))))))
; Joined path conditions
(pop) ; 25
(push) ; 25
; [else-branch: 352 | !(i1@648@04 < V@15@04)]
(assert (not (< i1@648@04 V@15@04)))
(pop) ; 25
(pop) ; 24
; Joined path conditions
(assert (implies
  (< i1@648@04 V@15@04)
  (and
    (< i1@648@04 V@15@04)
    (implies
      (<= 0 i2@649@04)
      (and
        (<= 0 i2@649@04)
        (implies
          (< i2@649@04 V@15@04)
          (and
            (< i2@649@04 V@15@04)
            (< i1@648@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@618@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@648@04)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@648@04))
            (< i2@649@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@618@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@649@04)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@649@04)))))))))
; Joined path conditions
(pop) ; 23
(push) ; 23
; [else-branch: 351 | !(0 <= i1@648@04)]
(assert (not (<= 0 i1@648@04)))
(pop) ; 23
(pop) ; 22
; Joined path conditions
(assert (implies
  (<= 0 i1@648@04)
  (and
    (<= 0 i1@648@04)
    (implies
      (< i1@648@04 V@15@04)
      (and
        (< i1@648@04 V@15@04)
        (implies
          (<= 0 i2@649@04)
          (and
            (<= 0 i2@649@04)
            (implies
              (< i2@649@04 V@15@04)
              (and
                (< i2@649@04 V@15@04)
                (< i1@648@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@618@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@648@04)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@648@04))
                (< i2@649@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@618@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@649@04)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@649@04)))))))))))
; Joined path conditions
(push) ; 22
; [then-branch: 355 | Lookup(option$array$,sm@618@04,aloc((_, _), opt_get1(_, G@11@04), i1@648@04)) == Lookup(option$array$,sm@618@04,aloc((_, _), opt_get1(_, G@11@04), i2@649@04)) && i2@649@04 < V@15@04 && 0 <= i2@649@04 && i1@648@04 < V@15@04 && 0 <= i1@648@04 | live]
; [else-branch: 355 | !(Lookup(option$array$,sm@618@04,aloc((_, _), opt_get1(_, G@11@04), i1@648@04)) == Lookup(option$array$,sm@618@04,aloc((_, _), opt_get1(_, G@11@04), i2@649@04)) && i2@649@04 < V@15@04 && 0 <= i2@649@04 && i1@648@04 < V@15@04 && 0 <= i1@648@04) | live]
(push) ; 23
; [then-branch: 355 | Lookup(option$array$,sm@618@04,aloc((_, _), opt_get1(_, G@11@04), i1@648@04)) == Lookup(option$array$,sm@618@04,aloc((_, _), opt_get1(_, G@11@04), i2@649@04)) && i2@649@04 < V@15@04 && 0 <= i2@649@04 && i1@648@04 < V@15@04 && 0 <= i1@648@04]
(assert (and
  (and
    (and
      (and
        (=
          ($FVF.lookup_option$array$ (as sm@618@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@648@04))
          ($FVF.lookup_option$array$ (as sm@618@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@649@04)))
        (< i2@649@04 V@15@04))
      (<= 0 i2@649@04))
    (< i1@648@04 V@15@04))
  (<= 0 i1@648@04)))
; [eval] i1 == i2
(pop) ; 23
(push) ; 23
; [else-branch: 355 | !(Lookup(option$array$,sm@618@04,aloc((_, _), opt_get1(_, G@11@04), i1@648@04)) == Lookup(option$array$,sm@618@04,aloc((_, _), opt_get1(_, G@11@04), i2@649@04)) && i2@649@04 < V@15@04 && 0 <= i2@649@04 && i1@648@04 < V@15@04 && 0 <= i1@648@04)]
(assert (not
  (and
    (and
      (and
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@618@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@648@04))
            ($FVF.lookup_option$array$ (as sm@618@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@649@04)))
          (< i2@649@04 V@15@04))
        (<= 0 i2@649@04))
      (< i1@648@04 V@15@04))
    (<= 0 i1@648@04))))
(pop) ; 23
(pop) ; 22
; Joined path conditions
(assert (implies
  (and
    (and
      (and
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@618@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@648@04))
            ($FVF.lookup_option$array$ (as sm@618@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@649@04)))
          (< i2@649@04 V@15@04))
        (<= 0 i2@649@04))
      (< i1@648@04 V@15@04))
    (<= 0 i1@648@04))
  (and
    (=
      ($FVF.lookup_option$array$ (as sm@618@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@648@04))
      ($FVF.lookup_option$array$ (as sm@618@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@649@04)))
    (< i2@649@04 V@15@04)
    (<= 0 i2@649@04)
    (< i1@648@04 V@15@04)
    (<= 0 i1@648@04))))
; Joined path conditions
(pop) ; 21
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i2@649@04 Int)) (!
  (and
    (implies
      (<= 0 i1@648@04)
      (and
        (<= 0 i1@648@04)
        (implies
          (< i1@648@04 V@15@04)
          (and
            (< i1@648@04 V@15@04)
            (implies
              (<= 0 i2@649@04)
              (and
                (<= 0 i2@649@04)
                (implies
                  (< i2@649@04 V@15@04)
                  (and
                    (< i2@649@04 V@15@04)
                    (< i1@648@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
                    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@618@04  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@648@04)) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@648@04))
                    (< i2@649@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
                    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@618@04  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@649@04)) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@649@04))))))))))
    (implies
      (and
        (and
          (and
            (and
              (=
                ($FVF.lookup_option$array$ (as sm@618@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@648@04))
                ($FVF.lookup_option$array$ (as sm@618@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@649@04)))
              (< i2@649@04 V@15@04))
            (<= 0 i2@649@04))
          (< i1@648@04 V@15@04))
        (<= 0 i1@648@04))
      (and
        (=
          ($FVF.lookup_option$array$ (as sm@618@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@648@04))
          ($FVF.lookup_option$array$ (as sm@618@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@649@04)))
        (< i2@649@04 V@15@04)
        (<= 0 i2@649@04)
        (< i1@648@04 V@15@04)
        (<= 0 i1@648@04))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@649@04))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 20
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@648@04 Int)) (!
  (forall ((i2@649@04 Int)) (!
    (and
      (implies
        (<= 0 i1@648@04)
        (and
          (<= 0 i1@648@04)
          (implies
            (< i1@648@04 V@15@04)
            (and
              (< i1@648@04 V@15@04)
              (implies
                (<= 0 i2@649@04)
                (and
                  (<= 0 i2@649@04)
                  (implies
                    (< i2@649@04 V@15@04)
                    (and
                      (< i2@649@04 V@15@04)
                      (< i1@648@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
                      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@618@04  $FVF<option<array>>) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@648@04)) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@648@04))
                      (< i2@649@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
                      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@618@04  $FVF<option<array>>) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@649@04)) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@649@04))))))))))
      (implies
        (and
          (and
            (and
              (and
                (=
                  ($FVF.lookup_option$array$ (as sm@618@04  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@648@04))
                  ($FVF.lookup_option$array$ (as sm@618@04  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@649@04)))
                (< i2@649@04 V@15@04))
              (<= 0 i2@649@04))
            (< i1@648@04 V@15@04))
          (<= 0 i1@648@04))
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@618@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@648@04))
            ($FVF.lookup_option$array$ (as sm@618@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@649@04)))
          (< i2@649@04 V@15@04)
          (<= 0 i2@649@04)
          (< i1@648@04 V@15@04)
          (<= 0 i1@648@04))))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@649@04))
    :qid |prog.l<no position>-aux|))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@648@04))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(push) ; 20
(assert (not (forall ((i1@648@04 Int)) (!
  (forall ((i2@649@04 Int)) (!
    (implies
      (and
        (and
          (and
            (and
              (=
                ($FVF.lookup_option$array$ (as sm@618@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@648@04))
                ($FVF.lookup_option$array$ (as sm@618@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@649@04)))
              (< i2@649@04 V@15@04))
            (<= 0 i2@649@04))
          (< i1@648@04 V@15@04))
        (<= 0 i1@648@04))
      (= i1@648@04 i2@649@04))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@649@04))
    :qid |prog.l<no position>|))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@648@04))
  :qid |prog.l<no position>|))))
(check-sat)
; unsat
(pop) ; 20
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               32120838
;  :arith-add-rows          6499878
;  :arith-assert-diseq      213869
;  :arith-assert-lower      5735443
;  :arith-assert-upper      4975686
;  :arith-bound-prop        143111
;  :arith-conflicts         3666
;  :arith-eq-adapter        2110237
;  :arith-fixed-eqs         5332514
;  :arith-offset-eqs        3362848
;  :arith-pivots            936673
;  :conflicts               8586
;  :datatype-accessor-ax    2779
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1328869
;  :del-clause              81383099
;  :final-checks            5
;  :max-generation          15
;  :max-memory              541.79
;  :memory                  503.12
;  :minimized-lits          1323
;  :mk-bool-var             69190124
;  :mk-clause               81385684
;  :num-allocs              163904383
;  :num-checks              735
;  :propagations            24217315
;  :quant-instantiations    28474326
;  :restarts                18
;  :rlimit-count            645180783
;  :time                    0.01)
(assert (forall ((i1@648@04 Int)) (!
  (forall ((i2@649@04 Int)) (!
    (implies
      (and
        (and
          (and
            (and
              (=
                ($FVF.lookup_option$array$ (as sm@618@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@648@04))
                ($FVF.lookup_option$array$ (as sm@618@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@649@04)))
              (< i2@649@04 V@15@04))
            (<= 0 i2@649@04))
          (< i1@648@04 V@15@04))
        (<= 0 i1@648@04))
      (= i1@648@04 i2@649@04))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@649@04))
    :qid |prog.l<no position>|))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@648@04))
  :qid |prog.l<no position>|)))
(declare-const i1@650@04 Int)
(declare-const j@651@04 Int)
(push) ; 20
; [eval] 0 <= i1 && i1 < V && (0 <= j && j < V)
; [eval] 0 <= i1
(push) ; 21
; [then-branch: 356 | 0 <= i1@650@04 | live]
; [else-branch: 356 | !(0 <= i1@650@04) | live]
(push) ; 22
; [then-branch: 356 | 0 <= i1@650@04]
(assert (<= 0 i1@650@04))
; [eval] i1 < V
(push) ; 23
; [then-branch: 357 | i1@650@04 < V@15@04 | live]
; [else-branch: 357 | !(i1@650@04 < V@15@04) | live]
(push) ; 24
; [then-branch: 357 | i1@650@04 < V@15@04]
(assert (< i1@650@04 V@15@04))
; [eval] 0 <= j
(push) ; 25
; [then-branch: 358 | 0 <= j@651@04 | live]
; [else-branch: 358 | !(0 <= j@651@04) | live]
(push) ; 26
; [then-branch: 358 | 0 <= j@651@04]
(assert (<= 0 j@651@04))
; [eval] j < V
(pop) ; 26
(push) ; 26
; [else-branch: 358 | !(0 <= j@651@04)]
(assert (not (<= 0 j@651@04)))
(pop) ; 26
(pop) ; 25
; Joined path conditions
; Joined path conditions
(pop) ; 24
(push) ; 24
; [else-branch: 357 | !(i1@650@04 < V@15@04)]
(assert (not (< i1@650@04 V@15@04)))
(pop) ; 24
(pop) ; 23
; Joined path conditions
; Joined path conditions
(pop) ; 22
(push) ; 22
; [else-branch: 356 | !(0 <= i1@650@04)]
(assert (not (<= 0 i1@650@04)))
(pop) ; 22
(pop) ; 21
; Joined path conditions
; Joined path conditions
(assert (and
  (and (and (< j@651@04 V@15@04) (<= 0 j@651@04)) (< i1@650@04 V@15@04))
  (<= 0 i1@650@04)))
; [eval] aloc(opt_get1(aloc(opt_get1(G), i1).option$array$), j)
; [eval] opt_get1(aloc(opt_get1(G), i1).option$array$)
; [eval] aloc(opt_get1(G), i1)
; [eval] opt_get1(G)
(push) ; 21
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 21
; Joined path conditions
(push) ; 21
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 22
(assert (not (< i1@650@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))))
(check-sat)
; unsat
(pop) ; 22
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               32120852
;  :arith-add-rows          6499881
;  :arith-assert-diseq      213873
;  :arith-assert-lower      5735453
;  :arith-assert-upper      4975686
;  :arith-bound-prop        143113
;  :arith-conflicts         3666
;  :arith-eq-adapter        2110237
;  :arith-fixed-eqs         5332514
;  :arith-offset-eqs        3362860
;  :arith-pivots            936677
;  :conflicts               8586
;  :datatype-accessor-ax    2779
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1328869
;  :del-clause              81383100
;  :final-checks            5
;  :max-generation          15
;  :max-memory              541.79
;  :memory                  503.12
;  :minimized-lits          1323
;  :mk-bool-var             69190131
;  :mk-clause               81385686
;  :num-allocs              163904982
;  :num-checks              736
;  :propagations            24217323
;  :quant-instantiations    28474326
;  :restarts                18
;  :rlimit-count            645181850)
(assert (< i1@650@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(pop) ; 21
; Joined path conditions
(assert (< i1@650@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@618@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@650@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@650@04)))
(push) ; 21
(assert (not (<
  $Perm.No
  (+
    (+
      (+
        (ite
          (and
            (<
              (inv@617@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@650@04))
              V@15@04)
            (<=
              0
              (inv@617@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@650@04))))
          $k@616@04
          $Perm.No)
        (ite
          (and
            (<
              (inv@445@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@650@04))
              V@15@04)
            (<=
              0
              (inv@445@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@650@04))))
          $k@444@04
          $Perm.No))
      (ite
        (and
          (<
            (inv@357@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@650@04))
            V@15@04)
          (<=
            0
            (inv@357@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@650@04))))
        $k@356@04
        $Perm.No))
    (-
      (-
        (-
          (ite
            (and
              (<
                (inv@296@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@650@04))
                V@15@04)
              (<=
                0
                (inv@296@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@650@04))))
            $k@295@04
            $Perm.No)
          (pTaken@380@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@650@04)))
        (pTaken@469@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@650@04)))
      (pTaken@583@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@650@04)))))))
(check-sat)
; unsat
(pop) ; 21
; 0.05s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               32122045
;  :arith-add-rows          6501381
;  :arith-assert-diseq      213888
;  :arith-assert-lower      5735608
;  :arith-assert-upper      4975797
;  :arith-bound-prop        143176
;  :arith-conflicts         3669
;  :arith-eq-adapter        2110348
;  :arith-fixed-eqs         5332631
;  :arith-offset-eqs        3362927
;  :arith-pivots            936759
;  :conflicts               8605
;  :datatype-accessor-ax    2783
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1329280
;  :del-clause              81396165
;  :final-checks            5
;  :max-generation          15
;  :max-memory              541.79
;  :memory                  503.18
;  :minimized-lits          1323
;  :mk-bool-var             69200248
;  :mk-clause               81399416
;  :num-allocs              163936441
;  :num-checks              737
;  :propagations            24219042
;  :quant-instantiations    28476635
;  :restarts                18
;  :rlimit-count            645323578
;  :time                    0.05)
(push) ; 21
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 22
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@618@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@650@04))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 22
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               32122045
;  :arith-add-rows          6501381
;  :arith-assert-diseq      213888
;  :arith-assert-lower      5735608
;  :arith-assert-upper      4975797
;  :arith-bound-prop        143176
;  :arith-conflicts         3669
;  :arith-eq-adapter        2110348
;  :arith-fixed-eqs         5332631
;  :arith-offset-eqs        3362927
;  :arith-pivots            936759
;  :conflicts               8606
;  :datatype-accessor-ax    2783
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1329280
;  :del-clause              81396165
;  :final-checks            5
;  :max-generation          15
;  :max-memory              541.79
;  :memory                  503.18
;  :minimized-lits          1323
;  :mk-bool-var             69200248
;  :mk-clause               81399416
;  :num-allocs              163936531
;  :num-checks              738
;  :propagations            24219042
;  :quant-instantiations    28476635
;  :restarts                18
;  :rlimit-count            645323673)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@618@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@650@04))
    (as None<option<array>>  option<array>))))
(pop) ; 21
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@618@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@650@04))
    (as None<option<array>>  option<array>))))
(push) ; 21
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 22
(assert (not (<
  j@651@04
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@618@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@650@04)))))))
(check-sat)
; unsat
(pop) ; 22
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               32122049
;  :arith-add-rows          6501384
;  :arith-assert-diseq      213888
;  :arith-assert-lower      5735609
;  :arith-assert-upper      4975798
;  :arith-bound-prop        143178
;  :arith-conflicts         3669
;  :arith-eq-adapter        2110349
;  :arith-fixed-eqs         5332631
;  :arith-offset-eqs        3362927
;  :arith-pivots            936761
;  :conflicts               8607
;  :datatype-accessor-ax    2783
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1329280
;  :del-clause              81396171
;  :final-checks            5
;  :max-generation          15
;  :max-memory              541.79
;  :memory                  503.18
;  :minimized-lits          1323
;  :mk-bool-var             69200259
;  :mk-clause               81399422
;  :num-allocs              163936729
;  :num-checks              739
;  :propagations            24219042
;  :quant-instantiations    28476644
;  :restarts                18
;  :rlimit-count            645324143
;  :time                    0.00)
(assert (<
  j@651@04
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@618@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@650@04))))))
(pop) ; 21
; Joined path conditions
(assert (<
  j@651@04
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@618@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@650@04))))))
(pop) ; 20
(declare-fun inv@652@04 ($Ref) Int)
(declare-fun inv@653@04 ($Ref) Int)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(assert (forall ((i1@650@04 Int) (j@651@04 Int)) (!
  (and
    (< i1@650@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@618@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@650@04)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@650@04))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@618@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@650@04))
        (as None<option<array>>  option<array>)))
    (<
      j@651@04
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@618@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@650@04))))))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@618@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@650@04))) j@651@04))
  :qid |int-aux|)))
(declare-const sm@654@04 $FVF<Int>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (-
          (-
            (ite
              (and
                (and
                  (and (< (inv@366@04 r) V@15@04) (<= 0 (inv@366@04 r)))
                  (< (inv@365@04 r) V@15@04))
                (<= 0 (inv@365@04 r)))
              $Perm.Write
              $Perm.No)
            (pTaken@481@04 r))
          (pTaken@485@04 r))
        (pTaken@601@04 r)))
    (=
      ($FVF.lookup_int (as sm@654@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@654@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))))))) r))
  :qid |qp.fvfValDef504|)))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (-
          (ite
            (and (< (inv@457@04 r) V@15@04) (<= 0 (inv@457@04 r)))
            $Perm.Write
            $Perm.No)
          (pTaken@595@04 r))
        (pTaken@603@04 r)))
    (=
      ($FVF.lookup_int (as sm@654@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04)))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@654@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04)))))))))))))) r))
  :qid |qp.fvfValDef505|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@626@04 r) V@15@04) (<= 0 (inv@626@04 r)))
        (< (inv@625@04 r) V@15@04))
      (<= 0 (inv@625@04 r)))
    (=
      ($FVF.lookup_int (as sm@654@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@614@04))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@654@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@614@04))))))))))))))) r))
  :qid |qp.fvfValDef506|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@629@04 r) V@15@04) (<= 0 (inv@629@04 r)))
    (=
      ($FVF.lookup_int (as sm@654@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@614@04)))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@654@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@614@04)))))))))))))))) r))
  :qid |qp.fvfValDef507|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04)))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@614@04))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@614@04)))))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@654@04  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef508|)))
; Check receiver injectivity
(push) ; 20
(assert (not (forall ((i11@650@04 Int) (j1@651@04 Int) (i12@650@04 Int) (j2@651@04 Int)) (!
  (implies
    (and
      (and
        (and
          (and
            (and (< j1@651@04 V@15@04) (<= 0 j1@651@04))
            (< i11@650@04 V@15@04))
          (<= 0 i11@650@04))
        ($FVF.loc_int ($FVF.lookup_int (as sm@654@04  $FVF<Int>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@618@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i11@650@04))) j1@651@04)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@618@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i11@650@04))) j1@651@04)))
      (and
        (and
          (and
            (and (< j2@651@04 V@15@04) (<= 0 j2@651@04))
            (< i12@650@04 V@15@04))
          (<= 0 i12@650@04))
        ($FVF.loc_int ($FVF.lookup_int (as sm@654@04  $FVF<Int>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@618@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i12@650@04))) j2@651@04)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@618@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i12@650@04))) j2@651@04)))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@618@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i11@650@04))) j1@651@04)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@618@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i12@650@04))) j2@651@04)))
    (and (= i11@650@04 i12@650@04) (= j1@651@04 j2@651@04)))
  
  :qid |int-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 20
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               32122176
;  :arith-add-rows          6501507
;  :arith-assert-diseq      213890
;  :arith-assert-lower      5735620
;  :arith-assert-upper      4975799
;  :arith-bound-prop        143181
;  :arith-conflicts         3669
;  :arith-eq-adapter        2110373
;  :arith-fixed-eqs         5332631
;  :arith-offset-eqs        3362935
;  :arith-pivots            936799
;  :conflicts               8608
;  :datatype-accessor-ax    2783
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1329280
;  :del-clause              81397366
;  :final-checks            5
;  :max-generation          15
;  :max-memory              541.79
;  :memory                  503.10
;  :minimized-lits          1323
;  :mk-bool-var             69201037
;  :mk-clause               81399951
;  :num-allocs              163942692
;  :num-checks              740
;  :propagations            24219072
;  :quant-instantiations    28476968
;  :restarts                18
;  :rlimit-count            645349625
;  :time                    0.01)
; Definitional axioms for inverse functions
(assert (forall ((i1@650@04 Int) (j@651@04 Int)) (!
  (implies
    (and
      (and (and (< j@651@04 V@15@04) (<= 0 j@651@04)) (< i1@650@04 V@15@04))
      (<= 0 i1@650@04))
    (and
      (=
        (inv@652@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@618@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@650@04))) j@651@04))
        i1@650@04)
      (=
        (inv@653@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@618@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@650@04))) j@651@04))
        j@651@04)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@618@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@650@04))) j@651@04))
  :qid |int-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@653@04 r) V@15@04) (<= 0 (inv@653@04 r)))
        (< (inv@652@04 r) V@15@04))
      (<= 0 (inv@652@04 r)))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@618@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) (inv@652@04 r)))) (inv@653@04 r))
      r))
  :pattern ((inv@652@04 r))
  :pattern ((inv@653@04 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@653@04 r) V@15@04) (<= 0 (inv@653@04 r)))
        (< (inv@652@04 r) V@15@04))
      (<= 0 (inv@652@04 r)))
    ($FVF.loc_int ($FVF.lookup_int (as sm@654@04  $FVF<Int>) r) r))
  :pattern ((inv@652@04 r) (inv@653@04 r))
  )))
; Precomputing data for removing quantified permissions
(define-fun pTaken@655@04 ((r $Ref)) $Perm
  (ite
    (and
      (and
        (and (< (inv@653@04 r) V@15@04) (<= 0 (inv@653@04 r)))
        (< (inv@652@04 r) V@15@04))
      (<= 0 (inv@652@04 r)))
    ($Perm.min
      (-
        (-
          (-
            (ite
              (and
                (and
                  (and (< (inv@366@04 r) V@15@04) (<= 0 (inv@366@04 r)))
                  (< (inv@365@04 r) V@15@04))
                (<= 0 (inv@365@04 r)))
              $Perm.Write
              $Perm.No)
            (pTaken@481@04 r))
          (pTaken@485@04 r))
        (pTaken@601@04 r))
      $Perm.Write)
    $Perm.No))
(define-fun pTaken@656@04 ((r $Ref)) $Perm
  (ite
    (and
      (and
        (and (< (inv@653@04 r) V@15@04) (<= 0 (inv@653@04 r)))
        (< (inv@652@04 r) V@15@04))
      (<= 0 (inv@652@04 r)))
    ($Perm.min
      (-
        (-
          (ite
            (and (< (inv@457@04 r) V@15@04) (<= 0 (inv@457@04 r)))
            $Perm.Write
            $Perm.No)
          (pTaken@595@04 r))
        (pTaken@603@04 r))
      (- $Perm.Write (pTaken@655@04 r)))
    $Perm.No))
(define-fun pTaken@657@04 ((r $Ref)) $Perm
  (ite
    (and
      (and
        (and (< (inv@653@04 r) V@15@04) (<= 0 (inv@653@04 r)))
        (< (inv@652@04 r) V@15@04))
      (<= 0 (inv@652@04 r)))
    ($Perm.min
      (ite
        (and
          (and
            (and (< (inv@626@04 r) V@15@04) (<= 0 (inv@626@04 r)))
            (< (inv@625@04 r) V@15@04))
          (<= 0 (inv@625@04 r)))
        $Perm.Write
        $Perm.No)
      (- (- $Perm.Write (pTaken@655@04 r)) (pTaken@656@04 r)))
    $Perm.No))
(define-fun pTaken@658@04 ((r $Ref)) $Perm
  (ite
    (and
      (and
        (and (< (inv@653@04 r) V@15@04) (<= 0 (inv@653@04 r)))
        (< (inv@652@04 r) V@15@04))
      (<= 0 (inv@652@04 r)))
    ($Perm.min
      (ite
        (and (< (inv@629@04 r) V@15@04) (<= 0 (inv@629@04 r)))
        $Perm.Write
        $Perm.No)
      (-
        (- (- $Perm.Write (pTaken@655@04 r)) (pTaken@656@04 r))
        (pTaken@657@04 r)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 500)
(push) ; 20
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (-
        (-
          (-
            (ite
              (and
                (and
                  (and (< (inv@366@04 r) V@15@04) (<= 0 (inv@366@04 r)))
                  (< (inv@365@04 r) V@15@04))
                (<= 0 (inv@365@04 r)))
              $Perm.Write
              $Perm.No)
            (pTaken@481@04 r))
          (pTaken@485@04 r))
        (pTaken@601@04 r))
      (pTaken@655@04 r))
    $Perm.No)
  
  ))))
(check-sat)
; unknown
(pop) ; 20
; 0.50s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               32136084
;  :arith-add-rows          6509980
;  :arith-assert-diseq      213997
;  :arith-assert-lower      5737742
;  :arith-assert-upper      4977499
;  :arith-bound-prop        143799
;  :arith-conflicts         3686
;  :arith-eq-adapter        2112293
;  :arith-fixed-eqs         5334211
;  :arith-offset-eqs        3364262
;  :arith-pivots            938680
;  :conflicts               8640
;  :datatype-accessor-ax    2791
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1330221
;  :del-clause              81473332
;  :final-checks            5
;  :max-generation          15
;  :max-memory              541.79
;  :memory                  502.92
;  :minimized-lits          1330
;  :mk-bool-var             69279431
;  :mk-clause               81475917
;  :num-allocs              164157332
;  :num-checks              742
;  :propagations            24230273
;  :quant-instantiations    28501082
;  :restarts                18
;  :rlimit-count            646290830
;  :time                    0.50)
; Intermediate check if already taken enough permissions
(push) ; 20
(assert (not (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@653@04 r) V@15@04) (<= 0 (inv@653@04 r)))
        (< (inv@652@04 r) V@15@04))
      (<= 0 (inv@652@04 r)))
    (= (- $Perm.Write (pTaken@655@04 r)) $Perm.No))
  
  ))))
(check-sat)
; unknown
(pop) ; 20
; 0.50s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               32147848
;  :arith-add-rows          6523009
;  :arith-assert-diseq      214229
;  :arith-assert-lower      5739505
;  :arith-assert-upper      4978528
;  :arith-bound-prop        144029
;  :arith-conflicts         3694
;  :arith-eq-adapter        2113349
;  :arith-fixed-eqs         5335214
;  :arith-offset-eqs        3364658
;  :arith-pivots            939261
;  :conflicts               8658
;  :datatype-accessor-ax    2823
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1335521
;  :del-clause              81619421
;  :final-checks            5
;  :max-generation          15
;  :max-memory              541.79
;  :memory                  502.85
;  :minimized-lits          1330
;  :mk-bool-var             69380526
;  :mk-clause               81622006
;  :num-allocs              164375531
;  :num-checks              743
;  :propagations            24249896
;  :quant-instantiations    28522611
;  :restarts                18
;  :rlimit-count            647159579
;  :time                    0.50)
; Chunk depleted?
(push) ; 20
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (-
        (-
          (ite
            (and (< (inv@457@04 r) V@15@04) (<= 0 (inv@457@04 r)))
            $Perm.Write
            $Perm.No)
          (pTaken@595@04 r))
        (pTaken@603@04 r))
      (pTaken@656@04 r))
    $Perm.No)
  
  ))))
(check-sat)
; unknown
(pop) ; 20
; 0.50s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               32161652
;  :arith-add-rows          6532938
;  :arith-assert-diseq      214431
;  :arith-assert-lower      5742234
;  :arith-assert-upper      4980553
;  :arith-bound-prop        144372
;  :arith-conflicts         3706
;  :arith-eq-adapter        2115223
;  :arith-fixed-eqs         5337471
;  :arith-offset-eqs        3364991
;  :arith-pivots            940669
;  :conflicts               8688
;  :datatype-accessor-ax    2847
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1338050
;  :del-clause              81736959
;  :final-checks            5
;  :max-generation          15
;  :max-memory              541.79
;  :memory                  502.76
;  :minimized-lits          1335
;  :mk-bool-var             69469976
;  :mk-clause               81739544
;  :num-allocs              164607436
;  :num-checks              744
;  :propagations            24267475
;  :quant-instantiations    28548528
;  :restarts                18
;  :rlimit-count            648043689
;  :time                    0.50)
; Intermediate check if already taken enough permissions
(push) ; 20
(assert (not (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@653@04 r) V@15@04) (<= 0 (inv@653@04 r)))
        (< (inv@652@04 r) V@15@04))
      (<= 0 (inv@652@04 r)))
    (= (- (- $Perm.Write (pTaken@655@04 r)) (pTaken@656@04 r)) $Perm.No))
  
  ))))
(check-sat)
; unknown
(pop) ; 20
; 0.50s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               32173645
;  :arith-add-rows          6546109
;  :arith-assert-diseq      214724
;  :arith-assert-lower      5744266
;  :arith-assert-upper      4981815
;  :arith-bound-prop        144635
;  :arith-conflicts         3729
;  :arith-eq-adapter        2116342
;  :arith-fixed-eqs         5338603
;  :arith-offset-eqs        3365558
;  :arith-pivots            941300
;  :conflicts               8733
;  :datatype-accessor-ax    2879
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1343546
;  :del-clause              81885780
;  :final-checks            5
;  :max-generation          15
;  :max-memory              541.79
;  :memory                  502.75
;  :minimized-lits          1348
;  :mk-bool-var             69572383
;  :mk-clause               81888365
;  :num-allocs              164828037
;  :num-checks              745
;  :propagations            24287870
;  :quant-instantiations    28570546
;  :restarts                18
;  :rlimit-count            648926941
;  :time                    0.50)
; Chunk depleted?
(push) ; 20
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and
          (and
            (and (< (inv@626@04 r) V@15@04) (<= 0 (inv@626@04 r)))
            (< (inv@625@04 r) V@15@04))
          (<= 0 (inv@625@04 r)))
        $Perm.Write
        $Perm.No)
      (pTaken@657@04 r))
    $Perm.No)
  
  ))))
(check-sat)
; unknown
(pop) ; 20
; 0.50s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               32185327
;  :arith-add-rows          6558464
;  :arith-assert-diseq      215066
;  :arith-assert-lower      5746335
;  :arith-assert-upper      4983185
;  :arith-bound-prop        145075
;  :arith-conflicts         3748
;  :arith-eq-adapter        2117505
;  :arith-fixed-eqs         5339895
;  :arith-offset-eqs        3366255
;  :arith-pivots            942039
;  :conflicts               8787
;  :datatype-accessor-ax    2907
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1347693
;  :del-clause              82012202
;  :final-checks            5
;  :max-generation          15
;  :max-memory              541.79
;  :memory                  502.77
;  :minimized-lits          1363
;  :mk-bool-var             69663049
;  :mk-clause               82014787
;  :num-allocs              165033628
;  :num-checks              746
;  :propagations            24304733
;  :quant-instantiations    28590602
;  :restarts                18
;  :rlimit-count            649725546
;  :time                    0.50)
; Intermediate check if already taken enough permissions
(push) ; 20
(assert (not (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@653@04 r) V@15@04) (<= 0 (inv@653@04 r)))
        (< (inv@652@04 r) V@15@04))
      (<= 0 (inv@652@04 r)))
    (=
      (-
        (- (- $Perm.Write (pTaken@655@04 r)) (pTaken@656@04 r))
        (pTaken@657@04 r))
      $Perm.No))
  
  ))))
(check-sat)
; unsat
(pop) ; 20
; 0.03s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               32186700
;  :arith-add-rows          6559344
;  :arith-assert-diseq      215128
;  :arith-assert-lower      5746735
;  :arith-assert-upper      4983473
;  :arith-bound-prop        145229
;  :arith-conflicts         3771
;  :arith-eq-adapter        2117728
;  :arith-fixed-eqs         5340080
;  :arith-offset-eqs        3366441
;  :arith-pivots            942293
;  :conflicts               8824
;  :datatype-accessor-ax    2907
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1347769
;  :del-clause              82015065
;  :final-checks            5
;  :max-generation          15
;  :max-memory              541.79
;  :memory                  502.90
;  :minimized-lits          1373
;  :mk-bool-var             69666557
;  :mk-clause               82017650
;  :num-allocs              165045094
;  :num-checks              747
;  :propagations            24305487
;  :quant-instantiations    28591487
;  :restarts                18
;  :rlimit-count            649793289
;  :time                    0.03)
; Final check if taken enough permissions
; Done removing quantified permissions
; Definitional axioms for snapshot map values
; [eval] P != (None(): option[array])
; [eval] (None(): option[array])
; [eval] alen(opt_get1(P)) == V
; [eval] alen(opt_get1(P))
; [eval] opt_get1(P)
(push) ; 20
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 20
; Joined path conditions
(declare-const i1@659@04 Int)
(push) ; 20
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 21
; [then-branch: 359 | 0 <= i1@659@04 | live]
; [else-branch: 359 | !(0 <= i1@659@04) | live]
(push) ; 22
; [then-branch: 359 | 0 <= i1@659@04]
(assert (<= 0 i1@659@04))
; [eval] i1 < V
(pop) ; 22
(push) ; 22
; [else-branch: 359 | !(0 <= i1@659@04)]
(assert (not (<= 0 i1@659@04)))
(pop) ; 22
(pop) ; 21
; Joined path conditions
; Joined path conditions
(assert (and (< i1@659@04 V@15@04) (<= 0 i1@659@04)))
; [eval] aloc(opt_get1(P), i1)
; [eval] opt_get1(P)
(push) ; 21
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 21
; Joined path conditions
(push) ; 21
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 22
(assert (not (< i1@659@04 (alen<Int> (opt_get1 $Snap.unit P@14@04)))))
(check-sat)
; unsat
(pop) ; 22
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               32186707
;  :arith-add-rows          6559345
;  :arith-assert-diseq      215130
;  :arith-assert-lower      5746739
;  :arith-assert-upper      4983473
;  :arith-bound-prop        145230
;  :arith-conflicts         3771
;  :arith-eq-adapter        2117728
;  :arith-fixed-eqs         5340080
;  :arith-offset-eqs        3366447
;  :arith-pivots            942294
;  :conflicts               8824
;  :datatype-accessor-ax    2907
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1347769
;  :del-clause              82015065
;  :final-checks            5
;  :max-generation          15
;  :max-memory              541.79
;  :memory                  502.90
;  :minimized-lits          1373
;  :mk-bool-var             69666559
;  :mk-clause               82017651
;  :num-allocs              165045203
;  :num-checks              748
;  :propagations            24305491
;  :quant-instantiations    28591487
;  :restarts                18
;  :rlimit-count            649793503)
(assert (< i1@659@04 (alen<Int> (opt_get1 $Snap.unit P@14@04))))
(pop) ; 21
; Joined path conditions
(assert (< i1@659@04 (alen<Int> (opt_get1 $Snap.unit P@14@04))))
(pop) ; 20
(declare-fun inv@660@04 ($Ref) Int)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(assert (forall ((i1@659@04 Int)) (!
  (< i1@659@04 (alen<Int> (opt_get1 $Snap.unit P@14@04)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i1@659@04))
  :qid |int-aux|)))
(declare-const sm@661@04 $FVF<Int>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@629@04 r) V@15@04) (<= 0 (inv@629@04 r)))
    (=
      ($FVF.lookup_int (as sm@661@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@614@04)))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@661@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@614@04)))))))))))))))) r))
  :qid |qp.fvfValDef509|)))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (ite
          (and
            (and
              (and (< (inv@626@04 r) V@15@04) (<= 0 (inv@626@04 r)))
              (< (inv@625@04 r) V@15@04))
            (<= 0 (inv@625@04 r)))
          $Perm.Write
          $Perm.No)
        (pTaken@657@04 r)))
    (=
      ($FVF.lookup_int (as sm@661@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@614@04))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@661@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@614@04))))))))))))))) r))
  :qid |qp.fvfValDef510|)))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (-
          (-
            (ite
              (and (< (inv@457@04 r) V@15@04) (<= 0 (inv@457@04 r)))
              $Perm.Write
              $Perm.No)
            (pTaken@595@04 r))
          (pTaken@603@04 r))
        (pTaken@656@04 r)))
    (=
      ($FVF.lookup_int (as sm@661@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04)))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@661@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04)))))))))))))) r))
  :qid |qp.fvfValDef511|)))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (-
          (-
            (-
              (ite
                (and
                  (and
                    (and (< (inv@366@04 r) V@15@04) (<= 0 (inv@366@04 r)))
                    (< (inv@365@04 r) V@15@04))
                  (<= 0 (inv@365@04 r)))
                $Perm.Write
                $Perm.No)
              (pTaken@481@04 r))
            (pTaken@485@04 r))
          (pTaken@601@04 r))
        (pTaken@655@04 r)))
    (=
      ($FVF.lookup_int (as sm@661@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@661@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))))))) r))
  :qid |qp.fvfValDef512|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@614@04)))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@614@04))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04)))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@661@04  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef513|)))
; Check receiver injectivity
(push) ; 20
(assert (not (forall ((i11@659@04 Int) (i12@659@04 Int)) (!
  (implies
    (and
      (and
        (and (< i11@659@04 V@15@04) (<= 0 i11@659@04))
        ($FVF.loc_int ($FVF.lookup_int (as sm@661@04  $FVF<Int>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit P@14@04) i11@659@04)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit P@14@04) i11@659@04)))
      (and
        (and (< i12@659@04 V@15@04) (<= 0 i12@659@04))
        ($FVF.loc_int ($FVF.lookup_int (as sm@661@04  $FVF<Int>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit P@14@04) i12@659@04)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit P@14@04) i12@659@04)))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i11@659@04)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i12@659@04)))
    (= i11@659@04 i12@659@04))
  
  :qid |int-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 20
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               32186784
;  :arith-add-rows          6559370
;  :arith-assert-diseq      215131
;  :arith-assert-lower      5746743
;  :arith-assert-upper      4983473
;  :arith-bound-prop        145231
;  :arith-conflicts         3771
;  :arith-eq-adapter        2117729
;  :arith-fixed-eqs         5340080
;  :arith-offset-eqs        3366447
;  :arith-pivots            942299
;  :conflicts               8825
;  :datatype-accessor-ax    2907
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1347769
;  :del-clause              82015178
;  :final-checks            5
;  :max-generation          15
;  :max-memory              541.79
;  :memory                  502.82
;  :minimized-lits          1373
;  :mk-bool-var             69666773
;  :mk-clause               82017763
;  :num-allocs              165048207
;  :num-checks              749
;  :propagations            24305499
;  :quant-instantiations    28591613
;  :restarts                18
;  :rlimit-count            649809623
;  :time                    0.00)
; Definitional axioms for inverse functions
(assert (forall ((i1@659@04 Int)) (!
  (implies
    (and (< i1@659@04 V@15@04) (<= 0 i1@659@04))
    (=
      (inv@660@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i1@659@04))
      i1@659@04))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i1@659@04))
  :qid |int-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@660@04 r) V@15@04) (<= 0 (inv@660@04 r)))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) (inv@660@04 r))
      r))
  :pattern ((inv@660@04 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@660@04 r) V@15@04) (<= 0 (inv@660@04 r)))
    ($FVF.loc_int ($FVF.lookup_int (as sm@661@04  $FVF<Int>) r) r))
  :pattern ((inv@660@04 r))
  )))
; Precomputing data for removing quantified permissions
(define-fun pTaken@662@04 ((r $Ref)) $Perm
  (ite
    (and (< (inv@660@04 r) V@15@04) (<= 0 (inv@660@04 r)))
    ($Perm.min
      (ite
        (and (< (inv@629@04 r) V@15@04) (<= 0 (inv@629@04 r)))
        $Perm.Write
        $Perm.No)
      $Perm.Write)
    $Perm.No))
(define-fun pTaken@663@04 ((r $Ref)) $Perm
  (ite
    (and (< (inv@660@04 r) V@15@04) (<= 0 (inv@660@04 r)))
    ($Perm.min
      (-
        (ite
          (and
            (and
              (and (< (inv@626@04 r) V@15@04) (<= 0 (inv@626@04 r)))
              (< (inv@625@04 r) V@15@04))
            (<= 0 (inv@625@04 r)))
          $Perm.Write
          $Perm.No)
        (pTaken@657@04 r))
      (- $Perm.Write (pTaken@662@04 r)))
    $Perm.No))
(define-fun pTaken@664@04 ((r $Ref)) $Perm
  (ite
    (and (< (inv@660@04 r) V@15@04) (<= 0 (inv@660@04 r)))
    ($Perm.min
      (-
        (-
          (-
            (ite
              (and (< (inv@457@04 r) V@15@04) (<= 0 (inv@457@04 r)))
              $Perm.Write
              $Perm.No)
            (pTaken@595@04 r))
          (pTaken@603@04 r))
        (pTaken@656@04 r))
      (- (- $Perm.Write (pTaken@662@04 r)) (pTaken@663@04 r)))
    $Perm.No))
(define-fun pTaken@665@04 ((r $Ref)) $Perm
  (ite
    (and (< (inv@660@04 r) V@15@04) (<= 0 (inv@660@04 r)))
    ($Perm.min
      (-
        (-
          (-
            (-
              (ite
                (and
                  (and
                    (and (< (inv@366@04 r) V@15@04) (<= 0 (inv@366@04 r)))
                    (< (inv@365@04 r) V@15@04))
                  (<= 0 (inv@365@04 r)))
                $Perm.Write
                $Perm.No)
              (pTaken@481@04 r))
            (pTaken@485@04 r))
          (pTaken@601@04 r))
        (pTaken@655@04 r))
      (-
        (- (- $Perm.Write (pTaken@662@04 r)) (pTaken@663@04 r))
        (pTaken@664@04 r)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 500)
(push) ; 20
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and (< (inv@629@04 r) V@15@04) (<= 0 (inv@629@04 r)))
        $Perm.Write
        $Perm.No)
      (pTaken@662@04 r))
    $Perm.No)
  
  ))))
(check-sat)
; unsat
(pop) ; 20
; 0.07s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               32188763
;  :arith-add-rows          6562464
;  :arith-assert-diseq      215159
;  :arith-assert-lower      5747001
;  :arith-assert-upper      4983661
;  :arith-bound-prop        145290
;  :arith-conflicts         3775
;  :arith-eq-adapter        2117940
;  :arith-fixed-eqs         5340271
;  :arith-offset-eqs        3366561
;  :arith-pivots            942493
;  :conflicts               8847
;  :datatype-accessor-ax    2911
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1348208
;  :del-clause              82034371
;  :final-checks            5
;  :max-generation          15
;  :max-memory              541.79
;  :memory                  502.97
;  :minimized-lits          1373
;  :mk-bool-var             69684542
;  :mk-clause               82036956
;  :num-allocs              165100722
;  :num-checks              751
;  :propagations            24307232
;  :quant-instantiations    28595467
;  :restarts                18
;  :rlimit-count            650037837
;  :time                    0.07)
; Intermediate check if already taken enough permissions
(push) ; 20
(assert (not (forall ((r $Ref)) (!
  (implies
    (and (< (inv@660@04 r) V@15@04) (<= 0 (inv@660@04 r)))
    (= (- $Perm.Write (pTaken@662@04 r)) $Perm.No))
  
  ))))
(check-sat)
; unsat
(pop) ; 20
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               32189000
;  :arith-add-rows          6562614
;  :arith-assert-diseq      215163
;  :arith-assert-lower      5747052
;  :arith-assert-upper      4983689
;  :arith-bound-prop        145297
;  :arith-conflicts         3776
;  :arith-eq-adapter        2117978
;  :arith-fixed-eqs         5340295
;  :arith-offset-eqs        3366578
;  :arith-pivots            942518
;  :conflicts               8848
;  :datatype-accessor-ax    2911
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1348208
;  :del-clause              82035476
;  :final-checks            5
;  :max-generation          15
;  :max-memory              541.79
;  :memory                  502.97
;  :minimized-lits          1373
;  :mk-bool-var             69685957
;  :mk-clause               82038061
;  :num-allocs              165104533
;  :num-checks              752
;  :propagations            24307248
;  :quant-instantiations    28595834
;  :restarts                18
;  :rlimit-count            650058589
;  :time                    0.01)
; Final check if taken enough permissions
; Done removing quantified permissions
; Definitional axioms for snapshot map values
; [eval] valid_graph_vertices(this, P, V)
(push) ; 20
; [eval] this != null
; [eval] p != (None(): option[array])
; [eval] (None(): option[array])
; [eval] alen(opt_get1(p)) == V
; [eval] alen(opt_get1(p))
; [eval] opt_get1(p)
(push) ; 21
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 21
; Joined path conditions
(declare-const i1@666@04 Int)
(push) ; 21
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 22
; [then-branch: 360 | 0 <= i1@666@04 | live]
; [else-branch: 360 | !(0 <= i1@666@04) | live]
(push) ; 23
; [then-branch: 360 | 0 <= i1@666@04]
(assert (<= 0 i1@666@04))
; [eval] i1 < V
(pop) ; 23
(push) ; 23
; [else-branch: 360 | !(0 <= i1@666@04)]
(assert (not (<= 0 i1@666@04)))
(pop) ; 23
(pop) ; 22
; Joined path conditions
; Joined path conditions
(assert (and (< i1@666@04 V@15@04) (<= 0 i1@666@04)))
(declare-const $k@667@04 $Perm)
(assert ($Perm.isReadVar $k@667@04 $Perm.Write))
; [eval] aloc(opt_get1(p), i1)
; [eval] opt_get1(p)
(push) ; 22
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 22
; Joined path conditions
(push) ; 22
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 23
(assert (not (< i1@666@04 (alen<Int> (opt_get1 $Snap.unit P@14@04)))))
(check-sat)
; unsat
(pop) ; 23
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               32189007
;  :arith-add-rows          6562615
;  :arith-assert-diseq      215166
;  :arith-assert-lower      5747058
;  :arith-assert-upper      4983690
;  :arith-bound-prop        145298
;  :arith-conflicts         3776
;  :arith-eq-adapter        2117979
;  :arith-fixed-eqs         5340295
;  :arith-offset-eqs        3366584
;  :arith-pivots            942518
;  :conflicts               8848
;  :datatype-accessor-ax    2911
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1348208
;  :del-clause              82035476
;  :final-checks            5
;  :max-generation          15
;  :max-memory              541.79
;  :memory                  502.98
;  :minimized-lits          1373
;  :mk-bool-var             69685963
;  :mk-clause               82038064
;  :num-allocs              165104709
;  :num-checks              753
;  :propagations            24307253
;  :quant-instantiations    28595834
;  :restarts                18
;  :rlimit-count            650058944)
(assert (< i1@666@04 (alen<Int> (opt_get1 $Snap.unit P@14@04))))
(pop) ; 22
; Joined path conditions
(assert (< i1@666@04 (alen<Int> (opt_get1 $Snap.unit P@14@04))))
(pop) ; 21
(declare-fun inv@668@04 ($Ref) Int)
; Nested auxiliary terms: globals
(assert ($Perm.isReadVar $k@667@04 $Perm.Write))
; Nested auxiliary terms: non-globals
(assert (forall ((i1@666@04 Int)) (!
  (< i1@666@04 (alen<Int> (opt_get1 $Snap.unit P@14@04)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i1@666@04))
  :qid |int-aux|)))
(push) ; 21
(assert (not (forall ((i1@666@04 Int)) (!
  (implies
    (and (< i1@666@04 V@15@04) (<= 0 i1@666@04))
    (or (= $k@667@04 $Perm.No) (< $Perm.No $k@667@04)))
  
  ))))
(check-sat)
; unsat
(pop) ; 21
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               32189007
;  :arith-add-rows          6562616
;  :arith-assert-diseq      215167
;  :arith-assert-lower      5747060
;  :arith-assert-upper      4983691
;  :arith-bound-prop        145298
;  :arith-conflicts         3776
;  :arith-eq-adapter        2117980
;  :arith-fixed-eqs         5340295
;  :arith-offset-eqs        3366584
;  :arith-pivots            942518
;  :conflicts               8849
;  :datatype-accessor-ax    2911
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1348208
;  :del-clause              82035479
;  :final-checks            5
;  :max-generation          15
;  :max-memory              541.79
;  :memory                  502.97
;  :minimized-lits          1373
;  :mk-bool-var             69685970
;  :mk-clause               82038066
;  :num-allocs              165105139
;  :num-checks              754
;  :propagations            24307254
;  :quant-instantiations    28595834
;  :restarts                18
;  :rlimit-count            650059490)
(declare-const sm@669@04 $FVF<Int>)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@629@04 r) V@15@04) (<= 0 (inv@629@04 r)))
    (=
      ($FVF.lookup_int (as sm@669@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@614@04)))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@669@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@614@04)))))))))))))))) r))
  :qid |qp.fvfValDef514|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@626@04 r) V@15@04) (<= 0 (inv@626@04 r)))
        (< (inv@625@04 r) V@15@04))
      (<= 0 (inv@625@04 r)))
    (=
      ($FVF.lookup_int (as sm@669@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@614@04))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@669@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@614@04))))))))))))))) r))
  :qid |qp.fvfValDef515|)))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (-
          (ite
            (and (< (inv@457@04 r) V@15@04) (<= 0 (inv@457@04 r)))
            $Perm.Write
            $Perm.No)
          (pTaken@595@04 r))
        (pTaken@603@04 r)))
    (=
      ($FVF.lookup_int (as sm@669@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04)))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@669@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04)))))))))))))) r))
  :qid |qp.fvfValDef516|)))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (-
          (-
            (ite
              (and
                (and
                  (and (< (inv@366@04 r) V@15@04) (<= 0 (inv@366@04 r)))
                  (< (inv@365@04 r) V@15@04))
                (<= 0 (inv@365@04 r)))
              $Perm.Write
              $Perm.No)
            (pTaken@481@04 r))
          (pTaken@485@04 r))
        (pTaken@601@04 r)))
    (=
      ($FVF.lookup_int (as sm@669@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@669@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))))))) r))
  :qid |qp.fvfValDef517|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@614@04)))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@614@04))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04)))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@669@04  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef518|)))
; Check receiver injectivity
(push) ; 21
(assert (not (forall ((i11@666@04 Int) (i12@666@04 Int)) (!
  (implies
    (and
      (and
        (and
          (and (< i11@666@04 V@15@04) (<= 0 i11@666@04))
          ($FVF.loc_int ($FVF.lookup_int (as sm@669@04  $FVF<Int>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit P@14@04) i11@666@04)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit P@14@04) i11@666@04)))
        (< $Perm.No $k@667@04))
      (and
        (and
          (and (< i12@666@04 V@15@04) (<= 0 i12@666@04))
          ($FVF.loc_int ($FVF.lookup_int (as sm@669@04  $FVF<Int>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit P@14@04) i12@666@04)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit P@14@04) i12@666@04)))
        (< $Perm.No $k@667@04))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i11@666@04)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i12@666@04)))
    (= i11@666@04 i12@666@04))
  
  :qid |int-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 21
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               32189086
;  :arith-add-rows          6562637
;  :arith-assert-diseq      215168
;  :arith-assert-lower      5747064
;  :arith-assert-upper      4983691
;  :arith-bound-prop        145299
;  :arith-conflicts         3776
;  :arith-eq-adapter        2117981
;  :arith-fixed-eqs         5340295
;  :arith-offset-eqs        3366584
;  :arith-pivots            942520
;  :conflicts               8850
;  :datatype-accessor-ax    2911
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1348208
;  :del-clause              82035567
;  :final-checks            5
;  :max-generation          15
;  :max-memory              541.79
;  :memory                  502.94
;  :minimized-lits          1373
;  :mk-bool-var             69686161
;  :mk-clause               82038154
;  :num-allocs              165107573
;  :num-checks              755
;  :propagations            24307262
;  :quant-instantiations    28595964
;  :restarts                18
;  :rlimit-count            650070602
;  :time                    0.00)
; Definitional axioms for inverse functions
(assert (forall ((i1@666@04 Int)) (!
  (implies
    (and (and (< i1@666@04 V@15@04) (<= 0 i1@666@04)) (< $Perm.No $k@667@04))
    (=
      (inv@668@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i1@666@04))
      i1@666@04))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i1@666@04))
  :qid |int-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and (< (inv@668@04 r) V@15@04) (<= 0 (inv@668@04 r)))
      (< $Perm.No $k@667@04))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) (inv@668@04 r))
      r))
  :pattern ((inv@668@04 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@668@04 r) V@15@04) (<= 0 (inv@668@04 r)))
    ($FVF.loc_int ($FVF.lookup_int (as sm@669@04  $FVF<Int>) r) r))
  :pattern ((inv@668@04 r))
  )))
; Precomputing data for removing quantified permissions
(define-fun pTaken@670@04 ((r $Ref)) $Perm
  (ite
    (and (< (inv@668@04 r) V@15@04) (<= 0 (inv@668@04 r)))
    ($Perm.min
      (ite
        (and (< (inv@629@04 r) V@15@04) (<= 0 (inv@629@04 r)))
        $Perm.Write
        $Perm.No)
      $k@667@04)
    $Perm.No))
(define-fun pTaken@671@04 ((r $Ref)) $Perm
  (ite
    (and (< (inv@668@04 r) V@15@04) (<= 0 (inv@668@04 r)))
    ($Perm.min
      (ite
        (and
          (and
            (and (< (inv@626@04 r) V@15@04) (<= 0 (inv@626@04 r)))
            (< (inv@625@04 r) V@15@04))
          (<= 0 (inv@625@04 r)))
        $Perm.Write
        $Perm.No)
      (- $k@667@04 (pTaken@670@04 r)))
    $Perm.No))
(define-fun pTaken@672@04 ((r $Ref)) $Perm
  (ite
    (and (< (inv@668@04 r) V@15@04) (<= 0 (inv@668@04 r)))
    ($Perm.min
      (-
        (-
          (ite
            (and (< (inv@457@04 r) V@15@04) (<= 0 (inv@457@04 r)))
            $Perm.Write
            $Perm.No)
          (pTaken@595@04 r))
        (pTaken@603@04 r))
      (- (- $k@667@04 (pTaken@670@04 r)) (pTaken@671@04 r)))
    $Perm.No))
(define-fun pTaken@673@04 ((r $Ref)) $Perm
  (ite
    (and (< (inv@668@04 r) V@15@04) (<= 0 (inv@668@04 r)))
    ($Perm.min
      (-
        (-
          (-
            (ite
              (and
                (and
                  (and (< (inv@366@04 r) V@15@04) (<= 0 (inv@366@04 r)))
                  (< (inv@365@04 r) V@15@04))
                (<= 0 (inv@365@04 r)))
              $Perm.Write
              $Perm.No)
            (pTaken@481@04 r))
          (pTaken@485@04 r))
        (pTaken@601@04 r))
      (- (- (- $k@667@04 (pTaken@670@04 r)) (pTaken@671@04 r)) (pTaken@672@04 r)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Constrain original permissions $k@667@04
(assert (forall ((r $Ref)) (!
  (implies
    (not
      (=
        (ite
          (and (< (inv@629@04 r) V@15@04) (<= 0 (inv@629@04 r)))
          $Perm.Write
          $Perm.No)
        $Perm.No))
    (ite
      (and (< (inv@629@04 r) V@15@04) (<= 0 (inv@629@04 r)))
      (<
        (ite
          (and (< (inv@668@04 r) V@15@04) (<= 0 (inv@668@04 r)))
          $k@667@04
          $Perm.No)
        $Perm.Write)
      (<
        (ite
          (and (< (inv@668@04 r) V@15@04) (<= 0 (inv@668@04 r)))
          $k@667@04
          $Perm.No)
        $Perm.No)))
  :pattern ((inv@629@04 r))
  :pattern ((inv@668@04 r))
  :qid |qp.srp519|)))
; Intermediate check if already taken enough permissions
(set-option :timeout 500)
(push) ; 21
(assert (not (forall ((r $Ref)) (!
  (implies
    (and (< (inv@668@04 r) V@15@04) (<= 0 (inv@668@04 r)))
    (= (- $k@667@04 (pTaken@670@04 r)) $Perm.No))
  
  ))))
(check-sat)
; unsat
(pop) ; 21
; 0.07s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               32190365
;  :arith-add-rows          6564052
;  :arith-assert-diseq      215191
;  :arith-assert-lower      5747233
;  :arith-assert-upper      4983820
;  :arith-bound-prop        145350
;  :arith-conflicts         3778
;  :arith-eq-adapter        2118122
;  :arith-fixed-eqs         5340433
;  :arith-offset-eqs        3366671
;  :arith-pivots            942607
;  :conflicts               8871
;  :datatype-accessor-ax    2915
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1348639
;  :del-clause              82051018
;  :final-checks            5
;  :max-generation          15
;  :max-memory              541.79
;  :memory                  502.98
;  :minimized-lits          1373
;  :mk-bool-var             69697613
;  :mk-clause               82053603
;  :num-allocs              165143040
;  :num-checks              757
;  :propagations            24309141
;  :quant-instantiations    28598657
;  :restarts                18
;  :rlimit-count            650239767
;  :time                    0.07)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@674@04 $FVF<Int>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (iff
    (Set_in r ($FVF.domain_int (as sm@674@04  $FVF<Int>)))
    (and
      (and (< (inv@668@04 r) V@15@04) (<= 0 (inv@668@04 r)))
      (< $Perm.No $k@667@04)))
  :pattern ((Set_in r ($FVF.domain_int (as sm@674@04  $FVF<Int>))))
  :qid |qp.fvfDomDef525|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@668@04 r) V@15@04) (<= 0 (inv@668@04 r)))
        (< $Perm.No $k@667@04))
      (and (< (inv@629@04 r) V@15@04) (<= 0 (inv@629@04 r))))
    (=
      ($FVF.lookup_int (as sm@674@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@614@04)))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@674@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@614@04)))))))))))))))) r))
  :qid |qp.fvfValDef520|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@668@04 r) V@15@04) (<= 0 (inv@668@04 r)))
        (< $Perm.No $k@667@04))
      (and
        (and
          (and (< (inv@626@04 r) V@15@04) (<= 0 (inv@626@04 r)))
          (< (inv@625@04 r) V@15@04))
        (<= 0 (inv@625@04 r))))
    (=
      ($FVF.lookup_int (as sm@674@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@614@04))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@674@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@614@04))))))))))))))) r))
  :qid |qp.fvfValDef521|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@668@04 r) V@15@04) (<= 0 (inv@668@04 r)))
        (< $Perm.No $k@667@04))
      (<
        $Perm.No
        (-
          (-
            (ite
              (and (< (inv@457@04 r) V@15@04) (<= 0 (inv@457@04 r)))
              $Perm.Write
              $Perm.No)
            (pTaken@595@04 r))
          (pTaken@603@04 r))))
    (=
      ($FVF.lookup_int (as sm@674@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04)))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@674@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04)))))))))))))) r))
  :qid |qp.fvfValDef522|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@668@04 r) V@15@04) (<= 0 (inv@668@04 r)))
        (< $Perm.No $k@667@04))
      (<
        $Perm.No
        (-
          (-
            (-
              (ite
                (and
                  (and
                    (and (< (inv@366@04 r) V@15@04) (<= 0 (inv@366@04 r)))
                    (< (inv@365@04 r) V@15@04))
                  (<= 0 (inv@365@04 r)))
                $Perm.Write
                $Perm.No)
              (pTaken@481@04 r))
            (pTaken@485@04 r))
          (pTaken@601@04 r))))
    (=
      ($FVF.lookup_int (as sm@674@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@674@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))))))) r))
  :qid |qp.fvfValDef523|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@614@04)))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@614@04))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04)))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@674@04  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef524|)))
(pop) ; 20
; Joined path conditions
(assert ($Perm.isReadVar $k@667@04 $Perm.Write))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@629@04 r) V@15@04) (<= 0 (inv@629@04 r)))
    (=
      ($FVF.lookup_int (as sm@669@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@614@04)))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@669@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@614@04)))))))))))))))) r))
  :qid |qp.fvfValDef514|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@626@04 r) V@15@04) (<= 0 (inv@626@04 r)))
        (< (inv@625@04 r) V@15@04))
      (<= 0 (inv@625@04 r)))
    (=
      ($FVF.lookup_int (as sm@669@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@614@04))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@669@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@614@04))))))))))))))) r))
  :qid |qp.fvfValDef515|)))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (-
          (ite
            (and (< (inv@457@04 r) V@15@04) (<= 0 (inv@457@04 r)))
            $Perm.Write
            $Perm.No)
          (pTaken@595@04 r))
        (pTaken@603@04 r)))
    (=
      ($FVF.lookup_int (as sm@669@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04)))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@669@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04)))))))))))))) r))
  :qid |qp.fvfValDef516|)))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (-
          (-
            (ite
              (and
                (and
                  (and (< (inv@366@04 r) V@15@04) (<= 0 (inv@366@04 r)))
                  (< (inv@365@04 r) V@15@04))
                (<= 0 (inv@365@04 r)))
              $Perm.Write
              $Perm.No)
            (pTaken@481@04 r))
          (pTaken@485@04 r))
        (pTaken@601@04 r)))
    (=
      ($FVF.lookup_int (as sm@669@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@669@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))))))) r))
  :qid |qp.fvfValDef517|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@614@04)))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@614@04))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04)))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@669@04  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef518|)))
(assert (forall ((i1@666@04 Int)) (!
  (implies
    (and (and (< i1@666@04 V@15@04) (<= 0 i1@666@04)) (< $Perm.No $k@667@04))
    (=
      (inv@668@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i1@666@04))
      i1@666@04))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i1@666@04))
  :qid |int-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and (< (inv@668@04 r) V@15@04) (<= 0 (inv@668@04 r)))
      (< $Perm.No $k@667@04))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) (inv@668@04 r))
      r))
  :pattern ((inv@668@04 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (iff
    (Set_in r ($FVF.domain_int (as sm@674@04  $FVF<Int>)))
    (and
      (and (< (inv@668@04 r) V@15@04) (<= 0 (inv@668@04 r)))
      (< $Perm.No $k@667@04)))
  :pattern ((Set_in r ($FVF.domain_int (as sm@674@04  $FVF<Int>))))
  :qid |qp.fvfDomDef525|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@668@04 r) V@15@04) (<= 0 (inv@668@04 r)))
        (< $Perm.No $k@667@04))
      (and (< (inv@629@04 r) V@15@04) (<= 0 (inv@629@04 r))))
    (=
      ($FVF.lookup_int (as sm@674@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@614@04)))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@674@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@614@04)))))))))))))))) r))
  :qid |qp.fvfValDef520|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@668@04 r) V@15@04) (<= 0 (inv@668@04 r)))
        (< $Perm.No $k@667@04))
      (and
        (and
          (and (< (inv@626@04 r) V@15@04) (<= 0 (inv@626@04 r)))
          (< (inv@625@04 r) V@15@04))
        (<= 0 (inv@625@04 r))))
    (=
      ($FVF.lookup_int (as sm@674@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@614@04))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@674@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@614@04))))))))))))))) r))
  :qid |qp.fvfValDef521|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@668@04 r) V@15@04) (<= 0 (inv@668@04 r)))
        (< $Perm.No $k@667@04))
      (<
        $Perm.No
        (-
          (-
            (ite
              (and (< (inv@457@04 r) V@15@04) (<= 0 (inv@457@04 r)))
              $Perm.Write
              $Perm.No)
            (pTaken@595@04 r))
          (pTaken@603@04 r))))
    (=
      ($FVF.lookup_int (as sm@674@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04)))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@674@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04)))))))))))))) r))
  :qid |qp.fvfValDef522|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@668@04 r) V@15@04) (<= 0 (inv@668@04 r)))
        (< $Perm.No $k@667@04))
      (<
        $Perm.No
        (-
          (-
            (-
              (ite
                (and
                  (and
                    (and (< (inv@366@04 r) V@15@04) (<= 0 (inv@366@04 r)))
                    (< (inv@365@04 r) V@15@04))
                  (<= 0 (inv@365@04 r)))
                $Perm.Write
                $Perm.No)
              (pTaken@481@04 r))
            (pTaken@485@04 r))
          (pTaken@601@04 r))))
    (=
      ($FVF.lookup_int (as sm@674@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@674@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))))))) r))
  :qid |qp.fvfValDef523|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@614@04)))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@614@04))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@442@04)))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@354@04))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@674@04  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef524|)))
(assert (and
  (forall ((i1@666@04 Int)) (!
    (< i1@666@04 (alen<Int> (opt_get1 $Snap.unit P@14@04)))
    :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i1@666@04))
    :qid |int-aux|))
  (forall ((r $Ref)) (!
    (implies
      (and (< (inv@668@04 r) V@15@04) (<= 0 (inv@668@04 r)))
      ($FVF.loc_int ($FVF.lookup_int (as sm@669@04  $FVF<Int>) r) r))
    :pattern ((inv@668@04 r))
    ))
  (forall ((r $Ref)) (!
    (implies
      (not
        (=
          (ite
            (and (< (inv@629@04 r) V@15@04) (<= 0 (inv@629@04 r)))
            $Perm.Write
            $Perm.No)
          $Perm.No))
      (ite
        (and (< (inv@629@04 r) V@15@04) (<= 0 (inv@629@04 r)))
        (<
          (ite
            (and (< (inv@668@04 r) V@15@04) (<= 0 (inv@668@04 r)))
            $k@667@04
            $Perm.No)
          $Perm.Write)
        (<
          (ite
            (and (< (inv@668@04 r) V@15@04) (<= 0 (inv@668@04 r)))
            $k@667@04
            $Perm.No)
          $Perm.No)))
    :pattern ((inv@629@04 r))
    :pattern ((inv@668@04 r))
    :qid |qp.srp519|))))
(set-option :timeout 0)
(push) ; 20
(assert (not (valid_graph_vertices ($Snap.combine
  $Snap.unit
  ($Snap.combine
    $Snap.unit
    ($Snap.combine
      $Snap.unit
      ($SortWrappers.$FVF<Int>To$Snap (as sm@674@04  $FVF<Int>))))) this@9@04 P@14@04 V@15@04)))
(check-sat)
; unsat
(pop) ; 20
; 04m:33s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               44244617
;  :arith-add-rows          8696927
;  :arith-assert-diseq      322626
;  :arith-assert-lower      7933449
;  :arith-assert-upper      6895183
;  :arith-bound-prop        177075
;  :arith-conflicts         4332
;  :arith-eq-adapter        2817579
;  :arith-fixed-eqs         7360055
;  :arith-offset-eqs        4997386
;  :arith-pivots            1200034
;  :conflicts               9886
;  :datatype-accessor-ax    5362
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1909636
;  :del-clause              108427675
;  :final-checks            5
;  :max-generation          15
;  :max-memory              590.26
;  :memory                  565.46
;  :minimized-lits          1592
;  :mk-bool-var             91873669
;  :mk-clause               108430262
;  :num-allocs              217444680
;  :num-checks              758
;  :propagations            31715414
;  :quant-instantiations    37359185
;  :restarts                22
;  :rlimit-count            850094972
;  :time                    273.53)
(assert (valid_graph_vertices ($Snap.combine
  $Snap.unit
  ($Snap.combine
    $Snap.unit
    ($Snap.combine
      $Snap.unit
      ($SortWrappers.$FVF<Int>To$Snap (as sm@674@04  $FVF<Int>))))) this@9@04 P@14@04 V@15@04))
(pop) ; 19
(pop) ; 18
(pop) ; 17
(pop) ; 16
(pop) ; 15
(push) ; 15
; [else-branch: 285 | v1@441@04 != s@12@04]
(assert (not (= v1@441@04 s@12@04)))
(pop) ; 15
(pop) ; 14
(pop) ; 13
(pop) ; 12
(push) ; 12
; [else-branch: 238 | v@353@04 != s@12@04]
(assert (not (= v@353@04 s@12@04)))
(pop) ; 12
(pop) ; 11
(pop) ; 10
(pop) ; 9
(push) ; 9
; [else-branch: 189 | !(res1@292@04)]
(assert (not res1@292@04))
(pop) ; 9
; [eval] !res1
(set-option :timeout 10)
(push) ; 9
(assert (not res1@292@04))
(check-sat)
; unknown
(pop) ; 9
; 0.43s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               44244617
;  :arith-add-rows          8696935
;  :arith-assert-diseq      322626
;  :arith-assert-lower      7933449
;  :arith-assert-upper      6895183
;  :arith-bound-prop        177075
;  :arith-conflicts         4332
;  :arith-eq-adapter        2817579
;  :arith-fixed-eqs         7360055
;  :arith-offset-eqs        4997386
;  :arith-pivots            1200058
;  :conflicts               9886
;  :datatype-accessor-ax    5362
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1909636
;  :del-clause              108428901
;  :final-checks            5
;  :max-generation          15
;  :max-memory              590.26
;  :memory                  564.62
;  :minimized-lits          1592
;  :mk-bool-var             91873670
;  :mk-clause               108430262
;  :num-allocs              217444755
;  :num-checks              759
;  :propagations            31715414
;  :quant-instantiations    37359185
;  :restarts                22
;  :rlimit-count            850095259
;  :time                    0.43)
(push) ; 9
(assert (not (not res1@292@04)))
(check-sat)
; unknown
(pop) ; 9
; 0.11s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               44244714
;  :arith-add-rows          8696995
;  :arith-assert-diseq      322630
;  :arith-assert-lower      7933482
;  :arith-assert-upper      6895207
;  :arith-bound-prop        177075
;  :arith-conflicts         4332
;  :arith-eq-adapter        2817598
;  :arith-fixed-eqs         7360083
;  :arith-offset-eqs        4997392
;  :arith-pivots            1200066
;  :conflicts               9886
;  :datatype-accessor-ax    5362
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1909650
;  :del-clause              108429500
;  :final-checks            5
;  :max-generation          15
;  :max-memory              590.26
;  :memory                  554.63
;  :minimized-lits          1592
;  :mk-bool-var             91874163
;  :mk-clause               108430861
;  :num-allocs              217446976
;  :num-checks              760
;  :propagations            31715529
;  :quant-instantiations    37359378
;  :restarts                22
;  :rlimit-count            850104747
;  :time                    0.11)
; [then-branch: 361 | !(res1@292@04) | live]
; [else-branch: 361 | res1@292@04 | live]
(push) ; 9
; [then-branch: 361 | !(res1@292@04)]
(assert (not res1@292@04))
; [exec]
; P_seq := unknown(P, 0, alen(opt_get1(P)))
; [eval] unknown(P, 0, alen(opt_get1(P)))
; [eval] alen(opt_get1(P))
; [eval] opt_get1(P)
(push) ; 10
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 10
; Joined path conditions
(push) ; 10
; [eval] a2 != (None(): option[array])
; [eval] (None(): option[array])
; [eval] 0 <= from
; [eval] from <= to
; [eval] to <= alen(opt_get1(a2))
; [eval] alen(opt_get1(a2))
; [eval] opt_get1(a2)
(push) ; 11
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 11
; Joined path conditions
(declare-const i1@675@04 Int)
(push) ; 11
; [eval] from <= i1 && i1 < to
; [eval] from <= i1
(push) ; 12
; [then-branch: 362 | 0 <= i1@675@04 | live]
; [else-branch: 362 | !(0 <= i1@675@04) | live]
(push) ; 13
; [then-branch: 362 | 0 <= i1@675@04]
(assert (<= 0 i1@675@04))
; [eval] i1 < to
(pop) ; 13
(push) ; 13
; [else-branch: 362 | !(0 <= i1@675@04)]
(assert (not (<= 0 i1@675@04)))
(pop) ; 13
(pop) ; 12
; Joined path conditions
; Joined path conditions
(assert (and (< i1@675@04 (alen<Int> (opt_get1 $Snap.unit P@14@04))) (<= 0 i1@675@04)))
(declare-const $k@676@04 $Perm)
(assert ($Perm.isReadVar $k@676@04 $Perm.Write))
; [eval] aloc(opt_get1(a2), i1)
; [eval] opt_get1(a2)
(push) ; 12
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 12
; Joined path conditions
(push) ; 12
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(pop) ; 12
; Joined path conditions
(pop) ; 11
(declare-fun inv@677@04 ($Ref) Int)
; Nested auxiliary terms: globals
(assert ($Perm.isReadVar $k@676@04 $Perm.Write))
; Nested auxiliary terms: non-globals
(set-option :timeout 0)
(push) ; 11
(assert (not (forall ((i1@675@04 Int)) (!
  (implies
    (and
      (< i1@675@04 (alen<Int> (opt_get1 $Snap.unit P@14@04)))
      (<= 0 i1@675@04))
    (or (= $k@676@04 $Perm.No) (< $Perm.No $k@676@04)))
  
  ))))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               44244714
;  :arith-add-rows          8696997
;  :arith-assert-diseq      322632
;  :arith-assert-lower      7933488
;  :arith-assert-upper      6895209
;  :arith-bound-prop        177075
;  :arith-conflicts         4332
;  :arith-eq-adapter        2817600
;  :arith-fixed-eqs         7360083
;  :arith-offset-eqs        4997392
;  :arith-pivots            1200066
;  :conflicts               9887
;  :datatype-accessor-ax    5362
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1909650
;  :del-clause              108429502
;  :final-checks            5
;  :max-generation          15
;  :max-memory              590.26
;  :memory                  554.63
;  :minimized-lits          1592
;  :mk-bool-var             91874176
;  :mk-clause               108430865
;  :num-allocs              217447492
;  :num-checks              761
;  :propagations            31715531
;  :quant-instantiations    37359378
;  :restarts                22
;  :rlimit-count            850105463)
(declare-const sm@678@04 $FVF<Int>)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@305@04 r) V@15@04) (<= 0 (inv@305@04 r)))
        (< (inv@304@04 r) V@15@04))
      (<= 0 (inv@304@04 r)))
    (=
      ($FVF.lookup_int (as sm@678@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@678@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04))))))))) r))
  :qid |qp.fvfValDef526|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@308@04 r) V@15@04) (<= 0 (inv@308@04 r)))
    (=
      ($FVF.lookup_int (as sm@678@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04)))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@678@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04)))))))))))) r))
  :qid |qp.fvfValDef527|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04)))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@678@04  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef528|)))
; Check receiver injectivity
(push) ; 11
(assert (not (forall ((i11@675@04 Int) (i12@675@04 Int)) (!
  (implies
    (and
      (and
        (and
          (and
            (< i11@675@04 (alen<Int> (opt_get1 $Snap.unit P@14@04)))
            (<= 0 i11@675@04))
          ($FVF.loc_int ($FVF.lookup_int (as sm@678@04  $FVF<Int>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit P@14@04) i11@675@04)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit P@14@04) i11@675@04)))
        (< $Perm.No $k@676@04))
      (and
        (and
          (and
            (< i12@675@04 (alen<Int> (opt_get1 $Snap.unit P@14@04)))
            (<= 0 i12@675@04))
          ($FVF.loc_int ($FVF.lookup_int (as sm@678@04  $FVF<Int>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit P@14@04) i12@675@04)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit P@14@04) i12@675@04)))
        (< $Perm.No $k@676@04))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i11@675@04)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i12@675@04)))
    (= i11@675@04 i12@675@04))
  
  :qid |int-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               44244754
;  :arith-add-rows          8697004
;  :arith-assert-diseq      322633
;  :arith-assert-lower      7933492
;  :arith-assert-upper      6895209
;  :arith-bound-prop        177075
;  :arith-conflicts         4332
;  :arith-eq-adapter        2817601
;  :arith-fixed-eqs         7360083
;  :arith-offset-eqs        4997392
;  :arith-pivots            1200066
;  :conflicts               9888
;  :datatype-accessor-ax    5362
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1909650
;  :del-clause              108429513
;  :final-checks            5
;  :max-generation          15
;  :max-memory              590.26
;  :memory                  548.64
;  :minimized-lits          1592
;  :mk-bool-var             91874240
;  :mk-clause               108430876
;  :num-allocs              217448575
;  :num-checks              762
;  :propagations            31715533
;  :quant-instantiations    37359438
;  :restarts                22
;  :rlimit-count            850108924
;  :time                    0.00)
; Definitional axioms for inverse functions
(assert (forall ((i1@675@04 Int)) (!
  (implies
    (and
      (and
        (< i1@675@04 (alen<Int> (opt_get1 $Snap.unit P@14@04)))
        (<= 0 i1@675@04))
      (< $Perm.No $k@676@04))
    (=
      (inv@677@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i1@675@04))
      i1@675@04))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i1@675@04))
  :qid |int-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (< (inv@677@04 r) (alen<Int> (opt_get1 $Snap.unit P@14@04)))
        (<= 0 (inv@677@04 r)))
      (< $Perm.No $k@676@04))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) (inv@677@04 r))
      r))
  :pattern ((inv@677@04 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (< (inv@677@04 r) (alen<Int> (opt_get1 $Snap.unit P@14@04)))
      (<= 0 (inv@677@04 r)))
    ($FVF.loc_int ($FVF.lookup_int (as sm@678@04  $FVF<Int>) r) r))
  :pattern ((inv@677@04 r))
  )))
; Precomputing data for removing quantified permissions
(define-fun pTaken@679@04 ((r $Ref)) $Perm
  (ite
    (and
      (< (inv@677@04 r) (alen<Int> (opt_get1 $Snap.unit P@14@04)))
      (<= 0 (inv@677@04 r)))
    ($Perm.min
      (ite
        (and
          (and
            (and (< (inv@305@04 r) V@15@04) (<= 0 (inv@305@04 r)))
            (< (inv@304@04 r) V@15@04))
          (<= 0 (inv@304@04 r)))
        $Perm.Write
        $Perm.No)
      $k@676@04)
    $Perm.No))
(define-fun pTaken@680@04 ((r $Ref)) $Perm
  (ite
    (and
      (< (inv@677@04 r) (alen<Int> (opt_get1 $Snap.unit P@14@04)))
      (<= 0 (inv@677@04 r)))
    ($Perm.min
      (ite
        (and (< (inv@308@04 r) V@15@04) (<= 0 (inv@308@04 r)))
        $Perm.Write
        $Perm.No)
      (- $k@676@04 (pTaken@679@04 r)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Constrain original permissions $k@676@04
(assert (forall ((r $Ref)) (!
  (implies
    (not
      (=
        (ite
          (and
            (and
              (and (< (inv@305@04 r) V@15@04) (<= 0 (inv@305@04 r)))
              (< (inv@304@04 r) V@15@04))
            (<= 0 (inv@304@04 r)))
          $Perm.Write
          $Perm.No)
        $Perm.No))
    (ite
      (and
        (and
          (and (< (inv@305@04 r) V@15@04) (<= 0 (inv@305@04 r)))
          (< (inv@304@04 r) V@15@04))
        (<= 0 (inv@304@04 r)))
      (<
        (ite
          (and
            (< (inv@677@04 r) (alen<Int> (opt_get1 $Snap.unit P@14@04)))
            (<= 0 (inv@677@04 r)))
          $k@676@04
          $Perm.No)
        $Perm.Write)
      (<
        (ite
          (and
            (< (inv@677@04 r) (alen<Int> (opt_get1 $Snap.unit P@14@04)))
            (<= 0 (inv@677@04 r)))
          $k@676@04
          $Perm.No)
        $Perm.No)))
  :pattern ((inv@305@04 r))
  :pattern ((inv@304@04 r))
  :pattern ((inv@677@04 r))
  :qid |qp.srp529|)))
; Intermediate check if already taken enough permissions
(set-option :timeout 500)
(push) ; 11
(assert (not (forall ((r $Ref)) (!
  (implies
    (and
      (< (inv@677@04 r) (alen<Int> (opt_get1 $Snap.unit P@14@04)))
      (<= 0 (inv@677@04 r)))
    (= (- $k@676@04 (pTaken@679@04 r)) $Perm.No))
  
  ))))
(check-sat)
; unknown
(pop) ; 11
; 0.50s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               44255358
;  :arith-add-rows          8703095
;  :arith-assert-diseq      322724
;  :arith-assert-lower      7935344
;  :arith-assert-upper      6896605
;  :arith-bound-prop        177438
;  :arith-conflicts         4340
;  :arith-eq-adapter        2819087
;  :arith-fixed-eqs         7361421
;  :arith-offset-eqs        4998506
;  :arith-pivots            1201363
;  :conflicts               9903
;  :datatype-accessor-ax    5362
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1910855
;  :del-clause              108490576
;  :final-checks            5
;  :max-generation          15
;  :max-memory              590.26
;  :memory                  543.70
;  :minimized-lits          1596
;  :mk-bool-var             91928308
;  :mk-clause               108491937
;  :num-allocs              217599195
;  :num-checks              764
;  :propagations            31727663
;  :quant-instantiations    37378115
;  :restarts                22
;  :rlimit-count            850745946
;  :time                    0.50)
; Constrain original permissions $k@676@04
(assert (forall ((r $Ref)) (!
  (implies
    (not
      (=
        (ite
          (and (< (inv@308@04 r) V@15@04) (<= 0 (inv@308@04 r)))
          $Perm.Write
          $Perm.No)
        $Perm.No))
    (ite
      (and (< (inv@308@04 r) V@15@04) (<= 0 (inv@308@04 r)))
      (<
        (ite
          (and
            (< (inv@677@04 r) (alen<Int> (opt_get1 $Snap.unit P@14@04)))
            (<= 0 (inv@677@04 r)))
          $k@676@04
          $Perm.No)
        $Perm.Write)
      (<
        (ite
          (and
            (< (inv@677@04 r) (alen<Int> (opt_get1 $Snap.unit P@14@04)))
            (<= 0 (inv@677@04 r)))
          $k@676@04
          $Perm.No)
        $Perm.No)))
  :pattern ((inv@308@04 r))
  :pattern ((inv@677@04 r))
  :qid |qp.srp530|)))
; Intermediate check if already taken enough permissions
(push) ; 11
(assert (not (forall ((r $Ref)) (!
  (implies
    (and
      (< (inv@677@04 r) (alen<Int> (opt_get1 $Snap.unit P@14@04)))
      (<= 0 (inv@677@04 r)))
    (= (- (- $k@676@04 (pTaken@679@04 r)) (pTaken@680@04 r)) $Perm.No))
  
  ))))
(check-sat)
; unsat
(pop) ; 11
; 0.06s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               44255884
;  :arith-add-rows          8703720
;  :arith-assert-diseq      322750
;  :arith-assert-lower      7935449
;  :arith-assert-upper      6896686
;  :arith-bound-prop        177457
;  :arith-conflicts         4346
;  :arith-eq-adapter        2819176
;  :arith-fixed-eqs         7361495
;  :arith-offset-eqs        4998522
;  :arith-pivots            1201421
;  :conflicts               9928
;  :datatype-accessor-ax    5362
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1911015
;  :del-clause              108495948
;  :final-checks            5
;  :max-generation          15
;  :max-memory              590.26
;  :memory                  543.05
;  :minimized-lits          1597
;  :mk-bool-var             91932267
;  :mk-clause               108497309
;  :num-allocs              217612252
;  :num-checks              765
;  :propagations            31728334
;  :quant-instantiations    37379044
;  :restarts                22
;  :rlimit-count            850807158
;  :time                    0.06)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@681@04 $FVF<Int>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (iff
    (Set_in r ($FVF.domain_int (as sm@681@04  $FVF<Int>)))
    (and
      (and
        (< (inv@677@04 r) (alen<Int> (opt_get1 $Snap.unit P@14@04)))
        (<= 0 (inv@677@04 r)))
      (< $Perm.No $k@676@04)))
  :pattern ((Set_in r ($FVF.domain_int (as sm@681@04  $FVF<Int>))))
  :qid |qp.fvfDomDef534|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and
          (< (inv@677@04 r) (alen<Int> (opt_get1 $Snap.unit P@14@04)))
          (<= 0 (inv@677@04 r)))
        (< $Perm.No $k@676@04))
      (and
        (and
          (and (< (inv@305@04 r) V@15@04) (<= 0 (inv@305@04 r)))
          (< (inv@304@04 r) V@15@04))
        (<= 0 (inv@304@04 r))))
    (=
      ($FVF.lookup_int (as sm@681@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@681@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04))))))))) r))
  :qid |qp.fvfValDef531|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and
          (< (inv@677@04 r) (alen<Int> (opt_get1 $Snap.unit P@14@04)))
          (<= 0 (inv@677@04 r)))
        (< $Perm.No $k@676@04))
      (and (< (inv@308@04 r) V@15@04) (<= 0 (inv@308@04 r))))
    (=
      ($FVF.lookup_int (as sm@681@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04)))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@681@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04)))))))))))) r))
  :qid |qp.fvfValDef532|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04)))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@681@04  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef533|)))
(pop) ; 10
; Joined path conditions
(assert ($Perm.isReadVar $k@676@04 $Perm.Write))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@305@04 r) V@15@04) (<= 0 (inv@305@04 r)))
        (< (inv@304@04 r) V@15@04))
      (<= 0 (inv@304@04 r)))
    (=
      ($FVF.lookup_int (as sm@678@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@678@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04))))))))) r))
  :qid |qp.fvfValDef526|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@308@04 r) V@15@04) (<= 0 (inv@308@04 r)))
    (=
      ($FVF.lookup_int (as sm@678@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04)))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@678@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04)))))))))))) r))
  :qid |qp.fvfValDef527|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04)))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@678@04  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef528|)))
(assert (forall ((i1@675@04 Int)) (!
  (implies
    (and
      (and
        (< i1@675@04 (alen<Int> (opt_get1 $Snap.unit P@14@04)))
        (<= 0 i1@675@04))
      (< $Perm.No $k@676@04))
    (=
      (inv@677@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i1@675@04))
      i1@675@04))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i1@675@04))
  :qid |int-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (< (inv@677@04 r) (alen<Int> (opt_get1 $Snap.unit P@14@04)))
        (<= 0 (inv@677@04 r)))
      (< $Perm.No $k@676@04))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) (inv@677@04 r))
      r))
  :pattern ((inv@677@04 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (iff
    (Set_in r ($FVF.domain_int (as sm@681@04  $FVF<Int>)))
    (and
      (and
        (< (inv@677@04 r) (alen<Int> (opt_get1 $Snap.unit P@14@04)))
        (<= 0 (inv@677@04 r)))
      (< $Perm.No $k@676@04)))
  :pattern ((Set_in r ($FVF.domain_int (as sm@681@04  $FVF<Int>))))
  :qid |qp.fvfDomDef534|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and
          (< (inv@677@04 r) (alen<Int> (opt_get1 $Snap.unit P@14@04)))
          (<= 0 (inv@677@04 r)))
        (< $Perm.No $k@676@04))
      (and
        (and
          (and (< (inv@305@04 r) V@15@04) (<= 0 (inv@305@04 r)))
          (< (inv@304@04 r) V@15@04))
        (<= 0 (inv@304@04 r))))
    (=
      ($FVF.lookup_int (as sm@681@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@681@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04))))))))) r))
  :qid |qp.fvfValDef531|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and
          (< (inv@677@04 r) (alen<Int> (opt_get1 $Snap.unit P@14@04)))
          (<= 0 (inv@677@04 r)))
        (< $Perm.No $k@676@04))
      (and (< (inv@308@04 r) V@15@04) (<= 0 (inv@308@04 r))))
    (=
      ($FVF.lookup_int (as sm@681@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04)))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@681@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04)))))))))))) r))
  :qid |qp.fvfValDef532|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04)))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@681@04  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef533|)))
(assert (and
  (forall ((r $Ref)) (!
    (implies
      (and
        (< (inv@677@04 r) (alen<Int> (opt_get1 $Snap.unit P@14@04)))
        (<= 0 (inv@677@04 r)))
      ($FVF.loc_int ($FVF.lookup_int (as sm@678@04  $FVF<Int>) r) r))
    :pattern ((inv@677@04 r))
    ))
  (forall ((r $Ref)) (!
    (implies
      (not
        (=
          (ite
            (and
              (and
                (and (< (inv@305@04 r) V@15@04) (<= 0 (inv@305@04 r)))
                (< (inv@304@04 r) V@15@04))
              (<= 0 (inv@304@04 r)))
            $Perm.Write
            $Perm.No)
          $Perm.No))
      (ite
        (and
          (and
            (and (< (inv@305@04 r) V@15@04) (<= 0 (inv@305@04 r)))
            (< (inv@304@04 r) V@15@04))
          (<= 0 (inv@304@04 r)))
        (<
          (ite
            (and
              (< (inv@677@04 r) (alen<Int> (opt_get1 $Snap.unit P@14@04)))
              (<= 0 (inv@677@04 r)))
            $k@676@04
            $Perm.No)
          $Perm.Write)
        (<
          (ite
            (and
              (< (inv@677@04 r) (alen<Int> (opt_get1 $Snap.unit P@14@04)))
              (<= 0 (inv@677@04 r)))
            $k@676@04
            $Perm.No)
          $Perm.No)))
    :pattern ((inv@305@04 r))
    :pattern ((inv@304@04 r))
    :pattern ((inv@677@04 r))
    :qid |qp.srp529|))
  (forall ((r $Ref)) (!
    (implies
      (not
        (=
          (ite
            (and (< (inv@308@04 r) V@15@04) (<= 0 (inv@308@04 r)))
            $Perm.Write
            $Perm.No)
          $Perm.No))
      (ite
        (and (< (inv@308@04 r) V@15@04) (<= 0 (inv@308@04 r)))
        (<
          (ite
            (and
              (< (inv@677@04 r) (alen<Int> (opt_get1 $Snap.unit P@14@04)))
              (<= 0 (inv@677@04 r)))
            $k@676@04
            $Perm.No)
          $Perm.Write)
        (<
          (ite
            (and
              (< (inv@677@04 r) (alen<Int> (opt_get1 $Snap.unit P@14@04)))
              (<= 0 (inv@677@04 r)))
            $k@676@04
            $Perm.No)
          $Perm.No)))
    :pattern ((inv@308@04 r))
    :pattern ((inv@677@04 r))
    :qid |qp.srp530|))))
(declare-const P_seq@682@04 Seq<Int>)
(assert (Seq_equal
  P_seq@682@04
  (unknown_ ($Snap.combine
    $Snap.unit
    ($Snap.combine
      $Snap.unit
      ($Snap.combine
        $Snap.unit
        ($Snap.combine
          $Snap.unit
          ($SortWrappers.$FVF<Int>To$Snap (as sm@681@04  $FVF<Int>)))))) P@14@04 0 (alen<Int> (opt_get1 $Snap.unit P@14@04)))))
; [exec]
; return := maxFlow
; [exec]
; label end
; [exec]
; res := return
; [exec]
; label bubble
; [eval] exc == null
; [eval] exc == null ==> 0 <= s
; [eval] exc == null
(push) ; 10
(set-option :timeout 10)
(push) ; 11
(assert (not (not (= exc@291@04 $Ref.null))))
(check-sat)
; unknown
(pop) ; 11
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               44256019
;  :arith-add-rows          8703786
;  :arith-assert-diseq      322755
;  :arith-assert-lower      7935488
;  :arith-assert-upper      6896714
;  :arith-bound-prop        177457
;  :arith-conflicts         4346
;  :arith-eq-adapter        2819201
;  :arith-fixed-eqs         7361525
;  :arith-offset-eqs        4998528
;  :arith-pivots            1201432
;  :conflicts               9928
;  :datatype-accessor-ax    5366
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1911029
;  :del-clause              108496551
;  :final-checks            5
;  :max-generation          15
;  :max-memory              590.26
;  :memory                  542.69
;  :minimized-lits          1597
;  :mk-bool-var             91932950
;  :mk-clause               108498053
;  :num-allocs              217617227
;  :num-checks              766
;  :propagations            31728471
;  :quant-instantiations    37379271
;  :restarts                22
;  :rlimit-count            850825605
;  :time                    0.01)
; [then-branch: 363 | exc@291@04 == Null | live]
; [else-branch: 363 | exc@291@04 != Null | dead]
(push) ; 11
; [then-branch: 363 | exc@291@04 == Null]
; [eval] 0 <= s
(pop) ; 11
(pop) ; 10
; Joined path conditions
(set-option :timeout 0)
(push) ; 10
(assert (not (implies (= exc@291@04 $Ref.null) (<= 0 s@12@04))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               44256019
;  :arith-add-rows          8703786
;  :arith-assert-diseq      322755
;  :arith-assert-lower      7935488
;  :arith-assert-upper      6896714
;  :arith-bound-prop        177457
;  :arith-conflicts         4346
;  :arith-eq-adapter        2819201
;  :arith-fixed-eqs         7361525
;  :arith-offset-eqs        4998528
;  :arith-pivots            1201432
;  :conflicts               9928
;  :datatype-accessor-ax    5366
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1911029
;  :del-clause              108496551
;  :final-checks            5
;  :max-generation          15
;  :max-memory              590.26
;  :memory                  542.69
;  :minimized-lits          1597
;  :mk-bool-var             91932950
;  :mk-clause               108498053
;  :num-allocs              217617255
;  :num-checks              767
;  :propagations            31728471
;  :quant-instantiations    37379271
;  :restarts                22
;  :rlimit-count            850825631)
(assert (implies (= exc@291@04 $Ref.null) (<= 0 s@12@04)))
; [eval] exc == null ==> s < V
; [eval] exc == null
(push) ; 10
(set-option :timeout 10)
(push) ; 11
(assert (not (not (= exc@291@04 $Ref.null))))
(check-sat)
; unknown
(pop) ; 11
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               44256191
;  :arith-add-rows          8703888
;  :arith-assert-diseq      322761
;  :arith-assert-lower      7935532
;  :arith-assert-upper      6896745
;  :arith-bound-prop        177457
;  :arith-conflicts         4346
;  :arith-eq-adapter        2819231
;  :arith-fixed-eqs         7361560
;  :arith-offset-eqs        4998539
;  :arith-pivots            1201440
;  :conflicts               9928
;  :datatype-accessor-ax    5366
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1911055
;  :del-clause              108497639
;  :final-checks            5
;  :max-generation          15
;  :max-memory              590.26
;  :memory                  542.50
;  :minimized-lits          1597
;  :mk-bool-var             91933857
;  :mk-clause               108499141
;  :num-allocs              217620433
;  :num-checks              768
;  :propagations            31728620
;  :quant-instantiations    37379572
;  :restarts                22
;  :rlimit-count            850839904
;  :time                    0.01)
; [then-branch: 364 | exc@291@04 == Null | live]
; [else-branch: 364 | exc@291@04 != Null | dead]
(push) ; 11
; [then-branch: 364 | exc@291@04 == Null]
; [eval] s < V
(pop) ; 11
(pop) ; 10
; Joined path conditions
(set-option :timeout 0)
(push) ; 10
(assert (not (implies (= exc@291@04 $Ref.null) (< s@12@04 V@15@04))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               44256191
;  :arith-add-rows          8703888
;  :arith-assert-diseq      322761
;  :arith-assert-lower      7935532
;  :arith-assert-upper      6896745
;  :arith-bound-prop        177457
;  :arith-conflicts         4346
;  :arith-eq-adapter        2819231
;  :arith-fixed-eqs         7361560
;  :arith-offset-eqs        4998539
;  :arith-pivots            1201440
;  :conflicts               9928
;  :datatype-accessor-ax    5366
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1911055
;  :del-clause              108497639
;  :final-checks            5
;  :max-generation          15
;  :max-memory              590.26
;  :memory                  542.50
;  :minimized-lits          1597
;  :mk-bool-var             91933857
;  :mk-clause               108499141
;  :num-allocs              217620467
;  :num-checks              769
;  :propagations            31728620
;  :quant-instantiations    37379572
;  :restarts                22
;  :rlimit-count            850839933)
(assert (implies (= exc@291@04 $Ref.null) (< s@12@04 V@15@04)))
; [eval] exc == null ==> 0 <= t
; [eval] exc == null
(push) ; 10
(set-option :timeout 10)
(push) ; 11
(assert (not (not (= exc@291@04 $Ref.null))))
(check-sat)
; unknown
(pop) ; 11
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               44256430
;  :arith-add-rows          8704012
;  :arith-assert-diseq      322769
;  :arith-assert-lower      7935595
;  :arith-assert-upper      6896790
;  :arith-bound-prop        177457
;  :arith-conflicts         4346
;  :arith-eq-adapter        2819266
;  :arith-fixed-eqs         7361616
;  :arith-offset-eqs        4998557
;  :arith-pivots            1201456
;  :conflicts               9928
;  :datatype-accessor-ax    5366
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1911083
;  :del-clause              108498960
;  :final-checks            5
;  :max-generation          15
;  :max-memory              590.26
;  :memory                  542.41
;  :minimized-lits          1597
;  :mk-bool-var             91935032
;  :mk-clause               108500462
;  :num-allocs              217624519
;  :num-checks              770
;  :propagations            31728843
;  :quant-instantiations    37380000
;  :restarts                22
;  :rlimit-count            850858772
;  :time                    0.01)
; [then-branch: 365 | exc@291@04 == Null | live]
; [else-branch: 365 | exc@291@04 != Null | dead]
(push) ; 11
; [then-branch: 365 | exc@291@04 == Null]
; [eval] 0 <= t
(pop) ; 11
(pop) ; 10
; Joined path conditions
(set-option :timeout 0)
(push) ; 10
(assert (not (implies (= exc@291@04 $Ref.null) (<= 0 t@13@04))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               44256430
;  :arith-add-rows          8704012
;  :arith-assert-diseq      322769
;  :arith-assert-lower      7935595
;  :arith-assert-upper      6896790
;  :arith-bound-prop        177457
;  :arith-conflicts         4346
;  :arith-eq-adapter        2819266
;  :arith-fixed-eqs         7361616
;  :arith-offset-eqs        4998557
;  :arith-pivots            1201456
;  :conflicts               9928
;  :datatype-accessor-ax    5366
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1911083
;  :del-clause              108498960
;  :final-checks            5
;  :max-generation          15
;  :max-memory              590.26
;  :memory                  542.41
;  :minimized-lits          1597
;  :mk-bool-var             91935032
;  :mk-clause               108500462
;  :num-allocs              217624547
;  :num-checks              771
;  :propagations            31728843
;  :quant-instantiations    37380000
;  :restarts                22
;  :rlimit-count            850858798)
(assert (implies (= exc@291@04 $Ref.null) (<= 0 t@13@04)))
; [eval] exc == null ==> t < V
; [eval] exc == null
(push) ; 10
(set-option :timeout 10)
(push) ; 11
(assert (not (not (= exc@291@04 $Ref.null))))
(check-sat)
; unknown
(pop) ; 11
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               44256602
;  :arith-add-rows          8704132
;  :arith-assert-diseq      322775
;  :arith-assert-lower      7935639
;  :arith-assert-upper      6896821
;  :arith-bound-prop        177457
;  :arith-conflicts         4346
;  :arith-eq-adapter        2819297
;  :arith-fixed-eqs         7361651
;  :arith-offset-eqs        4998568
;  :arith-pivots            1201464
;  :conflicts               9928
;  :datatype-accessor-ax    5366
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1911109
;  :del-clause              108500189
;  :final-checks            5
;  :max-generation          15
;  :max-memory              590.26
;  :memory                  542.36
;  :minimized-lits          1597
;  :mk-bool-var             91936051
;  :mk-clause               108501691
;  :num-allocs              217627827
;  :num-checks              772
;  :propagations            31728992
;  :quant-instantiations    37380345
;  :restarts                22
;  :rlimit-count            850873324
;  :time                    0.01)
; [then-branch: 366 | exc@291@04 == Null | live]
; [else-branch: 366 | exc@291@04 != Null | dead]
(push) ; 11
; [then-branch: 366 | exc@291@04 == Null]
; [eval] t < V
(pop) ; 11
(pop) ; 10
; Joined path conditions
(set-option :timeout 0)
(push) ; 10
(assert (not (implies (= exc@291@04 $Ref.null) (< t@13@04 V@15@04))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               44256602
;  :arith-add-rows          8704132
;  :arith-assert-diseq      322775
;  :arith-assert-lower      7935639
;  :arith-assert-upper      6896821
;  :arith-bound-prop        177457
;  :arith-conflicts         4346
;  :arith-eq-adapter        2819297
;  :arith-fixed-eqs         7361651
;  :arith-offset-eqs        4998568
;  :arith-pivots            1201464
;  :conflicts               9928
;  :datatype-accessor-ax    5366
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1911109
;  :del-clause              108500189
;  :final-checks            5
;  :max-generation          15
;  :max-memory              590.26
;  :memory                  542.36
;  :minimized-lits          1597
;  :mk-bool-var             91936051
;  :mk-clause               108501691
;  :num-allocs              217627855
;  :num-checks              773
;  :propagations            31728992
;  :quant-instantiations    37380345
;  :restarts                22
;  :rlimit-count            850873353)
(assert (implies (= exc@291@04 $Ref.null) (< t@13@04 V@15@04)))
; [eval] exc == null ==> G != (None(): option[array])
; [eval] exc == null
(push) ; 10
(set-option :timeout 10)
(push) ; 11
(assert (not (not (= exc@291@04 $Ref.null))))
(check-sat)
; unknown
(pop) ; 11
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               44256856
;  :arith-add-rows          8704292
;  :arith-assert-diseq      322784
;  :arith-assert-lower      7935703
;  :arith-assert-upper      6896866
;  :arith-bound-prop        177457
;  :arith-conflicts         4346
;  :arith-eq-adapter        2819332
;  :arith-fixed-eqs         7361707
;  :arith-offset-eqs        4998586
;  :arith-pivots            1201480
;  :conflicts               9928
;  :datatype-accessor-ax    5366
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1911150
;  :del-clause              108501860
;  :final-checks            5
;  :max-generation          15
;  :max-memory              590.26
;  :memory                  542.34
;  :minimized-lits          1597
;  :mk-bool-var             91937452
;  :mk-clause               108503362
;  :num-allocs              217632709
;  :num-checks              774
;  :propagations            31729259
;  :quant-instantiations    37380811
;  :restarts                22
;  :rlimit-count            850895520
;  :time                    0.01)
; [then-branch: 367 | exc@291@04 == Null | live]
; [else-branch: 367 | exc@291@04 != Null | dead]
(push) ; 11
; [then-branch: 367 | exc@291@04 == Null]
; [eval] G != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 11
(pop) ; 10
; Joined path conditions
(set-option :timeout 0)
(push) ; 10
(assert (not (implies
  (= exc@291@04 $Ref.null)
  (not (= G@11@04 (as None<option<array>>  option<array>))))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               44256856
;  :arith-add-rows          8704292
;  :arith-assert-diseq      322784
;  :arith-assert-lower      7935703
;  :arith-assert-upper      6896866
;  :arith-bound-prop        177457
;  :arith-conflicts         4346
;  :arith-eq-adapter        2819332
;  :arith-fixed-eqs         7361707
;  :arith-offset-eqs        4998586
;  :arith-pivots            1201480
;  :conflicts               9928
;  :datatype-accessor-ax    5366
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1911150
;  :del-clause              108501860
;  :final-checks            5
;  :max-generation          15
;  :max-memory              590.26
;  :memory                  542.34
;  :minimized-lits          1597
;  :mk-bool-var             91937452
;  :mk-clause               108503362
;  :num-allocs              217632733
;  :num-checks              775
;  :propagations            31729259
;  :quant-instantiations    37380811
;  :restarts                22
;  :rlimit-count            850895540)
(assert (implies
  (= exc@291@04 $Ref.null)
  (not (= G@11@04 (as None<option<array>>  option<array>)))))
; [eval] exc == null ==> alen(opt_get1(G)) == V
; [eval] exc == null
(push) ; 10
(set-option :timeout 10)
(push) ; 11
(assert (not (not (= exc@291@04 $Ref.null))))
(check-sat)
; unknown
(pop) ; 11
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               44257028
;  :arith-add-rows          8704412
;  :arith-assert-diseq      322790
;  :arith-assert-lower      7935747
;  :arith-assert-upper      6896897
;  :arith-bound-prop        177457
;  :arith-conflicts         4346
;  :arith-eq-adapter        2819363
;  :arith-fixed-eqs         7361742
;  :arith-offset-eqs        4998597
;  :arith-pivots            1201488
;  :conflicts               9928
;  :datatype-accessor-ax    5366
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1911176
;  :del-clause              108503116
;  :final-checks            5
;  :max-generation          15
;  :max-memory              590.26
;  :memory                  542.34
;  :minimized-lits          1597
;  :mk-bool-var             91938500
;  :mk-clause               108504618
;  :num-allocs              217636379
;  :num-checks              776
;  :propagations            31729408
;  :quant-instantiations    37381182
;  :restarts                22
;  :rlimit-count            850911838
;  :time                    0.01)
; [then-branch: 368 | exc@291@04 == Null | live]
; [else-branch: 368 | exc@291@04 != Null | dead]
(push) ; 11
; [then-branch: 368 | exc@291@04 == Null]
; [eval] alen(opt_get1(G)) == V
; [eval] alen(opt_get1(G))
; [eval] opt_get1(G)
(push) ; 12
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 12
; Joined path conditions
(pop) ; 11
(pop) ; 10
; Joined path conditions
(set-option :timeout 0)
(push) ; 10
(assert (not (implies
  (= exc@291@04 $Ref.null)
  (= (alen<Int> (opt_get1 $Snap.unit G@11@04)) V@15@04))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               44257028
;  :arith-add-rows          8704412
;  :arith-assert-diseq      322790
;  :arith-assert-lower      7935747
;  :arith-assert-upper      6896897
;  :arith-bound-prop        177457
;  :arith-conflicts         4346
;  :arith-eq-adapter        2819363
;  :arith-fixed-eqs         7361742
;  :arith-offset-eqs        4998597
;  :arith-pivots            1201488
;  :conflicts               9928
;  :datatype-accessor-ax    5366
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1911176
;  :del-clause              108503116
;  :final-checks            5
;  :max-generation          15
;  :max-memory              590.26
;  :memory                  542.34
;  :minimized-lits          1597
;  :mk-bool-var             91938500
;  :mk-clause               108504618
;  :num-allocs              217636397
;  :num-checks              777
;  :propagations            31729408
;  :quant-instantiations    37381182
;  :restarts                22
;  :rlimit-count            850911863)
(assert (implies
  (= exc@291@04 $Ref.null)
  (= (alen<Int> (opt_get1 $Snap.unit G@11@04)) V@15@04)))
; [eval] exc == null
(set-option :timeout 10)
(push) ; 10
(assert (not (not (= exc@291@04 $Ref.null))))
(check-sat)
; unknown
(pop) ; 10
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               44257270
;  :arith-add-rows          8704542
;  :arith-assert-diseq      322798
;  :arith-assert-lower      7935810
;  :arith-assert-upper      6896942
;  :arith-bound-prop        177457
;  :arith-conflicts         4346
;  :arith-eq-adapter        2819398
;  :arith-fixed-eqs         7361798
;  :arith-offset-eqs        4998615
;  :arith-pivots            1201504
;  :conflicts               9928
;  :datatype-accessor-ax    5366
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1911206
;  :del-clause              108504500
;  :final-checks            5
;  :max-generation          15
;  :max-memory              590.26
;  :memory                  542.34
;  :minimized-lits          1597
;  :mk-bool-var             91939713
;  :mk-clause               108506002
;  :num-allocs              217640441
;  :num-checks              778
;  :propagations            31729640
;  :quant-instantiations    37381617
;  :restarts                22
;  :rlimit-count            850930806
;  :time                    0.01)
; [then-branch: 369 | exc@291@04 == Null | live]
; [else-branch: 369 | exc@291@04 != Null | dead]
(push) ; 10
; [then-branch: 369 | exc@291@04 == Null]
(declare-const i1@683@04 Int)
(push) ; 11
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 12
; [then-branch: 370 | 0 <= i1@683@04 | live]
; [else-branch: 370 | !(0 <= i1@683@04) | live]
(push) ; 13
; [then-branch: 370 | 0 <= i1@683@04]
(assert (<= 0 i1@683@04))
; [eval] i1 < V
(pop) ; 13
(push) ; 13
; [else-branch: 370 | !(0 <= i1@683@04)]
(assert (not (<= 0 i1@683@04)))
(pop) ; 13
(pop) ; 12
; Joined path conditions
; Joined path conditions
(assert (and (< i1@683@04 V@15@04) (<= 0 i1@683@04)))
(declare-const $k@684@04 $Perm)
(assert ($Perm.isReadVar $k@684@04 $Perm.Write))
; [eval] aloc(opt_get1(G), i1)
; [eval] opt_get1(G)
(push) ; 12
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 12
; Joined path conditions
(push) ; 12
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 13
(assert (not (< i1@683@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))))
(check-sat)
; unsat
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               44257270
;  :arith-add-rows          8704543
;  :arith-assert-diseq      322799
;  :arith-assert-lower      7935814
;  :arith-assert-upper      6896943
;  :arith-bound-prop        177457
;  :arith-conflicts         4346
;  :arith-eq-adapter        2819399
;  :arith-fixed-eqs         7361798
;  :arith-offset-eqs        4998615
;  :arith-pivots            1201504
;  :conflicts               9928
;  :datatype-accessor-ax    5366
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1911206
;  :del-clause              108504500
;  :final-checks            5
;  :max-generation          15
;  :max-memory              590.26
;  :memory                  542.34
;  :minimized-lits          1597
;  :mk-bool-var             91939719
;  :mk-clause               108506004
;  :num-allocs              217640606
;  :num-checks              779
;  :propagations            31729641
;  :quant-instantiations    37381617
;  :restarts                22
;  :rlimit-count            850931134)
(assert (< i1@683@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(pop) ; 12
; Joined path conditions
(assert (< i1@683@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(pop) ; 11
(declare-fun inv@685@04 ($Ref) Int)
; Nested auxiliary terms: globals
(assert ($Perm.isReadVar $k@684@04 $Perm.Write))
; Nested auxiliary terms: non-globals
(assert (forall ((i1@683@04 Int)) (!
  (< i1@683@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@683@04))
  :qid |option$array$-aux|)))
(push) ; 11
(assert (not (forall ((i1@683@04 Int)) (!
  (implies
    (and (< i1@683@04 V@15@04) (<= 0 i1@683@04))
    (or (= $k@684@04 $Perm.No) (< $Perm.No $k@684@04)))
  
  ))))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               44257270
;  :arith-add-rows          8704544
;  :arith-assert-diseq      322800
;  :arith-assert-lower      7935816
;  :arith-assert-upper      6896944
;  :arith-bound-prop        177457
;  :arith-conflicts         4346
;  :arith-eq-adapter        2819400
;  :arith-fixed-eqs         7361798
;  :arith-offset-eqs        4998615
;  :arith-pivots            1201504
;  :conflicts               9929
;  :datatype-accessor-ax    5366
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1911206
;  :del-clause              108504502
;  :final-checks            5
;  :max-generation          15
;  :max-memory              590.26
;  :memory                  542.34
;  :minimized-lits          1597
;  :mk-bool-var             91939726
;  :mk-clause               108506006
;  :num-allocs              217641034
;  :num-checks              780
;  :propagations            31729642
;  :quant-instantiations    37381617
;  :restarts                22
;  :rlimit-count            850931681)
(declare-const sm@686@04 $FVF<option<array>>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (ite
          (and (< (inv@262@04 r) V@15@04) (<= 0 (inv@262@04 r)))
          $k@261@04
          $Perm.No)
        (pTaken@319@04 r)))
    (=
      ($FVF.lookup_option$array$ (as sm@686@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@259@04))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@686@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@259@04))))) r))
  :qid |qp.fvfValDef535|)))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (ite
          (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
          $k@20@04
          $Perm.No)
        (pTaken@234@04 r)))
    (=
      ($FVF.lookup_option$array$ (as sm@686@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@686@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r))
  :qid |qp.fvfValDef536|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@296@04 r) V@15@04) (<= 0 (inv@296@04 r)))
      (< $Perm.No $k@295@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@686@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@686@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r))
  :qid |qp.fvfValDef537|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@259@04))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r) r))
  :pattern (($FVF.lookup_option$array$ (as sm@686@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef538|)))
; Check receiver injectivity
(push) ; 11
(assert (not (forall ((i11@683@04 Int) (i12@683@04 Int)) (!
  (implies
    (and
      (and
        (and
          (and (< i11@683@04 V@15@04) (<= 0 i11@683@04))
          ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@686@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i11@683@04)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i11@683@04)))
        (< $Perm.No $k@684@04))
      (and
        (and
          (and (< i12@683@04 V@15@04) (<= 0 i12@683@04))
          ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@686@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i12@683@04)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i12@683@04)))
        (< $Perm.No $k@684@04))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i11@683@04)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i12@683@04)))
    (= i11@683@04 i12@683@04))
  
  :qid |option$array$-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               44257316
;  :arith-add-rows          8704557
;  :arith-assert-diseq      322801
;  :arith-assert-lower      7935820
;  :arith-assert-upper      6896944
;  :arith-bound-prop        177457
;  :arith-conflicts         4346
;  :arith-eq-adapter        2819401
;  :arith-fixed-eqs         7361798
;  :arith-offset-eqs        4998615
;  :arith-pivots            1201508
;  :conflicts               9930
;  :datatype-accessor-ax    5366
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1911206
;  :del-clause              108504539
;  :final-checks            5
;  :max-generation          15
;  :max-memory              590.26
;  :memory                  542.34
;  :minimized-lits          1597
;  :mk-bool-var             91939835
;  :mk-clause               108506043
;  :num-allocs              217642819
;  :num-checks              781
;  :propagations            31729645
;  :quant-instantiations    37381696
;  :restarts                22
;  :rlimit-count            850937123
;  :time                    0.00)
; Definitional axioms for inverse functions
(assert (forall ((i1@683@04 Int)) (!
  (implies
    (and (and (< i1@683@04 V@15@04) (<= 0 i1@683@04)) (< $Perm.No $k@684@04))
    (=
      (inv@685@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@683@04))
      i1@683@04))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@683@04))
  :qid |option$array$-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and (< (inv@685@04 r) V@15@04) (<= 0 (inv@685@04 r)))
      (< $Perm.No $k@684@04))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) (inv@685@04 r))
      r))
  :pattern ((inv@685@04 r))
  :qid |option$array$-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@685@04 r) V@15@04) (<= 0 (inv@685@04 r)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@686@04  $FVF<option<array>>) r) r))
  :pattern ((inv@685@04 r))
  )))
; Precomputing data for removing quantified permissions
(define-fun pTaken@687@04 ((r $Ref)) $Perm
  (ite
    (and (< (inv@685@04 r) V@15@04) (<= 0 (inv@685@04 r)))
    ($Perm.min
      (-
        (ite
          (and (< (inv@262@04 r) V@15@04) (<= 0 (inv@262@04 r)))
          $k@261@04
          $Perm.No)
        (pTaken@319@04 r))
      $k@684@04)
    $Perm.No))
(define-fun pTaken@688@04 ((r $Ref)) $Perm
  (ite
    (and (< (inv@685@04 r) V@15@04) (<= 0 (inv@685@04 r)))
    ($Perm.min
      (-
        (ite
          (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
          $k@20@04
          $Perm.No)
        (pTaken@234@04 r))
      (- $k@684@04 (pTaken@687@04 r)))
    $Perm.No))
(define-fun pTaken@689@04 ((r $Ref)) $Perm
  (ite
    (and (< (inv@685@04 r) V@15@04) (<= 0 (inv@685@04 r)))
    ($Perm.min
      (ite
        (and (< (inv@296@04 r) V@15@04) (<= 0 (inv@296@04 r)))
        $k@295@04
        $Perm.No)
      (- (- $k@684@04 (pTaken@687@04 r)) (pTaken@688@04 r)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Constrain original permissions $k@684@04
(assert (forall ((r $Ref)) (!
  (implies
    (not
      (=
        (-
          (ite
            (and (< (inv@262@04 r) V@15@04) (<= 0 (inv@262@04 r)))
            $k@261@04
            $Perm.No)
          (pTaken@319@04 r))
        $Perm.No))
    (<
      (ite
        (and (< (inv@685@04 r) V@15@04) (<= 0 (inv@685@04 r)))
        $k@684@04
        $Perm.No)
      (-
        (ite
          (and (< (inv@262@04 r) V@15@04) (<= 0 (inv@262@04 r)))
          $k@261@04
          $Perm.No)
        (pTaken@319@04 r))))
  :pattern ((inv@262@04 r))
  :pattern ((inv@685@04 r))
  :qid |qp.srp539|)))
; Intermediate check if already taken enough permissions
(set-option :timeout 500)
(push) ; 11
(assert (not (forall ((r $Ref)) (!
  (implies
    (and (< (inv@685@04 r) V@15@04) (<= 0 (inv@685@04 r)))
    (= (- $k@684@04 (pTaken@687@04 r)) $Perm.No))
  
  ))))
(check-sat)
; unknown
(pop) ; 11
; 0.52s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               44263607
;  :arith-add-rows          8708212
;  :arith-assert-diseq      322857
;  :arith-assert-lower      7936962
;  :arith-assert-upper      6897752
;  :arith-bound-prop        177708
;  :arith-conflicts         4350
;  :arith-eq-adapter        2820336
;  :arith-fixed-eqs         7362587
;  :arith-offset-eqs        4999264
;  :arith-pivots            1202490
;  :conflicts               9936
;  :datatype-accessor-ax    5366
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1911701
;  :del-clause              108537904
;  :final-checks            5
;  :max-generation          15
;  :max-memory              590.26
;  :memory                  543.20
;  :minimized-lits          1597
;  :mk-bool-var             91971541
;  :mk-clause               108539408
;  :num-allocs              217736957
;  :num-checks              783
;  :propagations            31736180
;  :quant-instantiations    37392791
;  :restarts                22
;  :rlimit-count            851364686
;  :time                    0.52)
; Constrain original permissions $k@684@04
(assert (forall ((r $Ref)) (!
  (implies
    (not
      (=
        (-
          (ite
            (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
            $k@20@04
            $Perm.No)
          (pTaken@234@04 r))
        $Perm.No))
    (<
      (ite
        (and (< (inv@685@04 r) V@15@04) (<= 0 (inv@685@04 r)))
        $k@684@04
        $Perm.No)
      (-
        (ite
          (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
          $k@20@04
          $Perm.No)
        (pTaken@234@04 r))))
  :pattern ((inv@21@04 r))
  :pattern ((inv@685@04 r))
  :qid |qp.srp540|)))
; Intermediate check if already taken enough permissions
(push) ; 11
(assert (not (forall ((r $Ref)) (!
  (implies
    (and (< (inv@685@04 r) V@15@04) (<= 0 (inv@685@04 r)))
    (= (- (- $k@684@04 (pTaken@687@04 r)) (pTaken@688@04 r)) $Perm.No))
  
  ))))
(check-sat)
; unsat
(pop) ; 11
; 0.09s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               44264596
;  :arith-add-rows          8709321
;  :arith-assert-diseq      322906
;  :arith-assert-lower      7937149
;  :arith-assert-upper      6897869
;  :arith-bound-prop        177759
;  :arith-conflicts         4357
;  :arith-eq-adapter        2820505
;  :arith-fixed-eqs         7362688
;  :arith-offset-eqs        4999330
;  :arith-pivots            1202595
;  :conflicts               9964
;  :datatype-accessor-ax    5366
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1911900
;  :del-clause              108544313
;  :final-checks            5
;  :max-generation          15
;  :max-memory              590.26
;  :memory                  543.49
;  :minimized-lits          1601
;  :mk-bool-var             91976621
;  :mk-clause               108545817
;  :num-allocs              217753821
;  :num-checks              784
;  :propagations            31737204
;  :quant-instantiations    37393908
;  :restarts                22
;  :rlimit-count            851434096
;  :time                    0.09)
; Final check if taken enough permissions
; Done removing quantified permissions
; Definitional axioms for snapshot map values
; [eval] exc == null ==> (forall i1: Int :: { aloc(opt_get1(G), i1) } 0 <= i1 && i1 < V ==> aloc(opt_get1(G), i1).option$array$ != (None(): option[array]))
; [eval] exc == null
(push) ; 11
(set-option :timeout 10)
(push) ; 12
(assert (not (not (= exc@291@04 $Ref.null))))
(check-sat)
; unknown
(pop) ; 12
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               44264644
;  :arith-add-rows          8709379
;  :arith-assert-diseq      322909
;  :arith-assert-lower      7937168
;  :arith-assert-upper      6897883
;  :arith-bound-prop        177759
;  :arith-conflicts         4357
;  :arith-eq-adapter        2820523
;  :arith-fixed-eqs         7362705
;  :arith-offset-eqs        4999335
;  :arith-pivots            1202595
;  :conflicts               9964
;  :datatype-accessor-ax    5366
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1911914
;  :del-clause              108544894
;  :final-checks            5
;  :max-generation          15
;  :max-memory              590.26
;  :memory                  543.30
;  :minimized-lits          1601
;  :mk-bool-var             91977046
;  :mk-clause               108546398
;  :num-allocs              217755571
;  :num-checks              785
;  :propagations            31737294
;  :quant-instantiations    37394061
;  :restarts                22
;  :rlimit-count            851441412
;  :time                    0.01)
; [then-branch: 371 | exc@291@04 == Null | live]
; [else-branch: 371 | exc@291@04 != Null | dead]
(push) ; 12
; [then-branch: 371 | exc@291@04 == Null]
; [eval] (forall i1: Int :: { aloc(opt_get1(G), i1) } 0 <= i1 && i1 < V ==> aloc(opt_get1(G), i1).option$array$ != (None(): option[array]))
(declare-const i1@690@04 Int)
(push) ; 13
; [eval] 0 <= i1 && i1 < V ==> aloc(opt_get1(G), i1).option$array$ != (None(): option[array])
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 14
; [then-branch: 372 | 0 <= i1@690@04 | live]
; [else-branch: 372 | !(0 <= i1@690@04) | live]
(push) ; 15
; [then-branch: 372 | 0 <= i1@690@04]
(assert (<= 0 i1@690@04))
; [eval] i1 < V
(pop) ; 15
(push) ; 15
; [else-branch: 372 | !(0 <= i1@690@04)]
(assert (not (<= 0 i1@690@04)))
(pop) ; 15
(pop) ; 14
; Joined path conditions
; Joined path conditions
(push) ; 14
; [then-branch: 373 | i1@690@04 < V@15@04 && 0 <= i1@690@04 | live]
; [else-branch: 373 | !(i1@690@04 < V@15@04 && 0 <= i1@690@04) | live]
(push) ; 15
; [then-branch: 373 | i1@690@04 < V@15@04 && 0 <= i1@690@04]
(assert (and (< i1@690@04 V@15@04) (<= 0 i1@690@04)))
; [eval] aloc(opt_get1(G), i1).option$array$ != (None(): option[array])
; [eval] aloc(opt_get1(G), i1)
; [eval] opt_get1(G)
(push) ; 16
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 16
; Joined path conditions
(push) ; 16
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 17
(assert (not (< i1@690@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))))
(check-sat)
; unsat
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               44264644
;  :arith-add-rows          8709380
;  :arith-assert-diseq      322909
;  :arith-assert-lower      7937170
;  :arith-assert-upper      6897883
;  :arith-bound-prop        177759
;  :arith-conflicts         4357
;  :arith-eq-adapter        2820523
;  :arith-fixed-eqs         7362705
;  :arith-offset-eqs        4999335
;  :arith-pivots            1202596
;  :conflicts               9964
;  :datatype-accessor-ax    5366
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1911914
;  :del-clause              108544894
;  :final-checks            5
;  :max-generation          15
;  :max-memory              590.26
;  :memory                  543.30
;  :minimized-lits          1601
;  :mk-bool-var             91977048
;  :mk-clause               108546398
;  :num-allocs              217755675
;  :num-checks              786
;  :propagations            31737294
;  :quant-instantiations    37394061
;  :restarts                22
;  :rlimit-count            851441613)
(assert (< i1@690@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(pop) ; 16
; Joined path conditions
(assert (< i1@690@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@686@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@690@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@690@04)))
(push) ; 16
(assert (not (<
  $Perm.No
  (+
    (+
      (-
        (ite
          (and
            (<
              (inv@262@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@690@04))
              V@15@04)
            (<=
              0
              (inv@262@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@690@04))))
          $k@261@04
          $Perm.No)
        (pTaken@319@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@690@04)))
      (-
        (ite
          (and
            (<
              (inv@21@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@690@04))
              V@15@04)
            (<=
              0
              (inv@21@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@690@04))))
          $k@20@04
          $Perm.No)
        (pTaken@234@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@690@04))))
    (ite
      (and
        (<
          (inv@296@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@690@04))
          V@15@04)
        (<=
          0
          (inv@296@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@690@04))))
      $k@295@04
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 16
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               44265040
;  :arith-add-rows          8709715
;  :arith-assert-diseq      322931
;  :arith-assert-lower      7937280
;  :arith-assert-upper      6897934
;  :arith-bound-prop        177823
;  :arith-conflicts         4361
;  :arith-eq-adapter        2820600
;  :arith-fixed-eqs         7362745
;  :arith-offset-eqs        4999368
;  :arith-pivots            1202669
;  :conflicts               9975
;  :datatype-accessor-ax    5366
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1911984
;  :del-clause              108546375
;  :final-checks            5
;  :max-generation          15
;  :max-memory              590.26
;  :memory                  543.25
;  :minimized-lits          1601
;  :mk-bool-var             91978696
;  :mk-clause               108548200
;  :num-allocs              217760934
;  :num-checks              787
;  :propagations            31737582
;  :quant-instantiations    37394384
;  :restarts                22
;  :rlimit-count            851463172
;  :time                    0.01)
; [eval] (None(): option[array])
(pop) ; 15
(push) ; 15
; [else-branch: 373 | !(i1@690@04 < V@15@04 && 0 <= i1@690@04)]
(assert (not (and (< i1@690@04 V@15@04) (<= 0 i1@690@04))))
(pop) ; 15
(pop) ; 14
; Joined path conditions
(assert (implies
  (and (< i1@690@04 V@15@04) (<= 0 i1@690@04))
  (and
    (< i1@690@04 V@15@04)
    (<= 0 i1@690@04)
    (< i1@690@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@686@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@690@04)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@690@04)))))
; Joined path conditions
(pop) ; 13
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@690@04 Int)) (!
  (implies
    (and (< i1@690@04 V@15@04) (<= 0 i1@690@04))
    (and
      (< i1@690@04 V@15@04)
      (<= 0 i1@690@04)
      (< i1@690@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@686@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@690@04)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@690@04))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@690@04))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 12
(pop) ; 11
; Joined path conditions
(assert (implies
  (= exc@291@04 $Ref.null)
  (forall ((i1@690@04 Int)) (!
    (implies
      (and (< i1@690@04 V@15@04) (<= 0 i1@690@04))
      (and
        (< i1@690@04 V@15@04)
        (<= 0 i1@690@04)
        (< i1@690@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@686@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@690@04)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@690@04))))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@690@04))
    :qid |prog.l<no position>-aux|))))
(push) ; 11
(assert (not (implies
  (= exc@291@04 $Ref.null)
  (forall ((i1@690@04 Int)) (!
    (implies
      (and (< i1@690@04 V@15@04) (<= 0 i1@690@04))
      (not
        (=
          ($FVF.lookup_option$array$ (as sm@686@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@690@04))
          (as None<option<array>>  option<array>))))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@690@04))
    :qid |prog.l<no position>|)))))
(check-sat)
; unsat
(pop) ; 11
; 0.06s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               44265600
;  :arith-add-rows          8710409
;  :arith-assert-diseq      322941
;  :arith-assert-lower      7937373
;  :arith-assert-upper      6898001
;  :arith-bound-prop        177853
;  :arith-conflicts         4362
;  :arith-eq-adapter        2820665
;  :arith-fixed-eqs         7362822
;  :arith-offset-eqs        4999417
;  :arith-pivots            1202755
;  :conflicts               9993
;  :datatype-accessor-ax    5366
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1912161
;  :del-clause              108552738
;  :final-checks            5
;  :max-generation          15
;  :max-memory              590.26
;  :memory                  543.16
;  :minimized-lits          1601
;  :mk-bool-var             91983023
;  :mk-clause               108554242
;  :num-allocs              217774893
;  :num-checks              788
;  :propagations            31738334
;  :quant-instantiations    37395482
;  :restarts                22
;  :rlimit-count            851526620
;  :time                    0.06)
(assert (implies
  (= exc@291@04 $Ref.null)
  (forall ((i1@690@04 Int)) (!
    (implies
      (and (< i1@690@04 V@15@04) (<= 0 i1@690@04))
      (not
        (=
          ($FVF.lookup_option$array$ (as sm@686@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@690@04))
          (as None<option<array>>  option<array>))))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@690@04))
    :qid |prog.l<no position>|))))
; [eval] exc == null ==> (forall i1: Int :: { alen(opt_get1(aloc(opt_get1(G), i1).option$array$)) } 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(G), i1).option$array$)) == V)
; [eval] exc == null
(push) ; 11
(set-option :timeout 10)
(push) ; 12
(assert (not (not (= exc@291@04 $Ref.null))))
(check-sat)
; unknown
(pop) ; 12
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               44265687
;  :arith-add-rows          8710471
;  :arith-assert-diseq      322944
;  :arith-assert-lower      7937403
;  :arith-assert-upper      6898022
;  :arith-bound-prop        177853
;  :arith-conflicts         4362
;  :arith-eq-adapter        2820687
;  :arith-fixed-eqs         7362847
;  :arith-offset-eqs        4999423
;  :arith-pivots            1202755
;  :conflicts               9993
;  :datatype-accessor-ax    5366
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1912175
;  :del-clause              108553331
;  :final-checks            5
;  :max-generation          15
;  :max-memory              590.26
;  :memory                  543.16
;  :minimized-lits          1601
;  :mk-bool-var             91983469
;  :mk-clause               108554835
;  :num-allocs              217776911
;  :num-checks              789
;  :propagations            31738452
;  :quant-instantiations    37395641
;  :restarts                22
;  :rlimit-count            851534553
;  :time                    0.01)
; [then-branch: 374 | exc@291@04 == Null | live]
; [else-branch: 374 | exc@291@04 != Null | dead]
(push) ; 12
; [then-branch: 374 | exc@291@04 == Null]
; [eval] (forall i1: Int :: { alen(opt_get1(aloc(opt_get1(G), i1).option$array$)) } 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(G), i1).option$array$)) == V)
(declare-const i1@691@04 Int)
(push) ; 13
; [eval] 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(G), i1).option$array$)) == V
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 14
; [then-branch: 375 | 0 <= i1@691@04 | live]
; [else-branch: 375 | !(0 <= i1@691@04) | live]
(push) ; 15
; [then-branch: 375 | 0 <= i1@691@04]
(assert (<= 0 i1@691@04))
; [eval] i1 < V
(pop) ; 15
(push) ; 15
; [else-branch: 375 | !(0 <= i1@691@04)]
(assert (not (<= 0 i1@691@04)))
(pop) ; 15
(pop) ; 14
; Joined path conditions
; Joined path conditions
(push) ; 14
; [then-branch: 376 | i1@691@04 < V@15@04 && 0 <= i1@691@04 | live]
; [else-branch: 376 | !(i1@691@04 < V@15@04 && 0 <= i1@691@04) | live]
(push) ; 15
; [then-branch: 376 | i1@691@04 < V@15@04 && 0 <= i1@691@04]
(assert (and (< i1@691@04 V@15@04) (<= 0 i1@691@04)))
; [eval] alen(opt_get1(aloc(opt_get1(G), i1).option$array$)) == V
; [eval] alen(opt_get1(aloc(opt_get1(G), i1).option$array$))
; [eval] opt_get1(aloc(opt_get1(G), i1).option$array$)
; [eval] aloc(opt_get1(G), i1)
; [eval] opt_get1(G)
(push) ; 16
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 16
; Joined path conditions
(push) ; 16
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 17
(assert (not (< i1@691@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))))
(check-sat)
; unsat
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               44265687
;  :arith-add-rows          8710472
;  :arith-assert-diseq      322944
;  :arith-assert-lower      7937405
;  :arith-assert-upper      6898022
;  :arith-bound-prop        177853
;  :arith-conflicts         4362
;  :arith-eq-adapter        2820687
;  :arith-fixed-eqs         7362847
;  :arith-offset-eqs        4999423
;  :arith-pivots            1202756
;  :conflicts               9993
;  :datatype-accessor-ax    5366
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1912175
;  :del-clause              108553331
;  :final-checks            5
;  :max-generation          15
;  :max-memory              590.26
;  :memory                  543.16
;  :minimized-lits          1601
;  :mk-bool-var             91983471
;  :mk-clause               108554835
;  :num-allocs              217777015
;  :num-checks              790
;  :propagations            31738452
;  :quant-instantiations    37395641
;  :restarts                22
;  :rlimit-count            851534754)
(assert (< i1@691@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(pop) ; 16
; Joined path conditions
(assert (< i1@691@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@686@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@691@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@691@04)))
(push) ; 16
(assert (not (<
  $Perm.No
  (+
    (+
      (-
        (ite
          (and
            (<
              (inv@262@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@691@04))
              V@15@04)
            (<=
              0
              (inv@262@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@691@04))))
          $k@261@04
          $Perm.No)
        (pTaken@319@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@691@04)))
      (-
        (ite
          (and
            (<
              (inv@21@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@691@04))
              V@15@04)
            (<=
              0
              (inv@21@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@691@04))))
          $k@20@04
          $Perm.No)
        (pTaken@234@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@691@04))))
    (ite
      (and
        (<
          (inv@296@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@691@04))
          V@15@04)
        (<=
          0
          (inv@296@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@691@04))))
      $k@295@04
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 16
; 0.04s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               44266372
;  :arith-add-rows          8711367
;  :arith-assert-diseq      322963
;  :arith-assert-lower      7937533
;  :arith-assert-upper      6898108
;  :arith-bound-prop        177900
;  :arith-conflicts         4367
;  :arith-eq-adapter        2820776
;  :arith-fixed-eqs         7362939
;  :arith-offset-eqs        4999473
;  :arith-pivots            1202832
;  :conflicts               10014
;  :datatype-accessor-ax    5366
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1912355
;  :del-clause              108559190
;  :final-checks            5
;  :max-generation          15
;  :max-memory              590.26
;  :memory                  543.20
;  :minimized-lits          1601
;  :mk-bool-var             91988315
;  :mk-clause               108561015
;  :num-allocs              217792761
;  :num-checks              791
;  :propagations            31739275
;  :quant-instantiations    37396759
;  :restarts                22
;  :rlimit-count            851601315
;  :time                    0.04)
(push) ; 16
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 17
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@686@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@691@04))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               44266372
;  :arith-add-rows          8711367
;  :arith-assert-diseq      322963
;  :arith-assert-lower      7937533
;  :arith-assert-upper      6898108
;  :arith-bound-prop        177900
;  :arith-conflicts         4367
;  :arith-eq-adapter        2820776
;  :arith-fixed-eqs         7362939
;  :arith-offset-eqs        4999473
;  :arith-pivots            1202832
;  :conflicts               10015
;  :datatype-accessor-ax    5366
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1912355
;  :del-clause              108559190
;  :final-checks            5
;  :max-generation          15
;  :max-memory              590.26
;  :memory                  543.20
;  :minimized-lits          1601
;  :mk-bool-var             91988315
;  :mk-clause               108561015
;  :num-allocs              217792850
;  :num-checks              792
;  :propagations            31739275
;  :quant-instantiations    37396759
;  :restarts                22
;  :rlimit-count            851601410)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@686@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@691@04))
    (as None<option<array>>  option<array>))))
(pop) ; 16
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@686@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@691@04))
    (as None<option<array>>  option<array>))))
(pop) ; 15
(push) ; 15
; [else-branch: 376 | !(i1@691@04 < V@15@04 && 0 <= i1@691@04)]
(assert (not (and (< i1@691@04 V@15@04) (<= 0 i1@691@04))))
(pop) ; 15
(pop) ; 14
; Joined path conditions
(assert (implies
  (and (< i1@691@04 V@15@04) (<= 0 i1@691@04))
  (and
    (< i1@691@04 V@15@04)
    (<= 0 i1@691@04)
    (< i1@691@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@686@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@691@04)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@691@04))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@686@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@691@04))
        (as None<option<array>>  option<array>))))))
; Joined path conditions
(pop) ; 13
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@691@04 Int)) (!
  (implies
    (and (< i1@691@04 V@15@04) (<= 0 i1@691@04))
    (and
      (< i1@691@04 V@15@04)
      (<= 0 i1@691@04)
      (< i1@691@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@686@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@691@04)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@691@04))
      (not
        (=
          ($FVF.lookup_option$array$ (as sm@686@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@691@04))
          (as None<option<array>>  option<array>)))))
  :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@686@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@691@04)))))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 12
(pop) ; 11
; Joined path conditions
(assert (implies
  (= exc@291@04 $Ref.null)
  (forall ((i1@691@04 Int)) (!
    (implies
      (and (< i1@691@04 V@15@04) (<= 0 i1@691@04))
      (and
        (< i1@691@04 V@15@04)
        (<= 0 i1@691@04)
        (< i1@691@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@686@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@691@04)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@691@04))
        (not
          (=
            ($FVF.lookup_option$array$ (as sm@686@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@691@04))
            (as None<option<array>>  option<array>)))))
    :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@686@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@691@04)))))
    :qid |prog.l<no position>-aux|))))
(push) ; 11
(assert (not (implies
  (= exc@291@04 $Ref.null)
  (forall ((i1@691@04 Int)) (!
    (implies
      (and (< i1@691@04 V@15@04) (<= 0 i1@691@04))
      (=
        (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@686@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@691@04))))
        V@15@04))
    :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@686@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@691@04)))))
    :qid |prog.l<no position>|)))))
(check-sat)
; unsat
(pop) ; 11
; 0.06s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               44267096
;  :arith-add-rows          8712049
;  :arith-assert-diseq      322975
;  :arith-assert-lower      7937637
;  :arith-assert-upper      6898177
;  :arith-bound-prop        177930
;  :arith-conflicts         4368
;  :arith-eq-adapter        2820844
;  :arith-fixed-eqs         7363016
;  :arith-offset-eqs        4999522
;  :arith-pivots            1202918
;  :conflicts               10035
;  :datatype-accessor-ax    5366
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1912536
;  :del-clause              108565575
;  :final-checks            5
;  :max-generation          15
;  :max-memory              590.26
;  :memory                  543.16
;  :minimized-lits          1601
;  :mk-bool-var             91992687
;  :mk-clause               108567079
;  :num-allocs              217807051
;  :num-checks              793
;  :propagations            31740227
;  :quant-instantiations    37397884
;  :restarts                22
;  :rlimit-count            851665989
;  :time                    0.06)
(assert (implies
  (= exc@291@04 $Ref.null)
  (forall ((i1@691@04 Int)) (!
    (implies
      (and (< i1@691@04 V@15@04) (<= 0 i1@691@04))
      (=
        (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@686@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@691@04))))
        V@15@04))
    :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@686@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@691@04)))))
    :qid |prog.l<no position>|))))
; [eval] exc == null ==> (forall i1: Int :: { aloc(opt_get1(G), i1) } (forall i2: Int :: { aloc(opt_get1(G), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(G), i1).option$array$ == aloc(opt_get1(G), i2).option$array$ ==> i1 == i2))
; [eval] exc == null
(push) ; 11
(set-option :timeout 10)
(push) ; 12
(assert (not (not (= exc@291@04 $Ref.null))))
(check-sat)
; unknown
(pop) ; 12
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               44267226
;  :arith-add-rows          8712122
;  :arith-assert-diseq      322980
;  :arith-assert-lower      7937672
;  :arith-assert-upper      6898202
;  :arith-bound-prop        177930
;  :arith-conflicts         4368
;  :arith-eq-adapter        2820866
;  :arith-fixed-eqs         7363045
;  :arith-offset-eqs        4999528
;  :arith-pivots            1202926
;  :conflicts               10035
;  :datatype-accessor-ax    5366
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1912555
;  :del-clause              108566446
;  :final-checks            5
;  :max-generation          15
;  :max-memory              590.26
;  :memory                  543.16
;  :minimized-lits          1601
;  :mk-bool-var             91993429
;  :mk-clause               108567950
;  :num-allocs              217809663
;  :num-checks              794
;  :propagations            31740358
;  :quant-instantiations    37398131
;  :restarts                22
;  :rlimit-count            851677479
;  :time                    0.01)
; [then-branch: 377 | exc@291@04 == Null | live]
; [else-branch: 377 | exc@291@04 != Null | dead]
(push) ; 12
; [then-branch: 377 | exc@291@04 == Null]
; [eval] (forall i1: Int :: { aloc(opt_get1(G), i1) } (forall i2: Int :: { aloc(opt_get1(G), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(G), i1).option$array$ == aloc(opt_get1(G), i2).option$array$ ==> i1 == i2))
(declare-const i1@692@04 Int)
(push) ; 13
; [eval] (forall i2: Int :: { aloc(opt_get1(G), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(G), i1).option$array$ == aloc(opt_get1(G), i2).option$array$ ==> i1 == i2)
(declare-const i2@693@04 Int)
(push) ; 14
; [eval] 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(G), i1).option$array$ == aloc(opt_get1(G), i2).option$array$ ==> i1 == i2
; [eval] 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(G), i1).option$array$ == aloc(opt_get1(G), i2).option$array$
; [eval] 0 <= i1
(push) ; 15
; [then-branch: 378 | 0 <= i1@692@04 | live]
; [else-branch: 378 | !(0 <= i1@692@04) | live]
(push) ; 16
; [then-branch: 378 | 0 <= i1@692@04]
(assert (<= 0 i1@692@04))
; [eval] i1 < V
(push) ; 17
; [then-branch: 379 | i1@692@04 < V@15@04 | live]
; [else-branch: 379 | !(i1@692@04 < V@15@04) | live]
(push) ; 18
; [then-branch: 379 | i1@692@04 < V@15@04]
(assert (< i1@692@04 V@15@04))
; [eval] 0 <= i2
(push) ; 19
; [then-branch: 380 | 0 <= i2@693@04 | live]
; [else-branch: 380 | !(0 <= i2@693@04) | live]
(push) ; 20
; [then-branch: 380 | 0 <= i2@693@04]
(assert (<= 0 i2@693@04))
; [eval] i2 < V
(push) ; 21
; [then-branch: 381 | i2@693@04 < V@15@04 | live]
; [else-branch: 381 | !(i2@693@04 < V@15@04) | live]
(push) ; 22
; [then-branch: 381 | i2@693@04 < V@15@04]
(assert (< i2@693@04 V@15@04))
; [eval] aloc(opt_get1(G), i1).option$array$ == aloc(opt_get1(G), i2).option$array$
; [eval] aloc(opt_get1(G), i1)
; [eval] opt_get1(G)
(push) ; 23
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 23
; Joined path conditions
(push) ; 23
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 24
(assert (not (< i1@692@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))))
(check-sat)
; unsat
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               44267226
;  :arith-add-rows          8712124
;  :arith-assert-diseq      322980
;  :arith-assert-lower      7937676
;  :arith-assert-upper      6898202
;  :arith-bound-prop        177930
;  :arith-conflicts         4368
;  :arith-eq-adapter        2820866
;  :arith-fixed-eqs         7363045
;  :arith-offset-eqs        4999528
;  :arith-pivots            1202927
;  :conflicts               10035
;  :datatype-accessor-ax    5366
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1912555
;  :del-clause              108566446
;  :final-checks            5
;  :max-generation          15
;  :max-memory              590.26
;  :memory                  543.16
;  :minimized-lits          1601
;  :mk-bool-var             91993433
;  :mk-clause               108567950
;  :num-allocs              217809945
;  :num-checks              795
;  :propagations            31740358
;  :quant-instantiations    37398131
;  :restarts                22
;  :rlimit-count            851677826)
(assert (< i1@692@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(pop) ; 23
; Joined path conditions
(assert (< i1@692@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@686@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@692@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@692@04)))
(push) ; 23
(assert (not (<
  $Perm.No
  (+
    (+
      (-
        (ite
          (and
            (<
              (inv@262@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@692@04))
              V@15@04)
            (<=
              0
              (inv@262@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@692@04))))
          $k@261@04
          $Perm.No)
        (pTaken@319@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@692@04)))
      (-
        (ite
          (and
            (<
              (inv@21@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@692@04))
              V@15@04)
            (<=
              0
              (inv@21@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@692@04))))
          $k@20@04
          $Perm.No)
        (pTaken@234@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@692@04))))
    (ite
      (and
        (<
          (inv@296@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@692@04))
          V@15@04)
        (<=
          0
          (inv@296@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@692@04))))
      $k@295@04
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 23
; 0.05s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               44267914
;  :arith-add-rows          8712980
;  :arith-assert-diseq      322999
;  :arith-assert-lower      7937803
;  :arith-assert-upper      6898287
;  :arith-bound-prop        177978
;  :arith-conflicts         4373
;  :arith-eq-adapter        2820956
;  :arith-fixed-eqs         7363137
;  :arith-offset-eqs        4999578
;  :arith-pivots            1202994
;  :conflicts               10056
;  :datatype-accessor-ax    5366
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1912735
;  :del-clause              108572283
;  :final-checks            5
;  :max-generation          15
;  :max-memory              590.26
;  :memory                  543.20
;  :minimized-lits          1601
;  :mk-bool-var             91998251
;  :mk-clause               108574108
;  :num-allocs              217825650
;  :num-checks              796
;  :propagations            31741179
;  :quant-instantiations    37399249
;  :restarts                22
;  :rlimit-count            851742027
;  :time                    0.05)
; [eval] aloc(opt_get1(G), i2)
; [eval] opt_get1(G)
(push) ; 23
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 23
; Joined path conditions
(push) ; 23
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 24
(assert (not (< i2@693@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))))
(check-sat)
; unsat
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               44267914
;  :arith-add-rows          8712980
;  :arith-assert-diseq      322999
;  :arith-assert-lower      7937803
;  :arith-assert-upper      6898287
;  :arith-bound-prop        177978
;  :arith-conflicts         4373
;  :arith-eq-adapter        2820956
;  :arith-fixed-eqs         7363137
;  :arith-offset-eqs        4999578
;  :arith-pivots            1202994
;  :conflicts               10056
;  :datatype-accessor-ax    5366
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1912735
;  :del-clause              108572283
;  :final-checks            5
;  :max-generation          15
;  :max-memory              590.26
;  :memory                  543.20
;  :minimized-lits          1601
;  :mk-bool-var             91998251
;  :mk-clause               108574108
;  :num-allocs              217825676
;  :num-checks              797
;  :propagations            31741179
;  :quant-instantiations    37399249
;  :restarts                22
;  :rlimit-count            851742057)
(assert (< i2@693@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(pop) ; 23
; Joined path conditions
(assert (< i2@693@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@686@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@693@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@693@04)))
(push) ; 23
(assert (not (<
  $Perm.No
  (+
    (+
      (-
        (ite
          (and
            (<
              (inv@262@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@693@04))
              V@15@04)
            (<=
              0
              (inv@262@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@693@04))))
          $k@261@04
          $Perm.No)
        (pTaken@319@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@693@04)))
      (-
        (ite
          (and
            (<
              (inv@21@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@693@04))
              V@15@04)
            (<=
              0
              (inv@21@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@693@04))))
          $k@20@04
          $Perm.No)
        (pTaken@234@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@693@04))))
    (ite
      (and
        (<
          (inv@296@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@693@04))
          V@15@04)
        (<=
          0
          (inv@296@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@693@04))))
      $k@295@04
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 23
; 0.06s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               44268857
;  :arith-add-rows          8714338
;  :arith-assert-diseq      323039
;  :arith-assert-lower      7938030
;  :arith-assert-upper      6898419
;  :arith-bound-prop        178061
;  :arith-conflicts         4383
;  :arith-eq-adapter        2821107
;  :arith-fixed-eqs         7363252
;  :arith-offset-eqs        4999644
;  :arith-pivots            1203114
;  :conflicts               10083
;  :datatype-accessor-ax    5366
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1912955
;  :del-clause              108579297
;  :final-checks            5
;  :max-generation          15
;  :max-memory              590.26
;  :memory                  543.24
;  :minimized-lits          1603
;  :mk-bool-var             92004347
;  :mk-clause               108581401
;  :num-allocs              217845047
;  :num-checks              798
;  :propagations            31742284
;  :quant-instantiations    37400514
;  :restarts                22
;  :rlimit-count            851819751
;  :time                    0.06)
(pop) ; 22
(push) ; 22
; [else-branch: 381 | !(i2@693@04 < V@15@04)]
(assert (not (< i2@693@04 V@15@04)))
(pop) ; 22
(pop) ; 21
; Joined path conditions
(assert (implies
  (< i2@693@04 V@15@04)
  (and
    (< i2@693@04 V@15@04)
    (< i1@692@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@686@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@692@04)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@692@04))
    (< i2@693@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@686@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@693@04)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@693@04)))))
; Joined path conditions
(pop) ; 20
(push) ; 20
; [else-branch: 380 | !(0 <= i2@693@04)]
(assert (not (<= 0 i2@693@04)))
(pop) ; 20
(pop) ; 19
; Joined path conditions
(assert (implies
  (<= 0 i2@693@04)
  (and
    (<= 0 i2@693@04)
    (implies
      (< i2@693@04 V@15@04)
      (and
        (< i2@693@04 V@15@04)
        (< i1@692@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@686@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@692@04)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@692@04))
        (< i2@693@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@686@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@693@04)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@693@04)))))))
; Joined path conditions
(pop) ; 18
(push) ; 18
; [else-branch: 379 | !(i1@692@04 < V@15@04)]
(assert (not (< i1@692@04 V@15@04)))
(pop) ; 18
(pop) ; 17
; Joined path conditions
(assert (implies
  (< i1@692@04 V@15@04)
  (and
    (< i1@692@04 V@15@04)
    (implies
      (<= 0 i2@693@04)
      (and
        (<= 0 i2@693@04)
        (implies
          (< i2@693@04 V@15@04)
          (and
            (< i2@693@04 V@15@04)
            (< i1@692@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@686@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@692@04)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@692@04))
            (< i2@693@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@686@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@693@04)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@693@04)))))))))
; Joined path conditions
(pop) ; 16
(push) ; 16
; [else-branch: 378 | !(0 <= i1@692@04)]
(assert (not (<= 0 i1@692@04)))
(pop) ; 16
(pop) ; 15
; Joined path conditions
(assert (implies
  (<= 0 i1@692@04)
  (and
    (<= 0 i1@692@04)
    (implies
      (< i1@692@04 V@15@04)
      (and
        (< i1@692@04 V@15@04)
        (implies
          (<= 0 i2@693@04)
          (and
            (<= 0 i2@693@04)
            (implies
              (< i2@693@04 V@15@04)
              (and
                (< i2@693@04 V@15@04)
                (< i1@692@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@686@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@692@04)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@692@04))
                (< i2@693@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@686@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@693@04)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@693@04)))))))))))
; Joined path conditions
(push) ; 15
; [then-branch: 382 | Lookup(option$array$,sm@686@04,aloc((_, _), opt_get1(_, G@11@04), i1@692@04)) == Lookup(option$array$,sm@686@04,aloc((_, _), opt_get1(_, G@11@04), i2@693@04)) && i2@693@04 < V@15@04 && 0 <= i2@693@04 && i1@692@04 < V@15@04 && 0 <= i1@692@04 | live]
; [else-branch: 382 | !(Lookup(option$array$,sm@686@04,aloc((_, _), opt_get1(_, G@11@04), i1@692@04)) == Lookup(option$array$,sm@686@04,aloc((_, _), opt_get1(_, G@11@04), i2@693@04)) && i2@693@04 < V@15@04 && 0 <= i2@693@04 && i1@692@04 < V@15@04 && 0 <= i1@692@04) | live]
(push) ; 16
; [then-branch: 382 | Lookup(option$array$,sm@686@04,aloc((_, _), opt_get1(_, G@11@04), i1@692@04)) == Lookup(option$array$,sm@686@04,aloc((_, _), opt_get1(_, G@11@04), i2@693@04)) && i2@693@04 < V@15@04 && 0 <= i2@693@04 && i1@692@04 < V@15@04 && 0 <= i1@692@04]
(assert (and
  (and
    (and
      (and
        (=
          ($FVF.lookup_option$array$ (as sm@686@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@692@04))
          ($FVF.lookup_option$array$ (as sm@686@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@693@04)))
        (< i2@693@04 V@15@04))
      (<= 0 i2@693@04))
    (< i1@692@04 V@15@04))
  (<= 0 i1@692@04)))
; [eval] i1 == i2
(pop) ; 16
(push) ; 16
; [else-branch: 382 | !(Lookup(option$array$,sm@686@04,aloc((_, _), opt_get1(_, G@11@04), i1@692@04)) == Lookup(option$array$,sm@686@04,aloc((_, _), opt_get1(_, G@11@04), i2@693@04)) && i2@693@04 < V@15@04 && 0 <= i2@693@04 && i1@692@04 < V@15@04 && 0 <= i1@692@04)]
(assert (not
  (and
    (and
      (and
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@686@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@692@04))
            ($FVF.lookup_option$array$ (as sm@686@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@693@04)))
          (< i2@693@04 V@15@04))
        (<= 0 i2@693@04))
      (< i1@692@04 V@15@04))
    (<= 0 i1@692@04))))
(pop) ; 16
(pop) ; 15
; Joined path conditions
(assert (implies
  (and
    (and
      (and
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@686@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@692@04))
            ($FVF.lookup_option$array$ (as sm@686@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@693@04)))
          (< i2@693@04 V@15@04))
        (<= 0 i2@693@04))
      (< i1@692@04 V@15@04))
    (<= 0 i1@692@04))
  (and
    (=
      ($FVF.lookup_option$array$ (as sm@686@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@692@04))
      ($FVF.lookup_option$array$ (as sm@686@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@693@04)))
    (< i2@693@04 V@15@04)
    (<= 0 i2@693@04)
    (< i1@692@04 V@15@04)
    (<= 0 i1@692@04))))
; Joined path conditions
(pop) ; 14
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i2@693@04 Int)) (!
  (and
    (implies
      (<= 0 i1@692@04)
      (and
        (<= 0 i1@692@04)
        (implies
          (< i1@692@04 V@15@04)
          (and
            (< i1@692@04 V@15@04)
            (implies
              (<= 0 i2@693@04)
              (and
                (<= 0 i2@693@04)
                (implies
                  (< i2@693@04 V@15@04)
                  (and
                    (< i2@693@04 V@15@04)
                    (< i1@692@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
                    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@686@04  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@692@04)) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@692@04))
                    (< i2@693@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
                    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@686@04  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@693@04)) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@693@04))))))))))
    (implies
      (and
        (and
          (and
            (and
              (=
                ($FVF.lookup_option$array$ (as sm@686@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@692@04))
                ($FVF.lookup_option$array$ (as sm@686@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@693@04)))
              (< i2@693@04 V@15@04))
            (<= 0 i2@693@04))
          (< i1@692@04 V@15@04))
        (<= 0 i1@692@04))
      (and
        (=
          ($FVF.lookup_option$array$ (as sm@686@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@692@04))
          ($FVF.lookup_option$array$ (as sm@686@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@693@04)))
        (< i2@693@04 V@15@04)
        (<= 0 i2@693@04)
        (< i1@692@04 V@15@04)
        (<= 0 i1@692@04))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@693@04))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 13
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@692@04 Int)) (!
  (forall ((i2@693@04 Int)) (!
    (and
      (implies
        (<= 0 i1@692@04)
        (and
          (<= 0 i1@692@04)
          (implies
            (< i1@692@04 V@15@04)
            (and
              (< i1@692@04 V@15@04)
              (implies
                (<= 0 i2@693@04)
                (and
                  (<= 0 i2@693@04)
                  (implies
                    (< i2@693@04 V@15@04)
                    (and
                      (< i2@693@04 V@15@04)
                      (< i1@692@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
                      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@686@04  $FVF<option<array>>) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@692@04)) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@692@04))
                      (< i2@693@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
                      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@686@04  $FVF<option<array>>) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@693@04)) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@693@04))))))))))
      (implies
        (and
          (and
            (and
              (and
                (=
                  ($FVF.lookup_option$array$ (as sm@686@04  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@692@04))
                  ($FVF.lookup_option$array$ (as sm@686@04  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@693@04)))
                (< i2@693@04 V@15@04))
              (<= 0 i2@693@04))
            (< i1@692@04 V@15@04))
          (<= 0 i1@692@04))
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@686@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@692@04))
            ($FVF.lookup_option$array$ (as sm@686@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@693@04)))
          (< i2@693@04 V@15@04)
          (<= 0 i2@693@04)
          (< i1@692@04 V@15@04)
          (<= 0 i1@692@04))))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@693@04))
    :qid |prog.l<no position>-aux|))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@692@04))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 12
(pop) ; 11
; Joined path conditions
(assert (implies
  (= exc@291@04 $Ref.null)
  (forall ((i1@692@04 Int)) (!
    (forall ((i2@693@04 Int)) (!
      (and
        (implies
          (<= 0 i1@692@04)
          (and
            (<= 0 i1@692@04)
            (implies
              (< i1@692@04 V@15@04)
              (and
                (< i1@692@04 V@15@04)
                (implies
                  (<= 0 i2@693@04)
                  (and
                    (<= 0 i2@693@04)
                    (implies
                      (< i2@693@04 V@15@04)
                      (and
                        (< i2@693@04 V@15@04)
                        (< i1@692@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
                        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@686@04  $FVF<option<array>>) (aloc ($Snap.combine
                          $Snap.unit
                          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@692@04)) (aloc ($Snap.combine
                          $Snap.unit
                          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@692@04))
                        (< i2@693@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
                        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@686@04  $FVF<option<array>>) (aloc ($Snap.combine
                          $Snap.unit
                          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@693@04)) (aloc ($Snap.combine
                          $Snap.unit
                          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@693@04))))))))))
        (implies
          (and
            (and
              (and
                (and
                  (=
                    ($FVF.lookup_option$array$ (as sm@686@04  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@692@04))
                    ($FVF.lookup_option$array$ (as sm@686@04  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@693@04)))
                  (< i2@693@04 V@15@04))
                (<= 0 i2@693@04))
              (< i1@692@04 V@15@04))
            (<= 0 i1@692@04))
          (and
            (=
              ($FVF.lookup_option$array$ (as sm@686@04  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@692@04))
              ($FVF.lookup_option$array$ (as sm@686@04  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@693@04)))
            (< i2@693@04 V@15@04)
            (<= 0 i2@693@04)
            (< i1@692@04 V@15@04)
            (<= 0 i1@692@04))))
      :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@693@04))
      :qid |prog.l<no position>-aux|))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@692@04))
    :qid |prog.l<no position>-aux|))))
(push) ; 11
(assert (not (implies
  (= exc@291@04 $Ref.null)
  (forall ((i1@692@04 Int)) (!
    (forall ((i2@693@04 Int)) (!
      (implies
        (and
          (and
            (and
              (and
                (=
                  ($FVF.lookup_option$array$ (as sm@686@04  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@692@04))
                  ($FVF.lookup_option$array$ (as sm@686@04  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@693@04)))
                (< i2@693@04 V@15@04))
              (<= 0 i2@693@04))
            (< i1@692@04 V@15@04))
          (<= 0 i1@692@04))
        (= i1@692@04 i2@693@04))
      :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@693@04))
      :qid |prog.l<no position>|))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@692@04))
    :qid |prog.l<no position>|)))))
(check-sat)
; unsat
(pop) ; 11
; 0.07s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               44269698
;  :arith-add-rows          8715381
;  :arith-assert-diseq      323051
;  :arith-assert-lower      7938156
;  :arith-assert-upper      6898511
;  :arith-bound-prop        178128
;  :arith-conflicts         4384
;  :arith-eq-adapter        2821201
;  :arith-fixed-eqs         7363354
;  :arith-offset-eqs        4999736
;  :arith-pivots            1203275
;  :conflicts               10101
;  :datatype-accessor-ax    5366
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1913135
;  :del-clause              108586473
;  :final-checks            5
;  :max-generation          15
;  :max-memory              590.26
;  :memory                  543.17
;  :minimized-lits          1605
;  :mk-bool-var             92009566
;  :mk-clause               108587977
;  :num-allocs              217862827
;  :num-checks              799
;  :propagations            31743208
;  :quant-instantiations    37401881
;  :restarts                22
;  :rlimit-count            851901122
;  :time                    0.07)
(assert (implies
  (= exc@291@04 $Ref.null)
  (forall ((i1@692@04 Int)) (!
    (forall ((i2@693@04 Int)) (!
      (implies
        (and
          (and
            (and
              (and
                (=
                  ($FVF.lookup_option$array$ (as sm@686@04  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@692@04))
                  ($FVF.lookup_option$array$ (as sm@686@04  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@693@04)))
                (< i2@693@04 V@15@04))
              (<= 0 i2@693@04))
            (< i1@692@04 V@15@04))
          (<= 0 i1@692@04))
        (= i1@692@04 i2@693@04))
      :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@693@04))
      :qid |prog.l<no position>|))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@692@04))
    :qid |prog.l<no position>|))))
; [eval] exc == null
(set-option :timeout 10)
(push) ; 11
(assert (not (not (= exc@291@04 $Ref.null))))
(check-sat)
; unknown
(pop) ; 11
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               44269821
;  :arith-add-rows          8715443
;  :arith-assert-diseq      323056
;  :arith-assert-lower      7938191
;  :arith-assert-upper      6898536
;  :arith-bound-prop        178128
;  :arith-conflicts         4384
;  :arith-eq-adapter        2821223
;  :arith-fixed-eqs         7363383
;  :arith-offset-eqs        4999742
;  :arith-pivots            1203283
;  :conflicts               10101
;  :datatype-accessor-ax    5366
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1913150
;  :del-clause              108587220
;  :final-checks            5
;  :max-generation          15
;  :max-memory              590.26
;  :memory                  543.17
;  :minimized-lits          1605
;  :mk-bool-var             92010239
;  :mk-clause               108588724
;  :num-allocs              217865507
;  :num-checks              800
;  :propagations            31743328
;  :quant-instantiations    37402117
;  :restarts                22
;  :rlimit-count            851912512
;  :time                    0.01)
; [then-branch: 383 | exc@291@04 == Null | live]
; [else-branch: 383 | exc@291@04 != Null | dead]
(push) ; 11
; [then-branch: 383 | exc@291@04 == Null]
(declare-const i1@694@04 Int)
(declare-const j@695@04 Int)
(push) ; 12
; [eval] 0 <= i1 && i1 < V && (0 <= j && j < V)
; [eval] 0 <= i1
(push) ; 13
; [then-branch: 384 | 0 <= i1@694@04 | live]
; [else-branch: 384 | !(0 <= i1@694@04) | live]
(push) ; 14
; [then-branch: 384 | 0 <= i1@694@04]
(assert (<= 0 i1@694@04))
; [eval] i1 < V
(push) ; 15
; [then-branch: 385 | i1@694@04 < V@15@04 | live]
; [else-branch: 385 | !(i1@694@04 < V@15@04) | live]
(push) ; 16
; [then-branch: 385 | i1@694@04 < V@15@04]
(assert (< i1@694@04 V@15@04))
; [eval] 0 <= j
(push) ; 17
; [then-branch: 386 | 0 <= j@695@04 | live]
; [else-branch: 386 | !(0 <= j@695@04) | live]
(push) ; 18
; [then-branch: 386 | 0 <= j@695@04]
(assert (<= 0 j@695@04))
; [eval] j < V
(pop) ; 18
(push) ; 18
; [else-branch: 386 | !(0 <= j@695@04)]
(assert (not (<= 0 j@695@04)))
(pop) ; 18
(pop) ; 17
; Joined path conditions
; Joined path conditions
(pop) ; 16
(push) ; 16
; [else-branch: 385 | !(i1@694@04 < V@15@04)]
(assert (not (< i1@694@04 V@15@04)))
(pop) ; 16
(pop) ; 15
; Joined path conditions
; Joined path conditions
(pop) ; 14
(push) ; 14
; [else-branch: 384 | !(0 <= i1@694@04)]
(assert (not (<= 0 i1@694@04)))
(pop) ; 14
(pop) ; 13
; Joined path conditions
; Joined path conditions
(assert (and
  (and (and (< j@695@04 V@15@04) (<= 0 j@695@04)) (< i1@694@04 V@15@04))
  (<= 0 i1@694@04)))
; [eval] aloc(opt_get1(aloc(opt_get1(G), i1).option$array$), j)
; [eval] opt_get1(aloc(opt_get1(G), i1).option$array$)
; [eval] aloc(opt_get1(G), i1)
; [eval] opt_get1(G)
(push) ; 13
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 13
; Joined path conditions
(push) ; 13
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 14
(assert (not (< i1@694@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))))
(check-sat)
; unsat
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               44269821
;  :arith-add-rows          8715446
;  :arith-assert-diseq      323056
;  :arith-assert-lower      7938197
;  :arith-assert-upper      6898536
;  :arith-bound-prop        178128
;  :arith-conflicts         4384
;  :arith-eq-adapter        2821223
;  :arith-fixed-eqs         7363383
;  :arith-offset-eqs        4999742
;  :arith-pivots            1203283
;  :conflicts               10101
;  :datatype-accessor-ax    5366
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1913150
;  :del-clause              108587220
;  :final-checks            5
;  :max-generation          15
;  :max-memory              590.26
;  :memory                  543.17
;  :minimized-lits          1605
;  :mk-bool-var             92010245
;  :mk-clause               108588724
;  :num-allocs              217865781
;  :num-checks              801
;  :propagations            31743328
;  :quant-instantiations    37402117
;  :restarts                22
;  :rlimit-count            851912987)
(assert (< i1@694@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(pop) ; 13
; Joined path conditions
(assert (< i1@694@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@686@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@694@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@694@04)))
(push) ; 13
(assert (not (<
  $Perm.No
  (+
    (+
      (-
        (ite
          (and
            (<
              (inv@262@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@694@04))
              V@15@04)
            (<=
              0
              (inv@262@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@694@04))))
          $k@261@04
          $Perm.No)
        (pTaken@319@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@694@04)))
      (-
        (ite
          (and
            (<
              (inv@21@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@694@04))
              V@15@04)
            (<=
              0
              (inv@21@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@694@04))))
          $k@20@04
          $Perm.No)
        (pTaken@234@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@694@04))))
    (ite
      (and
        (<
          (inv@296@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@694@04))
          V@15@04)
        (<=
          0
          (inv@296@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@694@04))))
      $k@295@04
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 13
; 0.04s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               44270517
;  :arith-add-rows          8716441
;  :arith-assert-diseq      323075
;  :arith-assert-lower      7938327
;  :arith-assert-upper      6898621
;  :arith-bound-prop        178176
;  :arith-conflicts         4389
;  :arith-eq-adapter        2821311
;  :arith-fixed-eqs         7363475
;  :arith-offset-eqs        4999804
;  :arith-pivots            1203350
;  :conflicts               10122
;  :datatype-accessor-ax    5366
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1913330
;  :del-clause              108593127
;  :final-checks            5
;  :max-generation          15
;  :max-memory              590.26
;  :memory                  543.21
;  :minimized-lits          1605
;  :mk-bool-var             92015172
;  :mk-clause               108594952
;  :num-allocs              217881935
;  :num-checks              802
;  :propagations            31744168
;  :quant-instantiations    37403256
;  :restarts                22
;  :rlimit-count            851979922
;  :time                    0.04)
(push) ; 13
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 14
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@686@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@694@04))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               44270517
;  :arith-add-rows          8716441
;  :arith-assert-diseq      323075
;  :arith-assert-lower      7938327
;  :arith-assert-upper      6898621
;  :arith-bound-prop        178176
;  :arith-conflicts         4389
;  :arith-eq-adapter        2821311
;  :arith-fixed-eqs         7363475
;  :arith-offset-eqs        4999804
;  :arith-pivots            1203350
;  :conflicts               10123
;  :datatype-accessor-ax    5366
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1913330
;  :del-clause              108593127
;  :final-checks            5
;  :max-generation          15
;  :max-memory              590.26
;  :memory                  543.21
;  :minimized-lits          1605
;  :mk-bool-var             92015172
;  :mk-clause               108594952
;  :num-allocs              217882024
;  :num-checks              803
;  :propagations            31744168
;  :quant-instantiations    37403256
;  :restarts                22
;  :rlimit-count            851980017)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@686@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@694@04))
    (as None<option<array>>  option<array>))))
(pop) ; 13
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@686@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@694@04))
    (as None<option<array>>  option<array>))))
(push) ; 13
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 14
(assert (not (<
  j@695@04
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@686@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@694@04)))))))
(check-sat)
; unsat
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               44270523
;  :arith-add-rows          8716447
;  :arith-assert-diseq      323075
;  :arith-assert-lower      7938329
;  :arith-assert-upper      6898623
;  :arith-bound-prop        178176
;  :arith-conflicts         4390
;  :arith-eq-adapter        2821312
;  :arith-fixed-eqs         7363476
;  :arith-offset-eqs        4999804
;  :arith-pivots            1203354
;  :conflicts               10124
;  :datatype-accessor-ax    5366
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1913330
;  :del-clause              108593131
;  :final-checks            5
;  :max-generation          15
;  :max-memory              590.26
;  :memory                  543.21
;  :minimized-lits          1605
;  :mk-bool-var             92015183
;  :mk-clause               108594956
;  :num-allocs              217882211
;  :num-checks              804
;  :propagations            31744170
;  :quant-instantiations    37403263
;  :restarts                22
;  :rlimit-count            851980522
;  :time                    0.00)
(assert (<
  j@695@04
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@686@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@694@04))))))
(pop) ; 13
; Joined path conditions
(assert (<
  j@695@04
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@686@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@694@04))))))
(pop) ; 12
(declare-fun inv@696@04 ($Ref) Int)
(declare-fun inv@697@04 ($Ref) Int)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(assert (forall ((i1@694@04 Int) (j@695@04 Int)) (!
  (and
    (< i1@694@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@686@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@694@04)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@694@04))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@686@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@694@04))
        (as None<option<array>>  option<array>)))
    (<
      j@695@04
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@686@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@694@04))))))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@686@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@694@04))) j@695@04))
  :qid |int-aux|)))
(declare-const sm@698@04 $FVF<Int>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@308@04 r) V@15@04) (<= 0 (inv@308@04 r)))
    (=
      ($FVF.lookup_int (as sm@698@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04)))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@698@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04)))))))))))) r))
  :qid |qp.fvfValDef541|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@305@04 r) V@15@04) (<= 0 (inv@305@04 r)))
        (< (inv@304@04 r) V@15@04))
      (<= 0 (inv@304@04 r)))
    (=
      ($FVF.lookup_int (as sm@698@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@698@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04))))))))) r))
  :qid |qp.fvfValDef542|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04)))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@698@04  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef543|)))
; Check receiver injectivity
(push) ; 12
(assert (not (forall ((i11@694@04 Int) (j1@695@04 Int) (i12@694@04 Int) (j2@695@04 Int)) (!
  (implies
    (and
      (and
        (and
          (and
            (and (< j1@695@04 V@15@04) (<= 0 j1@695@04))
            (< i11@694@04 V@15@04))
          (<= 0 i11@694@04))
        ($FVF.loc_int ($FVF.lookup_int (as sm@698@04  $FVF<Int>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@686@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i11@694@04))) j1@695@04)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@686@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i11@694@04))) j1@695@04)))
      (and
        (and
          (and
            (and (< j2@695@04 V@15@04) (<= 0 j2@695@04))
            (< i12@694@04 V@15@04))
          (<= 0 i12@694@04))
        ($FVF.loc_int ($FVF.lookup_int (as sm@698@04  $FVF<Int>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@686@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i12@694@04))) j2@695@04)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@686@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i12@694@04))) j2@695@04)))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@686@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i11@694@04))) j1@695@04)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@686@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i12@694@04))) j2@695@04)))
    (and (= i11@694@04 i12@694@04) (= j1@695@04 j2@695@04)))
  
  :qid |int-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 12
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               44270706
;  :arith-add-rows          8716548
;  :arith-assert-diseq      323075
;  :arith-assert-lower      7938359
;  :arith-assert-upper      6898633
;  :arith-bound-prop        178186
;  :arith-conflicts         4390
;  :arith-eq-adapter        2821361
;  :arith-fixed-eqs         7363486
;  :arith-offset-eqs        4999804
;  :arith-pivots            1203398
;  :conflicts               10125
;  :datatype-accessor-ax    5366
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1913330
;  :del-clause              108594286
;  :final-checks            5
;  :max-generation          15
;  :max-memory              590.26
;  :memory                  543.15
;  :minimized-lits          1605
;  :mk-bool-var             92016467
;  :mk-clause               108595790
;  :num-allocs              217887875
;  :num-checks              805
;  :propagations            31744210
;  :quant-instantiations    37403711
;  :restarts                22
;  :rlimit-count            852003730
;  :time                    0.01)
; Definitional axioms for inverse functions
(assert (forall ((i1@694@04 Int) (j@695@04 Int)) (!
  (implies
    (and
      (and (and (< j@695@04 V@15@04) (<= 0 j@695@04)) (< i1@694@04 V@15@04))
      (<= 0 i1@694@04))
    (and
      (=
        (inv@696@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@686@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@694@04))) j@695@04))
        i1@694@04)
      (=
        (inv@697@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@686@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@694@04))) j@695@04))
        j@695@04)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@686@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@694@04))) j@695@04))
  :qid |int-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@697@04 r) V@15@04) (<= 0 (inv@697@04 r)))
        (< (inv@696@04 r) V@15@04))
      (<= 0 (inv@696@04 r)))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@686@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) (inv@696@04 r)))) (inv@697@04 r))
      r))
  :pattern ((inv@696@04 r))
  :pattern ((inv@697@04 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@697@04 r) V@15@04) (<= 0 (inv@697@04 r)))
        (< (inv@696@04 r) V@15@04))
      (<= 0 (inv@696@04 r)))
    ($FVF.loc_int ($FVF.lookup_int (as sm@698@04  $FVF<Int>) r) r))
  :pattern ((inv@696@04 r) (inv@697@04 r))
  )))
; Precomputing data for removing quantified permissions
(define-fun pTaken@699@04 ((r $Ref)) $Perm
  (ite
    (and
      (and
        (and (< (inv@697@04 r) V@15@04) (<= 0 (inv@697@04 r)))
        (< (inv@696@04 r) V@15@04))
      (<= 0 (inv@696@04 r)))
    ($Perm.min
      (ite
        (and (< (inv@308@04 r) V@15@04) (<= 0 (inv@308@04 r)))
        $Perm.Write
        $Perm.No)
      $Perm.Write)
    $Perm.No))
(define-fun pTaken@700@04 ((r $Ref)) $Perm
  (ite
    (and
      (and
        (and (< (inv@697@04 r) V@15@04) (<= 0 (inv@697@04 r)))
        (< (inv@696@04 r) V@15@04))
      (<= 0 (inv@696@04 r)))
    ($Perm.min
      (ite
        (and
          (and
            (and (< (inv@305@04 r) V@15@04) (<= 0 (inv@305@04 r)))
            (< (inv@304@04 r) V@15@04))
          (<= 0 (inv@304@04 r)))
        $Perm.Write
        $Perm.No)
      (- $Perm.Write (pTaken@699@04 r)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 500)
(push) ; 12
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and (< (inv@308@04 r) V@15@04) (<= 0 (inv@308@04 r)))
        $Perm.Write
        $Perm.No)
      (pTaken@699@04 r))
    $Perm.No)
  
  ))))
(check-sat)
; unknown
(pop) ; 12
; 0.50s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               44279993
;  :arith-add-rows          8721425
;  :arith-assert-diseq      323121
;  :arith-assert-lower      7940000
;  :arith-assert-upper      6899871
;  :arith-bound-prop        178527
;  :arith-conflicts         4394
;  :arith-eq-adapter        2822813
;  :arith-fixed-eqs         7364749
;  :arith-offset-eqs        5000802
;  :arith-pivots            1204789
;  :conflicts               10134
;  :datatype-accessor-ax    5366
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1913949
;  :del-clause              108645958
;  :final-checks            5
;  :max-generation          15
;  :max-memory              590.26
;  :memory                  542.96
;  :minimized-lits          1605
;  :mk-bool-var             92065210
;  :mk-clause               108647462
;  :num-allocs              218023577
;  :num-checks              807
;  :propagations            31753970
;  :quant-instantiations    37420949
;  :restarts                22
;  :rlimit-count            852571282
;  :time                    0.50)
; Intermediate check if already taken enough permissions
(push) ; 12
(assert (not (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@697@04 r) V@15@04) (<= 0 (inv@697@04 r)))
        (< (inv@696@04 r) V@15@04))
      (<= 0 (inv@696@04 r)))
    (= (- $Perm.Write (pTaken@699@04 r)) $Perm.No))
  
  ))))
(check-sat)
; unknown
(pop) ; 12
; 0.50s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               44288733
;  :arith-add-rows          8726484
;  :arith-assert-diseq      323203
;  :arith-assert-lower      7941590
;  :arith-assert-upper      6900969
;  :arith-bound-prop        178825
;  :arith-conflicts         4398
;  :arith-eq-adapter        2824144
;  :arith-fixed-eqs         7365815
;  :arith-offset-eqs        5001674
;  :arith-pivots            1205968
;  :conflicts               10140
;  :datatype-accessor-ax    5366
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1914804
;  :del-clause              108698404
;  :final-checks            5
;  :max-generation          15
;  :max-memory              590.26
;  :memory                  542.94
;  :minimized-lits          1605
;  :mk-bool-var             92112160
;  :mk-clause               108699908
;  :num-allocs              218151273
;  :num-checks              808
;  :propagations            31764319
;  :quant-instantiations    37436879
;  :restarts                22
;  :rlimit-count            853137277
;  :time                    0.50)
; Chunk depleted?
(push) ; 12
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and
          (and
            (and (< (inv@305@04 r) V@15@04) (<= 0 (inv@305@04 r)))
            (< (inv@304@04 r) V@15@04))
          (<= 0 (inv@304@04 r)))
        $Perm.Write
        $Perm.No)
      (pTaken@700@04 r))
    $Perm.No)
  
  ))))
(check-sat)
; unknown
(pop) ; 12
; 0.50s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               44298561
;  :arith-add-rows          8735992
;  :arith-assert-diseq      323471
;  :arith-assert-lower      7943834
;  :arith-assert-upper      6902179
;  :arith-bound-prop        179069
;  :arith-conflicts         4414
;  :arith-eq-adapter        2825405
;  :arith-fixed-eqs         7367036
;  :arith-offset-eqs        5002356
;  :arith-pivots            1206844
;  :conflicts               10161
;  :datatype-accessor-ax    5366
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1917896
;  :del-clause              108782828
;  :final-checks            5
;  :max-generation          15
;  :max-memory              590.26
;  :memory                  543.57
;  :minimized-lits          1622
;  :mk-bool-var             92171856
;  :mk-clause               108784332
;  :num-allocs              218278532
;  :num-checks              809
;  :propagations            31777195
;  :quant-instantiations    37450140
;  :restarts                22
;  :rlimit-count            853668292
;  :time                    0.50)
; Intermediate check if already taken enough permissions
(push) ; 12
(assert (not (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@697@04 r) V@15@04) (<= 0 (inv@697@04 r)))
        (< (inv@696@04 r) V@15@04))
      (<= 0 (inv@696@04 r)))
    (= (- (- $Perm.Write (pTaken@699@04 r)) (pTaken@700@04 r)) $Perm.No))
  
  ))))
(check-sat)
; unsat
(pop) ; 12
; 0.05s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               44299559
;  :arith-add-rows          8736901
;  :arith-assert-diseq      323495
;  :arith-assert-lower      7943988
;  :arith-assert-upper      6902301
;  :arith-bound-prop        179109
;  :arith-conflicts         4421
;  :arith-eq-adapter        2825520
;  :arith-fixed-eqs         7367148
;  :arith-offset-eqs        5002401
;  :arith-pivots            1206959
;  :conflicts               10171
;  :datatype-accessor-ax    5366
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1918082
;  :del-clause              108789339
;  :final-checks            5
;  :max-generation          15
;  :max-memory              590.26
;  :memory                  543.36
;  :minimized-lits          1622
;  :mk-bool-var             92176884
;  :mk-clause               108790843
;  :num-allocs              218293491
;  :num-checks              810
;  :propagations            31778245
;  :quant-instantiations    37451419
;  :restarts                22
;  :rlimit-count            853742156
;  :time                    0.05)
; Final check if taken enough permissions
; Done removing quantified permissions
; Definitional axioms for snapshot map values
; [eval] exc == null ==> P != (None(): option[array])
; [eval] exc == null
(push) ; 12
(set-option :timeout 10)
(push) ; 13
(assert (not (not (= exc@291@04 $Ref.null))))
(check-sat)
; unknown
(pop) ; 13
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               44299737
;  :arith-add-rows          8737025
;  :arith-assert-diseq      323501
;  :arith-assert-lower      7944033
;  :arith-assert-upper      6902333
;  :arith-bound-prop        179109
;  :arith-conflicts         4421
;  :arith-eq-adapter        2825557
;  :arith-fixed-eqs         7367184
;  :arith-offset-eqs        5002412
;  :arith-pivots            1206967
;  :conflicts               10171
;  :datatype-accessor-ax    5366
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1918108
;  :del-clause              108790664
;  :final-checks            5
;  :max-generation          15
;  :max-memory              590.26
;  :memory                  543.27
;  :minimized-lits          1622
;  :mk-bool-var             92177987
;  :mk-clause               108792168
;  :num-allocs              218297143
;  :num-checks              811
;  :propagations            31778398
;  :quant-instantiations    37451796
;  :restarts                22
;  :rlimit-count            853758433
;  :time                    0.01)
; [then-branch: 387 | exc@291@04 == Null | live]
; [else-branch: 387 | exc@291@04 != Null | dead]
(push) ; 13
; [then-branch: 387 | exc@291@04 == Null]
; [eval] P != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 13
(pop) ; 12
; Joined path conditions
(set-option :timeout 0)
(push) ; 12
(assert (not (implies
  (= exc@291@04 $Ref.null)
  (not (= P@14@04 (as None<option<array>>  option<array>))))))
(check-sat)
; unsat
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               44299737
;  :arith-add-rows          8737025
;  :arith-assert-diseq      323501
;  :arith-assert-lower      7944033
;  :arith-assert-upper      6902333
;  :arith-bound-prop        179109
;  :arith-conflicts         4421
;  :arith-eq-adapter        2825557
;  :arith-fixed-eqs         7367184
;  :arith-offset-eqs        5002412
;  :arith-pivots            1206967
;  :conflicts               10171
;  :datatype-accessor-ax    5366
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1918108
;  :del-clause              108790664
;  :final-checks            5
;  :max-generation          15
;  :max-memory              590.26
;  :memory                  543.27
;  :minimized-lits          1622
;  :mk-bool-var             92177987
;  :mk-clause               108792168
;  :num-allocs              218297167
;  :num-checks              812
;  :propagations            31778398
;  :quant-instantiations    37451796
;  :restarts                22
;  :rlimit-count            853758453)
(assert (implies
  (= exc@291@04 $Ref.null)
  (not (= P@14@04 (as None<option<array>>  option<array>)))))
; [eval] exc == null ==> alen(opt_get1(P)) == V
; [eval] exc == null
(push) ; 12
(set-option :timeout 10)
(push) ; 13
(assert (not (not (= exc@291@04 $Ref.null))))
(check-sat)
; unknown
(pop) ; 13
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               44299915
;  :arith-add-rows          8737133
;  :arith-assert-diseq      323507
;  :arith-assert-lower      7944078
;  :arith-assert-upper      6902365
;  :arith-bound-prop        179109
;  :arith-conflicts         4421
;  :arith-eq-adapter        2825591
;  :arith-fixed-eqs         7367220
;  :arith-offset-eqs        5002423
;  :arith-pivots            1206975
;  :conflicts               10171
;  :datatype-accessor-ax    5366
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1918134
;  :del-clause              108791798
;  :final-checks            5
;  :max-generation          15
;  :max-memory              590.26
;  :memory                  542.59
;  :minimized-lits          1622
;  :mk-bool-var             92178946
;  :mk-clause               108793302
;  :num-allocs              218300352
;  :num-checks              813
;  :propagations            31778551
;  :quant-instantiations    37452125
;  :restarts                22
;  :rlimit-count            853772894
;  :time                    0.01)
; [then-branch: 388 | exc@291@04 == Null | live]
; [else-branch: 388 | exc@291@04 != Null | dead]
(push) ; 13
; [then-branch: 388 | exc@291@04 == Null]
; [eval] alen(opt_get1(P)) == V
; [eval] alen(opt_get1(P))
; [eval] opt_get1(P)
(push) ; 14
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 14
; Joined path conditions
(pop) ; 13
(pop) ; 12
; Joined path conditions
(set-option :timeout 0)
(push) ; 12
(assert (not (implies
  (= exc@291@04 $Ref.null)
  (= (alen<Int> (opt_get1 $Snap.unit P@14@04)) V@15@04))))
(check-sat)
; unsat
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               44299915
;  :arith-add-rows          8737133
;  :arith-assert-diseq      323507
;  :arith-assert-lower      7944078
;  :arith-assert-upper      6902365
;  :arith-bound-prop        179109
;  :arith-conflicts         4421
;  :arith-eq-adapter        2825591
;  :arith-fixed-eqs         7367220
;  :arith-offset-eqs        5002423
;  :arith-pivots            1206975
;  :conflicts               10171
;  :datatype-accessor-ax    5366
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1918134
;  :del-clause              108791798
;  :final-checks            5
;  :max-generation          15
;  :max-memory              590.26
;  :memory                  542.59
;  :minimized-lits          1622
;  :mk-bool-var             92178946
;  :mk-clause               108793302
;  :num-allocs              218300370
;  :num-checks              814
;  :propagations            31778551
;  :quant-instantiations    37452125
;  :restarts                22
;  :rlimit-count            853772919)
(assert (implies
  (= exc@291@04 $Ref.null)
  (= (alen<Int> (opt_get1 $Snap.unit P@14@04)) V@15@04)))
; [eval] exc == null
(set-option :timeout 10)
(push) ; 12
(assert (not (not (= exc@291@04 $Ref.null))))
(check-sat)
; unknown
(pop) ; 12
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               44300093
;  :arith-add-rows          8737257
;  :arith-assert-diseq      323513
;  :arith-assert-lower      7944123
;  :arith-assert-upper      6902397
;  :arith-bound-prop        179109
;  :arith-conflicts         4421
;  :arith-eq-adapter        2825628
;  :arith-fixed-eqs         7367256
;  :arith-offset-eqs        5002434
;  :arith-pivots            1206983
;  :conflicts               10171
;  :datatype-accessor-ax    5366
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1918160
;  :del-clause              108793125
;  :final-checks            5
;  :max-generation          15
;  :max-memory              590.26
;  :memory                  542.57
;  :minimized-lits          1622
;  :mk-bool-var             92180051
;  :mk-clause               108794629
;  :num-allocs              218304551
;  :num-checks              815
;  :propagations            31778704
;  :quant-instantiations    37452504
;  :restarts                22
;  :rlimit-count            853792820
;  :time                    0.01)
; [then-branch: 389 | exc@291@04 == Null | live]
; [else-branch: 389 | exc@291@04 != Null | dead]
(push) ; 12
; [then-branch: 389 | exc@291@04 == Null]
(declare-const i1@701@04 Int)
(push) ; 13
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 14
; [then-branch: 390 | 0 <= i1@701@04 | live]
; [else-branch: 390 | !(0 <= i1@701@04) | live]
(push) ; 15
; [then-branch: 390 | 0 <= i1@701@04]
(assert (<= 0 i1@701@04))
; [eval] i1 < V
(pop) ; 15
(push) ; 15
; [else-branch: 390 | !(0 <= i1@701@04)]
(assert (not (<= 0 i1@701@04)))
(pop) ; 15
(pop) ; 14
; Joined path conditions
; Joined path conditions
(assert (and (< i1@701@04 V@15@04) (<= 0 i1@701@04)))
; [eval] aloc(opt_get1(P), i1)
; [eval] opt_get1(P)
(push) ; 14
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 14
; Joined path conditions
(push) ; 14
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 15
(assert (not (< i1@701@04 (alen<Int> (opt_get1 $Snap.unit P@14@04)))))
(check-sat)
; unsat
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               44300093
;  :arith-add-rows          8737258
;  :arith-assert-diseq      323513
;  :arith-assert-lower      7944125
;  :arith-assert-upper      6902397
;  :arith-bound-prop        179109
;  :arith-conflicts         4421
;  :arith-eq-adapter        2825628
;  :arith-fixed-eqs         7367256
;  :arith-offset-eqs        5002434
;  :arith-pivots            1206983
;  :conflicts               10171
;  :datatype-accessor-ax    5366
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1918160
;  :del-clause              108793125
;  :final-checks            5
;  :max-generation          15
;  :max-memory              590.26
;  :memory                  542.57
;  :minimized-lits          1622
;  :mk-bool-var             92180053
;  :mk-clause               108794629
;  :num-allocs              218304648
;  :num-checks              816
;  :propagations            31778704
;  :quant-instantiations    37452504
;  :restarts                22
;  :rlimit-count            853793006)
(assert (< i1@701@04 (alen<Int> (opt_get1 $Snap.unit P@14@04))))
(pop) ; 14
; Joined path conditions
(assert (< i1@701@04 (alen<Int> (opt_get1 $Snap.unit P@14@04))))
(pop) ; 13
(declare-fun inv@702@04 ($Ref) Int)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(assert (forall ((i1@701@04 Int)) (!
  (< i1@701@04 (alen<Int> (opt_get1 $Snap.unit P@14@04)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i1@701@04))
  :qid |int-aux|)))
(declare-const sm@703@04 $FVF<Int>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (ite
          (and
            (and
              (and (< (inv@305@04 r) V@15@04) (<= 0 (inv@305@04 r)))
              (< (inv@304@04 r) V@15@04))
            (<= 0 (inv@304@04 r)))
          $Perm.Write
          $Perm.No)
        (pTaken@700@04 r)))
    (=
      ($FVF.lookup_int (as sm@703@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@703@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04))))))))) r))
  :qid |qp.fvfValDef544|)))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (ite
          (and (< (inv@308@04 r) V@15@04) (<= 0 (inv@308@04 r)))
          $Perm.Write
          $Perm.No)
        (pTaken@699@04 r)))
    (=
      ($FVF.lookup_int (as sm@703@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04)))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@703@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04)))))))))))) r))
  :qid |qp.fvfValDef545|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04)))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@703@04  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef546|)))
; Check receiver injectivity
(push) ; 13
(assert (not (forall ((i11@701@04 Int) (i12@701@04 Int)) (!
  (implies
    (and
      (and
        (and (< i11@701@04 V@15@04) (<= 0 i11@701@04))
        ($FVF.loc_int ($FVF.lookup_int (as sm@703@04  $FVF<Int>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit P@14@04) i11@701@04)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit P@14@04) i11@701@04)))
      (and
        (and (< i12@701@04 V@15@04) (<= 0 i12@701@04))
        ($FVF.loc_int ($FVF.lookup_int (as sm@703@04  $FVF<Int>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit P@14@04) i12@701@04)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit P@14@04) i12@701@04)))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i11@701@04)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i12@701@04)))
    (= i11@701@04 i12@701@04))
  
  :qid |int-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               44300134
;  :arith-add-rows          8737269
;  :arith-assert-diseq      323514
;  :arith-assert-lower      7944129
;  :arith-assert-upper      6902397
;  :arith-bound-prop        179109
;  :arith-conflicts         4421
;  :arith-eq-adapter        2825629
;  :arith-fixed-eqs         7367256
;  :arith-offset-eqs        5002434
;  :arith-pivots            1206985
;  :conflicts               10172
;  :datatype-accessor-ax    5366
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1918160
;  :del-clause              108793161
;  :final-checks            5
;  :max-generation          15
;  :max-memory              590.26
;  :memory                  542.58
;  :minimized-lits          1622
;  :mk-bool-var             92180142
;  :mk-clause               108794665
;  :num-allocs              218306089
;  :num-checks              817
;  :propagations            31778706
;  :quant-instantiations    37452568
;  :restarts                22
;  :rlimit-count            853797967
;  :time                    0.00)
; Definitional axioms for inverse functions
(assert (forall ((i1@701@04 Int)) (!
  (implies
    (and (< i1@701@04 V@15@04) (<= 0 i1@701@04))
    (=
      (inv@702@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i1@701@04))
      i1@701@04))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i1@701@04))
  :qid |int-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@702@04 r) V@15@04) (<= 0 (inv@702@04 r)))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) (inv@702@04 r))
      r))
  :pattern ((inv@702@04 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@702@04 r) V@15@04) (<= 0 (inv@702@04 r)))
    ($FVF.loc_int ($FVF.lookup_int (as sm@703@04  $FVF<Int>) r) r))
  :pattern ((inv@702@04 r))
  )))
; Precomputing data for removing quantified permissions
(define-fun pTaken@704@04 ((r $Ref)) $Perm
  (ite
    (and (< (inv@702@04 r) V@15@04) (<= 0 (inv@702@04 r)))
    ($Perm.min
      (-
        (ite
          (and
            (and
              (and (< (inv@305@04 r) V@15@04) (<= 0 (inv@305@04 r)))
              (< (inv@304@04 r) V@15@04))
            (<= 0 (inv@304@04 r)))
          $Perm.Write
          $Perm.No)
        (pTaken@700@04 r))
      $Perm.Write)
    $Perm.No))
(define-fun pTaken@705@04 ((r $Ref)) $Perm
  (ite
    (and (< (inv@702@04 r) V@15@04) (<= 0 (inv@702@04 r)))
    ($Perm.min
      (-
        (ite
          (and (< (inv@308@04 r) V@15@04) (<= 0 (inv@308@04 r)))
          $Perm.Write
          $Perm.No)
        (pTaken@699@04 r))
      (- $Perm.Write (pTaken@704@04 r)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 500)
(push) ; 13
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (-
        (ite
          (and
            (and
              (and (< (inv@305@04 r) V@15@04) (<= 0 (inv@305@04 r)))
              (< (inv@304@04 r) V@15@04))
            (<= 0 (inv@304@04 r)))
          $Perm.Write
          $Perm.No)
        (pTaken@700@04 r))
      (pTaken@704@04 r))
    $Perm.No)
  
  ))))
(check-sat)
; unsat
(pop) ; 13
; 0.44s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               44311054
;  :arith-add-rows          8747237
;  :arith-assert-diseq      323594
;  :arith-assert-lower      7946161
;  :arith-assert-upper      6903925
;  :arith-bound-prop        179572
;  :arith-conflicts         4435
;  :arith-eq-adapter        2827482
;  :arith-fixed-eqs         7368783
;  :arith-offset-eqs        5003590
;  :arith-pivots            1208798
;  :conflicts               10213
;  :datatype-accessor-ax    5366
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1918813
;  :del-clause              108851475
;  :final-checks            5
;  :max-generation          15
;  :max-memory              590.26
;  :memory                  543.63
;  :minimized-lits          1629
;  :mk-bool-var             92245090
;  :mk-clause               108852979
;  :num-allocs              218499393
;  :num-checks              819
;  :propagations            31790280
;  :quant-instantiations    37472169
;  :restarts                22
;  :rlimit-count            854441095
;  :time                    0.44)
; Intermediate check if already taken enough permissions
(push) ; 13
(assert (not (forall ((r $Ref)) (!
  (implies
    (and (< (inv@702@04 r) V@15@04) (<= 0 (inv@702@04 r)))
    (= (- $Perm.Write (pTaken@704@04 r)) $Perm.No))
  
  ))))
(check-sat)
; unknown
(pop) ; 13
; 0.50s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               44320569
;  :arith-add-rows          8754589
;  :arith-assert-diseq      323693
;  :arith-assert-lower      7947866
;  :arith-assert-upper      6905193
;  :arith-bound-prop        179937
;  :arith-conflicts         4441
;  :arith-eq-adapter        2828989
;  :arith-fixed-eqs         7369971
;  :arith-offset-eqs        5004472
;  :arith-pivots            1210125
;  :conflicts               10225
;  :datatype-accessor-ax    5366
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1920010
;  :del-clause              108912251
;  :final-checks            5
;  :max-generation          15
;  :max-memory              590.26
;  :memory                  543.65
;  :minimized-lits          1629
;  :mk-bool-var             92298777
;  :mk-clause               108913755
;  :num-allocs              218645969
;  :num-checks              820
;  :propagations            31802642
;  :quant-instantiations    37489875
;  :restarts                22
;  :rlimit-count            855125569
;  :time                    0.50)
; Chunk depleted?
(push) ; 13
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (-
        (ite
          (and (< (inv@308@04 r) V@15@04) (<= 0 (inv@308@04 r)))
          $Perm.Write
          $Perm.No)
        (pTaken@699@04 r))
      (pTaken@705@04 r))
    $Perm.No)
  
  ))))
(check-sat)
; unsat
(pop) ; 13
; 0.29s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               44325503
;  :arith-add-rows          8759088
;  :arith-assert-diseq      323792
;  :arith-assert-lower      7948780
;  :arith-assert-upper      6905834
;  :arith-bound-prop        180079
;  :arith-conflicts         4450
;  :arith-eq-adapter        2829612
;  :arith-fixed-eqs         7370702
;  :arith-offset-eqs        5004698
;  :arith-pivots            1210586
;  :conflicts               10249
;  :datatype-accessor-ax    5366
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1921174
;  :del-clause              108950887
;  :final-checks            5
;  :max-generation          15
;  :max-memory              590.26
;  :memory                  543.61
;  :minimized-lits          1632
;  :mk-bool-var             92327924
;  :mk-clause               108952391
;  :num-allocs              218720600
;  :num-checks              821
;  :propagations            31808258
;  :quant-instantiations    37497434
;  :restarts                22
;  :rlimit-count            855411951
;  :time                    0.29)
; Intermediate check if already taken enough permissions
(push) ; 13
(assert (not (forall ((r $Ref)) (!
  (implies
    (and (< (inv@702@04 r) V@15@04) (<= 0 (inv@702@04 r)))
    (= (- (- $Perm.Write (pTaken@704@04 r)) (pTaken@705@04 r)) $Perm.No))
  
  ))))
(check-sat)
; unsat
(pop) ; 13
; 0.35s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               44334451
;  :arith-add-rows          8767983
;  :arith-assert-diseq      323878
;  :arith-assert-lower      7950398
;  :arith-assert-upper      6907012
;  :arith-bound-prop        180460
;  :arith-conflicts         4465
;  :arith-eq-adapter        2831099
;  :arith-fixed-eqs         7371859
;  :arith-offset-eqs        5005623
;  :arith-pivots            1212066
;  :conflicts               10287
;  :datatype-accessor-ax    5366
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1922181
;  :del-clause              109005781
;  :final-checks            5
;  :max-generation          15
;  :max-memory              590.26
;  :memory                  544.30
;  :minimized-lits          1643
;  :mk-bool-var             92383675
;  :mk-clause               109007285
;  :num-allocs              218882702
;  :num-checks              822
;  :propagations            31818342
;  :quant-instantiations    37513149
;  :restarts                22
;  :rlimit-count            855973853
;  :time                    0.35)
; Final check if taken enough permissions
; Done removing quantified permissions
; Definitional axioms for snapshot map values
; [eval] exc == null ==> valid_graph_vertices(this, P, V)
; [eval] exc == null
(push) ; 13
(set-option :timeout 10)
(push) ; 14
(assert (not (not (= exc@291@04 $Ref.null))))
(check-sat)
; unknown
(pop) ; 14
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               44334588
;  :arith-add-rows          8768085
;  :arith-assert-diseq      323883
;  :arith-assert-lower      7950435
;  :arith-assert-upper      6907037
;  :arith-bound-prop        180460
;  :arith-conflicts         4465
;  :arith-eq-adapter        2831126
;  :arith-fixed-eqs         7371888
;  :arith-offset-eqs        5005629
;  :arith-pivots            1212074
;  :conflicts               10287
;  :datatype-accessor-ax    5366
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1922207
;  :del-clause              109006876
;  :final-checks            5
;  :max-generation          15
;  :max-memory              590.26
;  :memory                  544.30
;  :minimized-lits          1643
;  :mk-bool-var             92384582
;  :mk-clause               109008380
;  :num-allocs              218885590
;  :num-checks              823
;  :propagations            31818495
;  :quant-instantiations    37513439
;  :restarts                22
;  :rlimit-count            855986982
;  :time                    0.01)
; [then-branch: 391 | exc@291@04 == Null | live]
; [else-branch: 391 | exc@291@04 != Null | dead]
(push) ; 14
; [then-branch: 391 | exc@291@04 == Null]
; [eval] valid_graph_vertices(this, P, V)
(push) ; 15
; [eval] this != null
; [eval] p != (None(): option[array])
; [eval] (None(): option[array])
; [eval] alen(opt_get1(p)) == V
; [eval] alen(opt_get1(p))
; [eval] opt_get1(p)
(push) ; 16
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 16
; Joined path conditions
(declare-const i1@706@04 Int)
(push) ; 16
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 17
; [then-branch: 392 | 0 <= i1@706@04 | live]
; [else-branch: 392 | !(0 <= i1@706@04) | live]
(push) ; 18
; [then-branch: 392 | 0 <= i1@706@04]
(assert (<= 0 i1@706@04))
; [eval] i1 < V
(pop) ; 18
(push) ; 18
; [else-branch: 392 | !(0 <= i1@706@04)]
(assert (not (<= 0 i1@706@04)))
(pop) ; 18
(pop) ; 17
; Joined path conditions
; Joined path conditions
(assert (and (< i1@706@04 V@15@04) (<= 0 i1@706@04)))
(declare-const $k@707@04 $Perm)
(assert ($Perm.isReadVar $k@707@04 $Perm.Write))
; [eval] aloc(opt_get1(p), i1)
; [eval] opt_get1(p)
(push) ; 17
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 17
; Joined path conditions
(push) ; 17
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 18
(assert (not (< i1@706@04 (alen<Int> (opt_get1 $Snap.unit P@14@04)))))
(check-sat)
; unsat
(pop) ; 18
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               44334588
;  :arith-add-rows          8768086
;  :arith-assert-diseq      323884
;  :arith-assert-lower      7950439
;  :arith-assert-upper      6907038
;  :arith-bound-prop        180460
;  :arith-conflicts         4465
;  :arith-eq-adapter        2831127
;  :arith-fixed-eqs         7371888
;  :arith-offset-eqs        5005629
;  :arith-pivots            1212075
;  :conflicts               10287
;  :datatype-accessor-ax    5366
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1922207
;  :del-clause              109006876
;  :final-checks            5
;  :max-generation          15
;  :max-memory              590.26
;  :memory                  544.31
;  :minimized-lits          1643
;  :mk-bool-var             92384588
;  :mk-clause               109008382
;  :num-allocs              218885760
;  :num-checks              824
;  :propagations            31818496
;  :quant-instantiations    37513439
;  :restarts                22
;  :rlimit-count            855987324)
(assert (< i1@706@04 (alen<Int> (opt_get1 $Snap.unit P@14@04))))
(pop) ; 17
; Joined path conditions
(assert (< i1@706@04 (alen<Int> (opt_get1 $Snap.unit P@14@04))))
(pop) ; 16
(declare-fun inv@708@04 ($Ref) Int)
; Nested auxiliary terms: globals
(assert ($Perm.isReadVar $k@707@04 $Perm.Write))
; Nested auxiliary terms: non-globals
(assert (forall ((i1@706@04 Int)) (!
  (< i1@706@04 (alen<Int> (opt_get1 $Snap.unit P@14@04)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i1@706@04))
  :qid |int-aux|)))
(push) ; 16
(assert (not (forall ((i1@706@04 Int)) (!
  (implies
    (and (< i1@706@04 V@15@04) (<= 0 i1@706@04))
    (or (= $k@707@04 $Perm.No) (< $Perm.No $k@707@04)))
  
  ))))
(check-sat)
; unsat
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               44334588
;  :arith-add-rows          8768087
;  :arith-assert-diseq      323885
;  :arith-assert-lower      7950441
;  :arith-assert-upper      6907039
;  :arith-bound-prop        180460
;  :arith-conflicts         4465
;  :arith-eq-adapter        2831128
;  :arith-fixed-eqs         7371888
;  :arith-offset-eqs        5005629
;  :arith-pivots            1212076
;  :conflicts               10288
;  :datatype-accessor-ax    5366
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1922207
;  :del-clause              109006878
;  :final-checks            5
;  :max-generation          15
;  :max-memory              590.26
;  :memory                  544.30
;  :minimized-lits          1643
;  :mk-bool-var             92384595
;  :mk-clause               109008384
;  :num-allocs              218886190
;  :num-checks              825
;  :propagations            31818497
;  :quant-instantiations    37513439
;  :restarts                22
;  :rlimit-count            855987874)
(declare-const sm@709@04 $FVF<Int>)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@305@04 r) V@15@04) (<= 0 (inv@305@04 r)))
        (< (inv@304@04 r) V@15@04))
      (<= 0 (inv@304@04 r)))
    (=
      ($FVF.lookup_int (as sm@709@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@709@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04))))))))) r))
  :qid |qp.fvfValDef547|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@308@04 r) V@15@04) (<= 0 (inv@308@04 r)))
    (=
      ($FVF.lookup_int (as sm@709@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04)))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@709@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04)))))))))))) r))
  :qid |qp.fvfValDef548|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04)))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@709@04  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef549|)))
; Check receiver injectivity
(push) ; 16
(assert (not (forall ((i11@706@04 Int) (i12@706@04 Int)) (!
  (implies
    (and
      (and
        (and
          (and (< i11@706@04 V@15@04) (<= 0 i11@706@04))
          ($FVF.loc_int ($FVF.lookup_int (as sm@709@04  $FVF<Int>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit P@14@04) i11@706@04)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit P@14@04) i11@706@04)))
        (< $Perm.No $k@707@04))
      (and
        (and
          (and (< i12@706@04 V@15@04) (<= 0 i12@706@04))
          ($FVF.loc_int ($FVF.lookup_int (as sm@709@04  $FVF<Int>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit P@14@04) i12@706@04)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit P@14@04) i12@706@04)))
        (< $Perm.No $k@707@04))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i11@706@04)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i12@706@04)))
    (= i11@706@04 i12@706@04))
  
  :qid |int-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               44334632
;  :arith-add-rows          8768098
;  :arith-assert-diseq      323886
;  :arith-assert-lower      7950445
;  :arith-assert-upper      6907039
;  :arith-bound-prop        180460
;  :arith-conflicts         4465
;  :arith-eq-adapter        2831129
;  :arith-fixed-eqs         7371888
;  :arith-offset-eqs        5005629
;  :arith-pivots            1212080
;  :conflicts               10289
;  :datatype-accessor-ax    5366
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1922207
;  :del-clause              109006889
;  :final-checks            5
;  :max-generation          15
;  :max-memory              590.26
;  :memory                  544.12
;  :minimized-lits          1643
;  :mk-bool-var             92384663
;  :mk-clause               109008395
;  :num-allocs              218887295
;  :num-checks              826
;  :propagations            31818499
;  :quant-instantiations    37513507
;  :restarts                22
;  :rlimit-count            855991395
;  :time                    0.00)
; Definitional axioms for inverse functions
(assert (forall ((i1@706@04 Int)) (!
  (implies
    (and (and (< i1@706@04 V@15@04) (<= 0 i1@706@04)) (< $Perm.No $k@707@04))
    (=
      (inv@708@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i1@706@04))
      i1@706@04))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i1@706@04))
  :qid |int-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and (< (inv@708@04 r) V@15@04) (<= 0 (inv@708@04 r)))
      (< $Perm.No $k@707@04))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) (inv@708@04 r))
      r))
  :pattern ((inv@708@04 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@708@04 r) V@15@04) (<= 0 (inv@708@04 r)))
    ($FVF.loc_int ($FVF.lookup_int (as sm@709@04  $FVF<Int>) r) r))
  :pattern ((inv@708@04 r))
  )))
; Precomputing data for removing quantified permissions
(define-fun pTaken@710@04 ((r $Ref)) $Perm
  (ite
    (and (< (inv@708@04 r) V@15@04) (<= 0 (inv@708@04 r)))
    ($Perm.min
      (ite
        (and
          (and
            (and (< (inv@305@04 r) V@15@04) (<= 0 (inv@305@04 r)))
            (< (inv@304@04 r) V@15@04))
          (<= 0 (inv@304@04 r)))
        $Perm.Write
        $Perm.No)
      $k@707@04)
    $Perm.No))
(define-fun pTaken@711@04 ((r $Ref)) $Perm
  (ite
    (and (< (inv@708@04 r) V@15@04) (<= 0 (inv@708@04 r)))
    ($Perm.min
      (ite
        (and (< (inv@308@04 r) V@15@04) (<= 0 (inv@308@04 r)))
        $Perm.Write
        $Perm.No)
      (- $k@707@04 (pTaken@710@04 r)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Constrain original permissions $k@707@04
(assert (forall ((r $Ref)) (!
  (implies
    (not
      (=
        (ite
          (and
            (and
              (and (< (inv@305@04 r) V@15@04) (<= 0 (inv@305@04 r)))
              (< (inv@304@04 r) V@15@04))
            (<= 0 (inv@304@04 r)))
          $Perm.Write
          $Perm.No)
        $Perm.No))
    (ite
      (and
        (and
          (and (< (inv@305@04 r) V@15@04) (<= 0 (inv@305@04 r)))
          (< (inv@304@04 r) V@15@04))
        (<= 0 (inv@304@04 r)))
      (<
        (ite
          (and (< (inv@708@04 r) V@15@04) (<= 0 (inv@708@04 r)))
          $k@707@04
          $Perm.No)
        $Perm.Write)
      (<
        (ite
          (and (< (inv@708@04 r) V@15@04) (<= 0 (inv@708@04 r)))
          $k@707@04
          $Perm.No)
        $Perm.No)))
  :pattern ((inv@305@04 r))
  :pattern ((inv@304@04 r))
  :pattern ((inv@708@04 r))
  :qid |qp.srp550|)))
; Intermediate check if already taken enough permissions
(set-option :timeout 500)
(push) ; 16
(assert (not (forall ((r $Ref)) (!
  (implies
    (and (< (inv@708@04 r) V@15@04) (<= 0 (inv@708@04 r)))
    (= (- $k@707@04 (pTaken@710@04 r)) $Perm.No))
  
  ))))
(check-sat)
; unknown
(pop) ; 16
; 0.50s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               44350774
;  :arith-add-rows          8781690
;  :arith-assert-diseq      324071
;  :arith-assert-lower      7953297
;  :arith-assert-upper      6909205
;  :arith-bound-prop        180954
;  :arith-conflicts         4474
;  :arith-eq-adapter        2833454
;  :arith-fixed-eqs         7374014
;  :arith-offset-eqs        5007280
;  :arith-pivots            1213815
;  :conflicts               10306
;  :datatype-accessor-ax    5370
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1924441
;  :del-clause              109117166
;  :final-checks            5
;  :max-generation          15
;  :max-memory              590.26
;  :memory                  544.32
;  :minimized-lits          1645
;  :mk-bool-var             92477381
;  :mk-clause               109118670
;  :num-allocs              219114197
;  :num-checks              828
;  :propagations            31841481
;  :quant-instantiations    37544297
;  :restarts                22
;  :rlimit-count            856997580
;  :time                    0.50)
; Constrain original permissions $k@707@04
(assert (forall ((r $Ref)) (!
  (implies
    (not
      (=
        (ite
          (and (< (inv@308@04 r) V@15@04) (<= 0 (inv@308@04 r)))
          $Perm.Write
          $Perm.No)
        $Perm.No))
    (ite
      (and (< (inv@308@04 r) V@15@04) (<= 0 (inv@308@04 r)))
      (<
        (ite
          (and (< (inv@708@04 r) V@15@04) (<= 0 (inv@708@04 r)))
          $k@707@04
          $Perm.No)
        $Perm.Write)
      (<
        (ite
          (and (< (inv@708@04 r) V@15@04) (<= 0 (inv@708@04 r)))
          $k@707@04
          $Perm.No)
        $Perm.No)))
  :pattern ((inv@308@04 r))
  :pattern ((inv@708@04 r))
  :qid |qp.srp551|)))
; Intermediate check if already taken enough permissions
(push) ; 16
(assert (not (forall ((r $Ref)) (!
  (implies
    (and (< (inv@708@04 r) V@15@04) (<= 0 (inv@708@04 r)))
    (= (- (- $k@707@04 (pTaken@710@04 r)) (pTaken@711@04 r)) $Perm.No))
  
  ))))
(check-sat)
; unsat
(pop) ; 16
; 0.03s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               44351601
;  :arith-add-rows          8782683
;  :arith-assert-diseq      324098
;  :arith-assert-lower      7953431
;  :arith-assert-upper      6909303
;  :arith-bound-prop        180997
;  :arith-conflicts         4480
;  :arith-eq-adapter        2833579
;  :arith-fixed-eqs         7374099
;  :arith-offset-eqs        5007344
;  :arith-pivots            1213901
;  :conflicts               10332
;  :datatype-accessor-ax    5370
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1924628
;  :del-clause              109124099
;  :final-checks            5
;  :max-generation          15
;  :max-memory              590.26
;  :memory                  544.26
;  :minimized-lits          1647
;  :mk-bool-var             92483090
;  :mk-clause               109125603
;  :num-allocs              219129435
;  :num-checks              829
;  :propagations            31842377
;  :quant-instantiations    37545551
;  :restarts                22
;  :rlimit-count            857064211
;  :time                    0.03)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@712@04 $FVF<Int>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (iff
    (Set_in r ($FVF.domain_int (as sm@712@04  $FVF<Int>)))
    (and
      (and (< (inv@708@04 r) V@15@04) (<= 0 (inv@708@04 r)))
      (< $Perm.No $k@707@04)))
  :pattern ((Set_in r ($FVF.domain_int (as sm@712@04  $FVF<Int>))))
  :qid |qp.fvfDomDef555|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@708@04 r) V@15@04) (<= 0 (inv@708@04 r)))
        (< $Perm.No $k@707@04))
      (and
        (and
          (and (< (inv@305@04 r) V@15@04) (<= 0 (inv@305@04 r)))
          (< (inv@304@04 r) V@15@04))
        (<= 0 (inv@304@04 r))))
    (=
      ($FVF.lookup_int (as sm@712@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@712@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04))))))))) r))
  :qid |qp.fvfValDef552|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@708@04 r) V@15@04) (<= 0 (inv@708@04 r)))
        (< $Perm.No $k@707@04))
      (and (< (inv@308@04 r) V@15@04) (<= 0 (inv@308@04 r))))
    (=
      ($FVF.lookup_int (as sm@712@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04)))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@712@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04)))))))))))) r))
  :qid |qp.fvfValDef553|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04)))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@712@04  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef554|)))
(pop) ; 15
; Joined path conditions
(assert ($Perm.isReadVar $k@707@04 $Perm.Write))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@305@04 r) V@15@04) (<= 0 (inv@305@04 r)))
        (< (inv@304@04 r) V@15@04))
      (<= 0 (inv@304@04 r)))
    (=
      ($FVF.lookup_int (as sm@709@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@709@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04))))))))) r))
  :qid |qp.fvfValDef547|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@308@04 r) V@15@04) (<= 0 (inv@308@04 r)))
    (=
      ($FVF.lookup_int (as sm@709@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04)))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@709@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04)))))))))))) r))
  :qid |qp.fvfValDef548|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04)))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@709@04  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef549|)))
(assert (forall ((i1@706@04 Int)) (!
  (implies
    (and (and (< i1@706@04 V@15@04) (<= 0 i1@706@04)) (< $Perm.No $k@707@04))
    (=
      (inv@708@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i1@706@04))
      i1@706@04))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i1@706@04))
  :qid |int-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and (< (inv@708@04 r) V@15@04) (<= 0 (inv@708@04 r)))
      (< $Perm.No $k@707@04))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) (inv@708@04 r))
      r))
  :pattern ((inv@708@04 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (iff
    (Set_in r ($FVF.domain_int (as sm@712@04  $FVF<Int>)))
    (and
      (and (< (inv@708@04 r) V@15@04) (<= 0 (inv@708@04 r)))
      (< $Perm.No $k@707@04)))
  :pattern ((Set_in r ($FVF.domain_int (as sm@712@04  $FVF<Int>))))
  :qid |qp.fvfDomDef555|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@708@04 r) V@15@04) (<= 0 (inv@708@04 r)))
        (< $Perm.No $k@707@04))
      (and
        (and
          (and (< (inv@305@04 r) V@15@04) (<= 0 (inv@305@04 r)))
          (< (inv@304@04 r) V@15@04))
        (<= 0 (inv@304@04 r))))
    (=
      ($FVF.lookup_int (as sm@712@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@712@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04))))))))) r))
  :qid |qp.fvfValDef552|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@708@04 r) V@15@04) (<= 0 (inv@708@04 r)))
        (< $Perm.No $k@707@04))
      (and (< (inv@308@04 r) V@15@04) (<= 0 (inv@308@04 r))))
    (=
      ($FVF.lookup_int (as sm@712@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04)))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@712@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04)))))))))))) r))
  :qid |qp.fvfValDef553|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04)))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@712@04  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef554|)))
(assert (and
  (forall ((i1@706@04 Int)) (!
    (< i1@706@04 (alen<Int> (opt_get1 $Snap.unit P@14@04)))
    :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i1@706@04))
    :qid |int-aux|))
  (forall ((r $Ref)) (!
    (implies
      (and (< (inv@708@04 r) V@15@04) (<= 0 (inv@708@04 r)))
      ($FVF.loc_int ($FVF.lookup_int (as sm@709@04  $FVF<Int>) r) r))
    :pattern ((inv@708@04 r))
    ))
  (forall ((r $Ref)) (!
    (implies
      (not
        (=
          (ite
            (and
              (and
                (and (< (inv@305@04 r) V@15@04) (<= 0 (inv@305@04 r)))
                (< (inv@304@04 r) V@15@04))
              (<= 0 (inv@304@04 r)))
            $Perm.Write
            $Perm.No)
          $Perm.No))
      (ite
        (and
          (and
            (and (< (inv@305@04 r) V@15@04) (<= 0 (inv@305@04 r)))
            (< (inv@304@04 r) V@15@04))
          (<= 0 (inv@304@04 r)))
        (<
          (ite
            (and (< (inv@708@04 r) V@15@04) (<= 0 (inv@708@04 r)))
            $k@707@04
            $Perm.No)
          $Perm.Write)
        (<
          (ite
            (and (< (inv@708@04 r) V@15@04) (<= 0 (inv@708@04 r)))
            $k@707@04
            $Perm.No)
          $Perm.No)))
    :pattern ((inv@305@04 r))
    :pattern ((inv@304@04 r))
    :pattern ((inv@708@04 r))
    :qid |qp.srp550|))
  (forall ((r $Ref)) (!
    (implies
      (not
        (=
          (ite
            (and (< (inv@308@04 r) V@15@04) (<= 0 (inv@308@04 r)))
            $Perm.Write
            $Perm.No)
          $Perm.No))
      (ite
        (and (< (inv@308@04 r) V@15@04) (<= 0 (inv@308@04 r)))
        (<
          (ite
            (and (< (inv@708@04 r) V@15@04) (<= 0 (inv@708@04 r)))
            $k@707@04
            $Perm.No)
          $Perm.Write)
        (<
          (ite
            (and (< (inv@708@04 r) V@15@04) (<= 0 (inv@708@04 r)))
            $k@707@04
            $Perm.No)
          $Perm.No)))
    :pattern ((inv@308@04 r))
    :pattern ((inv@708@04 r))
    :qid |qp.srp551|))))
(pop) ; 14
(pop) ; 13
; Joined path conditions
(assert ($Perm.isReadVar $k@707@04 $Perm.Write))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@305@04 r) V@15@04) (<= 0 (inv@305@04 r)))
        (< (inv@304@04 r) V@15@04))
      (<= 0 (inv@304@04 r)))
    (=
      ($FVF.lookup_int (as sm@709@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@709@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04))))))))) r))
  :qid |qp.fvfValDef547|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@308@04 r) V@15@04) (<= 0 (inv@308@04 r)))
    (=
      ($FVF.lookup_int (as sm@709@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04)))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@709@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04)))))))))))) r))
  :qid |qp.fvfValDef548|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04)))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@709@04  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef549|)))
(assert (forall ((i1@706@04 Int)) (!
  (implies
    (and (and (< i1@706@04 V@15@04) (<= 0 i1@706@04)) (< $Perm.No $k@707@04))
    (=
      (inv@708@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i1@706@04))
      i1@706@04))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i1@706@04))
  :qid |int-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and (< (inv@708@04 r) V@15@04) (<= 0 (inv@708@04 r)))
      (< $Perm.No $k@707@04))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) (inv@708@04 r))
      r))
  :pattern ((inv@708@04 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (iff
    (Set_in r ($FVF.domain_int (as sm@712@04  $FVF<Int>)))
    (and
      (and (< (inv@708@04 r) V@15@04) (<= 0 (inv@708@04 r)))
      (< $Perm.No $k@707@04)))
  :pattern ((Set_in r ($FVF.domain_int (as sm@712@04  $FVF<Int>))))
  :qid |qp.fvfDomDef555|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@708@04 r) V@15@04) (<= 0 (inv@708@04 r)))
        (< $Perm.No $k@707@04))
      (and
        (and
          (and (< (inv@305@04 r) V@15@04) (<= 0 (inv@305@04 r)))
          (< (inv@304@04 r) V@15@04))
        (<= 0 (inv@304@04 r))))
    (=
      ($FVF.lookup_int (as sm@712@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@712@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04))))))))) r))
  :qid |qp.fvfValDef552|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@708@04 r) V@15@04) (<= 0 (inv@708@04 r)))
        (< $Perm.No $k@707@04))
      (and (< (inv@308@04 r) V@15@04) (<= 0 (inv@308@04 r))))
    (=
      ($FVF.lookup_int (as sm@712@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04)))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@712@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04)))))))))))) r))
  :qid |qp.fvfValDef553|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04)))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@712@04  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef554|)))
(assert (implies
  (= exc@291@04 $Ref.null)
  (and
    (forall ((i1@706@04 Int)) (!
      (< i1@706@04 (alen<Int> (opt_get1 $Snap.unit P@14@04)))
      :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@14@04) i1@706@04))
      :qid |int-aux|))
    (forall ((r $Ref)) (!
      (implies
        (and (< (inv@708@04 r) V@15@04) (<= 0 (inv@708@04 r)))
        ($FVF.loc_int ($FVF.lookup_int (as sm@709@04  $FVF<Int>) r) r))
      :pattern ((inv@708@04 r))
      ))
    (forall ((r $Ref)) (!
      (implies
        (not
          (=
            (ite
              (and
                (and
                  (and (< (inv@305@04 r) V@15@04) (<= 0 (inv@305@04 r)))
                  (< (inv@304@04 r) V@15@04))
                (<= 0 (inv@304@04 r)))
              $Perm.Write
              $Perm.No)
            $Perm.No))
        (ite
          (and
            (and
              (and (< (inv@305@04 r) V@15@04) (<= 0 (inv@305@04 r)))
              (< (inv@304@04 r) V@15@04))
            (<= 0 (inv@304@04 r)))
          (<
            (ite
              (and (< (inv@708@04 r) V@15@04) (<= 0 (inv@708@04 r)))
              $k@707@04
              $Perm.No)
            $Perm.Write)
          (<
            (ite
              (and (< (inv@708@04 r) V@15@04) (<= 0 (inv@708@04 r)))
              $k@707@04
              $Perm.No)
            $Perm.No)))
      :pattern ((inv@305@04 r))
      :pattern ((inv@304@04 r))
      :pattern ((inv@708@04 r))
      :qid |qp.srp550|))
    (forall ((r $Ref)) (!
      (implies
        (not
          (=
            (ite
              (and (< (inv@308@04 r) V@15@04) (<= 0 (inv@308@04 r)))
              $Perm.Write
              $Perm.No)
            $Perm.No))
        (ite
          (and (< (inv@308@04 r) V@15@04) (<= 0 (inv@308@04 r)))
          (<
            (ite
              (and (< (inv@708@04 r) V@15@04) (<= 0 (inv@708@04 r)))
              $k@707@04
              $Perm.No)
            $Perm.Write)
          (<
            (ite
              (and (< (inv@708@04 r) V@15@04) (<= 0 (inv@708@04 r)))
              $k@707@04
              $Perm.No)
            $Perm.No)))
      :pattern ((inv@308@04 r))
      :pattern ((inv@708@04 r))
      :qid |qp.srp551|)))))
(set-option :timeout 0)
(push) ; 13
(assert (not (implies
  (= exc@291@04 $Ref.null)
  (valid_graph_vertices ($Snap.combine
    $Snap.unit
    ($Snap.combine
      $Snap.unit
      ($Snap.combine
        $Snap.unit
        ($SortWrappers.$FVF<Int>To$Snap (as sm@712@04  $FVF<Int>))))) this@9@04 P@14@04 V@15@04))))
(check-sat)
; unsat
(pop) ; 13
; 16.37s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               45476624
;  :arith-add-rows          9074144
;  :arith-assert-diseq      330136
;  :arith-assert-lower      8137862
;  :arith-assert-upper      7074742
;  :arith-bound-prop        189175
;  :arith-conflicts         4689
;  :arith-eq-adapter        2921967
;  :arith-fixed-eqs         7555338
;  :arith-offset-eqs        5153676
;  :arith-pivots            1260697
;  :conflicts               10645
;  :datatype-accessor-ax    5421
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1964277
;  :del-clause              111572950
;  :final-checks            5
;  :max-generation          15
;  :max-memory              590.26
;  :memory                  551.62
;  :minimized-lits          1709
;  :mk-bool-var             94869751
;  :mk-clause               111574456
;  :num-allocs              224997426
;  :num-checks              830
;  :propagations            32466450
;  :quant-instantiations    38455373
;  :restarts                24
;  :rlimit-count            878264122
;  :time                    16.37)
(assert (implies
  (= exc@291@04 $Ref.null)
  (valid_graph_vertices ($Snap.combine
    $Snap.unit
    ($Snap.combine
      $Snap.unit
      ($Snap.combine
        $Snap.unit
        ($SortWrappers.$FVF<Int>To$Snap (as sm@712@04  $FVF<Int>))))) this@9@04 P@14@04 V@15@04)))
; [eval] exc == null ==> FlowNetwork1(this, G, V, s, t)
; [eval] exc == null
(push) ; 13
(set-option :timeout 10)
(push) ; 14
(assert (not (not (= exc@291@04 $Ref.null))))
(check-sat)
; unknown
(pop) ; 14
; 0.11s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               45476645
;  :arith-add-rows          9074147
;  :arith-assert-diseq      330136
;  :arith-assert-lower      8137862
;  :arith-assert-upper      7074742
;  :arith-bound-prop        189175
;  :arith-conflicts         4689
;  :arith-eq-adapter        2921967
;  :arith-fixed-eqs         7555338
;  :arith-offset-eqs        5153676
;  :arith-pivots            1260697
;  :conflicts               10645
;  :datatype-accessor-ax    5424
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1964277
;  :del-clause              111572950
;  :final-checks            5
;  :max-generation          15
;  :max-memory              590.26
;  :memory                  551.62
;  :minimized-lits          1709
;  :mk-bool-var             94869905
;  :mk-clause               111574585
;  :num-allocs              224997895
;  :num-checks              831
;  :propagations            32466461
;  :quant-instantiations    38455402
;  :restarts                24
;  :rlimit-count            878265206
;  :time                    0.10)
; [then-branch: 393 | exc@291@04 == Null | live]
; [else-branch: 393 | exc@291@04 != Null | dead]
(push) ; 14
; [then-branch: 393 | exc@291@04 == Null]
; [eval] FlowNetwork1(this, G, V, s, t)
(push) ; 15
; [eval] this != null
; [eval] G != (None(): option[array])
; [eval] (None(): option[array])
; [eval] alen(opt_get1(G)) == V
; [eval] alen(opt_get1(G))
; [eval] opt_get1(G)
(push) ; 16
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 16
; Joined path conditions
(declare-const i1@713@04 Int)
(push) ; 16
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 17
; [then-branch: 394 | 0 <= i1@713@04 | live]
; [else-branch: 394 | !(0 <= i1@713@04) | live]
(push) ; 18
; [then-branch: 394 | 0 <= i1@713@04]
(assert (<= 0 i1@713@04))
; [eval] i1 < V
(pop) ; 18
(push) ; 18
; [else-branch: 394 | !(0 <= i1@713@04)]
(assert (not (<= 0 i1@713@04)))
(pop) ; 18
(pop) ; 17
; Joined path conditions
; Joined path conditions
(assert (and (< i1@713@04 V@15@04) (<= 0 i1@713@04)))
(declare-const $k@714@04 $Perm)
(assert ($Perm.isReadVar $k@714@04 $Perm.Write))
; [eval] aloc(opt_get1(G), i1)
; [eval] opt_get1(G)
(push) ; 17
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 17
; Joined path conditions
(push) ; 17
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 18
(assert (not (< i1@713@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))))
(check-sat)
; unsat
(pop) ; 18
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               45476645
;  :arith-add-rows          9074148
;  :arith-assert-diseq      330137
;  :arith-assert-lower      8137866
;  :arith-assert-upper      7074743
;  :arith-bound-prop        189175
;  :arith-conflicts         4689
;  :arith-eq-adapter        2921968
;  :arith-fixed-eqs         7555338
;  :arith-offset-eqs        5153676
;  :arith-pivots            1260697
;  :conflicts               10645
;  :datatype-accessor-ax    5424
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1964277
;  :del-clause              111572950
;  :final-checks            5
;  :max-generation          15
;  :max-memory              590.26
;  :memory                  551.62
;  :minimized-lits          1709
;  :mk-bool-var             94869911
;  :mk-clause               111574587
;  :num-allocs              224998066
;  :num-checks              832
;  :propagations            32466462
;  :quant-instantiations    38455402
;  :restarts                24
;  :rlimit-count            878265541)
(assert (< i1@713@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(pop) ; 17
; Joined path conditions
(assert (< i1@713@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(pop) ; 16
(declare-fun inv@715@04 ($Ref) Int)
; Nested auxiliary terms: globals
(assert ($Perm.isReadVar $k@714@04 $Perm.Write))
; Nested auxiliary terms: non-globals
(assert (forall ((i1@713@04 Int)) (!
  (< i1@713@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@713@04))
  :qid |option$array$-aux|)))
(push) ; 16
(assert (not (forall ((i1@713@04 Int)) (!
  (implies
    (and (< i1@713@04 V@15@04) (<= 0 i1@713@04))
    (or (= $k@714@04 $Perm.No) (< $Perm.No $k@714@04)))
  
  ))))
(check-sat)
; unsat
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               45476645
;  :arith-add-rows          9074149
;  :arith-assert-diseq      330138
;  :arith-assert-lower      8137868
;  :arith-assert-upper      7074744
;  :arith-bound-prop        189175
;  :arith-conflicts         4689
;  :arith-eq-adapter        2921969
;  :arith-fixed-eqs         7555338
;  :arith-offset-eqs        5153676
;  :arith-pivots            1260697
;  :conflicts               10646
;  :datatype-accessor-ax    5424
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1964277
;  :del-clause              111572952
;  :final-checks            5
;  :max-generation          15
;  :max-memory              590.26
;  :memory                  551.62
;  :minimized-lits          1709
;  :mk-bool-var             94869918
;  :mk-clause               111574589
;  :num-allocs              224998497
;  :num-checks              833
;  :propagations            32466463
;  :quant-instantiations    38455402
;  :restarts                24
;  :rlimit-count            878266087)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 16
(assert (not (forall ((i11@713@04 Int) (i12@713@04 Int)) (!
  (implies
    (and
      (and
        (and
          (and (< i11@713@04 V@15@04) (<= 0 i11@713@04))
          ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@686@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i11@713@04)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i11@713@04)))
        (< $Perm.No $k@714@04))
      (and
        (and
          (and (< i12@713@04 V@15@04) (<= 0 i12@713@04))
          ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@686@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i12@713@04)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i12@713@04)))
        (< $Perm.No $k@714@04))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i11@713@04)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i12@713@04)))
    (= i11@713@04 i12@713@04))
  
  :qid |option$array$-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               45476692
;  :arith-add-rows          9074158
;  :arith-assert-diseq      330139
;  :arith-assert-lower      8137872
;  :arith-assert-upper      7074744
;  :arith-bound-prop        189175
;  :arith-conflicts         4689
;  :arith-eq-adapter        2921970
;  :arith-fixed-eqs         7555338
;  :arith-offset-eqs        5153676
;  :arith-pivots            1260697
;  :conflicts               10647
;  :datatype-accessor-ax    5424
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1964277
;  :del-clause              111572989
;  :final-checks            5
;  :max-generation          15
;  :max-memory              590.26
;  :memory                  551.62
;  :minimized-lits          1709
;  :mk-bool-var             94870024
;  :mk-clause               111574626
;  :num-allocs              224999501
;  :num-checks              834
;  :propagations            32466466
;  :quant-instantiations    38455485
;  :restarts                24
;  :rlimit-count            878269173
;  :time                    0.00)
; Definitional axioms for inverse functions
(assert (forall ((i1@713@04 Int)) (!
  (implies
    (and (and (< i1@713@04 V@15@04) (<= 0 i1@713@04)) (< $Perm.No $k@714@04))
    (=
      (inv@715@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@713@04))
      i1@713@04))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@713@04))
  :qid |option$array$-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and (< (inv@715@04 r) V@15@04) (<= 0 (inv@715@04 r)))
      (< $Perm.No $k@714@04))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) (inv@715@04 r))
      r))
  :pattern ((inv@715@04 r))
  :qid |option$array$-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@715@04 r) V@15@04) (<= 0 (inv@715@04 r)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@686@04  $FVF<option<array>>) r) r))
  :pattern ((inv@715@04 r))
  )))
; Precomputing data for removing quantified permissions
(define-fun pTaken@716@04 ((r $Ref)) $Perm
  (ite
    (and (< (inv@715@04 r) V@15@04) (<= 0 (inv@715@04 r)))
    ($Perm.min
      (-
        (ite
          (and (< (inv@262@04 r) V@15@04) (<= 0 (inv@262@04 r)))
          $k@261@04
          $Perm.No)
        (pTaken@319@04 r))
      $k@714@04)
    $Perm.No))
(define-fun pTaken@717@04 ((r $Ref)) $Perm
  (ite
    (and (< (inv@715@04 r) V@15@04) (<= 0 (inv@715@04 r)))
    ($Perm.min
      (-
        (ite
          (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
          $k@20@04
          $Perm.No)
        (pTaken@234@04 r))
      (- $k@714@04 (pTaken@716@04 r)))
    $Perm.No))
(define-fun pTaken@718@04 ((r $Ref)) $Perm
  (ite
    (and (< (inv@715@04 r) V@15@04) (<= 0 (inv@715@04 r)))
    ($Perm.min
      (ite
        (and (< (inv@296@04 r) V@15@04) (<= 0 (inv@296@04 r)))
        $k@295@04
        $Perm.No)
      (- (- $k@714@04 (pTaken@716@04 r)) (pTaken@717@04 r)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Constrain original permissions $k@714@04
(assert (forall ((r $Ref)) (!
  (implies
    (not
      (=
        (-
          (ite
            (and (< (inv@262@04 r) V@15@04) (<= 0 (inv@262@04 r)))
            $k@261@04
            $Perm.No)
          (pTaken@319@04 r))
        $Perm.No))
    (<
      (ite
        (and (< (inv@715@04 r) V@15@04) (<= 0 (inv@715@04 r)))
        $k@714@04
        $Perm.No)
      (-
        (ite
          (and (< (inv@262@04 r) V@15@04) (<= 0 (inv@262@04 r)))
          $k@261@04
          $Perm.No)
        (pTaken@319@04 r))))
  :pattern ((inv@262@04 r))
  :pattern ((inv@715@04 r))
  :qid |qp.srp556|)))
; Intermediate check if already taken enough permissions
(set-option :timeout 500)
(push) ; 16
(assert (not (forall ((r $Ref)) (!
  (implies
    (and (< (inv@715@04 r) V@15@04) (<= 0 (inv@715@04 r)))
    (= (- $k@714@04 (pTaken@716@04 r)) $Perm.No))
  
  ))))
(check-sat)
; unsat
(pop) ; 16
; 0.03s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               45477606
;  :arith-add-rows          9075279
;  :arith-assert-diseq      330170
;  :arith-assert-lower      8138054
;  :arith-assert-upper      7074872
;  :arith-bound-prop        189195
;  :arith-conflicts         4694
;  :arith-eq-adapter        2922109
;  :arith-fixed-eqs         7555479
;  :arith-offset-eqs        5153716
;  :arith-pivots            1260785
;  :conflicts               10669
;  :datatype-accessor-ax    5424
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1964577
;  :del-clause              111583234
;  :final-checks            5
;  :max-generation          15
;  :max-memory              590.26
;  :memory                  544.49
;  :minimized-lits          1710
;  :mk-bool-var             94877561
;  :mk-clause               111584871
;  :num-allocs              225024077
;  :num-checks              836
;  :propagations            32467776
;  :quant-instantiations    38457362
;  :restarts                24
;  :rlimit-count            878381060
;  :time                    0.03)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@719@04 $FVF<option<array>>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (iff
    (Set_in r ($FVF.domain_option$array$ (as sm@719@04  $FVF<option<array>>)))
    (and
      (and (< (inv@715@04 r) V@15@04) (<= 0 (inv@715@04 r)))
      (< $Perm.No $k@714@04)))
  :pattern ((Set_in r ($FVF.domain_option$array$ (as sm@719@04  $FVF<option<array>>))))
  :qid |qp.fvfDomDef561|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@715@04 r) V@15@04) (<= 0 (inv@715@04 r)))
        (< $Perm.No $k@714@04))
      (<
        $Perm.No
        (-
          (ite
            (and (< (inv@262@04 r) V@15@04) (<= 0 (inv@262@04 r)))
            $k@261@04
            $Perm.No)
          (pTaken@319@04 r))))
    (=
      ($FVF.lookup_option$array$ (as sm@719@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@259@04))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@719@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@259@04))))) r))
  :qid |qp.fvfValDef557|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@715@04 r) V@15@04) (<= 0 (inv@715@04 r)))
        (< $Perm.No $k@714@04))
      (<
        $Perm.No
        (-
          (ite
            (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
            $k@20@04
            $Perm.No)
          (pTaken@234@04 r))))
    (=
      ($FVF.lookup_option$array$ (as sm@719@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@719@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r))
  :qid |qp.fvfValDef558|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@715@04 r) V@15@04) (<= 0 (inv@715@04 r)))
        (< $Perm.No $k@714@04))
      (ite
        (and (< (inv@296@04 r) V@15@04) (<= 0 (inv@296@04 r)))
        (< $Perm.No $k@295@04)
        false))
    (=
      ($FVF.lookup_option$array$ (as sm@719@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@719@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r))
  :qid |qp.fvfValDef559|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@259@04))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r) r))
  :pattern (($FVF.lookup_option$array$ (as sm@719@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef560|)))
; [eval] (forall i1: Int :: 0 <= i1 && i1 < V ==> aloc(opt_get1(G), i1).option$array$ != (None(): option[array]))
(declare-const i1@720@04 Int)
(push) ; 16
; [eval] 0 <= i1 && i1 < V ==> aloc(opt_get1(G), i1).option$array$ != (None(): option[array])
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 17
; [then-branch: 395 | 0 <= i1@720@04 | live]
; [else-branch: 395 | !(0 <= i1@720@04) | live]
(push) ; 18
; [then-branch: 395 | 0 <= i1@720@04]
(assert (<= 0 i1@720@04))
; [eval] i1 < V
(pop) ; 18
(push) ; 18
; [else-branch: 395 | !(0 <= i1@720@04)]
(assert (not (<= 0 i1@720@04)))
(pop) ; 18
(pop) ; 17
; Joined path conditions
; Joined path conditions
(push) ; 17
; [then-branch: 396 | i1@720@04 < V@15@04 && 0 <= i1@720@04 | live]
; [else-branch: 396 | !(i1@720@04 < V@15@04 && 0 <= i1@720@04) | live]
(push) ; 18
; [then-branch: 396 | i1@720@04 < V@15@04 && 0 <= i1@720@04]
(assert (and (< i1@720@04 V@15@04) (<= 0 i1@720@04)))
; [eval] aloc(opt_get1(G), i1).option$array$ != (None(): option[array])
; [eval] aloc(opt_get1(G), i1)
; [eval] opt_get1(G)
(push) ; 19
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 19
; Joined path conditions
(push) ; 19
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 20
(assert (not (< i1@720@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))))
(check-sat)
; unsat
(pop) ; 20
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               45477606
;  :arith-add-rows          9075280
;  :arith-assert-diseq      330170
;  :arith-assert-lower      8138056
;  :arith-assert-upper      7074872
;  :arith-bound-prop        189195
;  :arith-conflicts         4694
;  :arith-eq-adapter        2922109
;  :arith-fixed-eqs         7555479
;  :arith-offset-eqs        5153716
;  :arith-pivots            1260785
;  :conflicts               10669
;  :datatype-accessor-ax    5424
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1964577
;  :del-clause              111583234
;  :final-checks            5
;  :max-generation          15
;  :max-memory              590.26
;  :memory                  544.49
;  :minimized-lits          1710
;  :mk-bool-var             94877568
;  :mk-clause               111584871
;  :num-allocs              225025195
;  :num-checks              837
;  :propagations            32467776
;  :quant-instantiations    38457362
;  :restarts                24
;  :rlimit-count            878384383)
(assert (< i1@720@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(pop) ; 19
; Joined path conditions
(assert (< i1@720@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(declare-const sm@721@04 $FVF<option<array>>)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (ite
          (and (< (inv@262@04 r) V@15@04) (<= 0 (inv@262@04 r)))
          $k@261@04
          $Perm.No)
        (pTaken@319@04 r)))
    (=
      ($FVF.lookup_option$array$ (as sm@721@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@259@04))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@721@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@259@04))))) r))
  :qid |qp.fvfValDef562|)))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (ite
          (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
          $k@20@04
          $Perm.No)
        (pTaken@234@04 r)))
    (=
      ($FVF.lookup_option$array$ (as sm@721@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@721@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r))
  :qid |qp.fvfValDef563|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@296@04 r) V@15@04) (<= 0 (inv@296@04 r)))
      (< $Perm.No $k@295@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@721@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@721@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r))
  :qid |qp.fvfValDef564|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@259@04))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r) r))
  :pattern (($FVF.lookup_option$array$ (as sm@721@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef565|)))
(declare-const pm@722@04 $FPM)
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@722@04  $FPM) r)
    (+
      (+
        (-
          (ite
            (and (< (inv@262@04 r) V@15@04) (<= 0 (inv@262@04 r)))
            $k@261@04
            $Perm.No)
          (pTaken@319@04 r))
        (-
          (ite
            (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
            $k@20@04
            $Perm.No)
          (pTaken@234@04 r)))
      (ite
        (and (< (inv@296@04 r) V@15@04) (<= 0 (inv@296@04 r)))
        $k@295@04
        $Perm.No)))
  :pattern (($FVF.perm_option$array$ (as pm@722@04  $FPM) r))
  :qid |qp.resPrmSumDef566|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@721@04  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@259@04))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@722@04  $FPM) r))
  :qid |qp.resTrgDef567|)))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@721@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@720@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@720@04)))
(push) ; 19
(assert (not (<
  $Perm.No
  ($FVF.perm_option$array$ (as pm@722@04  $FPM) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@720@04)))))
(check-sat)
; unsat
(pop) ; 19
; 0.03s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               45478774
;  :arith-add-rows          9076354
;  :arith-assert-diseq      330200
;  :arith-assert-lower      8138281
;  :arith-assert-upper      7074999
;  :arith-bound-prop        189255
;  :arith-conflicts         4704
;  :arith-eq-adapter        2922274
;  :arith-fixed-eqs         7555599
;  :arith-offset-eqs        5153838
;  :arith-pivots            1260906
;  :conflicts               10682
;  :datatype-accessor-ax    5424
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1964799
;  :del-clause              111589983
;  :final-checks            5
;  :max-generation          15
;  :max-memory              590.26
;  :memory                  544.15
;  :minimized-lits          1710
;  :mk-bool-var             94882976
;  :mk-clause               111591958
;  :num-allocs              225044658
;  :num-checks              838
;  :propagations            32469117
;  :quant-instantiations    38458630
;  :restarts                24
;  :rlimit-count            878472792
;  :time                    0.03)
; [eval] (None(): option[array])
(pop) ; 18
(push) ; 18
; [else-branch: 396 | !(i1@720@04 < V@15@04 && 0 <= i1@720@04)]
(assert (not (and (< i1@720@04 V@15@04) (<= 0 i1@720@04))))
(pop) ; 18
(pop) ; 17
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (ite
          (and (< (inv@262@04 r) V@15@04) (<= 0 (inv@262@04 r)))
          $k@261@04
          $Perm.No)
        (pTaken@319@04 r)))
    (=
      ($FVF.lookup_option$array$ (as sm@721@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@259@04))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@721@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@259@04))))) r))
  :qid |qp.fvfValDef562|)))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (ite
          (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
          $k@20@04
          $Perm.No)
        (pTaken@234@04 r)))
    (=
      ($FVF.lookup_option$array$ (as sm@721@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@721@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r))
  :qid |qp.fvfValDef563|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@296@04 r) V@15@04) (<= 0 (inv@296@04 r)))
      (< $Perm.No $k@295@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@721@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@721@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r))
  :qid |qp.fvfValDef564|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@259@04))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r) r))
  :pattern (($FVF.lookup_option$array$ (as sm@721@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef565|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@722@04  $FPM) r)
    (+
      (+
        (-
          (ite
            (and (< (inv@262@04 r) V@15@04) (<= 0 (inv@262@04 r)))
            $k@261@04
            $Perm.No)
          (pTaken@319@04 r))
        (-
          (ite
            (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
            $k@20@04
            $Perm.No)
          (pTaken@234@04 r)))
      (ite
        (and (< (inv@296@04 r) V@15@04) (<= 0 (inv@296@04 r)))
        $k@295@04
        $Perm.No)))
  :pattern (($FVF.perm_option$array$ (as pm@722@04  $FPM) r))
  :qid |qp.resPrmSumDef566|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@721@04  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@259@04))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@722@04  $FPM) r))
  :qid |qp.resTrgDef567|)))
(assert (implies
  (and (< i1@720@04 V@15@04) (<= 0 i1@720@04))
  (and
    (< i1@720@04 V@15@04)
    (<= 0 i1@720@04)
    (< i1@720@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@721@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@720@04)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@720@04)))))
; Joined path conditions
(pop) ; 16
; Nested auxiliary terms: globals (aux)
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (ite
          (and (< (inv@262@04 r) V@15@04) (<= 0 (inv@262@04 r)))
          $k@261@04
          $Perm.No)
        (pTaken@319@04 r)))
    (=
      ($FVF.lookup_option$array$ (as sm@721@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@259@04))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@721@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@259@04))))) r))
  :qid |qp.fvfValDef562|)))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (ite
          (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
          $k@20@04
          $Perm.No)
        (pTaken@234@04 r)))
    (=
      ($FVF.lookup_option$array$ (as sm@721@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@721@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r))
  :qid |qp.fvfValDef563|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@296@04 r) V@15@04) (<= 0 (inv@296@04 r)))
      (< $Perm.No $k@295@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@721@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@721@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r))
  :qid |qp.fvfValDef564|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@259@04))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r) r))
  :pattern (($FVF.lookup_option$array$ (as sm@721@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef565|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@722@04  $FPM) r)
    (+
      (+
        (-
          (ite
            (and (< (inv@262@04 r) V@15@04) (<= 0 (inv@262@04 r)))
            $k@261@04
            $Perm.No)
          (pTaken@319@04 r))
        (-
          (ite
            (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
            $k@20@04
            $Perm.No)
          (pTaken@234@04 r)))
      (ite
        (and (< (inv@296@04 r) V@15@04) (<= 0 (inv@296@04 r)))
        $k@295@04
        $Perm.No)))
  :pattern (($FVF.perm_option$array$ (as pm@722@04  $FPM) r))
  :qid |qp.resPrmSumDef566|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@721@04  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@259@04))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@722@04  $FPM) r))
  :qid |qp.resTrgDef567|)))
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
; Nested auxiliary terms: non-globals (tlq)
(push) ; 16
(assert (not (forall ((i1@720@04 Int)) (!
  (implies
    (and (< i1@720@04 V@15@04) (<= 0 i1@720@04))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@721@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@720@04))
        (as None<option<array>>  option<array>))))
  
  :qid |prog.l<no position>|))))
(check-sat)
; unsat
(pop) ; 16
; 0.03s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               45479350
;  :arith-add-rows          9077109
;  :arith-assert-diseq      330210
;  :arith-assert-lower      8138377
;  :arith-assert-upper      7075069
;  :arith-bound-prop        189287
;  :arith-conflicts         4705
;  :arith-eq-adapter        2922341
;  :arith-fixed-eqs         7555679
;  :arith-offset-eqs        5153889
;  :arith-pivots            1260994
;  :conflicts               10700
;  :datatype-accessor-ax    5424
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1965002
;  :del-clause              111597184
;  :final-checks            5
;  :max-generation          15
;  :max-memory              590.26
;  :memory                  543.92
;  :minimized-lits          1710
;  :mk-bool-var             94887868
;  :mk-clause               111598821
;  :num-allocs              225062397
;  :num-checks              839
;  :propagations            32469969
;  :quant-instantiations    38459860
;  :restarts                24
;  :rlimit-count            878553501
;  :time                    0.03)
(assert (forall ((i1@720@04 Int)) (!
  (implies
    (and (< i1@720@04 V@15@04) (<= 0 i1@720@04))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@721@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@720@04))
        (as None<option<array>>  option<array>))))
  
  :qid |prog.l<no position>|)))
; [eval] (forall i1: Int :: 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(G), i1).option$array$)) == V)
(declare-const i1@723@04 Int)
(push) ; 16
; [eval] 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(G), i1).option$array$)) == V
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 17
; [then-branch: 397 | 0 <= i1@723@04 | live]
; [else-branch: 397 | !(0 <= i1@723@04) | live]
(push) ; 18
; [then-branch: 397 | 0 <= i1@723@04]
(assert (<= 0 i1@723@04))
; [eval] i1 < V
(pop) ; 18
(push) ; 18
; [else-branch: 397 | !(0 <= i1@723@04)]
(assert (not (<= 0 i1@723@04)))
(pop) ; 18
(pop) ; 17
; Joined path conditions
; Joined path conditions
(push) ; 17
; [then-branch: 398 | i1@723@04 < V@15@04 && 0 <= i1@723@04 | live]
; [else-branch: 398 | !(i1@723@04 < V@15@04 && 0 <= i1@723@04) | live]
(push) ; 18
; [then-branch: 398 | i1@723@04 < V@15@04 && 0 <= i1@723@04]
(assert (and (< i1@723@04 V@15@04) (<= 0 i1@723@04)))
; [eval] alen(opt_get1(aloc(opt_get1(G), i1).option$array$)) == V
; [eval] alen(opt_get1(aloc(opt_get1(G), i1).option$array$))
; [eval] opt_get1(aloc(opt_get1(G), i1).option$array$)
; [eval] aloc(opt_get1(G), i1)
; [eval] opt_get1(G)
(push) ; 19
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 19
; Joined path conditions
(push) ; 19
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 20
(assert (not (< i1@723@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))))
(check-sat)
; unsat
(pop) ; 20
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               45479350
;  :arith-add-rows          9077110
;  :arith-assert-diseq      330210
;  :arith-assert-lower      8138379
;  :arith-assert-upper      7075069
;  :arith-bound-prop        189287
;  :arith-conflicts         4705
;  :arith-eq-adapter        2922341
;  :arith-fixed-eqs         7555679
;  :arith-offset-eqs        5153889
;  :arith-pivots            1260994
;  :conflicts               10700
;  :datatype-accessor-ax    5424
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1965002
;  :del-clause              111597184
;  :final-checks            5
;  :max-generation          15
;  :max-memory              590.26
;  :memory                  543.92
;  :minimized-lits          1710
;  :mk-bool-var             94887871
;  :mk-clause               111598821
;  :num-allocs              225062715
;  :num-checks              840
;  :propagations            32469969
;  :quant-instantiations    38459860
;  :restarts                24
;  :rlimit-count            878553971)
(assert (< i1@723@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(pop) ; 19
; Joined path conditions
(assert (< i1@723@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(declare-const sm@724@04 $FVF<option<array>>)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (ite
          (and (< (inv@262@04 r) V@15@04) (<= 0 (inv@262@04 r)))
          $k@261@04
          $Perm.No)
        (pTaken@319@04 r)))
    (=
      ($FVF.lookup_option$array$ (as sm@724@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@259@04))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@724@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@259@04))))) r))
  :qid |qp.fvfValDef568|)))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (ite
          (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
          $k@20@04
          $Perm.No)
        (pTaken@234@04 r)))
    (=
      ($FVF.lookup_option$array$ (as sm@724@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@724@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r))
  :qid |qp.fvfValDef569|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@296@04 r) V@15@04) (<= 0 (inv@296@04 r)))
      (< $Perm.No $k@295@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@724@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@724@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r))
  :qid |qp.fvfValDef570|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@259@04))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r) r))
  :pattern (($FVF.lookup_option$array$ (as sm@724@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef571|)))
(declare-const pm@725@04 $FPM)
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@725@04  $FPM) r)
    (+
      (+
        (-
          (ite
            (and (< (inv@262@04 r) V@15@04) (<= 0 (inv@262@04 r)))
            $k@261@04
            $Perm.No)
          (pTaken@319@04 r))
        (-
          (ite
            (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
            $k@20@04
            $Perm.No)
          (pTaken@234@04 r)))
      (ite
        (and (< (inv@296@04 r) V@15@04) (<= 0 (inv@296@04 r)))
        $k@295@04
        $Perm.No)))
  :pattern (($FVF.perm_option$array$ (as pm@725@04  $FPM) r))
  :qid |qp.resPrmSumDef572|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@724@04  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@259@04))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@725@04  $FPM) r))
  :qid |qp.resTrgDef573|)))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@724@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@723@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@723@04)))
(push) ; 19
(assert (not (<
  $Perm.No
  ($FVF.perm_option$array$ (as pm@725@04  $FPM) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@723@04)))))
(check-sat)
; unsat
(pop) ; 19
; 0.03s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               45480530
;  :arith-add-rows          9078151
;  :arith-assert-diseq      330252
;  :arith-assert-lower      8138652
;  :arith-assert-upper      7075214
;  :arith-bound-prop        189353
;  :arith-conflicts         4713
;  :arith-eq-adapter        2922514
;  :arith-fixed-eqs         7555814
;  :arith-offset-eqs        5154032
;  :arith-pivots            1261131
;  :conflicts               10712
;  :datatype-accessor-ax    5424
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1965230
;  :del-clause              111603919
;  :final-checks            5
;  :max-generation          15
;  :max-memory              590.26
;  :memory                  543.87
;  :minimized-lits          1710
;  :mk-bool-var             94893251
;  :mk-clause               111605897
;  :num-allocs              225082099
;  :num-checks              841
;  :propagations            32471292
;  :quant-instantiations    38461157
;  :restarts                24
;  :rlimit-count            878643558
;  :time                    0.03)
(push) ; 19
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 20
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@724@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@723@04))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 20
; 0.02s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               45481044
;  :arith-add-rows          9078804
;  :arith-assert-diseq      330262
;  :arith-assert-lower      8138722
;  :arith-assert-upper      7075264
;  :arith-bound-prop        189369
;  :arith-conflicts         4714
;  :arith-eq-adapter        2922559
;  :arith-fixed-eqs         7555874
;  :arith-offset-eqs        5154083
;  :arith-pivots            1261148
;  :conflicts               10730
;  :datatype-accessor-ax    5424
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1965433
;  :del-clause              111610411
;  :final-checks            5
;  :max-generation          15
;  :max-memory              590.26
;  :memory                  543.87
;  :minimized-lits          1710
;  :mk-bool-var             94897633
;  :mk-clause               111612389
;  :num-allocs              225095965
;  :num-checks              842
;  :propagations            32472197
;  :quant-instantiations    38462201
;  :restarts                24
;  :rlimit-count            878709237
;  :time                    0.02)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@724@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@723@04))
    (as None<option<array>>  option<array>))))
(pop) ; 19
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@724@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@723@04))
    (as None<option<array>>  option<array>))))
(pop) ; 18
(push) ; 18
; [else-branch: 398 | !(i1@723@04 < V@15@04 && 0 <= i1@723@04)]
(assert (not (and (< i1@723@04 V@15@04) (<= 0 i1@723@04))))
(pop) ; 18
(pop) ; 17
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (ite
          (and (< (inv@262@04 r) V@15@04) (<= 0 (inv@262@04 r)))
          $k@261@04
          $Perm.No)
        (pTaken@319@04 r)))
    (=
      ($FVF.lookup_option$array$ (as sm@724@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@259@04))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@724@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@259@04))))) r))
  :qid |qp.fvfValDef568|)))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (ite
          (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
          $k@20@04
          $Perm.No)
        (pTaken@234@04 r)))
    (=
      ($FVF.lookup_option$array$ (as sm@724@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@724@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r))
  :qid |qp.fvfValDef569|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@296@04 r) V@15@04) (<= 0 (inv@296@04 r)))
      (< $Perm.No $k@295@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@724@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@724@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r))
  :qid |qp.fvfValDef570|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@259@04))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r) r))
  :pattern (($FVF.lookup_option$array$ (as sm@724@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef571|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@725@04  $FPM) r)
    (+
      (+
        (-
          (ite
            (and (< (inv@262@04 r) V@15@04) (<= 0 (inv@262@04 r)))
            $k@261@04
            $Perm.No)
          (pTaken@319@04 r))
        (-
          (ite
            (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
            $k@20@04
            $Perm.No)
          (pTaken@234@04 r)))
      (ite
        (and (< (inv@296@04 r) V@15@04) (<= 0 (inv@296@04 r)))
        $k@295@04
        $Perm.No)))
  :pattern (($FVF.perm_option$array$ (as pm@725@04  $FPM) r))
  :qid |qp.resPrmSumDef572|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@724@04  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@259@04))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@725@04  $FPM) r))
  :qid |qp.resTrgDef573|)))
(assert (implies
  (and (< i1@723@04 V@15@04) (<= 0 i1@723@04))
  (and
    (< i1@723@04 V@15@04)
    (<= 0 i1@723@04)
    (< i1@723@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@724@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@723@04)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@723@04))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@724@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@723@04))
        (as None<option<array>>  option<array>))))))
; Joined path conditions
(pop) ; 16
; Nested auxiliary terms: globals (aux)
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (ite
          (and (< (inv@262@04 r) V@15@04) (<= 0 (inv@262@04 r)))
          $k@261@04
          $Perm.No)
        (pTaken@319@04 r)))
    (=
      ($FVF.lookup_option$array$ (as sm@724@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@259@04))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@724@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@259@04))))) r))
  :qid |qp.fvfValDef568|)))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (ite
          (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
          $k@20@04
          $Perm.No)
        (pTaken@234@04 r)))
    (=
      ($FVF.lookup_option$array$ (as sm@724@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@724@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r))
  :qid |qp.fvfValDef569|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@296@04 r) V@15@04) (<= 0 (inv@296@04 r)))
      (< $Perm.No $k@295@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@724@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@724@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r))
  :qid |qp.fvfValDef570|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@259@04))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r) r))
  :pattern (($FVF.lookup_option$array$ (as sm@724@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef571|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@725@04  $FPM) r)
    (+
      (+
        (-
          (ite
            (and (< (inv@262@04 r) V@15@04) (<= 0 (inv@262@04 r)))
            $k@261@04
            $Perm.No)
          (pTaken@319@04 r))
        (-
          (ite
            (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
            $k@20@04
            $Perm.No)
          (pTaken@234@04 r)))
      (ite
        (and (< (inv@296@04 r) V@15@04) (<= 0 (inv@296@04 r)))
        $k@295@04
        $Perm.No)))
  :pattern (($FVF.perm_option$array$ (as pm@725@04  $FPM) r))
  :qid |qp.resPrmSumDef572|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@724@04  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@259@04))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@725@04  $FPM) r))
  :qid |qp.resTrgDef573|)))
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
; Nested auxiliary terms: non-globals (tlq)
(push) ; 16
(assert (not (forall ((i1@723@04 Int)) (!
  (implies
    (and (< i1@723@04 V@15@04) (<= 0 i1@723@04))
    (=
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@724@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@723@04))))
      V@15@04))
  
  :qid |prog.l<no position>|))))
(check-sat)
; unsat
(pop) ; 16
; 0.03s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               45481727
;  :arith-add-rows          9079537
;  :arith-assert-diseq      330274
;  :arith-assert-lower      8138819
;  :arith-assert-upper      7075334
;  :arith-bound-prop        189401
;  :arith-conflicts         4715
;  :arith-eq-adapter        2922627
;  :arith-fixed-eqs         7555954
;  :arith-offset-eqs        5154134
;  :arith-pivots            1261234
;  :conflicts               10748
;  :datatype-accessor-ax    5424
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1965637
;  :del-clause              111617642
;  :final-checks            5
;  :max-generation          15
;  :max-memory              590.26
;  :memory                  543.83
;  :minimized-lits          1710
;  :mk-bool-var             94902577
;  :mk-clause               111619279
;  :num-allocs              225113989
;  :num-checks              843
;  :propagations            32473147
;  :quant-instantiations    38463466
;  :restarts                24
;  :rlimit-count            878790909
;  :time                    0.03)
(assert (forall ((i1@723@04 Int)) (!
  (implies
    (and (< i1@723@04 V@15@04) (<= 0 i1@723@04))
    (=
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@724@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@723@04))))
      V@15@04))
  
  :qid |prog.l<no position>|)))
; [eval] (forall i1: Int :: (forall i2: Int :: { aloc(opt_get1(G), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(G), i1).option$array$ == aloc(opt_get1(G), i2).option$array$ ==> i1 == i2))
(declare-const i1@726@04 Int)
(push) ; 16
; [eval] (forall i2: Int :: { aloc(opt_get1(G), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(G), i1).option$array$ == aloc(opt_get1(G), i2).option$array$ ==> i1 == i2)
(declare-const i2@727@04 Int)
(push) ; 17
; [eval] 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(G), i1).option$array$ == aloc(opt_get1(G), i2).option$array$ ==> i1 == i2
; [eval] 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(G), i1).option$array$ == aloc(opt_get1(G), i2).option$array$
; [eval] 0 <= i1
(push) ; 18
; [then-branch: 399 | 0 <= i1@726@04 | live]
; [else-branch: 399 | !(0 <= i1@726@04) | live]
(push) ; 19
; [then-branch: 399 | 0 <= i1@726@04]
(assert (<= 0 i1@726@04))
; [eval] i1 < V
(push) ; 20
; [then-branch: 400 | i1@726@04 < V@15@04 | live]
; [else-branch: 400 | !(i1@726@04 < V@15@04) | live]
(push) ; 21
; [then-branch: 400 | i1@726@04 < V@15@04]
(assert (< i1@726@04 V@15@04))
; [eval] 0 <= i2
(push) ; 22
; [then-branch: 401 | 0 <= i2@727@04 | live]
; [else-branch: 401 | !(0 <= i2@727@04) | live]
(push) ; 23
; [then-branch: 401 | 0 <= i2@727@04]
(assert (<= 0 i2@727@04))
; [eval] i2 < V
(push) ; 24
; [then-branch: 402 | i2@727@04 < V@15@04 | live]
; [else-branch: 402 | !(i2@727@04 < V@15@04) | live]
(push) ; 25
; [then-branch: 402 | i2@727@04 < V@15@04]
(assert (< i2@727@04 V@15@04))
; [eval] aloc(opt_get1(G), i1).option$array$ == aloc(opt_get1(G), i2).option$array$
; [eval] aloc(opt_get1(G), i1)
; [eval] opt_get1(G)
(push) ; 26
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 26
; Joined path conditions
(push) ; 26
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 27
(assert (not (< i1@726@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))))
(check-sat)
; unsat
(pop) ; 27
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               45481727
;  :arith-add-rows          9079539
;  :arith-assert-diseq      330274
;  :arith-assert-lower      8138823
;  :arith-assert-upper      7075334
;  :arith-bound-prop        189401
;  :arith-conflicts         4715
;  :arith-eq-adapter        2922627
;  :arith-fixed-eqs         7555954
;  :arith-offset-eqs        5154134
;  :arith-pivots            1261234
;  :conflicts               10748
;  :datatype-accessor-ax    5424
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1965637
;  :del-clause              111617642
;  :final-checks            5
;  :max-generation          15
;  :max-memory              590.26
;  :memory                  543.83
;  :minimized-lits          1710
;  :mk-bool-var             94902582
;  :mk-clause               111619279
;  :num-allocs              225114515
;  :num-checks              844
;  :propagations            32473147
;  :quant-instantiations    38463466
;  :restarts                24
;  :rlimit-count            878791540)
(assert (< i1@726@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(pop) ; 26
; Joined path conditions
(assert (< i1@726@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(declare-const sm@728@04 $FVF<option<array>>)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (ite
          (and (< (inv@262@04 r) V@15@04) (<= 0 (inv@262@04 r)))
          $k@261@04
          $Perm.No)
        (pTaken@319@04 r)))
    (=
      ($FVF.lookup_option$array$ (as sm@728@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@259@04))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@728@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@259@04))))) r))
  :qid |qp.fvfValDef574|)))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (ite
          (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
          $k@20@04
          $Perm.No)
        (pTaken@234@04 r)))
    (=
      ($FVF.lookup_option$array$ (as sm@728@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@728@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r))
  :qid |qp.fvfValDef575|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@296@04 r) V@15@04) (<= 0 (inv@296@04 r)))
      (< $Perm.No $k@295@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@728@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@728@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r))
  :qid |qp.fvfValDef576|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@259@04))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r) r))
  :pattern (($FVF.lookup_option$array$ (as sm@728@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef577|)))
(declare-const pm@729@04 $FPM)
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@729@04  $FPM) r)
    (+
      (+
        (-
          (ite
            (and (< (inv@262@04 r) V@15@04) (<= 0 (inv@262@04 r)))
            $k@261@04
            $Perm.No)
          (pTaken@319@04 r))
        (-
          (ite
            (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
            $k@20@04
            $Perm.No)
          (pTaken@234@04 r)))
      (ite
        (and (< (inv@296@04 r) V@15@04) (<= 0 (inv@296@04 r)))
        $k@295@04
        $Perm.No)))
  :pattern (($FVF.perm_option$array$ (as pm@729@04  $FPM) r))
  :qid |qp.resPrmSumDef578|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@728@04  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@259@04))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@729@04  $FPM) r))
  :qid |qp.resTrgDef579|)))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@728@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@726@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@726@04)))
(push) ; 26
(assert (not (<
  $Perm.No
  ($FVF.perm_option$array$ (as pm@729@04  $FPM) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@726@04)))))
(check-sat)
; unsat
(pop) ; 26
; 0.03s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               45483004
;  :arith-add-rows          9080590
;  :arith-assert-diseq      330310
;  :arith-assert-lower      8139083
;  :arith-assert-upper      7075471
;  :arith-bound-prop        189469
;  :arith-conflicts         4722
;  :arith-eq-adapter        2922792
;  :arith-fixed-eqs         7556088
;  :arith-offset-eqs        5154274
;  :arith-pivots            1261372
;  :conflicts               10759
;  :datatype-accessor-ax    5424
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1965861
;  :del-clause              111624380
;  :final-checks            5
;  :max-generation          15
;  :max-memory              590.26
;  :memory                  544.03
;  :minimized-lits          1710
;  :mk-bool-var             94908000
;  :mk-clause               111626363
;  :num-allocs              225134035
;  :num-checks              845
;  :propagations            32474510
;  :quant-instantiations    38464804
;  :restarts                24
;  :rlimit-count            878882800
;  :time                    0.03)
; [eval] aloc(opt_get1(G), i2)
; [eval] opt_get1(G)
(push) ; 26
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 26
; Joined path conditions
(push) ; 26
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 27
(assert (not (< i2@727@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))))
(check-sat)
; unsat
(pop) ; 27
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               45483004
;  :arith-add-rows          9080590
;  :arith-assert-diseq      330310
;  :arith-assert-lower      8139083
;  :arith-assert-upper      7075471
;  :arith-bound-prop        189469
;  :arith-conflicts         4722
;  :arith-eq-adapter        2922792
;  :arith-fixed-eqs         7556088
;  :arith-offset-eqs        5154274
;  :arith-pivots            1261372
;  :conflicts               10759
;  :datatype-accessor-ax    5424
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1965861
;  :del-clause              111624380
;  :final-checks            5
;  :max-generation          15
;  :max-memory              590.26
;  :memory                  544.03
;  :minimized-lits          1710
;  :mk-bool-var             94908000
;  :mk-clause               111626363
;  :num-allocs              225134061
;  :num-checks              846
;  :propagations            32474510
;  :quant-instantiations    38464804
;  :restarts                24
;  :rlimit-count            878882830)
(assert (< i2@727@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(pop) ; 26
; Joined path conditions
(assert (< i2@727@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(declare-const sm@730@04 $FVF<option<array>>)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (ite
          (and (< (inv@262@04 r) V@15@04) (<= 0 (inv@262@04 r)))
          $k@261@04
          $Perm.No)
        (pTaken@319@04 r)))
    (=
      ($FVF.lookup_option$array$ (as sm@730@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@259@04))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@730@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@259@04))))) r))
  :qid |qp.fvfValDef580|)))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (ite
          (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
          $k@20@04
          $Perm.No)
        (pTaken@234@04 r)))
    (=
      ($FVF.lookup_option$array$ (as sm@730@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@730@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r))
  :qid |qp.fvfValDef581|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@296@04 r) V@15@04) (<= 0 (inv@296@04 r)))
      (< $Perm.No $k@295@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@730@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@730@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r))
  :qid |qp.fvfValDef582|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@259@04))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r) r))
  :pattern (($FVF.lookup_option$array$ (as sm@730@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef583|)))
(declare-const pm@731@04 $FPM)
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@731@04  $FPM) r)
    (+
      (+
        (-
          (ite
            (and (< (inv@262@04 r) V@15@04) (<= 0 (inv@262@04 r)))
            $k@261@04
            $Perm.No)
          (pTaken@319@04 r))
        (-
          (ite
            (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
            $k@20@04
            $Perm.No)
          (pTaken@234@04 r)))
      (ite
        (and (< (inv@296@04 r) V@15@04) (<= 0 (inv@296@04 r)))
        $k@295@04
        $Perm.No)))
  :pattern (($FVF.perm_option$array$ (as pm@731@04  $FPM) r))
  :qid |qp.resPrmSumDef584|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@730@04  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@259@04))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@731@04  $FPM) r))
  :qid |qp.resTrgDef585|)))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@730@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@727@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@727@04)))
(push) ; 26
(assert (not (<
  $Perm.No
  ($FVF.perm_option$array$ (as pm@731@04  $FPM) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@727@04)))))
(check-sat)
; unsat
(pop) ; 26
; 0.03s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               45485192
;  :arith-add-rows          9082091
;  :arith-assert-diseq      330392
;  :arith-assert-lower      8139533
;  :arith-assert-upper      7075674
;  :arith-bound-prop        189584
;  :arith-conflicts         4736
;  :arith-eq-adapter        2923063
;  :arith-fixed-eqs         7556263
;  :arith-offset-eqs        5154459
;  :arith-pivots            1261533
;  :conflicts               10776
;  :datatype-accessor-ax    5424
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1966137
;  :del-clause              111632281
;  :final-checks            5
;  :max-generation          15
;  :max-memory              590.26
;  :memory                  544.08
;  :minimized-lits          1710
;  :mk-bool-var             94914470
;  :mk-clause               111634590
;  :num-allocs              225157111
;  :num-checks              847
;  :propagations            32476666
;  :quant-instantiations    38466345
;  :restarts                24
;  :rlimit-count            878992438
;  :time                    0.03)
(pop) ; 25
(push) ; 25
; [else-branch: 402 | !(i2@727@04 < V@15@04)]
(assert (not (< i2@727@04 V@15@04)))
(pop) ; 25
(pop) ; 24
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (ite
          (and (< (inv@262@04 r) V@15@04) (<= 0 (inv@262@04 r)))
          $k@261@04
          $Perm.No)
        (pTaken@319@04 r)))
    (=
      ($FVF.lookup_option$array$ (as sm@728@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@259@04))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@728@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@259@04))))) r))
  :qid |qp.fvfValDef574|)))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (ite
          (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
          $k@20@04
          $Perm.No)
        (pTaken@234@04 r)))
    (=
      ($FVF.lookup_option$array$ (as sm@728@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@728@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r))
  :qid |qp.fvfValDef575|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@296@04 r) V@15@04) (<= 0 (inv@296@04 r)))
      (< $Perm.No $k@295@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@728@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@728@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r))
  :qid |qp.fvfValDef576|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@259@04))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r) r))
  :pattern (($FVF.lookup_option$array$ (as sm@728@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef577|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@729@04  $FPM) r)
    (+
      (+
        (-
          (ite
            (and (< (inv@262@04 r) V@15@04) (<= 0 (inv@262@04 r)))
            $k@261@04
            $Perm.No)
          (pTaken@319@04 r))
        (-
          (ite
            (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
            $k@20@04
            $Perm.No)
          (pTaken@234@04 r)))
      (ite
        (and (< (inv@296@04 r) V@15@04) (<= 0 (inv@296@04 r)))
        $k@295@04
        $Perm.No)))
  :pattern (($FVF.perm_option$array$ (as pm@729@04  $FPM) r))
  :qid |qp.resPrmSumDef578|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@728@04  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@259@04))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@729@04  $FPM) r))
  :qid |qp.resTrgDef579|)))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (ite
          (and (< (inv@262@04 r) V@15@04) (<= 0 (inv@262@04 r)))
          $k@261@04
          $Perm.No)
        (pTaken@319@04 r)))
    (=
      ($FVF.lookup_option$array$ (as sm@730@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@259@04))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@730@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@259@04))))) r))
  :qid |qp.fvfValDef580|)))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (ite
          (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
          $k@20@04
          $Perm.No)
        (pTaken@234@04 r)))
    (=
      ($FVF.lookup_option$array$ (as sm@730@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@730@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r))
  :qid |qp.fvfValDef581|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@296@04 r) V@15@04) (<= 0 (inv@296@04 r)))
      (< $Perm.No $k@295@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@730@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@730@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r))
  :qid |qp.fvfValDef582|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@259@04))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r) r))
  :pattern (($FVF.lookup_option$array$ (as sm@730@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef583|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@731@04  $FPM) r)
    (+
      (+
        (-
          (ite
            (and (< (inv@262@04 r) V@15@04) (<= 0 (inv@262@04 r)))
            $k@261@04
            $Perm.No)
          (pTaken@319@04 r))
        (-
          (ite
            (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
            $k@20@04
            $Perm.No)
          (pTaken@234@04 r)))
      (ite
        (and (< (inv@296@04 r) V@15@04) (<= 0 (inv@296@04 r)))
        $k@295@04
        $Perm.No)))
  :pattern (($FVF.perm_option$array$ (as pm@731@04  $FPM) r))
  :qid |qp.resPrmSumDef584|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@730@04  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@259@04))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@731@04  $FPM) r))
  :qid |qp.resTrgDef585|)))
(assert (implies
  (< i2@727@04 V@15@04)
  (and
    (< i2@727@04 V@15@04)
    (< i1@726@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@728@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@726@04)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@726@04))
    (< i2@727@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@730@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@727@04)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@727@04)))))
; Joined path conditions
(pop) ; 23
(push) ; 23
; [else-branch: 401 | !(0 <= i2@727@04)]
(assert (not (<= 0 i2@727@04)))
(pop) ; 23
(pop) ; 22
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (ite
          (and (< (inv@262@04 r) V@15@04) (<= 0 (inv@262@04 r)))
          $k@261@04
          $Perm.No)
        (pTaken@319@04 r)))
    (=
      ($FVF.lookup_option$array$ (as sm@728@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@259@04))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@728@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@259@04))))) r))
  :qid |qp.fvfValDef574|)))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (ite
          (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
          $k@20@04
          $Perm.No)
        (pTaken@234@04 r)))
    (=
      ($FVF.lookup_option$array$ (as sm@728@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@728@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r))
  :qid |qp.fvfValDef575|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@296@04 r) V@15@04) (<= 0 (inv@296@04 r)))
      (< $Perm.No $k@295@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@728@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@728@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r))
  :qid |qp.fvfValDef576|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@259@04))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r) r))
  :pattern (($FVF.lookup_option$array$ (as sm@728@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef577|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@729@04  $FPM) r)
    (+
      (+
        (-
          (ite
            (and (< (inv@262@04 r) V@15@04) (<= 0 (inv@262@04 r)))
            $k@261@04
            $Perm.No)
          (pTaken@319@04 r))
        (-
          (ite
            (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
            $k@20@04
            $Perm.No)
          (pTaken@234@04 r)))
      (ite
        (and (< (inv@296@04 r) V@15@04) (<= 0 (inv@296@04 r)))
        $k@295@04
        $Perm.No)))
  :pattern (($FVF.perm_option$array$ (as pm@729@04  $FPM) r))
  :qid |qp.resPrmSumDef578|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@728@04  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@259@04))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@729@04  $FPM) r))
  :qid |qp.resTrgDef579|)))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (ite
          (and (< (inv@262@04 r) V@15@04) (<= 0 (inv@262@04 r)))
          $k@261@04
          $Perm.No)
        (pTaken@319@04 r)))
    (=
      ($FVF.lookup_option$array$ (as sm@730@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@259@04))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@730@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@259@04))))) r))
  :qid |qp.fvfValDef580|)))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (ite
          (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
          $k@20@04
          $Perm.No)
        (pTaken@234@04 r)))
    (=
      ($FVF.lookup_option$array$ (as sm@730@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@730@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r))
  :qid |qp.fvfValDef581|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@296@04 r) V@15@04) (<= 0 (inv@296@04 r)))
      (< $Perm.No $k@295@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@730@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@730@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r))
  :qid |qp.fvfValDef582|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@259@04))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r) r))
  :pattern (($FVF.lookup_option$array$ (as sm@730@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef583|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@731@04  $FPM) r)
    (+
      (+
        (-
          (ite
            (and (< (inv@262@04 r) V@15@04) (<= 0 (inv@262@04 r)))
            $k@261@04
            $Perm.No)
          (pTaken@319@04 r))
        (-
          (ite
            (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
            $k@20@04
            $Perm.No)
          (pTaken@234@04 r)))
      (ite
        (and (< (inv@296@04 r) V@15@04) (<= 0 (inv@296@04 r)))
        $k@295@04
        $Perm.No)))
  :pattern (($FVF.perm_option$array$ (as pm@731@04  $FPM) r))
  :qid |qp.resPrmSumDef584|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@730@04  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@259@04))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@731@04  $FPM) r))
  :qid |qp.resTrgDef585|)))
(assert (implies
  (<= 0 i2@727@04)
  (and
    (<= 0 i2@727@04)
    (implies
      (< i2@727@04 V@15@04)
      (and
        (< i2@727@04 V@15@04)
        (< i1@726@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@728@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@726@04)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@726@04))
        (< i2@727@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@730@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@727@04)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@727@04)))))))
; Joined path conditions
(pop) ; 21
(push) ; 21
; [else-branch: 400 | !(i1@726@04 < V@15@04)]
(assert (not (< i1@726@04 V@15@04)))
(pop) ; 21
(pop) ; 20
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (ite
          (and (< (inv@262@04 r) V@15@04) (<= 0 (inv@262@04 r)))
          $k@261@04
          $Perm.No)
        (pTaken@319@04 r)))
    (=
      ($FVF.lookup_option$array$ (as sm@728@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@259@04))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@728@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@259@04))))) r))
  :qid |qp.fvfValDef574|)))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (ite
          (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
          $k@20@04
          $Perm.No)
        (pTaken@234@04 r)))
    (=
      ($FVF.lookup_option$array$ (as sm@728@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@728@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r))
  :qid |qp.fvfValDef575|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@296@04 r) V@15@04) (<= 0 (inv@296@04 r)))
      (< $Perm.No $k@295@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@728@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@728@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r))
  :qid |qp.fvfValDef576|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@259@04))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r) r))
  :pattern (($FVF.lookup_option$array$ (as sm@728@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef577|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@729@04  $FPM) r)
    (+
      (+
        (-
          (ite
            (and (< (inv@262@04 r) V@15@04) (<= 0 (inv@262@04 r)))
            $k@261@04
            $Perm.No)
          (pTaken@319@04 r))
        (-
          (ite
            (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
            $k@20@04
            $Perm.No)
          (pTaken@234@04 r)))
      (ite
        (and (< (inv@296@04 r) V@15@04) (<= 0 (inv@296@04 r)))
        $k@295@04
        $Perm.No)))
  :pattern (($FVF.perm_option$array$ (as pm@729@04  $FPM) r))
  :qid |qp.resPrmSumDef578|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@728@04  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@259@04))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@729@04  $FPM) r))
  :qid |qp.resTrgDef579|)))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (ite
          (and (< (inv@262@04 r) V@15@04) (<= 0 (inv@262@04 r)))
          $k@261@04
          $Perm.No)
        (pTaken@319@04 r)))
    (=
      ($FVF.lookup_option$array$ (as sm@730@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@259@04))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@730@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@259@04))))) r))
  :qid |qp.fvfValDef580|)))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (ite
          (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
          $k@20@04
          $Perm.No)
        (pTaken@234@04 r)))
    (=
      ($FVF.lookup_option$array$ (as sm@730@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@730@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r))
  :qid |qp.fvfValDef581|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@296@04 r) V@15@04) (<= 0 (inv@296@04 r)))
      (< $Perm.No $k@295@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@730@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@730@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r))
  :qid |qp.fvfValDef582|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@259@04))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r) r))
  :pattern (($FVF.lookup_option$array$ (as sm@730@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef583|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@731@04  $FPM) r)
    (+
      (+
        (-
          (ite
            (and (< (inv@262@04 r) V@15@04) (<= 0 (inv@262@04 r)))
            $k@261@04
            $Perm.No)
          (pTaken@319@04 r))
        (-
          (ite
            (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
            $k@20@04
            $Perm.No)
          (pTaken@234@04 r)))
      (ite
        (and (< (inv@296@04 r) V@15@04) (<= 0 (inv@296@04 r)))
        $k@295@04
        $Perm.No)))
  :pattern (($FVF.perm_option$array$ (as pm@731@04  $FPM) r))
  :qid |qp.resPrmSumDef584|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@730@04  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@259@04))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@731@04  $FPM) r))
  :qid |qp.resTrgDef585|)))
(assert (implies
  (< i1@726@04 V@15@04)
  (and
    (< i1@726@04 V@15@04)
    (implies
      (<= 0 i2@727@04)
      (and
        (<= 0 i2@727@04)
        (implies
          (< i2@727@04 V@15@04)
          (and
            (< i2@727@04 V@15@04)
            (< i1@726@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@728@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@726@04)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@726@04))
            (< i2@727@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@730@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@727@04)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@727@04)))))))))
; Joined path conditions
(pop) ; 19
(push) ; 19
; [else-branch: 399 | !(0 <= i1@726@04)]
(assert (not (<= 0 i1@726@04)))
(pop) ; 19
(pop) ; 18
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (ite
          (and (< (inv@262@04 r) V@15@04) (<= 0 (inv@262@04 r)))
          $k@261@04
          $Perm.No)
        (pTaken@319@04 r)))
    (=
      ($FVF.lookup_option$array$ (as sm@728@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@259@04))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@728@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@259@04))))) r))
  :qid |qp.fvfValDef574|)))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (ite
          (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
          $k@20@04
          $Perm.No)
        (pTaken@234@04 r)))
    (=
      ($FVF.lookup_option$array$ (as sm@728@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@728@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r))
  :qid |qp.fvfValDef575|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@296@04 r) V@15@04) (<= 0 (inv@296@04 r)))
      (< $Perm.No $k@295@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@728@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@728@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r))
  :qid |qp.fvfValDef576|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@259@04))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r) r))
  :pattern (($FVF.lookup_option$array$ (as sm@728@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef577|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@729@04  $FPM) r)
    (+
      (+
        (-
          (ite
            (and (< (inv@262@04 r) V@15@04) (<= 0 (inv@262@04 r)))
            $k@261@04
            $Perm.No)
          (pTaken@319@04 r))
        (-
          (ite
            (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
            $k@20@04
            $Perm.No)
          (pTaken@234@04 r)))
      (ite
        (and (< (inv@296@04 r) V@15@04) (<= 0 (inv@296@04 r)))
        $k@295@04
        $Perm.No)))
  :pattern (($FVF.perm_option$array$ (as pm@729@04  $FPM) r))
  :qid |qp.resPrmSumDef578|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@728@04  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@259@04))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@729@04  $FPM) r))
  :qid |qp.resTrgDef579|)))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (ite
          (and (< (inv@262@04 r) V@15@04) (<= 0 (inv@262@04 r)))
          $k@261@04
          $Perm.No)
        (pTaken@319@04 r)))
    (=
      ($FVF.lookup_option$array$ (as sm@730@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@259@04))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@730@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@259@04))))) r))
  :qid |qp.fvfValDef580|)))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (ite
          (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
          $k@20@04
          $Perm.No)
        (pTaken@234@04 r)))
    (=
      ($FVF.lookup_option$array$ (as sm@730@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@730@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r))
  :qid |qp.fvfValDef581|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@296@04 r) V@15@04) (<= 0 (inv@296@04 r)))
      (< $Perm.No $k@295@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@730@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@730@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r))
  :qid |qp.fvfValDef582|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@259@04))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r) r))
  :pattern (($FVF.lookup_option$array$ (as sm@730@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef583|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@731@04  $FPM) r)
    (+
      (+
        (-
          (ite
            (and (< (inv@262@04 r) V@15@04) (<= 0 (inv@262@04 r)))
            $k@261@04
            $Perm.No)
          (pTaken@319@04 r))
        (-
          (ite
            (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
            $k@20@04
            $Perm.No)
          (pTaken@234@04 r)))
      (ite
        (and (< (inv@296@04 r) V@15@04) (<= 0 (inv@296@04 r)))
        $k@295@04
        $Perm.No)))
  :pattern (($FVF.perm_option$array$ (as pm@731@04  $FPM) r))
  :qid |qp.resPrmSumDef584|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@730@04  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@259@04))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@731@04  $FPM) r))
  :qid |qp.resTrgDef585|)))
(assert (implies
  (<= 0 i1@726@04)
  (and
    (<= 0 i1@726@04)
    (implies
      (< i1@726@04 V@15@04)
      (and
        (< i1@726@04 V@15@04)
        (implies
          (<= 0 i2@727@04)
          (and
            (<= 0 i2@727@04)
            (implies
              (< i2@727@04 V@15@04)
              (and
                (< i2@727@04 V@15@04)
                (< i1@726@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@728@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@726@04)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@726@04))
                (< i2@727@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@730@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@727@04)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@727@04)))))))))))
; Joined path conditions
(push) ; 18
; [then-branch: 403 | Lookup(option$array$,sm@728@04,aloc((_, _), opt_get1(_, G@11@04), i1@726@04)) == Lookup(option$array$,sm@730@04,aloc((_, _), opt_get1(_, G@11@04), i2@727@04)) && i2@727@04 < V@15@04 && 0 <= i2@727@04 && i1@726@04 < V@15@04 && 0 <= i1@726@04 | live]
; [else-branch: 403 | !(Lookup(option$array$,sm@728@04,aloc((_, _), opt_get1(_, G@11@04), i1@726@04)) == Lookup(option$array$,sm@730@04,aloc((_, _), opt_get1(_, G@11@04), i2@727@04)) && i2@727@04 < V@15@04 && 0 <= i2@727@04 && i1@726@04 < V@15@04 && 0 <= i1@726@04) | live]
(push) ; 19
; [then-branch: 403 | Lookup(option$array$,sm@728@04,aloc((_, _), opt_get1(_, G@11@04), i1@726@04)) == Lookup(option$array$,sm@730@04,aloc((_, _), opt_get1(_, G@11@04), i2@727@04)) && i2@727@04 < V@15@04 && 0 <= i2@727@04 && i1@726@04 < V@15@04 && 0 <= i1@726@04]
(assert (and
  (and
    (and
      (and
        (=
          ($FVF.lookup_option$array$ (as sm@728@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@726@04))
          ($FVF.lookup_option$array$ (as sm@730@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@727@04)))
        (< i2@727@04 V@15@04))
      (<= 0 i2@727@04))
    (< i1@726@04 V@15@04))
  (<= 0 i1@726@04)))
; [eval] i1 == i2
(pop) ; 19
(push) ; 19
; [else-branch: 403 | !(Lookup(option$array$,sm@728@04,aloc((_, _), opt_get1(_, G@11@04), i1@726@04)) == Lookup(option$array$,sm@730@04,aloc((_, _), opt_get1(_, G@11@04), i2@727@04)) && i2@727@04 < V@15@04 && 0 <= i2@727@04 && i1@726@04 < V@15@04 && 0 <= i1@726@04)]
(assert (not
  (and
    (and
      (and
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@728@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@726@04))
            ($FVF.lookup_option$array$ (as sm@730@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@727@04)))
          (< i2@727@04 V@15@04))
        (<= 0 i2@727@04))
      (< i1@726@04 V@15@04))
    (<= 0 i1@726@04))))
(pop) ; 19
(pop) ; 18
; Joined path conditions
(assert (implies
  (and
    (and
      (and
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@728@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@726@04))
            ($FVF.lookup_option$array$ (as sm@730@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@727@04)))
          (< i2@727@04 V@15@04))
        (<= 0 i2@727@04))
      (< i1@726@04 V@15@04))
    (<= 0 i1@726@04))
  (and
    (=
      ($FVF.lookup_option$array$ (as sm@728@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@726@04))
      ($FVF.lookup_option$array$ (as sm@730@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@727@04)))
    (< i2@727@04 V@15@04)
    (<= 0 i2@727@04)
    (< i1@726@04 V@15@04)
    (<= 0 i1@726@04))))
; Joined path conditions
(pop) ; 17
; Nested auxiliary terms: globals (aux)
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (ite
          (and (< (inv@262@04 r) V@15@04) (<= 0 (inv@262@04 r)))
          $k@261@04
          $Perm.No)
        (pTaken@319@04 r)))
    (=
      ($FVF.lookup_option$array$ (as sm@728@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@259@04))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@728@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@259@04))))) r))
  :qid |qp.fvfValDef574|)))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (ite
          (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
          $k@20@04
          $Perm.No)
        (pTaken@234@04 r)))
    (=
      ($FVF.lookup_option$array$ (as sm@728@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@728@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r))
  :qid |qp.fvfValDef575|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@296@04 r) V@15@04) (<= 0 (inv@296@04 r)))
      (< $Perm.No $k@295@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@728@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@728@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r))
  :qid |qp.fvfValDef576|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@259@04))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r) r))
  :pattern (($FVF.lookup_option$array$ (as sm@728@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef577|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@729@04  $FPM) r)
    (+
      (+
        (-
          (ite
            (and (< (inv@262@04 r) V@15@04) (<= 0 (inv@262@04 r)))
            $k@261@04
            $Perm.No)
          (pTaken@319@04 r))
        (-
          (ite
            (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
            $k@20@04
            $Perm.No)
          (pTaken@234@04 r)))
      (ite
        (and (< (inv@296@04 r) V@15@04) (<= 0 (inv@296@04 r)))
        $k@295@04
        $Perm.No)))
  :pattern (($FVF.perm_option$array$ (as pm@729@04  $FPM) r))
  :qid |qp.resPrmSumDef578|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@728@04  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@259@04))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@729@04  $FPM) r))
  :qid |qp.resTrgDef579|)))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (ite
          (and (< (inv@262@04 r) V@15@04) (<= 0 (inv@262@04 r)))
          $k@261@04
          $Perm.No)
        (pTaken@319@04 r)))
    (=
      ($FVF.lookup_option$array$ (as sm@730@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@259@04))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@730@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@259@04))))) r))
  :qid |qp.fvfValDef580|)))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (ite
          (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
          $k@20@04
          $Perm.No)
        (pTaken@234@04 r)))
    (=
      ($FVF.lookup_option$array$ (as sm@730@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@730@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r))
  :qid |qp.fvfValDef581|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@296@04 r) V@15@04) (<= 0 (inv@296@04 r)))
      (< $Perm.No $k@295@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@730@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@730@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r))
  :qid |qp.fvfValDef582|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@259@04))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r) r))
  :pattern (($FVF.lookup_option$array$ (as sm@730@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef583|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@731@04  $FPM) r)
    (+
      (+
        (-
          (ite
            (and (< (inv@262@04 r) V@15@04) (<= 0 (inv@262@04 r)))
            $k@261@04
            $Perm.No)
          (pTaken@319@04 r))
        (-
          (ite
            (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
            $k@20@04
            $Perm.No)
          (pTaken@234@04 r)))
      (ite
        (and (< (inv@296@04 r) V@15@04) (<= 0 (inv@296@04 r)))
        $k@295@04
        $Perm.No)))
  :pattern (($FVF.perm_option$array$ (as pm@731@04  $FPM) r))
  :qid |qp.resPrmSumDef584|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@730@04  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@259@04))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@731@04  $FPM) r))
  :qid |qp.resTrgDef585|)))
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i2@727@04 Int)) (!
  (and
    (implies
      (<= 0 i1@726@04)
      (and
        (<= 0 i1@726@04)
        (implies
          (< i1@726@04 V@15@04)
          (and
            (< i1@726@04 V@15@04)
            (implies
              (<= 0 i2@727@04)
              (and
                (<= 0 i2@727@04)
                (implies
                  (< i2@727@04 V@15@04)
                  (and
                    (< i2@727@04 V@15@04)
                    (< i1@726@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
                    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@728@04  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@726@04)) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@726@04))
                    (< i2@727@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
                    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@730@04  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@727@04)) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@727@04))))))))))
    (implies
      (and
        (and
          (and
            (and
              (=
                ($FVF.lookup_option$array$ (as sm@728@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@726@04))
                ($FVF.lookup_option$array$ (as sm@730@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@727@04)))
              (< i2@727@04 V@15@04))
            (<= 0 i2@727@04))
          (< i1@726@04 V@15@04))
        (<= 0 i1@726@04))
      (and
        (=
          ($FVF.lookup_option$array$ (as sm@728@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@726@04))
          ($FVF.lookup_option$array$ (as sm@730@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@727@04)))
        (< i2@727@04 V@15@04)
        (<= 0 i2@727@04)
        (< i1@726@04 V@15@04)
        (<= 0 i1@726@04))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@727@04))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 16
; Nested auxiliary terms: globals (aux)
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (ite
          (and (< (inv@262@04 r) V@15@04) (<= 0 (inv@262@04 r)))
          $k@261@04
          $Perm.No)
        (pTaken@319@04 r)))
    (=
      ($FVF.lookup_option$array$ (as sm@728@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@259@04))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@728@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@259@04))))) r))
  :qid |qp.fvfValDef574|)))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (ite
          (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
          $k@20@04
          $Perm.No)
        (pTaken@234@04 r)))
    (=
      ($FVF.lookup_option$array$ (as sm@728@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@728@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r))
  :qid |qp.fvfValDef575|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@296@04 r) V@15@04) (<= 0 (inv@296@04 r)))
      (< $Perm.No $k@295@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@728@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@728@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r))
  :qid |qp.fvfValDef576|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@259@04))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r) r))
  :pattern (($FVF.lookup_option$array$ (as sm@728@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef577|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@729@04  $FPM) r)
    (+
      (+
        (-
          (ite
            (and (< (inv@262@04 r) V@15@04) (<= 0 (inv@262@04 r)))
            $k@261@04
            $Perm.No)
          (pTaken@319@04 r))
        (-
          (ite
            (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
            $k@20@04
            $Perm.No)
          (pTaken@234@04 r)))
      (ite
        (and (< (inv@296@04 r) V@15@04) (<= 0 (inv@296@04 r)))
        $k@295@04
        $Perm.No)))
  :pattern (($FVF.perm_option$array$ (as pm@729@04  $FPM) r))
  :qid |qp.resPrmSumDef578|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@728@04  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@259@04))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@729@04  $FPM) r))
  :qid |qp.resTrgDef579|)))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (ite
          (and (< (inv@262@04 r) V@15@04) (<= 0 (inv@262@04 r)))
          $k@261@04
          $Perm.No)
        (pTaken@319@04 r)))
    (=
      ($FVF.lookup_option$array$ (as sm@730@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@259@04))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@730@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@259@04))))) r))
  :qid |qp.fvfValDef580|)))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (ite
          (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
          $k@20@04
          $Perm.No)
        (pTaken@234@04 r)))
    (=
      ($FVF.lookup_option$array$ (as sm@730@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@730@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r))
  :qid |qp.fvfValDef581|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@296@04 r) V@15@04) (<= 0 (inv@296@04 r)))
      (< $Perm.No $k@295@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@730@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@730@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r))
  :qid |qp.fvfValDef582|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@259@04))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r) r))
  :pattern (($FVF.lookup_option$array$ (as sm@730@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef583|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@731@04  $FPM) r)
    (+
      (+
        (-
          (ite
            (and (< (inv@262@04 r) V@15@04) (<= 0 (inv@262@04 r)))
            $k@261@04
            $Perm.No)
          (pTaken@319@04 r))
        (-
          (ite
            (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
            $k@20@04
            $Perm.No)
          (pTaken@234@04 r)))
      (ite
        (and (< (inv@296@04 r) V@15@04) (<= 0 (inv@296@04 r)))
        $k@295@04
        $Perm.No)))
  :pattern (($FVF.perm_option$array$ (as pm@731@04  $FPM) r))
  :qid |qp.resPrmSumDef584|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@730@04  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@259@04))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@731@04  $FPM) r))
  :qid |qp.resTrgDef585|)))
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
; Nested auxiliary terms: non-globals (tlq)
(push) ; 16
(assert (not (forall ((i1@726@04 Int)) (!
  (forall ((i2@727@04 Int)) (!
    (implies
      (and
        (and
          (and
            (and
              (=
                ($FVF.lookup_option$array$ (as sm@728@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@726@04))
                ($FVF.lookup_option$array$ (as sm@730@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@727@04)))
              (< i2@727@04 V@15@04))
            (<= 0 i2@727@04))
          (< i1@726@04 V@15@04))
        (<= 0 i1@726@04))
      (= i1@726@04 i2@727@04))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@727@04))
    :qid |prog.l<no position>|))
  
  :qid |prog.l<no position>|))))
(check-sat)
; unsat
(pop) ; 16
; 0.03s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               45486091
;  :arith-add-rows          9083080
;  :arith-assert-diseq      330405
;  :arith-assert-lower      8139679
;  :arith-assert-upper      7075779
;  :arith-bound-prop        189667
;  :arith-conflicts         4738
;  :arith-eq-adapter        2923168
;  :arith-fixed-eqs         7556374
;  :arith-offset-eqs        5154559
;  :arith-pivots            1261720
;  :conflicts               10795
;  :datatype-accessor-ax    5424
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1966344
;  :del-clause              111640409
;  :final-checks            5
;  :max-generation          15
;  :max-memory              590.26
;  :memory                  543.99
;  :minimized-lits          1710
;  :mk-bool-var             94920180
;  :mk-clause               111642046
;  :num-allocs              225185220
;  :num-checks              848
;  :propagations            32477846
;  :quant-instantiations    38467907
;  :restarts                24
;  :rlimit-count            879109526
;  :time                    0.03)
(assert (forall ((i1@726@04 Int)) (!
  (forall ((i2@727@04 Int)) (!
    (implies
      (and
        (and
          (and
            (and
              (=
                ($FVF.lookup_option$array$ (as sm@728@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@726@04))
                ($FVF.lookup_option$array$ (as sm@730@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@727@04)))
              (< i2@727@04 V@15@04))
            (<= 0 i2@727@04))
          (< i1@726@04 V@15@04))
        (<= 0 i1@726@04))
      (= i1@726@04 i2@727@04))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@727@04))
    :qid |prog.l<no position>|))
  
  :qid |prog.l<no position>|)))
(declare-const i1@732@04 Int)
(declare-const j@733@04 Int)
(push) ; 16
; [eval] 0 <= i1 && i1 < V && (0 <= j && j < V)
; [eval] 0 <= i1
(push) ; 17
; [then-branch: 404 | 0 <= i1@732@04 | live]
; [else-branch: 404 | !(0 <= i1@732@04) | live]
(push) ; 18
; [then-branch: 404 | 0 <= i1@732@04]
(assert (<= 0 i1@732@04))
; [eval] i1 < V
(push) ; 19
; [then-branch: 405 | i1@732@04 < V@15@04 | live]
; [else-branch: 405 | !(i1@732@04 < V@15@04) | live]
(push) ; 20
; [then-branch: 405 | i1@732@04 < V@15@04]
(assert (< i1@732@04 V@15@04))
; [eval] 0 <= j
(push) ; 21
; [then-branch: 406 | 0 <= j@733@04 | live]
; [else-branch: 406 | !(0 <= j@733@04) | live]
(push) ; 22
; [then-branch: 406 | 0 <= j@733@04]
(assert (<= 0 j@733@04))
; [eval] j < V
(pop) ; 22
(push) ; 22
; [else-branch: 406 | !(0 <= j@733@04)]
(assert (not (<= 0 j@733@04)))
(pop) ; 22
(pop) ; 21
; Joined path conditions
; Joined path conditions
(pop) ; 20
(push) ; 20
; [else-branch: 405 | !(i1@732@04 < V@15@04)]
(assert (not (< i1@732@04 V@15@04)))
(pop) ; 20
(pop) ; 19
; Joined path conditions
; Joined path conditions
(pop) ; 18
(push) ; 18
; [else-branch: 404 | !(0 <= i1@732@04)]
(assert (not (<= 0 i1@732@04)))
(pop) ; 18
(pop) ; 17
; Joined path conditions
; Joined path conditions
(assert (and
  (and (and (< j@733@04 V@15@04) (<= 0 j@733@04)) (< i1@732@04 V@15@04))
  (<= 0 i1@732@04)))
(declare-const $k@734@04 $Perm)
(assert ($Perm.isReadVar $k@734@04 $Perm.Write))
; [eval] aloc(opt_get1(aloc(opt_get1(G), i1).option$array$), j)
; [eval] opt_get1(aloc(opt_get1(G), i1).option$array$)
; [eval] aloc(opt_get1(G), i1)
; [eval] opt_get1(G)
(push) ; 17
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 17
; Joined path conditions
(push) ; 17
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 18
(assert (not (< i1@732@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))))
(check-sat)
; unsat
(pop) ; 18
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               45486091
;  :arith-add-rows          9083083
;  :arith-assert-diseq      330406
;  :arith-assert-lower      8139687
;  :arith-assert-upper      7075780
;  :arith-bound-prop        189667
;  :arith-conflicts         4738
;  :arith-eq-adapter        2923169
;  :arith-fixed-eqs         7556374
;  :arith-offset-eqs        5154559
;  :arith-pivots            1261721
;  :conflicts               10795
;  :datatype-accessor-ax    5424
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1966344
;  :del-clause              111640409
;  :final-checks            5
;  :max-generation          15
;  :max-memory              590.26
;  :memory                  544.00
;  :minimized-lits          1710
;  :mk-bool-var             94920191
;  :mk-clause               111642048
;  :num-allocs              225185893
;  :num-checks              849
;  :propagations            32477847
;  :quant-instantiations    38467907
;  :restarts                24
;  :rlimit-count            879110621)
(assert (< i1@732@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(pop) ; 17
; Joined path conditions
(assert (< i1@732@04 (alen<Int> (opt_get1 $Snap.unit G@11@04))))
(declare-const sm@735@04 $FVF<option<array>>)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (ite
          (and (< (inv@262@04 r) V@15@04) (<= 0 (inv@262@04 r)))
          $k@261@04
          $Perm.No)
        (pTaken@319@04 r)))
    (=
      ($FVF.lookup_option$array$ (as sm@735@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@259@04))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@735@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@259@04))))) r))
  :qid |qp.fvfValDef586|)))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (ite
          (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
          $k@20@04
          $Perm.No)
        (pTaken@234@04 r)))
    (=
      ($FVF.lookup_option$array$ (as sm@735@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@735@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r))
  :qid |qp.fvfValDef587|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@296@04 r) V@15@04) (<= 0 (inv@296@04 r)))
      (< $Perm.No $k@295@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@735@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@735@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r))
  :qid |qp.fvfValDef588|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@259@04))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r) r))
  :pattern (($FVF.lookup_option$array$ (as sm@735@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef589|)))
(declare-const pm@736@04 $FPM)
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@736@04  $FPM) r)
    (+
      (+
        (-
          (ite
            (and (< (inv@262@04 r) V@15@04) (<= 0 (inv@262@04 r)))
            $k@261@04
            $Perm.No)
          (pTaken@319@04 r))
        (-
          (ite
            (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
            $k@20@04
            $Perm.No)
          (pTaken@234@04 r)))
      (ite
        (and (< (inv@296@04 r) V@15@04) (<= 0 (inv@296@04 r)))
        $k@295@04
        $Perm.No)))
  :pattern (($FVF.perm_option$array$ (as pm@736@04  $FPM) r))
  :qid |qp.resPrmSumDef590|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@735@04  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@259@04))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@736@04  $FPM) r))
  :qid |qp.resTrgDef591|)))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@735@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@732@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@732@04)))
(push) ; 17
(assert (not (<
  $Perm.No
  ($FVF.perm_option$array$ (as pm@736@04  $FPM) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@732@04)))))
(check-sat)
; unsat
(pop) ; 17
; 0.03s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               45487319
;  :arith-add-rows          9084134
;  :arith-assert-diseq      330440
;  :arith-assert-lower      8139934
;  :arith-assert-upper      7075908
;  :arith-bound-prop        189738
;  :arith-conflicts         4744
;  :arith-eq-adapter        2923326
;  :arith-fixed-eqs         7556502
;  :arith-offset-eqs        5154623
;  :arith-pivots            1261848
;  :conflicts               10804
;  :datatype-accessor-ax    5424
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1966562
;  :del-clause              111647139
;  :final-checks            5
;  :max-generation          15
;  :max-memory              590.26
;  :memory                  544.04
;  :minimized-lits          1710
;  :mk-bool-var             94925562
;  :mk-clause               111649130
;  :num-allocs              225205435
;  :num-checks              850
;  :propagations            32479183
;  :quant-instantiations    38469266
;  :restarts                24
;  :rlimit-count            879202314
;  :time                    0.03)
(push) ; 17
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 18
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@735@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@732@04))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 18
; 0.03s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               45487777
;  :arith-add-rows          9084789
;  :arith-assert-diseq      330450
;  :arith-assert-lower      8140008
;  :arith-assert-upper      7075960
;  :arith-bound-prop        189753
;  :arith-conflicts         4745
;  :arith-eq-adapter        2923373
;  :arith-fixed-eqs         7556564
;  :arith-offset-eqs        5154641
;  :arith-pivots            1261869
;  :conflicts               10822
;  :datatype-accessor-ax    5424
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1966765
;  :del-clause              111653660
;  :final-checks            5
;  :max-generation          15
;  :max-memory              590.26
;  :memory                  544.04
;  :minimized-lits          1710
;  :mk-bool-var             94929990
;  :mk-clause               111655651
;  :num-allocs              225219573
;  :num-checks              851
;  :propagations            32480017
;  :quant-instantiations    38470350
;  :restarts                24
;  :rlimit-count            879269279
;  :time                    0.03)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@735@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@732@04))
    (as None<option<array>>  option<array>))))
(pop) ; 17
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@735@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@732@04))
    (as None<option<array>>  option<array>))))
(push) ; 17
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 18
(assert (not (<
  j@733@04
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@735@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@732@04)))))))
(check-sat)
; unsat
(pop) ; 18
; 0.03s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               45488451
;  :arith-add-rows          9085443
;  :arith-assert-diseq      330460
;  :arith-assert-lower      8140084
;  :arith-assert-upper      7076014
;  :arith-bound-prop        189768
;  :arith-conflicts         4747
;  :arith-eq-adapter        2923429
;  :arith-fixed-eqs         7556627
;  :arith-offset-eqs        5154659
;  :arith-pivots            1261893
;  :conflicts               10840
;  :datatype-accessor-ax    5424
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1966968
;  :del-clause              111660208
;  :final-checks            5
;  :max-generation          15
;  :max-memory              590.26
;  :memory                  544.04
;  :minimized-lits          1710
;  :mk-bool-var             94934497
;  :mk-clause               111662199
;  :num-allocs              225234066
;  :num-checks              852
;  :propagations            32481015
;  :quant-instantiations    38471459
;  :restarts                24
;  :rlimit-count            879337244
;  :time                    0.03)
(assert (<
  j@733@04
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@735@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@732@04))))))
(pop) ; 17
; Joined path conditions
(assert (<
  j@733@04
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@735@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@732@04))))))
(pop) ; 16
(declare-fun inv@737@04 ($Ref) Int)
(declare-fun inv@738@04 ($Ref) Int)
; Nested auxiliary terms: globals
(assert ($Perm.isReadVar $k@734@04 $Perm.Write))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (ite
          (and (< (inv@262@04 r) V@15@04) (<= 0 (inv@262@04 r)))
          $k@261@04
          $Perm.No)
        (pTaken@319@04 r)))
    (=
      ($FVF.lookup_option$array$ (as sm@735@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@259@04))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@735@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@259@04))))) r))
  :qid |qp.fvfValDef586|)))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (ite
          (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
          $k@20@04
          $Perm.No)
        (pTaken@234@04 r)))
    (=
      ($FVF.lookup_option$array$ (as sm@735@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@735@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r))
  :qid |qp.fvfValDef587|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@296@04 r) V@15@04) (<= 0 (inv@296@04 r)))
      (< $Perm.No $k@295@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@735@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@735@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r))
  :qid |qp.fvfValDef588|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@259@04))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r) r))
  :pattern (($FVF.lookup_option$array$ (as sm@735@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef589|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@736@04  $FPM) r)
    (+
      (+
        (-
          (ite
            (and (< (inv@262@04 r) V@15@04) (<= 0 (inv@262@04 r)))
            $k@261@04
            $Perm.No)
          (pTaken@319@04 r))
        (-
          (ite
            (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
            $k@20@04
            $Perm.No)
          (pTaken@234@04 r)))
      (ite
        (and (< (inv@296@04 r) V@15@04) (<= 0 (inv@296@04 r)))
        $k@295@04
        $Perm.No)))
  :pattern (($FVF.perm_option$array$ (as pm@736@04  $FPM) r))
  :qid |qp.resPrmSumDef590|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@735@04  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@259@04))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@736@04  $FPM) r))
  :qid |qp.resTrgDef591|)))
; Nested auxiliary terms: non-globals
(assert (forall ((i1@732@04 Int) (j@733@04 Int)) (!
  (and
    (< i1@732@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@735@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@732@04)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@732@04))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@735@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@732@04))
        (as None<option<array>>  option<array>)))
    (<
      j@733@04
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@735@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@732@04))))))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@735@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@732@04))) j@733@04))
  :qid |int-aux|)))
(push) ; 16
(assert (not (forall ((i1@732@04 Int) (j@733@04 Int)) (!
  (implies
    (and
      (and (and (< j@733@04 V@15@04) (<= 0 j@733@04)) (< i1@732@04 V@15@04))
      (<= 0 i1@732@04))
    (or (= $k@734@04 $Perm.No) (< $Perm.No $k@734@04)))
  
  ))))
(check-sat)
; unsat
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               45488451
;  :arith-add-rows          9085466
;  :arith-assert-diseq      330461
;  :arith-assert-lower      8140086
;  :arith-assert-upper      7076015
;  :arith-bound-prop        189768
;  :arith-conflicts         4747
;  :arith-eq-adapter        2923430
;  :arith-fixed-eqs         7556627
;  :arith-offset-eqs        5154659
;  :arith-pivots            1261923
;  :conflicts               10841
;  :datatype-accessor-ax    5424
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1966968
;  :del-clause              111660562
;  :final-checks            5
;  :max-generation          15
;  :max-memory              590.26
;  :memory                  544.00
;  :minimized-lits          1710
;  :mk-bool-var             94934512
;  :mk-clause               111662201
;  :num-allocs              225235759
;  :num-checks              853
;  :propagations            32481016
;  :quant-instantiations    38471459
;  :restarts                24
;  :rlimit-count            879342633)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 16
(assert (not (forall ((i11@732@04 Int) (j1@733@04 Int) (i12@732@04 Int) (j2@733@04 Int)) (!
  (implies
    (and
      (and
        (and
          (and
            (and
              (and (< j1@733@04 V@15@04) (<= 0 j1@733@04))
              (< i11@732@04 V@15@04))
            (<= 0 i11@732@04))
          ($FVF.loc_int ($FVF.lookup_int (as sm@698@04  $FVF<Int>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@735@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i11@732@04))) j1@733@04)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@735@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i11@732@04))) j1@733@04)))
        (< $Perm.No $k@734@04))
      (and
        (and
          (and
            (and
              (and (< j2@733@04 V@15@04) (<= 0 j2@733@04))
              (< i12@732@04 V@15@04))
            (<= 0 i12@732@04))
          ($FVF.loc_int ($FVF.lookup_int (as sm@698@04  $FVF<Int>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@735@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i12@732@04))) j2@733@04)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@735@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i12@732@04))) j2@733@04)))
        (< $Perm.No $k@734@04))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@735@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i11@732@04))) j1@733@04)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@735@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i12@732@04))) j2@733@04)))
    (and (= i11@732@04 i12@732@04) (= j1@733@04 j2@733@04)))
  
  :qid |int-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 16
; 0.04s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               45489475
;  :arith-add-rows          9086432
;  :arith-assert-diseq      330473
;  :arith-assert-lower      8140245
;  :arith-assert-upper      7076131
;  :arith-bound-prop        189852
;  :arith-conflicts         4749
;  :arith-eq-adapter        2923545
;  :arith-fixed-eqs         7556748
;  :arith-offset-eqs        5154761
;  :arith-pivots            1262070
;  :conflicts               10859
;  :datatype-accessor-ax    5424
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1967173
;  :del-clause              111668342
;  :final-checks            5
;  :max-generation          15
;  :max-memory              590.26
;  :memory                  544.00
;  :minimized-lits          1710
;  :mk-bool-var             94940657
;  :mk-clause               111669981
;  :num-allocs              225256424
;  :num-checks              854
;  :propagations            32482296
;  :quant-instantiations    38473161
;  :restarts                24
;  :rlimit-count            879444993
;  :time                    0.04)
; Definitional axioms for inverse functions
(assert (forall ((i1@732@04 Int) (j@733@04 Int)) (!
  (implies
    (and
      (and
        (and (and (< j@733@04 V@15@04) (<= 0 j@733@04)) (< i1@732@04 V@15@04))
        (<= 0 i1@732@04))
      (< $Perm.No $k@734@04))
    (and
      (=
        (inv@737@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@735@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@732@04))) j@733@04))
        i1@732@04)
      (=
        (inv@738@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@735@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@732@04))) j@733@04))
        j@733@04)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@735@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@732@04))) j@733@04))
  :qid |int-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and
          (and (< (inv@738@04 r) V@15@04) (<= 0 (inv@738@04 r)))
          (< (inv@737@04 r) V@15@04))
        (<= 0 (inv@737@04 r)))
      (< $Perm.No $k@734@04))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@735@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) (inv@737@04 r)))) (inv@738@04 r))
      r))
  :pattern ((inv@737@04 r))
  :pattern ((inv@738@04 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@738@04 r) V@15@04) (<= 0 (inv@738@04 r)))
        (< (inv@737@04 r) V@15@04))
      (<= 0 (inv@737@04 r)))
    ($FVF.loc_int ($FVF.lookup_int (as sm@698@04  $FVF<Int>) r) r))
  :pattern ((inv@737@04 r) (inv@738@04 r))
  )))
; Precomputing data for removing quantified permissions
(define-fun pTaken@739@04 ((r $Ref)) $Perm
  (ite
    (and
      (and
        (and (< (inv@738@04 r) V@15@04) (<= 0 (inv@738@04 r)))
        (< (inv@737@04 r) V@15@04))
      (<= 0 (inv@737@04 r)))
    ($Perm.min
      (ite
        (and (< (inv@308@04 r) V@15@04) (<= 0 (inv@308@04 r)))
        $Perm.Write
        $Perm.No)
      $k@734@04)
    $Perm.No))
(define-fun pTaken@740@04 ((r $Ref)) $Perm
  (ite
    (and
      (and
        (and (< (inv@738@04 r) V@15@04) (<= 0 (inv@738@04 r)))
        (< (inv@737@04 r) V@15@04))
      (<= 0 (inv@737@04 r)))
    ($Perm.min
      (ite
        (and
          (and
            (and (< (inv@305@04 r) V@15@04) (<= 0 (inv@305@04 r)))
            (< (inv@304@04 r) V@15@04))
          (<= 0 (inv@304@04 r)))
        $Perm.Write
        $Perm.No)
      (- $k@734@04 (pTaken@739@04 r)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Constrain original permissions $k@734@04
(assert (forall ((r $Ref)) (!
  (implies
    (not
      (=
        (ite
          (and (< (inv@308@04 r) V@15@04) (<= 0 (inv@308@04 r)))
          $Perm.Write
          $Perm.No)
        $Perm.No))
    (ite
      (and (< (inv@308@04 r) V@15@04) (<= 0 (inv@308@04 r)))
      (<
        (ite
          (and
            (and
              (and (< (inv@738@04 r) V@15@04) (<= 0 (inv@738@04 r)))
              (< (inv@737@04 r) V@15@04))
            (<= 0 (inv@737@04 r)))
          $k@734@04
          $Perm.No)
        $Perm.Write)
      (<
        (ite
          (and
            (and
              (and (< (inv@738@04 r) V@15@04) (<= 0 (inv@738@04 r)))
              (< (inv@737@04 r) V@15@04))
            (<= 0 (inv@737@04 r)))
          $k@734@04
          $Perm.No)
        $Perm.No)))
  :pattern ((inv@308@04 r))
  :pattern ((inv@738@04 r))
  :pattern ((inv@737@04 r))
  :qid |qp.srp592|)))
; Intermediate check if already taken enough permissions
(set-option :timeout 500)
(push) ; 16
(assert (not (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@738@04 r) V@15@04) (<= 0 (inv@738@04 r)))
        (< (inv@737@04 r) V@15@04))
      (<= 0 (inv@737@04 r)))
    (= (- $k@734@04 (pTaken@739@04 r)) $Perm.No))
  
  ))))
(check-sat)
; unknown
(pop) ; 16
; 0.51s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               45509167
;  :arith-add-rows          9098856
;  :arith-assert-diseq      330782
;  :arith-assert-lower      8143875
;  :arith-assert-upper      7078853
;  :arith-bound-prop        190515
;  :arith-conflicts         4762
;  :arith-eq-adapter        2926445
;  :arith-fixed-eqs         7559331
;  :arith-offset-eqs        5156216
;  :arith-pivots            1264453
;  :conflicts               10879
;  :datatype-accessor-ax    5428
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1968949
;  :del-clause              111783608
;  :final-checks            5
;  :max-generation          15
;  :max-memory              590.26
;  :memory                  544.05
;  :minimized-lits          1713
;  :mk-bool-var             95041810
;  :mk-clause               111785245
;  :num-allocs              225525557
;  :num-checks              856
;  :propagations            32506450
;  :quant-instantiations    38509427
;  :restarts                24
;  :rlimit-count            880622869
;  :time                    0.51)
; Constrain original permissions $k@734@04
(assert (forall ((r $Ref)) (!
  (implies
    (not
      (=
        (ite
          (and
            (and
              (and (< (inv@305@04 r) V@15@04) (<= 0 (inv@305@04 r)))
              (< (inv@304@04 r) V@15@04))
            (<= 0 (inv@304@04 r)))
          $Perm.Write
          $Perm.No)
        $Perm.No))
    (ite
      (and
        (and
          (and (< (inv@305@04 r) V@15@04) (<= 0 (inv@305@04 r)))
          (< (inv@304@04 r) V@15@04))
        (<= 0 (inv@304@04 r)))
      (<
        (ite
          (and
            (and
              (and (< (inv@738@04 r) V@15@04) (<= 0 (inv@738@04 r)))
              (< (inv@737@04 r) V@15@04))
            (<= 0 (inv@737@04 r)))
          $k@734@04
          $Perm.No)
        $Perm.Write)
      (<
        (ite
          (and
            (and
              (and (< (inv@738@04 r) V@15@04) (<= 0 (inv@738@04 r)))
              (< (inv@737@04 r) V@15@04))
            (<= 0 (inv@737@04 r)))
          $k@734@04
          $Perm.No)
        $Perm.No)))
  :pattern ((inv@305@04 r))
  :pattern ((inv@304@04 r))
  :pattern ((inv@738@04 r))
  :pattern ((inv@737@04 r))
  :qid |qp.srp593|)))
; Intermediate check if already taken enough permissions
(push) ; 16
(assert (not (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@738@04 r) V@15@04) (<= 0 (inv@738@04 r)))
        (< (inv@737@04 r) V@15@04))
      (<= 0 (inv@737@04 r)))
    (= (- (- $k@734@04 (pTaken@739@04 r)) (pTaken@740@04 r)) $Perm.No))
  
  ))))
(check-sat)
; unsat
(pop) ; 16
; 0.10s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               45511831
;  :arith-add-rows          9101812
;  :arith-assert-diseq      330846
;  :arith-assert-lower      8144297
;  :arith-assert-upper      7079165
;  :arith-bound-prop        190566
;  :arith-conflicts         4771
;  :arith-eq-adapter        2926742
;  :arith-fixed-eqs         7559644
;  :arith-offset-eqs        5156299
;  :arith-pivots            1264664
;  :conflicts               10895
;  :datatype-accessor-ax    5428
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               1969774
;  :del-clause              111810726
;  :final-checks            5
;  :max-generation          15
;  :max-memory              590.26
;  :memory                  544.15
;  :minimized-lits          1713
;  :mk-bool-var             95060938
;  :mk-clause               111812363
;  :num-allocs              225573841
;  :num-checks              857
;  :propagations            32510405
;  :quant-instantiations    38514199
;  :restarts                24
;  :rlimit-count            880811194
;  :time                    0.10)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@741@04 $FVF<Int>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (iff
    (Set_in r ($FVF.domain_int (as sm@741@04  $FVF<Int>)))
    (and
      (and
        (and
          (and (< (inv@738@04 r) V@15@04) (<= 0 (inv@738@04 r)))
          (< (inv@737@04 r) V@15@04))
        (<= 0 (inv@737@04 r)))
      (< $Perm.No $k@734@04)))
  :pattern ((Set_in r ($FVF.domain_int (as sm@741@04  $FVF<Int>))))
  :qid |qp.fvfDomDef597|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and
          (and
            (and (< (inv@738@04 r) V@15@04) (<= 0 (inv@738@04 r)))
            (< (inv@737@04 r) V@15@04))
          (<= 0 (inv@737@04 r)))
        (< $Perm.No $k@734@04))
      (and (< (inv@308@04 r) V@15@04) (<= 0 (inv@308@04 r))))
    (=
      ($FVF.lookup_int (as sm@741@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04)))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@741@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04)))))))))))) r))
  :qid |qp.fvfValDef594|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and
          (and
            (and (< (inv@738@04 r) V@15@04) (<= 0 (inv@738@04 r)))
            (< (inv@737@04 r) V@15@04))
          (<= 0 (inv@737@04 r)))
        (< $Perm.No $k@734@04))
      (and
        (and
          (and (< (inv@305@04 r) V@15@04) (<= 0 (inv@305@04 r)))
          (< (inv@304@04 r) V@15@04))
        (<= 0 (inv@304@04 r))))
    (=
      ($FVF.lookup_int (as sm@741@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@741@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04))))))))) r))
  :qid |qp.fvfValDef595|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04)))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@741@04  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef596|)))
(pop) ; 15
; Joined path conditions
(assert ($Perm.isReadVar $k@714@04 $Perm.Write))
(assert (forall ((i1@713@04 Int)) (!
  (implies
    (and (and (< i1@713@04 V@15@04) (<= 0 i1@713@04)) (< $Perm.No $k@714@04))
    (=
      (inv@715@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@713@04))
      i1@713@04))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@713@04))
  :qid |option$array$-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and (< (inv@715@04 r) V@15@04) (<= 0 (inv@715@04 r)))
      (< $Perm.No $k@714@04))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) (inv@715@04 r))
      r))
  :pattern ((inv@715@04 r))
  :qid |option$array$-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (iff
    (Set_in r ($FVF.domain_option$array$ (as sm@719@04  $FVF<option<array>>)))
    (and
      (and (< (inv@715@04 r) V@15@04) (<= 0 (inv@715@04 r)))
      (< $Perm.No $k@714@04)))
  :pattern ((Set_in r ($FVF.domain_option$array$ (as sm@719@04  $FVF<option<array>>))))
  :qid |qp.fvfDomDef561|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@715@04 r) V@15@04) (<= 0 (inv@715@04 r)))
        (< $Perm.No $k@714@04))
      (<
        $Perm.No
        (-
          (ite
            (and (< (inv@262@04 r) V@15@04) (<= 0 (inv@262@04 r)))
            $k@261@04
            $Perm.No)
          (pTaken@319@04 r))))
    (=
      ($FVF.lookup_option$array$ (as sm@719@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@259@04))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@719@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@259@04))))) r))
  :qid |qp.fvfValDef557|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@715@04 r) V@15@04) (<= 0 (inv@715@04 r)))
        (< $Perm.No $k@714@04))
      (<
        $Perm.No
        (-
          (ite
            (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
            $k@20@04
            $Perm.No)
          (pTaken@234@04 r))))
    (=
      ($FVF.lookup_option$array$ (as sm@719@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@719@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r))
  :qid |qp.fvfValDef558|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@715@04 r) V@15@04) (<= 0 (inv@715@04 r)))
        (< $Perm.No $k@714@04))
      (ite
        (and (< (inv@296@04 r) V@15@04) (<= 0 (inv@296@04 r)))
        (< $Perm.No $k@295@04)
        false))
    (=
      ($FVF.lookup_option$array$ (as sm@719@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@719@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r))
  :qid |qp.fvfValDef559|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@259@04))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r) r))
  :pattern (($FVF.lookup_option$array$ (as sm@719@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef560|)))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (ite
          (and (< (inv@262@04 r) V@15@04) (<= 0 (inv@262@04 r)))
          $k@261@04
          $Perm.No)
        (pTaken@319@04 r)))
    (=
      ($FVF.lookup_option$array$ (as sm@721@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@259@04))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@721@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@259@04))))) r))
  :qid |qp.fvfValDef562|)))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (ite
          (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
          $k@20@04
          $Perm.No)
        (pTaken@234@04 r)))
    (=
      ($FVF.lookup_option$array$ (as sm@721@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@721@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r))
  :qid |qp.fvfValDef563|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@296@04 r) V@15@04) (<= 0 (inv@296@04 r)))
      (< $Perm.No $k@295@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@721@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@721@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r))
  :qid |qp.fvfValDef564|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@259@04))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r) r))
  :pattern (($FVF.lookup_option$array$ (as sm@721@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef565|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@722@04  $FPM) r)
    (+
      (+
        (-
          (ite
            (and (< (inv@262@04 r) V@15@04) (<= 0 (inv@262@04 r)))
            $k@261@04
            $Perm.No)
          (pTaken@319@04 r))
        (-
          (ite
            (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
            $k@20@04
            $Perm.No)
          (pTaken@234@04 r)))
      (ite
        (and (< (inv@296@04 r) V@15@04) (<= 0 (inv@296@04 r)))
        $k@295@04
        $Perm.No)))
  :pattern (($FVF.perm_option$array$ (as pm@722@04  $FPM) r))
  :qid |qp.resPrmSumDef566|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@721@04  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@259@04))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@722@04  $FPM) r))
  :qid |qp.resTrgDef567|)))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (ite
          (and (< (inv@262@04 r) V@15@04) (<= 0 (inv@262@04 r)))
          $k@261@04
          $Perm.No)
        (pTaken@319@04 r)))
    (=
      ($FVF.lookup_option$array$ (as sm@724@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@259@04))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@724@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@259@04))))) r))
  :qid |qp.fvfValDef568|)))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (ite
          (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
          $k@20@04
          $Perm.No)
        (pTaken@234@04 r)))
    (=
      ($FVF.lookup_option$array$ (as sm@724@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@724@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r))
  :qid |qp.fvfValDef569|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@296@04 r) V@15@04) (<= 0 (inv@296@04 r)))
      (< $Perm.No $k@295@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@724@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@724@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r))
  :qid |qp.fvfValDef570|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@259@04))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r) r))
  :pattern (($FVF.lookup_option$array$ (as sm@724@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef571|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@725@04  $FPM) r)
    (+
      (+
        (-
          (ite
            (and (< (inv@262@04 r) V@15@04) (<= 0 (inv@262@04 r)))
            $k@261@04
            $Perm.No)
          (pTaken@319@04 r))
        (-
          (ite
            (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
            $k@20@04
            $Perm.No)
          (pTaken@234@04 r)))
      (ite
        (and (< (inv@296@04 r) V@15@04) (<= 0 (inv@296@04 r)))
        $k@295@04
        $Perm.No)))
  :pattern (($FVF.perm_option$array$ (as pm@725@04  $FPM) r))
  :qid |qp.resPrmSumDef572|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@724@04  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@259@04))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@725@04  $FPM) r))
  :qid |qp.resTrgDef573|)))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (ite
          (and (< (inv@262@04 r) V@15@04) (<= 0 (inv@262@04 r)))
          $k@261@04
          $Perm.No)
        (pTaken@319@04 r)))
    (=
      ($FVF.lookup_option$array$ (as sm@728@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@259@04))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@728@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@259@04))))) r))
  :qid |qp.fvfValDef574|)))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (ite
          (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
          $k@20@04
          $Perm.No)
        (pTaken@234@04 r)))
    (=
      ($FVF.lookup_option$array$ (as sm@728@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@728@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r))
  :qid |qp.fvfValDef575|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@296@04 r) V@15@04) (<= 0 (inv@296@04 r)))
      (< $Perm.No $k@295@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@728@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@728@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r))
  :qid |qp.fvfValDef576|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@259@04))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r) r))
  :pattern (($FVF.lookup_option$array$ (as sm@728@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef577|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@729@04  $FPM) r)
    (+
      (+
        (-
          (ite
            (and (< (inv@262@04 r) V@15@04) (<= 0 (inv@262@04 r)))
            $k@261@04
            $Perm.No)
          (pTaken@319@04 r))
        (-
          (ite
            (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
            $k@20@04
            $Perm.No)
          (pTaken@234@04 r)))
      (ite
        (and (< (inv@296@04 r) V@15@04) (<= 0 (inv@296@04 r)))
        $k@295@04
        $Perm.No)))
  :pattern (($FVF.perm_option$array$ (as pm@729@04  $FPM) r))
  :qid |qp.resPrmSumDef578|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@728@04  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@259@04))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@729@04  $FPM) r))
  :qid |qp.resTrgDef579|)))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (ite
          (and (< (inv@262@04 r) V@15@04) (<= 0 (inv@262@04 r)))
          $k@261@04
          $Perm.No)
        (pTaken@319@04 r)))
    (=
      ($FVF.lookup_option$array$ (as sm@730@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@259@04))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@730@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@259@04))))) r))
  :qid |qp.fvfValDef580|)))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (ite
          (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
          $k@20@04
          $Perm.No)
        (pTaken@234@04 r)))
    (=
      ($FVF.lookup_option$array$ (as sm@730@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@730@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r))
  :qid |qp.fvfValDef581|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@296@04 r) V@15@04) (<= 0 (inv@296@04 r)))
      (< $Perm.No $k@295@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@730@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@730@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r))
  :qid |qp.fvfValDef582|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@259@04))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r) r))
  :pattern (($FVF.lookup_option$array$ (as sm@730@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef583|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@731@04  $FPM) r)
    (+
      (+
        (-
          (ite
            (and (< (inv@262@04 r) V@15@04) (<= 0 (inv@262@04 r)))
            $k@261@04
            $Perm.No)
          (pTaken@319@04 r))
        (-
          (ite
            (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
            $k@20@04
            $Perm.No)
          (pTaken@234@04 r)))
      (ite
        (and (< (inv@296@04 r) V@15@04) (<= 0 (inv@296@04 r)))
        $k@295@04
        $Perm.No)))
  :pattern (($FVF.perm_option$array$ (as pm@731@04  $FPM) r))
  :qid |qp.resPrmSumDef584|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@730@04  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@259@04))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@731@04  $FPM) r))
  :qid |qp.resTrgDef585|)))
(assert ($Perm.isReadVar $k@734@04 $Perm.Write))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (ite
          (and (< (inv@262@04 r) V@15@04) (<= 0 (inv@262@04 r)))
          $k@261@04
          $Perm.No)
        (pTaken@319@04 r)))
    (=
      ($FVF.lookup_option$array$ (as sm@735@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@259@04))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@735@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@259@04))))) r))
  :qid |qp.fvfValDef586|)))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (ite
          (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
          $k@20@04
          $Perm.No)
        (pTaken@234@04 r)))
    (=
      ($FVF.lookup_option$array$ (as sm@735@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@735@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r))
  :qid |qp.fvfValDef587|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@296@04 r) V@15@04) (<= 0 (inv@296@04 r)))
      (< $Perm.No $k@295@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@735@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@735@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r))
  :qid |qp.fvfValDef588|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@259@04))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r) r))
  :pattern (($FVF.lookup_option$array$ (as sm@735@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef589|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@736@04  $FPM) r)
    (+
      (+
        (-
          (ite
            (and (< (inv@262@04 r) V@15@04) (<= 0 (inv@262@04 r)))
            $k@261@04
            $Perm.No)
          (pTaken@319@04 r))
        (-
          (ite
            (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
            $k@20@04
            $Perm.No)
          (pTaken@234@04 r)))
      (ite
        (and (< (inv@296@04 r) V@15@04) (<= 0 (inv@296@04 r)))
        $k@295@04
        $Perm.No)))
  :pattern (($FVF.perm_option$array$ (as pm@736@04  $FPM) r))
  :qid |qp.resPrmSumDef590|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@735@04  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@259@04))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@736@04  $FPM) r))
  :qid |qp.resTrgDef591|)))
(assert (forall ((i1@732@04 Int) (j@733@04 Int)) (!
  (implies
    (and
      (and
        (and (and (< j@733@04 V@15@04) (<= 0 j@733@04)) (< i1@732@04 V@15@04))
        (<= 0 i1@732@04))
      (< $Perm.No $k@734@04))
    (and
      (=
        (inv@737@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@735@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@732@04))) j@733@04))
        i1@732@04)
      (=
        (inv@738@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@735@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@732@04))) j@733@04))
        j@733@04)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@735@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@732@04))) j@733@04))
  :qid |int-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and
          (and (< (inv@738@04 r) V@15@04) (<= 0 (inv@738@04 r)))
          (< (inv@737@04 r) V@15@04))
        (<= 0 (inv@737@04 r)))
      (< $Perm.No $k@734@04))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@735@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) (inv@737@04 r)))) (inv@738@04 r))
      r))
  :pattern ((inv@737@04 r))
  :pattern ((inv@738@04 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (iff
    (Set_in r ($FVF.domain_int (as sm@741@04  $FVF<Int>)))
    (and
      (and
        (and
          (and (< (inv@738@04 r) V@15@04) (<= 0 (inv@738@04 r)))
          (< (inv@737@04 r) V@15@04))
        (<= 0 (inv@737@04 r)))
      (< $Perm.No $k@734@04)))
  :pattern ((Set_in r ($FVF.domain_int (as sm@741@04  $FVF<Int>))))
  :qid |qp.fvfDomDef597|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and
          (and
            (and (< (inv@738@04 r) V@15@04) (<= 0 (inv@738@04 r)))
            (< (inv@737@04 r) V@15@04))
          (<= 0 (inv@737@04 r)))
        (< $Perm.No $k@734@04))
      (and (< (inv@308@04 r) V@15@04) (<= 0 (inv@308@04 r))))
    (=
      ($FVF.lookup_int (as sm@741@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04)))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@741@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04)))))))))))) r))
  :qid |qp.fvfValDef594|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and
          (and
            (and (< (inv@738@04 r) V@15@04) (<= 0 (inv@738@04 r)))
            (< (inv@737@04 r) V@15@04))
          (<= 0 (inv@737@04 r)))
        (< $Perm.No $k@734@04))
      (and
        (and
          (and (< (inv@305@04 r) V@15@04) (<= 0 (inv@305@04 r)))
          (< (inv@304@04 r) V@15@04))
        (<= 0 (inv@304@04 r))))
    (=
      ($FVF.lookup_int (as sm@741@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@741@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04))))))))) r))
  :qid |qp.fvfValDef595|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04)))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@741@04  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef596|)))
(assert (and
  (forall ((i1@713@04 Int)) (!
    (< i1@713@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
    :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@713@04))
    :qid |option$array$-aux|))
  (forall ((r $Ref)) (!
    (implies
      (and (< (inv@715@04 r) V@15@04) (<= 0 (inv@715@04 r)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@686@04  $FVF<option<array>>) r) r))
    :pattern ((inv@715@04 r))
    ))
  (forall ((r $Ref)) (!
    (implies
      (not
        (=
          (-
            (ite
              (and (< (inv@262@04 r) V@15@04) (<= 0 (inv@262@04 r)))
              $k@261@04
              $Perm.No)
            (pTaken@319@04 r))
          $Perm.No))
      (<
        (ite
          (and (< (inv@715@04 r) V@15@04) (<= 0 (inv@715@04 r)))
          $k@714@04
          $Perm.No)
        (-
          (ite
            (and (< (inv@262@04 r) V@15@04) (<= 0 (inv@262@04 r)))
            $k@261@04
            $Perm.No)
          (pTaken@319@04 r))))
    :pattern ((inv@262@04 r))
    :pattern ((inv@715@04 r))
    :qid |qp.srp556|))
  (forall ((i1@720@04 Int)) (!
    (implies
      (and (< i1@720@04 V@15@04) (<= 0 i1@720@04))
      (not
        (=
          ($FVF.lookup_option$array$ (as sm@721@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@720@04))
          (as None<option<array>>  option<array>))))
    
    :qid |prog.l<no position>|))
  (forall ((i1@723@04 Int)) (!
    (implies
      (and (< i1@723@04 V@15@04) (<= 0 i1@723@04))
      (=
        (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@724@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@723@04))))
        V@15@04))
    
    :qid |prog.l<no position>|))
  (forall ((i1@726@04 Int)) (!
    (forall ((i2@727@04 Int)) (!
      (implies
        (and
          (and
            (and
              (and
                (=
                  ($FVF.lookup_option$array$ (as sm@728@04  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@726@04))
                  ($FVF.lookup_option$array$ (as sm@730@04  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@727@04)))
                (< i2@727@04 V@15@04))
              (<= 0 i2@727@04))
            (< i1@726@04 V@15@04))
          (<= 0 i1@726@04))
        (= i1@726@04 i2@727@04))
      :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@727@04))
      :qid |prog.l<no position>|))
    
    :qid |prog.l<no position>|))
  (forall ((i1@732@04 Int) (j@733@04 Int)) (!
    (and
      (< i1@732@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@735@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@732@04)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@732@04))
      (not
        (=
          ($FVF.lookup_option$array$ (as sm@735@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@732@04))
          (as None<option<array>>  option<array>)))
      (<
        j@733@04
        (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@735@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@732@04))))))
    :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@735@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@732@04))) j@733@04))
    :qid |int-aux|))
  (forall ((r $Ref)) (!
    (implies
      (and
        (and
          (and (< (inv@738@04 r) V@15@04) (<= 0 (inv@738@04 r)))
          (< (inv@737@04 r) V@15@04))
        (<= 0 (inv@737@04 r)))
      ($FVF.loc_int ($FVF.lookup_int (as sm@698@04  $FVF<Int>) r) r))
    :pattern ((inv@737@04 r) (inv@738@04 r))
    ))
  (forall ((r $Ref)) (!
    (implies
      (not
        (=
          (ite
            (and (< (inv@308@04 r) V@15@04) (<= 0 (inv@308@04 r)))
            $Perm.Write
            $Perm.No)
          $Perm.No))
      (ite
        (and (< (inv@308@04 r) V@15@04) (<= 0 (inv@308@04 r)))
        (<
          (ite
            (and
              (and
                (and (< (inv@738@04 r) V@15@04) (<= 0 (inv@738@04 r)))
                (< (inv@737@04 r) V@15@04))
              (<= 0 (inv@737@04 r)))
            $k@734@04
            $Perm.No)
          $Perm.Write)
        (<
          (ite
            (and
              (and
                (and (< (inv@738@04 r) V@15@04) (<= 0 (inv@738@04 r)))
                (< (inv@737@04 r) V@15@04))
              (<= 0 (inv@737@04 r)))
            $k@734@04
            $Perm.No)
          $Perm.No)))
    :pattern ((inv@308@04 r))
    :pattern ((inv@738@04 r))
    :pattern ((inv@737@04 r))
    :qid |qp.srp592|))
  (forall ((r $Ref)) (!
    (implies
      (not
        (=
          (ite
            (and
              (and
                (and (< (inv@305@04 r) V@15@04) (<= 0 (inv@305@04 r)))
                (< (inv@304@04 r) V@15@04))
              (<= 0 (inv@304@04 r)))
            $Perm.Write
            $Perm.No)
          $Perm.No))
      (ite
        (and
          (and
            (and (< (inv@305@04 r) V@15@04) (<= 0 (inv@305@04 r)))
            (< (inv@304@04 r) V@15@04))
          (<= 0 (inv@304@04 r)))
        (<
          (ite
            (and
              (and
                (and (< (inv@738@04 r) V@15@04) (<= 0 (inv@738@04 r)))
                (< (inv@737@04 r) V@15@04))
              (<= 0 (inv@737@04 r)))
            $k@734@04
            $Perm.No)
          $Perm.Write)
        (<
          (ite
            (and
              (and
                (and (< (inv@738@04 r) V@15@04) (<= 0 (inv@738@04 r)))
                (< (inv@737@04 r) V@15@04))
              (<= 0 (inv@737@04 r)))
            $k@734@04
            $Perm.No)
          $Perm.No)))
    :pattern ((inv@305@04 r))
    :pattern ((inv@304@04 r))
    :pattern ((inv@738@04 r))
    :pattern ((inv@737@04 r))
    :qid |qp.srp593|))))
(pop) ; 14
(pop) ; 13
; Joined path conditions
(assert ($Perm.isReadVar $k@714@04 $Perm.Write))
(assert (forall ((i1@713@04 Int)) (!
  (implies
    (and (and (< i1@713@04 V@15@04) (<= 0 i1@713@04)) (< $Perm.No $k@714@04))
    (=
      (inv@715@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@713@04))
      i1@713@04))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@713@04))
  :qid |option$array$-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and (< (inv@715@04 r) V@15@04) (<= 0 (inv@715@04 r)))
      (< $Perm.No $k@714@04))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) (inv@715@04 r))
      r))
  :pattern ((inv@715@04 r))
  :qid |option$array$-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (iff
    (Set_in r ($FVF.domain_option$array$ (as sm@719@04  $FVF<option<array>>)))
    (and
      (and (< (inv@715@04 r) V@15@04) (<= 0 (inv@715@04 r)))
      (< $Perm.No $k@714@04)))
  :pattern ((Set_in r ($FVF.domain_option$array$ (as sm@719@04  $FVF<option<array>>))))
  :qid |qp.fvfDomDef561|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@715@04 r) V@15@04) (<= 0 (inv@715@04 r)))
        (< $Perm.No $k@714@04))
      (<
        $Perm.No
        (-
          (ite
            (and (< (inv@262@04 r) V@15@04) (<= 0 (inv@262@04 r)))
            $k@261@04
            $Perm.No)
          (pTaken@319@04 r))))
    (=
      ($FVF.lookup_option$array$ (as sm@719@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@259@04))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@719@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@259@04))))) r))
  :qid |qp.fvfValDef557|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@715@04 r) V@15@04) (<= 0 (inv@715@04 r)))
        (< $Perm.No $k@714@04))
      (<
        $Perm.No
        (-
          (ite
            (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
            $k@20@04
            $Perm.No)
          (pTaken@234@04 r))))
    (=
      ($FVF.lookup_option$array$ (as sm@719@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@719@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r))
  :qid |qp.fvfValDef558|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@715@04 r) V@15@04) (<= 0 (inv@715@04 r)))
        (< $Perm.No $k@714@04))
      (ite
        (and (< (inv@296@04 r) V@15@04) (<= 0 (inv@296@04 r)))
        (< $Perm.No $k@295@04)
        false))
    (=
      ($FVF.lookup_option$array$ (as sm@719@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@719@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r))
  :qid |qp.fvfValDef559|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@259@04))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r) r))
  :pattern (($FVF.lookup_option$array$ (as sm@719@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef560|)))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (ite
          (and (< (inv@262@04 r) V@15@04) (<= 0 (inv@262@04 r)))
          $k@261@04
          $Perm.No)
        (pTaken@319@04 r)))
    (=
      ($FVF.lookup_option$array$ (as sm@721@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@259@04))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@721@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@259@04))))) r))
  :qid |qp.fvfValDef562|)))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (ite
          (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
          $k@20@04
          $Perm.No)
        (pTaken@234@04 r)))
    (=
      ($FVF.lookup_option$array$ (as sm@721@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@721@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r))
  :qid |qp.fvfValDef563|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@296@04 r) V@15@04) (<= 0 (inv@296@04 r)))
      (< $Perm.No $k@295@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@721@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@721@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r))
  :qid |qp.fvfValDef564|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@259@04))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r) r))
  :pattern (($FVF.lookup_option$array$ (as sm@721@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef565|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@722@04  $FPM) r)
    (+
      (+
        (-
          (ite
            (and (< (inv@262@04 r) V@15@04) (<= 0 (inv@262@04 r)))
            $k@261@04
            $Perm.No)
          (pTaken@319@04 r))
        (-
          (ite
            (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
            $k@20@04
            $Perm.No)
          (pTaken@234@04 r)))
      (ite
        (and (< (inv@296@04 r) V@15@04) (<= 0 (inv@296@04 r)))
        $k@295@04
        $Perm.No)))
  :pattern (($FVF.perm_option$array$ (as pm@722@04  $FPM) r))
  :qid |qp.resPrmSumDef566|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@721@04  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@259@04))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@722@04  $FPM) r))
  :qid |qp.resTrgDef567|)))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (ite
          (and (< (inv@262@04 r) V@15@04) (<= 0 (inv@262@04 r)))
          $k@261@04
          $Perm.No)
        (pTaken@319@04 r)))
    (=
      ($FVF.lookup_option$array$ (as sm@724@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@259@04))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@724@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@259@04))))) r))
  :qid |qp.fvfValDef568|)))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (ite
          (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
          $k@20@04
          $Perm.No)
        (pTaken@234@04 r)))
    (=
      ($FVF.lookup_option$array$ (as sm@724@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@724@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r))
  :qid |qp.fvfValDef569|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@296@04 r) V@15@04) (<= 0 (inv@296@04 r)))
      (< $Perm.No $k@295@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@724@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@724@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r))
  :qid |qp.fvfValDef570|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@259@04))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r) r))
  :pattern (($FVF.lookup_option$array$ (as sm@724@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef571|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@725@04  $FPM) r)
    (+
      (+
        (-
          (ite
            (and (< (inv@262@04 r) V@15@04) (<= 0 (inv@262@04 r)))
            $k@261@04
            $Perm.No)
          (pTaken@319@04 r))
        (-
          (ite
            (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
            $k@20@04
            $Perm.No)
          (pTaken@234@04 r)))
      (ite
        (and (< (inv@296@04 r) V@15@04) (<= 0 (inv@296@04 r)))
        $k@295@04
        $Perm.No)))
  :pattern (($FVF.perm_option$array$ (as pm@725@04  $FPM) r))
  :qid |qp.resPrmSumDef572|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@724@04  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@259@04))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@725@04  $FPM) r))
  :qid |qp.resTrgDef573|)))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (ite
          (and (< (inv@262@04 r) V@15@04) (<= 0 (inv@262@04 r)))
          $k@261@04
          $Perm.No)
        (pTaken@319@04 r)))
    (=
      ($FVF.lookup_option$array$ (as sm@728@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@259@04))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@728@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@259@04))))) r))
  :qid |qp.fvfValDef574|)))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (ite
          (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
          $k@20@04
          $Perm.No)
        (pTaken@234@04 r)))
    (=
      ($FVF.lookup_option$array$ (as sm@728@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@728@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r))
  :qid |qp.fvfValDef575|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@296@04 r) V@15@04) (<= 0 (inv@296@04 r)))
      (< $Perm.No $k@295@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@728@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@728@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r))
  :qid |qp.fvfValDef576|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@259@04))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r) r))
  :pattern (($FVF.lookup_option$array$ (as sm@728@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef577|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@729@04  $FPM) r)
    (+
      (+
        (-
          (ite
            (and (< (inv@262@04 r) V@15@04) (<= 0 (inv@262@04 r)))
            $k@261@04
            $Perm.No)
          (pTaken@319@04 r))
        (-
          (ite
            (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
            $k@20@04
            $Perm.No)
          (pTaken@234@04 r)))
      (ite
        (and (< (inv@296@04 r) V@15@04) (<= 0 (inv@296@04 r)))
        $k@295@04
        $Perm.No)))
  :pattern (($FVF.perm_option$array$ (as pm@729@04  $FPM) r))
  :qid |qp.resPrmSumDef578|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@728@04  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@259@04))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@729@04  $FPM) r))
  :qid |qp.resTrgDef579|)))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (ite
          (and (< (inv@262@04 r) V@15@04) (<= 0 (inv@262@04 r)))
          $k@261@04
          $Perm.No)
        (pTaken@319@04 r)))
    (=
      ($FVF.lookup_option$array$ (as sm@730@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@259@04))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@730@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@259@04))))) r))
  :qid |qp.fvfValDef580|)))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (ite
          (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
          $k@20@04
          $Perm.No)
        (pTaken@234@04 r)))
    (=
      ($FVF.lookup_option$array$ (as sm@730@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@730@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r))
  :qid |qp.fvfValDef581|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@296@04 r) V@15@04) (<= 0 (inv@296@04 r)))
      (< $Perm.No $k@295@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@730@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@730@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r))
  :qid |qp.fvfValDef582|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@259@04))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r) r))
  :pattern (($FVF.lookup_option$array$ (as sm@730@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef583|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@731@04  $FPM) r)
    (+
      (+
        (-
          (ite
            (and (< (inv@262@04 r) V@15@04) (<= 0 (inv@262@04 r)))
            $k@261@04
            $Perm.No)
          (pTaken@319@04 r))
        (-
          (ite
            (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
            $k@20@04
            $Perm.No)
          (pTaken@234@04 r)))
      (ite
        (and (< (inv@296@04 r) V@15@04) (<= 0 (inv@296@04 r)))
        $k@295@04
        $Perm.No)))
  :pattern (($FVF.perm_option$array$ (as pm@731@04  $FPM) r))
  :qid |qp.resPrmSumDef584|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@730@04  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@259@04))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@731@04  $FPM) r))
  :qid |qp.resTrgDef585|)))
(assert ($Perm.isReadVar $k@734@04 $Perm.Write))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (ite
          (and (< (inv@262@04 r) V@15@04) (<= 0 (inv@262@04 r)))
          $k@261@04
          $Perm.No)
        (pTaken@319@04 r)))
    (=
      ($FVF.lookup_option$array$ (as sm@735@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@259@04))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@735@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@259@04))))) r))
  :qid |qp.fvfValDef586|)))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (ite
          (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
          $k@20@04
          $Perm.No)
        (pTaken@234@04 r)))
    (=
      ($FVF.lookup_option$array$ (as sm@735@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@735@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r))
  :qid |qp.fvfValDef587|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@296@04 r) V@15@04) (<= 0 (inv@296@04 r)))
      (< $Perm.No $k@295@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@735@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@735@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r))
  :qid |qp.fvfValDef588|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@259@04))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r) r))
  :pattern (($FVF.lookup_option$array$ (as sm@735@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef589|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@736@04  $FPM) r)
    (+
      (+
        (-
          (ite
            (and (< (inv@262@04 r) V@15@04) (<= 0 (inv@262@04 r)))
            $k@261@04
            $Perm.No)
          (pTaken@319@04 r))
        (-
          (ite
            (and (< (inv@21@04 r) V@15@04) (<= 0 (inv@21@04 r)))
            $k@20@04
            $Perm.No)
          (pTaken@234@04 r)))
      (ite
        (and (< (inv@296@04 r) V@15@04) (<= 0 (inv@296@04 r)))
        $k@295@04
        $Perm.No)))
  :pattern (($FVF.perm_option$array$ (as pm@736@04  $FPM) r))
  :qid |qp.resPrmSumDef590|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@735@04  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@259@04))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@04))))))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@293@04))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@736@04  $FPM) r))
  :qid |qp.resTrgDef591|)))
(assert (forall ((i1@732@04 Int) (j@733@04 Int)) (!
  (implies
    (and
      (and
        (and (and (< j@733@04 V@15@04) (<= 0 j@733@04)) (< i1@732@04 V@15@04))
        (<= 0 i1@732@04))
      (< $Perm.No $k@734@04))
    (and
      (=
        (inv@737@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@735@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@732@04))) j@733@04))
        i1@732@04)
      (=
        (inv@738@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@735@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@732@04))) j@733@04))
        j@733@04)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@735@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@732@04))) j@733@04))
  :qid |int-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and
          (and (< (inv@738@04 r) V@15@04) (<= 0 (inv@738@04 r)))
          (< (inv@737@04 r) V@15@04))
        (<= 0 (inv@737@04 r)))
      (< $Perm.No $k@734@04))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@735@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) (inv@737@04 r)))) (inv@738@04 r))
      r))
  :pattern ((inv@737@04 r))
  :pattern ((inv@738@04 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (iff
    (Set_in r ($FVF.domain_int (as sm@741@04  $FVF<Int>)))
    (and
      (and
        (and
          (and (< (inv@738@04 r) V@15@04) (<= 0 (inv@738@04 r)))
          (< (inv@737@04 r) V@15@04))
        (<= 0 (inv@737@04 r)))
      (< $Perm.No $k@734@04)))
  :pattern ((Set_in r ($FVF.domain_int (as sm@741@04  $FVF<Int>))))
  :qid |qp.fvfDomDef597|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and
          (and
            (and (< (inv@738@04 r) V@15@04) (<= 0 (inv@738@04 r)))
            (< (inv@737@04 r) V@15@04))
          (<= 0 (inv@737@04 r)))
        (< $Perm.No $k@734@04))
      (and (< (inv@308@04 r) V@15@04) (<= 0 (inv@308@04 r))))
    (=
      ($FVF.lookup_int (as sm@741@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04)))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@741@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04)))))))))))) r))
  :qid |qp.fvfValDef594|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and
          (and
            (and (< (inv@738@04 r) V@15@04) (<= 0 (inv@738@04 r)))
            (< (inv@737@04 r) V@15@04))
          (<= 0 (inv@737@04 r)))
        (< $Perm.No $k@734@04))
      (and
        (and
          (and (< (inv@305@04 r) V@15@04) (<= 0 (inv@305@04 r)))
          (< (inv@304@04 r) V@15@04))
        (<= 0 (inv@304@04 r))))
    (=
      ($FVF.lookup_int (as sm@741@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@741@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04))))))))) r))
  :qid |qp.fvfValDef595|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04)))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@293@04))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@741@04  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef596|)))
(assert (implies
  (= exc@291@04 $Ref.null)
  (and
    (forall ((i1@713@04 Int)) (!
      (< i1@713@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
      :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@713@04))
      :qid |option$array$-aux|))
    (forall ((r $Ref)) (!
      (implies
        (and (< (inv@715@04 r) V@15@04) (<= 0 (inv@715@04 r)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@686@04  $FVF<option<array>>) r) r))
      :pattern ((inv@715@04 r))
      ))
    (forall ((r $Ref)) (!
      (implies
        (not
          (=
            (-
              (ite
                (and (< (inv@262@04 r) V@15@04) (<= 0 (inv@262@04 r)))
                $k@261@04
                $Perm.No)
              (pTaken@319@04 r))
            $Perm.No))
        (<
          (ite
            (and (< (inv@715@04 r) V@15@04) (<= 0 (inv@715@04 r)))
            $k@714@04
            $Perm.No)
          (-
            (ite
              (and (< (inv@262@04 r) V@15@04) (<= 0 (inv@262@04 r)))
              $k@261@04
              $Perm.No)
            (pTaken@319@04 r))))
      :pattern ((inv@262@04 r))
      :pattern ((inv@715@04 r))
      :qid |qp.srp556|))
    (forall ((i1@720@04 Int)) (!
      (implies
        (and (< i1@720@04 V@15@04) (<= 0 i1@720@04))
        (not
          (=
            ($FVF.lookup_option$array$ (as sm@721@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@720@04))
            (as None<option<array>>  option<array>))))
      
      :qid |prog.l<no position>|))
    (forall ((i1@723@04 Int)) (!
      (implies
        (and (< i1@723@04 V@15@04) (<= 0 i1@723@04))
        (=
          (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@724@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@723@04))))
          V@15@04))
      
      :qid |prog.l<no position>|))
    (forall ((i1@726@04 Int)) (!
      (forall ((i2@727@04 Int)) (!
        (implies
          (and
            (and
              (and
                (and
                  (=
                    ($FVF.lookup_option$array$ (as sm@728@04  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@726@04))
                    ($FVF.lookup_option$array$ (as sm@730@04  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@727@04)))
                  (< i2@727@04 V@15@04))
                (<= 0 i2@727@04))
              (< i1@726@04 V@15@04))
            (<= 0 i1@726@04))
          (= i1@726@04 i2@727@04))
        :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@11@04) i2@727@04))
        :qid |prog.l<no position>|))
      
      :qid |prog.l<no position>|))
    (forall ((i1@732@04 Int) (j@733@04 Int)) (!
      (and
        (< i1@732@04 (alen<Int> (opt_get1 $Snap.unit G@11@04)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@735@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@732@04)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@732@04))
        (not
          (=
            ($FVF.lookup_option$array$ (as sm@735@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@732@04))
            (as None<option<array>>  option<array>)))
        (<
          j@733@04
          (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@735@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@732@04))))))
      :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@735@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@11@04) i1@732@04))) j@733@04))
      :qid |int-aux|))
    (forall ((r $Ref)) (!
      (implies
        (and
          (and
            (and (< (inv@738@04 r) V@15@04) (<= 0 (inv@738@04 r)))
            (< (inv@737@04 r) V@15@04))
          (<= 0 (inv@737@04 r)))
        ($FVF.loc_int ($FVF.lookup_int (as sm@698@04  $FVF<Int>) r) r))
      :pattern ((inv@737@04 r) (inv@738@04 r))
      ))
    (forall ((r $Ref)) (!
      (implies
        (not
          (=
            (ite
              (and (< (inv@308@04 r) V@15@04) (<= 0 (inv@308@04 r)))
              $Perm.Write
              $Perm.No)
            $Perm.No))
        (ite
          (and (< (inv@308@04 r) V@15@04) (<= 0 (inv@308@04 r)))
          (<
            (ite
              (and
                (and
                  (and (< (inv@738@04 r) V@15@04) (<= 0 (inv@738@04 r)))
                  (< (inv@737@04 r) V@15@04))
                (<= 0 (inv@737@04 r)))
              $k@734@04
              $Perm.No)
            $Perm.Write)
          (<
            (ite
              (and
                (and
                  (and (< (inv@738@04 r) V@15@04) (<= 0 (inv@738@04 r)))
                  (< (inv@737@04 r) V@15@04))
                (<= 0 (inv@737@04 r)))
              $k@734@04
              $Perm.No)
            $Perm.No)))
      :pattern ((inv@308@04 r))
      :pattern ((inv@738@04 r))
      :pattern ((inv@737@04 r))
      :qid |qp.srp592|))
    (forall ((r $Ref)) (!
      (implies
        (not
          (=
            (ite
              (and
                (and
                  (and (< (inv@305@04 r) V@15@04) (<= 0 (inv@305@04 r)))
                  (< (inv@304@04 r) V@15@04))
                (<= 0 (inv@304@04 r)))
              $Perm.Write
              $Perm.No)
            $Perm.No))
        (ite
          (and
            (and
              (and (< (inv@305@04 r) V@15@04) (<= 0 (inv@305@04 r)))
              (< (inv@304@04 r) V@15@04))
            (<= 0 (inv@304@04 r)))
          (<
            (ite
              (and
                (and
                  (and (< (inv@738@04 r) V@15@04) (<= 0 (inv@738@04 r)))
                  (< (inv@737@04 r) V@15@04))
                (<= 0 (inv@737@04 r)))
              $k@734@04
              $Perm.No)
            $Perm.Write)
          (<
            (ite
              (and
                (and
                  (and (< (inv@738@04 r) V@15@04) (<= 0 (inv@738@04 r)))
                  (< (inv@737@04 r) V@15@04))
                (<= 0 (inv@737@04 r)))
              $k@734@04
              $Perm.No)
            $Perm.No)))
      :pattern ((inv@305@04 r))
      :pattern ((inv@304@04 r))
      :pattern ((inv@738@04 r))
      :pattern ((inv@737@04 r))
      :qid |qp.srp593|)))))
(set-option :timeout 0)
(push) ; 13
(assert (not (implies
  (= exc@291@04 $Ref.null)
  (FlowNetwork1 ($Snap.combine
    $Snap.unit
    ($Snap.combine
      $Snap.unit
      ($Snap.combine
        $Snap.unit
        ($Snap.combine
          ($SortWrappers.$FVF<option<array>>To$Snap (as sm@719@04  $FVF<option<array>>))
          ($Snap.combine
            $Snap.unit
            ($Snap.combine
              $Snap.unit
              ($Snap.combine
                $Snap.unit
                ($SortWrappers.$FVF<Int>To$Snap (as sm@741@04  $FVF<Int>))))))))) this@9@04 G@11@04 V@15@04 s@12@04 t@13@04))))
(check-sat)
; unsat
(pop) ; 13
; 01m:32s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               48659737
;  :arith-add-rows          9812224
;  :arith-assert-diseq      352658
;  :arith-assert-lower      8674553
;  :arith-assert-upper      7539037
;  :arith-bound-prop        209760
;  :arith-conflicts         5064
;  :arith-eq-adapter        3232824
;  :arith-fixed-eqs         8075148
;  :arith-offset-eqs        5392764
;  :arith-pivots            1381889
;  :conflicts               11333
;  :datatype-accessor-ax    5486
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   10
;  :datatype-splits         8
;  :decisions               2056150
;  :del-clause              125648069
;  :final-checks            5
;  :max-generation          15
;  :max-memory              602.37
;  :memory                  588.08
;  :minimized-lits          1874
;  :mk-bool-var             105947099
;  :mk-clause               125649708
;  :num-allocs              248435475
;  :num-checks              858
;  :propagations            35848527
;  :quant-instantiations    42930069
;  :restarts                26
;  :rlimit-count            972011311
;  :time                    92.28)
(assert (implies
  (= exc@291@04 $Ref.null)
  (FlowNetwork1 ($Snap.combine
    $Snap.unit
    ($Snap.combine
      $Snap.unit
      ($Snap.combine
        $Snap.unit
        ($Snap.combine
          ($SortWrappers.$FVF<option<array>>To$Snap (as sm@719@04  $FVF<option<array>>))
          ($Snap.combine
            $Snap.unit
            ($Snap.combine
              $Snap.unit
              ($Snap.combine
                $Snap.unit
                ($SortWrappers.$FVF<Int>To$Snap (as sm@741@04  $FVF<Int>))))))))) this@9@04 G@11@04 V@15@04 s@12@04 t@13@04)))
(pop) ; 12
(pop) ; 11
(pop) ; 10
(pop) ; 9
(push) ; 9
; [else-branch: 361 | res1@292@04]
(assert res1@292@04)
(pop) ; 9
(pop) ; 8
(pop) ; 7
(pop) ; 6
(pop) ; 5
(pop) ; 4
(pop) ; 3
(pop) ; 2
(pop) ; 1
