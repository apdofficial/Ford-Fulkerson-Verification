(get-info :version)
; (:version "4.8.6")
; Started: 2022-06-16 09:19:35
; Silicon.version: 1.1-SNAPSHOT (cd20cf02@(detached))
; Input file: -
; Verifier id: 00
; ------------------------------------------------------------
; Begin preamble
; ////////// Static preamble
; 
; ; /z3config.smt2
(set-option :print-success true) ; Boogie: false
(set-option :global-decls true) ; Boogie: default
(set-option :auto_config false) ; Usually a good idea
(set-option :smt.restart_strategy 0)
(set-option :smt.restart_factor |1.5|)
(set-option :smt.case_split 3)
(set-option :smt.delay_units true)
(set-option :smt.delay_units_threshold 16)
(set-option :nnf.sk_hack true)
(set-option :type_check true)
(set-option :smt.bv.reflect true)
(set-option :smt.mbqi false)
(set-option :smt.qi.eager_threshold 100)
(set-option :smt.qi.cost "(+ weight generation)")
(set-option :smt.qi.max_multi_patterns 1000)
(set-option :smt.phase_selection 0) ; default: 3, Boogie: 0
(set-option :sat.phase caching)
(set-option :sat.random_seed 0)
(set-option :nlsat.randomize true)
(set-option :nlsat.seed 0)
(set-option :nlsat.shuffle_vars false)
(set-option :fp.spacer.order_children 0) ; Not available with Z3 4.5
(set-option :fp.spacer.random_seed 0) ; Not available with Z3 4.5
(set-option :smt.arith.random_initial_value true) ; Boogie: true
(set-option :smt.random_seed 0)
(set-option :sls.random_offset true)
(set-option :sls.random_seed 0)
(set-option :sls.restart_init false)
(set-option :sls.walksat_ucb true)
(set-option :model.v2 true)
; 
; ; /preamble.smt2
(declare-datatypes () ((
    $Snap ($Snap.unit)
    ($Snap.combine ($Snap.first $Snap) ($Snap.second $Snap)))))
(declare-sort $Ref 0)
(declare-const $Ref.null $Ref)
(declare-sort $FPM)
(declare-sort $PPM)
(define-sort $Perm () Real)
(define-const $Perm.Write $Perm 1.0)
(define-const $Perm.No $Perm 0.0)
(define-fun $Perm.isValidVar ((p $Perm)) Bool
	(<= $Perm.No p))
(define-fun $Perm.isReadVar ((p $Perm) (ub $Perm)) Bool
    (and ($Perm.isValidVar p)
         (not (= p $Perm.No))
         (< p $Perm.Write)))
(define-fun $Perm.min ((p1 $Perm) (p2 $Perm)) Real
    (ite (<= p1 p2) p1 p2))
(define-fun $Math.min ((a Int) (b Int)) Int
    (ite (<= a b) a b))
(define-fun $Math.clip ((a Int)) Int
    (ite (< a 0) 0 a))
; ////////// Sorts
(declare-sort Seq<Seq<Int>>)
(declare-sort Seq<Int>)
(declare-sort Set<Int>)
(declare-sort Set<Bool>)
(declare-sort Set<option<array>>)
(declare-sort Set<$Ref>)
(declare-sort Set<$Snap>)
(declare-sort t_null)
(declare-sort any)
(declare-sort void)
(declare-sort option<any>)
(declare-sort option<array>)
(declare-sort array)
(declare-sort $FVF<Int>)
(declare-sort $FVF<option<array>>)
(declare-sort $FVF<Bool>)
(declare-sort $FVF<$Ref>)
; ////////// Sort wrappers
; Declaring additional sort wrappers
(declare-fun $SortWrappers.IntTo$Snap (Int) $Snap)
(declare-fun $SortWrappers.$SnapToInt ($Snap) Int)
(assert (forall ((x Int)) (!
    (= x ($SortWrappers.$SnapToInt($SortWrappers.IntTo$Snap x)))
    :pattern (($SortWrappers.IntTo$Snap x))
    :qid |$Snap.$SnapToIntTo$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.IntTo$Snap($SortWrappers.$SnapToInt x)))
    :pattern (($SortWrappers.$SnapToInt x))
    :qid |$Snap.IntTo$SnapToInt|
    )))
(declare-fun $SortWrappers.BoolTo$Snap (Bool) $Snap)
(declare-fun $SortWrappers.$SnapToBool ($Snap) Bool)
(assert (forall ((x Bool)) (!
    (= x ($SortWrappers.$SnapToBool($SortWrappers.BoolTo$Snap x)))
    :pattern (($SortWrappers.BoolTo$Snap x))
    :qid |$Snap.$SnapToBoolTo$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.BoolTo$Snap($SortWrappers.$SnapToBool x)))
    :pattern (($SortWrappers.$SnapToBool x))
    :qid |$Snap.BoolTo$SnapToBool|
    )))
(declare-fun $SortWrappers.$RefTo$Snap ($Ref) $Snap)
(declare-fun $SortWrappers.$SnapTo$Ref ($Snap) $Ref)
(assert (forall ((x $Ref)) (!
    (= x ($SortWrappers.$SnapTo$Ref($SortWrappers.$RefTo$Snap x)))
    :pattern (($SortWrappers.$RefTo$Snap x))
    :qid |$Snap.$SnapTo$RefTo$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.$RefTo$Snap($SortWrappers.$SnapTo$Ref x)))
    :pattern (($SortWrappers.$SnapTo$Ref x))
    :qid |$Snap.$RefTo$SnapTo$Ref|
    )))
(declare-fun $SortWrappers.$PermTo$Snap ($Perm) $Snap)
(declare-fun $SortWrappers.$SnapTo$Perm ($Snap) $Perm)
(assert (forall ((x $Perm)) (!
    (= x ($SortWrappers.$SnapTo$Perm($SortWrappers.$PermTo$Snap x)))
    :pattern (($SortWrappers.$PermTo$Snap x))
    :qid |$Snap.$SnapTo$PermTo$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.$PermTo$Snap($SortWrappers.$SnapTo$Perm x)))
    :pattern (($SortWrappers.$SnapTo$Perm x))
    :qid |$Snap.$PermTo$SnapTo$Perm|
    )))
; Declaring additional sort wrappers
(declare-fun $SortWrappers.Seq<Seq<Int>>To$Snap (Seq<Seq<Int>>) $Snap)
(declare-fun $SortWrappers.$SnapToSeq<Seq<Int>> ($Snap) Seq<Seq<Int>>)
(assert (forall ((x Seq<Seq<Int>>)) (!
    (= x ($SortWrappers.$SnapToSeq<Seq<Int>>($SortWrappers.Seq<Seq<Int>>To$Snap x)))
    :pattern (($SortWrappers.Seq<Seq<Int>>To$Snap x))
    :qid |$Snap.$SnapToSeq<Seq<Int>>To$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.Seq<Seq<Int>>To$Snap($SortWrappers.$SnapToSeq<Seq<Int>> x)))
    :pattern (($SortWrappers.$SnapToSeq<Seq<Int>> x))
    :qid |$Snap.Seq<Seq<Int>>To$SnapToSeq<Seq<Int>>|
    )))
(declare-fun $SortWrappers.Seq<Int>To$Snap (Seq<Int>) $Snap)
(declare-fun $SortWrappers.$SnapToSeq<Int> ($Snap) Seq<Int>)
(assert (forall ((x Seq<Int>)) (!
    (= x ($SortWrappers.$SnapToSeq<Int>($SortWrappers.Seq<Int>To$Snap x)))
    :pattern (($SortWrappers.Seq<Int>To$Snap x))
    :qid |$Snap.$SnapToSeq<Int>To$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.Seq<Int>To$Snap($SortWrappers.$SnapToSeq<Int> x)))
    :pattern (($SortWrappers.$SnapToSeq<Int> x))
    :qid |$Snap.Seq<Int>To$SnapToSeq<Int>|
    )))
; Declaring additional sort wrappers
(declare-fun $SortWrappers.Set<Int>To$Snap (Set<Int>) $Snap)
(declare-fun $SortWrappers.$SnapToSet<Int> ($Snap) Set<Int>)
(assert (forall ((x Set<Int>)) (!
    (= x ($SortWrappers.$SnapToSet<Int>($SortWrappers.Set<Int>To$Snap x)))
    :pattern (($SortWrappers.Set<Int>To$Snap x))
    :qid |$Snap.$SnapToSet<Int>To$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.Set<Int>To$Snap($SortWrappers.$SnapToSet<Int> x)))
    :pattern (($SortWrappers.$SnapToSet<Int> x))
    :qid |$Snap.Set<Int>To$SnapToSet<Int>|
    )))
(declare-fun $SortWrappers.Set<Bool>To$Snap (Set<Bool>) $Snap)
(declare-fun $SortWrappers.$SnapToSet<Bool> ($Snap) Set<Bool>)
(assert (forall ((x Set<Bool>)) (!
    (= x ($SortWrappers.$SnapToSet<Bool>($SortWrappers.Set<Bool>To$Snap x)))
    :pattern (($SortWrappers.Set<Bool>To$Snap x))
    :qid |$Snap.$SnapToSet<Bool>To$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.Set<Bool>To$Snap($SortWrappers.$SnapToSet<Bool> x)))
    :pattern (($SortWrappers.$SnapToSet<Bool> x))
    :qid |$Snap.Set<Bool>To$SnapToSet<Bool>|
    )))
(declare-fun $SortWrappers.Set<option<array>>To$Snap (Set<option<array>>) $Snap)
(declare-fun $SortWrappers.$SnapToSet<option<array>> ($Snap) Set<option<array>>)
(assert (forall ((x Set<option<array>>)) (!
    (= x ($SortWrappers.$SnapToSet<option<array>>($SortWrappers.Set<option<array>>To$Snap x)))
    :pattern (($SortWrappers.Set<option<array>>To$Snap x))
    :qid |$Snap.$SnapToSet<option<array>>To$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.Set<option<array>>To$Snap($SortWrappers.$SnapToSet<option<array>> x)))
    :pattern (($SortWrappers.$SnapToSet<option<array>> x))
    :qid |$Snap.Set<option<array>>To$SnapToSet<option<array>>|
    )))
(declare-fun $SortWrappers.Set<$Ref>To$Snap (Set<$Ref>) $Snap)
(declare-fun $SortWrappers.$SnapToSet<$Ref> ($Snap) Set<$Ref>)
(assert (forall ((x Set<$Ref>)) (!
    (= x ($SortWrappers.$SnapToSet<$Ref>($SortWrappers.Set<$Ref>To$Snap x)))
    :pattern (($SortWrappers.Set<$Ref>To$Snap x))
    :qid |$Snap.$SnapToSet<$Ref>To$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.Set<$Ref>To$Snap($SortWrappers.$SnapToSet<$Ref> x)))
    :pattern (($SortWrappers.$SnapToSet<$Ref> x))
    :qid |$Snap.Set<$Ref>To$SnapToSet<$Ref>|
    )))
(declare-fun $SortWrappers.Set<$Snap>To$Snap (Set<$Snap>) $Snap)
(declare-fun $SortWrappers.$SnapToSet<$Snap> ($Snap) Set<$Snap>)
(assert (forall ((x Set<$Snap>)) (!
    (= x ($SortWrappers.$SnapToSet<$Snap>($SortWrappers.Set<$Snap>To$Snap x)))
    :pattern (($SortWrappers.Set<$Snap>To$Snap x))
    :qid |$Snap.$SnapToSet<$Snap>To$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.Set<$Snap>To$Snap($SortWrappers.$SnapToSet<$Snap> x)))
    :pattern (($SortWrappers.$SnapToSet<$Snap> x))
    :qid |$Snap.Set<$Snap>To$SnapToSet<$Snap>|
    )))
; Declaring additional sort wrappers
(declare-fun $SortWrappers.t_nullTo$Snap (t_null) $Snap)
(declare-fun $SortWrappers.$SnapTot_null ($Snap) t_null)
(assert (forall ((x t_null)) (!
    (= x ($SortWrappers.$SnapTot_null($SortWrappers.t_nullTo$Snap x)))
    :pattern (($SortWrappers.t_nullTo$Snap x))
    :qid |$Snap.$SnapTot_nullTo$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.t_nullTo$Snap($SortWrappers.$SnapTot_null x)))
    :pattern (($SortWrappers.$SnapTot_null x))
    :qid |$Snap.t_nullTo$SnapTot_null|
    )))
(declare-fun $SortWrappers.anyTo$Snap (any) $Snap)
(declare-fun $SortWrappers.$SnapToany ($Snap) any)
(assert (forall ((x any)) (!
    (= x ($SortWrappers.$SnapToany($SortWrappers.anyTo$Snap x)))
    :pattern (($SortWrappers.anyTo$Snap x))
    :qid |$Snap.$SnapToanyTo$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.anyTo$Snap($SortWrappers.$SnapToany x)))
    :pattern (($SortWrappers.$SnapToany x))
    :qid |$Snap.anyTo$SnapToany|
    )))
(declare-fun $SortWrappers.voidTo$Snap (void) $Snap)
(declare-fun $SortWrappers.$SnapTovoid ($Snap) void)
(assert (forall ((x void)) (!
    (= x ($SortWrappers.$SnapTovoid($SortWrappers.voidTo$Snap x)))
    :pattern (($SortWrappers.voidTo$Snap x))
    :qid |$Snap.$SnapTovoidTo$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.voidTo$Snap($SortWrappers.$SnapTovoid x)))
    :pattern (($SortWrappers.$SnapTovoid x))
    :qid |$Snap.voidTo$SnapTovoid|
    )))
(declare-fun $SortWrappers.option<any>To$Snap (option<any>) $Snap)
(declare-fun $SortWrappers.$SnapTooption<any> ($Snap) option<any>)
(assert (forall ((x option<any>)) (!
    (= x ($SortWrappers.$SnapTooption<any>($SortWrappers.option<any>To$Snap x)))
    :pattern (($SortWrappers.option<any>To$Snap x))
    :qid |$Snap.$SnapTooption<any>To$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.option<any>To$Snap($SortWrappers.$SnapTooption<any> x)))
    :pattern (($SortWrappers.$SnapTooption<any> x))
    :qid |$Snap.option<any>To$SnapTooption<any>|
    )))
(declare-fun $SortWrappers.option<array>To$Snap (option<array>) $Snap)
(declare-fun $SortWrappers.$SnapTooption<array> ($Snap) option<array>)
(assert (forall ((x option<array>)) (!
    (= x ($SortWrappers.$SnapTooption<array>($SortWrappers.option<array>To$Snap x)))
    :pattern (($SortWrappers.option<array>To$Snap x))
    :qid |$Snap.$SnapTooption<array>To$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.option<array>To$Snap($SortWrappers.$SnapTooption<array> x)))
    :pattern (($SortWrappers.$SnapTooption<array> x))
    :qid |$Snap.option<array>To$SnapTooption<array>|
    )))
(declare-fun $SortWrappers.arrayTo$Snap (array) $Snap)
(declare-fun $SortWrappers.$SnapToarray ($Snap) array)
(assert (forall ((x array)) (!
    (= x ($SortWrappers.$SnapToarray($SortWrappers.arrayTo$Snap x)))
    :pattern (($SortWrappers.arrayTo$Snap x))
    :qid |$Snap.$SnapToarrayTo$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.arrayTo$Snap($SortWrappers.$SnapToarray x)))
    :pattern (($SortWrappers.$SnapToarray x))
    :qid |$Snap.arrayTo$SnapToarray|
    )))
; Declaring additional sort wrappers
(declare-fun $SortWrappers.$FVF<Int>To$Snap ($FVF<Int>) $Snap)
(declare-fun $SortWrappers.$SnapTo$FVF<Int> ($Snap) $FVF<Int>)
(assert (forall ((x $FVF<Int>)) (!
    (= x ($SortWrappers.$SnapTo$FVF<Int>($SortWrappers.$FVF<Int>To$Snap x)))
    :pattern (($SortWrappers.$FVF<Int>To$Snap x))
    :qid |$Snap.$SnapTo$FVF<Int>To$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.$FVF<Int>To$Snap($SortWrappers.$SnapTo$FVF<Int> x)))
    :pattern (($SortWrappers.$SnapTo$FVF<Int> x))
    :qid |$Snap.$FVF<Int>To$SnapTo$FVF<Int>|
    )))
(declare-fun $SortWrappers.$FVF<option<array>>To$Snap ($FVF<option<array>>) $Snap)
(declare-fun $SortWrappers.$SnapTo$FVF<option<array>> ($Snap) $FVF<option<array>>)
(assert (forall ((x $FVF<option<array>>)) (!
    (= x ($SortWrappers.$SnapTo$FVF<option<array>>($SortWrappers.$FVF<option<array>>To$Snap x)))
    :pattern (($SortWrappers.$FVF<option<array>>To$Snap x))
    :qid |$Snap.$SnapTo$FVF<option<array>>To$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.$FVF<option<array>>To$Snap($SortWrappers.$SnapTo$FVF<option<array>> x)))
    :pattern (($SortWrappers.$SnapTo$FVF<option<array>> x))
    :qid |$Snap.$FVF<option<array>>To$SnapTo$FVF<option<array>>|
    )))
(declare-fun $SortWrappers.$FVF<Bool>To$Snap ($FVF<Bool>) $Snap)
(declare-fun $SortWrappers.$SnapTo$FVF<Bool> ($Snap) $FVF<Bool>)
(assert (forall ((x $FVF<Bool>)) (!
    (= x ($SortWrappers.$SnapTo$FVF<Bool>($SortWrappers.$FVF<Bool>To$Snap x)))
    :pattern (($SortWrappers.$FVF<Bool>To$Snap x))
    :qid |$Snap.$SnapTo$FVF<Bool>To$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.$FVF<Bool>To$Snap($SortWrappers.$SnapTo$FVF<Bool> x)))
    :pattern (($SortWrappers.$SnapTo$FVF<Bool> x))
    :qid |$Snap.$FVF<Bool>To$SnapTo$FVF<Bool>|
    )))
(declare-fun $SortWrappers.$FVF<$Ref>To$Snap ($FVF<$Ref>) $Snap)
(declare-fun $SortWrappers.$SnapTo$FVF<$Ref> ($Snap) $FVF<$Ref>)
(assert (forall ((x $FVF<$Ref>)) (!
    (= x ($SortWrappers.$SnapTo$FVF<$Ref>($SortWrappers.$FVF<$Ref>To$Snap x)))
    :pattern (($SortWrappers.$FVF<$Ref>To$Snap x))
    :qid |$Snap.$SnapTo$FVF<$Ref>To$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.$FVF<$Ref>To$Snap($SortWrappers.$SnapTo$FVF<$Ref> x)))
    :pattern (($SortWrappers.$SnapTo$FVF<$Ref> x))
    :qid |$Snap.$FVF<$Ref>To$SnapTo$FVF<$Ref>|
    )))
; ////////// Symbols
(declare-fun Set_in (Int Set<Int>) Bool)
(declare-fun Set_card (Set<Int>) Int)
(declare-const Set_empty Set<Int>)
(declare-fun Set_singleton (Int) Set<Int>)
(declare-fun Set_unionone (Set<Int> Int) Set<Int>)
(declare-fun Set_union (Set<Int> Set<Int>) Set<Int>)
(declare-fun Set_disjoint (Set<Int> Set<Int>) Bool)
(declare-fun Set_difference (Set<Int> Set<Int>) Set<Int>)
(declare-fun Set_intersection (Set<Int> Set<Int>) Set<Int>)
(declare-fun Set_subset (Set<Int> Set<Int>) Bool)
(declare-fun Set_equal (Set<Int> Set<Int>) Bool)
(declare-fun Set_in (Bool Set<Bool>) Bool)
(declare-fun Set_card (Set<Bool>) Int)
(declare-const Set_empty Set<Bool>)
(declare-fun Set_singleton (Bool) Set<Bool>)
(declare-fun Set_unionone (Set<Bool> Bool) Set<Bool>)
(declare-fun Set_union (Set<Bool> Set<Bool>) Set<Bool>)
(declare-fun Set_disjoint (Set<Bool> Set<Bool>) Bool)
(declare-fun Set_difference (Set<Bool> Set<Bool>) Set<Bool>)
(declare-fun Set_intersection (Set<Bool> Set<Bool>) Set<Bool>)
(declare-fun Set_subset (Set<Bool> Set<Bool>) Bool)
(declare-fun Set_equal (Set<Bool> Set<Bool>) Bool)
(declare-fun Set_in (option<array> Set<option<array>>) Bool)
(declare-fun Set_card (Set<option<array>>) Int)
(declare-const Set_empty Set<option<array>>)
(declare-fun Set_singleton (option<array>) Set<option<array>>)
(declare-fun Set_unionone (Set<option<array>> option<array>) Set<option<array>>)
(declare-fun Set_union (Set<option<array>> Set<option<array>>) Set<option<array>>)
(declare-fun Set_disjoint (Set<option<array>> Set<option<array>>) Bool)
(declare-fun Set_difference (Set<option<array>> Set<option<array>>) Set<option<array>>)
(declare-fun Set_intersection (Set<option<array>> Set<option<array>>) Set<option<array>>)
(declare-fun Set_subset (Set<option<array>> Set<option<array>>) Bool)
(declare-fun Set_equal (Set<option<array>> Set<option<array>>) Bool)
(declare-fun Set_in ($Ref Set<$Ref>) Bool)
(declare-fun Set_card (Set<$Ref>) Int)
(declare-const Set_empty Set<$Ref>)
(declare-fun Set_singleton ($Ref) Set<$Ref>)
(declare-fun Set_unionone (Set<$Ref> $Ref) Set<$Ref>)
(declare-fun Set_union (Set<$Ref> Set<$Ref>) Set<$Ref>)
(declare-fun Set_disjoint (Set<$Ref> Set<$Ref>) Bool)
(declare-fun Set_difference (Set<$Ref> Set<$Ref>) Set<$Ref>)
(declare-fun Set_intersection (Set<$Ref> Set<$Ref>) Set<$Ref>)
(declare-fun Set_subset (Set<$Ref> Set<$Ref>) Bool)
(declare-fun Set_equal (Set<$Ref> Set<$Ref>) Bool)
(declare-fun Set_in ($Snap Set<$Snap>) Bool)
(declare-fun Set_card (Set<$Snap>) Int)
(declare-const Set_empty Set<$Snap>)
(declare-fun Set_singleton ($Snap) Set<$Snap>)
(declare-fun Set_unionone (Set<$Snap> $Snap) Set<$Snap>)
(declare-fun Set_union (Set<$Snap> Set<$Snap>) Set<$Snap>)
(declare-fun Set_disjoint (Set<$Snap> Set<$Snap>) Bool)
(declare-fun Set_difference (Set<$Snap> Set<$Snap>) Set<$Snap>)
(declare-fun Set_intersection (Set<$Snap> Set<$Snap>) Set<$Snap>)
(declare-fun Set_subset (Set<$Snap> Set<$Snap>) Bool)
(declare-fun Set_equal (Set<$Snap> Set<$Snap>) Bool)
(declare-fun Seq_length (Seq<Seq<Int>>) Int)
(declare-const Seq_empty Seq<Seq<Int>>)
(declare-fun Seq_singleton (Seq<Int>) Seq<Seq<Int>>)
(declare-fun Seq_build (Seq<Seq<Int>> Seq<Int>) Seq<Seq<Int>>)
(declare-fun Seq_index (Seq<Seq<Int>> Int) Seq<Int>)
(declare-fun Seq_append (Seq<Seq<Int>> Seq<Seq<Int>>) Seq<Seq<Int>>)
(declare-fun Seq_update (Seq<Seq<Int>> Int Seq<Int>) Seq<Seq<Int>>)
(declare-fun Seq_contains (Seq<Seq<Int>> Seq<Int>) Bool)
(declare-fun Seq_take (Seq<Seq<Int>> Int) Seq<Seq<Int>>)
(declare-fun Seq_drop (Seq<Seq<Int>> Int) Seq<Seq<Int>>)
(declare-fun Seq_equal (Seq<Seq<Int>> Seq<Seq<Int>>) Bool)
(declare-fun Seq_sameuntil (Seq<Seq<Int>> Seq<Seq<Int>> Int) Bool)
(declare-fun Seq_length (Seq<Int>) Int)
(declare-const Seq_empty Seq<Int>)
(declare-fun Seq_singleton (Int) Seq<Int>)
(declare-fun Seq_build (Seq<Int> Int) Seq<Int>)
(declare-fun Seq_index (Seq<Int> Int) Int)
(declare-fun Seq_append (Seq<Int> Seq<Int>) Seq<Int>)
(declare-fun Seq_update (Seq<Int> Int Int) Seq<Int>)
(declare-fun Seq_contains (Seq<Int> Int) Bool)
(declare-fun Seq_take (Seq<Int> Int) Seq<Int>)
(declare-fun Seq_drop (Seq<Int> Int) Seq<Int>)
(declare-fun Seq_equal (Seq<Int> Seq<Int>) Bool)
(declare-fun Seq_sameuntil (Seq<Int> Seq<Int> Int) Bool)
(declare-fun Seq_range (Int Int) Seq<Int>)
(declare-fun array_loc<Ref> (array Int) $Ref)
(declare-fun alen<Int> (array) Int)
(declare-fun loc_inv_1<array> ($Ref) array)
(declare-fun loc_inv_2<Int> ($Ref) Int)
(declare-const None<option<array>> option<array>)
(declare-fun some<option<array>> (array) option<array>)
(declare-fun option_get<array> (option<array>) array)
(declare-const v_null<t_null> t_null)
(declare-const None<option<any>> option<any>)
(declare-fun some<option<any>> (any) option<any>)
(declare-fun option_get<any> (option<any>) any)
(declare-const unit<void> void)
; /field_value_functions_declarations.smt2 [int: Int]
(declare-fun $FVF.domain_int ($FVF<Int>) Set<$Ref>)
(declare-fun $FVF.lookup_int ($FVF<Int> $Ref) Int)
(declare-fun $FVF.after_int ($FVF<Int> $FVF<Int>) Bool)
(declare-fun $FVF.loc_int (Int $Ref) Bool)
(declare-fun $FVF.perm_int ($FPM $Ref) $Perm)
(declare-const $fvfTOP_int $FVF<Int>)
; /field_value_functions_declarations.smt2 [option$array$: option[array]]
(declare-fun $FVF.domain_option$array$ ($FVF<option<array>>) Set<$Ref>)
(declare-fun $FVF.lookup_option$array$ ($FVF<option<array>> $Ref) option<array>)
(declare-fun $FVF.after_option$array$ ($FVF<option<array>> $FVF<option<array>>) Bool)
(declare-fun $FVF.loc_option$array$ (option<array> $Ref) Bool)
(declare-fun $FVF.perm_option$array$ ($FPM $Ref) $Perm)
(declare-const $fvfTOP_option$array$ $FVF<option<array>>)
; /field_value_functions_declarations.smt2 [bool: Bool]
(declare-fun $FVF.domain_bool ($FVF<Bool>) Set<$Ref>)
(declare-fun $FVF.lookup_bool ($FVF<Bool> $Ref) Bool)
(declare-fun $FVF.after_bool ($FVF<Bool> $FVF<Bool>) Bool)
(declare-fun $FVF.loc_bool (Bool $Ref) Bool)
(declare-fun $FVF.perm_bool ($FPM $Ref) $Perm)
(declare-const $fvfTOP_bool $FVF<Bool>)
; Declaring symbols related to program functions (from program analysis)
(declare-fun SquareIntMatrix ($Snap $Ref Seq<Seq<Int>> Int) Bool)
(declare-fun SquareIntMatrix%limited ($Snap $Ref Seq<Seq<Int>> Int) Bool)
(declare-fun SquareIntMatrix%stateless ($Ref Seq<Seq<Int>> Int) Bool)
(declare-fun NonNegativeCapacities ($Snap $Ref Seq<Seq<Int>> Int) Bool)
(declare-fun NonNegativeCapacities%limited ($Snap $Ref Seq<Seq<Int>> Int) Bool)
(declare-fun NonNegativeCapacities%stateless ($Ref Seq<Seq<Int>> Int) Bool)
(declare-fun FlowNetwork ($Snap $Ref Seq<Seq<Int>> Int Int Int) Bool)
(declare-fun FlowNetwork%limited ($Snap $Ref Seq<Seq<Int>> Int Int Int) Bool)
(declare-fun FlowNetwork%stateless ($Ref Seq<Seq<Int>> Int Int Int) Bool)
(declare-fun SumOutgoingFlow ($Snap $Ref Seq<Seq<Int>> Int Int Int) Int)
(declare-fun SumOutgoingFlow%limited ($Snap $Ref Seq<Seq<Int>> Int Int Int) Int)
(declare-fun SumOutgoingFlow%stateless ($Ref Seq<Seq<Int>> Int Int Int) Bool)
(declare-fun SumIncomingFlow ($Snap $Ref Seq<Seq<Int>> Int Int Int) Int)
(declare-fun SumIncomingFlow%limited ($Snap $Ref Seq<Seq<Int>> Int Int Int) Int)
(declare-fun SumIncomingFlow%stateless ($Ref Seq<Seq<Int>> Int Int Int) Bool)
(declare-fun CapacityConstraint ($Snap $Ref Seq<Seq<Int>> Seq<Seq<Int>> Int) Bool)
(declare-fun CapacityConstraint%limited ($Snap $Ref Seq<Seq<Int>> Seq<Seq<Int>> Int) Bool)
(declare-fun CapacityConstraint%stateless ($Ref Seq<Seq<Int>> Seq<Seq<Int>> Int) Bool)
(declare-fun FlowConservation ($Snap $Ref Seq<Seq<Int>> Int Int Int) Bool)
(declare-fun FlowConservation%limited ($Snap $Ref Seq<Seq<Int>> Int Int Int) Bool)
(declare-fun FlowConservation%stateless ($Ref Seq<Seq<Int>> Int Int Int) Bool)
(declare-fun aloc ($Snap array Int) $Ref)
(declare-fun aloc%limited ($Snap array Int) $Ref)
(declare-fun aloc%stateless (array Int) Bool)
(declare-fun opt_get1 ($Snap option<array>) array)
(declare-fun opt_get1%limited ($Snap option<array>) array)
(declare-fun opt_get1%stateless (option<array>) Bool)
(declare-fun valid_graph_vertices1 ($Snap $Ref Seq<Int> Int) Bool)
(declare-fun valid_graph_vertices1%limited ($Snap $Ref Seq<Int> Int) Bool)
(declare-fun valid_graph_vertices1%stateless ($Ref Seq<Int> Int) Bool)
(declare-fun ValidFlow ($Snap $Ref Seq<Seq<Int>> Seq<Seq<Int>> Int Int Int) Bool)
(declare-fun ValidFlow%limited ($Snap $Ref Seq<Seq<Int>> Seq<Seq<Int>> Int Int Int) Bool)
(declare-fun ValidFlow%stateless ($Ref Seq<Seq<Int>> Seq<Seq<Int>> Int Int Int) Bool)
(declare-fun SquareIntMatrix1 ($Snap $Ref option<array> Int) Bool)
(declare-fun SquareIntMatrix1%limited ($Snap $Ref option<array> Int) Bool)
(declare-fun SquareIntMatrix1%stateless ($Ref option<array> Int) Bool)
(declare-fun any_as ($Snap any) any)
(declare-fun any_as%limited ($Snap any) any)
(declare-fun any_as%stateless (any) Bool)
(declare-fun unknown_ ($Snap option<array> Int Int) Seq<Int>)
(declare-fun unknown%limited ($Snap option<array> Int Int) Seq<Int>)
(declare-fun unknown%stateless (option<array> Int Int) Bool)
(declare-fun AugPath ($Snap $Ref Seq<Seq<Int>> Seq<Seq<Int>> Int Int Int Seq<Int>) Bool)
(declare-fun AugPath%limited ($Snap $Ref Seq<Seq<Int>> Seq<Seq<Int>> Int Int Int Seq<Int>) Bool)
(declare-fun AugPath%stateless ($Ref Seq<Seq<Int>> Seq<Seq<Int>> Int Int Int Seq<Int>) Bool)
(declare-fun opt_get ($Snap option<any>) any)
(declare-fun opt_get%limited ($Snap option<any>) any)
(declare-fun opt_get%stateless (option<any>) Bool)
(declare-fun NonNegativeCapacities1 ($Snap $Ref option<array> Int) Bool)
(declare-fun NonNegativeCapacities1%limited ($Snap $Ref option<array> Int) Bool)
(declare-fun NonNegativeCapacities1%stateless ($Ref option<array> Int) Bool)
(declare-fun as_any ($Snap any) any)
(declare-fun as_any%limited ($Snap any) any)
(declare-fun as_any%stateless (any) Bool)
(declare-fun valid_graph_vertices ($Snap $Ref option<array> Int) Bool)
(declare-fun valid_graph_vertices%limited ($Snap $Ref option<array> Int) Bool)
(declare-fun valid_graph_vertices%stateless ($Ref option<array> Int) Bool)
(declare-fun type ($Snap $Ref) Int)
(declare-fun type%limited ($Snap $Ref) Int)
(declare-fun type%stateless ($Ref) Bool)
(declare-fun subtype ($Snap Int Int) Bool)
(declare-fun subtype%limited ($Snap Int Int) Bool)
(declare-fun subtype%stateless (Int Int) Bool)
(declare-fun matrixValues ($Snap $Ref option<array> Int) Seq<Seq<Int>>)
(declare-fun matrixValues%limited ($Snap $Ref option<array> Int) Seq<Seq<Int>>)
(declare-fun matrixValues%stateless ($Ref option<array> Int) Bool)
(declare-fun ExAugPath ($Snap $Ref Seq<Seq<Int>> Seq<Seq<Int>> Int Int Int) Bool)
(declare-fun ExAugPath%limited ($Snap $Ref Seq<Seq<Int>> Seq<Seq<Int>> Int Int Int) Bool)
(declare-fun ExAugPath%stateless ($Ref Seq<Seq<Int>> Seq<Seq<Int>> Int Int Int) Bool)
(declare-fun opt_or_else ($Snap option<any> any) any)
(declare-fun opt_or_else%limited ($Snap option<any> any) any)
(declare-fun opt_or_else%stateless (option<any> any) Bool)
(declare-fun FlowNetwork1 ($Snap $Ref option<array> Int Int Int) Bool)
(declare-fun FlowNetwork1%limited ($Snap $Ref option<array> Int Int Int) Bool)
(declare-fun FlowNetwork1%stateless ($Ref option<array> Int Int Int) Bool)
; Snapshot variable to be used during function verification
(declare-fun s@$ () $Snap)
; Declaring predicate trigger functions
(declare-fun lock_inv_FordFulkerson%trigger ($Snap $Ref) Bool)
(declare-fun lock_held_FordFulkerson%trigger ($Snap $Ref) Bool)
(declare-fun lock_inv_Object%trigger ($Snap $Ref) Bool)
(declare-fun lock_held_Object%trigger ($Snap $Ref) Bool)
; ////////// Uniqueness assumptions from domains
; ////////// Axioms
(assert (forall ((s Seq<Seq<Int>>)) (!
  (<= 0 (Seq_length s))
  :pattern ((Seq_length s))
  :qid |$Seq[Seq[Int]]_prog.seq_length_non_negative|)))
(assert (= (Seq_length (as Seq_empty  Seq<Seq<Int>>)) 0))
(assert (forall ((s Seq<Seq<Int>>)) (!
  (implies (= (Seq_length s) 0) (= s (as Seq_empty  Seq<Seq<Int>>)))
  :pattern ((Seq_length s))
  :qid |$Seq[Seq[Int]]_prog.only_empty_seq_length_zero|)))
(assert (forall ((e Seq<Int>)) (!
  (= (Seq_length (Seq_singleton e)) 1)
  :pattern ((Seq_length (Seq_singleton e)))
  :qid |$Seq[Seq[Int]]_prog.length_singleton_seq|)))
(assert (forall ((s Seq<Seq<Int>>) (e Seq<Int>)) (!
  (= (Seq_length (Seq_build s e)) (+ 1 (Seq_length s)))
  :pattern ((Seq_length (Seq_build s e)))
  :qid |$Seq[Seq[Int]]_prog.length_seq_build_inc_by_one|)))
(assert (forall ((s Seq<Seq<Int>>) (i Int) (e Seq<Int>)) (!
  (ite
    (= i (Seq_length s))
    (= (Seq_index (Seq_build s e) i) e)
    (= (Seq_index (Seq_build s e) i) (Seq_index s i)))
  :pattern ((Seq_index (Seq_build s e) i))
  :qid |$Seq[Seq[Int]]_prog.seq_index_over_build|)))
(assert (forall ((s1 Seq<Seq<Int>>) (s2 Seq<Seq<Int>>)) (!
  (implies
    (and
      (not (= s1 (as Seq_empty  Seq<Seq<Int>>)))
      (not (= s2 (as Seq_empty  Seq<Seq<Int>>))))
    (= (Seq_length (Seq_append s1 s2)) (+ (Seq_length s1) (Seq_length s2))))
  :pattern ((Seq_length (Seq_append s1 s2)))
  :qid |$Seq[Seq[Int]]_prog.seq_length_over_append|)))
(assert (forall ((e Seq<Int>)) (!
  (= (Seq_index (Seq_singleton e) 0) e)
  :pattern ((Seq_index (Seq_singleton e) 0))
  :qid |$Seq[Seq[Int]]_prog.seq_index_over_singleton|)))
(assert (forall ((e1 Seq<Int>) (e2 Seq<Int>)) (!
  (= (Seq_contains (Seq_singleton e1) e2) (= e1 e2))
  :pattern ((Seq_contains (Seq_singleton e1) e2))
  :qid |$Seq[Seq[Int]]_prog.seq_contains_over_singleton|)))
(assert (forall ((s Seq<Seq<Int>>)) (!
  (= (Seq_append (as Seq_empty  Seq<Seq<Int>>) s) s)
  :pattern ((Seq_append (as Seq_empty  Seq<Seq<Int>>) s))
  :qid |$Seq[Seq[Int]]_prog.seq_append_empty_left|)))
(assert (forall ((s Seq<Seq<Int>>)) (!
  (= (Seq_append s (as Seq_empty  Seq<Seq<Int>>)) s)
  :pattern ((Seq_append s (as Seq_empty  Seq<Seq<Int>>)))
  :qid |$Seq[Seq[Int]]_prog.seq_append_empty_right|)))
(assert (forall ((s1 Seq<Seq<Int>>) (s2 Seq<Seq<Int>>) (i Int)) (!
  (implies
    (and
      (not (= s1 (as Seq_empty  Seq<Seq<Int>>)))
      (not (= s2 (as Seq_empty  Seq<Seq<Int>>))))
    (ite
      (< i (Seq_length s1))
      (= (Seq_index (Seq_append s1 s2) i) (Seq_index s1 i))
      (= (Seq_index (Seq_append s1 s2) i) (Seq_index s2 (- i (Seq_length s1))))))
  :pattern ((Seq_index (Seq_append s1 s2) i))
  :pattern ((Seq_index s1 i) (Seq_append s1 s2))
  :qid |$Seq[Seq[Int]]_prog.seq_index_over_append|)))
(assert (forall ((s Seq<Seq<Int>>) (i Int) (e Seq<Int>)) (!
  (implies
    (and (<= 0 i) (< i (Seq_length s)))
    (= (Seq_length (Seq_update s i e)) (Seq_length s)))
  :pattern ((Seq_length (Seq_update s i e)))
  :qid |$Seq[Seq[Int]]_prog.seq_length_invariant_over_update|)))
(assert (forall ((s Seq<Seq<Int>>) (i Int) (e Seq<Int>) (j Int)) (!
  (ite
    (implies (and (<= 0 i) (< i (Seq_length s))) (= i j))
    (= (Seq_index (Seq_update s i e) j) e)
    (= (Seq_index (Seq_update s i e) j) (Seq_index s j)))
  :pattern ((Seq_index (Seq_update s i e) j))
  :qid |$Seq[Seq[Int]]_prog.seq_index_over_update|)))
(assert (forall ((s Seq<Seq<Int>>) (e Seq<Int>)) (!
  (=
    (Seq_contains s e)
    (exists ((i Int)) (!
      (and (<= 0 i) (and (< i (Seq_length s)) (= (Seq_index s i) e)))
      :pattern ((Seq_index s i))
      )))
  :pattern ((Seq_contains s e))
  :qid |$Seq[Seq[Int]]_prog.seq_element_contains_index_exists|)))
(assert (forall ((e Seq<Int>)) (!
  (not (Seq_contains (as Seq_empty  Seq<Seq<Int>>) e))
  :pattern ((Seq_contains (as Seq_empty  Seq<Seq<Int>>) e))
  :qid |$Seq[Seq[Int]]_prog.empty_seq_contains_nothing|)))
(assert (forall ((s1 Seq<Seq<Int>>) (s2 Seq<Seq<Int>>) (e Seq<Int>)) (!
  (=
    (Seq_contains (Seq_append s1 s2) e)
    (or (Seq_contains s1 e) (Seq_contains s2 e)))
  :pattern ((Seq_contains (Seq_append s1 s2) e))
  :qid |$Seq[Seq[Int]]_prog.seq_contains_over_append|)))
(assert (forall ((s Seq<Seq<Int>>) (e1 Seq<Int>) (e2 Seq<Int>)) (!
  (= (Seq_contains (Seq_build s e1) e2) (or (= e1 e2) (Seq_contains s e2)))
  :pattern ((Seq_contains (Seq_build s e1) e2))
  :qid |$Seq[Seq[Int]]_prog.seq_contains_over_build|)))
(assert (forall ((s Seq<Seq<Int>>) (n Int)) (!
  (implies (<= n 0) (= (Seq_take s n) (as Seq_empty  Seq<Seq<Int>>)))
  :pattern ((Seq_take s n))
  :qid |$Seq[Seq[Int]]_prog.seq_take_negative_length|)))
(assert (forall ((s Seq<Seq<Int>>) (n Int) (e Seq<Int>)) (!
  (=
    (Seq_contains (Seq_take s n) e)
    (exists ((i Int)) (!
      (and
        (<= 0 i)
        (and (< i n) (and (< i (Seq_length s)) (= (Seq_index s i) e))))
      :pattern ((Seq_index s i))
      )))
  :pattern ((Seq_contains (Seq_take s n) e))
  :qid |$Seq[Seq[Int]]_prog.seq_contains_over_take_index_exists|)))
(assert (forall ((s Seq<Seq<Int>>) (n Int)) (!
  (implies (<= n 0) (= (Seq_drop s n) s))
  :pattern ((Seq_drop s n))
  :qid |$Seq[Seq[Int]]_prog.seq_drop_negative_length|)))
(assert (forall ((s Seq<Seq<Int>>) (n Int) (e Seq<Int>)) (!
  (=
    (Seq_contains (Seq_drop s n) e)
    (exists ((i Int)) (!
      (and
        (<= 0 i)
        (and (<= n i) (and (< i (Seq_length s)) (= (Seq_index s i) e))))
      :pattern ((Seq_index s i))
      )))
  :pattern ((Seq_contains (Seq_drop s n) e))
  :qid |$Seq[Seq[Int]]_prog.seq_contains_over_drop_index_exists|)))
(assert (forall ((s1 Seq<Seq<Int>>) (s2 Seq<Seq<Int>>)) (!
  (=
    (Seq_equal s1 s2)
    (and
      (= (Seq_length s1) (Seq_length s2))
      (forall ((i Int)) (!
        (implies
          (and (<= 0 i) (< i (Seq_length s1)))
          (= (Seq_index s1 i) (Seq_index s2 i)))
        :pattern ((Seq_index s1 i))
        :pattern ((Seq_index s2 i))
        ))))
  :pattern ((Seq_equal s1 s2))
  :qid |$Seq[Seq[Int]]_prog.extensional_seq_equality|)))
(assert (forall ((s1 Seq<Seq<Int>>) (s2 Seq<Seq<Int>>)) (!
  (implies (Seq_equal s1 s2) (= s1 s2))
  :pattern ((Seq_equal s1 s2))
  :qid |$Seq[Seq[Int]]_prog.seq_equality_identity|)))
(assert (forall ((s1 Seq<Seq<Int>>) (s2 Seq<Seq<Int>>) (n Int)) (!
  (=
    (Seq_sameuntil s1 s2 n)
    (forall ((i Int)) (!
      (implies (and (<= 0 i) (< i n)) (= (Seq_index s1 i) (Seq_index s2 i)))
      :pattern ((Seq_index s1 i))
      :pattern ((Seq_index s2 i))
      )))
  :pattern ((Seq_sameuntil s1 s2 n))
  :qid |$Seq[Seq[Int]]_prog.extensional_seq_equality_prefix|)))
(assert (forall ((s Seq<Seq<Int>>) (n Int)) (!
  (implies
    (<= 0 n)
    (ite
      (<= n (Seq_length s))
      (= (Seq_length (Seq_take s n)) n)
      (= (Seq_length (Seq_take s n)) (Seq_length s))))
  :pattern ((Seq_length (Seq_take s n)))
  :qid |$Seq[Seq[Int]]_prog.seq_length_over_take|)))
(assert (forall ((s Seq<Seq<Int>>) (n Int) (i Int)) (!
  (implies
    (and (<= 0 i) (and (< i n) (< i (Seq_length s))))
    (= (Seq_index (Seq_take s n) i) (Seq_index s i)))
  :pattern ((Seq_index (Seq_take s n) i))
  :pattern ((Seq_index s i) (Seq_take s n))
  :qid |$Seq[Seq[Int]]_prog.seq_index_over_take|)))
(assert (forall ((s Seq<Seq<Int>>) (n Int)) (!
  (implies
    (<= 0 n)
    (ite
      (<= n (Seq_length s))
      (= (Seq_length (Seq_drop s n)) (- (Seq_length s) n))
      (= (Seq_length (Seq_drop s n)) 0)))
  :pattern ((Seq_length (Seq_drop s n)))
  :qid |$Seq[Seq[Int]]_prog.seq_length_over_drop|)))
(assert (forall ((s Seq<Seq<Int>>) (n Int) (i Int)) (!
  (implies
    (and (<= 0 n) (and (<= 0 i) (< i (- (Seq_length s) n))))
    (= (Seq_index (Seq_drop s n) i) (Seq_index s (+ i n))))
  :pattern ((Seq_index (Seq_drop s n) i))
  :qid |$Seq[Seq[Int]]_prog.seq_index_over_drop_1|)))
(assert (forall ((s Seq<Seq<Int>>) (n Int) (i Int)) (!
  (implies
    (and (<= 0 n) (and (<= n i) (< i (Seq_length s))))
    (= (Seq_index (Seq_drop s n) (- i n)) (Seq_index s i)))
  :pattern ((Seq_index s i) (Seq_drop s n))
  :qid |$Seq[Seq[Int]]_prog.seq_index_over_drop_2|)))
(assert (forall ((s Seq<Seq<Int>>) (i Int) (e Seq<Int>) (n Int)) (!
  (implies
    (and (<= 0 i) (and (< i n) (< n (Seq_length s))))
    (= (Seq_take (Seq_update s i e) n) (Seq_update (Seq_take s n) i e)))
  :pattern ((Seq_take (Seq_update s i e) n))
  :qid |$Seq[Seq[Int]]_prog.seq_take_over_update_1|)))
(assert (forall ((s Seq<Seq<Int>>) (i Int) (e Seq<Int>) (n Int)) (!
  (implies
    (and (<= n i) (< i (Seq_length s)))
    (= (Seq_take (Seq_update s i e) n) (Seq_take s n)))
  :pattern ((Seq_take (Seq_update s i e) n))
  :qid |$Seq[Seq[Int]]_prog.seq_take_over_update_2|)))
(assert (forall ((s Seq<Seq<Int>>) (i Int) (e Seq<Int>) (n Int)) (!
  (implies
    (and (<= 0 n) (and (<= n i) (< i (Seq_length s))))
    (= (Seq_drop (Seq_update s i e) n) (Seq_update (Seq_drop s n) (- i n) e)))
  :pattern ((Seq_drop (Seq_update s i e) n))
  :qid |$Seq[Seq[Int]]_prog.seq_drop_over_update_1|)))
(assert (forall ((s Seq<Seq<Int>>) (i Int) (e Seq<Int>) (n Int)) (!
  (implies
    (and (<= 0 i) (and (< i n) (< n (Seq_length s))))
    (= (Seq_drop (Seq_update s i e) n) (Seq_drop s n)))
  :pattern ((Seq_drop (Seq_update s i e) n))
  :qid |$Seq[Seq[Int]]_prog.seq_drop_over_update_2|)))
(assert (forall ((s Seq<Seq<Int>>) (e Seq<Int>) (n Int)) (!
  (implies
    (and (<= 0 n) (<= n (Seq_length s)))
    (= (Seq_drop (Seq_build s e) n) (Seq_build (Seq_drop s n) e)))
  :pattern ((Seq_drop (Seq_build s e) n))
  :qid |$Seq[Seq[Int]]_prog.seq_drop_over_build|)))
(assert (forall ((s Seq<Int>)) (!
  (<= 0 (Seq_length s))
  :pattern ((Seq_length s))
  :qid |$Seq[Int]_prog.seq_length_non_negative|)))
(assert (= (Seq_length (as Seq_empty  Seq<Int>)) 0))
(assert (forall ((s Seq<Int>)) (!
  (implies (= (Seq_length s) 0) (= s (as Seq_empty  Seq<Int>)))
  :pattern ((Seq_length s))
  :qid |$Seq[Int]_prog.only_empty_seq_length_zero|)))
(assert (forall ((e Int)) (!
  (= (Seq_length (Seq_singleton e)) 1)
  :pattern ((Seq_length (Seq_singleton e)))
  :qid |$Seq[Int]_prog.length_singleton_seq|)))
(assert (forall ((s Seq<Int>) (e Int)) (!
  (= (Seq_length (Seq_build s e)) (+ 1 (Seq_length s)))
  :pattern ((Seq_length (Seq_build s e)))
  :qid |$Seq[Int]_prog.length_seq_build_inc_by_one|)))
(assert (forall ((s Seq<Int>) (i Int) (e Int)) (!
  (ite
    (= i (Seq_length s))
    (= (Seq_index (Seq_build s e) i) e)
    (= (Seq_index (Seq_build s e) i) (Seq_index s i)))
  :pattern ((Seq_index (Seq_build s e) i))
  :qid |$Seq[Int]_prog.seq_index_over_build|)))
(assert (forall ((s1 Seq<Int>) (s2 Seq<Int>)) (!
  (implies
    (and
      (not (= s1 (as Seq_empty  Seq<Int>)))
      (not (= s2 (as Seq_empty  Seq<Int>))))
    (= (Seq_length (Seq_append s1 s2)) (+ (Seq_length s1) (Seq_length s2))))
  :pattern ((Seq_length (Seq_append s1 s2)))
  :qid |$Seq[Int]_prog.seq_length_over_append|)))
(assert (forall ((e Int)) (!
  (= (Seq_index (Seq_singleton e) 0) e)
  :pattern ((Seq_index (Seq_singleton e) 0))
  :qid |$Seq[Int]_prog.seq_index_over_singleton|)))
(assert (forall ((e1 Int) (e2 Int)) (!
  (= (Seq_contains (Seq_singleton e1) e2) (= e1 e2))
  :pattern ((Seq_contains (Seq_singleton e1) e2))
  :qid |$Seq[Int]_prog.seq_contains_over_singleton|)))
(assert (forall ((s Seq<Int>)) (!
  (= (Seq_append (as Seq_empty  Seq<Int>) s) s)
  :pattern ((Seq_append (as Seq_empty  Seq<Int>) s))
  :qid |$Seq[Int]_prog.seq_append_empty_left|)))
(assert (forall ((s Seq<Int>)) (!
  (= (Seq_append s (as Seq_empty  Seq<Int>)) s)
  :pattern ((Seq_append s (as Seq_empty  Seq<Int>)))
  :qid |$Seq[Int]_prog.seq_append_empty_right|)))
(assert (forall ((s1 Seq<Int>) (s2 Seq<Int>) (i Int)) (!
  (implies
    (and
      (not (= s1 (as Seq_empty  Seq<Int>)))
      (not (= s2 (as Seq_empty  Seq<Int>))))
    (ite
      (< i (Seq_length s1))
      (= (Seq_index (Seq_append s1 s2) i) (Seq_index s1 i))
      (= (Seq_index (Seq_append s1 s2) i) (Seq_index s2 (- i (Seq_length s1))))))
  :pattern ((Seq_index (Seq_append s1 s2) i))
  :pattern ((Seq_index s1 i) (Seq_append s1 s2))
  :qid |$Seq[Int]_prog.seq_index_over_append|)))
(assert (forall ((s Seq<Int>) (i Int) (e Int)) (!
  (implies
    (and (<= 0 i) (< i (Seq_length s)))
    (= (Seq_length (Seq_update s i e)) (Seq_length s)))
  :pattern ((Seq_length (Seq_update s i e)))
  :qid |$Seq[Int]_prog.seq_length_invariant_over_update|)))
(assert (forall ((s Seq<Int>) (i Int) (e Int) (j Int)) (!
  (ite
    (implies (and (<= 0 i) (< i (Seq_length s))) (= i j))
    (= (Seq_index (Seq_update s i e) j) e)
    (= (Seq_index (Seq_update s i e) j) (Seq_index s j)))
  :pattern ((Seq_index (Seq_update s i e) j))
  :qid |$Seq[Int]_prog.seq_index_over_update|)))
(assert (forall ((s Seq<Int>) (e Int)) (!
  (=
    (Seq_contains s e)
    (exists ((i Int)) (!
      (and (<= 0 i) (and (< i (Seq_length s)) (= (Seq_index s i) e)))
      :pattern ((Seq_index s i))
      )))
  :pattern ((Seq_contains s e))
  :qid |$Seq[Int]_prog.seq_element_contains_index_exists|)))
(assert (forall ((e Int)) (!
  (not (Seq_contains (as Seq_empty  Seq<Int>) e))
  :pattern ((Seq_contains (as Seq_empty  Seq<Int>) e))
  :qid |$Seq[Int]_prog.empty_seq_contains_nothing|)))
(assert (forall ((s1 Seq<Int>) (s2 Seq<Int>) (e Int)) (!
  (=
    (Seq_contains (Seq_append s1 s2) e)
    (or (Seq_contains s1 e) (Seq_contains s2 e)))
  :pattern ((Seq_contains (Seq_append s1 s2) e))
  :qid |$Seq[Int]_prog.seq_contains_over_append|)))
(assert (forall ((s Seq<Int>) (e1 Int) (e2 Int)) (!
  (= (Seq_contains (Seq_build s e1) e2) (or (= e1 e2) (Seq_contains s e2)))
  :pattern ((Seq_contains (Seq_build s e1) e2))
  :qid |$Seq[Int]_prog.seq_contains_over_build|)))
(assert (forall ((s Seq<Int>) (n Int)) (!
  (implies (<= n 0) (= (Seq_take s n) (as Seq_empty  Seq<Int>)))
  :pattern ((Seq_take s n))
  :qid |$Seq[Int]_prog.seq_take_negative_length|)))
(assert (forall ((s Seq<Int>) (n Int) (e Int)) (!
  (=
    (Seq_contains (Seq_take s n) e)
    (exists ((i Int)) (!
      (and
        (<= 0 i)
        (and (< i n) (and (< i (Seq_length s)) (= (Seq_index s i) e))))
      :pattern ((Seq_index s i))
      )))
  :pattern ((Seq_contains (Seq_take s n) e))
  :qid |$Seq[Int]_prog.seq_contains_over_take_index_exists|)))
(assert (forall ((s Seq<Int>) (n Int)) (!
  (implies (<= n 0) (= (Seq_drop s n) s))
  :pattern ((Seq_drop s n))
  :qid |$Seq[Int]_prog.seq_drop_negative_length|)))
(assert (forall ((s Seq<Int>) (n Int) (e Int)) (!
  (=
    (Seq_contains (Seq_drop s n) e)
    (exists ((i Int)) (!
      (and
        (<= 0 i)
        (and (<= n i) (and (< i (Seq_length s)) (= (Seq_index s i) e))))
      :pattern ((Seq_index s i))
      )))
  :pattern ((Seq_contains (Seq_drop s n) e))
  :qid |$Seq[Int]_prog.seq_contains_over_drop_index_exists|)))
(assert (forall ((s1 Seq<Int>) (s2 Seq<Int>)) (!
  (=
    (Seq_equal s1 s2)
    (and
      (= (Seq_length s1) (Seq_length s2))
      (forall ((i Int)) (!
        (implies
          (and (<= 0 i) (< i (Seq_length s1)))
          (= (Seq_index s1 i) (Seq_index s2 i)))
        :pattern ((Seq_index s1 i))
        :pattern ((Seq_index s2 i))
        ))))
  :pattern ((Seq_equal s1 s2))
  :qid |$Seq[Int]_prog.extensional_seq_equality|)))
(assert (forall ((s1 Seq<Int>) (s2 Seq<Int>)) (!
  (implies (Seq_equal s1 s2) (= s1 s2))
  :pattern ((Seq_equal s1 s2))
  :qid |$Seq[Int]_prog.seq_equality_identity|)))
(assert (forall ((s1 Seq<Int>) (s2 Seq<Int>) (n Int)) (!
  (=
    (Seq_sameuntil s1 s2 n)
    (forall ((i Int)) (!
      (implies (and (<= 0 i) (< i n)) (= (Seq_index s1 i) (Seq_index s2 i)))
      :pattern ((Seq_index s1 i))
      :pattern ((Seq_index s2 i))
      )))
  :pattern ((Seq_sameuntil s1 s2 n))
  :qid |$Seq[Int]_prog.extensional_seq_equality_prefix|)))
(assert (forall ((s Seq<Int>) (n Int)) (!
  (implies
    (<= 0 n)
    (ite
      (<= n (Seq_length s))
      (= (Seq_length (Seq_take s n)) n)
      (= (Seq_length (Seq_take s n)) (Seq_length s))))
  :pattern ((Seq_length (Seq_take s n)))
  :qid |$Seq[Int]_prog.seq_length_over_take|)))
(assert (forall ((s Seq<Int>) (n Int) (i Int)) (!
  (implies
    (and (<= 0 i) (and (< i n) (< i (Seq_length s))))
    (= (Seq_index (Seq_take s n) i) (Seq_index s i)))
  :pattern ((Seq_index (Seq_take s n) i))
  :pattern ((Seq_index s i) (Seq_take s n))
  :qid |$Seq[Int]_prog.seq_index_over_take|)))
(assert (forall ((s Seq<Int>) (n Int)) (!
  (implies
    (<= 0 n)
    (ite
      (<= n (Seq_length s))
      (= (Seq_length (Seq_drop s n)) (- (Seq_length s) n))
      (= (Seq_length (Seq_drop s n)) 0)))
  :pattern ((Seq_length (Seq_drop s n)))
  :qid |$Seq[Int]_prog.seq_length_over_drop|)))
(assert (forall ((s Seq<Int>) (n Int) (i Int)) (!
  (implies
    (and (<= 0 n) (and (<= 0 i) (< i (- (Seq_length s) n))))
    (= (Seq_index (Seq_drop s n) i) (Seq_index s (+ i n))))
  :pattern ((Seq_index (Seq_drop s n) i))
  :qid |$Seq[Int]_prog.seq_index_over_drop_1|)))
(assert (forall ((s Seq<Int>) (n Int) (i Int)) (!
  (implies
    (and (<= 0 n) (and (<= n i) (< i (Seq_length s))))
    (= (Seq_index (Seq_drop s n) (- i n)) (Seq_index s i)))
  :pattern ((Seq_index s i) (Seq_drop s n))
  :qid |$Seq[Int]_prog.seq_index_over_drop_2|)))
(assert (forall ((s Seq<Int>) (i Int) (e Int) (n Int)) (!
  (implies
    (and (<= 0 i) (and (< i n) (< n (Seq_length s))))
    (= (Seq_take (Seq_update s i e) n) (Seq_update (Seq_take s n) i e)))
  :pattern ((Seq_take (Seq_update s i e) n))
  :qid |$Seq[Int]_prog.seq_take_over_update_1|)))
(assert (forall ((s Seq<Int>) (i Int) (e Int) (n Int)) (!
  (implies
    (and (<= n i) (< i (Seq_length s)))
    (= (Seq_take (Seq_update s i e) n) (Seq_take s n)))
  :pattern ((Seq_take (Seq_update s i e) n))
  :qid |$Seq[Int]_prog.seq_take_over_update_2|)))
(assert (forall ((s Seq<Int>) (i Int) (e Int) (n Int)) (!
  (implies
    (and (<= 0 n) (and (<= n i) (< i (Seq_length s))))
    (= (Seq_drop (Seq_update s i e) n) (Seq_update (Seq_drop s n) (- i n) e)))
  :pattern ((Seq_drop (Seq_update s i e) n))
  :qid |$Seq[Int]_prog.seq_drop_over_update_1|)))
(assert (forall ((s Seq<Int>) (i Int) (e Int) (n Int)) (!
  (implies
    (and (<= 0 i) (and (< i n) (< n (Seq_length s))))
    (= (Seq_drop (Seq_update s i e) n) (Seq_drop s n)))
  :pattern ((Seq_drop (Seq_update s i e) n))
  :qid |$Seq[Int]_prog.seq_drop_over_update_2|)))
(assert (forall ((s Seq<Int>) (e Int) (n Int)) (!
  (implies
    (and (<= 0 n) (<= n (Seq_length s)))
    (= (Seq_drop (Seq_build s e) n) (Seq_build (Seq_drop s n) e)))
  :pattern ((Seq_drop (Seq_build s e) n))
  :qid |$Seq[Int]_prog.seq_drop_over_build|)))
(assert (forall ((min_ Int) (max Int)) (!
  (ite
    (< min_ max)
    (= (Seq_length (Seq_range min_ max)) (- max min_))
    (= (Seq_length (Seq_range min_ max)) 0))
  :pattern ((Seq_length (Seq_range min_ max)))
  :qid |$Seq[Int]_prog.ranged_seq_length|)))
(assert (forall ((min_ Int) (max Int) (i Int)) (!
  (implies
    (and (<= 0 i) (< i (- max min_)))
    (= (Seq_index (Seq_range min_ max) i) (+ min_ i)))
  :pattern ((Seq_index (Seq_range min_ max) i))
  :qid |$Seq[Int]_prog.ranged_seq_index|)))
(assert (forall ((min_ Int) (max Int) (e Int)) (!
  (= (Seq_contains (Seq_range min_ max) e) (and (<= min_ e) (< e max)))
  :pattern ((Seq_contains (Seq_range min_ max) e))
  :qid |$Seq[Int]_prog.ranged_seq_contains|)))
(assert (forall ((s Set<Int>)) (!
  (<= 0 (Set_card s))
  :pattern ((Set_card s))
  :qid |$Set[Int]_prog.card_non_negative|)))
(assert (forall ((e Int)) (!
  (not (Set_in e (as Set_empty  Set<Int>)))
  :pattern ((Set_in e (as Set_empty  Set<Int>)))
  :qid |$Set[Int]_prog.in_empty_set|)))
(assert (forall ((s Set<Int>)) (!
  (and
    (= (= (Set_card s) 0) (= s (as Set_empty  Set<Int>)))
    (implies
      (not (= (Set_card s) 0))
      (exists ((e Int)) (!
        (Set_in e s)
        :pattern ((Set_in e s))
        ))))
  :pattern ((Set_card s))
  :qid |$Set[Int]_prog.empty_set_cardinality|)))
(assert (forall ((e Int)) (!
  (Set_in e (Set_singleton e))
  :pattern ((Set_singleton e))
  :qid |$Set[Int]_prog.in_singleton_set|)))
(assert (forall ((e1 Int) (e2 Int)) (!
  (= (Set_in e1 (Set_singleton e2)) (= e1 e2))
  :pattern ((Set_in e1 (Set_singleton e2)))
  :qid |$Set[Int]_prog.in_singleton_set_equality|)))
(assert (forall ((e Int)) (!
  (= (Set_card (Set_singleton e)) 1)
  :pattern ((Set_card (Set_singleton e)))
  :qid |$Set[Int]_prog.singleton_set_cardinality|)))
(assert (forall ((s Set<Int>) (e Int)) (!
  (Set_in e (Set_unionone s e))
  :pattern ((Set_unionone s e))
  :qid |$Set[Int]_prog.in_unionone_same|)))
(assert (forall ((s Set<Int>) (e1 Int) (e2 Int)) (!
  (= (Set_in e1 (Set_unionone s e2)) (or (= e1 e2) (Set_in e1 s)))
  :pattern ((Set_in e1 (Set_unionone s e2)))
  :qid |$Set[Int]_prog.in_unionone_other|)))
(assert (forall ((s Set<Int>) (e1 Int) (e2 Int)) (!
  (implies (Set_in e1 s) (Set_in e1 (Set_unionone s e2)))
  :pattern ((Set_in e1 s) (Set_unionone s e2))
  :qid |$Set[Int]_prog.invariance_in_unionone|)))
(assert (forall ((s Set<Int>) (e Int)) (!
  (implies (Set_in e s) (= (Set_card (Set_unionone s e)) (Set_card s)))
  :pattern ((Set_card (Set_unionone s e)))
  :qid |$Set[Int]_prog.unionone_cardinality_invariant|)))
(assert (forall ((s Set<Int>) (e Int)) (!
  (implies
    (not (Set_in e s))
    (= (Set_card (Set_unionone s e)) (+ (Set_card s) 1)))
  :pattern ((Set_card (Set_unionone s e)))
  :qid |$Set[Int]_prog.unionone_cardinality_changed|)))
(assert (forall ((s1 Set<Int>) (s2 Set<Int>) (e Int)) (!
  (= (Set_in e (Set_union s1 s2)) (or (Set_in e s1) (Set_in e s2)))
  :pattern ((Set_in e (Set_union s1 s2)))
  :qid |$Set[Int]_prog.in_union_in_one|)))
(assert (forall ((s1 Set<Int>) (s2 Set<Int>) (e Int)) (!
  (implies (Set_in e s1) (Set_in e (Set_union s1 s2)))
  :pattern ((Set_in e s1) (Set_union s1 s2))
  :qid |$Set[Int]_prog.in_left_in_union|)))
(assert (forall ((s1 Set<Int>) (s2 Set<Int>) (e Int)) (!
  (implies (Set_in e s2) (Set_in e (Set_union s1 s2)))
  :pattern ((Set_in e s2) (Set_union s1 s2))
  :qid |$Set[Int]_prog.in_right_in_union|)))
(assert (forall ((s1 Set<Int>) (s2 Set<Int>) (e Int)) (!
  (= (Set_in e (Set_intersection s1 s2)) (and (Set_in e s1) (Set_in e s2)))
  :pattern ((Set_in e (Set_intersection s1 s2)))
  :pattern ((Set_intersection s1 s2) (Set_in e s1))
  :pattern ((Set_intersection s1 s2) (Set_in e s2))
  :qid |$Set[Int]_prog.in_intersection_in_both|)))
(assert (forall ((s1 Set<Int>) (s2 Set<Int>)) (!
  (= (Set_union s1 (Set_union s1 s2)) (Set_union s1 s2))
  :pattern ((Set_union s1 (Set_union s1 s2)))
  :qid |$Set[Int]_prog.union_left_idempotency|)))
(assert (forall ((s1 Set<Int>) (s2 Set<Int>)) (!
  (= (Set_union (Set_union s1 s2) s2) (Set_union s1 s2))
  :pattern ((Set_union (Set_union s1 s2) s2))
  :qid |$Set[Int]_prog.union_right_idempotency|)))
(assert (forall ((s1 Set<Int>) (s2 Set<Int>)) (!
  (= (Set_intersection s1 (Set_intersection s1 s2)) (Set_intersection s1 s2))
  :pattern ((Set_intersection s1 (Set_intersection s1 s2)))
  :qid |$Set[Int]_prog.intersection_left_idempotency|)))
(assert (forall ((s1 Set<Int>) (s2 Set<Int>)) (!
  (= (Set_intersection (Set_intersection s1 s2) s2) (Set_intersection s1 s2))
  :pattern ((Set_intersection (Set_intersection s1 s2) s2))
  :qid |$Set[Int]_prog.intersection_right_idempotency|)))
(assert (forall ((s1 Set<Int>) (s2 Set<Int>)) (!
  (=
    (+ (Set_card (Set_union s1 s2)) (Set_card (Set_intersection s1 s2)))
    (+ (Set_card s1) (Set_card s2)))
  :pattern ((Set_card (Set_union s1 s2)))
  :pattern ((Set_card (Set_intersection s1 s2)))
  :qid |$Set[Int]_prog.cardinality_sums|)))
(assert (forall ((s1 Set<Int>) (s2 Set<Int>) (e Int)) (!
  (= (Set_in e (Set_difference s1 s2)) (and (Set_in e s1) (not (Set_in e s2))))
  :pattern ((Set_in e (Set_difference s1 s2)))
  :qid |$Set[Int]_prog.in_difference|)))
(assert (forall ((s1 Set<Int>) (s2 Set<Int>) (e Int)) (!
  (implies (Set_in e s2) (not (Set_in e (Set_difference s1 s2))))
  :pattern ((Set_difference s1 s2) (Set_in e s2))
  :qid |$Set[Int]_prog.not_in_difference|)))
(assert (forall ((s1 Set<Int>) (s2 Set<Int>)) (!
  (=
    (Set_subset s1 s2)
    (forall ((e Int)) (!
      (implies (Set_in e s1) (Set_in e s2))
      :pattern ((Set_in e s1))
      :pattern ((Set_in e s2))
      )))
  :pattern ((Set_subset s1 s2))
  :qid |$Set[Int]_prog.subset_definition|)))
(assert (forall ((s1 Set<Int>) (s2 Set<Int>)) (!
  (=
    (Set_equal s1 s2)
    (forall ((e Int)) (!
      (= (Set_in e s1) (Set_in e s2))
      :pattern ((Set_in e s1))
      :pattern ((Set_in e s2))
      )))
  :pattern ((Set_equal s1 s2))
  :qid |$Set[Int]_prog.equality_definition|)))
(assert (forall ((s1 Set<Int>) (s2 Set<Int>)) (!
  (implies (Set_equal s1 s2) (= s1 s2))
  :pattern ((Set_equal s1 s2))
  :qid |$Set[Int]_prog.native_equality|)))
(assert (forall ((s1 Set<Int>) (s2 Set<Int>)) (!
  (=
    (Set_disjoint s1 s2)
    (forall ((e Int)) (!
      (or (not (Set_in e s1)) (not (Set_in e s2)))
      :pattern ((Set_in e s1))
      :pattern ((Set_in e s2))
      )))
  :pattern ((Set_disjoint s1 s2))
  :qid |$Set[Int]_prog.disjointness_definition|)))
(assert (forall ((s1 Set<Int>) (s2 Set<Int>)) (!
  (and
    (=
      (+
        (+ (Set_card (Set_difference s1 s2)) (Set_card (Set_difference s2 s1)))
        (Set_card (Set_intersection s1 s2)))
      (Set_card (Set_union s1 s2)))
    (=
      (Set_card (Set_difference s1 s2))
      (- (Set_card s1) (Set_card (Set_intersection s1 s2)))))
  :pattern ((Set_card (Set_difference s1 s2)))
  :qid |$Set[Int]_prog.cardinality_difference|)))
(assert (forall ((s Set<Bool>)) (!
  (<= 0 (Set_card s))
  :pattern ((Set_card s))
  :qid |$Set[Bool]_prog.card_non_negative|)))
(assert (forall ((e Bool)) (!
  (not (Set_in e (as Set_empty  Set<Bool>)))
  :pattern ((Set_in e (as Set_empty  Set<Bool>)))
  :qid |$Set[Bool]_prog.in_empty_set|)))
(assert (forall ((s Set<Bool>)) (!
  (and
    (= (= (Set_card s) 0) (= s (as Set_empty  Set<Bool>)))
    (implies
      (not (= (Set_card s) 0))
      (exists ((e Bool)) (!
        (Set_in e s)
        :pattern ((Set_in e s))
        ))))
  :pattern ((Set_card s))
  :qid |$Set[Bool]_prog.empty_set_cardinality|)))
(assert (forall ((e Bool)) (!
  (Set_in e (Set_singleton e))
  :pattern ((Set_singleton e))
  :qid |$Set[Bool]_prog.in_singleton_set|)))
(assert (forall ((e1 Bool) (e2 Bool)) (!
  (= (Set_in e1 (Set_singleton e2)) (= e1 e2))
  :pattern ((Set_in e1 (Set_singleton e2)))
  :qid |$Set[Bool]_prog.in_singleton_set_equality|)))
(assert (forall ((e Bool)) (!
  (= (Set_card (Set_singleton e)) 1)
  :pattern ((Set_card (Set_singleton e)))
  :qid |$Set[Bool]_prog.singleton_set_cardinality|)))
(assert (forall ((s Set<Bool>) (e Bool)) (!
  (Set_in e (Set_unionone s e))
  :pattern ((Set_unionone s e))
  :qid |$Set[Bool]_prog.in_unionone_same|)))
(assert (forall ((s Set<Bool>) (e1 Bool) (e2 Bool)) (!
  (= (Set_in e1 (Set_unionone s e2)) (or (= e1 e2) (Set_in e1 s)))
  :pattern ((Set_in e1 (Set_unionone s e2)))
  :qid |$Set[Bool]_prog.in_unionone_other|)))
(assert (forall ((s Set<Bool>) (e1 Bool) (e2 Bool)) (!
  (implies (Set_in e1 s) (Set_in e1 (Set_unionone s e2)))
  :pattern ((Set_in e1 s) (Set_unionone s e2))
  :qid |$Set[Bool]_prog.invariance_in_unionone|)))
(assert (forall ((s Set<Bool>) (e Bool)) (!
  (implies (Set_in e s) (= (Set_card (Set_unionone s e)) (Set_card s)))
  :pattern ((Set_card (Set_unionone s e)))
  :qid |$Set[Bool]_prog.unionone_cardinality_invariant|)))
(assert (forall ((s Set<Bool>) (e Bool)) (!
  (implies
    (not (Set_in e s))
    (= (Set_card (Set_unionone s e)) (+ (Set_card s) 1)))
  :pattern ((Set_card (Set_unionone s e)))
  :qid |$Set[Bool]_prog.unionone_cardinality_changed|)))
(assert (forall ((s1 Set<Bool>) (s2 Set<Bool>) (e Bool)) (!
  (= (Set_in e (Set_union s1 s2)) (or (Set_in e s1) (Set_in e s2)))
  :pattern ((Set_in e (Set_union s1 s2)))
  :qid |$Set[Bool]_prog.in_union_in_one|)))
(assert (forall ((s1 Set<Bool>) (s2 Set<Bool>) (e Bool)) (!
  (implies (Set_in e s1) (Set_in e (Set_union s1 s2)))
  :pattern ((Set_in e s1) (Set_union s1 s2))
  :qid |$Set[Bool]_prog.in_left_in_union|)))
(assert (forall ((s1 Set<Bool>) (s2 Set<Bool>) (e Bool)) (!
  (implies (Set_in e s2) (Set_in e (Set_union s1 s2)))
  :pattern ((Set_in e s2) (Set_union s1 s2))
  :qid |$Set[Bool]_prog.in_right_in_union|)))
(assert (forall ((s1 Set<Bool>) (s2 Set<Bool>) (e Bool)) (!
  (= (Set_in e (Set_intersection s1 s2)) (and (Set_in e s1) (Set_in e s2)))
  :pattern ((Set_in e (Set_intersection s1 s2)))
  :pattern ((Set_intersection s1 s2) (Set_in e s1))
  :pattern ((Set_intersection s1 s2) (Set_in e s2))
  :qid |$Set[Bool]_prog.in_intersection_in_both|)))
(assert (forall ((s1 Set<Bool>) (s2 Set<Bool>)) (!
  (= (Set_union s1 (Set_union s1 s2)) (Set_union s1 s2))
  :pattern ((Set_union s1 (Set_union s1 s2)))
  :qid |$Set[Bool]_prog.union_left_idempotency|)))
(assert (forall ((s1 Set<Bool>) (s2 Set<Bool>)) (!
  (= (Set_union (Set_union s1 s2) s2) (Set_union s1 s2))
  :pattern ((Set_union (Set_union s1 s2) s2))
  :qid |$Set[Bool]_prog.union_right_idempotency|)))
(assert (forall ((s1 Set<Bool>) (s2 Set<Bool>)) (!
  (= (Set_intersection s1 (Set_intersection s1 s2)) (Set_intersection s1 s2))
  :pattern ((Set_intersection s1 (Set_intersection s1 s2)))
  :qid |$Set[Bool]_prog.intersection_left_idempotency|)))
(assert (forall ((s1 Set<Bool>) (s2 Set<Bool>)) (!
  (= (Set_intersection (Set_intersection s1 s2) s2) (Set_intersection s1 s2))
  :pattern ((Set_intersection (Set_intersection s1 s2) s2))
  :qid |$Set[Bool]_prog.intersection_right_idempotency|)))
(assert (forall ((s1 Set<Bool>) (s2 Set<Bool>)) (!
  (=
    (+ (Set_card (Set_union s1 s2)) (Set_card (Set_intersection s1 s2)))
    (+ (Set_card s1) (Set_card s2)))
  :pattern ((Set_card (Set_union s1 s2)))
  :pattern ((Set_card (Set_intersection s1 s2)))
  :qid |$Set[Bool]_prog.cardinality_sums|)))
(assert (forall ((s1 Set<Bool>) (s2 Set<Bool>) (e Bool)) (!
  (= (Set_in e (Set_difference s1 s2)) (and (Set_in e s1) (not (Set_in e s2))))
  :pattern ((Set_in e (Set_difference s1 s2)))
  :qid |$Set[Bool]_prog.in_difference|)))
(assert (forall ((s1 Set<Bool>) (s2 Set<Bool>) (e Bool)) (!
  (implies (Set_in e s2) (not (Set_in e (Set_difference s1 s2))))
  :pattern ((Set_difference s1 s2) (Set_in e s2))
  :qid |$Set[Bool]_prog.not_in_difference|)))
(assert (forall ((s1 Set<Bool>) (s2 Set<Bool>)) (!
  (=
    (Set_subset s1 s2)
    (forall ((e Bool)) (!
      (implies (Set_in e s1) (Set_in e s2))
      :pattern ((Set_in e s1))
      :pattern ((Set_in e s2))
      )))
  :pattern ((Set_subset s1 s2))
  :qid |$Set[Bool]_prog.subset_definition|)))
(assert (forall ((s1 Set<Bool>) (s2 Set<Bool>)) (!
  (=
    (Set_equal s1 s2)
    (forall ((e Bool)) (!
      (= (Set_in e s1) (Set_in e s2))
      :pattern ((Set_in e s1))
      :pattern ((Set_in e s2))
      )))
  :pattern ((Set_equal s1 s2))
  :qid |$Set[Bool]_prog.equality_definition|)))
(assert (forall ((s1 Set<Bool>) (s2 Set<Bool>)) (!
  (implies (Set_equal s1 s2) (= s1 s2))
  :pattern ((Set_equal s1 s2))
  :qid |$Set[Bool]_prog.native_equality|)))
(assert (forall ((s1 Set<Bool>) (s2 Set<Bool>)) (!
  (=
    (Set_disjoint s1 s2)
    (forall ((e Bool)) (!
      (or (not (Set_in e s1)) (not (Set_in e s2)))
      :pattern ((Set_in e s1))
      :pattern ((Set_in e s2))
      )))
  :pattern ((Set_disjoint s1 s2))
  :qid |$Set[Bool]_prog.disjointness_definition|)))
(assert (forall ((s1 Set<Bool>) (s2 Set<Bool>)) (!
  (and
    (=
      (+
        (+ (Set_card (Set_difference s1 s2)) (Set_card (Set_difference s2 s1)))
        (Set_card (Set_intersection s1 s2)))
      (Set_card (Set_union s1 s2)))
    (=
      (Set_card (Set_difference s1 s2))
      (- (Set_card s1) (Set_card (Set_intersection s1 s2)))))
  :pattern ((Set_card (Set_difference s1 s2)))
  :qid |$Set[Bool]_prog.cardinality_difference|)))
(assert (forall ((s Set<option<array>>)) (!
  (<= 0 (Set_card s))
  :pattern ((Set_card s))
  :qid |$Set[option[array]]_prog.card_non_negative|)))
(assert (forall ((e option<array>)) (!
  (not (Set_in e (as Set_empty  Set<option<array>>)))
  :pattern ((Set_in e (as Set_empty  Set<option<array>>)))
  :qid |$Set[option[array]]_prog.in_empty_set|)))
(assert (forall ((s Set<option<array>>)) (!
  (and
    (= (= (Set_card s) 0) (= s (as Set_empty  Set<option<array>>)))
    (implies
      (not (= (Set_card s) 0))
      (exists ((e option<array>)) (!
        (Set_in e s)
        :pattern ((Set_in e s))
        ))))
  :pattern ((Set_card s))
  :qid |$Set[option[array]]_prog.empty_set_cardinality|)))
(assert (forall ((e option<array>)) (!
  (Set_in e (Set_singleton e))
  :pattern ((Set_singleton e))
  :qid |$Set[option[array]]_prog.in_singleton_set|)))
(assert (forall ((e1 option<array>) (e2 option<array>)) (!
  (= (Set_in e1 (Set_singleton e2)) (= e1 e2))
  :pattern ((Set_in e1 (Set_singleton e2)))
  :qid |$Set[option[array]]_prog.in_singleton_set_equality|)))
(assert (forall ((e option<array>)) (!
  (= (Set_card (Set_singleton e)) 1)
  :pattern ((Set_card (Set_singleton e)))
  :qid |$Set[option[array]]_prog.singleton_set_cardinality|)))
(assert (forall ((s Set<option<array>>) (e option<array>)) (!
  (Set_in e (Set_unionone s e))
  :pattern ((Set_unionone s e))
  :qid |$Set[option[array]]_prog.in_unionone_same|)))
(assert (forall ((s Set<option<array>>) (e1 option<array>) (e2 option<array>)) (!
  (= (Set_in e1 (Set_unionone s e2)) (or (= e1 e2) (Set_in e1 s)))
  :pattern ((Set_in e1 (Set_unionone s e2)))
  :qid |$Set[option[array]]_prog.in_unionone_other|)))
(assert (forall ((s Set<option<array>>) (e1 option<array>) (e2 option<array>)) (!
  (implies (Set_in e1 s) (Set_in e1 (Set_unionone s e2)))
  :pattern ((Set_in e1 s) (Set_unionone s e2))
  :qid |$Set[option[array]]_prog.invariance_in_unionone|)))
(assert (forall ((s Set<option<array>>) (e option<array>)) (!
  (implies (Set_in e s) (= (Set_card (Set_unionone s e)) (Set_card s)))
  :pattern ((Set_card (Set_unionone s e)))
  :qid |$Set[option[array]]_prog.unionone_cardinality_invariant|)))
(assert (forall ((s Set<option<array>>) (e option<array>)) (!
  (implies
    (not (Set_in e s))
    (= (Set_card (Set_unionone s e)) (+ (Set_card s) 1)))
  :pattern ((Set_card (Set_unionone s e)))
  :qid |$Set[option[array]]_prog.unionone_cardinality_changed|)))
(assert (forall ((s1 Set<option<array>>) (s2 Set<option<array>>) (e option<array>)) (!
  (= (Set_in e (Set_union s1 s2)) (or (Set_in e s1) (Set_in e s2)))
  :pattern ((Set_in e (Set_union s1 s2)))
  :qid |$Set[option[array]]_prog.in_union_in_one|)))
(assert (forall ((s1 Set<option<array>>) (s2 Set<option<array>>) (e option<array>)) (!
  (implies (Set_in e s1) (Set_in e (Set_union s1 s2)))
  :pattern ((Set_in e s1) (Set_union s1 s2))
  :qid |$Set[option[array]]_prog.in_left_in_union|)))
(assert (forall ((s1 Set<option<array>>) (s2 Set<option<array>>) (e option<array>)) (!
  (implies (Set_in e s2) (Set_in e (Set_union s1 s2)))
  :pattern ((Set_in e s2) (Set_union s1 s2))
  :qid |$Set[option[array]]_prog.in_right_in_union|)))
(assert (forall ((s1 Set<option<array>>) (s2 Set<option<array>>) (e option<array>)) (!
  (= (Set_in e (Set_intersection s1 s2)) (and (Set_in e s1) (Set_in e s2)))
  :pattern ((Set_in e (Set_intersection s1 s2)))
  :pattern ((Set_intersection s1 s2) (Set_in e s1))
  :pattern ((Set_intersection s1 s2) (Set_in e s2))
  :qid |$Set[option[array]]_prog.in_intersection_in_both|)))
(assert (forall ((s1 Set<option<array>>) (s2 Set<option<array>>)) (!
  (= (Set_union s1 (Set_union s1 s2)) (Set_union s1 s2))
  :pattern ((Set_union s1 (Set_union s1 s2)))
  :qid |$Set[option[array]]_prog.union_left_idempotency|)))
(assert (forall ((s1 Set<option<array>>) (s2 Set<option<array>>)) (!
  (= (Set_union (Set_union s1 s2) s2) (Set_union s1 s2))
  :pattern ((Set_union (Set_union s1 s2) s2))
  :qid |$Set[option[array]]_prog.union_right_idempotency|)))
(assert (forall ((s1 Set<option<array>>) (s2 Set<option<array>>)) (!
  (= (Set_intersection s1 (Set_intersection s1 s2)) (Set_intersection s1 s2))
  :pattern ((Set_intersection s1 (Set_intersection s1 s2)))
  :qid |$Set[option[array]]_prog.intersection_left_idempotency|)))
(assert (forall ((s1 Set<option<array>>) (s2 Set<option<array>>)) (!
  (= (Set_intersection (Set_intersection s1 s2) s2) (Set_intersection s1 s2))
  :pattern ((Set_intersection (Set_intersection s1 s2) s2))
  :qid |$Set[option[array]]_prog.intersection_right_idempotency|)))
(assert (forall ((s1 Set<option<array>>) (s2 Set<option<array>>)) (!
  (=
    (+ (Set_card (Set_union s1 s2)) (Set_card (Set_intersection s1 s2)))
    (+ (Set_card s1) (Set_card s2)))
  :pattern ((Set_card (Set_union s1 s2)))
  :pattern ((Set_card (Set_intersection s1 s2)))
  :qid |$Set[option[array]]_prog.cardinality_sums|)))
(assert (forall ((s1 Set<option<array>>) (s2 Set<option<array>>) (e option<array>)) (!
  (= (Set_in e (Set_difference s1 s2)) (and (Set_in e s1) (not (Set_in e s2))))
  :pattern ((Set_in e (Set_difference s1 s2)))
  :qid |$Set[option[array]]_prog.in_difference|)))
(assert (forall ((s1 Set<option<array>>) (s2 Set<option<array>>) (e option<array>)) (!
  (implies (Set_in e s2) (not (Set_in e (Set_difference s1 s2))))
  :pattern ((Set_difference s1 s2) (Set_in e s2))
  :qid |$Set[option[array]]_prog.not_in_difference|)))
(assert (forall ((s1 Set<option<array>>) (s2 Set<option<array>>)) (!
  (=
    (Set_subset s1 s2)
    (forall ((e option<array>)) (!
      (implies (Set_in e s1) (Set_in e s2))
      :pattern ((Set_in e s1))
      :pattern ((Set_in e s2))
      )))
  :pattern ((Set_subset s1 s2))
  :qid |$Set[option[array]]_prog.subset_definition|)))
(assert (forall ((s1 Set<option<array>>) (s2 Set<option<array>>)) (!
  (=
    (Set_equal s1 s2)
    (forall ((e option<array>)) (!
      (= (Set_in e s1) (Set_in e s2))
      :pattern ((Set_in e s1))
      :pattern ((Set_in e s2))
      )))
  :pattern ((Set_equal s1 s2))
  :qid |$Set[option[array]]_prog.equality_definition|)))
(assert (forall ((s1 Set<option<array>>) (s2 Set<option<array>>)) (!
  (implies (Set_equal s1 s2) (= s1 s2))
  :pattern ((Set_equal s1 s2))
  :qid |$Set[option[array]]_prog.native_equality|)))
(assert (forall ((s1 Set<option<array>>) (s2 Set<option<array>>)) (!
  (=
    (Set_disjoint s1 s2)
    (forall ((e option<array>)) (!
      (or (not (Set_in e s1)) (not (Set_in e s2)))
      :pattern ((Set_in e s1))
      :pattern ((Set_in e s2))
      )))
  :pattern ((Set_disjoint s1 s2))
  :qid |$Set[option[array]]_prog.disjointness_definition|)))
(assert (forall ((s1 Set<option<array>>) (s2 Set<option<array>>)) (!
  (and
    (=
      (+
        (+ (Set_card (Set_difference s1 s2)) (Set_card (Set_difference s2 s1)))
        (Set_card (Set_intersection s1 s2)))
      (Set_card (Set_union s1 s2)))
    (=
      (Set_card (Set_difference s1 s2))
      (- (Set_card s1) (Set_card (Set_intersection s1 s2)))))
  :pattern ((Set_card (Set_difference s1 s2)))
  :qid |$Set[option[array]]_prog.cardinality_difference|)))
(assert (forall ((s Set<$Ref>)) (!
  (<= 0 (Set_card s))
  :pattern ((Set_card s))
  :qid |$Set[Ref]_prog.card_non_negative|)))
(assert (forall ((e $Ref)) (!
  (not (Set_in e (as Set_empty  Set<$Ref>)))
  :pattern ((Set_in e (as Set_empty  Set<$Ref>)))
  :qid |$Set[Ref]_prog.in_empty_set|)))
(assert (forall ((s Set<$Ref>)) (!
  (and
    (= (= (Set_card s) 0) (= s (as Set_empty  Set<$Ref>)))
    (implies
      (not (= (Set_card s) 0))
      (exists ((e $Ref)) (!
        (Set_in e s)
        :pattern ((Set_in e s))
        ))))
  :pattern ((Set_card s))
  :qid |$Set[Ref]_prog.empty_set_cardinality|)))
(assert (forall ((e $Ref)) (!
  (Set_in e (Set_singleton e))
  :pattern ((Set_singleton e))
  :qid |$Set[Ref]_prog.in_singleton_set|)))
(assert (forall ((e1 $Ref) (e2 $Ref)) (!
  (= (Set_in e1 (Set_singleton e2)) (= e1 e2))
  :pattern ((Set_in e1 (Set_singleton e2)))
  :qid |$Set[Ref]_prog.in_singleton_set_equality|)))
(assert (forall ((e $Ref)) (!
  (= (Set_card (Set_singleton e)) 1)
  :pattern ((Set_card (Set_singleton e)))
  :qid |$Set[Ref]_prog.singleton_set_cardinality|)))
(assert (forall ((s Set<$Ref>) (e $Ref)) (!
  (Set_in e (Set_unionone s e))
  :pattern ((Set_unionone s e))
  :qid |$Set[Ref]_prog.in_unionone_same|)))
(assert (forall ((s Set<$Ref>) (e1 $Ref) (e2 $Ref)) (!
  (= (Set_in e1 (Set_unionone s e2)) (or (= e1 e2) (Set_in e1 s)))
  :pattern ((Set_in e1 (Set_unionone s e2)))
  :qid |$Set[Ref]_prog.in_unionone_other|)))
(assert (forall ((s Set<$Ref>) (e1 $Ref) (e2 $Ref)) (!
  (implies (Set_in e1 s) (Set_in e1 (Set_unionone s e2)))
  :pattern ((Set_in e1 s) (Set_unionone s e2))
  :qid |$Set[Ref]_prog.invariance_in_unionone|)))
(assert (forall ((s Set<$Ref>) (e $Ref)) (!
  (implies (Set_in e s) (= (Set_card (Set_unionone s e)) (Set_card s)))
  :pattern ((Set_card (Set_unionone s e)))
  :qid |$Set[Ref]_prog.unionone_cardinality_invariant|)))
(assert (forall ((s Set<$Ref>) (e $Ref)) (!
  (implies
    (not (Set_in e s))
    (= (Set_card (Set_unionone s e)) (+ (Set_card s) 1)))
  :pattern ((Set_card (Set_unionone s e)))
  :qid |$Set[Ref]_prog.unionone_cardinality_changed|)))
(assert (forall ((s1 Set<$Ref>) (s2 Set<$Ref>) (e $Ref)) (!
  (= (Set_in e (Set_union s1 s2)) (or (Set_in e s1) (Set_in e s2)))
  :pattern ((Set_in e (Set_union s1 s2)))
  :qid |$Set[Ref]_prog.in_union_in_one|)))
(assert (forall ((s1 Set<$Ref>) (s2 Set<$Ref>) (e $Ref)) (!
  (implies (Set_in e s1) (Set_in e (Set_union s1 s2)))
  :pattern ((Set_in e s1) (Set_union s1 s2))
  :qid |$Set[Ref]_prog.in_left_in_union|)))
(assert (forall ((s1 Set<$Ref>) (s2 Set<$Ref>) (e $Ref)) (!
  (implies (Set_in e s2) (Set_in e (Set_union s1 s2)))
  :pattern ((Set_in e s2) (Set_union s1 s2))
  :qid |$Set[Ref]_prog.in_right_in_union|)))
(assert (forall ((s1 Set<$Ref>) (s2 Set<$Ref>) (e $Ref)) (!
  (= (Set_in e (Set_intersection s1 s2)) (and (Set_in e s1) (Set_in e s2)))
  :pattern ((Set_in e (Set_intersection s1 s2)))
  :pattern ((Set_intersection s1 s2) (Set_in e s1))
  :pattern ((Set_intersection s1 s2) (Set_in e s2))
  :qid |$Set[Ref]_prog.in_intersection_in_both|)))
(assert (forall ((s1 Set<$Ref>) (s2 Set<$Ref>)) (!
  (= (Set_union s1 (Set_union s1 s2)) (Set_union s1 s2))
  :pattern ((Set_union s1 (Set_union s1 s2)))
  :qid |$Set[Ref]_prog.union_left_idempotency|)))
(assert (forall ((s1 Set<$Ref>) (s2 Set<$Ref>)) (!
  (= (Set_union (Set_union s1 s2) s2) (Set_union s1 s2))
  :pattern ((Set_union (Set_union s1 s2) s2))
  :qid |$Set[Ref]_prog.union_right_idempotency|)))
(assert (forall ((s1 Set<$Ref>) (s2 Set<$Ref>)) (!
  (= (Set_intersection s1 (Set_intersection s1 s2)) (Set_intersection s1 s2))
  :pattern ((Set_intersection s1 (Set_intersection s1 s2)))
  :qid |$Set[Ref]_prog.intersection_left_idempotency|)))
(assert (forall ((s1 Set<$Ref>) (s2 Set<$Ref>)) (!
  (= (Set_intersection (Set_intersection s1 s2) s2) (Set_intersection s1 s2))
  :pattern ((Set_intersection (Set_intersection s1 s2) s2))
  :qid |$Set[Ref]_prog.intersection_right_idempotency|)))
(assert (forall ((s1 Set<$Ref>) (s2 Set<$Ref>)) (!
  (=
    (+ (Set_card (Set_union s1 s2)) (Set_card (Set_intersection s1 s2)))
    (+ (Set_card s1) (Set_card s2)))
  :pattern ((Set_card (Set_union s1 s2)))
  :pattern ((Set_card (Set_intersection s1 s2)))
  :qid |$Set[Ref]_prog.cardinality_sums|)))
(assert (forall ((s1 Set<$Ref>) (s2 Set<$Ref>) (e $Ref)) (!
  (= (Set_in e (Set_difference s1 s2)) (and (Set_in e s1) (not (Set_in e s2))))
  :pattern ((Set_in e (Set_difference s1 s2)))
  :qid |$Set[Ref]_prog.in_difference|)))
(assert (forall ((s1 Set<$Ref>) (s2 Set<$Ref>) (e $Ref)) (!
  (implies (Set_in e s2) (not (Set_in e (Set_difference s1 s2))))
  :pattern ((Set_difference s1 s2) (Set_in e s2))
  :qid |$Set[Ref]_prog.not_in_difference|)))
(assert (forall ((s1 Set<$Ref>) (s2 Set<$Ref>)) (!
  (=
    (Set_subset s1 s2)
    (forall ((e $Ref)) (!
      (implies (Set_in e s1) (Set_in e s2))
      :pattern ((Set_in e s1))
      :pattern ((Set_in e s2))
      )))
  :pattern ((Set_subset s1 s2))
  :qid |$Set[Ref]_prog.subset_definition|)))
(assert (forall ((s1 Set<$Ref>) (s2 Set<$Ref>)) (!
  (=
    (Set_equal s1 s2)
    (forall ((e $Ref)) (!
      (= (Set_in e s1) (Set_in e s2))
      :pattern ((Set_in e s1))
      :pattern ((Set_in e s2))
      )))
  :pattern ((Set_equal s1 s2))
  :qid |$Set[Ref]_prog.equality_definition|)))
(assert (forall ((s1 Set<$Ref>) (s2 Set<$Ref>)) (!
  (implies (Set_equal s1 s2) (= s1 s2))
  :pattern ((Set_equal s1 s2))
  :qid |$Set[Ref]_prog.native_equality|)))
(assert (forall ((s1 Set<$Ref>) (s2 Set<$Ref>)) (!
  (=
    (Set_disjoint s1 s2)
    (forall ((e $Ref)) (!
      (or (not (Set_in e s1)) (not (Set_in e s2)))
      :pattern ((Set_in e s1))
      :pattern ((Set_in e s2))
      )))
  :pattern ((Set_disjoint s1 s2))
  :qid |$Set[Ref]_prog.disjointness_definition|)))
(assert (forall ((s1 Set<$Ref>) (s2 Set<$Ref>)) (!
  (and
    (=
      (+
        (+ (Set_card (Set_difference s1 s2)) (Set_card (Set_difference s2 s1)))
        (Set_card (Set_intersection s1 s2)))
      (Set_card (Set_union s1 s2)))
    (=
      (Set_card (Set_difference s1 s2))
      (- (Set_card s1) (Set_card (Set_intersection s1 s2)))))
  :pattern ((Set_card (Set_difference s1 s2)))
  :qid |$Set[Ref]_prog.cardinality_difference|)))
(assert (forall ((s Set<$Snap>)) (!
  (<= 0 (Set_card s))
  :pattern ((Set_card s))
  :qid |$Set[Snap]_prog.card_non_negative|)))
(assert (forall ((e $Snap)) (!
  (not (Set_in e (as Set_empty  Set<$Snap>)))
  :pattern ((Set_in e (as Set_empty  Set<$Snap>)))
  :qid |$Set[Snap]_prog.in_empty_set|)))
(assert (forall ((s Set<$Snap>)) (!
  (and
    (= (= (Set_card s) 0) (= s (as Set_empty  Set<$Snap>)))
    (implies
      (not (= (Set_card s) 0))
      (exists ((e $Snap)) (!
        (Set_in e s)
        :pattern ((Set_in e s))
        ))))
  :pattern ((Set_card s))
  :qid |$Set[Snap]_prog.empty_set_cardinality|)))
(assert (forall ((e $Snap)) (!
  (Set_in e (Set_singleton e))
  :pattern ((Set_singleton e))
  :qid |$Set[Snap]_prog.in_singleton_set|)))
(assert (forall ((e1 $Snap) (e2 $Snap)) (!
  (= (Set_in e1 (Set_singleton e2)) (= e1 e2))
  :pattern ((Set_in e1 (Set_singleton e2)))
  :qid |$Set[Snap]_prog.in_singleton_set_equality|)))
(assert (forall ((e $Snap)) (!
  (= (Set_card (Set_singleton e)) 1)
  :pattern ((Set_card (Set_singleton e)))
  :qid |$Set[Snap]_prog.singleton_set_cardinality|)))
(assert (forall ((s Set<$Snap>) (e $Snap)) (!
  (Set_in e (Set_unionone s e))
  :pattern ((Set_unionone s e))
  :qid |$Set[Snap]_prog.in_unionone_same|)))
(assert (forall ((s Set<$Snap>) (e1 $Snap) (e2 $Snap)) (!
  (= (Set_in e1 (Set_unionone s e2)) (or (= e1 e2) (Set_in e1 s)))
  :pattern ((Set_in e1 (Set_unionone s e2)))
  :qid |$Set[Snap]_prog.in_unionone_other|)))
(assert (forall ((s Set<$Snap>) (e1 $Snap) (e2 $Snap)) (!
  (implies (Set_in e1 s) (Set_in e1 (Set_unionone s e2)))
  :pattern ((Set_in e1 s) (Set_unionone s e2))
  :qid |$Set[Snap]_prog.invariance_in_unionone|)))
(assert (forall ((s Set<$Snap>) (e $Snap)) (!
  (implies (Set_in e s) (= (Set_card (Set_unionone s e)) (Set_card s)))
  :pattern ((Set_card (Set_unionone s e)))
  :qid |$Set[Snap]_prog.unionone_cardinality_invariant|)))
(assert (forall ((s Set<$Snap>) (e $Snap)) (!
  (implies
    (not (Set_in e s))
    (= (Set_card (Set_unionone s e)) (+ (Set_card s) 1)))
  :pattern ((Set_card (Set_unionone s e)))
  :qid |$Set[Snap]_prog.unionone_cardinality_changed|)))
(assert (forall ((s1 Set<$Snap>) (s2 Set<$Snap>) (e $Snap)) (!
  (= (Set_in e (Set_union s1 s2)) (or (Set_in e s1) (Set_in e s2)))
  :pattern ((Set_in e (Set_union s1 s2)))
  :qid |$Set[Snap]_prog.in_union_in_one|)))
(assert (forall ((s1 Set<$Snap>) (s2 Set<$Snap>) (e $Snap)) (!
  (implies (Set_in e s1) (Set_in e (Set_union s1 s2)))
  :pattern ((Set_in e s1) (Set_union s1 s2))
  :qid |$Set[Snap]_prog.in_left_in_union|)))
(assert (forall ((s1 Set<$Snap>) (s2 Set<$Snap>) (e $Snap)) (!
  (implies (Set_in e s2) (Set_in e (Set_union s1 s2)))
  :pattern ((Set_in e s2) (Set_union s1 s2))
  :qid |$Set[Snap]_prog.in_right_in_union|)))
(assert (forall ((s1 Set<$Snap>) (s2 Set<$Snap>) (e $Snap)) (!
  (= (Set_in e (Set_intersection s1 s2)) (and (Set_in e s1) (Set_in e s2)))
  :pattern ((Set_in e (Set_intersection s1 s2)))
  :pattern ((Set_intersection s1 s2) (Set_in e s1))
  :pattern ((Set_intersection s1 s2) (Set_in e s2))
  :qid |$Set[Snap]_prog.in_intersection_in_both|)))
(assert (forall ((s1 Set<$Snap>) (s2 Set<$Snap>)) (!
  (= (Set_union s1 (Set_union s1 s2)) (Set_union s1 s2))
  :pattern ((Set_union s1 (Set_union s1 s2)))
  :qid |$Set[Snap]_prog.union_left_idempotency|)))
(assert (forall ((s1 Set<$Snap>) (s2 Set<$Snap>)) (!
  (= (Set_union (Set_union s1 s2) s2) (Set_union s1 s2))
  :pattern ((Set_union (Set_union s1 s2) s2))
  :qid |$Set[Snap]_prog.union_right_idempotency|)))
(assert (forall ((s1 Set<$Snap>) (s2 Set<$Snap>)) (!
  (= (Set_intersection s1 (Set_intersection s1 s2)) (Set_intersection s1 s2))
  :pattern ((Set_intersection s1 (Set_intersection s1 s2)))
  :qid |$Set[Snap]_prog.intersection_left_idempotency|)))
(assert (forall ((s1 Set<$Snap>) (s2 Set<$Snap>)) (!
  (= (Set_intersection (Set_intersection s1 s2) s2) (Set_intersection s1 s2))
  :pattern ((Set_intersection (Set_intersection s1 s2) s2))
  :qid |$Set[Snap]_prog.intersection_right_idempotency|)))
(assert (forall ((s1 Set<$Snap>) (s2 Set<$Snap>)) (!
  (=
    (+ (Set_card (Set_union s1 s2)) (Set_card (Set_intersection s1 s2)))
    (+ (Set_card s1) (Set_card s2)))
  :pattern ((Set_card (Set_union s1 s2)))
  :pattern ((Set_card (Set_intersection s1 s2)))
  :qid |$Set[Snap]_prog.cardinality_sums|)))
(assert (forall ((s1 Set<$Snap>) (s2 Set<$Snap>) (e $Snap)) (!
  (= (Set_in e (Set_difference s1 s2)) (and (Set_in e s1) (not (Set_in e s2))))
  :pattern ((Set_in e (Set_difference s1 s2)))
  :qid |$Set[Snap]_prog.in_difference|)))
(assert (forall ((s1 Set<$Snap>) (s2 Set<$Snap>) (e $Snap)) (!
  (implies (Set_in e s2) (not (Set_in e (Set_difference s1 s2))))
  :pattern ((Set_difference s1 s2) (Set_in e s2))
  :qid |$Set[Snap]_prog.not_in_difference|)))
(assert (forall ((s1 Set<$Snap>) (s2 Set<$Snap>)) (!
  (=
    (Set_subset s1 s2)
    (forall ((e $Snap)) (!
      (implies (Set_in e s1) (Set_in e s2))
      :pattern ((Set_in e s1))
      :pattern ((Set_in e s2))
      )))
  :pattern ((Set_subset s1 s2))
  :qid |$Set[Snap]_prog.subset_definition|)))
(assert (forall ((s1 Set<$Snap>) (s2 Set<$Snap>)) (!
  (=
    (Set_equal s1 s2)
    (forall ((e $Snap)) (!
      (= (Set_in e s1) (Set_in e s2))
      :pattern ((Set_in e s1))
      :pattern ((Set_in e s2))
      )))
  :pattern ((Set_equal s1 s2))
  :qid |$Set[Snap]_prog.equality_definition|)))
(assert (forall ((s1 Set<$Snap>) (s2 Set<$Snap>)) (!
  (implies (Set_equal s1 s2) (= s1 s2))
  :pattern ((Set_equal s1 s2))
  :qid |$Set[Snap]_prog.native_equality|)))
(assert (forall ((s1 Set<$Snap>) (s2 Set<$Snap>)) (!
  (=
    (Set_disjoint s1 s2)
    (forall ((e $Snap)) (!
      (or (not (Set_in e s1)) (not (Set_in e s2)))
      :pattern ((Set_in e s1))
      :pattern ((Set_in e s2))
      )))
  :pattern ((Set_disjoint s1 s2))
  :qid |$Set[Snap]_prog.disjointness_definition|)))
(assert (forall ((s1 Set<$Snap>) (s2 Set<$Snap>)) (!
  (and
    (=
      (+
        (+ (Set_card (Set_difference s1 s2)) (Set_card (Set_difference s2 s1)))
        (Set_card (Set_intersection s1 s2)))
      (Set_card (Set_union s1 s2)))
    (=
      (Set_card (Set_difference s1 s2))
      (- (Set_card s1) (Set_card (Set_intersection s1 s2)))))
  :pattern ((Set_card (Set_difference s1 s2)))
  :qid |$Set[Snap]_prog.cardinality_difference|)))
(assert (forall ((a2 array)) (!
  (forall ((i1 Int)) (!
    (and
      (= (loc_inv_1<array> (array_loc<Ref> a2 i1)) a2)
      (= (loc_inv_2<Int> (array_loc<Ref> a2 i1)) i1))
    :pattern ((loc_inv_1<array> (array_loc<Ref> a2 i1)))
    :pattern ((loc_inv_2<Int> (array_loc<Ref> a2 i1)))
    ))
  
  )))
(assert (forall ((a2 array)) (!
  (>= (alen<Int> a2) 0)
  :pattern ((alen<Int> a2))
  )))
(assert (forall ((x1 array)) (!
  (not (= (as None<option<array>>  option<array>) (some<option<array>> x1)))
  :pattern ((some<option<array>> x1))
  )))
(assert (forall ((x1 array)) (!
  (= (option_get<array> (some<option<array>> x1)) x1)
  :pattern ((option_get<array> (some<option<array>> x1)))
  )))
(assert (forall ((opt1 option<array>)) (!
  (= (some<option<array>> (option_get<array> opt1)) opt1)
  :pattern ((some<option<array>> (option_get<array> opt1)))
  )))
(assert (forall ((v t_null)) (!
  (= (as v_null<t_null>  t_null) v)
  
  )))
(assert (forall ((x1 any)) (!
  (not (= (as None<option<any>>  option<any>) (some<option<any>> x1)))
  :pattern ((some<option<any>> x1))
  )))
(assert (forall ((x1 any)) (!
  (= (option_get<any> (some<option<any>> x1)) x1)
  :pattern ((option_get<any> (some<option<any>> x1)))
  )))
(assert (forall ((opt1 option<any>)) (!
  (= (some<option<any>> (option_get<any> opt1)) opt1)
  :pattern ((some<option<any>> (option_get<any> opt1)))
  )))
(assert (forall ((v void)) (!
  (= (as unit<void>  void) v)
  
  )))
; /field_value_functions_axioms.smt2 [int: Int]
(assert (forall ((vs $FVF<Int>) (ws $FVF<Int>)) (!
    (implies
      (and
        (Set_equal ($FVF.domain_int vs) ($FVF.domain_int ws))
        (forall ((x $Ref)) (!
          (implies
            (Set_in x ($FVF.domain_int vs))
            (= ($FVF.lookup_int vs x) ($FVF.lookup_int ws x)))
          :pattern (($FVF.lookup_int vs x) ($FVF.lookup_int ws x))
          :qid |qp.$FVF<Int>-eq-inner|
          )))
      (= vs ws))
    :pattern (($SortWrappers.$FVF<Int>To$Snap vs)
              ($SortWrappers.$FVF<Int>To$Snap ws)
              )
    :qid |qp.$FVF<Int>-eq-outer|
    )))
(assert (forall ((r $Ref) (pm $FPM)) (!
    ($Perm.isValidVar ($FVF.perm_int pm r))
    :pattern ($FVF.perm_int pm r))))
(assert (forall ((r $Ref) (f Int)) (!
    (= ($FVF.loc_int f r) true)
    :pattern ($FVF.loc_int f r))))
; /field_value_functions_axioms.smt2 [option$array$: option[array]]
(assert (forall ((vs $FVF<option<array>>) (ws $FVF<option<array>>)) (!
    (implies
      (and
        (Set_equal ($FVF.domain_option$array$ vs) ($FVF.domain_option$array$ ws))
        (forall ((x $Ref)) (!
          (implies
            (Set_in x ($FVF.domain_option$array$ vs))
            (= ($FVF.lookup_option$array$ vs x) ($FVF.lookup_option$array$ ws x)))
          :pattern (($FVF.lookup_option$array$ vs x) ($FVF.lookup_option$array$ ws x))
          :qid |qp.$FVF<option<array>>-eq-inner|
          )))
      (= vs ws))
    :pattern (($SortWrappers.$FVF<option<array>>To$Snap vs)
              ($SortWrappers.$FVF<option<array>>To$Snap ws)
              )
    :qid |qp.$FVF<option<array>>-eq-outer|
    )))
(assert (forall ((r $Ref) (pm $FPM)) (!
    ($Perm.isValidVar ($FVF.perm_option$array$ pm r))
    :pattern ($FVF.perm_option$array$ pm r))))
(assert (forall ((r $Ref) (f option<array>)) (!
    (= ($FVF.loc_option$array$ f r) true)
    :pattern ($FVF.loc_option$array$ f r))))
; /field_value_functions_axioms.smt2 [bool: Bool]
(assert (forall ((vs $FVF<Bool>) (ws $FVF<Bool>)) (!
    (implies
      (and
        (Set_equal ($FVF.domain_bool vs) ($FVF.domain_bool ws))
        (forall ((x $Ref)) (!
          (implies
            (Set_in x ($FVF.domain_bool vs))
            (= ($FVF.lookup_bool vs x) ($FVF.lookup_bool ws x)))
          :pattern (($FVF.lookup_bool vs x) ($FVF.lookup_bool ws x))
          :qid |qp.$FVF<Bool>-eq-inner|
          )))
      (= vs ws))
    :pattern (($SortWrappers.$FVF<Bool>To$Snap vs)
              ($SortWrappers.$FVF<Bool>To$Snap ws)
              )
    :qid |qp.$FVF<Bool>-eq-outer|
    )))
(assert (forall ((r $Ref) (pm $FPM)) (!
    ($Perm.isValidVar ($FVF.perm_bool pm r))
    :pattern ($FVF.perm_bool pm r))))
(assert (forall ((r $Ref) (f Bool)) (!
    (= ($FVF.loc_bool f r) true)
    :pattern ($FVF.loc_bool f r))))
; End preamble
; ------------------------------------------------------------
; State saturation: after preamble
(set-option :timeout 100)
(check-sat)
; unknown
; ---------- FUNCTION SquareIntMatrix----------
(declare-fun this@0@00 () $Ref)
(declare-fun G@1@00 () Seq<Seq<Int>>)
(declare-fun V@2@00 () Int)
(declare-fun result@3@00 () Bool)
; ----- Well-definedness of specifications -----
(push) ; 1
(assert (= s@$ $Snap.unit))
; [eval] this != null
(assert (not (= this@0@00 $Ref.null)))
(pop) ; 1
(assert (forall ((s@$ $Snap) (this@0@00 $Ref) (G@1@00 Seq<Seq<Int>>) (V@2@00 Int)) (!
  (=
    (SquareIntMatrix%limited s@$ this@0@00 G@1@00 V@2@00)
    (SquareIntMatrix s@$ this@0@00 G@1@00 V@2@00))
  :pattern ((SquareIntMatrix s@$ this@0@00 G@1@00 V@2@00))
  )))
(assert (forall ((s@$ $Snap) (this@0@00 $Ref) (G@1@00 Seq<Seq<Int>>) (V@2@00 Int)) (!
  (SquareIntMatrix%stateless this@0@00 G@1@00 V@2@00)
  :pattern ((SquareIntMatrix%limited s@$ this@0@00 G@1@00 V@2@00))
  )))
; ----- Verification of function body and postcondition -----
(push) ; 1
(assert (= s@$ $Snap.unit))
(assert (not (= this@0@00 $Ref.null)))
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
; [eval] |G| == V && (forall e: Seq[Int] :: { (e in G) } { |e| } (e in G) ==> |e| == V)
; [eval] |G| == V
; [eval] |G|
(push) ; 2
; [then-branch: 0 | |G@1@00| == V@2@00 | live]
; [else-branch: 0 | |G@1@00| != V@2@00 | live]
(push) ; 3
; [then-branch: 0 | |G@1@00| == V@2@00]
(assert (= (Seq_length G@1@00) V@2@00))
; [eval] (forall e: Seq[Int] :: { (e in G) } { |e| } (e in G) ==> |e| == V)
(declare-const e@108@00 Seq<Int>)
(push) ; 4
; [eval] (e in G) ==> |e| == V
; [eval] (e in G)
(push) ; 5
; [then-branch: 1 | e@108@00 in G@1@00 | live]
; [else-branch: 1 | !(e@108@00 in G@1@00) | live]
(push) ; 6
; [then-branch: 1 | e@108@00 in G@1@00]
(assert (Seq_contains G@1@00 e@108@00))
; [eval] |e| == V
; [eval] |e|
(pop) ; 6
(push) ; 6
; [else-branch: 1 | !(e@108@00 in G@1@00)]
(assert (not (Seq_contains G@1@00 e@108@00)))
(pop) ; 6
(pop) ; 5
; Joined path conditions
; Joined path conditions
(pop) ; 4
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 3
(push) ; 3
; [else-branch: 0 | |G@1@00| != V@2@00]
(assert (not (= (Seq_length G@1@00) V@2@00)))
(pop) ; 3
(pop) ; 2
; Joined path conditions
; Joined path conditions
(assert (=
  result@3@00
  (and
    (forall ((e@108@00 Seq<Int>)) (!
      (implies (Seq_contains G@1@00 e@108@00) (= (Seq_length e@108@00) V@2@00))
      :pattern ((Seq_contains G@1@00 e@108@00))
      :pattern ((Seq_length e@108@00))
      :qid |prog.l<no position>|))
    (= (Seq_length G@1@00) V@2@00))))
(pop) ; 1
(assert (forall ((s@$ $Snap) (this@0@00 $Ref) (G@1@00 Seq<Seq<Int>>) (V@2@00 Int)) (!
  (implies
    (not (= this@0@00 $Ref.null))
    (=
      (SquareIntMatrix s@$ this@0@00 G@1@00 V@2@00)
      (and
        (= (Seq_length G@1@00) V@2@00)
        (forall ((e Seq<Int>)) (!
          (implies (Seq_contains G@1@00 e) (= (Seq_length e) V@2@00))
          :pattern ((Seq_contains G@1@00 e))
          :pattern ((Seq_length e))
          )))))
  :pattern ((SquareIntMatrix s@$ this@0@00 G@1@00 V@2@00))
  )))
; ---------- FUNCTION NonNegativeCapacities----------
(declare-fun this@4@00 () $Ref)
(declare-fun G@5@00 () Seq<Seq<Int>>)
(declare-fun V@6@00 () Int)
(declare-fun result@7@00 () Bool)
; ----- Well-definedness of specifications -----
(push) ; 1
(assert (= s@$ ($Snap.combine ($Snap.first s@$) ($Snap.second s@$))))
(assert (= ($Snap.first s@$) $Snap.unit))
; [eval] this != null
(assert (not (= this@4@00 $Ref.null)))
(assert (= ($Snap.second s@$) $Snap.unit))
; [eval] SquareIntMatrix(this, G, V)
(push) ; 2
; [eval] this != null
(pop) ; 2
; Joined path conditions
(assert (SquareIntMatrix $Snap.unit this@4@00 G@5@00 V@6@00))
(pop) ; 1
(assert (forall ((s@$ $Snap) (this@4@00 $Ref) (G@5@00 Seq<Seq<Int>>) (V@6@00 Int)) (!
  (=
    (NonNegativeCapacities%limited s@$ this@4@00 G@5@00 V@6@00)
    (NonNegativeCapacities s@$ this@4@00 G@5@00 V@6@00))
  :pattern ((NonNegativeCapacities s@$ this@4@00 G@5@00 V@6@00))
  )))
(assert (forall ((s@$ $Snap) (this@4@00 $Ref) (G@5@00 Seq<Seq<Int>>) (V@6@00 Int)) (!
  (NonNegativeCapacities%stateless this@4@00 G@5@00 V@6@00)
  :pattern ((NonNegativeCapacities%limited s@$ this@4@00 G@5@00 V@6@00))
  )))
; ----- Verification of function body and postcondition -----
(push) ; 1
(assert (= s@$ ($Snap.combine ($Snap.first s@$) ($Snap.second s@$))))
(assert (= ($Snap.first s@$) $Snap.unit))
(assert (not (= this@4@00 $Ref.null)))
(assert (= ($Snap.second s@$) $Snap.unit))
(assert (SquareIntMatrix $Snap.unit this@4@00 G@5@00 V@6@00))
; State saturation: after contract
(check-sat)
; unknown
; [eval] (forall i1: Int :: { G[i1] } 0 <= i1 && i1 < V ==> (forall j: Int :: { G[i1][j] } 0 <= j && j < V ==> 0 < G[i1][j]))
(declare-const i1@109@00 Int)
(push) ; 2
; [eval] 0 <= i1 && i1 < V ==> (forall j: Int :: { G[i1][j] } 0 <= j && j < V ==> 0 < G[i1][j])
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 3
; [then-branch: 2 | 0 <= i1@109@00 | live]
; [else-branch: 2 | !(0 <= i1@109@00) | live]
(push) ; 4
; [then-branch: 2 | 0 <= i1@109@00]
(assert (<= 0 i1@109@00))
; [eval] i1 < V
(pop) ; 4
(push) ; 4
; [else-branch: 2 | !(0 <= i1@109@00)]
(assert (not (<= 0 i1@109@00)))
(pop) ; 4
(pop) ; 3
; Joined path conditions
; Joined path conditions
(push) ; 3
; [then-branch: 3 | i1@109@00 < V@6@00 && 0 <= i1@109@00 | live]
; [else-branch: 3 | !(i1@109@00 < V@6@00 && 0 <= i1@109@00) | live]
(push) ; 4
; [then-branch: 3 | i1@109@00 < V@6@00 && 0 <= i1@109@00]
(assert (and (< i1@109@00 V@6@00) (<= 0 i1@109@00)))
; [eval] (forall j: Int :: { G[i1][j] } 0 <= j && j < V ==> 0 < G[i1][j])
(declare-const j@110@00 Int)
(push) ; 5
; [eval] 0 <= j && j < V ==> 0 < G[i1][j]
; [eval] 0 <= j && j < V
; [eval] 0 <= j
(push) ; 6
; [then-branch: 4 | 0 <= j@110@00 | live]
; [else-branch: 4 | !(0 <= j@110@00) | live]
(push) ; 7
; [then-branch: 4 | 0 <= j@110@00]
(assert (<= 0 j@110@00))
; [eval] j < V
(pop) ; 7
(push) ; 7
; [else-branch: 4 | !(0 <= j@110@00)]
(assert (not (<= 0 j@110@00)))
(pop) ; 7
(pop) ; 6
; Joined path conditions
; Joined path conditions
(push) ; 6
; [then-branch: 5 | j@110@00 < V@6@00 && 0 <= j@110@00 | live]
; [else-branch: 5 | !(j@110@00 < V@6@00 && 0 <= j@110@00) | live]
(push) ; 7
; [then-branch: 5 | j@110@00 < V@6@00 && 0 <= j@110@00]
(assert (and (< j@110@00 V@6@00) (<= 0 j@110@00)))
; [eval] 0 < G[i1][j]
; [eval] G[i1][j]
; [eval] G[i1]
(set-option :timeout 0)
(push) ; 8
(assert (not (>= i1@109@00 0)))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs             22
;  :arith-add-rows        3
;  :arith-assert-diseq    4
;  :arith-assert-lower    10
;  :arith-assert-upper    7
;  :arith-bound-prop      3
;  :arith-eq-adapter      6
;  :arith-fixed-eqs       1
;  :arith-pivots          2
;  :datatype-accessor-ax  5
;  :datatype-occurs-check 2
;  :decisions             1
;  :del-clause            24
;  :final-checks          2
;  :max-generation        3
;  :max-memory            4.25
;  :memory                3.99
;  :mk-bool-var           338
;  :mk-clause             43
;  :num-allocs            129066
;  :num-checks            3
;  :propagations          15
;  :quant-instantiations  12
;  :rlimit-count          136869)
(push) ; 8
(assert (not (< i1@109@00 (Seq_length G@5@00))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs             22
;  :arith-add-rows        5
;  :arith-assert-diseq    4
;  :arith-assert-lower    11
;  :arith-assert-upper    7
;  :arith-bound-prop      3
;  :arith-conflicts       1
;  :arith-eq-adapter      6
;  :arith-fixed-eqs       1
;  :arith-pivots          4
;  :conflicts             1
;  :datatype-accessor-ax  5
;  :datatype-occurs-check 2
;  :decisions             1
;  :del-clause            24
;  :final-checks          2
;  :max-generation        3
;  :max-memory            4.25
;  :memory                3.98
;  :mk-bool-var           339
;  :mk-clause             43
;  :num-allocs            129162
;  :num-checks            4
;  :propagations          15
;  :quant-instantiations  12
;  :rlimit-count          136997)
(push) ; 8
(assert (not (>= j@110@00 0)))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs             22
;  :arith-add-rows        5
;  :arith-assert-diseq    4
;  :arith-assert-lower    11
;  :arith-assert-upper    7
;  :arith-bound-prop      3
;  :arith-conflicts       1
;  :arith-eq-adapter      6
;  :arith-fixed-eqs       1
;  :arith-pivots          4
;  :conflicts             1
;  :datatype-accessor-ax  5
;  :datatype-occurs-check 2
;  :decisions             1
;  :del-clause            24
;  :final-checks          2
;  :max-generation        3
;  :max-memory            4.25
;  :memory                3.98
;  :mk-bool-var           339
;  :mk-clause             43
;  :num-allocs            129181
;  :num-checks            5
;  :propagations          15
;  :quant-instantiations  12
;  :rlimit-count          137006)
(push) ; 8
(assert (not (< j@110@00 (Seq_length (Seq_index G@5@00 i1@109@00)))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs             24
;  :arith-add-rows        21
;  :arith-assert-diseq    9
;  :arith-assert-lower    16
;  :arith-assert-upper    9
;  :arith-bound-prop      5
;  :arith-conflicts       2
;  :arith-eq-adapter      8
;  :arith-fixed-eqs       1
;  :arith-offset-eqs      1
;  :arith-pivots          8
;  :conflicts             3
;  :datatype-accessor-ax  5
;  :datatype-occurs-check 2
;  :decisions             2
;  :del-clause            51
;  :final-checks          2
;  :max-generation        4
;  :max-memory            4.25
;  :memory                4.00
;  :mk-bool-var           366
;  :mk-clause             70
;  :num-allocs            129533
;  :num-checks            6
;  :propagations          25
;  :quant-instantiations  20
;  :rlimit-count          137777)
(pop) ; 7
(push) ; 7
; [else-branch: 5 | !(j@110@00 < V@6@00 && 0 <= j@110@00)]
(assert (not (and (< j@110@00 V@6@00) (<= 0 j@110@00))))
(pop) ; 7
(pop) ; 6
; Joined path conditions
; Joined path conditions
(pop) ; 5
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 4
(push) ; 4
; [else-branch: 3 | !(i1@109@00 < V@6@00 && 0 <= i1@109@00)]
(assert (not (and (< i1@109@00 V@6@00) (<= 0 i1@109@00))))
(pop) ; 4
(pop) ; 3
; Joined path conditions
; Joined path conditions
(pop) ; 2
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
; Nested auxiliary terms: non-globals (tlq)
(assert (=
  result@7@00
  (forall ((i1@109@00 Int)) (!
    (implies
      (and (< i1@109@00 V@6@00) (<= 0 i1@109@00))
      (forall ((j@110@00 Int)) (!
        (implies
          (and (< j@110@00 V@6@00) (<= 0 j@110@00))
          (< 0 (Seq_index (Seq_index G@5@00 i1@109@00) j@110@00)))
        :pattern ((Seq_index (Seq_index G@5@00 i1@109@00) j@110@00))
        :qid |prog.l<no position>|)))
    :pattern ((Seq_index G@5@00 i1@109@00))
    :qid |prog.l<no position>|))))
(pop) ; 1
(assert (forall ((s@$ $Snap) (this@4@00 $Ref) (G@5@00 Seq<Seq<Int>>) (V@6@00 Int)) (!
  (implies
    (and
      (not (= this@4@00 $Ref.null))
      (SquareIntMatrix $Snap.unit this@4@00 G@5@00 V@6@00))
    (=
      (NonNegativeCapacities s@$ this@4@00 G@5@00 V@6@00)
      (forall ((i1 Int)) (!
        (implies
          (and (<= 0 i1) (< i1 V@6@00))
          (forall ((j Int)) (!
            (implies
              (and (<= 0 j) (< j V@6@00))
              (< 0 (Seq_index (Seq_index G@5@00 i1) j)))
            :pattern ((Seq_index (Seq_index G@5@00 i1) j))
            )))
        :pattern ((Seq_index G@5@00 i1))
        ))))
  :pattern ((NonNegativeCapacities s@$ this@4@00 G@5@00 V@6@00))
  )))
; ---------- FUNCTION FlowNetwork----------
(declare-fun this@8@00 () $Ref)
(declare-fun G@9@00 () Seq<Seq<Int>>)
(declare-fun V@10@00 () Int)
(declare-fun s@11@00 () Int)
(declare-fun t@12@00 () Int)
(declare-fun result@13@00 () Bool)
; ----- Well-definedness of specifications -----
(push) ; 1
(assert (= s@$ $Snap.unit))
; [eval] this != null
(assert (not (= this@8@00 $Ref.null)))
(pop) ; 1
(assert (forall ((s@$ $Snap) (this@8@00 $Ref) (G@9@00 Seq<Seq<Int>>) (V@10@00 Int) (s@11@00 Int) (t@12@00 Int)) (!
  (=
    (FlowNetwork%limited s@$ this@8@00 G@9@00 V@10@00 s@11@00 t@12@00)
    (FlowNetwork s@$ this@8@00 G@9@00 V@10@00 s@11@00 t@12@00))
  :pattern ((FlowNetwork s@$ this@8@00 G@9@00 V@10@00 s@11@00 t@12@00))
  )))
(assert (forall ((s@$ $Snap) (this@8@00 $Ref) (G@9@00 Seq<Seq<Int>>) (V@10@00 Int) (s@11@00 Int) (t@12@00 Int)) (!
  (FlowNetwork%stateless this@8@00 G@9@00 V@10@00 s@11@00 t@12@00)
  :pattern ((FlowNetwork%limited s@$ this@8@00 G@9@00 V@10@00 s@11@00 t@12@00))
  )))
; ----- Verification of function body and postcondition -----
(push) ; 1
(assert (= s@$ $Snap.unit))
(assert (not (= this@8@00 $Ref.null)))
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
; [eval] 0 <= s && s < V && 0 <= t && t < V && SquareIntMatrix(this, G, V) && NonNegativeCapacities(this, G, V)
; [eval] 0 <= s
(push) ; 2
; [then-branch: 6 | 0 <= s@11@00 | live]
; [else-branch: 6 | !(0 <= s@11@00) | live]
(push) ; 3
; [then-branch: 6 | 0 <= s@11@00]
(assert (<= 0 s@11@00))
; [eval] s < V
(push) ; 4
; [then-branch: 7 | s@11@00 < V@10@00 | live]
; [else-branch: 7 | !(s@11@00 < V@10@00) | live]
(push) ; 5
; [then-branch: 7 | s@11@00 < V@10@00]
(assert (< s@11@00 V@10@00))
; [eval] 0 <= t
(push) ; 6
; [then-branch: 8 | 0 <= t@12@00 | live]
; [else-branch: 8 | !(0 <= t@12@00) | live]
(push) ; 7
; [then-branch: 8 | 0 <= t@12@00]
(assert (<= 0 t@12@00))
; [eval] t < V
(push) ; 8
; [then-branch: 9 | t@12@00 < V@10@00 | live]
; [else-branch: 9 | !(t@12@00 < V@10@00) | live]
(push) ; 9
; [then-branch: 9 | t@12@00 < V@10@00]
(assert (< t@12@00 V@10@00))
; [eval] SquareIntMatrix(this, G, V)
(push) ; 10
; [eval] this != null
(pop) ; 10
; Joined path conditions
(push) ; 10
; [then-branch: 10 | SquareIntMatrix(_, this@8@00, G@9@00, V@10@00) | live]
; [else-branch: 10 | !(SquareIntMatrix(_, this@8@00, G@9@00, V@10@00)) | live]
(push) ; 11
; [then-branch: 10 | SquareIntMatrix(_, this@8@00, G@9@00, V@10@00)]
(assert (SquareIntMatrix $Snap.unit this@8@00 G@9@00 V@10@00))
; [eval] NonNegativeCapacities(this, G, V)
(push) ; 12
; [eval] this != null
; [eval] SquareIntMatrix(this, G, V)
(push) ; 13
; [eval] this != null
(pop) ; 13
; Joined path conditions
(pop) ; 12
; Joined path conditions
(pop) ; 11
(push) ; 11
; [else-branch: 10 | !(SquareIntMatrix(_, this@8@00, G@9@00, V@10@00))]
(assert (not (SquareIntMatrix $Snap.unit this@8@00 G@9@00 V@10@00)))
(pop) ; 11
(pop) ; 10
; Joined path conditions
; Joined path conditions
(pop) ; 9
(push) ; 9
; [else-branch: 9 | !(t@12@00 < V@10@00)]
(assert (not (< t@12@00 V@10@00)))
(pop) ; 9
(pop) ; 8
; Joined path conditions
; Joined path conditions
(pop) ; 7
(push) ; 7
; [else-branch: 8 | !(0 <= t@12@00)]
(assert (not (<= 0 t@12@00)))
(pop) ; 7
(pop) ; 6
; Joined path conditions
; Joined path conditions
(pop) ; 5
(push) ; 5
; [else-branch: 7 | !(s@11@00 < V@10@00)]
(assert (not (< s@11@00 V@10@00)))
(pop) ; 5
(pop) ; 4
; Joined path conditions
; Joined path conditions
(pop) ; 3
(push) ; 3
; [else-branch: 6 | !(0 <= s@11@00)]
(assert (not (<= 0 s@11@00)))
(pop) ; 3
(pop) ; 2
; Joined path conditions
; Joined path conditions
(assert (=
  result@13@00
  (and
    (and
      (and
        (and
          (and
            (NonNegativeCapacities ($Snap.combine $Snap.unit $Snap.unit) this@8@00 G@9@00 V@10@00)
            (SquareIntMatrix $Snap.unit this@8@00 G@9@00 V@10@00))
          (< t@12@00 V@10@00))
        (<= 0 t@12@00))
      (< s@11@00 V@10@00))
    (<= 0 s@11@00))))
(pop) ; 1
(assert (forall ((s@$ $Snap) (this@8@00 $Ref) (G@9@00 Seq<Seq<Int>>) (V@10@00 Int) (s@11@00 Int) (t@12@00 Int)) (!
  (implies
    (not (= this@8@00 $Ref.null))
    (=
      (FlowNetwork s@$ this@8@00 G@9@00 V@10@00 s@11@00 t@12@00)
      (and
        (and
          (and
            (and (and (<= 0 s@11@00) (< s@11@00 V@10@00)) (<= 0 t@12@00))
            (< t@12@00 V@10@00))
          (SquareIntMatrix $Snap.unit this@8@00 G@9@00 V@10@00))
        (NonNegativeCapacities ($Snap.combine $Snap.unit $Snap.unit) this@8@00 G@9@00 V@10@00))))
  :pattern ((FlowNetwork s@$ this@8@00 G@9@00 V@10@00 s@11@00 t@12@00))
  )))
; ---------- FUNCTION SumOutgoingFlow----------
(declare-fun this@14@00 () $Ref)
(declare-fun G@15@00 () Seq<Seq<Int>>)
(declare-fun n@16@00 () Int)
(declare-fun v@17@00 () Int)
(declare-fun V@18@00 () Int)
(declare-fun result@19@00 () Int)
; ----- Well-definedness of specifications -----
(push) ; 1
(assert (= s@$ ($Snap.combine ($Snap.first s@$) ($Snap.second s@$))))
(assert (= ($Snap.first s@$) $Snap.unit))
; [eval] this != null
(assert (not (= this@14@00 $Ref.null)))
(assert (= ($Snap.second s@$) $Snap.unit))
; [eval] FlowNetwork(this, G, V, n, v)
(push) ; 2
; [eval] this != null
(pop) ; 2
; Joined path conditions
(assert (FlowNetwork $Snap.unit this@14@00 G@15@00 V@18@00 n@16@00 v@17@00))
(pop) ; 1
(assert (forall ((s@$ $Snap) (this@14@00 $Ref) (G@15@00 Seq<Seq<Int>>) (n@16@00 Int) (v@17@00 Int) (V@18@00 Int)) (!
  (=
    (SumOutgoingFlow%limited s@$ this@14@00 G@15@00 n@16@00 v@17@00 V@18@00)
    (SumOutgoingFlow s@$ this@14@00 G@15@00 n@16@00 v@17@00 V@18@00))
  :pattern ((SumOutgoingFlow s@$ this@14@00 G@15@00 n@16@00 v@17@00 V@18@00))
  )))
(assert (forall ((s@$ $Snap) (this@14@00 $Ref) (G@15@00 Seq<Seq<Int>>) (n@16@00 Int) (v@17@00 Int) (V@18@00 Int)) (!
  (SumOutgoingFlow%stateless this@14@00 G@15@00 n@16@00 v@17@00 V@18@00)
  :pattern ((SumOutgoingFlow%limited s@$ this@14@00 G@15@00 n@16@00 v@17@00 V@18@00))
  )))
; ----- Verification of function body and postcondition -----
(push) ; 1
(assert (= s@$ ($Snap.combine ($Snap.first s@$) ($Snap.second s@$))))
(assert (= ($Snap.first s@$) $Snap.unit))
(assert (not (= this@14@00 $Ref.null)))
(assert (= ($Snap.second s@$) $Snap.unit))
(assert (FlowNetwork $Snap.unit this@14@00 G@15@00 V@18@00 n@16@00 v@17@00))
; State saturation: after contract
(check-sat)
; unknown
; [eval] (0 < n ? G[v][n] + SumOutgoingFlow(this, G, n - 1, v, V) : 0)
; [eval] 0 < n
(push) ; 2
(set-option :timeout 10)
(push) ; 3
(assert (not (not (< 0 n@16@00))))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs             45
;  :arith-add-rows        32
;  :arith-assert-diseq    13
;  :arith-assert-lower    28
;  :arith-assert-upper    18
;  :arith-bound-prop      11
;  :arith-conflicts       2
;  :arith-eq-adapter      14
;  :arith-fixed-eqs       3
;  :arith-offset-eqs      1
;  :arith-pivots          17
;  :conflicts             3
;  :datatype-accessor-ax  10
;  :datatype-occurs-check 5
;  :decisions             2
;  :del-clause            148
;  :final-checks          5
;  :max-generation        4
;  :max-memory            4.25
;  :memory                4.03
;  :mk-bool-var           473
;  :mk-clause             161
;  :num-allocs            133525
;  :num-checks            9
;  :propagations          54
;  :quant-instantiations  40
;  :rlimit-count          142792)
(push) ; 3
(assert (not (< 0 n@16@00)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs             47
;  :arith-add-rows        32
;  :arith-assert-diseq    13
;  :arith-assert-lower    28
;  :arith-assert-upper    19
;  :arith-bound-prop      11
;  :arith-conflicts       2
;  :arith-eq-adapter      14
;  :arith-fixed-eqs       4
;  :arith-offset-eqs      2
;  :arith-pivots          18
;  :conflicts             3
;  :datatype-accessor-ax  10
;  :datatype-occurs-check 6
;  :decisions             2
;  :del-clause            148
;  :final-checks          6
;  :max-generation        4
;  :max-memory            4.25
;  :memory                4.03
;  :mk-bool-var           474
;  :mk-clause             161
;  :num-allocs            134037
;  :num-checks            10
;  :propagations          54
;  :quant-instantiations  40
;  :rlimit-count          143174)
; [then-branch: 11 | 0 < n@16@00 | live]
; [else-branch: 11 | !(0 < n@16@00) | live]
(push) ; 3
; [then-branch: 11 | 0 < n@16@00]
(assert (< 0 n@16@00))
; [eval] G[v][n] + SumOutgoingFlow(this, G, n - 1, v, V)
; [eval] G[v][n]
; [eval] G[v]
(set-option :timeout 0)
(push) ; 4
(assert (not (>= v@17@00 0)))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs             47
;  :arith-add-rows        32
;  :arith-assert-diseq    13
;  :arith-assert-lower    29
;  :arith-assert-upper    19
;  :arith-bound-prop      11
;  :arith-conflicts       2
;  :arith-eq-adapter      14
;  :arith-fixed-eqs       4
;  :arith-offset-eqs      2
;  :arith-pivots          18
;  :conflicts             4
;  :datatype-accessor-ax  10
;  :datatype-occurs-check 6
;  :decisions             2
;  :del-clause            148
;  :final-checks          6
;  :max-generation        4
;  :max-memory            4.25
;  :memory                4.03
;  :mk-bool-var           475
;  :mk-clause             161
;  :num-allocs            134172
;  :num-checks            11
;  :propagations          54
;  :quant-instantiations  40
;  :rlimit-count          143300)
(push) ; 4
(assert (not (< v@17@00 (Seq_length G@15@00))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs             47
;  :arith-add-rows        34
;  :arith-assert-diseq    13
;  :arith-assert-lower    29
;  :arith-assert-upper    20
;  :arith-bound-prop      11
;  :arith-conflicts       3
;  :arith-eq-adapter      14
;  :arith-fixed-eqs       4
;  :arith-offset-eqs      2
;  :arith-pivots          18
;  :conflicts             5
;  :datatype-accessor-ax  10
;  :datatype-occurs-check 6
;  :decisions             2
;  :del-clause            148
;  :final-checks          6
;  :max-generation        4
;  :max-memory            4.25
;  :memory                4.03
;  :mk-bool-var           476
;  :mk-clause             161
;  :num-allocs            134254
;  :num-checks            12
;  :propagations          54
;  :quant-instantiations  40
;  :rlimit-count          143394)
(push) ; 4
(assert (not (>= n@16@00 0)))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs             47
;  :arith-add-rows        34
;  :arith-assert-diseq    13
;  :arith-assert-lower    29
;  :arith-assert-upper    20
;  :arith-bound-prop      11
;  :arith-conflicts       3
;  :arith-eq-adapter      14
;  :arith-fixed-eqs       4
;  :arith-offset-eqs      2
;  :arith-pivots          18
;  :conflicts             6
;  :datatype-accessor-ax  10
;  :datatype-occurs-check 6
;  :decisions             2
;  :del-clause            148
;  :final-checks          6
;  :max-generation        4
;  :max-memory            4.25
;  :memory                4.03
;  :mk-bool-var           476
;  :mk-clause             161
;  :num-allocs            134330
;  :num-checks            13
;  :propagations          54
;  :quant-instantiations  40
;  :rlimit-count          143450)
(push) ; 4
(assert (not (< n@16@00 (Seq_length (Seq_index G@15@00 v@17@00)))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs             49
;  :arith-add-rows        39
;  :arith-assert-diseq    16
;  :arith-assert-lower    34
;  :arith-assert-upper    20
;  :arith-bound-prop      14
;  :arith-conflicts       3
;  :arith-eq-adapter      16
;  :arith-fixed-eqs       4
;  :arith-offset-eqs      3
;  :arith-pivots          20
;  :conflicts             7
;  :datatype-accessor-ax  10
;  :datatype-occurs-check 6
;  :decisions             2
;  :del-clause            168
;  :final-checks          6
;  :max-generation        5
;  :max-memory            4.25
;  :memory                4.04
;  :mk-bool-var           496
;  :mk-clause             181
;  :num-allocs            134587
;  :num-checks            14
;  :propagations          61
;  :quant-instantiations  47
;  :rlimit-count          143918)
; [eval] SumOutgoingFlow(this, G, n - 1, v, V)
; [eval] n - 1
(push) ; 4
; [eval] this != null
; [eval] FlowNetwork(this, G, V, n, v)
(push) ; 5
; [eval] this != null
(pop) ; 5
; Joined path conditions
(push) ; 5
(assert (not (FlowNetwork $Snap.unit this@14@00 G@15@00 V@18@00 (- n@16@00 1) v@17@00)))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs             49
;  :arith-add-rows        39
;  :arith-assert-diseq    16
;  :arith-assert-lower    34
;  :arith-assert-upper    20
;  :arith-bound-prop      14
;  :arith-conflicts       3
;  :arith-eq-adapter      16
;  :arith-fixed-eqs       4
;  :arith-offset-eqs      3
;  :arith-pivots          20
;  :conflicts             8
;  :datatype-accessor-ax  10
;  :datatype-occurs-check 6
;  :decisions             2
;  :del-clause            170
;  :final-checks          6
;  :max-generation        5
;  :max-memory            4.25
;  :memory                4.04
;  :mk-bool-var           503
;  :mk-clause             183
;  :num-allocs            134689
;  :num-checks            15
;  :propagations          61
;  :quant-instantiations  49
;  :rlimit-count          144086)
(assert (FlowNetwork $Snap.unit this@14@00 G@15@00 V@18@00 (- n@16@00 1) v@17@00))
(pop) ; 4
; Joined path conditions
(assert (FlowNetwork $Snap.unit this@14@00 G@15@00 V@18@00 (- n@16@00 1) v@17@00))
(pop) ; 3
(push) ; 3
; [else-branch: 11 | !(0 < n@16@00)]
(assert (not (< 0 n@16@00)))
(pop) ; 3
(pop) ; 2
; Joined path conditions
(assert (implies
  (< 0 n@16@00)
  (and
    (< 0 n@16@00)
    (FlowNetwork $Snap.unit this@14@00 G@15@00 V@18@00 (- n@16@00 1) v@17@00))))
; Joined path conditions
(assert (=
  result@19@00
  (ite
    (< 0 n@16@00)
    (+
      (Seq_index (Seq_index G@15@00 v@17@00) n@16@00)
      (SumOutgoingFlow ($Snap.combine $Snap.unit $Snap.unit) this@14@00 G@15@00 (-
        n@16@00
        1) v@17@00 V@18@00))
    0)))
(pop) ; 1
(assert (forall ((s@$ $Snap) (this@14@00 $Ref) (G@15@00 Seq<Seq<Int>>) (n@16@00 Int) (v@17@00 Int) (V@18@00 Int)) (!
  (implies
    (and
      (not (= this@14@00 $Ref.null))
      (FlowNetwork $Snap.unit this@14@00 G@15@00 V@18@00 n@16@00 v@17@00))
    (=
      (SumOutgoingFlow s@$ this@14@00 G@15@00 n@16@00 v@17@00 V@18@00)
      (ite
        (< 0 n@16@00)
        (+
          (Seq_index (Seq_index G@15@00 v@17@00) n@16@00)
          (SumOutgoingFlow%limited ($Snap.combine $Snap.unit $Snap.unit) this@14@00 G@15@00 (-
            n@16@00
            1) v@17@00 V@18@00))
        0)))
  :pattern ((SumOutgoingFlow s@$ this@14@00 G@15@00 n@16@00 v@17@00 V@18@00))
  )))
; ---------- FUNCTION SumIncomingFlow----------
(declare-fun this@20@00 () $Ref)
(declare-fun G@21@00 () Seq<Seq<Int>>)
(declare-fun n@22@00 () Int)
(declare-fun v@23@00 () Int)
(declare-fun V@24@00 () Int)
(declare-fun result@25@00 () Int)
; ----- Well-definedness of specifications -----
(push) ; 1
(assert (= s@$ ($Snap.combine ($Snap.first s@$) ($Snap.second s@$))))
(assert (= ($Snap.first s@$) $Snap.unit))
; [eval] this != null
(assert (not (= this@20@00 $Ref.null)))
(assert (= ($Snap.second s@$) $Snap.unit))
; [eval] FlowNetwork(this, G, V, n, v)
(push) ; 2
; [eval] this != null
(pop) ; 2
; Joined path conditions
(assert (FlowNetwork $Snap.unit this@20@00 G@21@00 V@24@00 n@22@00 v@23@00))
(pop) ; 1
(assert (forall ((s@$ $Snap) (this@20@00 $Ref) (G@21@00 Seq<Seq<Int>>) (n@22@00 Int) (v@23@00 Int) (V@24@00 Int)) (!
  (=
    (SumIncomingFlow%limited s@$ this@20@00 G@21@00 n@22@00 v@23@00 V@24@00)
    (SumIncomingFlow s@$ this@20@00 G@21@00 n@22@00 v@23@00 V@24@00))
  :pattern ((SumIncomingFlow s@$ this@20@00 G@21@00 n@22@00 v@23@00 V@24@00))
  )))
(assert (forall ((s@$ $Snap) (this@20@00 $Ref) (G@21@00 Seq<Seq<Int>>) (n@22@00 Int) (v@23@00 Int) (V@24@00 Int)) (!
  (SumIncomingFlow%stateless this@20@00 G@21@00 n@22@00 v@23@00 V@24@00)
  :pattern ((SumIncomingFlow%limited s@$ this@20@00 G@21@00 n@22@00 v@23@00 V@24@00))
  )))
; ----- Verification of function body and postcondition -----
(push) ; 1
(assert (= s@$ ($Snap.combine ($Snap.first s@$) ($Snap.second s@$))))
(assert (= ($Snap.first s@$) $Snap.unit))
(assert (not (= this@20@00 $Ref.null)))
(assert (= ($Snap.second s@$) $Snap.unit))
(assert (FlowNetwork $Snap.unit this@20@00 G@21@00 V@24@00 n@22@00 v@23@00))
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
; [eval] (0 < n ? G[n][v] + SumIncomingFlow(this, G, n - 1, v, V) : 0)
; [eval] 0 < n
(push) ; 2
(set-option :timeout 10)
(push) ; 3
(assert (not (not (< 0 n@22@00))))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs             67
;  :arith-add-rows        47
;  :arith-assert-diseq    20
;  :arith-assert-lower    44
;  :arith-assert-upper    26
;  :arith-bound-prop      15
;  :arith-conflicts       4
;  :arith-eq-adapter      19
;  :arith-fixed-eqs       5
;  :arith-offset-eqs      3
;  :arith-pivots          25
;  :conflicts             9
;  :datatype-accessor-ax  14
;  :datatype-occurs-check 8
;  :decisions             4
;  :del-clause            219
;  :final-checks          8
;  :max-generation        5
;  :max-memory            4.25
;  :memory                4.07
;  :mk-bool-var           579
;  :mk-clause             245
;  :num-allocs            136729
;  :num-checks            17
;  :propagations          88
;  :quant-instantiations  63
;  :rlimit-count          146763)
(push) ; 3
(assert (not (< 0 n@22@00)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs             68
;  :arith-add-rows        47
;  :arith-assert-diseq    20
;  :arith-assert-lower    44
;  :arith-assert-upper    27
;  :arith-bound-prop      15
;  :arith-conflicts       4
;  :arith-eq-adapter      19
;  :arith-fixed-eqs       6
;  :arith-offset-eqs      3
;  :arith-pivots          25
;  :conflicts             9
;  :datatype-accessor-ax  14
;  :datatype-occurs-check 9
;  :decisions             4
;  :del-clause            219
;  :final-checks          9
;  :max-generation        5
;  :max-memory            4.25
;  :memory                4.07
;  :mk-bool-var           580
;  :mk-clause             245
;  :num-allocs            137253
;  :num-checks            18
;  :propagations          88
;  :quant-instantiations  63
;  :rlimit-count          147123)
; [then-branch: 12 | 0 < n@22@00 | live]
; [else-branch: 12 | !(0 < n@22@00) | live]
(push) ; 3
; [then-branch: 12 | 0 < n@22@00]
(assert (< 0 n@22@00))
; [eval] G[n][v] + SumIncomingFlow(this, G, n - 1, v, V)
; [eval] G[n][v]
; [eval] G[n]
(set-option :timeout 0)
(push) ; 4
(assert (not (>= n@22@00 0)))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs             68
;  :arith-add-rows        47
;  :arith-assert-diseq    20
;  :arith-assert-lower    45
;  :arith-assert-upper    27
;  :arith-bound-prop      15
;  :arith-conflicts       4
;  :arith-eq-adapter      19
;  :arith-fixed-eqs       6
;  :arith-offset-eqs      3
;  :arith-pivots          25
;  :conflicts             10
;  :datatype-accessor-ax  14
;  :datatype-occurs-check 9
;  :decisions             4
;  :del-clause            219
;  :final-checks          9
;  :max-generation        5
;  :max-memory            4.25
;  :memory                4.07
;  :mk-bool-var           581
;  :mk-clause             245
;  :num-allocs            137388
;  :num-checks            19
;  :propagations          88
;  :quant-instantiations  63
;  :rlimit-count          147243)
(push) ; 4
(assert (not (< n@22@00 (Seq_length G@21@00))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs             68
;  :arith-add-rows        50
;  :arith-assert-diseq    20
;  :arith-assert-lower    45
;  :arith-assert-upper    28
;  :arith-bound-prop      15
;  :arith-conflicts       5
;  :arith-eq-adapter      19
;  :arith-fixed-eqs       6
;  :arith-offset-eqs      3
;  :arith-pivots          27
;  :conflicts             11
;  :datatype-accessor-ax  14
;  :datatype-occurs-check 9
;  :decisions             4
;  :del-clause            219
;  :final-checks          9
;  :max-generation        5
;  :max-memory            4.25
;  :memory                4.06
;  :mk-bool-var           582
;  :mk-clause             245
;  :num-allocs            137471
;  :num-checks            20
;  :propagations          88
;  :quant-instantiations  63
;  :rlimit-count          147384)
(push) ; 4
(assert (not (>= v@23@00 0)))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs             68
;  :arith-add-rows        50
;  :arith-assert-diseq    20
;  :arith-assert-lower    45
;  :arith-assert-upper    28
;  :arith-bound-prop      15
;  :arith-conflicts       5
;  :arith-eq-adapter      19
;  :arith-fixed-eqs       6
;  :arith-offset-eqs      3
;  :arith-pivots          27
;  :conflicts             12
;  :datatype-accessor-ax  14
;  :datatype-occurs-check 9
;  :decisions             4
;  :del-clause            219
;  :final-checks          9
;  :max-generation        5
;  :max-memory            4.25
;  :memory                4.06
;  :mk-bool-var           582
;  :mk-clause             245
;  :num-allocs            137543
;  :num-checks            21
;  :propagations          88
;  :quant-instantiations  63
;  :rlimit-count          147440)
(push) ; 4
(assert (not (< v@23@00 (Seq_length (Seq_index G@21@00 n@22@00)))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs             73
;  :arith-add-rows        63
;  :arith-assert-diseq    27
;  :arith-assert-lower    50
;  :arith-assert-upper    30
;  :arith-bound-prop      15
;  :arith-conflicts       7
;  :arith-eq-adapter      21
;  :arith-fixed-eqs       7
;  :arith-offset-eqs      4
;  :arith-pivots          33
;  :conflicts             16
;  :datatype-accessor-ax  14
;  :datatype-occurs-check 9
;  :decisions             7
;  :del-clause            260
;  :final-checks          9
;  :max-generation        5
;  :max-memory            4.25
;  :memory                4.07
;  :mk-bool-var           625
;  :mk-clause             286
;  :num-allocs            137823
;  :num-checks            22
;  :propagations          108
;  :quant-instantiations  73
;  :rlimit-count          148279)
; [eval] SumIncomingFlow(this, G, n - 1, v, V)
; [eval] n - 1
(push) ; 4
; [eval] this != null
; [eval] FlowNetwork(this, G, V, n, v)
(push) ; 5
; [eval] this != null
(pop) ; 5
; Joined path conditions
(push) ; 5
(assert (not (FlowNetwork $Snap.unit this@20@00 G@21@00 V@24@00 (- n@22@00 1) v@23@00)))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs             73
;  :arith-add-rows        63
;  :arith-assert-diseq    27
;  :arith-assert-lower    50
;  :arith-assert-upper    30
;  :arith-bound-prop      15
;  :arith-conflicts       7
;  :arith-eq-adapter      21
;  :arith-fixed-eqs       7
;  :arith-offset-eqs      4
;  :arith-pivots          33
;  :conflicts             17
;  :datatype-accessor-ax  14
;  :datatype-occurs-check 9
;  :decisions             7
;  :del-clause            262
;  :final-checks          9
;  :max-generation        5
;  :max-memory            4.25
;  :memory                4.07
;  :mk-bool-var           632
;  :mk-clause             288
;  :num-allocs            137935
;  :num-checks            23
;  :propagations          108
;  :quant-instantiations  75
;  :rlimit-count          148447)
(assert (FlowNetwork $Snap.unit this@20@00 G@21@00 V@24@00 (- n@22@00 1) v@23@00))
(pop) ; 4
; Joined path conditions
(assert (FlowNetwork $Snap.unit this@20@00 G@21@00 V@24@00 (- n@22@00 1) v@23@00))
(pop) ; 3
(push) ; 3
; [else-branch: 12 | !(0 < n@22@00)]
(assert (not (< 0 n@22@00)))
(pop) ; 3
(pop) ; 2
; Joined path conditions
(assert (implies
  (< 0 n@22@00)
  (and
    (< 0 n@22@00)
    (FlowNetwork $Snap.unit this@20@00 G@21@00 V@24@00 (- n@22@00 1) v@23@00))))
; Joined path conditions
(assert (=
  result@25@00
  (ite
    (< 0 n@22@00)
    (+
      (Seq_index (Seq_index G@21@00 n@22@00) v@23@00)
      (SumIncomingFlow ($Snap.combine $Snap.unit $Snap.unit) this@20@00 G@21@00 (-
        n@22@00
        1) v@23@00 V@24@00))
    0)))
(pop) ; 1
(assert (forall ((s@$ $Snap) (this@20@00 $Ref) (G@21@00 Seq<Seq<Int>>) (n@22@00 Int) (v@23@00 Int) (V@24@00 Int)) (!
  (implies
    (and
      (not (= this@20@00 $Ref.null))
      (FlowNetwork $Snap.unit this@20@00 G@21@00 V@24@00 n@22@00 v@23@00))
    (=
      (SumIncomingFlow s@$ this@20@00 G@21@00 n@22@00 v@23@00 V@24@00)
      (ite
        (< 0 n@22@00)
        (+
          (Seq_index (Seq_index G@21@00 n@22@00) v@23@00)
          (SumIncomingFlow%limited ($Snap.combine $Snap.unit $Snap.unit) this@20@00 G@21@00 (-
            n@22@00
            1) v@23@00 V@24@00))
        0)))
  :pattern ((SumIncomingFlow s@$ this@20@00 G@21@00 n@22@00 v@23@00 V@24@00))
  )))
; ---------- FUNCTION CapacityConstraint----------
(declare-fun this@26@00 () $Ref)
(declare-fun G@27@00 () Seq<Seq<Int>>)
(declare-fun Gf@28@00 () Seq<Seq<Int>>)
(declare-fun V@29@00 () Int)
(declare-fun result@30@00 () Bool)
; ----- Well-definedness of specifications -----
(push) ; 1
(assert (= s@$ ($Snap.combine ($Snap.first s@$) ($Snap.second s@$))))
(assert (= ($Snap.first s@$) $Snap.unit))
; [eval] this != null
(assert (not (= this@26@00 $Ref.null)))
(assert (=
  ($Snap.second s@$)
  ($Snap.combine
    ($Snap.first ($Snap.second s@$))
    ($Snap.second ($Snap.second s@$)))))
(assert (= ($Snap.first ($Snap.second s@$)) $Snap.unit))
; [eval] SquareIntMatrix(this, G, V)
(push) ; 2
; [eval] this != null
(pop) ; 2
; Joined path conditions
(assert (SquareIntMatrix $Snap.unit this@26@00 G@27@00 V@29@00))
(assert (= ($Snap.second ($Snap.second s@$)) $Snap.unit))
; [eval] SquareIntMatrix(this, Gf, V)
(push) ; 2
; [eval] this != null
(pop) ; 2
; Joined path conditions
(assert (SquareIntMatrix $Snap.unit this@26@00 Gf@28@00 V@29@00))
(pop) ; 1
(assert (forall ((s@$ $Snap) (this@26@00 $Ref) (G@27@00 Seq<Seq<Int>>) (Gf@28@00 Seq<Seq<Int>>) (V@29@00 Int)) (!
  (=
    (CapacityConstraint%limited s@$ this@26@00 G@27@00 Gf@28@00 V@29@00)
    (CapacityConstraint s@$ this@26@00 G@27@00 Gf@28@00 V@29@00))
  :pattern ((CapacityConstraint s@$ this@26@00 G@27@00 Gf@28@00 V@29@00))
  )))
(assert (forall ((s@$ $Snap) (this@26@00 $Ref) (G@27@00 Seq<Seq<Int>>) (Gf@28@00 Seq<Seq<Int>>) (V@29@00 Int)) (!
  (CapacityConstraint%stateless this@26@00 G@27@00 Gf@28@00 V@29@00)
  :pattern ((CapacityConstraint%limited s@$ this@26@00 G@27@00 Gf@28@00 V@29@00))
  )))
; ----- Verification of function body and postcondition -----
(push) ; 1
(assert (= s@$ ($Snap.combine ($Snap.first s@$) ($Snap.second s@$))))
(assert (= ($Snap.first s@$) $Snap.unit))
(assert (not (= this@26@00 $Ref.null)))
(assert (=
  ($Snap.second s@$)
  ($Snap.combine
    ($Snap.first ($Snap.second s@$))
    ($Snap.second ($Snap.second s@$)))))
(assert (= ($Snap.first ($Snap.second s@$)) $Snap.unit))
(assert (SquareIntMatrix $Snap.unit this@26@00 G@27@00 V@29@00))
(assert (= ($Snap.second ($Snap.second s@$)) $Snap.unit))
(assert (SquareIntMatrix $Snap.unit this@26@00 Gf@28@00 V@29@00))
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
; [eval] (forall i1: Int :: { Gf[i1] } { G[i1] } 0 <= i1 && i1 < V ==> (forall j: Int :: { Gf[i1][j] } { G[i1][j] } 0 <= j && j < V ==> Gf[i1][j] <= G[i1][j]))
(declare-const i1@111@00 Int)
(push) ; 2
; [eval] 0 <= i1 && i1 < V ==> (forall j: Int :: { Gf[i1][j] } { G[i1][j] } 0 <= j && j < V ==> Gf[i1][j] <= G[i1][j])
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 3
; [then-branch: 13 | 0 <= i1@111@00 | live]
; [else-branch: 13 | !(0 <= i1@111@00) | live]
(push) ; 4
; [then-branch: 13 | 0 <= i1@111@00]
(assert (<= 0 i1@111@00))
; [eval] i1 < V
(pop) ; 4
(push) ; 4
; [else-branch: 13 | !(0 <= i1@111@00)]
(assert (not (<= 0 i1@111@00)))
(pop) ; 4
(pop) ; 3
; Joined path conditions
; Joined path conditions
(push) ; 3
; [then-branch: 14 | i1@111@00 < V@29@00 && 0 <= i1@111@00 | live]
; [else-branch: 14 | !(i1@111@00 < V@29@00 && 0 <= i1@111@00) | live]
(push) ; 4
; [then-branch: 14 | i1@111@00 < V@29@00 && 0 <= i1@111@00]
(assert (and (< i1@111@00 V@29@00) (<= 0 i1@111@00)))
; [eval] (forall j: Int :: { Gf[i1][j] } { G[i1][j] } 0 <= j && j < V ==> Gf[i1][j] <= G[i1][j])
(declare-const j@112@00 Int)
(push) ; 5
; [eval] 0 <= j && j < V ==> Gf[i1][j] <= G[i1][j]
; [eval] 0 <= j && j < V
; [eval] 0 <= j
(push) ; 6
; [then-branch: 15 | 0 <= j@112@00 | live]
; [else-branch: 15 | !(0 <= j@112@00) | live]
(push) ; 7
; [then-branch: 15 | 0 <= j@112@00]
(assert (<= 0 j@112@00))
; [eval] j < V
(pop) ; 7
(push) ; 7
; [else-branch: 15 | !(0 <= j@112@00)]
(assert (not (<= 0 j@112@00)))
(pop) ; 7
(pop) ; 6
; Joined path conditions
; Joined path conditions
(push) ; 6
; [then-branch: 16 | j@112@00 < V@29@00 && 0 <= j@112@00 | live]
; [else-branch: 16 | !(j@112@00 < V@29@00 && 0 <= j@112@00) | live]
(push) ; 7
; [then-branch: 16 | j@112@00 < V@29@00 && 0 <= j@112@00]
(assert (and (< j@112@00 V@29@00) (<= 0 j@112@00)))
; [eval] Gf[i1][j] <= G[i1][j]
; [eval] Gf[i1][j]
; [eval] Gf[i1]
(set-option :timeout 0)
(push) ; 8
(assert (not (>= i1@111@00 0)))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs             111
;  :arith-add-rows        74
;  :arith-assert-diseq    33
;  :arith-assert-lower    64
;  :arith-assert-upper    37
;  :arith-bound-prop      20
;  :arith-conflicts       7
;  :arith-eq-adapter      29
;  :arith-fixed-eqs       10
;  :arith-offset-eqs      4
;  :arith-pivots          40
;  :conflicts             17
;  :datatype-accessor-ax  20
;  :datatype-occurs-check 10
;  :decisions             8
;  :del-clause            352
;  :final-checks          10
;  :max-generation        5
;  :max-memory            4.25
;  :memory                4.09
;  :mk-bool-var           752
;  :mk-clause             387
;  :num-allocs            139813
;  :num-checks            25
;  :propagations          141
;  :quant-instantiations  97
;  :rlimit-count          151673)
(push) ; 8
(assert (not (< i1@111@00 (Seq_length Gf@28@00))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs             111
;  :arith-add-rows        77
;  :arith-assert-diseq    33
;  :arith-assert-lower    64
;  :arith-assert-upper    38
;  :arith-bound-prop      20
;  :arith-conflicts       8
;  :arith-eq-adapter      29
;  :arith-fixed-eqs       10
;  :arith-offset-eqs      4
;  :arith-pivots          42
;  :conflicts             18
;  :datatype-accessor-ax  20
;  :datatype-occurs-check 10
;  :decisions             8
;  :del-clause            352
;  :final-checks          10
;  :max-generation        5
;  :max-memory            4.25
;  :memory                4.09
;  :mk-bool-var           753
;  :mk-clause             387
;  :num-allocs            139893
;  :num-checks            26
;  :propagations          141
;  :quant-instantiations  97
;  :rlimit-count          151810)
(push) ; 8
(assert (not (>= j@112@00 0)))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs             111
;  :arith-add-rows        77
;  :arith-assert-diseq    33
;  :arith-assert-lower    64
;  :arith-assert-upper    38
;  :arith-bound-prop      20
;  :arith-conflicts       8
;  :arith-eq-adapter      29
;  :arith-fixed-eqs       10
;  :arith-offset-eqs      4
;  :arith-pivots          42
;  :conflicts             18
;  :datatype-accessor-ax  20
;  :datatype-occurs-check 10
;  :decisions             8
;  :del-clause            352
;  :final-checks          10
;  :max-generation        5
;  :max-memory            4.25
;  :memory                4.09
;  :mk-bool-var           753
;  :mk-clause             387
;  :num-allocs            139912
;  :num-checks            27
;  :propagations          141
;  :quant-instantiations  97
;  :rlimit-count          151819)
(push) ; 8
(assert (not (< j@112@00 (Seq_length (Seq_index Gf@28@00 i1@111@00)))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs             116
;  :arith-add-rows        88
;  :arith-assert-diseq    40
;  :arith-assert-lower    69
;  :arith-assert-upper    40
;  :arith-bound-prop      20
;  :arith-conflicts       10
;  :arith-eq-adapter      31
;  :arith-fixed-eqs       11
;  :arith-offset-eqs      5
;  :arith-pivots          46
;  :conflicts             22
;  :datatype-accessor-ax  20
;  :datatype-occurs-check 10
;  :decisions             11
;  :del-clause            418
;  :final-checks          10
;  :max-generation        5
;  :max-memory            4.25
;  :memory                4.10
;  :mk-bool-var           820
;  :mk-clause             453
;  :num-allocs            140284
;  :num-checks            28
;  :propagations          168
;  :quant-instantiations  110
;  :rlimit-count          152820)
; [eval] G[i1][j]
; [eval] G[i1]
(push) ; 8
(assert (not (>= i1@111@00 0)))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs             116
;  :arith-add-rows        88
;  :arith-assert-diseq    40
;  :arith-assert-lower    69
;  :arith-assert-upper    40
;  :arith-bound-prop      20
;  :arith-conflicts       10
;  :arith-eq-adapter      31
;  :arith-fixed-eqs       11
;  :arith-offset-eqs      5
;  :arith-pivots          46
;  :conflicts             22
;  :datatype-accessor-ax  20
;  :datatype-occurs-check 10
;  :decisions             11
;  :del-clause            418
;  :final-checks          10
;  :max-generation        5
;  :max-memory            4.25
;  :memory                4.10
;  :mk-bool-var           820
;  :mk-clause             453
;  :num-allocs            140303
;  :num-checks            29
;  :propagations          168
;  :quant-instantiations  110
;  :rlimit-count          152829)
(push) ; 8
(assert (not (< i1@111@00 (Seq_length G@27@00))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs             116
;  :arith-add-rows        90
;  :arith-assert-diseq    40
;  :arith-assert-lower    69
;  :arith-assert-upper    41
;  :arith-bound-prop      20
;  :arith-conflicts       11
;  :arith-eq-adapter      31
;  :arith-fixed-eqs       11
;  :arith-offset-eqs      5
;  :arith-pivots          48
;  :conflicts             23
;  :datatype-accessor-ax  20
;  :datatype-occurs-check 10
;  :decisions             11
;  :del-clause            418
;  :final-checks          10
;  :max-generation        5
;  :max-memory            4.25
;  :memory                4.10
;  :mk-bool-var           821
;  :mk-clause             453
;  :num-allocs            140378
;  :num-checks            30
;  :propagations          168
;  :quant-instantiations  110
;  :rlimit-count          152953)
(push) ; 8
(assert (not (>= j@112@00 0)))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs             116
;  :arith-add-rows        90
;  :arith-assert-diseq    40
;  :arith-assert-lower    69
;  :arith-assert-upper    41
;  :arith-bound-prop      20
;  :arith-conflicts       11
;  :arith-eq-adapter      31
;  :arith-fixed-eqs       11
;  :arith-offset-eqs      5
;  :arith-pivots          48
;  :conflicts             23
;  :datatype-accessor-ax  20
;  :datatype-occurs-check 10
;  :decisions             11
;  :del-clause            418
;  :final-checks          10
;  :max-generation        5
;  :max-memory            4.25
;  :memory                4.10
;  :mk-bool-var           821
;  :mk-clause             453
;  :num-allocs            140397
;  :num-checks            31
;  :propagations          168
;  :quant-instantiations  110
;  :rlimit-count          152962)
(push) ; 8
(assert (not (< j@112@00 (Seq_length (Seq_index G@27@00 i1@111@00)))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs             121
;  :arith-add-rows        99
;  :arith-assert-diseq    47
;  :arith-assert-lower    74
;  :arith-assert-upper    43
;  :arith-bound-prop      20
;  :arith-conflicts       13
;  :arith-eq-adapter      33
;  :arith-fixed-eqs       12
;  :arith-offset-eqs      6
;  :arith-pivots          52
;  :conflicts             27
;  :datatype-accessor-ax  20
;  :datatype-occurs-check 10
;  :decisions             14
;  :del-clause            484
;  :final-checks          10
;  :max-generation        5
;  :max-memory            4.25
;  :memory                4.11
;  :mk-bool-var           888
;  :mk-clause             519
;  :num-allocs            140721
;  :num-checks            32
;  :propagations          195
;  :quant-instantiations  123
;  :rlimit-count          153955)
(pop) ; 7
(push) ; 7
; [else-branch: 16 | !(j@112@00 < V@29@00 && 0 <= j@112@00)]
(assert (not (and (< j@112@00 V@29@00) (<= 0 j@112@00))))
(pop) ; 7
(pop) ; 6
; Joined path conditions
; Joined path conditions
(pop) ; 5
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 4
(push) ; 4
; [else-branch: 14 | !(i1@111@00 < V@29@00 && 0 <= i1@111@00)]
(assert (not (and (< i1@111@00 V@29@00) (<= 0 i1@111@00))))
(pop) ; 4
(pop) ; 3
; Joined path conditions
; Joined path conditions
(pop) ; 2
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
; Nested auxiliary terms: non-globals (tlq)
(assert (=
  result@30@00
  (forall ((i1@111@00 Int)) (!
    (implies
      (and (< i1@111@00 V@29@00) (<= 0 i1@111@00))
      (forall ((j@112@00 Int)) (!
        (implies
          (and (< j@112@00 V@29@00) (<= 0 j@112@00))
          (<=
            (Seq_index (Seq_index Gf@28@00 i1@111@00) j@112@00)
            (Seq_index (Seq_index G@27@00 i1@111@00) j@112@00)))
        :pattern ((Seq_index (Seq_index Gf@28@00 i1@111@00) j@112@00))
        :pattern ((Seq_index (Seq_index G@27@00 i1@111@00) j@112@00))
        :qid |prog.l<no position>|)))
    :pattern ((Seq_index Gf@28@00 i1@111@00))
    :pattern ((Seq_index G@27@00 i1@111@00))
    :qid |prog.l<no position>|))))
(pop) ; 1
(assert (forall ((s@$ $Snap) (this@26@00 $Ref) (G@27@00 Seq<Seq<Int>>) (Gf@28@00 Seq<Seq<Int>>) (V@29@00 Int)) (!
  (implies
    (and
      (not (= this@26@00 $Ref.null))
      (SquareIntMatrix $Snap.unit this@26@00 G@27@00 V@29@00)
      (SquareIntMatrix $Snap.unit this@26@00 Gf@28@00 V@29@00))
    (=
      (CapacityConstraint s@$ this@26@00 G@27@00 Gf@28@00 V@29@00)
      (forall ((i1 Int)) (!
        (implies
          (and (<= 0 i1) (< i1 V@29@00))
          (forall ((j Int)) (!
            (implies
              (and (<= 0 j) (< j V@29@00))
              (<=
                (Seq_index (Seq_index Gf@28@00 i1) j)
                (Seq_index (Seq_index G@27@00 i1) j)))
            :pattern ((Seq_index (Seq_index Gf@28@00 i1) j))
            :pattern ((Seq_index (Seq_index G@27@00 i1) j))
            )))
        :pattern ((Seq_index Gf@28@00 i1))
        :pattern ((Seq_index G@27@00 i1))
        ))))
  :pattern ((CapacityConstraint s@$ this@26@00 G@27@00 Gf@28@00 V@29@00))
  )))
; ---------- FUNCTION FlowConservation----------
(declare-fun this@31@00 () $Ref)
(declare-fun G@32@00 () Seq<Seq<Int>>)
(declare-fun V@33@00 () Int)
(declare-fun s@34@00 () Int)
(declare-fun t@35@00 () Int)
(declare-fun result@36@00 () Bool)
; ----- Well-definedness of specifications -----
(push) ; 1
(assert (= s@$ ($Snap.combine ($Snap.first s@$) ($Snap.second s@$))))
(assert (= ($Snap.first s@$) $Snap.unit))
; [eval] this != null
(assert (not (= this@31@00 $Ref.null)))
(assert (= ($Snap.second s@$) $Snap.unit))
; [eval] FlowNetwork(this, G, V, s, t)
(push) ; 2
; [eval] this != null
(pop) ; 2
; Joined path conditions
(assert (FlowNetwork $Snap.unit this@31@00 G@32@00 V@33@00 s@34@00 t@35@00))
(pop) ; 1
(assert (forall ((s@$ $Snap) (this@31@00 $Ref) (G@32@00 Seq<Seq<Int>>) (V@33@00 Int) (s@34@00 Int) (t@35@00 Int)) (!
  (=
    (FlowConservation%limited s@$ this@31@00 G@32@00 V@33@00 s@34@00 t@35@00)
    (FlowConservation s@$ this@31@00 G@32@00 V@33@00 s@34@00 t@35@00))
  :pattern ((FlowConservation s@$ this@31@00 G@32@00 V@33@00 s@34@00 t@35@00))
  )))
(assert (forall ((s@$ $Snap) (this@31@00 $Ref) (G@32@00 Seq<Seq<Int>>) (V@33@00 Int) (s@34@00 Int) (t@35@00 Int)) (!
  (FlowConservation%stateless this@31@00 G@32@00 V@33@00 s@34@00 t@35@00)
  :pattern ((FlowConservation%limited s@$ this@31@00 G@32@00 V@33@00 s@34@00 t@35@00))
  )))
; ----- Verification of function body and postcondition -----
(push) ; 1
(assert (= s@$ ($Snap.combine ($Snap.first s@$) ($Snap.second s@$))))
(assert (= ($Snap.first s@$) $Snap.unit))
(assert (not (= this@31@00 $Ref.null)))
(assert (= ($Snap.second s@$) $Snap.unit))
(assert (FlowNetwork $Snap.unit this@31@00 G@32@00 V@33@00 s@34@00 t@35@00))
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
; [eval] SumIncomingFlow(this, G, V - 1, s, V) <= SumOutgoingFlow(this, G, V - 1, s, V) && SumOutgoingFlow(this, G, V - 1, t, V) <= SumIncomingFlow(this, G, V - 1, t, V) && (forall v: Int, fresh__1: Int :: { SumOutgoingFlow(this, G, fresh__1, v, V) } 0 <= v && v < V && v != s && v != t ==> SumIncomingFlow(this, G, V - 1, v, V) == SumOutgoingFlow(this, G, V - 1, v, V))
; [eval] SumIncomingFlow(this, G, V - 1, s, V) <= SumOutgoingFlow(this, G, V - 1, s, V)
; [eval] SumIncomingFlow(this, G, V - 1, s, V)
; [eval] V - 1
(push) ; 2
; [eval] this != null
; [eval] FlowNetwork(this, G, V, n, v)
(push) ; 3
; [eval] this != null
(pop) ; 3
; Joined path conditions
(set-option :timeout 0)
(push) ; 3
(assert (not (FlowNetwork $Snap.unit this@31@00 G@32@00 V@33@00 (- V@33@00 1) s@34@00)))
(check-sat)
; unsat
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs             142
;  :arith-add-rows        117
;  :arith-assert-diseq    49
;  :arith-assert-lower    82
;  :arith-assert-upper    48
;  :arith-bound-prop      23
;  :arith-conflicts       14
;  :arith-eq-adapter      37
;  :arith-fixed-eqs       14
;  :arith-offset-eqs      7
;  :arith-pivots          61
;  :conflicts             28
;  :datatype-accessor-ax  24
;  :datatype-occurs-check 11
;  :decisions             15
;  :del-clause            568
;  :final-checks          12
;  :interface-eqs         1
;  :max-generation        5
;  :max-memory            4.25
;  :memory                4.12
;  :mk-bool-var           964
;  :mk-clause             585
;  :num-allocs            142754
;  :num-checks            34
;  :propagations          220
;  :quant-instantiations  138
;  :rlimit-count          157306)
(assert (FlowNetwork $Snap.unit this@31@00 G@32@00 V@33@00 (- V@33@00 1) s@34@00))
(pop) ; 2
; Joined path conditions
(assert (FlowNetwork $Snap.unit this@31@00 G@32@00 V@33@00 (- V@33@00 1) s@34@00))
; [eval] SumOutgoingFlow(this, G, V - 1, s, V)
; [eval] V - 1
(push) ; 2
; [eval] this != null
; [eval] FlowNetwork(this, G, V, n, v)
(push) ; 3
; [eval] this != null
(pop) ; 3
; Joined path conditions
(pop) ; 2
; Joined path conditions
(push) ; 2
; [then-branch: 17 | SumIncomingFlow((_, _), this@31@00, G@32@00, V@33@00 - 1, s@34@00, V@33@00) <= SumOutgoingFlow((_, _), this@31@00, G@32@00, V@33@00 - 1, s@34@00, V@33@00) | live]
; [else-branch: 17 | !(SumIncomingFlow((_, _), this@31@00, G@32@00, V@33@00 - 1, s@34@00, V@33@00) <= SumOutgoingFlow((_, _), this@31@00, G@32@00, V@33@00 - 1, s@34@00, V@33@00)) | live]
(push) ; 3
; [then-branch: 17 | SumIncomingFlow((_, _), this@31@00, G@32@00, V@33@00 - 1, s@34@00, V@33@00) <= SumOutgoingFlow((_, _), this@31@00, G@32@00, V@33@00 - 1, s@34@00, V@33@00)]
(assert (<=
  (SumIncomingFlow ($Snap.combine $Snap.unit $Snap.unit) this@31@00 G@32@00 (-
    V@33@00
    1) s@34@00 V@33@00)
  (SumOutgoingFlow ($Snap.combine $Snap.unit $Snap.unit) this@31@00 G@32@00 (-
    V@33@00
    1) s@34@00 V@33@00)))
; [eval] SumOutgoingFlow(this, G, V - 1, t, V) <= SumIncomingFlow(this, G, V - 1, t, V)
; [eval] SumOutgoingFlow(this, G, V - 1, t, V)
; [eval] V - 1
(push) ; 4
; [eval] this != null
; [eval] FlowNetwork(this, G, V, n, v)
(push) ; 5
; [eval] this != null
(pop) ; 5
; Joined path conditions
(push) ; 5
(assert (not (FlowNetwork $Snap.unit this@31@00 G@32@00 V@33@00 (- V@33@00 1) t@35@00)))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs             146
;  :arith-add-rows        117
;  :arith-assert-diseq    49
;  :arith-assert-lower    83
;  :arith-assert-upper    49
;  :arith-bound-prop      23
;  :arith-conflicts       14
;  :arith-eq-adapter      37
;  :arith-fixed-eqs       14
;  :arith-offset-eqs      7
;  :arith-pivots          62
;  :conflicts             29
;  :datatype-accessor-ax  24
;  :datatype-occurs-check 11
;  :decisions             15
;  :del-clause            570
;  :final-checks          12
;  :interface-eqs         1
;  :max-generation        5
;  :max-memory            4.25
;  :memory                4.14
;  :mk-bool-var           988
;  :mk-clause             597
;  :num-allocs            143127
;  :num-checks            35
;  :propagations          223
;  :quant-instantiations  149
;  :rlimit-count          157855)
(assert (FlowNetwork $Snap.unit this@31@00 G@32@00 V@33@00 (- V@33@00 1) t@35@00))
(pop) ; 4
; Joined path conditions
(assert (FlowNetwork $Snap.unit this@31@00 G@32@00 V@33@00 (- V@33@00 1) t@35@00))
; [eval] SumIncomingFlow(this, G, V - 1, t, V)
; [eval] V - 1
(push) ; 4
; [eval] this != null
; [eval] FlowNetwork(this, G, V, n, v)
(push) ; 5
; [eval] this != null
(pop) ; 5
; Joined path conditions
(pop) ; 4
; Joined path conditions
(push) ; 4
; [then-branch: 18 | SumOutgoingFlow((_, _), this@31@00, G@32@00, V@33@00 - 1, t@35@00, V@33@00) <= SumIncomingFlow((_, _), this@31@00, G@32@00, V@33@00 - 1, t@35@00, V@33@00) | live]
; [else-branch: 18 | !(SumOutgoingFlow((_, _), this@31@00, G@32@00, V@33@00 - 1, t@35@00, V@33@00) <= SumIncomingFlow((_, _), this@31@00, G@32@00, V@33@00 - 1, t@35@00, V@33@00)) | live]
(push) ; 5
; [then-branch: 18 | SumOutgoingFlow((_, _), this@31@00, G@32@00, V@33@00 - 1, t@35@00, V@33@00) <= SumIncomingFlow((_, _), this@31@00, G@32@00, V@33@00 - 1, t@35@00, V@33@00)]
(assert (<=
  (SumOutgoingFlow ($Snap.combine $Snap.unit $Snap.unit) this@31@00 G@32@00 (-
    V@33@00
    1) t@35@00 V@33@00)
  (SumIncomingFlow ($Snap.combine $Snap.unit $Snap.unit) this@31@00 G@32@00 (-
    V@33@00
    1) t@35@00 V@33@00)))
; [eval] (forall v: Int, fresh__1: Int :: { SumOutgoingFlow(this, G, fresh__1, v, V) } 0 <= v && v < V && v != s && v != t ==> SumIncomingFlow(this, G, V - 1, v, V) == SumOutgoingFlow(this, G, V - 1, v, V))
(declare-const v@113@00 Int)
(declare-const fresh__1@114@00 Int)
(push) ; 6
; [eval] 0 <= v && v < V && v != s && v != t ==> SumIncomingFlow(this, G, V - 1, v, V) == SumOutgoingFlow(this, G, V - 1, v, V)
; [eval] 0 <= v && v < V && v != s && v != t
; [eval] 0 <= v
(push) ; 7
; [then-branch: 19 | 0 <= v@113@00 | live]
; [else-branch: 19 | !(0 <= v@113@00) | live]
(push) ; 8
; [then-branch: 19 | 0 <= v@113@00]
(assert (<= 0 v@113@00))
; [eval] v < V
(push) ; 9
; [then-branch: 20 | v@113@00 < V@33@00 | live]
; [else-branch: 20 | !(v@113@00 < V@33@00) | live]
(push) ; 10
; [then-branch: 20 | v@113@00 < V@33@00]
(assert (< v@113@00 V@33@00))
; [eval] v != s
(push) ; 11
; [then-branch: 21 | v@113@00 != s@34@00 | live]
; [else-branch: 21 | v@113@00 == s@34@00 | live]
(push) ; 12
; [then-branch: 21 | v@113@00 != s@34@00]
(assert (not (= v@113@00 s@34@00)))
; [eval] v != t
(pop) ; 12
(push) ; 12
; [else-branch: 21 | v@113@00 == s@34@00]
(assert (= v@113@00 s@34@00))
(pop) ; 12
(pop) ; 11
; Joined path conditions
; Joined path conditions
(pop) ; 10
(push) ; 10
; [else-branch: 20 | !(v@113@00 < V@33@00)]
(assert (not (< v@113@00 V@33@00)))
(pop) ; 10
(pop) ; 9
; Joined path conditions
; Joined path conditions
(pop) ; 8
(push) ; 8
; [else-branch: 19 | !(0 <= v@113@00)]
(assert (not (<= 0 v@113@00)))
(pop) ; 8
(pop) ; 7
; Joined path conditions
; Joined path conditions
(push) ; 7
; [then-branch: 22 | v@113@00 != t@35@00 && v@113@00 != s@34@00 && v@113@00 < V@33@00 && 0 <= v@113@00 | live]
; [else-branch: 22 | !(v@113@00 != t@35@00 && v@113@00 != s@34@00 && v@113@00 < V@33@00 && 0 <= v@113@00) | live]
(push) ; 8
; [then-branch: 22 | v@113@00 != t@35@00 && v@113@00 != s@34@00 && v@113@00 < V@33@00 && 0 <= v@113@00]
(assert (and
  (and
    (and (not (= v@113@00 t@35@00)) (not (= v@113@00 s@34@00)))
    (< v@113@00 V@33@00))
  (<= 0 v@113@00)))
; [eval] SumIncomingFlow(this, G, V - 1, v, V) == SumOutgoingFlow(this, G, V - 1, v, V)
; [eval] SumIncomingFlow(this, G, V - 1, v, V)
; [eval] V - 1
(push) ; 9
; [eval] this != null
; [eval] FlowNetwork(this, G, V, n, v)
(push) ; 10
; [eval] this != null
(pop) ; 10
; Joined path conditions
(push) ; 10
(assert (not (FlowNetwork $Snap.unit this@31@00 G@32@00 V@33@00 (- V@33@00 1) v@113@00)))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs             152
;  :arith-add-rows        118
;  :arith-assert-diseq    55
;  :arith-assert-lower    87
;  :arith-assert-upper    50
;  :arith-bound-prop      23
;  :arith-conflicts       14
;  :arith-eq-adapter      39
;  :arith-fixed-eqs       14
;  :arith-offset-eqs      7
;  :arith-pivots          63
;  :conflicts             30
;  :datatype-accessor-ax  24
;  :datatype-occurs-check 11
;  :decisions             15
;  :del-clause            572
;  :final-checks          12
;  :interface-eqs         1
;  :max-generation        5
;  :max-memory            4.25
;  :memory                4.16
;  :mk-bool-var           1022
;  :mk-clause             613
;  :num-allocs            143748
;  :num-checks            36
;  :propagations          224
;  :quant-instantiations  160
;  :rlimit-count          158845)
(assert (FlowNetwork $Snap.unit this@31@00 G@32@00 V@33@00 (- V@33@00 1) v@113@00))
(pop) ; 9
; Joined path conditions
(assert (FlowNetwork $Snap.unit this@31@00 G@32@00 V@33@00 (- V@33@00 1) v@113@00))
; [eval] SumOutgoingFlow(this, G, V - 1, v, V)
; [eval] V - 1
(push) ; 9
; [eval] this != null
; [eval] FlowNetwork(this, G, V, n, v)
(push) ; 10
; [eval] this != null
(pop) ; 10
; Joined path conditions
(pop) ; 9
; Joined path conditions
(pop) ; 8
(push) ; 8
; [else-branch: 22 | !(v@113@00 != t@35@00 && v@113@00 != s@34@00 && v@113@00 < V@33@00 && 0 <= v@113@00)]
(assert (not
  (and
    (and
      (and (not (= v@113@00 t@35@00)) (not (= v@113@00 s@34@00)))
      (< v@113@00 V@33@00))
    (<= 0 v@113@00))))
(pop) ; 8
(pop) ; 7
; Joined path conditions
(assert (implies
  (and
    (and
      (and (not (= v@113@00 t@35@00)) (not (= v@113@00 s@34@00)))
      (< v@113@00 V@33@00))
    (<= 0 v@113@00))
  (and
    (not (= v@113@00 t@35@00))
    (not (= v@113@00 s@34@00))
    (< v@113@00 V@33@00)
    (<= 0 v@113@00)
    (FlowNetwork $Snap.unit this@31@00 G@32@00 V@33@00 (- V@33@00 1) v@113@00))))
; Joined path conditions
; [eval] SumOutgoingFlow(this, G, fresh__1, v, V)
(push) ; 7
; [eval] this != null
; [eval] FlowNetwork(this, G, V, n, v)
(push) ; 8
; [eval] this != null
(pop) ; 8
; Joined path conditions
(push) ; 8
(assert (not (FlowNetwork $Snap.unit this@31@00 G@32@00 V@33@00 fresh__1@114@00 v@113@00)))
(check-sat)
; unknown
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs             208
;  :arith-add-rows        193
;  :arith-assert-diseq    59
;  :arith-assert-lower    107
;  :arith-assert-upper    64
;  :arith-bound-prop      28
;  :arith-conflicts       14
;  :arith-eq-adapter      53
;  :arith-fixed-eqs       27
;  :arith-offset-eqs      8
;  :arith-pivots          85
;  :conflicts             30
;  :datatype-accessor-ax  24
;  :datatype-occurs-check 12
;  :decisions             20
;  :del-clause            612
;  :final-checks          14
;  :interface-eqs         2
;  :max-generation        5
;  :max-memory            4.25
;  :memory                4.23
;  :mk-bool-var           1096
;  :mk-clause             660
;  :num-allocs            145253
;  :num-checks            37
;  :propagations          238
;  :quant-instantiations  174
;  :rlimit-count          161396)
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; [eval] FlowNetwork(this, G, V, n, v)
(push) ; 8
; [eval] this != null
(pop) ; 8
; Joined path conditions
(set-option :timeout 0)
(push) ; 8
(assert (not (FlowNetwork $Snap.unit this@31@00 G@32@00 V@33@00 fresh__1@114@00 v@113@00)))
(check-sat)
; unknown
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs             316
;  :arith-add-rows        331
;  :arith-assert-diseq    67
;  :arith-assert-lower    147
;  :arith-assert-upper    92
;  :arith-bound-prop      31
;  :arith-conflicts       14
;  :arith-eq-adapter      77
;  :arith-fixed-eqs       53
;  :arith-offset-eqs      10
;  :arith-pivots          124
;  :conflicts             30
;  :datatype-accessor-ax  24
;  :datatype-occurs-check 14
;  :decisions             34
;  :del-clause            650
;  :final-checks          18
;  :interface-eqs         4
;  :max-generation        5
;  :max-memory            4.26
;  :memory                4.24
;  :mk-bool-var           1196
;  :mk-clause             701
;  :num-allocs            147150
;  :num-checks            39
;  :propagations          263
;  :quant-instantiations  193
;  :rlimit-count          165635)
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; [eval] FlowNetwork(this, G, V, n, v)
(push) ; 8
; [eval] this != null
(pop) ; 8
; Joined path conditions
(set-option :timeout 0)
(push) ; 8
(assert (not (FlowNetwork $Snap.unit this@31@00 G@32@00 V@33@00 fresh__1@114@00 v@113@00)))
(check-sat)
; unknown
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs             426
;  :arith-add-rows        443
;  :arith-assert-diseq    75
;  :arith-assert-lower    187
;  :arith-assert-upper    120
;  :arith-bound-prop      31
;  :arith-conflicts       14
;  :arith-eq-adapter      101
;  :arith-fixed-eqs       81
;  :arith-offset-eqs      12
;  :arith-pivots          160
;  :conflicts             30
;  :datatype-accessor-ax  24
;  :datatype-occurs-check 16
;  :decisions             48
;  :del-clause            686
;  :final-checks          22
;  :interface-eqs         6
;  :max-generation        5
;  :max-memory            4.26
;  :memory                4.24
;  :mk-bool-var           1292
;  :mk-clause             736
;  :num-allocs            148966
;  :num-checks            41
;  :propagations          289
;  :quant-instantiations  212
;  :rlimit-count          169534)
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; [eval] FlowNetwork(this, G, V, n, v)
(push) ; 8
; [eval] this != null
(pop) ; 8
; Joined path conditions
(set-option :timeout 0)
(push) ; 8
(assert (not (FlowNetwork $Snap.unit this@31@00 G@32@00 V@33@00 fresh__1@114@00 v@113@00)))
(check-sat)
; unknown
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs             536
;  :arith-add-rows        555
;  :arith-assert-diseq    83
;  :arith-assert-lower    227
;  :arith-assert-upper    148
;  :arith-bound-prop      31
;  :arith-conflicts       14
;  :arith-eq-adapter      125
;  :arith-fixed-eqs       109
;  :arith-offset-eqs      14
;  :arith-pivots          196
;  :conflicts             30
;  :datatype-accessor-ax  24
;  :datatype-occurs-check 18
;  :decisions             62
;  :del-clause            721
;  :final-checks          26
;  :interface-eqs         8
;  :max-generation        5
;  :max-memory            4.26
;  :memory                4.24
;  :mk-bool-var           1388
;  :mk-clause             771
;  :num-allocs            150779
;  :num-checks            43
;  :propagations          315
;  :quant-instantiations  231
;  :rlimit-count          173433)
(pop) ; 7
(pop) ; 6
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((v@113@00 Int) (fresh__1@114@00 Int)) (!
  (implies
    (and
      (and
        (and (not (= v@113@00 t@35@00)) (not (= v@113@00 s@34@00)))
        (< v@113@00 V@33@00))
      (<= 0 v@113@00))
    (and
      (not (= v@113@00 t@35@00))
      (not (= v@113@00 s@34@00))
      (< v@113@00 V@33@00)
      (<= 0 v@113@00)
      (FlowNetwork $Snap.unit this@31@00 G@32@00 V@33@00 (- V@33@00 1) v@113@00)))
  :pattern ()
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 5
(push) ; 5
; [else-branch: 18 | !(SumOutgoingFlow((_, _), this@31@00, G@32@00, V@33@00 - 1, t@35@00, V@33@00) <= SumIncomingFlow((_, _), this@31@00, G@32@00, V@33@00 - 1, t@35@00, V@33@00))]
(assert (not
  (<=
    (SumOutgoingFlow ($Snap.combine $Snap.unit $Snap.unit) this@31@00 G@32@00 (-
      V@33@00
      1) t@35@00 V@33@00)
    (SumIncomingFlow ($Snap.combine $Snap.unit $Snap.unit) this@31@00 G@32@00 (-
      V@33@00
      1) t@35@00 V@33@00))))
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (implies
  (<=
    (SumOutgoingFlow ($Snap.combine $Snap.unit $Snap.unit) this@31@00 G@32@00 (-
      V@33@00
      1) t@35@00 V@33@00)
    (SumIncomingFlow ($Snap.combine $Snap.unit $Snap.unit) this@31@00 G@32@00 (-
      V@33@00
      1) t@35@00 V@33@00))
  (and
    (<=
      (SumOutgoingFlow ($Snap.combine $Snap.unit $Snap.unit) this@31@00 G@32@00 (-
        V@33@00
        1) t@35@00 V@33@00)
      (SumIncomingFlow ($Snap.combine $Snap.unit $Snap.unit) this@31@00 G@32@00 (-
        V@33@00
        1) t@35@00 V@33@00))
    (forall ((v@113@00 Int) (fresh__1@114@00 Int)) (!
      (implies
        (and
          (and
            (and (not (= v@113@00 t@35@00)) (not (= v@113@00 s@34@00)))
            (< v@113@00 V@33@00))
          (<= 0 v@113@00))
        (and
          (not (= v@113@00 t@35@00))
          (not (= v@113@00 s@34@00))
          (< v@113@00 V@33@00)
          (<= 0 v@113@00)
          (FlowNetwork $Snap.unit this@31@00 G@32@00 V@33@00 (- V@33@00 1) v@113@00)))
      :pattern ()
      :qid |prog.l<no position>-aux|)))))
; Joined path conditions
(pop) ; 3
(push) ; 3
; [else-branch: 17 | !(SumIncomingFlow((_, _), this@31@00, G@32@00, V@33@00 - 1, s@34@00, V@33@00) <= SumOutgoingFlow((_, _), this@31@00, G@32@00, V@33@00 - 1, s@34@00, V@33@00))]
(assert (not
  (<=
    (SumIncomingFlow ($Snap.combine $Snap.unit $Snap.unit) this@31@00 G@32@00 (-
      V@33@00
      1) s@34@00 V@33@00)
    (SumOutgoingFlow ($Snap.combine $Snap.unit $Snap.unit) this@31@00 G@32@00 (-
      V@33@00
      1) s@34@00 V@33@00))))
(pop) ; 3
(pop) ; 2
; Joined path conditions
(assert (implies
  (<=
    (SumIncomingFlow ($Snap.combine $Snap.unit $Snap.unit) this@31@00 G@32@00 (-
      V@33@00
      1) s@34@00 V@33@00)
    (SumOutgoingFlow ($Snap.combine $Snap.unit $Snap.unit) this@31@00 G@32@00 (-
      V@33@00
      1) s@34@00 V@33@00))
  (and
    (<=
      (SumIncomingFlow ($Snap.combine $Snap.unit $Snap.unit) this@31@00 G@32@00 (-
        V@33@00
        1) s@34@00 V@33@00)
      (SumOutgoingFlow ($Snap.combine $Snap.unit $Snap.unit) this@31@00 G@32@00 (-
        V@33@00
        1) s@34@00 V@33@00))
    (FlowNetwork $Snap.unit this@31@00 G@32@00 V@33@00 (- V@33@00 1) t@35@00)
    (implies
      (<=
        (SumOutgoingFlow ($Snap.combine $Snap.unit $Snap.unit) this@31@00 G@32@00 (-
          V@33@00
          1) t@35@00 V@33@00)
        (SumIncomingFlow ($Snap.combine $Snap.unit $Snap.unit) this@31@00 G@32@00 (-
          V@33@00
          1) t@35@00 V@33@00))
      (and
        (<=
          (SumOutgoingFlow ($Snap.combine $Snap.unit $Snap.unit) this@31@00 G@32@00 (-
            V@33@00
            1) t@35@00 V@33@00)
          (SumIncomingFlow ($Snap.combine $Snap.unit $Snap.unit) this@31@00 G@32@00 (-
            V@33@00
            1) t@35@00 V@33@00))
        (forall ((v@113@00 Int) (fresh__1@114@00 Int)) (!
          (implies
            (and
              (and
                (and (not (= v@113@00 t@35@00)) (not (= v@113@00 s@34@00)))
                (< v@113@00 V@33@00))
              (<= 0 v@113@00))
            (and
              (not (= v@113@00 t@35@00))
              (not (= v@113@00 s@34@00))
              (< v@113@00 V@33@00)
              (<= 0 v@113@00)
              (FlowNetwork $Snap.unit this@31@00 G@32@00 V@33@00 (- V@33@00 1) v@113@00)))
          :pattern ()
          :qid |prog.l<no position>-aux|)))))))
; Joined path conditions
(assert (=
  result@36@00
  (and
    (and
      (forall ((v@113@00 Int) (fresh__1@114@00 Int)) (!
        (implies
          (and
            (and
              (and (not (= v@113@00 t@35@00)) (not (= v@113@00 s@34@00)))
              (< v@113@00 V@33@00))
            (<= 0 v@113@00))
          (=
            (SumIncomingFlow ($Snap.combine $Snap.unit $Snap.unit) this@31@00 G@32@00 (-
              V@33@00
              1) v@113@00 V@33@00)
            (SumOutgoingFlow ($Snap.combine $Snap.unit $Snap.unit) this@31@00 G@32@00 (-
              V@33@00
              1) v@113@00 V@33@00)))
        :pattern ()
        :qid |prog.l<no position>|))
      (<=
        (SumOutgoingFlow ($Snap.combine $Snap.unit $Snap.unit) this@31@00 G@32@00 (-
          V@33@00
          1) t@35@00 V@33@00)
        (SumIncomingFlow ($Snap.combine $Snap.unit $Snap.unit) this@31@00 G@32@00 (-
          V@33@00
          1) t@35@00 V@33@00)))
    (<=
      (SumIncomingFlow ($Snap.combine $Snap.unit $Snap.unit) this@31@00 G@32@00 (-
        V@33@00
        1) s@34@00 V@33@00)
      (SumOutgoingFlow ($Snap.combine $Snap.unit $Snap.unit) this@31@00 G@32@00 (-
        V@33@00
        1) s@34@00 V@33@00)))))
(pop) ; 1
(declare-const $unresolved@115@00 $Snap)
(assert (forall ((s@$ $Snap) (this@31@00 $Ref) (G@32@00 Seq<Seq<Int>>) (V@33@00 Int) (s@34@00 Int) (t@35@00 Int)) (!
  (implies
    (and
      (not (= this@31@00 $Ref.null))
      (FlowNetwork $Snap.unit this@31@00 G@32@00 V@33@00 s@34@00 t@35@00))
    (=
      (FlowConservation s@$ this@31@00 G@32@00 V@33@00 s@34@00 t@35@00)
      (and
        (and
          (<=
            (SumIncomingFlow ($Snap.combine $Snap.unit $Snap.unit) this@31@00 G@32@00 (-
              V@33@00
              1) s@34@00 V@33@00)
            (SumOutgoingFlow ($Snap.combine $Snap.unit $Snap.unit) this@31@00 G@32@00 (-
              V@33@00
              1) s@34@00 V@33@00))
          (<=
            (SumOutgoingFlow ($Snap.combine $Snap.unit $Snap.unit) this@31@00 G@32@00 (-
              V@33@00
              1) t@35@00 V@33@00)
            (SumIncomingFlow ($Snap.combine $Snap.unit $Snap.unit) this@31@00 G@32@00 (-
              V@33@00
              1) t@35@00 V@33@00)))
        (forall ((v Int) (fresh__1 Int)) (!
          (implies
            (and
              (and (and (<= 0 v) (< v V@33@00)) (not (= v s@34@00)))
              (not (= v t@35@00)))
            (=
              (SumIncomingFlow ($Snap.combine $Snap.unit $Snap.unit) this@31@00 G@32@00 (-
                V@33@00
                1) v V@33@00)
              (SumOutgoingFlow ($Snap.combine $Snap.unit $Snap.unit) this@31@00 G@32@00 (-
                V@33@00
                1) v V@33@00)))
          :pattern ((SumOutgoingFlow%limited $unresolved@115@00 this@31@00 G@32@00 fresh__1 v V@33@00))
          )))))
  :pattern ((FlowConservation s@$ this@31@00 G@32@00 V@33@00 s@34@00 t@35@00))
  )))
; ---------- FUNCTION aloc----------
(declare-fun a2@37@00 () array)
(declare-fun i1@38@00 () Int)
(declare-fun result@39@00 () $Ref)
; ----- Well-definedness of specifications -----
(push) ; 1
(assert (= s@$ ($Snap.combine ($Snap.first s@$) ($Snap.second s@$))))
(assert (= ($Snap.first s@$) $Snap.unit))
; [eval] 0 <= i1
(assert (<= 0 i1@38@00))
(assert (= ($Snap.second s@$) $Snap.unit))
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(assert (< i1@38@00 (alen<Int> a2@37@00)))
(declare-const $t@116@00 $Snap)
(assert (= $t@116@00 ($Snap.combine ($Snap.first $t@116@00) ($Snap.second $t@116@00))))
(assert (= ($Snap.first $t@116@00) $Snap.unit))
; [eval] loc_inv_1(result) == a2
; [eval] loc_inv_1(result)
(assert (= (loc_inv_1<array> result@39@00) a2@37@00))
(assert (= ($Snap.second $t@116@00) $Snap.unit))
; [eval] loc_inv_2(result) == i1
; [eval] loc_inv_2(result)
(assert (= (loc_inv_2<Int> result@39@00) i1@38@00))
(pop) ; 1
(assert (forall ((s@$ $Snap) (a2@37@00 array) (i1@38@00 Int)) (!
  (= (aloc%limited s@$ a2@37@00 i1@38@00) (aloc s@$ a2@37@00 i1@38@00))
  :pattern ((aloc s@$ a2@37@00 i1@38@00))
  )))
(assert (forall ((s@$ $Snap) (a2@37@00 array) (i1@38@00 Int)) (!
  (aloc%stateless a2@37@00 i1@38@00)
  :pattern ((aloc%limited s@$ a2@37@00 i1@38@00))
  )))
(assert (forall ((s@$ $Snap) (a2@37@00 array) (i1@38@00 Int)) (!
  (let ((result@39@00 (aloc%limited s@$ a2@37@00 i1@38@00))) (implies
    (and (<= 0 i1@38@00) (< i1@38@00 (alen<Int> a2@37@00)))
    (and
      (= (loc_inv_1<array> result@39@00) a2@37@00)
      (= (loc_inv_2<Int> result@39@00) i1@38@00))))
  :pattern ((aloc%limited s@$ a2@37@00 i1@38@00))
  )))
; ----- Verification of function body and postcondition -----
(push) ; 1
(assert (= s@$ ($Snap.combine ($Snap.first s@$) ($Snap.second s@$))))
(assert (= ($Snap.first s@$) $Snap.unit))
(assert (<= 0 i1@38@00))
(assert (= ($Snap.second s@$) $Snap.unit))
(assert (< i1@38@00 (alen<Int> a2@37@00)))
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
; [eval] array_loc(a2, i1)
(assert (= result@39@00 (array_loc<Ref> a2@37@00 i1@38@00)))
; [eval] loc_inv_1(result) == a2
; [eval] loc_inv_1(result)
(set-option :timeout 0)
(push) ; 2
(assert (not (= (loc_inv_1<array> result@39@00) a2@37@00)))
(check-sat)
; unsat
(pop) ; 2
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs             547
;  :arith-add-rows        562
;  :arith-assert-diseq    83
;  :arith-assert-lower    230
;  :arith-assert-upper    148
;  :arith-bound-prop      31
;  :arith-conflicts       14
;  :arith-eq-adapter      125
;  :arith-fixed-eqs       109
;  :arith-offset-eqs      14
;  :arith-pivots          205
;  :conflicts             31
;  :datatype-accessor-ax  26
;  :datatype-occurs-check 19
;  :decisions             62
;  :del-clause            771
;  :final-checks          27
;  :interface-eqs         8
;  :max-generation        5
;  :max-memory            4.26
;  :memory                4.22
;  :mk-bool-var           1403
;  :mk-clause             774
;  :num-allocs            152590
;  :num-checks            45
;  :propagations          317
;  :quant-instantiations  233
;  :rlimit-count          176392)
(assert (= (loc_inv_1<array> result@39@00) a2@37@00))
; [eval] loc_inv_2(result) == i1
; [eval] loc_inv_2(result)
(push) ; 2
(assert (not (= (loc_inv_2<Int> result@39@00) i1@38@00)))
(check-sat)
; unsat
(pop) ; 2
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs             550
;  :arith-add-rows        562
;  :arith-assert-diseq    83
;  :arith-assert-lower    230
;  :arith-assert-upper    148
;  :arith-bound-prop      31
;  :arith-conflicts       14
;  :arith-eq-adapter      125
;  :arith-fixed-eqs       109
;  :arith-offset-eqs      14
;  :arith-pivots          205
;  :conflicts             32
;  :datatype-accessor-ax  26
;  :datatype-occurs-check 19
;  :decisions             62
;  :del-clause            771
;  :final-checks          27
;  :interface-eqs         8
;  :max-generation        5
;  :max-memory            4.26
;  :memory                4.22
;  :mk-bool-var           1405
;  :mk-clause             774
;  :num-allocs            152727
;  :num-checks            46
;  :propagations          317
;  :quant-instantiations  233
;  :rlimit-count          176525)
(assert (= (loc_inv_2<Int> result@39@00) i1@38@00))
(pop) ; 1
(assert (forall ((s@$ $Snap) (a2@37@00 array) (i1@38@00 Int)) (!
  (implies
    (and (<= 0 i1@38@00) (< i1@38@00 (alen<Int> a2@37@00)))
    (= (aloc s@$ a2@37@00 i1@38@00) (array_loc<Ref> a2@37@00 i1@38@00)))
  :pattern ((aloc s@$ a2@37@00 i1@38@00))
  )))
; ---------- FUNCTION opt_get1----------
(declare-fun opt1@40@00 () option<array>)
(declare-fun result@41@00 () array)
; ----- Well-definedness of specifications -----
(push) ; 1
(assert (= s@$ $Snap.unit))
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(assert (not (= opt1@40@00 (as None<option<array>>  option<array>))))
(declare-const $t@117@00 $Snap)
(assert (= $t@117@00 $Snap.unit))
; [eval] (some(result): option[array]) == opt1
; [eval] (some(result): option[array])
(assert (= (some<option<array>> result@41@00) opt1@40@00))
(pop) ; 1
(assert (forall ((s@$ $Snap) (opt1@40@00 option<array>)) (!
  (= (opt_get1%limited s@$ opt1@40@00) (opt_get1 s@$ opt1@40@00))
  :pattern ((opt_get1 s@$ opt1@40@00))
  )))
(assert (forall ((s@$ $Snap) (opt1@40@00 option<array>)) (!
  (opt_get1%stateless opt1@40@00)
  :pattern ((opt_get1%limited s@$ opt1@40@00))
  )))
(assert (forall ((s@$ $Snap) (opt1@40@00 option<array>)) (!
  (let ((result@41@00 (opt_get1%limited s@$ opt1@40@00))) (implies
    (not (= opt1@40@00 (as None<option<array>>  option<array>)))
    (= (some<option<array>> result@41@00) opt1@40@00)))
  :pattern ((opt_get1%limited s@$ opt1@40@00))
  )))
; ----- Verification of function body and postcondition -----
(push) ; 1
(assert (= s@$ $Snap.unit))
(assert (not (= opt1@40@00 (as None<option<array>>  option<array>))))
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
; [eval] (option_get(opt1): array)
(assert (= result@41@00 (option_get<array> opt1@40@00)))
; [eval] (some(result): option[array]) == opt1
; [eval] (some(result): option[array])
(set-option :timeout 0)
(push) ; 2
(assert (not (= (some<option<array>> result@41@00) opt1@40@00)))
(check-sat)
; unsat
(pop) ; 2
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs             554
;  :arith-add-rows        562
;  :arith-assert-diseq    83
;  :arith-assert-lower    230
;  :arith-assert-upper    148
;  :arith-bound-prop      31
;  :arith-conflicts       14
;  :arith-eq-adapter      125
;  :arith-fixed-eqs       109
;  :arith-offset-eqs      14
;  :arith-pivots          206
;  :conflicts             33
;  :datatype-accessor-ax  27
;  :datatype-occurs-check 20
;  :decisions             62
;  :del-clause            774
;  :final-checks          28
;  :interface-eqs         8
;  :max-generation        5
;  :max-memory            4.26
;  :memory                4.21
;  :mk-bool-var           1415
;  :mk-clause             774
;  :num-allocs            153831
;  :num-checks            48
;  :propagations          317
;  :quant-instantiations  235
;  :rlimit-count          177726)
(assert (= (some<option<array>> result@41@00) opt1@40@00))
(pop) ; 1
(assert (forall ((s@$ $Snap) (opt1@40@00 option<array>)) (!
  (implies
    (not (= opt1@40@00 (as None<option<array>>  option<array>)))
    (= (opt_get1 s@$ opt1@40@00) (option_get<array> opt1@40@00)))
  :pattern ((opt_get1 s@$ opt1@40@00))
  )))
; ---------- FUNCTION valid_graph_vertices1----------
(declare-fun this@42@00 () $Ref)
(declare-fun p@43@00 () Seq<Int>)
(declare-fun V@44@00 () Int)
(declare-fun result@45@00 () Bool)
; ----- Well-definedness of specifications -----
(push) ; 1
(assert (= s@$ $Snap.unit))
; [eval] this != null
(assert (not (= this@42@00 $Ref.null)))
(pop) ; 1
(assert (forall ((s@$ $Snap) (this@42@00 $Ref) (p@43@00 Seq<Int>) (V@44@00 Int)) (!
  (=
    (valid_graph_vertices1%limited s@$ this@42@00 p@43@00 V@44@00)
    (valid_graph_vertices1 s@$ this@42@00 p@43@00 V@44@00))
  :pattern ((valid_graph_vertices1 s@$ this@42@00 p@43@00 V@44@00))
  )))
(assert (forall ((s@$ $Snap) (this@42@00 $Ref) (p@43@00 Seq<Int>) (V@44@00 Int)) (!
  (valid_graph_vertices1%stateless this@42@00 p@43@00 V@44@00)
  :pattern ((valid_graph_vertices1%limited s@$ this@42@00 p@43@00 V@44@00))
  )))
; ----- Verification of function body and postcondition -----
(push) ; 1
(assert (= s@$ $Snap.unit))
(assert (not (= this@42@00 $Ref.null)))
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
; [eval] (forall unknown1: Int :: { p[unknown1] } 0 <= unknown1 && unknown1 < |p| ==> 0 <= p[unknown1]) && (forall unknown1: Int :: { p[unknown1] } 0 <= unknown1 && unknown1 < |p| ==> p[unknown1] < V)
; [eval] (forall unknown1: Int :: { p[unknown1] } 0 <= unknown1 && unknown1 < |p| ==> 0 <= p[unknown1])
(declare-const unknown1@118@00 Int)
(push) ; 2
; [eval] 0 <= unknown1 && unknown1 < |p| ==> 0 <= p[unknown1]
; [eval] 0 <= unknown1 && unknown1 < |p|
; [eval] 0 <= unknown1
(push) ; 3
; [then-branch: 23 | 0 <= unknown1@118@00 | live]
; [else-branch: 23 | !(0 <= unknown1@118@00) | live]
(push) ; 4
; [then-branch: 23 | 0 <= unknown1@118@00]
(assert (<= 0 unknown1@118@00))
; [eval] unknown1 < |p|
; [eval] |p|
(pop) ; 4
(push) ; 4
; [else-branch: 23 | !(0 <= unknown1@118@00)]
(assert (not (<= 0 unknown1@118@00)))
(pop) ; 4
(pop) ; 3
; Joined path conditions
; Joined path conditions
(push) ; 3
; [then-branch: 24 | unknown1@118@00 < |p@43@00| && 0 <= unknown1@118@00 | live]
; [else-branch: 24 | !(unknown1@118@00 < |p@43@00| && 0 <= unknown1@118@00) | live]
(push) ; 4
; [then-branch: 24 | unknown1@118@00 < |p@43@00| && 0 <= unknown1@118@00]
(assert (and (< unknown1@118@00 (Seq_length p@43@00)) (<= 0 unknown1@118@00)))
; [eval] 0 <= p[unknown1]
; [eval] p[unknown1]
(set-option :timeout 0)
(push) ; 5
(assert (not (>= unknown1@118@00 0)))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs             555
;  :arith-add-rows        562
;  :arith-assert-diseq    84
;  :arith-assert-lower    234
;  :arith-assert-upper    148
;  :arith-bound-prop      32
;  :arith-conflicts       14
;  :arith-eq-adapter      126
;  :arith-fixed-eqs       109
;  :arith-offset-eqs      14
;  :arith-pivots          207
;  :conflicts             33
;  :datatype-accessor-ax  28
;  :datatype-occurs-check 21
;  :decisions             62
;  :del-clause            774
;  :final-checks          29
;  :interface-eqs         8
;  :max-generation        5
;  :max-memory            4.26
;  :memory                4.22
;  :mk-bool-var           1426
;  :mk-clause             778
;  :num-allocs            154756
;  :num-checks            50
;  :propagations          318
;  :quant-instantiations  237
;  :rlimit-count          178728)
(pop) ; 4
(push) ; 4
; [else-branch: 24 | !(unknown1@118@00 < |p@43@00| && 0 <= unknown1@118@00)]
(assert (not (and (< unknown1@118@00 (Seq_length p@43@00)) (<= 0 unknown1@118@00))))
(pop) ; 4
(pop) ; 3
; Joined path conditions
; Joined path conditions
(pop) ; 2
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
; Nested auxiliary terms: non-globals (tlq)
(push) ; 2
; [then-branch: 25 | QA unknown1@118@00 :: unknown1@118@00 < |p@43@00| && 0 <= unknown1@118@00 ==> 0 <= p@43@00[unknown1@118@00] | live]
; [else-branch: 25 | !(QA unknown1@118@00 :: unknown1@118@00 < |p@43@00| && 0 <= unknown1@118@00 ==> 0 <= p@43@00[unknown1@118@00]) | live]
(push) ; 3
; [then-branch: 25 | QA unknown1@118@00 :: unknown1@118@00 < |p@43@00| && 0 <= unknown1@118@00 ==> 0 <= p@43@00[unknown1@118@00]]
(assert (forall ((unknown1@118@00 Int)) (!
  (implies
    (and (< unknown1@118@00 (Seq_length p@43@00)) (<= 0 unknown1@118@00))
    (<= 0 (Seq_index p@43@00 unknown1@118@00)))
  :pattern ((Seq_index p@43@00 unknown1@118@00))
  :qid |prog.l<no position>|)))
; [eval] (forall unknown1: Int :: { p[unknown1] } 0 <= unknown1 && unknown1 < |p| ==> p[unknown1] < V)
(declare-const unknown1@119@00 Int)
(push) ; 4
; [eval] 0 <= unknown1 && unknown1 < |p| ==> p[unknown1] < V
; [eval] 0 <= unknown1 && unknown1 < |p|
; [eval] 0 <= unknown1
(push) ; 5
; [then-branch: 26 | 0 <= unknown1@119@00 | live]
; [else-branch: 26 | !(0 <= unknown1@119@00) | live]
(push) ; 6
; [then-branch: 26 | 0 <= unknown1@119@00]
(assert (<= 0 unknown1@119@00))
; [eval] unknown1 < |p|
; [eval] |p|
(pop) ; 6
(push) ; 6
; [else-branch: 26 | !(0 <= unknown1@119@00)]
(assert (not (<= 0 unknown1@119@00)))
(pop) ; 6
(pop) ; 5
; Joined path conditions
; Joined path conditions
(push) ; 5
; [then-branch: 27 | unknown1@119@00 < |p@43@00| && 0 <= unknown1@119@00 | live]
; [else-branch: 27 | !(unknown1@119@00 < |p@43@00| && 0 <= unknown1@119@00) | live]
(push) ; 6
; [then-branch: 27 | unknown1@119@00 < |p@43@00| && 0 <= unknown1@119@00]
(assert (and (< unknown1@119@00 (Seq_length p@43@00)) (<= 0 unknown1@119@00)))
; [eval] p[unknown1] < V
; [eval] p[unknown1]
(push) ; 7
(assert (not (>= unknown1@119@00 0)))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs             555
;  :arith-add-rows        562
;  :arith-assert-diseq    85
;  :arith-assert-lower    238
;  :arith-assert-upper    148
;  :arith-bound-prop      33
;  :arith-conflicts       14
;  :arith-eq-adapter      127
;  :arith-fixed-eqs       109
;  :arith-offset-eqs      14
;  :arith-pivots          209
;  :conflicts             33
;  :datatype-accessor-ax  28
;  :datatype-occurs-check 21
;  :decisions             62
;  :del-clause            778
;  :final-checks          29
;  :interface-eqs         8
;  :max-generation        5
;  :max-memory            4.26
;  :memory                4.22
;  :mk-bool-var           1433
;  :mk-clause             782
;  :num-allocs            155059
;  :num-checks            51
;  :propagations          319
;  :quant-instantiations  239
;  :rlimit-count          179204)
(pop) ; 6
(push) ; 6
; [else-branch: 27 | !(unknown1@119@00 < |p@43@00| && 0 <= unknown1@119@00)]
(assert (not (and (< unknown1@119@00 (Seq_length p@43@00)) (<= 0 unknown1@119@00))))
(pop) ; 6
(pop) ; 5
; Joined path conditions
; Joined path conditions
(pop) ; 4
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 3
(push) ; 3
; [else-branch: 25 | !(QA unknown1@118@00 :: unknown1@118@00 < |p@43@00| && 0 <= unknown1@118@00 ==> 0 <= p@43@00[unknown1@118@00])]
(assert (not
  (forall ((unknown1@118@00 Int)) (!
    (implies
      (and (< unknown1@118@00 (Seq_length p@43@00)) (<= 0 unknown1@118@00))
      (<= 0 (Seq_index p@43@00 unknown1@118@00)))
    :pattern ((Seq_index p@43@00 unknown1@118@00))
    :qid |prog.l<no position>|))))
(pop) ; 3
(pop) ; 2
; Joined path conditions
; Joined path conditions
(assert (=
  result@45@00
  (and
    (forall ((unknown1@119@00 Int)) (!
      (implies
        (and (< unknown1@119@00 (Seq_length p@43@00)) (<= 0 unknown1@119@00))
        (< (Seq_index p@43@00 unknown1@119@00) V@44@00))
      :pattern ((Seq_index p@43@00 unknown1@119@00))
      :qid |prog.l<no position>|))
    (forall ((unknown1@118@00 Int)) (!
      (implies
        (and (< unknown1@118@00 (Seq_length p@43@00)) (<= 0 unknown1@118@00))
        (<= 0 (Seq_index p@43@00 unknown1@118@00)))
      :pattern ((Seq_index p@43@00 unknown1@118@00))
      :qid |prog.l<no position>|)))))
(pop) ; 1
(assert (forall ((s@$ $Snap) (this@42@00 $Ref) (p@43@00 Seq<Int>) (V@44@00 Int)) (!
  (implies
    (not (= this@42@00 $Ref.null))
    (=
      (valid_graph_vertices1 s@$ this@42@00 p@43@00 V@44@00)
      (and
        (forall ((unknown1 Int)) (!
          (implies
            (and (<= 0 unknown1) (< unknown1 (Seq_length p@43@00)))
            (<= 0 (Seq_index p@43@00 unknown1)))
          :pattern ((Seq_index p@43@00 unknown1))
          ))
        (forall ((unknown1 Int)) (!
          (implies
            (and (<= 0 unknown1) (< unknown1 (Seq_length p@43@00)))
            (< (Seq_index p@43@00 unknown1) V@44@00))
          :pattern ((Seq_index p@43@00 unknown1))
          )))))
  :pattern ((valid_graph_vertices1 s@$ this@42@00 p@43@00 V@44@00))
  )))
; ---------- FUNCTION ValidFlow----------
(declare-fun this@46@00 () $Ref)
(declare-fun G@47@00 () Seq<Seq<Int>>)
(declare-fun Gf@48@00 () Seq<Seq<Int>>)
(declare-fun V@49@00 () Int)
(declare-fun s@50@00 () Int)
(declare-fun t@51@00 () Int)
(declare-fun result@52@00 () Bool)
; ----- Well-definedness of specifications -----
(push) ; 1
(assert (= s@$ ($Snap.combine ($Snap.first s@$) ($Snap.second s@$))))
(assert (= ($Snap.first s@$) $Snap.unit))
; [eval] this != null
(assert (not (= this@46@00 $Ref.null)))
(assert (=
  ($Snap.second s@$)
  ($Snap.combine
    ($Snap.first ($Snap.second s@$))
    ($Snap.second ($Snap.second s@$)))))
(assert (= ($Snap.first ($Snap.second s@$)) $Snap.unit))
; [eval] SquareIntMatrix(this, Gf, V)
(push) ; 2
; [eval] this != null
(pop) ; 2
; Joined path conditions
(assert (SquareIntMatrix $Snap.unit this@46@00 Gf@48@00 V@49@00))
(assert (=
  ($Snap.second ($Snap.second s@$))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second s@$)))
    ($Snap.second ($Snap.second ($Snap.second s@$))))))
(assert (= ($Snap.first ($Snap.second ($Snap.second s@$))) $Snap.unit))
; [eval] FlowNetwork(this, G, V, s, t)
(push) ; 2
; [eval] this != null
(pop) ; 2
; Joined path conditions
(assert (FlowNetwork $Snap.unit this@46@00 G@47@00 V@49@00 s@50@00 t@51@00))
(assert (= ($Snap.second ($Snap.second ($Snap.second s@$))) $Snap.unit))
; [eval] FlowNetwork(this, Gf, V, s, t)
(push) ; 2
; [eval] this != null
(pop) ; 2
; Joined path conditions
(assert (FlowNetwork $Snap.unit this@46@00 Gf@48@00 V@49@00 s@50@00 t@51@00))
(pop) ; 1
(assert (forall ((s@$ $Snap) (this@46@00 $Ref) (G@47@00 Seq<Seq<Int>>) (Gf@48@00 Seq<Seq<Int>>) (V@49@00 Int) (s@50@00 Int) (t@51@00 Int)) (!
  (=
    (ValidFlow%limited s@$ this@46@00 G@47@00 Gf@48@00 V@49@00 s@50@00 t@51@00)
    (ValidFlow s@$ this@46@00 G@47@00 Gf@48@00 V@49@00 s@50@00 t@51@00))
  :pattern ((ValidFlow s@$ this@46@00 G@47@00 Gf@48@00 V@49@00 s@50@00 t@51@00))
  )))
(assert (forall ((s@$ $Snap) (this@46@00 $Ref) (G@47@00 Seq<Seq<Int>>) (Gf@48@00 Seq<Seq<Int>>) (V@49@00 Int) (s@50@00 Int) (t@51@00 Int)) (!
  (ValidFlow%stateless this@46@00 G@47@00 Gf@48@00 V@49@00 s@50@00 t@51@00)
  :pattern ((ValidFlow%limited s@$ this@46@00 G@47@00 Gf@48@00 V@49@00 s@50@00 t@51@00))
  )))
; ----- Verification of function body and postcondition -----
(push) ; 1
(assert (= s@$ ($Snap.combine ($Snap.first s@$) ($Snap.second s@$))))
(assert (= ($Snap.first s@$) $Snap.unit))
(assert (not (= this@46@00 $Ref.null)))
(assert (=
  ($Snap.second s@$)
  ($Snap.combine
    ($Snap.first ($Snap.second s@$))
    ($Snap.second ($Snap.second s@$)))))
(assert (= ($Snap.first ($Snap.second s@$)) $Snap.unit))
(assert (SquareIntMatrix $Snap.unit this@46@00 Gf@48@00 V@49@00))
(assert (=
  ($Snap.second ($Snap.second s@$))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second s@$)))
    ($Snap.second ($Snap.second ($Snap.second s@$))))))
(assert (= ($Snap.first ($Snap.second ($Snap.second s@$))) $Snap.unit))
(assert (FlowNetwork $Snap.unit this@46@00 G@47@00 V@49@00 s@50@00 t@51@00))
(assert (= ($Snap.second ($Snap.second ($Snap.second s@$))) $Snap.unit))
(assert (FlowNetwork $Snap.unit this@46@00 Gf@48@00 V@49@00 s@50@00 t@51@00))
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
; [eval] FlowConservation(this, G, V, s, t) && CapacityConstraint(this, G, Gf, V)
; [eval] FlowConservation(this, G, V, s, t)
(push) ; 2
; [eval] this != null
; [eval] FlowNetwork(this, G, V, s, t)
(push) ; 3
; [eval] this != null
(pop) ; 3
; Joined path conditions
(pop) ; 2
; Joined path conditions
(push) ; 2
; [then-branch: 28 | FlowConservation((_, _), this@46@00, G@47@00, V@49@00, s@50@00, t@51@00) | live]
; [else-branch: 28 | !(FlowConservation((_, _), this@46@00, G@47@00, V@49@00, s@50@00, t@51@00)) | live]
(push) ; 3
; [then-branch: 28 | FlowConservation((_, _), this@46@00, G@47@00, V@49@00, s@50@00, t@51@00)]
(assert (FlowConservation ($Snap.combine $Snap.unit $Snap.unit) this@46@00 G@47@00 V@49@00 s@50@00 t@51@00))
; [eval] CapacityConstraint(this, G, Gf, V)
(push) ; 4
; [eval] this != null
; [eval] SquareIntMatrix(this, G, V)
(push) ; 5
; [eval] this != null
(pop) ; 5
; Joined path conditions
(set-option :timeout 0)
(push) ; 5
(assert (not (SquareIntMatrix $Snap.unit this@46@00 G@47@00 V@49@00)))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs             617
;  :arith-add-rows        584
;  :arith-assert-diseq    90
;  :arith-assert-lower    257
;  :arith-assert-upper    158
;  :arith-bound-prop      39
;  :arith-conflicts       14
;  :arith-eq-adapter      137
;  :arith-fixed-eqs       113
;  :arith-offset-eqs      14
;  :arith-pivots          220
;  :conflicts             34
;  :datatype-accessor-ax  37
;  :datatype-occurs-check 22
;  :decisions             62
;  :del-clause            945
;  :final-checks          30
;  :interface-eqs         8
;  :max-generation        5
;  :max-memory            4.31
;  :memory                4.31
;  :mk-bool-var           1681
;  :mk-clause             1003
;  :num-allocs            158270
;  :num-checks            53
;  :propagations          388
;  :quant-instantiations  299
;  :rlimit-count          185176)
(assert (SquareIntMatrix $Snap.unit this@46@00 G@47@00 V@49@00))
; [eval] SquareIntMatrix(this, Gf, V)
(push) ; 5
; [eval] this != null
(pop) ; 5
; Joined path conditions
(pop) ; 4
; Joined path conditions
(assert (SquareIntMatrix $Snap.unit this@46@00 G@47@00 V@49@00))
(pop) ; 3
(push) ; 3
; [else-branch: 28 | !(FlowConservation((_, _), this@46@00, G@47@00, V@49@00, s@50@00, t@51@00))]
(assert (not
  (FlowConservation ($Snap.combine $Snap.unit $Snap.unit) this@46@00 G@47@00 V@49@00 s@50@00 t@51@00)))
(pop) ; 3
(pop) ; 2
; Joined path conditions
(assert (implies
  (FlowConservation ($Snap.combine $Snap.unit $Snap.unit) this@46@00 G@47@00 V@49@00 s@50@00 t@51@00)
  (and
    (FlowConservation ($Snap.combine $Snap.unit $Snap.unit) this@46@00 G@47@00 V@49@00 s@50@00 t@51@00)
    (SquareIntMatrix $Snap.unit this@46@00 G@47@00 V@49@00))))
; Joined path conditions
(assert (=
  result@52@00
  (and
    (CapacityConstraint ($Snap.combine
      $Snap.unit
      ($Snap.combine $Snap.unit $Snap.unit)) this@46@00 G@47@00 Gf@48@00 V@49@00)
    (FlowConservation ($Snap.combine $Snap.unit $Snap.unit) this@46@00 G@47@00 V@49@00 s@50@00 t@51@00))))
(pop) ; 1
(assert (forall ((s@$ $Snap) (this@46@00 $Ref) (G@47@00 Seq<Seq<Int>>) (Gf@48@00 Seq<Seq<Int>>) (V@49@00 Int) (s@50@00 Int) (t@51@00 Int)) (!
  (implies
    (and
      (not (= this@46@00 $Ref.null))
      (SquareIntMatrix $Snap.unit this@46@00 Gf@48@00 V@49@00)
      (FlowNetwork $Snap.unit this@46@00 G@47@00 V@49@00 s@50@00 t@51@00)
      (FlowNetwork $Snap.unit this@46@00 Gf@48@00 V@49@00 s@50@00 t@51@00))
    (=
      (ValidFlow s@$ this@46@00 G@47@00 Gf@48@00 V@49@00 s@50@00 t@51@00)
      (and
        (FlowConservation ($Snap.combine $Snap.unit $Snap.unit) this@46@00 G@47@00 V@49@00 s@50@00 t@51@00)
        (CapacityConstraint ($Snap.combine
          $Snap.unit
          ($Snap.combine $Snap.unit $Snap.unit)) this@46@00 G@47@00 Gf@48@00 V@49@00))))
  :pattern ((ValidFlow s@$ this@46@00 G@47@00 Gf@48@00 V@49@00 s@50@00 t@51@00))
  )))
; ---------- FUNCTION SquareIntMatrix1----------
(declare-fun this@53@00 () $Ref)
(declare-fun G@54@00 () option<array>)
(declare-fun V@55@00 () Int)
(declare-fun result@56@00 () Bool)
; ----- Well-definedness of specifications -----
(push) ; 1
(assert (= s@$ ($Snap.combine ($Snap.first s@$) ($Snap.second s@$))))
(assert (= ($Snap.first s@$) $Snap.unit))
; [eval] this != null
(assert (not (= this@53@00 $Ref.null)))
(assert (=
  ($Snap.second s@$)
  ($Snap.combine
    ($Snap.first ($Snap.second s@$))
    ($Snap.second ($Snap.second s@$)))))
(assert (= ($Snap.first ($Snap.second s@$)) $Snap.unit))
; [eval] G != (None(): option[array])
; [eval] (None(): option[array])
(assert (not (= G@54@00 (as None<option<array>>  option<array>))))
(assert (=
  ($Snap.second ($Snap.second s@$))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second s@$)))
    ($Snap.second ($Snap.second ($Snap.second s@$))))))
(assert (= ($Snap.first ($Snap.second ($Snap.second s@$))) $Snap.unit))
; [eval] alen(opt_get1(G)) == V
; [eval] alen(opt_get1(G))
; [eval] opt_get1(G)
(push) ; 2
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 2
; Joined path conditions
(assert (= (alen<Int> (opt_get1 $Snap.unit G@54@00)) V@55@00))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second s@$)))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$)))))))
(declare-const i1@120@00 Int)
(push) ; 2
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 3
; [then-branch: 29 | 0 <= i1@120@00 | live]
; [else-branch: 29 | !(0 <= i1@120@00) | live]
(push) ; 4
; [then-branch: 29 | 0 <= i1@120@00]
(assert (<= 0 i1@120@00))
; [eval] i1 < V
(pop) ; 4
(push) ; 4
; [else-branch: 29 | !(0 <= i1@120@00)]
(assert (not (<= 0 i1@120@00)))
(pop) ; 4
(pop) ; 3
; Joined path conditions
; Joined path conditions
(assert (and (< i1@120@00 V@55@00) (<= 0 i1@120@00)))
; [eval] aloc(opt_get1(G), i1)
; [eval] opt_get1(G)
(push) ; 3
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 3
; Joined path conditions
(push) ; 3
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 4
(assert (not (< i1@120@00 (alen<Int> (opt_get1 $Snap.unit G@54@00)))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs             645
;  :arith-add-rows        584
;  :arith-assert-diseq    90
;  :arith-assert-lower    260
;  :arith-assert-upper    160
;  :arith-bound-prop      39
;  :arith-conflicts       14
;  :arith-eq-adapter      138
;  :arith-fixed-eqs       114
;  :arith-offset-eqs      14
;  :arith-pivots          226
;  :conflicts             34
;  :datatype-accessor-ax  42
;  :datatype-occurs-check 22
;  :decisions             62
;  :del-clause            1003
;  :final-checks          30
;  :interface-eqs         8
;  :max-generation        5
;  :max-memory            4.31
;  :memory                4.30
;  :mk-bool-var           1701
;  :mk-clause             1003
;  :num-allocs            158979
;  :num-checks            54
;  :propagations          388
;  :quant-instantiations  304
;  :rlimit-count          186547)
(assert (< i1@120@00 (alen<Int> (opt_get1 $Snap.unit G@54@00))))
(pop) ; 3
; Joined path conditions
(assert (< i1@120@00 (alen<Int> (opt_get1 $Snap.unit G@54@00))))
(declare-const $k@121@00 $Perm)
(assert ($Perm.isReadVar $k@121@00 $Perm.Write))
(pop) ; 2
(declare-fun inv@122@00 ($Snap $Ref option<array> Int $Ref) Int)
; Nested auxiliary terms: globals
(assert ($Perm.isReadVar $k@121@00 $Perm.Write))
; Nested auxiliary terms: non-globals
(assert (forall ((i1@120@00 Int)) (!
  (< i1@120@00 (alen<Int> (opt_get1 $Snap.unit G@54@00)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@54@00) i1@120@00))
  :qid |option$array$-aux|)))
(push) ; 2
(assert (not (forall ((i1@120@00 Int)) (!
  (implies
    (and (< i1@120@00 V@55@00) (<= 0 i1@120@00))
    (or (= $k@121@00 $Perm.No) (< $Perm.No $k@121@00)))
  
  ))))
(check-sat)
; unsat
(pop) ; 2
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs             647
;  :arith-add-rows        584
;  :arith-assert-diseq    91
;  :arith-assert-lower    262
;  :arith-assert-upper    161
;  :arith-bound-prop      39
;  :arith-conflicts       14
;  :arith-eq-adapter      139
;  :arith-fixed-eqs       114
;  :arith-offset-eqs      14
;  :arith-pivots          227
;  :conflicts             35
;  :datatype-accessor-ax  43
;  :datatype-occurs-check 22
;  :decisions             62
;  :del-clause            1003
;  :final-checks          30
;  :interface-eqs         8
;  :max-generation        5
;  :max-memory            4.31
;  :memory                4.30
;  :mk-bool-var           1708
;  :mk-clause             1005
;  :num-allocs            159472
;  :num-checks            55
;  :propagations          389
;  :quant-instantiations  304
;  :rlimit-count          187123)
; Check receiver injectivity
(push) ; 2
(assert (not (forall ((i11@120@00 Int) (i12@120@00 Int)) (!
  (implies
    (and
      (and (and (< i11@120@00 V@55@00) (<= 0 i11@120@00)) (< $Perm.No $k@121@00))
      (and (and (< i12@120@00 V@55@00) (<= 0 i12@120@00)) (< $Perm.No $k@121@00))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@54@00) i11@120@00)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@54@00) i12@120@00)))
    (= i11@120@00 i12@120@00))
  
  :qid |option$array$-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 2
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs             676
;  :arith-add-rows        594
;  :arith-assert-diseq    94
;  :arith-assert-lower    270
;  :arith-assert-upper    164
;  :arith-bound-prop      39
;  :arith-conflicts       16
;  :arith-eq-adapter      141
;  :arith-fixed-eqs       115
;  :arith-offset-eqs      15
;  :arith-pivots          233
;  :conflicts             38
;  :datatype-accessor-ax  43
;  :datatype-occurs-check 22
;  :decisions             64
;  :del-clause            1021
;  :final-checks          30
;  :interface-eqs         8
;  :max-generation        5
;  :max-memory            4.33
;  :memory                4.31
;  :mk-bool-var           1735
;  :mk-clause             1023
;  :num-allocs            159875
;  :num-checks            56
;  :propagations          409
;  :quant-instantiations  315
;  :rlimit-count          188183)
; Definitional axioms for inverse functions
(assert (forall ((i1@120@00 Int)) (!
  (implies
    (and (and (< i1@120@00 V@55@00) (<= 0 i1@120@00)) (< $Perm.No $k@121@00))
    (=
      (inv@122@00 s@$ this@53@00 G@54@00 V@55@00 (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@54@00) i1@120@00))
      i1@120@00))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@54@00) i1@120@00))
  )))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (< (inv@122@00 s@$ this@53@00 G@54@00 V@55@00 r) V@55@00)
        (<= 0 (inv@122@00 s@$ this@53@00 G@54@00 V@55@00 r)))
      (< $Perm.No $k@121@00))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@54@00) (inv@122@00 s@$ this@53@00 G@54@00 V@55@00 r))
      r))
  :pattern ((inv@122@00 s@$ this@53@00 G@54@00 V@55@00 r))
  :qid |option$array$-fctOfInv|)))
; Permissions are non-negative
(assert (forall ((i1@120@00 Int)) (!
  (<= $Perm.No $k@121@00)
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@54@00) i1@120@00))
  :qid |option$array$-permAtLeastZero|)))
; Field permissions are at most one
(assert (forall ((i1@120@00 Int)) (!
  (<= $k@121@00 $Perm.Write)
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@54@00) i1@120@00))
  :qid |option$array$-permAtMostOne|)))
; Permission implies non-null receiver
(assert (forall ((i1@120@00 Int)) (!
  (implies
    (and (and (< i1@120@00 V@55@00) (<= 0 i1@120@00)) (< $Perm.No $k@121@00))
    (not
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@54@00) i1@120@00)
        $Ref.null)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@54@00) i1@120@00))
  :qid |option$array$-permImpliesNonNull|)))
(declare-fun sm@123@00 ($Snap $Ref option<array> Int) $FVF<option<array>>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and
        (< (inv@122@00 s@$ this@53@00 G@54@00 V@55@00 r) V@55@00)
        (<= 0 (inv@122@00 s@$ this@53@00 G@54@00 V@55@00 r)))
      (< $Perm.No $k@121@00)
      false)
    (=
      ($FVF.lookup_option$array$ (sm@123@00 s@$ this@53@00 G@54@00 V@55@00) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r)))
  :pattern (($FVF.lookup_option$array$ (sm@123@00 s@$ this@53@00 G@54@00 V@55@00) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r))
  :qid |qp.fvfValDef0|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r)
  :pattern (($FVF.lookup_option$array$ (sm@123@00 s@$ this@53@00 G@54@00 V@55@00) r))
  :qid |qp.fvfResTrgDef1|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (< (inv@122@00 s@$ this@53@00 G@54@00 V@55@00 r) V@55@00)
      (<= 0 (inv@122@00 s@$ this@53@00 G@54@00 V@55@00 r)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@123@00 s@$ this@53@00 G@54@00 V@55@00) r) r))
  :pattern ((inv@122@00 s@$ this@53@00 G@54@00 V@55@00 r))
  )))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$)))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$)))))
  $Snap.unit))
; [eval] (forall i1: Int :: { aloc(opt_get1(G), i1) } 0 <= i1 && i1 < V ==> aloc(opt_get1(G), i1).option$array$ != (None(): option[array]))
(declare-const i1@124@00 Int)
(push) ; 2
; [eval] 0 <= i1 && i1 < V ==> aloc(opt_get1(G), i1).option$array$ != (None(): option[array])
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 3
; [then-branch: 30 | 0 <= i1@124@00 | live]
; [else-branch: 30 | !(0 <= i1@124@00) | live]
(push) ; 4
; [then-branch: 30 | 0 <= i1@124@00]
(assert (<= 0 i1@124@00))
; [eval] i1 < V
(pop) ; 4
(push) ; 4
; [else-branch: 30 | !(0 <= i1@124@00)]
(assert (not (<= 0 i1@124@00)))
(pop) ; 4
(pop) ; 3
; Joined path conditions
; Joined path conditions
(push) ; 3
; [then-branch: 31 | i1@124@00 < V@55@00 && 0 <= i1@124@00 | live]
; [else-branch: 31 | !(i1@124@00 < V@55@00 && 0 <= i1@124@00) | live]
(push) ; 4
; [then-branch: 31 | i1@124@00 < V@55@00 && 0 <= i1@124@00]
(assert (and (< i1@124@00 V@55@00) (<= 0 i1@124@00)))
; [eval] aloc(opt_get1(G), i1).option$array$ != (None(): option[array])
; [eval] aloc(opt_get1(G), i1)
; [eval] opt_get1(G)
(push) ; 5
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 5
; Joined path conditions
(push) ; 5
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 6
(assert (not (< i1@124@00 (alen<Int> (opt_get1 $Snap.unit G@54@00)))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs             683
;  :arith-add-rows        594
;  :arith-assert-diseq    94
;  :arith-assert-lower    273
;  :arith-assert-upper    166
;  :arith-bound-prop      39
;  :arith-conflicts       16
;  :arith-eq-adapter      142
;  :arith-fixed-eqs       116
;  :arith-offset-eqs      15
;  :arith-pivots          234
;  :conflicts             38
;  :datatype-accessor-ax  44
;  :datatype-occurs-check 22
;  :decisions             64
;  :del-clause            1021
;  :final-checks          30
;  :interface-eqs         8
;  :max-generation        5
;  :max-memory            4.33
;  :memory                4.32
;  :mk-bool-var           1748
;  :mk-clause             1023
;  :num-allocs            161111
;  :num-checks            57
;  :propagations          409
;  :quant-instantiations  315
;  :rlimit-count          190595)
(assert (< i1@124@00 (alen<Int> (opt_get1 $Snap.unit G@54@00))))
(pop) ; 5
; Joined path conditions
(assert (< i1@124@00 (alen<Int> (opt_get1 $Snap.unit G@54@00))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@123@00 s@$ this@53@00 G@54@00 V@55@00) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@54@00) i1@124@00)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@54@00) i1@124@00)))
(push) ; 5
(assert (not (ite
  (and
    (<
      (inv@122@00 s@$ this@53@00 G@54@00 V@55@00 (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@54@00) i1@124@00))
      V@55@00)
    (<=
      0
      (inv@122@00 s@$ this@53@00 G@54@00 V@55@00 (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@54@00) i1@124@00))))
  (< $Perm.No $k@121@00)
  false)))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs             687
;  :arith-add-rows        599
;  :arith-assert-diseq    94
;  :arith-assert-lower    274
;  :arith-assert-upper    168
;  :arith-bound-prop      40
;  :arith-conflicts       17
;  :arith-eq-adapter      143
;  :arith-fixed-eqs       117
;  :arith-offset-eqs      15
;  :arith-pivots          236
;  :conflicts             39
;  :datatype-accessor-ax  44
;  :datatype-occurs-check 22
;  :decisions             64
;  :del-clause            1021
;  :final-checks          30
;  :interface-eqs         8
;  :max-generation        5
;  :max-memory            4.33
;  :memory                4.33
;  :mk-bool-var           1765
;  :mk-clause             1030
;  :num-allocs            161405
;  :num-checks            58
;  :propagations          409
;  :quant-instantiations  325
;  :rlimit-count          191279)
; [eval] (None(): option[array])
(pop) ; 4
(push) ; 4
; [else-branch: 31 | !(i1@124@00 < V@55@00 && 0 <= i1@124@00)]
(assert (not (and (< i1@124@00 V@55@00) (<= 0 i1@124@00))))
(pop) ; 4
(pop) ; 3
; Joined path conditions
(assert (implies
  (and (< i1@124@00 V@55@00) (<= 0 i1@124@00))
  (and
    (< i1@124@00 V@55@00)
    (<= 0 i1@124@00)
    (< i1@124@00 (alen<Int> (opt_get1 $Snap.unit G@54@00)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@123@00 s@$ this@53@00 G@54@00 V@55@00) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@54@00) i1@124@00)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@54@00) i1@124@00)))))
; Joined path conditions
(pop) ; 2
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@124@00 Int)) (!
  (implies
    (and (< i1@124@00 V@55@00) (<= 0 i1@124@00))
    (and
      (< i1@124@00 V@55@00)
      (<= 0 i1@124@00)
      (< i1@124@00 (alen<Int> (opt_get1 $Snap.unit G@54@00)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@123@00 s@$ this@53@00 G@54@00 V@55@00) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@54@00) i1@124@00)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@54@00) i1@124@00))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@54@00) i1@124@00))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(assert (forall ((i1@124@00 Int)) (!
  (implies
    (and (< i1@124@00 V@55@00) (<= 0 i1@124@00))
    (not
      (=
        ($FVF.lookup_option$array$ (sm@123@00 s@$ this@53@00 G@54@00 V@55@00) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@54@00) i1@124@00))
        (as None<option<array>>  option<array>))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@54@00) i1@124@00))
  :qid |prog.l<no position>|)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$)))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$)))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$))))))
  $Snap.unit))
; [eval] (forall i1: Int :: { alen(opt_get1(aloc(opt_get1(G), i1).option$array$)) } 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(G), i1).option$array$)) == V)
(declare-const i1@125@00 Int)
(push) ; 2
; [eval] 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(G), i1).option$array$)) == V
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 3
; [then-branch: 32 | 0 <= i1@125@00 | live]
; [else-branch: 32 | !(0 <= i1@125@00) | live]
(push) ; 4
; [then-branch: 32 | 0 <= i1@125@00]
(assert (<= 0 i1@125@00))
; [eval] i1 < V
(pop) ; 4
(push) ; 4
; [else-branch: 32 | !(0 <= i1@125@00)]
(assert (not (<= 0 i1@125@00)))
(pop) ; 4
(pop) ; 3
; Joined path conditions
; Joined path conditions
(push) ; 3
; [then-branch: 33 | i1@125@00 < V@55@00 && 0 <= i1@125@00 | live]
; [else-branch: 33 | !(i1@125@00 < V@55@00 && 0 <= i1@125@00) | live]
(push) ; 4
; [then-branch: 33 | i1@125@00 < V@55@00 && 0 <= i1@125@00]
(assert (and (< i1@125@00 V@55@00) (<= 0 i1@125@00)))
; [eval] alen(opt_get1(aloc(opt_get1(G), i1).option$array$)) == V
; [eval] alen(opt_get1(aloc(opt_get1(G), i1).option$array$))
; [eval] opt_get1(aloc(opt_get1(G), i1).option$array$)
; [eval] aloc(opt_get1(G), i1)
; [eval] opt_get1(G)
(push) ; 5
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 5
; Joined path conditions
(push) ; 5
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 6
(assert (not (< i1@125@00 (alen<Int> (opt_get1 $Snap.unit G@54@00)))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs             694
;  :arith-add-rows        601
;  :arith-assert-diseq    94
;  :arith-assert-lower    277
;  :arith-assert-upper    169
;  :arith-bound-prop      40
;  :arith-conflicts       17
;  :arith-eq-adapter      144
;  :arith-fixed-eqs       118
;  :arith-offset-eqs      15
;  :arith-pivots          240
;  :conflicts             39
;  :datatype-accessor-ax  45
;  :datatype-occurs-check 22
;  :decisions             64
;  :del-clause            1028
;  :final-checks          30
;  :interface-eqs         8
;  :max-generation        5
;  :max-memory            4.34
;  :memory                4.33
;  :mk-bool-var           1773
;  :mk-clause             1030
;  :num-allocs            161979
;  :num-checks            59
;  :propagations          409
;  :quant-instantiations  325
;  :rlimit-count          192482)
(assert (< i1@125@00 (alen<Int> (opt_get1 $Snap.unit G@54@00))))
(pop) ; 5
; Joined path conditions
(assert (< i1@125@00 (alen<Int> (opt_get1 $Snap.unit G@54@00))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@123@00 s@$ this@53@00 G@54@00 V@55@00) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@54@00) i1@125@00)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@54@00) i1@125@00)))
(push) ; 5
(assert (not (ite
  (and
    (<
      (inv@122@00 s@$ this@53@00 G@54@00 V@55@00 (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@54@00) i1@125@00))
      V@55@00)
    (<=
      0
      (inv@122@00 s@$ this@53@00 G@54@00 V@55@00 (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@54@00) i1@125@00))))
  (< $Perm.No $k@121@00)
  false)))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs             699
;  :arith-add-rows        606
;  :arith-assert-diseq    94
;  :arith-assert-lower    278
;  :arith-assert-upper    171
;  :arith-bound-prop      41
;  :arith-conflicts       18
;  :arith-eq-adapter      145
;  :arith-fixed-eqs       119
;  :arith-offset-eqs      15
;  :arith-pivots          242
;  :conflicts             40
;  :datatype-accessor-ax  45
;  :datatype-occurs-check 22
;  :decisions             64
;  :del-clause            1028
;  :final-checks          30
;  :interface-eqs         8
;  :max-generation        5
;  :max-memory            4.34
;  :memory                4.33
;  :mk-bool-var           1793
;  :mk-clause             1037
;  :num-allocs            162247
;  :num-checks            60
;  :propagations          409
;  :quant-instantiations  337
;  :rlimit-count          193211)
(push) ; 5
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 6
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (sm@123@00 s@$ this@53@00 G@54@00 V@55@00) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@54@00) i1@125@00))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs             699
;  :arith-add-rows        606
;  :arith-assert-diseq    94
;  :arith-assert-lower    278
;  :arith-assert-upper    171
;  :arith-bound-prop      41
;  :arith-conflicts       18
;  :arith-eq-adapter      145
;  :arith-fixed-eqs       119
;  :arith-offset-eqs      15
;  :arith-pivots          242
;  :conflicts             41
;  :datatype-accessor-ax  45
;  :datatype-occurs-check 22
;  :decisions             64
;  :del-clause            1028
;  :final-checks          30
;  :interface-eqs         8
;  :max-generation        5
;  :max-memory            4.34
;  :memory                4.33
;  :mk-bool-var           1793
;  :mk-clause             1037
;  :num-allocs            162336
;  :num-checks            61
;  :propagations          409
;  :quant-instantiations  337
;  :rlimit-count          193316)
(assert (not
  (=
    ($FVF.lookup_option$array$ (sm@123@00 s@$ this@53@00 G@54@00 V@55@00) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@54@00) i1@125@00))
    (as None<option<array>>  option<array>))))
(pop) ; 5
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (sm@123@00 s@$ this@53@00 G@54@00 V@55@00) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@54@00) i1@125@00))
    (as None<option<array>>  option<array>))))
(pop) ; 4
(push) ; 4
; [else-branch: 33 | !(i1@125@00 < V@55@00 && 0 <= i1@125@00)]
(assert (not (and (< i1@125@00 V@55@00) (<= 0 i1@125@00))))
(pop) ; 4
(pop) ; 3
; Joined path conditions
(assert (implies
  (and (< i1@125@00 V@55@00) (<= 0 i1@125@00))
  (and
    (< i1@125@00 V@55@00)
    (<= 0 i1@125@00)
    (< i1@125@00 (alen<Int> (opt_get1 $Snap.unit G@54@00)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@123@00 s@$ this@53@00 G@54@00 V@55@00) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@54@00) i1@125@00)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@54@00) i1@125@00))
    (not
      (=
        ($FVF.lookup_option$array$ (sm@123@00 s@$ this@53@00 G@54@00 V@55@00) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@54@00) i1@125@00))
        (as None<option<array>>  option<array>))))))
; Joined path conditions
(pop) ; 2
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@125@00 Int)) (!
  (implies
    (and (< i1@125@00 V@55@00) (<= 0 i1@125@00))
    (and
      (< i1@125@00 V@55@00)
      (<= 0 i1@125@00)
      (< i1@125@00 (alen<Int> (opt_get1 $Snap.unit G@54@00)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@123@00 s@$ this@53@00 G@54@00 V@55@00) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@54@00) i1@125@00)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@54@00) i1@125@00))
      (not
        (=
          ($FVF.lookup_option$array$ (sm@123@00 s@$ this@53@00 G@54@00 V@55@00) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@54@00) i1@125@00))
          (as None<option<array>>  option<array>)))))
  :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@123@00 s@$ this@53@00 G@54@00 V@55@00) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@54@00) i1@125@00)))))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(assert (forall ((i1@125@00 Int)) (!
  (implies
    (and (< i1@125@00 V@55@00) (<= 0 i1@125@00))
    (=
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@123@00 s@$ this@53@00 G@54@00 V@55@00) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@54@00) i1@125@00))))
      V@55@00))
  :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@123@00 s@$ this@53@00 G@54@00 V@55@00) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@54@00) i1@125@00)))))
  :qid |prog.l<no position>|)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$)))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$)))))))
  $Snap.unit))
; [eval] (forall i1: Int :: { aloc(opt_get1(G), i1) } (forall i2: Int :: { aloc(opt_get1(G), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(G), i1).option$array$ == aloc(opt_get1(G), i2).option$array$ ==> i1 == i2))
(declare-const i1@126@00 Int)
(push) ; 2
; [eval] (forall i2: Int :: { aloc(opt_get1(G), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(G), i1).option$array$ == aloc(opt_get1(G), i2).option$array$ ==> i1 == i2)
(declare-const i2@127@00 Int)
(push) ; 3
; [eval] 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(G), i1).option$array$ == aloc(opt_get1(G), i2).option$array$ ==> i1 == i2
; [eval] 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(G), i1).option$array$ == aloc(opt_get1(G), i2).option$array$
; [eval] 0 <= i1
(push) ; 4
; [then-branch: 34 | 0 <= i1@126@00 | live]
; [else-branch: 34 | !(0 <= i1@126@00) | live]
(push) ; 5
; [then-branch: 34 | 0 <= i1@126@00]
(assert (<= 0 i1@126@00))
; [eval] i1 < V
(push) ; 6
; [then-branch: 35 | i1@126@00 < V@55@00 | live]
; [else-branch: 35 | !(i1@126@00 < V@55@00) | live]
(push) ; 7
; [then-branch: 35 | i1@126@00 < V@55@00]
(assert (< i1@126@00 V@55@00))
; [eval] 0 <= i2
(push) ; 8
; [then-branch: 36 | 0 <= i2@127@00 | live]
; [else-branch: 36 | !(0 <= i2@127@00) | live]
(push) ; 9
; [then-branch: 36 | 0 <= i2@127@00]
(assert (<= 0 i2@127@00))
; [eval] i2 < V
(push) ; 10
; [then-branch: 37 | i2@127@00 < V@55@00 | live]
; [else-branch: 37 | !(i2@127@00 < V@55@00) | live]
(push) ; 11
; [then-branch: 37 | i2@127@00 < V@55@00]
(assert (< i2@127@00 V@55@00))
; [eval] aloc(opt_get1(G), i1).option$array$ == aloc(opt_get1(G), i2).option$array$
; [eval] aloc(opt_get1(G), i1)
; [eval] opt_get1(G)
(push) ; 12
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 12
; Joined path conditions
(push) ; 12
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 13
(assert (not (< i1@126@00 (alen<Int> (opt_get1 $Snap.unit G@54@00)))))
(check-sat)
; unsat
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs             706
;  :arith-add-rows        613
;  :arith-assert-diseq    94
;  :arith-assert-lower    283
;  :arith-assert-upper    172
;  :arith-bound-prop      41
;  :arith-conflicts       18
;  :arith-eq-adapter      146
;  :arith-fixed-eqs       120
;  :arith-offset-eqs      15
;  :arith-pivots          246
;  :conflicts             41
;  :datatype-accessor-ax  46
;  :datatype-occurs-check 22
;  :decisions             64
;  :del-clause            1035
;  :final-checks          30
;  :interface-eqs         8
;  :max-generation        5
;  :max-memory            4.35
;  :memory                4.34
;  :mk-bool-var           1803
;  :mk-clause             1037
;  :num-allocs            163110
;  :num-checks            62
;  :propagations          409
;  :quant-instantiations  337
;  :rlimit-count          194826)
(assert (< i1@126@00 (alen<Int> (opt_get1 $Snap.unit G@54@00))))
(pop) ; 12
; Joined path conditions
(assert (< i1@126@00 (alen<Int> (opt_get1 $Snap.unit G@54@00))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@123@00 s@$ this@53@00 G@54@00 V@55@00) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@54@00) i1@126@00)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@54@00) i1@126@00)))
(push) ; 12
(assert (not (ite
  (and
    (<
      (inv@122@00 s@$ this@53@00 G@54@00 V@55@00 (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@54@00) i1@126@00))
      V@55@00)
    (<=
      0
      (inv@122@00 s@$ this@53@00 G@54@00 V@55@00 (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@54@00) i1@126@00))))
  (< $Perm.No $k@121@00)
  false)))
(check-sat)
; unsat
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs             710
;  :arith-add-rows        618
;  :arith-assert-diseq    94
;  :arith-assert-lower    284
;  :arith-assert-upper    174
;  :arith-bound-prop      42
;  :arith-conflicts       19
;  :arith-eq-adapter      147
;  :arith-fixed-eqs       121
;  :arith-offset-eqs      15
;  :arith-pivots          248
;  :conflicts             42
;  :datatype-accessor-ax  46
;  :datatype-occurs-check 22
;  :decisions             64
;  :del-clause            1035
;  :final-checks          30
;  :interface-eqs         8
;  :max-generation        5
;  :max-memory            4.36
;  :memory                4.35
;  :mk-bool-var           1822
;  :mk-clause             1044
;  :num-allocs            163376
;  :num-checks            63
;  :propagations          409
;  :quant-instantiations  349
;  :rlimit-count          195549)
; [eval] aloc(opt_get1(G), i2)
; [eval] opt_get1(G)
(push) ; 12
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 12
; Joined path conditions
(push) ; 12
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 13
(assert (not (< i2@127@00 (alen<Int> (opt_get1 $Snap.unit G@54@00)))))
(check-sat)
; unsat
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs             710
;  :arith-add-rows        618
;  :arith-assert-diseq    94
;  :arith-assert-lower    284
;  :arith-assert-upper    174
;  :arith-bound-prop      42
;  :arith-conflicts       19
;  :arith-eq-adapter      147
;  :arith-fixed-eqs       121
;  :arith-offset-eqs      15
;  :arith-pivots          248
;  :conflicts             42
;  :datatype-accessor-ax  46
;  :datatype-occurs-check 22
;  :decisions             64
;  :del-clause            1035
;  :final-checks          30
;  :interface-eqs         8
;  :max-generation        5
;  :max-memory            4.36
;  :memory                4.35
;  :mk-bool-var           1822
;  :mk-clause             1044
;  :num-allocs            163401
;  :num-checks            64
;  :propagations          409
;  :quant-instantiations  349
;  :rlimit-count          195579)
(assert (< i2@127@00 (alen<Int> (opt_get1 $Snap.unit G@54@00))))
(pop) ; 12
; Joined path conditions
(assert (< i2@127@00 (alen<Int> (opt_get1 $Snap.unit G@54@00))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@123@00 s@$ this@53@00 G@54@00 V@55@00) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@54@00) i2@127@00)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@54@00) i2@127@00)))
(push) ; 12
(assert (not (ite
  (and
    (<
      (inv@122@00 s@$ this@53@00 G@54@00 V@55@00 (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@54@00) i2@127@00))
      V@55@00)
    (<=
      0
      (inv@122@00 s@$ this@53@00 G@54@00 V@55@00 (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@54@00) i2@127@00))))
  (< $Perm.No $k@121@00)
  false)))
(check-sat)
; unsat
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs             714
;  :arith-add-rows        623
;  :arith-assert-diseq    94
;  :arith-assert-lower    285
;  :arith-assert-upper    176
;  :arith-bound-prop      43
;  :arith-conflicts       20
;  :arith-eq-adapter      148
;  :arith-fixed-eqs       122
;  :arith-offset-eqs      15
;  :arith-pivots          250
;  :conflicts             43
;  :datatype-accessor-ax  46
;  :datatype-occurs-check 22
;  :decisions             64
;  :del-clause            1035
;  :final-checks          30
;  :interface-eqs         8
;  :max-generation        5
;  :max-memory            4.37
;  :memory                4.36
;  :mk-bool-var           1841
;  :mk-clause             1051
;  :num-allocs            163672
;  :num-checks            65
;  :propagations          409
;  :quant-instantiations  360
;  :rlimit-count          196286)
(pop) ; 11
(push) ; 11
; [else-branch: 37 | !(i2@127@00 < V@55@00)]
(assert (not (< i2@127@00 V@55@00)))
(pop) ; 11
(pop) ; 10
; Joined path conditions
(assert (implies
  (< i2@127@00 V@55@00)
  (and
    (< i2@127@00 V@55@00)
    (< i1@126@00 (alen<Int> (opt_get1 $Snap.unit G@54@00)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@123@00 s@$ this@53@00 G@54@00 V@55@00) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@54@00) i1@126@00)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@54@00) i1@126@00))
    (< i2@127@00 (alen<Int> (opt_get1 $Snap.unit G@54@00)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@123@00 s@$ this@53@00 G@54@00 V@55@00) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@54@00) i2@127@00)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@54@00) i2@127@00)))))
; Joined path conditions
(pop) ; 9
(push) ; 9
; [else-branch: 36 | !(0 <= i2@127@00)]
(assert (not (<= 0 i2@127@00)))
(pop) ; 9
(pop) ; 8
; Joined path conditions
(assert (implies
  (<= 0 i2@127@00)
  (and
    (<= 0 i2@127@00)
    (implies
      (< i2@127@00 V@55@00)
      (and
        (< i2@127@00 V@55@00)
        (< i1@126@00 (alen<Int> (opt_get1 $Snap.unit G@54@00)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@123@00 s@$ this@53@00 G@54@00 V@55@00) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@54@00) i1@126@00)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@54@00) i1@126@00))
        (< i2@127@00 (alen<Int> (opt_get1 $Snap.unit G@54@00)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@123@00 s@$ this@53@00 G@54@00 V@55@00) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@54@00) i2@127@00)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@54@00) i2@127@00)))))))
; Joined path conditions
(pop) ; 7
(push) ; 7
; [else-branch: 35 | !(i1@126@00 < V@55@00)]
(assert (not (< i1@126@00 V@55@00)))
(pop) ; 7
(pop) ; 6
; Joined path conditions
(assert (implies
  (< i1@126@00 V@55@00)
  (and
    (< i1@126@00 V@55@00)
    (implies
      (<= 0 i2@127@00)
      (and
        (<= 0 i2@127@00)
        (implies
          (< i2@127@00 V@55@00)
          (and
            (< i2@127@00 V@55@00)
            (< i1@126@00 (alen<Int> (opt_get1 $Snap.unit G@54@00)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@123@00 s@$ this@53@00 G@54@00 V@55@00) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@54@00) i1@126@00)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@54@00) i1@126@00))
            (< i2@127@00 (alen<Int> (opt_get1 $Snap.unit G@54@00)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@123@00 s@$ this@53@00 G@54@00 V@55@00) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@54@00) i2@127@00)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@54@00) i2@127@00)))))))))
; Joined path conditions
(pop) ; 5
(push) ; 5
; [else-branch: 34 | !(0 <= i1@126@00)]
(assert (not (<= 0 i1@126@00)))
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (implies
  (<= 0 i1@126@00)
  (and
    (<= 0 i1@126@00)
    (implies
      (< i1@126@00 V@55@00)
      (and
        (< i1@126@00 V@55@00)
        (implies
          (<= 0 i2@127@00)
          (and
            (<= 0 i2@127@00)
            (implies
              (< i2@127@00 V@55@00)
              (and
                (< i2@127@00 V@55@00)
                (< i1@126@00 (alen<Int> (opt_get1 $Snap.unit G@54@00)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@123@00 s@$ this@53@00 G@54@00 V@55@00) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@54@00) i1@126@00)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@54@00) i1@126@00))
                (< i2@127@00 (alen<Int> (opt_get1 $Snap.unit G@54@00)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@123@00 s@$ this@53@00 G@54@00 V@55@00) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@54@00) i2@127@00)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@54@00) i2@127@00)))))))))))
; Joined path conditions
(push) ; 4
; [then-branch: 38 | Lookup(option$array$,sm@123@00(s@$, this@53@00, G@54@00, V@55@00),aloc((_, _), opt_get1(_, G@54@00), i1@126@00)) == Lookup(option$array$,sm@123@00(s@$, this@53@00, G@54@00, V@55@00),aloc((_, _), opt_get1(_, G@54@00), i2@127@00)) && i2@127@00 < V@55@00 && 0 <= i2@127@00 && i1@126@00 < V@55@00 && 0 <= i1@126@00 | live]
; [else-branch: 38 | !(Lookup(option$array$,sm@123@00(s@$, this@53@00, G@54@00, V@55@00),aloc((_, _), opt_get1(_, G@54@00), i1@126@00)) == Lookup(option$array$,sm@123@00(s@$, this@53@00, G@54@00, V@55@00),aloc((_, _), opt_get1(_, G@54@00), i2@127@00)) && i2@127@00 < V@55@00 && 0 <= i2@127@00 && i1@126@00 < V@55@00 && 0 <= i1@126@00) | live]
(push) ; 5
; [then-branch: 38 | Lookup(option$array$,sm@123@00(s@$, this@53@00, G@54@00, V@55@00),aloc((_, _), opt_get1(_, G@54@00), i1@126@00)) == Lookup(option$array$,sm@123@00(s@$, this@53@00, G@54@00, V@55@00),aloc((_, _), opt_get1(_, G@54@00), i2@127@00)) && i2@127@00 < V@55@00 && 0 <= i2@127@00 && i1@126@00 < V@55@00 && 0 <= i1@126@00]
(assert (and
  (and
    (and
      (and
        (=
          ($FVF.lookup_option$array$ (sm@123@00 s@$ this@53@00 G@54@00 V@55@00) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@54@00) i1@126@00))
          ($FVF.lookup_option$array$ (sm@123@00 s@$ this@53@00 G@54@00 V@55@00) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@54@00) i2@127@00)))
        (< i2@127@00 V@55@00))
      (<= 0 i2@127@00))
    (< i1@126@00 V@55@00))
  (<= 0 i1@126@00)))
; [eval] i1 == i2
(pop) ; 5
(push) ; 5
; [else-branch: 38 | !(Lookup(option$array$,sm@123@00(s@$, this@53@00, G@54@00, V@55@00),aloc((_, _), opt_get1(_, G@54@00), i1@126@00)) == Lookup(option$array$,sm@123@00(s@$, this@53@00, G@54@00, V@55@00),aloc((_, _), opt_get1(_, G@54@00), i2@127@00)) && i2@127@00 < V@55@00 && 0 <= i2@127@00 && i1@126@00 < V@55@00 && 0 <= i1@126@00)]
(assert (not
  (and
    (and
      (and
        (and
          (=
            ($FVF.lookup_option$array$ (sm@123@00 s@$ this@53@00 G@54@00 V@55@00) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@54@00) i1@126@00))
            ($FVF.lookup_option$array$ (sm@123@00 s@$ this@53@00 G@54@00 V@55@00) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@54@00) i2@127@00)))
          (< i2@127@00 V@55@00))
        (<= 0 i2@127@00))
      (< i1@126@00 V@55@00))
    (<= 0 i1@126@00))))
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (implies
  (and
    (and
      (and
        (and
          (=
            ($FVF.lookup_option$array$ (sm@123@00 s@$ this@53@00 G@54@00 V@55@00) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@54@00) i1@126@00))
            ($FVF.lookup_option$array$ (sm@123@00 s@$ this@53@00 G@54@00 V@55@00) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@54@00) i2@127@00)))
          (< i2@127@00 V@55@00))
        (<= 0 i2@127@00))
      (< i1@126@00 V@55@00))
    (<= 0 i1@126@00))
  (and
    (=
      ($FVF.lookup_option$array$ (sm@123@00 s@$ this@53@00 G@54@00 V@55@00) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@54@00) i1@126@00))
      ($FVF.lookup_option$array$ (sm@123@00 s@$ this@53@00 G@54@00 V@55@00) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@54@00) i2@127@00)))
    (< i2@127@00 V@55@00)
    (<= 0 i2@127@00)
    (< i1@126@00 V@55@00)
    (<= 0 i1@126@00))))
; Joined path conditions
(pop) ; 3
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i2@127@00 Int)) (!
  (and
    (implies
      (<= 0 i1@126@00)
      (and
        (<= 0 i1@126@00)
        (implies
          (< i1@126@00 V@55@00)
          (and
            (< i1@126@00 V@55@00)
            (implies
              (<= 0 i2@127@00)
              (and
                (<= 0 i2@127@00)
                (implies
                  (< i2@127@00 V@55@00)
                  (and
                    (< i2@127@00 V@55@00)
                    (< i1@126@00 (alen<Int> (opt_get1 $Snap.unit G@54@00)))
                    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@123@00 s@$ this@53@00 G@54@00 V@55@00) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit G@54@00) i1@126@00)) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit G@54@00) i1@126@00))
                    (< i2@127@00 (alen<Int> (opt_get1 $Snap.unit G@54@00)))
                    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@123@00 s@$ this@53@00 G@54@00 V@55@00) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit G@54@00) i2@127@00)) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit G@54@00) i2@127@00))))))))))
    (implies
      (and
        (and
          (and
            (and
              (=
                ($FVF.lookup_option$array$ (sm@123@00 s@$ this@53@00 G@54@00 V@55@00) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@54@00) i1@126@00))
                ($FVF.lookup_option$array$ (sm@123@00 s@$ this@53@00 G@54@00 V@55@00) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@54@00) i2@127@00)))
              (< i2@127@00 V@55@00))
            (<= 0 i2@127@00))
          (< i1@126@00 V@55@00))
        (<= 0 i1@126@00))
      (and
        (=
          ($FVF.lookup_option$array$ (sm@123@00 s@$ this@53@00 G@54@00 V@55@00) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@54@00) i1@126@00))
          ($FVF.lookup_option$array$ (sm@123@00 s@$ this@53@00 G@54@00 V@55@00) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@54@00) i2@127@00)))
        (< i2@127@00 V@55@00)
        (<= 0 i2@127@00)
        (< i1@126@00 V@55@00)
        (<= 0 i1@126@00))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@54@00) i2@127@00))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 2
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@126@00 Int)) (!
  (forall ((i2@127@00 Int)) (!
    (and
      (implies
        (<= 0 i1@126@00)
        (and
          (<= 0 i1@126@00)
          (implies
            (< i1@126@00 V@55@00)
            (and
              (< i1@126@00 V@55@00)
              (implies
                (<= 0 i2@127@00)
                (and
                  (<= 0 i2@127@00)
                  (implies
                    (< i2@127@00 V@55@00)
                    (and
                      (< i2@127@00 V@55@00)
                      (< i1@126@00 (alen<Int> (opt_get1 $Snap.unit G@54@00)))
                      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@123@00 s@$ this@53@00 G@54@00 V@55@00) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit G@54@00) i1@126@00)) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit G@54@00) i1@126@00))
                      (< i2@127@00 (alen<Int> (opt_get1 $Snap.unit G@54@00)))
                      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@123@00 s@$ this@53@00 G@54@00 V@55@00) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit G@54@00) i2@127@00)) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit G@54@00) i2@127@00))))))))))
      (implies
        (and
          (and
            (and
              (and
                (=
                  ($FVF.lookup_option$array$ (sm@123@00 s@$ this@53@00 G@54@00 V@55@00) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit G@54@00) i1@126@00))
                  ($FVF.lookup_option$array$ (sm@123@00 s@$ this@53@00 G@54@00 V@55@00) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit G@54@00) i2@127@00)))
                (< i2@127@00 V@55@00))
              (<= 0 i2@127@00))
            (< i1@126@00 V@55@00))
          (<= 0 i1@126@00))
        (and
          (=
            ($FVF.lookup_option$array$ (sm@123@00 s@$ this@53@00 G@54@00 V@55@00) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@54@00) i1@126@00))
            ($FVF.lookup_option$array$ (sm@123@00 s@$ this@53@00 G@54@00 V@55@00) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@54@00) i2@127@00)))
          (< i2@127@00 V@55@00)
          (<= 0 i2@127@00)
          (< i1@126@00 V@55@00)
          (<= 0 i1@126@00))))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@54@00) i2@127@00))
    :qid |prog.l<no position>-aux|))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@54@00) i1@126@00))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(assert (forall ((i1@126@00 Int)) (!
  (forall ((i2@127@00 Int)) (!
    (implies
      (and
        (and
          (and
            (and
              (=
                ($FVF.lookup_option$array$ (sm@123@00 s@$ this@53@00 G@54@00 V@55@00) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@54@00) i1@126@00))
                ($FVF.lookup_option$array$ (sm@123@00 s@$ this@53@00 G@54@00 V@55@00) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@54@00) i2@127@00)))
              (< i2@127@00 V@55@00))
            (<= 0 i2@127@00))
          (< i1@126@00 V@55@00))
        (<= 0 i1@126@00))
      (= i1@126@00 i2@127@00))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@54@00) i2@127@00))
    :qid |prog.l<no position>|))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@54@00) i1@126@00))
  :qid |prog.l<no position>|)))
(declare-const i1@128@00 Int)
(declare-const j@129@00 Int)
(push) ; 2
; [eval] 0 <= i1 && i1 < V && (0 <= j && j < V)
; [eval] 0 <= i1
(push) ; 3
; [then-branch: 39 | 0 <= i1@128@00 | live]
; [else-branch: 39 | !(0 <= i1@128@00) | live]
(push) ; 4
; [then-branch: 39 | 0 <= i1@128@00]
(assert (<= 0 i1@128@00))
; [eval] i1 < V
(push) ; 5
; [then-branch: 40 | i1@128@00 < V@55@00 | live]
; [else-branch: 40 | !(i1@128@00 < V@55@00) | live]
(push) ; 6
; [then-branch: 40 | i1@128@00 < V@55@00]
(assert (< i1@128@00 V@55@00))
; [eval] 0 <= j
(push) ; 7
; [then-branch: 41 | 0 <= j@129@00 | live]
; [else-branch: 41 | !(0 <= j@129@00) | live]
(push) ; 8
; [then-branch: 41 | 0 <= j@129@00]
(assert (<= 0 j@129@00))
; [eval] j < V
(pop) ; 8
(push) ; 8
; [else-branch: 41 | !(0 <= j@129@00)]
(assert (not (<= 0 j@129@00)))
(pop) ; 8
(pop) ; 7
; Joined path conditions
; Joined path conditions
(pop) ; 6
(push) ; 6
; [else-branch: 40 | !(i1@128@00 < V@55@00)]
(assert (not (< i1@128@00 V@55@00)))
(pop) ; 6
(pop) ; 5
; Joined path conditions
; Joined path conditions
(pop) ; 4
(push) ; 4
; [else-branch: 39 | !(0 <= i1@128@00)]
(assert (not (<= 0 i1@128@00)))
(pop) ; 4
(pop) ; 3
; Joined path conditions
; Joined path conditions
(assert (and
  (and (and (< j@129@00 V@55@00) (<= 0 j@129@00)) (< i1@128@00 V@55@00))
  (<= 0 i1@128@00)))
; [eval] aloc(opt_get1(aloc(opt_get1(G), i1).option$array$), j)
; [eval] opt_get1(aloc(opt_get1(G), i1).option$array$)
; [eval] aloc(opt_get1(G), i1)
; [eval] opt_get1(G)
(push) ; 3
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 3
; Joined path conditions
(push) ; 3
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 4
(assert (not (< i1@128@00 (alen<Int> (opt_get1 $Snap.unit G@54@00)))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs             717
;  :arith-add-rows        631
;  :arith-assert-diseq    94
;  :arith-assert-lower    294
;  :arith-assert-upper    179
;  :arith-bound-prop      43
;  :arith-conflicts       20
;  :arith-eq-adapter      151
;  :arith-fixed-eqs       125
;  :arith-offset-eqs      15
;  :arith-pivots          260
;  :conflicts             43
;  :datatype-accessor-ax  46
;  :datatype-occurs-check 22
;  :decisions             64
;  :del-clause            1073
;  :final-checks          30
;  :interface-eqs         8
;  :max-generation        5
;  :max-memory            4.37
;  :memory                4.36
;  :mk-bool-var           1868
;  :mk-clause             1075
;  :num-allocs            164866
;  :num-checks            66
;  :propagations          409
;  :quant-instantiations  360
;  :rlimit-count          199115)
(assert (< i1@128@00 (alen<Int> (opt_get1 $Snap.unit G@54@00))))
(pop) ; 3
; Joined path conditions
(assert (< i1@128@00 (alen<Int> (opt_get1 $Snap.unit G@54@00))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@123@00 s@$ this@53@00 G@54@00 V@55@00) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@54@00) i1@128@00)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@54@00) i1@128@00)))
(push) ; 3
(assert (not (ite
  (and
    (<
      (inv@122@00 s@$ this@53@00 G@54@00 V@55@00 (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@54@00) i1@128@00))
      V@55@00)
    (<=
      0
      (inv@122@00 s@$ this@53@00 G@54@00 V@55@00 (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@54@00) i1@128@00))))
  (< $Perm.No $k@121@00)
  false)))
(check-sat)
; unsat
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs             722
;  :arith-add-rows        636
;  :arith-assert-diseq    94
;  :arith-assert-lower    295
;  :arith-assert-upper    181
;  :arith-bound-prop      44
;  :arith-conflicts       21
;  :arith-eq-adapter      152
;  :arith-fixed-eqs       126
;  :arith-offset-eqs      15
;  :arith-pivots          262
;  :conflicts             44
;  :datatype-accessor-ax  46
;  :datatype-occurs-check 22
;  :decisions             64
;  :del-clause            1073
;  :final-checks          30
;  :interface-eqs         8
;  :max-generation        5
;  :max-memory            4.37
;  :memory                4.36
;  :mk-bool-var           1897
;  :mk-clause             1082
;  :num-allocs            165207
;  :num-checks            67
;  :propagations          409
;  :quant-instantiations  375
;  :rlimit-count          200167)
(push) ; 3
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 4
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (sm@123@00 s@$ this@53@00 G@54@00 V@55@00) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@54@00) i1@128@00))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs             722
;  :arith-add-rows        636
;  :arith-assert-diseq    94
;  :arith-assert-lower    295
;  :arith-assert-upper    181
;  :arith-bound-prop      44
;  :arith-conflicts       21
;  :arith-eq-adapter      152
;  :arith-fixed-eqs       126
;  :arith-offset-eqs      15
;  :arith-pivots          262
;  :conflicts             45
;  :datatype-accessor-ax  46
;  :datatype-occurs-check 22
;  :decisions             64
;  :del-clause            1073
;  :final-checks          30
;  :interface-eqs         8
;  :max-generation        5
;  :max-memory            4.37
;  :memory                4.36
;  :mk-bool-var           1897
;  :mk-clause             1082
;  :num-allocs            165300
;  :num-checks            68
;  :propagations          409
;  :quant-instantiations  375
;  :rlimit-count          200272)
(assert (not
  (=
    ($FVF.lookup_option$array$ (sm@123@00 s@$ this@53@00 G@54@00 V@55@00) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@54@00) i1@128@00))
    (as None<option<array>>  option<array>))))
(pop) ; 3
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (sm@123@00 s@$ this@53@00 G@54@00 V@55@00) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@54@00) i1@128@00))
    (as None<option<array>>  option<array>))))
(push) ; 3
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 4
(assert (not (<
  j@129@00
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@123@00 s@$ this@53@00 G@54@00 V@55@00) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@54@00) i1@128@00)))))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs             728
;  :arith-add-rows        641
;  :arith-assert-diseq    94
;  :arith-assert-lower    298
;  :arith-assert-upper    182
;  :arith-bound-prop      44
;  :arith-conflicts       22
;  :arith-eq-adapter      153
;  :arith-fixed-eqs       127
;  :arith-offset-eqs      15
;  :arith-pivots          266
;  :conflicts             46
;  :datatype-accessor-ax  46
;  :datatype-occurs-check 22
;  :decisions             64
;  :del-clause            1077
;  :final-checks          30
;  :interface-eqs         8
;  :max-generation        5
;  :max-memory            4.37
;  :memory                4.36
;  :mk-bool-var           1908
;  :mk-clause             1086
;  :num-allocs            165505
;  :num-checks            69
;  :propagations          411
;  :quant-instantiations  382
;  :rlimit-count          200786)
(assert (<
  j@129@00
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@123@00 s@$ this@53@00 G@54@00 V@55@00) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@54@00) i1@128@00))))))
(pop) ; 3
; Joined path conditions
(assert (<
  j@129@00
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@123@00 s@$ this@53@00 G@54@00 V@55@00) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@54@00) i1@128@00))))))
(declare-const $k@130@00 $Perm)
(assert ($Perm.isReadVar $k@130@00 $Perm.Write))
(pop) ; 2
(declare-fun inv@131@00 ($Snap $Ref option<array> Int $Ref) Int)
(declare-fun inv@132@00 ($Snap $Ref option<array> Int $Ref) Int)
; Nested auxiliary terms: globals
(assert ($Perm.isReadVar $k@130@00 $Perm.Write))
; Nested auxiliary terms: non-globals
(assert (forall ((i1@128@00 Int) (j@129@00 Int)) (!
  (and
    (< i1@128@00 (alen<Int> (opt_get1 $Snap.unit G@54@00)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@123@00 s@$ this@53@00 G@54@00 V@55@00) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@54@00) i1@128@00)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@54@00) i1@128@00))
    (not
      (=
        ($FVF.lookup_option$array$ (sm@123@00 s@$ this@53@00 G@54@00 V@55@00) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@54@00) i1@128@00))
        (as None<option<array>>  option<array>)))
    (<
      j@129@00
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@123@00 s@$ this@53@00 G@54@00 V@55@00) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@54@00) i1@128@00))))))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@123@00 s@$ this@53@00 G@54@00 V@55@00) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@54@00) i1@128@00))) j@129@00))
  :qid |int-aux|)))
(push) ; 2
(assert (not (forall ((i1@128@00 Int) (j@129@00 Int)) (!
  (implies
    (and
      (and (and (< j@129@00 V@55@00) (<= 0 j@129@00)) (< i1@128@00 V@55@00))
      (<= 0 i1@128@00))
    (or (= $k@130@00 $Perm.No) (< $Perm.No $k@130@00)))
  
  ))))
(check-sat)
; unsat
(pop) ; 2
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs             728
;  :arith-add-rows        643
;  :arith-assert-diseq    95
;  :arith-assert-lower    300
;  :arith-assert-upper    183
;  :arith-bound-prop      44
;  :arith-conflicts       22
;  :arith-eq-adapter      154
;  :arith-fixed-eqs       127
;  :arith-offset-eqs      15
;  :arith-pivots          269
;  :conflicts             47
;  :datatype-accessor-ax  46
;  :datatype-occurs-check 22
;  :decisions             64
;  :del-clause            1084
;  :final-checks          30
;  :interface-eqs         8
;  :max-generation        5
;  :max-memory            4.37
;  :memory                4.36
;  :mk-bool-var           1917
;  :mk-clause             1088
;  :num-allocs            166095
;  :num-checks            70
;  :propagations          412
;  :quant-instantiations  382
;  :rlimit-count          201760)
; Check receiver injectivity
(push) ; 2
(assert (not (forall ((i11@128@00 Int) (j1@129@00 Int) (i12@128@00 Int) (j2@129@00 Int)) (!
  (implies
    (and
      (and
        (and
          (and
            (and (< j1@129@00 V@55@00) (<= 0 j1@129@00))
            (< i11@128@00 V@55@00))
          (<= 0 i11@128@00))
        (< $Perm.No $k@130@00))
      (and
        (and
          (and
            (and (< j2@129@00 V@55@00) (<= 0 j2@129@00))
            (< i12@128@00 V@55@00))
          (<= 0 i12@128@00))
        (< $Perm.No $k@130@00))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@123@00 s@$ this@53@00 G@54@00 V@55@00) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@54@00) i11@128@00))) j1@129@00)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@123@00 s@$ this@53@00 G@54@00 V@55@00) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@54@00) i12@128@00))) j2@129@00)))
    (and (= i11@128@00 i12@128@00) (= j1@129@00 j2@129@00)))
  
  :qid |int-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 2
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs             770
;  :arith-add-rows        654
;  :arith-assert-diseq    95
;  :arith-assert-lower    313
;  :arith-assert-upper    188
;  :arith-bound-prop      46
;  :arith-conflicts       22
;  :arith-eq-adapter      161
;  :arith-fixed-eqs       130
;  :arith-offset-eqs      15
;  :arith-pivots          281
;  :conflicts             48
;  :datatype-accessor-ax  46
;  :datatype-occurs-check 22
;  :decisions             64
;  :del-clause            1144
;  :final-checks          30
;  :interface-eqs         8
;  :max-generation        5
;  :max-memory            4.48
;  :memory                4.47
;  :mk-bool-var           2052
;  :mk-clause             1148
;  :num-allocs            167078
;  :num-checks            71
;  :propagations          434
;  :quant-instantiations  440
;  :rlimit-count          205034
;  :time                  0.00)
; Definitional axioms for inverse functions
(assert (forall ((i1@128@00 Int) (j@129@00 Int)) (!
  (implies
    (and
      (and
        (and (and (< j@129@00 V@55@00) (<= 0 j@129@00)) (< i1@128@00 V@55@00))
        (<= 0 i1@128@00))
      (< $Perm.No $k@130@00))
    (and
      (=
        (inv@131@00 s@$ this@53@00 G@54@00 V@55@00 (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@123@00 s@$ this@53@00 G@54@00 V@55@00) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@54@00) i1@128@00))) j@129@00))
        i1@128@00)
      (=
        (inv@132@00 s@$ this@53@00 G@54@00 V@55@00 (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@123@00 s@$ this@53@00 G@54@00 V@55@00) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@54@00) i1@128@00))) j@129@00))
        j@129@00)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@123@00 s@$ this@53@00 G@54@00 V@55@00) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@54@00) i1@128@00))) j@129@00))
  )))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and
          (and
            (< (inv@132@00 s@$ this@53@00 G@54@00 V@55@00 r) V@55@00)
            (<= 0 (inv@132@00 s@$ this@53@00 G@54@00 V@55@00 r)))
          (< (inv@131@00 s@$ this@53@00 G@54@00 V@55@00 r) V@55@00))
        (<= 0 (inv@131@00 s@$ this@53@00 G@54@00 V@55@00 r)))
      (< $Perm.No $k@130@00))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@123@00 s@$ this@53@00 G@54@00 V@55@00) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@54@00) (inv@131@00 s@$ this@53@00 G@54@00 V@55@00 r)))) (inv@132@00 s@$ this@53@00 G@54@00 V@55@00 r))
      r))
  :pattern ((inv@131@00 s@$ this@53@00 G@54@00 V@55@00 r))
  :pattern ((inv@132@00 s@$ this@53@00 G@54@00 V@55@00 r))
  :qid |int-fctOfInv|)))
; Permissions are non-negative
(assert (forall ((i1@128@00 Int) (j@129@00 Int)) (!
  (<= $Perm.No $k@130@00)
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@123@00 s@$ this@53@00 G@54@00 V@55@00) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@54@00) i1@128@00))) j@129@00))
  :qid |int-permAtLeastZero|)))
; Field permissions are at most one
(assert (forall ((i1@128@00 Int) (j@129@00 Int)) (!
  (<= $k@130@00 $Perm.Write)
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@123@00 s@$ this@53@00 G@54@00 V@55@00) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@54@00) i1@128@00))) j@129@00))
  :qid |int-permAtMostOne|)))
; Permission implies non-null receiver
(assert (forall ((i1@128@00 Int) (j@129@00 Int)) (!
  (implies
    (and
      (and
        (and (and (< j@129@00 V@55@00) (<= 0 j@129@00)) (< i1@128@00 V@55@00))
        (<= 0 i1@128@00))
      (< $Perm.No $k@130@00))
    (not
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@123@00 s@$ this@53@00 G@54@00 V@55@00) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@54@00) i1@128@00))) j@129@00)
        $Ref.null)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@123@00 s@$ this@53@00 G@54@00 V@55@00) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@54@00) i1@128@00))) j@129@00))
  :qid |int-permImpliesNonNull|)))
(declare-fun sm@133@00 ($Snap $Ref option<array> Int) $FVF<Int>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and
        (and
          (and
            (< (inv@132@00 s@$ this@53@00 G@54@00 V@55@00 r) V@55@00)
            (<= 0 (inv@132@00 s@$ this@53@00 G@54@00 V@55@00 r)))
          (< (inv@131@00 s@$ this@53@00 G@54@00 V@55@00 r) V@55@00))
        (<= 0 (inv@131@00 s@$ this@53@00 G@54@00 V@55@00 r)))
      (< $Perm.No $k@130@00)
      false)
    (=
      ($FVF.lookup_int (sm@133@00 s@$ this@53@00 G@54@00 V@55@00) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$)))))))) r)))
  :pattern (($FVF.lookup_int (sm@133@00 s@$ this@53@00 G@54@00 V@55@00) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$)))))))) r))
  :qid |qp.fvfValDef2|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$)))))))) r) r)
  :pattern (($FVF.lookup_int (sm@133@00 s@$ this@53@00 G@54@00 V@55@00) r))
  :qid |qp.fvfResTrgDef3|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and
          (< (inv@132@00 s@$ this@53@00 G@54@00 V@55@00 r) V@55@00)
          (<= 0 (inv@132@00 s@$ this@53@00 G@54@00 V@55@00 r)))
        (< (inv@131@00 s@$ this@53@00 G@54@00 V@55@00 r) V@55@00))
      (<= 0 (inv@131@00 s@$ this@53@00 G@54@00 V@55@00 r)))
    ($FVF.loc_int ($FVF.lookup_int (sm@133@00 s@$ this@53@00 G@54@00 V@55@00) r) r))
  :pattern ((inv@131@00 s@$ this@53@00 G@54@00 V@55@00 r) (inv@132@00 s@$ this@53@00 G@54@00 V@55@00 r))
  )))
(pop) ; 1
(assert (forall ((s@$ $Snap) (this@53@00 $Ref) (G@54@00 option<array>) (V@55@00 Int)) (!
  (=
    (SquareIntMatrix1%limited s@$ this@53@00 G@54@00 V@55@00)
    (SquareIntMatrix1 s@$ this@53@00 G@54@00 V@55@00))
  :pattern ((SquareIntMatrix1 s@$ this@53@00 G@54@00 V@55@00))
  )))
(assert (forall ((s@$ $Snap) (this@53@00 $Ref) (G@54@00 option<array>) (V@55@00 Int)) (!
  (SquareIntMatrix1%stateless this@53@00 G@54@00 V@55@00)
  :pattern ((SquareIntMatrix1%limited s@$ this@53@00 G@54@00 V@55@00))
  )))
; ----- Verification of function body and postcondition -----
(push) ; 1
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and
          (and
            (< (inv@132@00 s@$ this@53@00 G@54@00 V@55@00 r) V@55@00)
            (<= 0 (inv@132@00 s@$ this@53@00 G@54@00 V@55@00 r)))
          (< (inv@131@00 s@$ this@53@00 G@54@00 V@55@00 r) V@55@00))
        (<= 0 (inv@131@00 s@$ this@53@00 G@54@00 V@55@00 r)))
      (< $Perm.No $k@130@00))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@123@00 s@$ this@53@00 G@54@00 V@55@00) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@54@00) (inv@131@00 s@$ this@53@00 G@54@00 V@55@00 r)))) (inv@132@00 s@$ this@53@00 G@54@00 V@55@00 r))
      r))
  :pattern ((inv@131@00 s@$ this@53@00 G@54@00 V@55@00 r))
  :pattern ((inv@132@00 s@$ this@53@00 G@54@00 V@55@00 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and
        (and
          (and
            (< (inv@132@00 s@$ this@53@00 G@54@00 V@55@00 r) V@55@00)
            (<= 0 (inv@132@00 s@$ this@53@00 G@54@00 V@55@00 r)))
          (< (inv@131@00 s@$ this@53@00 G@54@00 V@55@00 r) V@55@00))
        (<= 0 (inv@131@00 s@$ this@53@00 G@54@00 V@55@00 r)))
      (< $Perm.No $k@130@00)
      false)
    (=
      ($FVF.lookup_int (sm@133@00 s@$ this@53@00 G@54@00 V@55@00) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$)))))))) r)))
  :pattern (($FVF.lookup_int (sm@133@00 s@$ this@53@00 G@54@00 V@55@00) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$)))))))) r))
  :qid |qp.fvfValDef2|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$)))))))) r) r)
  :pattern (($FVF.lookup_int (sm@133@00 s@$ this@53@00 G@54@00 V@55@00) r))
  :qid |qp.fvfResTrgDef3|)))
(assert (forall ((i1@128@00 Int) (j@129@00 Int)) (!
  (implies
    (and
      (and
        (and (and (< j@129@00 V@55@00) (<= 0 j@129@00)) (< i1@128@00 V@55@00))
        (<= 0 i1@128@00))
      (< $Perm.No $k@130@00))
    (and
      (=
        (inv@131@00 s@$ this@53@00 G@54@00 V@55@00 (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@123@00 s@$ this@53@00 G@54@00 V@55@00) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@54@00) i1@128@00))) j@129@00))
        i1@128@00)
      (=
        (inv@132@00 s@$ this@53@00 G@54@00 V@55@00 (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@123@00 s@$ this@53@00 G@54@00 V@55@00) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@54@00) i1@128@00))) j@129@00))
        j@129@00)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@123@00 s@$ this@53@00 G@54@00 V@55@00) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@54@00) i1@128@00))) j@129@00))
  )))
(assert (forall ((i1@128@00 Int) (j@129@00 Int)) (!
  (<= $Perm.No $k@130@00)
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@123@00 s@$ this@53@00 G@54@00 V@55@00) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@54@00) i1@128@00))) j@129@00))
  :qid |int-permAtLeastZero|)))
(assert (forall ((i1@128@00 Int) (j@129@00 Int)) (!
  (<= $k@130@00 $Perm.Write)
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@123@00 s@$ this@53@00 G@54@00 V@55@00) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@54@00) i1@128@00))) j@129@00))
  :qid |int-permAtMostOne|)))
(assert (forall ((i1@128@00 Int) (j@129@00 Int)) (!
  (implies
    (and
      (and
        (and (and (< j@129@00 V@55@00) (<= 0 j@129@00)) (< i1@128@00 V@55@00))
        (<= 0 i1@128@00))
      (< $Perm.No $k@130@00))
    (not
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@123@00 s@$ this@53@00 G@54@00 V@55@00) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@54@00) i1@128@00))) j@129@00)
        $Ref.null)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@123@00 s@$ this@53@00 G@54@00 V@55@00) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@54@00) i1@128@00))) j@129@00))
  :qid |int-permImpliesNonNull|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and
          (< (inv@132@00 s@$ this@53@00 G@54@00 V@55@00 r) V@55@00)
          (<= 0 (inv@132@00 s@$ this@53@00 G@54@00 V@55@00 r)))
        (< (inv@131@00 s@$ this@53@00 G@54@00 V@55@00 r) V@55@00))
      (<= 0 (inv@131@00 s@$ this@53@00 G@54@00 V@55@00 r)))
    ($FVF.loc_int ($FVF.lookup_int (sm@133@00 s@$ this@53@00 G@54@00 V@55@00) r) r))
  :pattern ((inv@131@00 s@$ this@53@00 G@54@00 V@55@00 r) (inv@132@00 s@$ this@53@00 G@54@00 V@55@00 r))
  )))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (< (inv@122@00 s@$ this@53@00 G@54@00 V@55@00 r) V@55@00)
        (<= 0 (inv@122@00 s@$ this@53@00 G@54@00 V@55@00 r)))
      (< $Perm.No $k@121@00))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@54@00) (inv@122@00 s@$ this@53@00 G@54@00 V@55@00 r))
      r))
  :pattern ((inv@122@00 s@$ this@53@00 G@54@00 V@55@00 r))
  :qid |option$array$-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and
        (< (inv@122@00 s@$ this@53@00 G@54@00 V@55@00 r) V@55@00)
        (<= 0 (inv@122@00 s@$ this@53@00 G@54@00 V@55@00 r)))
      (< $Perm.No $k@121@00)
      false)
    (=
      ($FVF.lookup_option$array$ (sm@123@00 s@$ this@53@00 G@54@00 V@55@00) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r)))
  :pattern (($FVF.lookup_option$array$ (sm@123@00 s@$ this@53@00 G@54@00 V@55@00) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r))
  :qid |qp.fvfValDef0|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r)
  :pattern (($FVF.lookup_option$array$ (sm@123@00 s@$ this@53@00 G@54@00 V@55@00) r))
  :qid |qp.fvfResTrgDef1|)))
(assert ($Perm.isReadVar $k@130@00 $Perm.Write))
(assert (forall ((i1@120@00 Int)) (!
  (implies
    (and (and (< i1@120@00 V@55@00) (<= 0 i1@120@00)) (< $Perm.No $k@121@00))
    (=
      (inv@122@00 s@$ this@53@00 G@54@00 V@55@00 (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@54@00) i1@120@00))
      i1@120@00))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@54@00) i1@120@00))
  )))
(assert (forall ((i1@120@00 Int)) (!
  (<= $Perm.No $k@121@00)
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@54@00) i1@120@00))
  :qid |option$array$-permAtLeastZero|)))
(assert (forall ((i1@120@00 Int)) (!
  (<= $k@121@00 $Perm.Write)
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@54@00) i1@120@00))
  :qid |option$array$-permAtMostOne|)))
(assert (forall ((i1@120@00 Int)) (!
  (implies
    (and (and (< i1@120@00 V@55@00) (<= 0 i1@120@00)) (< $Perm.No $k@121@00))
    (not
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@54@00) i1@120@00)
        $Ref.null)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@54@00) i1@120@00))
  :qid |option$array$-permImpliesNonNull|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (< (inv@122@00 s@$ this@53@00 G@54@00 V@55@00 r) V@55@00)
      (<= 0 (inv@122@00 s@$ this@53@00 G@54@00 V@55@00 r)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@123@00 s@$ this@53@00 G@54@00 V@55@00) r) r))
  :pattern ((inv@122@00 s@$ this@53@00 G@54@00 V@55@00 r))
  )))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$)))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$)))))
  $Snap.unit))
(assert (forall ((i1@124@00 Int)) (!
  (implies
    (and (< i1@124@00 V@55@00) (<= 0 i1@124@00))
    (and
      (< i1@124@00 V@55@00)
      (<= 0 i1@124@00)
      (< i1@124@00 (alen<Int> (opt_get1 $Snap.unit G@54@00)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@123@00 s@$ this@53@00 G@54@00 V@55@00) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@54@00) i1@124@00)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@54@00) i1@124@00))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@54@00) i1@124@00))
  :qid |prog.l<no position>-aux|)))
(assert (forall ((i1@124@00 Int)) (!
  (implies
    (and (< i1@124@00 V@55@00) (<= 0 i1@124@00))
    (not
      (=
        ($FVF.lookup_option$array$ (sm@123@00 s@$ this@53@00 G@54@00 V@55@00) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@54@00) i1@124@00))
        (as None<option<array>>  option<array>))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@54@00) i1@124@00))
  :qid |prog.l<no position>|)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$)))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$)))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$))))))
  $Snap.unit))
(assert (forall ((i1@125@00 Int)) (!
  (implies
    (and (< i1@125@00 V@55@00) (<= 0 i1@125@00))
    (and
      (< i1@125@00 V@55@00)
      (<= 0 i1@125@00)
      (< i1@125@00 (alen<Int> (opt_get1 $Snap.unit G@54@00)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@123@00 s@$ this@53@00 G@54@00 V@55@00) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@54@00) i1@125@00)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@54@00) i1@125@00))
      (not
        (=
          ($FVF.lookup_option$array$ (sm@123@00 s@$ this@53@00 G@54@00 V@55@00) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@54@00) i1@125@00))
          (as None<option<array>>  option<array>)))))
  :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@123@00 s@$ this@53@00 G@54@00 V@55@00) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@54@00) i1@125@00)))))
  :qid |prog.l<no position>-aux|)))
(assert (forall ((i1@125@00 Int)) (!
  (implies
    (and (< i1@125@00 V@55@00) (<= 0 i1@125@00))
    (=
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@123@00 s@$ this@53@00 G@54@00 V@55@00) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@54@00) i1@125@00))))
      V@55@00))
  :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@123@00 s@$ this@53@00 G@54@00 V@55@00) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@54@00) i1@125@00)))))
  :qid |prog.l<no position>|)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$)))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$)))))))
  $Snap.unit))
(assert (forall ((i1@126@00 Int)) (!
  (forall ((i2@127@00 Int)) (!
    (and
      (implies
        (<= 0 i1@126@00)
        (and
          (<= 0 i1@126@00)
          (implies
            (< i1@126@00 V@55@00)
            (and
              (< i1@126@00 V@55@00)
              (implies
                (<= 0 i2@127@00)
                (and
                  (<= 0 i2@127@00)
                  (implies
                    (< i2@127@00 V@55@00)
                    (and
                      (< i2@127@00 V@55@00)
                      (< i1@126@00 (alen<Int> (opt_get1 $Snap.unit G@54@00)))
                      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@123@00 s@$ this@53@00 G@54@00 V@55@00) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit G@54@00) i1@126@00)) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit G@54@00) i1@126@00))
                      (< i2@127@00 (alen<Int> (opt_get1 $Snap.unit G@54@00)))
                      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@123@00 s@$ this@53@00 G@54@00 V@55@00) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit G@54@00) i2@127@00)) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit G@54@00) i2@127@00))))))))))
      (implies
        (and
          (and
            (and
              (and
                (=
                  ($FVF.lookup_option$array$ (sm@123@00 s@$ this@53@00 G@54@00 V@55@00) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit G@54@00) i1@126@00))
                  ($FVF.lookup_option$array$ (sm@123@00 s@$ this@53@00 G@54@00 V@55@00) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit G@54@00) i2@127@00)))
                (< i2@127@00 V@55@00))
              (<= 0 i2@127@00))
            (< i1@126@00 V@55@00))
          (<= 0 i1@126@00))
        (and
          (=
            ($FVF.lookup_option$array$ (sm@123@00 s@$ this@53@00 G@54@00 V@55@00) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@54@00) i1@126@00))
            ($FVF.lookup_option$array$ (sm@123@00 s@$ this@53@00 G@54@00 V@55@00) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@54@00) i2@127@00)))
          (< i2@127@00 V@55@00)
          (<= 0 i2@127@00)
          (< i1@126@00 V@55@00)
          (<= 0 i1@126@00))))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@54@00) i2@127@00))
    :qid |prog.l<no position>-aux|))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@54@00) i1@126@00))
  :qid |prog.l<no position>-aux|)))
(assert (forall ((i1@126@00 Int)) (!
  (forall ((i2@127@00 Int)) (!
    (implies
      (and
        (and
          (and
            (and
              (=
                ($FVF.lookup_option$array$ (sm@123@00 s@$ this@53@00 G@54@00 V@55@00) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@54@00) i1@126@00))
                ($FVF.lookup_option$array$ (sm@123@00 s@$ this@53@00 G@54@00 V@55@00) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@54@00) i2@127@00)))
              (< i2@127@00 V@55@00))
            (<= 0 i2@127@00))
          (< i1@126@00 V@55@00))
        (<= 0 i1@126@00))
      (= i1@126@00 i2@127@00))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@54@00) i2@127@00))
    :qid |prog.l<no position>|))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@54@00) i1@126@00))
  :qid |prog.l<no position>|)))
(assert (forall ((i1@128@00 Int) (j@129@00 Int)) (!
  (and
    (< i1@128@00 (alen<Int> (opt_get1 $Snap.unit G@54@00)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@123@00 s@$ this@53@00 G@54@00 V@55@00) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@54@00) i1@128@00)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@54@00) i1@128@00))
    (not
      (=
        ($FVF.lookup_option$array$ (sm@123@00 s@$ this@53@00 G@54@00 V@55@00) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@54@00) i1@128@00))
        (as None<option<array>>  option<array>)))
    (<
      j@129@00
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@123@00 s@$ this@53@00 G@54@00 V@55@00) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@54@00) i1@128@00))))))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@123@00 s@$ this@53@00 G@54@00 V@55@00) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@54@00) i1@128@00))) j@129@00))
  :qid |int-aux|)))
(assert ($Perm.isReadVar $k@121@00 $Perm.Write))
(assert (= s@$ ($Snap.combine ($Snap.first s@$) ($Snap.second s@$))))
(assert (= ($Snap.first s@$) $Snap.unit))
(assert (not (= this@53@00 $Ref.null)))
(assert (=
  ($Snap.second s@$)
  ($Snap.combine
    ($Snap.first ($Snap.second s@$))
    ($Snap.second ($Snap.second s@$)))))
(assert (= ($Snap.first ($Snap.second s@$)) $Snap.unit))
(assert (not (= G@54@00 (as None<option<array>>  option<array>))))
(assert (=
  ($Snap.second ($Snap.second s@$))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second s@$)))
    ($Snap.second ($Snap.second ($Snap.second s@$))))))
(assert (= ($Snap.first ($Snap.second ($Snap.second s@$))) $Snap.unit))
(assert (= (alen<Int> (opt_get1 $Snap.unit G@54@00)) V@55@00))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second s@$)))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$)))))))
(assert (forall ((i1@120@00 Int)) (!
  (< i1@120@00 (alen<Int> (opt_get1 $Snap.unit G@54@00)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@54@00) i1@120@00))
  :qid |option$array$-aux|)))
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
; [eval] alen(opt_get1(G)) == V && (forall i1: Int :: { alen(opt_get1(aloc(opt_get1(G), i1).option$array$)) } 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(G), i1).option$array$)) == V)
; [eval] alen(opt_get1(G)) == V
; [eval] alen(opt_get1(G))
; [eval] opt_get1(G)
(push) ; 2
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 2
; Joined path conditions
(push) ; 2
; [then-branch: 42 | alen[Int](opt_get1(_, G@54@00)) == V@55@00 | live]
; [else-branch: 42 | alen[Int](opt_get1(_, G@54@00)) != V@55@00 | live]
(push) ; 3
; [then-branch: 42 | alen[Int](opt_get1(_, G@54@00)) == V@55@00]
; [eval] (forall i1: Int :: { alen(opt_get1(aloc(opt_get1(G), i1).option$array$)) } 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(G), i1).option$array$)) == V)
(declare-const i1@134@00 Int)
(push) ; 4
; [eval] 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(G), i1).option$array$)) == V
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 5
; [then-branch: 43 | 0 <= i1@134@00 | live]
; [else-branch: 43 | !(0 <= i1@134@00) | live]
(push) ; 6
; [then-branch: 43 | 0 <= i1@134@00]
(assert (<= 0 i1@134@00))
; [eval] i1 < V
(pop) ; 6
(push) ; 6
; [else-branch: 43 | !(0 <= i1@134@00)]
(assert (not (<= 0 i1@134@00)))
(pop) ; 6
(pop) ; 5
; Joined path conditions
; Joined path conditions
(push) ; 5
; [then-branch: 44 | i1@134@00 < V@55@00 && 0 <= i1@134@00 | live]
; [else-branch: 44 | !(i1@134@00 < V@55@00 && 0 <= i1@134@00) | live]
(push) ; 6
; [then-branch: 44 | i1@134@00 < V@55@00 && 0 <= i1@134@00]
(assert (and (< i1@134@00 V@55@00) (<= 0 i1@134@00)))
; [eval] alen(opt_get1(aloc(opt_get1(G), i1).option$array$)) == V
; [eval] alen(opt_get1(aloc(opt_get1(G), i1).option$array$))
; [eval] opt_get1(aloc(opt_get1(G), i1).option$array$)
; [eval] aloc(opt_get1(G), i1)
; [eval] opt_get1(G)
(push) ; 7
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 7
; Joined path conditions
(push) ; 7
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 8
(assert (not (< i1@134@00 (alen<Int> (opt_get1 $Snap.unit G@54@00)))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               823
;  :arith-add-rows          654
;  :arith-assert-diseq      97
;  :arith-assert-lower      321
;  :arith-assert-upper      193
;  :arith-bound-prop        46
;  :arith-conflicts         22
;  :arith-eq-adapter        164
;  :arith-fixed-eqs         131
;  :arith-offset-eqs        15
;  :arith-pivots            282
;  :conflicts               48
;  :datatype-accessor-ax    55
;  :datatype-constructor-ax 2
;  :datatype-occurs-check   25
;  :datatype-splits         2
;  :decisions               66
;  :del-clause              1152
;  :final-checks            32
;  :interface-eqs           8
;  :max-generation          5
;  :max-memory              4.51
;  :memory                  4.50
;  :mk-bool-var             2111
;  :mk-clause               1152
;  :num-allocs              172315
;  :num-checks              73
;  :propagations            436
;  :quant-instantiations    445
;  :rlimit-count            216269)
(assert (< i1@134@00 (alen<Int> (opt_get1 $Snap.unit G@54@00))))
(pop) ; 7
; Joined path conditions
(assert (< i1@134@00 (alen<Int> (opt_get1 $Snap.unit G@54@00))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@123@00 s@$ this@53@00 G@54@00 V@55@00) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@54@00) i1@134@00)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@54@00) i1@134@00)))
(push) ; 7
(assert (not (ite
  (and
    (<
      (inv@122@00 s@$ this@53@00 G@54@00 V@55@00 (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@54@00) i1@134@00))
      V@55@00)
    (<=
      0
      (inv@122@00 s@$ this@53@00 G@54@00 V@55@00 (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@54@00) i1@134@00))))
  (< $Perm.No $k@121@00)
  false)))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               828
;  :arith-add-rows          659
;  :arith-assert-diseq      97
;  :arith-assert-lower      322
;  :arith-assert-upper      195
;  :arith-bound-prop        47
;  :arith-conflicts         23
;  :arith-eq-adapter        165
;  :arith-fixed-eqs         132
;  :arith-offset-eqs        15
;  :arith-pivots            284
;  :conflicts               49
;  :datatype-accessor-ax    55
;  :datatype-constructor-ax 2
;  :datatype-occurs-check   25
;  :datatype-splits         2
;  :decisions               66
;  :del-clause              1152
;  :final-checks            32
;  :interface-eqs           8
;  :max-generation          5
;  :max-memory              4.51
;  :memory                  4.50
;  :mk-bool-var             2140
;  :mk-clause               1159
;  :num-allocs              172667
;  :num-checks              74
;  :propagations            436
;  :quant-instantiations    460
;  :rlimit-count            217325)
(push) ; 7
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 8
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (sm@123@00 s@$ this@53@00 G@54@00 V@55@00) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@54@00) i1@134@00))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               828
;  :arith-add-rows          659
;  :arith-assert-diseq      97
;  :arith-assert-lower      322
;  :arith-assert-upper      195
;  :arith-bound-prop        47
;  :arith-conflicts         23
;  :arith-eq-adapter        165
;  :arith-fixed-eqs         132
;  :arith-offset-eqs        15
;  :arith-pivots            284
;  :conflicts               50
;  :datatype-accessor-ax    55
;  :datatype-constructor-ax 2
;  :datatype-occurs-check   25
;  :datatype-splits         2
;  :decisions               66
;  :del-clause              1152
;  :final-checks            32
;  :interface-eqs           8
;  :max-generation          5
;  :max-memory              4.51
;  :memory                  4.50
;  :mk-bool-var             2140
;  :mk-clause               1159
;  :num-allocs              172758
;  :num-checks              75
;  :propagations            436
;  :quant-instantiations    460
;  :rlimit-count            217430)
(assert (not
  (=
    ($FVF.lookup_option$array$ (sm@123@00 s@$ this@53@00 G@54@00 V@55@00) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@54@00) i1@134@00))
    (as None<option<array>>  option<array>))))
(pop) ; 7
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (sm@123@00 s@$ this@53@00 G@54@00 V@55@00) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@54@00) i1@134@00))
    (as None<option<array>>  option<array>))))
(pop) ; 6
(push) ; 6
; [else-branch: 44 | !(i1@134@00 < V@55@00 && 0 <= i1@134@00)]
(assert (not (and (< i1@134@00 V@55@00) (<= 0 i1@134@00))))
(pop) ; 6
(pop) ; 5
; Joined path conditions
(assert (implies
  (and (< i1@134@00 V@55@00) (<= 0 i1@134@00))
  (and
    (< i1@134@00 V@55@00)
    (<= 0 i1@134@00)
    (< i1@134@00 (alen<Int> (opt_get1 $Snap.unit G@54@00)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@123@00 s@$ this@53@00 G@54@00 V@55@00) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@54@00) i1@134@00)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@54@00) i1@134@00))
    (not
      (=
        ($FVF.lookup_option$array$ (sm@123@00 s@$ this@53@00 G@54@00 V@55@00) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@54@00) i1@134@00))
        (as None<option<array>>  option<array>))))))
; Joined path conditions
(pop) ; 4
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@134@00 Int)) (!
  (implies
    (and (< i1@134@00 V@55@00) (<= 0 i1@134@00))
    (and
      (< i1@134@00 V@55@00)
      (<= 0 i1@134@00)
      (< i1@134@00 (alen<Int> (opt_get1 $Snap.unit G@54@00)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@123@00 s@$ this@53@00 G@54@00 V@55@00) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@54@00) i1@134@00)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@54@00) i1@134@00))
      (not
        (=
          ($FVF.lookup_option$array$ (sm@123@00 s@$ this@53@00 G@54@00 V@55@00) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@54@00) i1@134@00))
          (as None<option<array>>  option<array>)))))
  :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@123@00 s@$ this@53@00 G@54@00 V@55@00) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@54@00) i1@134@00)))))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 3
(push) ; 3
; [else-branch: 42 | alen[Int](opt_get1(_, G@54@00)) != V@55@00]
(assert (not (= (alen<Int> (opt_get1 $Snap.unit G@54@00)) V@55@00)))
(pop) ; 3
(pop) ; 2
; Joined path conditions
(assert (implies
  (= (alen<Int> (opt_get1 $Snap.unit G@54@00)) V@55@00)
  (forall ((i1@134@00 Int)) (!
    (implies
      (and (< i1@134@00 V@55@00) (<= 0 i1@134@00))
      (and
        (< i1@134@00 V@55@00)
        (<= 0 i1@134@00)
        (< i1@134@00 (alen<Int> (opt_get1 $Snap.unit G@54@00)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@123@00 s@$ this@53@00 G@54@00 V@55@00) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@54@00) i1@134@00)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@54@00) i1@134@00))
        (not
          (=
            ($FVF.lookup_option$array$ (sm@123@00 s@$ this@53@00 G@54@00 V@55@00) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@54@00) i1@134@00))
            (as None<option<array>>  option<array>)))))
    :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@123@00 s@$ this@53@00 G@54@00 V@55@00) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@54@00) i1@134@00)))))
    :qid |prog.l<no position>-aux|))))
; Joined path conditions
(assert (=
  result@56@00
  (and
    (forall ((i1@134@00 Int)) (!
      (implies
        (and (< i1@134@00 V@55@00) (<= 0 i1@134@00))
        (=
          (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@123@00 s@$ this@53@00 G@54@00 V@55@00) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@54@00) i1@134@00))))
          V@55@00))
      :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@123@00 s@$ this@53@00 G@54@00 V@55@00) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@54@00) i1@134@00)))))
      :qid |prog.l<no position>|))
    (= (alen<Int> (opt_get1 $Snap.unit G@54@00)) V@55@00))))
(pop) ; 1
(assert (forall ((s@$ $Snap) (this@53@00 $Ref) (G@54@00 option<array>) (V@55@00 Int)) (!
  (and
    (forall ((i1@120@00 Int)) (!
      (implies
        (and (and (< i1@120@00 V@55@00) (<= 0 i1@120@00)) (< $Perm.No $k@121@00))
        (=
          (inv@122@00 s@$ this@53@00 G@54@00 V@55@00 (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@54@00) i1@120@00))
          i1@120@00))
      :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@54@00) i1@120@00))
      ))
    (forall ((r $Ref)) (!
      (implies
        (and
          (and
            (< (inv@122@00 s@$ this@53@00 G@54@00 V@55@00 r) V@55@00)
            (<= 0 (inv@122@00 s@$ this@53@00 G@54@00 V@55@00 r)))
          (< $Perm.No $k@121@00))
        (=
          (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@54@00) (inv@122@00 s@$ this@53@00 G@54@00 V@55@00 r))
          r))
      :pattern ((inv@122@00 s@$ this@53@00 G@54@00 V@55@00 r))
      :qid |option$array$-fctOfInv|))
    (forall ((i1@128@00 Int) (j@129@00 Int)) (!
      (implies
        (and
          (and
            (and
              (and (< j@129@00 V@55@00) (<= 0 j@129@00))
              (< i1@128@00 V@55@00))
            (<= 0 i1@128@00))
          (< $Perm.No $k@130@00))
        (and
          (=
            (inv@131@00 s@$ this@53@00 G@54@00 V@55@00 (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@123@00 s@$ this@53@00 G@54@00 V@55@00) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@54@00) i1@128@00))) j@129@00))
            i1@128@00)
          (=
            (inv@132@00 s@$ this@53@00 G@54@00 V@55@00 (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@123@00 s@$ this@53@00 G@54@00 V@55@00) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@54@00) i1@128@00))) j@129@00))
            j@129@00)))
      :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@123@00 s@$ this@53@00 G@54@00 V@55@00) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@54@00) i1@128@00))) j@129@00))
      ))
    (forall ((r $Ref)) (!
      (implies
        (and
          (and
            (and
              (and
                (< (inv@132@00 s@$ this@53@00 G@54@00 V@55@00 r) V@55@00)
                (<= 0 (inv@132@00 s@$ this@53@00 G@54@00 V@55@00 r)))
              (< (inv@131@00 s@$ this@53@00 G@54@00 V@55@00 r) V@55@00))
            (<= 0 (inv@131@00 s@$ this@53@00 G@54@00 V@55@00 r)))
          (< $Perm.No $k@130@00))
        (=
          (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@123@00 s@$ this@53@00 G@54@00 V@55@00) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@54@00) (inv@131@00 s@$ this@53@00 G@54@00 V@55@00 r)))) (inv@132@00 s@$ this@53@00 G@54@00 V@55@00 r))
          r))
      :pattern ((inv@131@00 s@$ this@53@00 G@54@00 V@55@00 r))
      :pattern ((inv@132@00 s@$ this@53@00 G@54@00 V@55@00 r))
      :qid |int-fctOfInv|))
    (forall ((r $Ref)) (!
      (implies
        (ite
          (and
            (< (inv@122@00 s@$ this@53@00 G@54@00 V@55@00 r) V@55@00)
            (<= 0 (inv@122@00 s@$ this@53@00 G@54@00 V@55@00 r)))
          (< $Perm.No $k@121@00)
          false)
        (=
          ($FVF.lookup_option$array$ (sm@123@00 s@$ this@53@00 G@54@00 V@55@00) r)
          ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r)))
      :pattern (($FVF.lookup_option$array$ (sm@123@00 s@$ this@53@00 G@54@00 V@55@00) r))
      :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r))
      :qid |qp.fvfValDef0|))
    (forall ((r $Ref)) (!
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r)
      :pattern (($FVF.lookup_option$array$ (sm@123@00 s@$ this@53@00 G@54@00 V@55@00) r))
      :qid |qp.fvfResTrgDef1|))
    ($Perm.isReadVar $k@121@00 $Perm.Write)
    ($Perm.isReadVar $k@130@00 $Perm.Write)
    (implies
      (and
        (not (= this@53@00 $Ref.null))
        (not (= G@54@00 (as None<option<array>>  option<array>)))
        (= (alen<Int> (opt_get1 $Snap.unit G@54@00)) V@55@00)
        (forall ((i1 Int)) (!
          (implies
            (and (<= 0 i1) (< i1 V@55@00))
            (not
              (=
                ($FVF.lookup_option$array$ (sm@123@00 s@$ this@53@00 G@54@00 V@55@00) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@54@00) i1))
                (as None<option<array>>  option<array>))))
          :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@54@00) i1))
          ))
        (forall ((i1 Int)) (!
          (implies
            (and (<= 0 i1) (< i1 V@55@00))
            (=
              (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@123@00 s@$ this@53@00 G@54@00 V@55@00) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit G@54@00) i1))))
              V@55@00))
          :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@123@00 s@$ this@53@00 G@54@00 V@55@00) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@54@00) i1)))))
          ))
        (forall ((i1 Int)) (!
          (forall ((i2 Int)) (!
            (implies
              (and
                (and
                  (and (and (<= 0 i1) (< i1 V@55@00)) (<= 0 i2))
                  (< i2 V@55@00))
                (=
                  ($FVF.lookup_option$array$ (sm@123@00 s@$ this@53@00 G@54@00 V@55@00) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit G@54@00) i1))
                  ($FVF.lookup_option$array$ (sm@123@00 s@$ this@53@00 G@54@00 V@55@00) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit G@54@00) i2))))
              (= i1 i2))
            :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@54@00) i2))
            ))
          :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@54@00) i1))
          )))
      (=
        (SquareIntMatrix1 s@$ this@53@00 G@54@00 V@55@00)
        (and
          (= (alen<Int> (opt_get1 $Snap.unit G@54@00)) V@55@00)
          (forall ((i1 Int)) (!
            (implies
              (and (<= 0 i1) (< i1 V@55@00))
              (=
                (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@123@00 s@$ this@53@00 G@54@00 V@55@00) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@54@00) i1))))
                V@55@00))
            :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@123@00 s@$ this@53@00 G@54@00 V@55@00) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@54@00) i1)))))
            ))))))
  :pattern ((SquareIntMatrix1 s@$ this@53@00 G@54@00 V@55@00))
  )))
; ---------- FUNCTION any_as----------
(declare-fun t@57@00 () any)
(declare-fun result@58@00 () any)
; ----- Well-definedness of specifications -----
(push) ; 1
(pop) ; 1
(assert (forall ((s@$ $Snap) (t@57@00 any)) (!
  (= (any_as%limited s@$ t@57@00) (any_as s@$ t@57@00))
  :pattern ((any_as s@$ t@57@00))
  )))
(assert (forall ((s@$ $Snap) (t@57@00 any)) (!
  (any_as%stateless t@57@00)
  :pattern ((any_as%limited s@$ t@57@00))
  )))
; ---------- FUNCTION unknown----------
(declare-fun a2@59@00 () option<array>)
(declare-fun from@60@00 () Int)
(declare-fun to@61@00 () Int)
(declare-fun result@62@00 () Seq<Int>)
; ----- Well-definedness of specifications -----
(push) ; 1
(assert (= s@$ ($Snap.combine ($Snap.first s@$) ($Snap.second s@$))))
(assert (= ($Snap.first s@$) $Snap.unit))
; [eval] a2 != (None(): option[array])
; [eval] (None(): option[array])
(assert (not (= a2@59@00 (as None<option<array>>  option<array>))))
(assert (=
  ($Snap.second s@$)
  ($Snap.combine
    ($Snap.first ($Snap.second s@$))
    ($Snap.second ($Snap.second s@$)))))
(assert (= ($Snap.first ($Snap.second s@$)) $Snap.unit))
; [eval] 0 <= from
(assert (<= 0 from@60@00))
(assert (=
  ($Snap.second ($Snap.second s@$))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second s@$)))
    ($Snap.second ($Snap.second ($Snap.second s@$))))))
(assert (= ($Snap.first ($Snap.second ($Snap.second s@$))) $Snap.unit))
; [eval] from <= to
(assert (<= from@60@00 to@61@00))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second s@$)))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$)))))))
(assert (= ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$)))) $Snap.unit))
; [eval] to <= alen(opt_get1(a2))
; [eval] alen(opt_get1(a2))
; [eval] opt_get1(a2)
(push) ; 2
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 2
; Joined path conditions
(assert (<= to@61@00 (alen<Int> (opt_get1 $Snap.unit a2@59@00))))
(declare-const i1@135@00 Int)
(push) ; 2
; [eval] from <= i1 && i1 < to
; [eval] from <= i1
(push) ; 3
; [then-branch: 45 | from@60@00 <= i1@135@00 | live]
; [else-branch: 45 | !(from@60@00 <= i1@135@00) | live]
(push) ; 4
; [then-branch: 45 | from@60@00 <= i1@135@00]
(assert (<= from@60@00 i1@135@00))
; [eval] i1 < to
(pop) ; 4
(push) ; 4
; [else-branch: 45 | !(from@60@00 <= i1@135@00)]
(assert (not (<= from@60@00 i1@135@00)))
(pop) ; 4
(pop) ; 3
; Joined path conditions
; Joined path conditions
(assert (and (< i1@135@00 to@61@00) (<= from@60@00 i1@135@00)))
; [eval] aloc(opt_get1(a2), i1)
; [eval] opt_get1(a2)
(push) ; 3
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 3
; Joined path conditions
(push) ; 3
; [eval] 0 <= i1
(push) ; 4
(assert (not (<= 0 i1@135@00)))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               855
;  :arith-add-rows          674
;  :arith-assert-diseq      97
;  :arith-assert-lower      326
;  :arith-assert-upper      198
;  :arith-bound-prop        47
;  :arith-conflicts         24
;  :arith-eq-adapter        165
;  :arith-fixed-eqs         132
;  :arith-offset-eqs        15
;  :arith-pivots            292
;  :conflicts               51
;  :datatype-accessor-ax    60
;  :datatype-constructor-ax 2
;  :datatype-occurs-check   25
;  :datatype-splits         2
;  :decisions               66
;  :del-clause              1159
;  :final-checks            32
;  :interface-eqs           8
;  :max-generation          5
;  :max-memory              4.51
;  :memory                  4.49
;  :mk-bool-var             2163
;  :mk-clause               1159
;  :num-allocs              175409
;  :num-checks              76
;  :propagations            436
;  :quant-instantiations    465
;  :rlimit-count            223282)
(assert (<= 0 i1@135@00))
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 4
(assert (not (< i1@135@00 (alen<Int> (opt_get1 $Snap.unit a2@59@00)))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               855
;  :arith-add-rows          675
;  :arith-assert-diseq      97
;  :arith-assert-lower      328
;  :arith-assert-upper      198
;  :arith-bound-prop        47
;  :arith-conflicts         25
;  :arith-eq-adapter        165
;  :arith-fixed-eqs         132
;  :arith-offset-eqs        15
;  :arith-pivots            292
;  :conflicts               52
;  :datatype-accessor-ax    60
;  :datatype-constructor-ax 2
;  :datatype-occurs-check   25
;  :datatype-splits         2
;  :decisions               66
;  :del-clause              1159
;  :final-checks            32
;  :interface-eqs           8
;  :max-generation          5
;  :max-memory              4.51
;  :memory                  4.49
;  :mk-bool-var             2165
;  :mk-clause               1159
;  :num-allocs              175560
;  :num-checks              77
;  :propagations            436
;  :quant-instantiations    465
;  :rlimit-count            223418)
(assert (< i1@135@00 (alen<Int> (opt_get1 $Snap.unit a2@59@00))))
(pop) ; 3
; Joined path conditions
(assert (and (<= 0 i1@135@00) (< i1@135@00 (alen<Int> (opt_get1 $Snap.unit a2@59@00)))))
(declare-const $k@136@00 $Perm)
(assert ($Perm.isReadVar $k@136@00 $Perm.Write))
(declare-fun sm@137@00 ($Snap option<array> Int Int) $FVF<Int>)
; Definitional axioms for snapshot map values
; [eval] aloc(opt_get1(a2), i1)
; [eval] opt_get1(a2)
(push) ; 3
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 3
; Joined path conditions
(push) ; 3
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(pop) ; 3
; Joined path conditions
(pop) ; 2
(declare-fun inv@138@00 ($Snap option<array> Int Int $Ref) Int)
; Nested auxiliary terms: globals
(assert ($Perm.isReadVar $k@136@00 $Perm.Write))
; Nested auxiliary terms: non-globals
(assert (forall ((i1@135@00 Int)) (!
  (and (<= 0 i1@135@00) (< i1@135@00 (alen<Int> (opt_get1 $Snap.unit a2@59@00))))
  :pattern (($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$))))) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit a2@59@00) i1@135@00)) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit a2@59@00) i1@135@00)))
  :qid |int-aux|)))
(push) ; 2
(assert (not (forall ((i1@135@00 Int)) (!
  (implies
    (and (< i1@135@00 to@61@00) (<= from@60@00 i1@135@00))
    (or (= $k@136@00 $Perm.No) (< $Perm.No $k@136@00)))
  
  ))))
(check-sat)
; unsat
(pop) ; 2
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               857
;  :arith-add-rows          680
;  :arith-assert-diseq      99
;  :arith-assert-lower      333
;  :arith-assert-upper      201
;  :arith-bound-prop        47
;  :arith-conflicts         25
;  :arith-eq-adapter        167
;  :arith-fixed-eqs         132
;  :arith-offset-eqs        15
;  :arith-pivots            294
;  :conflicts               53
;  :datatype-accessor-ax    61
;  :datatype-constructor-ax 2
;  :datatype-occurs-check   25
;  :datatype-splits         2
;  :decisions               66
;  :del-clause              1161
;  :final-checks            32
;  :interface-eqs           8
;  :max-generation          5
;  :max-memory              4.51
;  :memory                  4.49
;  :mk-bool-var             2178
;  :mk-clause               1163
;  :num-allocs              176215
;  :num-checks              78
;  :propagations            438
;  :quant-instantiations    465
;  :rlimit-count            224508)
; Check receiver injectivity
(push) ; 2
(assert (not (forall ((i11@135@00 Int) (i12@135@00 Int)) (!
  (implies
    (and
      (and
        (and (< i11@135@00 to@61@00) (<= from@60@00 i11@135@00))
        (< $Perm.No $k@136@00))
      (and
        (and (< i12@135@00 to@61@00) (<= from@60@00 i12@135@00))
        (< $Perm.No $k@136@00))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit a2@59@00) i11@135@00)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit a2@59@00) i12@135@00)))
    (= i11@135@00 i12@135@00))
  
  :qid |int-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 2
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               881
;  :arith-add-rows          725
;  :arith-assert-diseq      103
;  :arith-assert-lower      338
;  :arith-assert-upper      207
;  :arith-bound-prop        51
;  :arith-conflicts         27
;  :arith-eq-adapter        168
;  :arith-fixed-eqs         132
;  :arith-offset-eqs        15
;  :arith-pivots            306
;  :conflicts               56
;  :datatype-accessor-ax    61
;  :datatype-constructor-ax 2
;  :datatype-occurs-check   25
;  :datatype-splits         2
;  :decisions               68
;  :del-clause              1179
;  :final-checks            32
;  :interface-eqs           8
;  :max-generation          5
;  :max-memory              4.51
;  :memory                  4.50
;  :mk-bool-var             2203
;  :mk-clause               1181
;  :num-allocs              176615
;  :num-checks              79
;  :propagations            463
;  :quant-instantiations    473
;  :rlimit-count            226015)
; Definitional axioms for inverse functions
(assert (forall ((i1@135@00 Int)) (!
  (implies
    (and
      (and (< i1@135@00 to@61@00) (<= from@60@00 i1@135@00))
      (< $Perm.No $k@136@00))
    (=
      (inv@138@00 s@$ a2@59@00 from@60@00 to@61@00 (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit a2@59@00) i1@135@00))
      i1@135@00))
  :pattern (($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$))))) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit a2@59@00) i1@135@00)) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit a2@59@00) i1@135@00)))
  )))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (< (inv@138@00 s@$ a2@59@00 from@60@00 to@61@00 r) to@61@00)
        (<= from@60@00 (inv@138@00 s@$ a2@59@00 from@60@00 to@61@00 r)))
      (< $Perm.No $k@136@00))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit a2@59@00) (inv@138@00 s@$ a2@59@00 from@60@00 to@61@00 r))
      r))
  :pattern ((inv@138@00 s@$ a2@59@00 from@60@00 to@61@00 r))
  :qid |int-fctOfInv|)))
; Permissions are non-negative
(assert (forall ((i1@135@00 Int)) (!
  (<= $Perm.No $k@136@00)
  :pattern (($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$))))) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit a2@59@00) i1@135@00)) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit a2@59@00) i1@135@00)))
  :qid |int-permAtLeastZero|)))
; Field permissions are at most one
(assert (forall ((i1@135@00 Int)) (!
  (<= $k@136@00 $Perm.Write)
  :pattern (($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$))))) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit a2@59@00) i1@135@00)) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit a2@59@00) i1@135@00)))
  :qid |int-permAtMostOne|)))
; Permission implies non-null receiver
(assert (forall ((i1@135@00 Int)) (!
  (implies
    (and
      (and (< i1@135@00 to@61@00) (<= from@60@00 i1@135@00))
      (< $Perm.No $k@136@00))
    (not
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit a2@59@00) i1@135@00)
        $Ref.null)))
  :pattern (($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$))))) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit a2@59@00) i1@135@00)) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit a2@59@00) i1@135@00)))
  :qid |int-permImpliesNonNull|)))
(declare-fun sm@139@00 ($Snap option<array> Int Int) $FVF<Int>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and
        (< (inv@138@00 s@$ a2@59@00 from@60@00 to@61@00 r) to@61@00)
        (<= from@60@00 (inv@138@00 s@$ a2@59@00 from@60@00 to@61@00 r)))
      (< $Perm.No $k@136@00)
      false)
    (=
      ($FVF.lookup_int (sm@139@00 s@$ a2@59@00 from@60@00 to@61@00) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$))))) r)))
  :pattern (($FVF.lookup_int (sm@139@00 s@$ a2@59@00 from@60@00 to@61@00) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$))))) r))
  :qid |qp.fvfValDef5|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r)
  :pattern (($FVF.lookup_int (sm@139@00 s@$ a2@59@00 from@60@00 to@61@00) r))
  :qid |qp.fvfResTrgDef6|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (< (inv@138@00 s@$ a2@59@00 from@60@00 to@61@00 r) to@61@00)
      (<= from@60@00 (inv@138@00 s@$ a2@59@00 from@60@00 to@61@00 r)))
    ($FVF.loc_int ($FVF.lookup_int (sm@139@00 s@$ a2@59@00 from@60@00 to@61@00) r) r))
  :pattern ((inv@138@00 s@$ a2@59@00 from@60@00 to@61@00 r))
  )))
(declare-const $t@140@00 $Snap)
(assert (= $t@140@00 ($Snap.combine ($Snap.first $t@140@00) ($Snap.second $t@140@00))))
(assert (= ($Snap.first $t@140@00) $Snap.unit))
; [eval] |result| == to - from
; [eval] |result|
; [eval] to - from
(assert (= (Seq_length result@62@00) (- to@61@00 from@60@00)))
(assert (=
  ($Snap.second $t@140@00)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@140@00))
    ($Snap.second ($Snap.second $t@140@00)))))
(assert (= ($Snap.first ($Snap.second $t@140@00)) $Snap.unit))
; [eval] (forall i1: Int :: { result[i1] } 0 <= i1 && i1 < to - from ==> result[i1] == aloc(opt_get1(a2), i1 + from).int)
(declare-const i1@141@00 Int)
(push) ; 2
; [eval] 0 <= i1 && i1 < to - from ==> result[i1] == aloc(opt_get1(a2), i1 + from).int
; [eval] 0 <= i1 && i1 < to - from
; [eval] 0 <= i1
(push) ; 3
; [then-branch: 46 | 0 <= i1@141@00 | live]
; [else-branch: 46 | !(0 <= i1@141@00) | live]
(push) ; 4
; [then-branch: 46 | 0 <= i1@141@00]
(assert (<= 0 i1@141@00))
; [eval] i1 < to - from
; [eval] to - from
(pop) ; 4
(push) ; 4
; [else-branch: 46 | !(0 <= i1@141@00)]
(assert (not (<= 0 i1@141@00)))
(pop) ; 4
(pop) ; 3
; Joined path conditions
; Joined path conditions
(push) ; 3
; [then-branch: 47 | i1@141@00 < to@61@00 - from@60@00 && 0 <= i1@141@00 | live]
; [else-branch: 47 | !(i1@141@00 < to@61@00 - from@60@00 && 0 <= i1@141@00) | live]
(push) ; 4
; [then-branch: 47 | i1@141@00 < to@61@00 - from@60@00 && 0 <= i1@141@00]
(assert (and (< i1@141@00 (- to@61@00 from@60@00)) (<= 0 i1@141@00)))
; [eval] result[i1] == aloc(opt_get1(a2), i1 + from).int
; [eval] result[i1]
(push) ; 5
(assert (not (>= i1@141@00 0)))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               895
;  :arith-add-rows          727
;  :arith-assert-diseq      103
;  :arith-assert-lower      342
;  :arith-assert-upper      209
;  :arith-bound-prop        51
;  :arith-conflicts         27
;  :arith-eq-adapter        170
;  :arith-fixed-eqs         132
;  :arith-offset-eqs        16
;  :arith-pivots            307
;  :conflicts               56
;  :datatype-accessor-ax    63
;  :datatype-constructor-ax 2
;  :datatype-occurs-check   25
;  :datatype-splits         2
;  :decisions               68
;  :del-clause              1179
;  :final-checks            32
;  :interface-eqs           8
;  :max-generation          5
;  :max-memory              4.51
;  :memory                  4.50
;  :mk-bool-var             2223
;  :mk-clause               1187
;  :num-allocs              177968
;  :num-checks              80
;  :propagations            465
;  :quant-instantiations    475
;  :rlimit-count            229065)
(push) ; 5
(assert (not (< i1@141@00 (Seq_length result@62@00))))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               895
;  :arith-add-rows          730
;  :arith-assert-diseq      103
;  :arith-assert-lower      342
;  :arith-assert-upper      210
;  :arith-bound-prop        51
;  :arith-conflicts         28
;  :arith-eq-adapter        170
;  :arith-fixed-eqs         132
;  :arith-offset-eqs        16
;  :arith-pivots            309
;  :conflicts               57
;  :datatype-accessor-ax    63
;  :datatype-constructor-ax 2
;  :datatype-occurs-check   25
;  :datatype-splits         2
;  :decisions               68
;  :del-clause              1179
;  :final-checks            32
;  :interface-eqs           8
;  :max-generation          5
;  :max-memory              4.51
;  :memory                  4.50
;  :mk-bool-var             2224
;  :mk-clause               1187
;  :num-allocs              178047
;  :num-checks              81
;  :propagations            465
;  :quant-instantiations    475
;  :rlimit-count            229194)
; [eval] aloc(opt_get1(a2), i1 + from)
; [eval] opt_get1(a2)
(push) ; 5
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 5
; Joined path conditions
; [eval] i1 + from
(push) ; 5
; [eval] 0 <= i1
(push) ; 6
(assert (not (<= 0 (+ i1@141@00 from@60@00))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               895
;  :arith-add-rows          734
;  :arith-assert-diseq      103
;  :arith-assert-lower      342
;  :arith-assert-upper      211
;  :arith-bound-prop        51
;  :arith-conflicts         29
;  :arith-eq-adapter        170
;  :arith-fixed-eqs         132
;  :arith-offset-eqs        16
;  :arith-pivots            311
;  :conflicts               58
;  :datatype-accessor-ax    63
;  :datatype-constructor-ax 2
;  :datatype-occurs-check   25
;  :datatype-splits         2
;  :decisions               68
;  :del-clause              1179
;  :final-checks            32
;  :interface-eqs           8
;  :max-generation          5
;  :max-memory              4.51
;  :memory                  4.50
;  :mk-bool-var             2225
;  :mk-clause               1187
;  :num-allocs              178134
;  :num-checks              82
;  :propagations            465
;  :quant-instantiations    475
;  :rlimit-count            229351)
(assert (<= 0 (+ i1@141@00 from@60@00)))
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 6
(assert (not (< (+ i1@141@00 from@60@00) (alen<Int> (opt_get1 $Snap.unit a2@59@00)))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               895
;  :arith-add-rows          739
;  :arith-assert-diseq      103
;  :arith-assert-lower      344
;  :arith-assert-upper      211
;  :arith-bound-prop        51
;  :arith-conflicts         30
;  :arith-eq-adapter        170
;  :arith-fixed-eqs         132
;  :arith-offset-eqs        16
;  :arith-pivots            313
;  :conflicts               59
;  :datatype-accessor-ax    63
;  :datatype-constructor-ax 2
;  :datatype-occurs-check   25
;  :datatype-splits         2
;  :decisions               68
;  :del-clause              1179
;  :final-checks            32
;  :interface-eqs           8
;  :max-generation          5
;  :max-memory              4.51
;  :memory                  4.50
;  :mk-bool-var             2227
;  :mk-clause               1187
;  :num-allocs              178301
;  :num-checks              83
;  :propagations            465
;  :quant-instantiations    475
;  :rlimit-count            229578)
(assert (< (+ i1@141@00 from@60@00) (alen<Int> (opt_get1 $Snap.unit a2@59@00))))
(pop) ; 5
; Joined path conditions
(assert (and
  (<= 0 (+ i1@141@00 from@60@00))
  (< (+ i1@141@00 from@60@00) (alen<Int> (opt_get1 $Snap.unit a2@59@00)))))
(assert ($FVF.loc_int ($FVF.lookup_int (sm@139@00 s@$ a2@59@00 from@60@00 to@61@00) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit a2@59@00) (+ i1@141@00 from@60@00))) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit a2@59@00) (+ i1@141@00 from@60@00))))
(push) ; 5
(assert (not (ite
  (and
    (<
      (inv@138@00 s@$ a2@59@00 from@60@00 to@61@00 (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit a2@59@00) (+ i1@141@00 from@60@00)))
      to@61@00)
    (<=
      from@60@00
      (inv@138@00 s@$ a2@59@00 from@60@00 to@61@00 (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit a2@59@00) (+ i1@141@00 from@60@00)))))
  (< $Perm.No $k@136@00)
  false)))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               907
;  :arith-add-rows          752
;  :arith-assert-diseq      103
;  :arith-assert-lower      349
;  :arith-assert-upper      217
;  :arith-bound-prop        52
;  :arith-conflicts         31
;  :arith-eq-adapter        174
;  :arith-fixed-eqs         133
;  :arith-offset-eqs        16
;  :arith-pivots            317
;  :conflicts               60
;  :datatype-accessor-ax    63
;  :datatype-constructor-ax 2
;  :datatype-occurs-check   25
;  :datatype-splits         2
;  :decisions               68
;  :del-clause              1179
;  :final-checks            32
;  :interface-eqs           8
;  :max-generation          5
;  :max-memory              4.51
;  :memory                  4.51
;  :mk-bool-var             2257
;  :mk-clause               1205
;  :num-allocs              178730
;  :num-checks              84
;  :propagations            475
;  :quant-instantiations    487
;  :rlimit-count            230655)
(pop) ; 4
(push) ; 4
; [else-branch: 47 | !(i1@141@00 < to@61@00 - from@60@00 && 0 <= i1@141@00)]
(assert (not (and (< i1@141@00 (- to@61@00 from@60@00)) (<= 0 i1@141@00))))
(pop) ; 4
(pop) ; 3
; Joined path conditions
(assert (implies
  (and (< i1@141@00 (- to@61@00 from@60@00)) (<= 0 i1@141@00))
  (and
    (< i1@141@00 (- to@61@00 from@60@00))
    (<= 0 i1@141@00)
    (<= 0 (+ i1@141@00 from@60@00))
    (< (+ i1@141@00 from@60@00) (alen<Int> (opt_get1 $Snap.unit a2@59@00)))
    ($FVF.loc_int ($FVF.lookup_int (sm@139@00 s@$ a2@59@00 from@60@00 to@61@00) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit a2@59@00) (+ i1@141@00 from@60@00))) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit a2@59@00) (+ i1@141@00 from@60@00))))))
; Joined path conditions
(pop) ; 2
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@141@00 Int)) (!
  (implies
    (and (< i1@141@00 (- to@61@00 from@60@00)) (<= 0 i1@141@00))
    (and
      (< i1@141@00 (- to@61@00 from@60@00))
      (<= 0 i1@141@00)
      (<= 0 (+ i1@141@00 from@60@00))
      (< (+ i1@141@00 from@60@00) (alen<Int> (opt_get1 $Snap.unit a2@59@00)))
      ($FVF.loc_int ($FVF.lookup_int (sm@139@00 s@$ a2@59@00 from@60@00 to@61@00) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit a2@59@00) (+ i1@141@00 from@60@00))) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit a2@59@00) (+ i1@141@00 from@60@00)))))
  :pattern ((Seq_index result@62@00 i1@141@00))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(assert (forall ((i1@141@00 Int)) (!
  (implies
    (and (< i1@141@00 (- to@61@00 from@60@00)) (<= 0 i1@141@00))
    (=
      (Seq_index result@62@00 i1@141@00)
      ($FVF.lookup_int (sm@139@00 s@$ a2@59@00 from@60@00 to@61@00) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit a2@59@00) (+ i1@141@00 from@60@00)))))
  :pattern ((Seq_index result@62@00 i1@141@00))
  :qid |prog.l<no position>|)))
(assert (= ($Snap.second ($Snap.second $t@140@00)) $Snap.unit))
; [eval] (forall i1: Int :: { aloc(opt_get1(a2), i1).int } from <= i1 && i1 < to ==> aloc(opt_get1(a2), i1).int == result[i1 - from])
(declare-const i1@142@00 Int)
(push) ; 2
; [eval] from <= i1 && i1 < to ==> aloc(opt_get1(a2), i1).int == result[i1 - from]
; [eval] from <= i1 && i1 < to
; [eval] from <= i1
(push) ; 3
; [then-branch: 48 | from@60@00 <= i1@142@00 | live]
; [else-branch: 48 | !(from@60@00 <= i1@142@00) | live]
(push) ; 4
; [then-branch: 48 | from@60@00 <= i1@142@00]
(assert (<= from@60@00 i1@142@00))
; [eval] i1 < to
(pop) ; 4
(push) ; 4
; [else-branch: 48 | !(from@60@00 <= i1@142@00)]
(assert (not (<= from@60@00 i1@142@00)))
(pop) ; 4
(pop) ; 3
; Joined path conditions
; Joined path conditions
(push) ; 3
; [then-branch: 49 | i1@142@00 < to@61@00 && from@60@00 <= i1@142@00 | live]
; [else-branch: 49 | !(i1@142@00 < to@61@00 && from@60@00 <= i1@142@00) | live]
(push) ; 4
; [then-branch: 49 | i1@142@00 < to@61@00 && from@60@00 <= i1@142@00]
(assert (and (< i1@142@00 to@61@00) (<= from@60@00 i1@142@00)))
; [eval] aloc(opt_get1(a2), i1).int == result[i1 - from]
; [eval] aloc(opt_get1(a2), i1)
; [eval] opt_get1(a2)
(push) ; 5
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 5
; Joined path conditions
(push) ; 5
; [eval] 0 <= i1
(push) ; 6
(assert (not (<= 0 i1@142@00)))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               909
;  :arith-add-rows          761
;  :arith-assert-diseq      103
;  :arith-assert-lower      350
;  :arith-assert-upper      219
;  :arith-bound-prop        52
;  :arith-conflicts         32
;  :arith-eq-adapter        174
;  :arith-fixed-eqs         133
;  :arith-offset-eqs        16
;  :arith-pivots            323
;  :conflicts               61
;  :datatype-accessor-ax    63
;  :datatype-constructor-ax 2
;  :datatype-occurs-check   25
;  :datatype-splits         2
;  :decisions               68
;  :del-clause              1197
;  :final-checks            32
;  :interface-eqs           8
;  :max-generation          5
;  :max-memory              4.51
;  :memory                  4.50
;  :mk-bool-var             2263
;  :mk-clause               1205
;  :num-allocs              179331
;  :num-checks              85
;  :propagations            475
;  :quant-instantiations    487
;  :rlimit-count            231976)
(assert (<= 0 i1@142@00))
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 6
(assert (not (< i1@142@00 (alen<Int> (opt_get1 $Snap.unit a2@59@00)))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               909
;  :arith-add-rows          770
;  :arith-assert-diseq      103
;  :arith-assert-lower      351
;  :arith-assert-upper      220
;  :arith-bound-prop        52
;  :arith-conflicts         33
;  :arith-eq-adapter        174
;  :arith-fixed-eqs         133
;  :arith-offset-eqs        16
;  :arith-pivots            325
;  :conflicts               62
;  :datatype-accessor-ax    63
;  :datatype-constructor-ax 2
;  :datatype-occurs-check   25
;  :datatype-splits         2
;  :decisions               68
;  :del-clause              1197
;  :final-checks            32
;  :interface-eqs           8
;  :max-generation          5
;  :max-memory              4.51
;  :memory                  4.50
;  :mk-bool-var             2265
;  :mk-clause               1205
;  :num-allocs              179480
;  :num-checks              86
;  :propagations            475
;  :quant-instantiations    487
;  :rlimit-count            232247)
(assert (< i1@142@00 (alen<Int> (opt_get1 $Snap.unit a2@59@00))))
(pop) ; 5
; Joined path conditions
(assert (and (<= 0 i1@142@00) (< i1@142@00 (alen<Int> (opt_get1 $Snap.unit a2@59@00)))))
(assert ($FVF.loc_int ($FVF.lookup_int (sm@139@00 s@$ a2@59@00 from@60@00 to@61@00) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit a2@59@00) i1@142@00)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit a2@59@00) i1@142@00)))
(push) ; 5
(assert (not (ite
  (and
    (<
      (inv@138@00 s@$ a2@59@00 from@60@00 to@61@00 (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit a2@59@00) i1@142@00))
      to@61@00)
    (<=
      from@60@00
      (inv@138@00 s@$ a2@59@00 from@60@00 to@61@00 (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit a2@59@00) i1@142@00))))
  (< $Perm.No $k@136@00)
  false)))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               922
;  :arith-add-rows          780
;  :arith-assert-diseq      103
;  :arith-assert-lower      354
;  :arith-assert-upper      222
;  :arith-bound-prop        53
;  :arith-conflicts         34
;  :arith-eq-adapter        175
;  :arith-fixed-eqs         134
;  :arith-offset-eqs        17
;  :arith-pivots            327
;  :conflicts               63
;  :datatype-accessor-ax    63
;  :datatype-constructor-ax 2
;  :datatype-occurs-check   25
;  :datatype-splits         2
;  :decisions               68
;  :del-clause              1197
;  :final-checks            32
;  :interface-eqs           8
;  :max-generation          5
;  :max-memory              4.52
;  :memory                  4.51
;  :mk-bool-var             2287
;  :mk-clause               1216
;  :num-allocs              179776
;  :num-checks              87
;  :propagations            481
;  :quant-instantiations    498
;  :rlimit-count            233167)
; [eval] result[i1 - from]
; [eval] i1 - from
(push) ; 5
(assert (not (>= (- i1@142@00 from@60@00) 0)))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               922
;  :arith-add-rows          780
;  :arith-assert-diseq      103
;  :arith-assert-lower      354
;  :arith-assert-upper      222
;  :arith-bound-prop        53
;  :arith-conflicts         34
;  :arith-eq-adapter        175
;  :arith-fixed-eqs         134
;  :arith-offset-eqs        17
;  :arith-pivots            327
;  :conflicts               63
;  :datatype-accessor-ax    63
;  :datatype-constructor-ax 2
;  :datatype-occurs-check   25
;  :datatype-splits         2
;  :decisions               68
;  :del-clause              1197
;  :final-checks            32
;  :interface-eqs           8
;  :max-generation          5
;  :max-memory              4.52
;  :memory                  4.51
;  :mk-bool-var             2287
;  :mk-clause               1216
;  :num-allocs              179808
;  :num-checks              88
;  :propagations            481
;  :quant-instantiations    498
;  :rlimit-count            233190)
(push) ; 5
(assert (not (< (- i1@142@00 from@60@00) (Seq_length result@62@00))))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               922
;  :arith-add-rows          794
;  :arith-assert-diseq      103
;  :arith-assert-lower      354
;  :arith-assert-upper      223
;  :arith-bound-prop        53
;  :arith-conflicts         35
;  :arith-eq-adapter        175
;  :arith-fixed-eqs         134
;  :arith-offset-eqs        17
;  :arith-pivots            329
;  :conflicts               64
;  :datatype-accessor-ax    63
;  :datatype-constructor-ax 2
;  :datatype-occurs-check   25
;  :datatype-splits         2
;  :decisions               68
;  :del-clause              1197
;  :final-checks            32
;  :interface-eqs           8
;  :max-generation          5
;  :max-memory              4.52
;  :memory                  4.51
;  :mk-bool-var             2288
;  :mk-clause               1216
;  :num-allocs              179895
;  :num-checks              89
;  :propagations            481
;  :quant-instantiations    498
;  :rlimit-count            233493)
(pop) ; 4
(push) ; 4
; [else-branch: 49 | !(i1@142@00 < to@61@00 && from@60@00 <= i1@142@00)]
(assert (not (and (< i1@142@00 to@61@00) (<= from@60@00 i1@142@00))))
(pop) ; 4
(pop) ; 3
; Joined path conditions
(assert (implies
  (and (< i1@142@00 to@61@00) (<= from@60@00 i1@142@00))
  (and
    (< i1@142@00 to@61@00)
    (<= from@60@00 i1@142@00)
    (<= 0 i1@142@00)
    (< i1@142@00 (alen<Int> (opt_get1 $Snap.unit a2@59@00)))
    ($FVF.loc_int ($FVF.lookup_int (sm@139@00 s@$ a2@59@00 from@60@00 to@61@00) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit a2@59@00) i1@142@00)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit a2@59@00) i1@142@00)))))
; Joined path conditions
; Definitional axioms for snapshot map values
(pop) ; 2
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@142@00 Int)) (!
  (implies
    (and (< i1@142@00 to@61@00) (<= from@60@00 i1@142@00))
    (and
      (< i1@142@00 to@61@00)
      (<= from@60@00 i1@142@00)
      (<= 0 i1@142@00)
      (< i1@142@00 (alen<Int> (opt_get1 $Snap.unit a2@59@00)))
      ($FVF.loc_int ($FVF.lookup_int (sm@139@00 s@$ a2@59@00 from@60@00 to@61@00) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit a2@59@00) i1@142@00)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit a2@59@00) i1@142@00))))
  :pattern (($FVF.loc_int ($FVF.lookup_int (sm@139@00 s@$ a2@59@00 from@60@00 to@61@00) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit a2@59@00) i1@142@00)) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit a2@59@00) i1@142@00)))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(assert (forall ((i1@142@00 Int)) (!
  (implies
    (and (< i1@142@00 to@61@00) (<= from@60@00 i1@142@00))
    (=
      ($FVF.lookup_int (sm@139@00 s@$ a2@59@00 from@60@00 to@61@00) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit a2@59@00) i1@142@00))
      (Seq_index result@62@00 (- i1@142@00 from@60@00))))
  :pattern (($FVF.loc_int ($FVF.lookup_int (sm@139@00 s@$ a2@59@00 from@60@00 to@61@00) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit a2@59@00) i1@142@00)) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit a2@59@00) i1@142@00)))
  :qid |prog.l<no position>|)))
(pop) ; 1
(assert (forall ((s@$ $Snap) (a2@59@00 option<array>) (from@60@00 Int) (to@61@00 Int)) (!
  (Seq_equal
    (unknown%limited s@$ a2@59@00 from@60@00 to@61@00)
    (unknown_ s@$ a2@59@00 from@60@00 to@61@00))
  :pattern ((unknown_ s@$ a2@59@00 from@60@00 to@61@00))
  )))
(assert (forall ((s@$ $Snap) (a2@59@00 option<array>) (from@60@00 Int) (to@61@00 Int)) (!
  (unknown%stateless a2@59@00 from@60@00 to@61@00)
  :pattern ((unknown%limited s@$ a2@59@00 from@60@00 to@61@00))
  )))
(assert (forall ((s@$ $Snap) (a2@59@00 option<array>) (from@60@00 Int) (to@61@00 Int)) (!
  (let ((result@62@00 (unknown%limited s@$ a2@59@00 from@60@00 to@61@00))) (and
    (forall ((i1@135@00 Int)) (!
      (implies
        (and
          (and (< i1@135@00 to@61@00) (<= from@60@00 i1@135@00))
          (< $Perm.No $k@136@00))
        (=
          (inv@138@00 s@$ a2@59@00 from@60@00 to@61@00 (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit a2@59@00) i1@135@00))
          i1@135@00))
      :pattern (($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$))))) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit a2@59@00) i1@135@00)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit a2@59@00) i1@135@00)))
      ))
    (forall ((r $Ref)) (!
      (implies
        (and
          (and
            (< (inv@138@00 s@$ a2@59@00 from@60@00 to@61@00 r) to@61@00)
            (<= from@60@00 (inv@138@00 s@$ a2@59@00 from@60@00 to@61@00 r)))
          (< $Perm.No $k@136@00))
        (=
          (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit a2@59@00) (inv@138@00 s@$ a2@59@00 from@60@00 to@61@00 r))
          r))
      :pattern ((inv@138@00 s@$ a2@59@00 from@60@00 to@61@00 r))
      :qid |int-fctOfInv|))
    (forall ((r $Ref)) (!
      (implies
        (ite
          (and
            (< (inv@138@00 s@$ a2@59@00 from@60@00 to@61@00 r) to@61@00)
            (<= from@60@00 (inv@138@00 s@$ a2@59@00 from@60@00 to@61@00 r)))
          (< $Perm.No $k@136@00)
          false)
        (=
          ($FVF.lookup_int (sm@139@00 s@$ a2@59@00 from@60@00 to@61@00) r)
          ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$))))) r)))
      :pattern (($FVF.lookup_int (sm@139@00 s@$ a2@59@00 from@60@00 to@61@00) r))
      :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$))))) r))
      :qid |qp.fvfValDef5|))
    (forall ((r $Ref)) (!
      ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r)
      :pattern (($FVF.lookup_int (sm@139@00 s@$ a2@59@00 from@60@00 to@61@00) r))
      :qid |qp.fvfResTrgDef6|))
    ($Perm.isReadVar $k@136@00 $Perm.Write)
    (implies
      (and
        (not (= a2@59@00 (as None<option<array>>  option<array>)))
        (<= 0 from@60@00)
        (<= from@60@00 to@61@00)
        (<= to@61@00 (alen<Int> (opt_get1 $Snap.unit a2@59@00))))
      (and
        (= (Seq_length result@62@00) (- to@61@00 from@60@00))
        (forall ((i1 Int)) (!
          (implies
            (and (<= 0 i1) (< i1 (- to@61@00 from@60@00)))
            (=
              (Seq_index result@62@00 i1)
              ($FVF.lookup_int (sm@139@00 s@$ a2@59@00 from@60@00 to@61@00) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit a2@59@00) (+ i1 from@60@00)))))
          :pattern ((Seq_index result@62@00 i1))
          ))
        (forall ((i1 Int)) (!
          (implies
            (and (<= from@60@00 i1) (< i1 to@61@00))
            (=
              ($FVF.lookup_int (sm@139@00 s@$ a2@59@00 from@60@00 to@61@00) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit a2@59@00) i1))
              (Seq_index result@62@00 (- i1 from@60@00))))
          :pattern (($FVF.lookup_int (sm@139@00 s@$ a2@59@00 from@60@00 to@61@00) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit a2@59@00) i1)))
          ))))))
  :pattern ((unknown%limited s@$ a2@59@00 from@60@00 to@61@00))
  )))
; ---------- FUNCTION AugPath----------
(declare-fun this@63@00 () $Ref)
(declare-fun G@64@00 () Seq<Seq<Int>>)
(declare-fun Gf@65@00 () Seq<Seq<Int>>)
(declare-fun V@66@00 () Int)
(declare-fun s@67@00 () Int)
(declare-fun t@68@00 () Int)
(declare-fun P@69@00 () Seq<Int>)
(declare-fun result@70@00 () Bool)
; ----- Well-definedness of specifications -----
(push) ; 1
(assert (= s@$ ($Snap.combine ($Snap.first s@$) ($Snap.second s@$))))
(assert (= ($Snap.first s@$) $Snap.unit))
; [eval] this != null
(assert (not (= this@63@00 $Ref.null)))
(assert (=
  ($Snap.second s@$)
  ($Snap.combine
    ($Snap.first ($Snap.second s@$))
    ($Snap.second ($Snap.second s@$)))))
(assert (= ($Snap.first ($Snap.second s@$)) $Snap.unit))
; [eval] SquareIntMatrix(this, G, V)
(push) ; 2
; [eval] this != null
(pop) ; 2
; Joined path conditions
(assert (SquareIntMatrix $Snap.unit this@63@00 G@64@00 V@66@00))
(assert (=
  ($Snap.second ($Snap.second s@$))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second s@$)))
    ($Snap.second ($Snap.second ($Snap.second s@$))))))
(assert (= ($Snap.first ($Snap.second ($Snap.second s@$))) $Snap.unit))
; [eval] SquareIntMatrix(this, Gf, V)
(push) ; 2
; [eval] this != null
(pop) ; 2
; Joined path conditions
(assert (SquareIntMatrix $Snap.unit this@63@00 Gf@65@00 V@66@00))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second s@$)))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$)))))))
(assert (= ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$)))) $Snap.unit))
; [eval] FlowNetwork(this, G, V, s, t)
(push) ; 2
; [eval] this != null
(pop) ; 2
; Joined path conditions
(assert (FlowNetwork $Snap.unit this@63@00 G@64@00 V@66@00 s@67@00 t@68@00))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$)))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$)))))
  $Snap.unit))
; [eval] FlowNetwork(this, Gf, V, s, t)
(push) ; 2
; [eval] this != null
(pop) ; 2
; Joined path conditions
(assert (FlowNetwork $Snap.unit this@63@00 Gf@65@00 V@66@00 s@67@00 t@68@00))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$)))))
  $Snap.unit))
; [eval] ValidFlow(this, G, Gf, V, s, t)
(push) ; 2
; [eval] this != null
; [eval] SquareIntMatrix(this, Gf, V)
(push) ; 3
; [eval] this != null
(pop) ; 3
; Joined path conditions
; [eval] FlowNetwork(this, G, V, s, t)
(push) ; 3
; [eval] this != null
(pop) ; 3
; Joined path conditions
; [eval] FlowNetwork(this, Gf, V, s, t)
(push) ; 3
; [eval] this != null
(pop) ; 3
; Joined path conditions
(pop) ; 2
; Joined path conditions
(assert (ValidFlow ($Snap.combine
  $Snap.unit
  ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) this@63@00 G@64@00 Gf@65@00 V@66@00 s@67@00 t@68@00))
(pop) ; 1
(assert (forall ((s@$ $Snap) (this@63@00 $Ref) (G@64@00 Seq<Seq<Int>>) (Gf@65@00 Seq<Seq<Int>>) (V@66@00 Int) (s@67@00 Int) (t@68@00 Int) (P@69@00 Seq<Int>)) (!
  (=
    (AugPath%limited s@$ this@63@00 G@64@00 Gf@65@00 V@66@00 s@67@00 t@68@00 P@69@00)
    (AugPath s@$ this@63@00 G@64@00 Gf@65@00 V@66@00 s@67@00 t@68@00 P@69@00))
  :pattern ((AugPath s@$ this@63@00 G@64@00 Gf@65@00 V@66@00 s@67@00 t@68@00 P@69@00))
  )))
(assert (forall ((s@$ $Snap) (this@63@00 $Ref) (G@64@00 Seq<Seq<Int>>) (Gf@65@00 Seq<Seq<Int>>) (V@66@00 Int) (s@67@00 Int) (t@68@00 Int) (P@69@00 Seq<Int>)) (!
  (AugPath%stateless this@63@00 G@64@00 Gf@65@00 V@66@00 s@67@00 t@68@00 P@69@00)
  :pattern ((AugPath%limited s@$ this@63@00 G@64@00 Gf@65@00 V@66@00 s@67@00 t@68@00 P@69@00))
  )))
; ----- Verification of function body and postcondition -----
(push) ; 1
(assert (= s@$ ($Snap.combine ($Snap.first s@$) ($Snap.second s@$))))
(assert (= ($Snap.first s@$) $Snap.unit))
(assert (not (= this@63@00 $Ref.null)))
(assert (=
  ($Snap.second s@$)
  ($Snap.combine
    ($Snap.first ($Snap.second s@$))
    ($Snap.second ($Snap.second s@$)))))
(assert (= ($Snap.first ($Snap.second s@$)) $Snap.unit))
(assert (SquareIntMatrix $Snap.unit this@63@00 G@64@00 V@66@00))
(assert (=
  ($Snap.second ($Snap.second s@$))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second s@$)))
    ($Snap.second ($Snap.second ($Snap.second s@$))))))
(assert (= ($Snap.first ($Snap.second ($Snap.second s@$))) $Snap.unit))
(assert (SquareIntMatrix $Snap.unit this@63@00 Gf@65@00 V@66@00))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second s@$)))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$)))))))
(assert (= ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$)))) $Snap.unit))
(assert (FlowNetwork $Snap.unit this@63@00 G@64@00 V@66@00 s@67@00 t@68@00))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$)))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$)))))
  $Snap.unit))
(assert (FlowNetwork $Snap.unit this@63@00 Gf@65@00 V@66@00 s@67@00 t@68@00))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$)))))
  $Snap.unit))
(assert (ValidFlow ($Snap.combine
  $Snap.unit
  ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) this@63@00 G@64@00 Gf@65@00 V@66@00 s@67@00 t@68@00))
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
; [eval] (0 <= s && s < V && 0 <= t && t < V && 1 < |P| ==> P[0] != P[|P| - 1]) && (0 <= s && s < V && 0 <= t && t < V && 1 < |P| ==> valid_graph_vertices1(this, P, V)) && (0 <= s && s < V && 0 <= t && t < V && 1 < |P| ==> (forall j: Int :: { Gf[P[j]] } 0 <= j && j < |P| - 1 ==> 0 < Gf[P[j]][P[j + 1]]))
; [eval] 0 <= s && s < V && 0 <= t && t < V && 1 < |P| ==> P[0] != P[|P| - 1]
; [eval] 0 <= s && s < V && 0 <= t && t < V && 1 < |P|
; [eval] 0 <= s
(push) ; 2
; [then-branch: 50 | 0 <= s@67@00 | live]
; [else-branch: 50 | !(0 <= s@67@00) | live]
(push) ; 3
; [then-branch: 50 | 0 <= s@67@00]
(assert (<= 0 s@67@00))
; [eval] s < V
(push) ; 4
; [then-branch: 51 | s@67@00 < V@66@00 | live]
; [else-branch: 51 | !(s@67@00 < V@66@00) | live]
(push) ; 5
; [then-branch: 51 | s@67@00 < V@66@00]
(assert (< s@67@00 V@66@00))
; [eval] 0 <= t
(push) ; 6
; [then-branch: 52 | 0 <= t@68@00 | live]
; [else-branch: 52 | !(0 <= t@68@00) | live]
(push) ; 7
; [then-branch: 52 | 0 <= t@68@00]
(assert (<= 0 t@68@00))
; [eval] t < V
(push) ; 8
; [then-branch: 53 | t@68@00 < V@66@00 | live]
; [else-branch: 53 | !(t@68@00 < V@66@00) | live]
(push) ; 9
; [then-branch: 53 | t@68@00 < V@66@00]
(assert (< t@68@00 V@66@00))
; [eval] 1 < |P|
; [eval] |P|
(pop) ; 9
(push) ; 9
; [else-branch: 53 | !(t@68@00 < V@66@00)]
(assert (not (< t@68@00 V@66@00)))
(pop) ; 9
(pop) ; 8
; Joined path conditions
; Joined path conditions
(pop) ; 7
(push) ; 7
; [else-branch: 52 | !(0 <= t@68@00)]
(assert (not (<= 0 t@68@00)))
(pop) ; 7
(pop) ; 6
; Joined path conditions
; Joined path conditions
(pop) ; 5
(push) ; 5
; [else-branch: 51 | !(s@67@00 < V@66@00)]
(assert (not (< s@67@00 V@66@00)))
(pop) ; 5
(pop) ; 4
; Joined path conditions
; Joined path conditions
(pop) ; 3
(push) ; 3
; [else-branch: 50 | !(0 <= s@67@00)]
(assert (not (<= 0 s@67@00)))
(pop) ; 3
(pop) ; 2
; Joined path conditions
; Joined path conditions
(push) ; 2
(set-option :timeout 10)
(push) ; 3
(assert (not (not
  (and
    (and
      (and (and (< 1 (Seq_length P@69@00)) (< t@68@00 V@66@00)) (<= 0 t@68@00))
      (< s@67@00 V@66@00))
    (<= 0 s@67@00)))))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1087
;  :arith-add-rows          960
;  :arith-assert-diseq      112
;  :arith-assert-lower      425
;  :arith-assert-upper      253
;  :arith-bound-prop        63
;  :arith-conflicts         38
;  :arith-eq-adapter        206
;  :arith-fixed-eqs         155
;  :arith-offset-eqs        23
;  :arith-pivots            385
;  :conflicts               69
;  :datatype-accessor-ax    76
;  :datatype-constructor-ax 4
;  :datatype-occurs-check   31
;  :datatype-splits         4
;  :decisions               88
;  :del-clause              1493
;  :final-checks            37
;  :interface-eqs           9
;  :max-generation          6
;  :max-memory              4.86
;  :memory                  4.83
;  :mk-bool-var             2774
;  :mk-clause               1556
;  :num-allocs              187111
;  :num-checks              91
;  :propagations            596
;  :quant-instantiations    651
;  :rlimit-count            248869
;  :time                    0.00)
(push) ; 3
(assert (not (and
  (and
    (and (and (< 1 (Seq_length P@69@00)) (< t@68@00 V@66@00)) (<= 0 t@68@00))
    (< s@67@00 V@66@00))
  (<= 0 s@67@00))))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1103
;  :arith-add-rows          982
;  :arith-assert-diseq      115
;  :arith-assert-lower      446
;  :arith-assert-upper      258
;  :arith-bound-prop        65
;  :arith-conflicts         38
;  :arith-eq-adapter        212
;  :arith-fixed-eqs         159
;  :arith-offset-eqs        24
;  :arith-pivots            393
;  :conflicts               69
;  :datatype-accessor-ax    76
;  :datatype-constructor-ax 5
;  :datatype-occurs-check   34
;  :datatype-splits         5
;  :decisions               99
;  :del-clause              1532
;  :final-checks            39
;  :interface-eqs           9
;  :max-generation          6
;  :max-memory              4.86
;  :memory                  4.83
;  :mk-bool-var             2857
;  :mk-clause               1595
;  :num-allocs              188620
;  :num-checks              92
;  :propagations            608
;  :quant-instantiations    694
;  :rlimit-count            251473
;  :time                    0.00)
; [then-branch: 54 | 1 < |P@69@00| && t@68@00 < V@66@00 && 0 <= t@68@00 && s@67@00 < V@66@00 && 0 <= s@67@00 | live]
; [else-branch: 54 | !(1 < |P@69@00| && t@68@00 < V@66@00 && 0 <= t@68@00 && s@67@00 < V@66@00 && 0 <= s@67@00) | live]
(push) ; 3
; [then-branch: 54 | 1 < |P@69@00| && t@68@00 < V@66@00 && 0 <= t@68@00 && s@67@00 < V@66@00 && 0 <= s@67@00]
(assert (and
  (and
    (and (and (< 1 (Seq_length P@69@00)) (< t@68@00 V@66@00)) (<= 0 t@68@00))
    (< s@67@00 V@66@00))
  (<= 0 s@67@00)))
; [eval] P[0] != P[|P| - 1]
; [eval] P[0]
(set-option :timeout 0)
(push) ; 4
(assert (not (< 0 (Seq_length P@69@00))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1104
;  :arith-add-rows          982
;  :arith-assert-diseq      116
;  :arith-assert-lower      449
;  :arith-assert-upper      258
;  :arith-bound-prop        65
;  :arith-conflicts         38
;  :arith-eq-adapter        214
;  :arith-fixed-eqs         159
;  :arith-offset-eqs        24
;  :arith-pivots            393
;  :conflicts               70
;  :datatype-accessor-ax    76
;  :datatype-constructor-ax 5
;  :datatype-occurs-check   34
;  :datatype-splits         5
;  :decisions               99
;  :del-clause              1532
;  :final-checks            39
;  :interface-eqs           9
;  :max-generation          6
;  :max-memory              4.86
;  :memory                  4.83
;  :mk-bool-var             2868
;  :mk-clause               1604
;  :num-allocs              188828
;  :num-checks              93
;  :propagations            609
;  :quant-instantiations    698
;  :rlimit-count            251804)
; [eval] P[|P| - 1]
; [eval] |P| - 1
; [eval] |P|
(push) ; 4
(assert (not (>= (- (Seq_length P@69@00) 1) 0)))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1104
;  :arith-add-rows          982
;  :arith-assert-diseq      116
;  :arith-assert-lower      449
;  :arith-assert-upper      259
;  :arith-bound-prop        65
;  :arith-conflicts         39
;  :arith-eq-adapter        214
;  :arith-fixed-eqs         159
;  :arith-offset-eqs        24
;  :arith-pivots            393
;  :conflicts               71
;  :datatype-accessor-ax    76
;  :datatype-constructor-ax 5
;  :datatype-occurs-check   34
;  :datatype-splits         5
;  :decisions               99
;  :del-clause              1532
;  :final-checks            39
;  :interface-eqs           9
;  :max-generation          6
;  :max-memory              4.86
;  :memory                  4.82
;  :mk-bool-var             2869
;  :mk-clause               1604
;  :num-allocs              188920
;  :num-checks              94
;  :propagations            609
;  :quant-instantiations    698
;  :rlimit-count            251882)
(push) ; 4
(assert (not (< (- (Seq_length P@69@00) 1) (Seq_length P@69@00))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1104
;  :arith-add-rows          982
;  :arith-assert-diseq      116
;  :arith-assert-lower      449
;  :arith-assert-upper      259
;  :arith-bound-prop        65
;  :arith-conflicts         39
;  :arith-eq-adapter        214
;  :arith-fixed-eqs         159
;  :arith-offset-eqs        24
;  :arith-pivots            393
;  :conflicts               71
;  :datatype-accessor-ax    76
;  :datatype-constructor-ax 5
;  :datatype-occurs-check   34
;  :datatype-splits         5
;  :decisions               99
;  :del-clause              1532
;  :final-checks            39
;  :interface-eqs           9
;  :max-generation          6
;  :max-memory              4.86
;  :memory                  4.82
;  :mk-bool-var             2869
;  :mk-clause               1604
;  :num-allocs              188954
;  :num-checks              95
;  :propagations            609
;  :quant-instantiations    698
;  :rlimit-count            251905)
(pop) ; 3
(push) ; 3
; [else-branch: 54 | !(1 < |P@69@00| && t@68@00 < V@66@00 && 0 <= t@68@00 && s@67@00 < V@66@00 && 0 <= s@67@00)]
(assert (not
  (and
    (and
      (and (and (< 1 (Seq_length P@69@00)) (< t@68@00 V@66@00)) (<= 0 t@68@00))
      (< s@67@00 V@66@00))
    (<= 0 s@67@00))))
(pop) ; 3
(pop) ; 2
; Joined path conditions
(assert (implies
  (and
    (and
      (and (and (< 1 (Seq_length P@69@00)) (< t@68@00 V@66@00)) (<= 0 t@68@00))
      (< s@67@00 V@66@00))
    (<= 0 s@67@00))
  (and
    (< 1 (Seq_length P@69@00))
    (< t@68@00 V@66@00)
    (<= 0 t@68@00)
    (< s@67@00 V@66@00)
    (<= 0 s@67@00))))
; Joined path conditions
(push) ; 2
; [then-branch: 55 | 1 < |P@69@00| && t@68@00 < V@66@00 && 0 <= t@68@00 && s@67@00 < V@66@00 && 0 <= s@67@00 ==> P@69@00[0] != P@69@00[|P@69@00| - 1] | live]
; [else-branch: 55 | !(1 < |P@69@00| && t@68@00 < V@66@00 && 0 <= t@68@00 && s@67@00 < V@66@00 && 0 <= s@67@00 ==> P@69@00[0] != P@69@00[|P@69@00| - 1]) | live]
(push) ; 3
; [then-branch: 55 | 1 < |P@69@00| && t@68@00 < V@66@00 && 0 <= t@68@00 && s@67@00 < V@66@00 && 0 <= s@67@00 ==> P@69@00[0] != P@69@00[|P@69@00| - 1]]
(assert (implies
  (and
    (and
      (and (and (< 1 (Seq_length P@69@00)) (< t@68@00 V@66@00)) (<= 0 t@68@00))
      (< s@67@00 V@66@00))
    (<= 0 s@67@00))
  (not (= (Seq_index P@69@00 0) (Seq_index P@69@00 (- (Seq_length P@69@00) 1))))))
; [eval] 0 <= s && s < V && 0 <= t && t < V && 1 < |P| ==> valid_graph_vertices1(this, P, V)
; [eval] 0 <= s && s < V && 0 <= t && t < V && 1 < |P|
; [eval] 0 <= s
(push) ; 4
; [then-branch: 56 | 0 <= s@67@00 | live]
; [else-branch: 56 | !(0 <= s@67@00) | live]
(push) ; 5
; [then-branch: 56 | 0 <= s@67@00]
(assert (<= 0 s@67@00))
; [eval] s < V
(push) ; 6
; [then-branch: 57 | s@67@00 < V@66@00 | live]
; [else-branch: 57 | !(s@67@00 < V@66@00) | live]
(push) ; 7
; [then-branch: 57 | s@67@00 < V@66@00]
(assert (< s@67@00 V@66@00))
; [eval] 0 <= t
(push) ; 8
; [then-branch: 58 | 0 <= t@68@00 | live]
; [else-branch: 58 | !(0 <= t@68@00) | live]
(push) ; 9
; [then-branch: 58 | 0 <= t@68@00]
(assert (<= 0 t@68@00))
; [eval] t < V
(push) ; 10
; [then-branch: 59 | t@68@00 < V@66@00 | live]
; [else-branch: 59 | !(t@68@00 < V@66@00) | live]
(push) ; 11
; [then-branch: 59 | t@68@00 < V@66@00]
(assert (< t@68@00 V@66@00))
; [eval] 1 < |P|
; [eval] |P|
(pop) ; 11
(push) ; 11
; [else-branch: 59 | !(t@68@00 < V@66@00)]
(assert (not (< t@68@00 V@66@00)))
(pop) ; 11
(pop) ; 10
; Joined path conditions
; Joined path conditions
(pop) ; 9
(push) ; 9
; [else-branch: 58 | !(0 <= t@68@00)]
(assert (not (<= 0 t@68@00)))
(pop) ; 9
(pop) ; 8
; Joined path conditions
; Joined path conditions
(pop) ; 7
(push) ; 7
; [else-branch: 57 | !(s@67@00 < V@66@00)]
(assert (not (< s@67@00 V@66@00)))
(pop) ; 7
(pop) ; 6
; Joined path conditions
; Joined path conditions
(pop) ; 5
(push) ; 5
; [else-branch: 56 | !(0 <= s@67@00)]
(assert (not (<= 0 s@67@00)))
(pop) ; 5
(pop) ; 4
; Joined path conditions
; Joined path conditions
(push) ; 4
(set-option :timeout 10)
(push) ; 5
(assert (not (not
  (and
    (and
      (and (and (< 1 (Seq_length P@69@00)) (< t@68@00 V@66@00)) (<= 0 t@68@00))
      (< s@67@00 V@66@00))
    (<= 0 s@67@00)))))
(check-sat)
; unknown
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1125
;  :arith-add-rows          1018
;  :arith-assert-diseq      119
;  :arith-assert-lower      473
;  :arith-assert-upper      265
;  :arith-bound-prop        67
;  :arith-conflicts         41
;  :arith-eq-adapter        220
;  :arith-fixed-eqs         163
;  :arith-offset-eqs        30
;  :arith-pivots            405
;  :conflicts               73
;  :datatype-accessor-ax    76
;  :datatype-constructor-ax 6
;  :datatype-occurs-check   37
;  :datatype-splits         6
;  :decisions               109
;  :del-clause              1577
;  :final-checks            41
;  :interface-eqs           9
;  :max-generation          6
;  :max-memory              4.87
;  :memory                  4.85
;  :mk-bool-var             2957
;  :mk-clause               1641
;  :num-allocs              190829
;  :num-checks              96
;  :propagations            625
;  :quant-instantiations    741
;  :rlimit-count            255336
;  :time                    0.00)
(push) ; 5
(assert (not (and
  (and
    (and (and (< 1 (Seq_length P@69@00)) (< t@68@00 V@66@00)) (<= 0 t@68@00))
    (< s@67@00 V@66@00))
  (<= 0 s@67@00))))
(check-sat)
; unknown
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1149
;  :arith-add-rows          1054
;  :arith-assert-diseq      122
;  :arith-assert-lower      496
;  :arith-assert-upper      272
;  :arith-bound-prop        71
;  :arith-conflicts         43
;  :arith-eq-adapter        226
;  :arith-fixed-eqs         168
;  :arith-offset-eqs        37
;  :arith-pivots            423
;  :conflicts               75
;  :datatype-accessor-ax    76
;  :datatype-constructor-ax 7
;  :datatype-occurs-check   40
;  :datatype-splits         7
;  :decisions               118
;  :del-clause              1618
;  :final-checks            43
;  :interface-eqs           9
;  :max-generation          6
;  :max-memory              4.87
;  :memory                  4.85
;  :mk-bool-var             3043
;  :mk-clause               1682
;  :num-allocs              192328
;  :num-checks              97
;  :propagations            641
;  :quant-instantiations    784
;  :rlimit-count            258144
;  :time                    0.00)
; [then-branch: 60 | 1 < |P@69@00| && t@68@00 < V@66@00 && 0 <= t@68@00 && s@67@00 < V@66@00 && 0 <= s@67@00 | live]
; [else-branch: 60 | !(1 < |P@69@00| && t@68@00 < V@66@00 && 0 <= t@68@00 && s@67@00 < V@66@00 && 0 <= s@67@00) | live]
(push) ; 5
; [then-branch: 60 | 1 < |P@69@00| && t@68@00 < V@66@00 && 0 <= t@68@00 && s@67@00 < V@66@00 && 0 <= s@67@00]
(assert (and
  (and
    (and (and (< 1 (Seq_length P@69@00)) (< t@68@00 V@66@00)) (<= 0 t@68@00))
    (< s@67@00 V@66@00))
  (<= 0 s@67@00)))
; [eval] valid_graph_vertices1(this, P, V)
(push) ; 6
; [eval] this != null
(pop) ; 6
; Joined path conditions
(pop) ; 5
(push) ; 5
; [else-branch: 60 | !(1 < |P@69@00| && t@68@00 < V@66@00 && 0 <= t@68@00 && s@67@00 < V@66@00 && 0 <= s@67@00)]
(assert (not
  (and
    (and
      (and (and (< 1 (Seq_length P@69@00)) (< t@68@00 V@66@00)) (<= 0 t@68@00))
      (< s@67@00 V@66@00))
    (<= 0 s@67@00))))
(pop) ; 5
(pop) ; 4
; Joined path conditions
; Joined path conditions
(push) ; 4
; [then-branch: 61 | 1 < |P@69@00| && t@68@00 < V@66@00 && 0 <= t@68@00 && s@67@00 < V@66@00 && 0 <= s@67@00 ==> valid_graph_vertices1(_, this@63@00, P@69@00, V@66@00) | live]
; [else-branch: 61 | !(1 < |P@69@00| && t@68@00 < V@66@00 && 0 <= t@68@00 && s@67@00 < V@66@00 && 0 <= s@67@00 ==> valid_graph_vertices1(_, this@63@00, P@69@00, V@66@00)) | live]
(push) ; 5
; [then-branch: 61 | 1 < |P@69@00| && t@68@00 < V@66@00 && 0 <= t@68@00 && s@67@00 < V@66@00 && 0 <= s@67@00 ==> valid_graph_vertices1(_, this@63@00, P@69@00, V@66@00)]
(assert (implies
  (and
    (and
      (and (and (< 1 (Seq_length P@69@00)) (< t@68@00 V@66@00)) (<= 0 t@68@00))
      (< s@67@00 V@66@00))
    (<= 0 s@67@00))
  (valid_graph_vertices1 $Snap.unit this@63@00 P@69@00 V@66@00)))
; [eval] 0 <= s && s < V && 0 <= t && t < V && 1 < |P| ==> (forall j: Int :: { Gf[P[j]] } 0 <= j && j < |P| - 1 ==> 0 < Gf[P[j]][P[j + 1]])
; [eval] 0 <= s && s < V && 0 <= t && t < V && 1 < |P|
; [eval] 0 <= s
(push) ; 6
; [then-branch: 62 | 0 <= s@67@00 | live]
; [else-branch: 62 | !(0 <= s@67@00) | live]
(push) ; 7
; [then-branch: 62 | 0 <= s@67@00]
(assert (<= 0 s@67@00))
; [eval] s < V
(push) ; 8
; [then-branch: 63 | s@67@00 < V@66@00 | live]
; [else-branch: 63 | !(s@67@00 < V@66@00) | live]
(push) ; 9
; [then-branch: 63 | s@67@00 < V@66@00]
(assert (< s@67@00 V@66@00))
; [eval] 0 <= t
(push) ; 10
; [then-branch: 64 | 0 <= t@68@00 | live]
; [else-branch: 64 | !(0 <= t@68@00) | live]
(push) ; 11
; [then-branch: 64 | 0 <= t@68@00]
(assert (<= 0 t@68@00))
; [eval] t < V
(push) ; 12
; [then-branch: 65 | t@68@00 < V@66@00 | live]
; [else-branch: 65 | !(t@68@00 < V@66@00) | live]
(push) ; 13
; [then-branch: 65 | t@68@00 < V@66@00]
(assert (< t@68@00 V@66@00))
; [eval] 1 < |P|
; [eval] |P|
(pop) ; 13
(push) ; 13
; [else-branch: 65 | !(t@68@00 < V@66@00)]
(assert (not (< t@68@00 V@66@00)))
(pop) ; 13
(pop) ; 12
; Joined path conditions
; Joined path conditions
(pop) ; 11
(push) ; 11
; [else-branch: 64 | !(0 <= t@68@00)]
(assert (not (<= 0 t@68@00)))
(pop) ; 11
(pop) ; 10
; Joined path conditions
; Joined path conditions
(pop) ; 9
(push) ; 9
; [else-branch: 63 | !(s@67@00 < V@66@00)]
(assert (not (< s@67@00 V@66@00)))
(pop) ; 9
(pop) ; 8
; Joined path conditions
; Joined path conditions
(pop) ; 7
(push) ; 7
; [else-branch: 62 | !(0 <= s@67@00)]
(assert (not (<= 0 s@67@00)))
(pop) ; 7
(pop) ; 6
; Joined path conditions
; Joined path conditions
(push) ; 6
(push) ; 7
(assert (not (not
  (and
    (and
      (and (and (< 1 (Seq_length P@69@00)) (< t@68@00 V@66@00)) (<= 0 t@68@00))
      (< s@67@00 V@66@00))
    (<= 0 s@67@00)))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1172
;  :arith-add-rows          1092
;  :arith-assert-diseq      128
;  :arith-assert-lower      529
;  :arith-assert-upper      278
;  :arith-bound-prop        73
;  :arith-conflicts         45
;  :arith-eq-adapter        235
;  :arith-fixed-eqs         172
;  :arith-offset-eqs        43
;  :arith-pivots            439
;  :conflicts               77
;  :datatype-accessor-ax    76
;  :datatype-constructor-ax 8
;  :datatype-occurs-check   43
;  :datatype-splits         8
;  :decisions               129
;  :del-clause              1686
;  :final-checks            45
;  :interface-eqs           9
;  :max-generation          6
;  :max-memory              4.90
;  :memory                  4.87
;  :mk-bool-var             3165
;  :mk-clause               1751
;  :num-allocs              194553
;  :num-checks              98
;  :propagations            666
;  :quant-instantiations    838
;  :rlimit-count            262258
;  :time                    0.00)
(push) ; 7
(assert (not (and
  (and
    (and (and (< 1 (Seq_length P@69@00)) (< t@68@00 V@66@00)) (<= 0 t@68@00))
    (< s@67@00 V@66@00))
  (<= 0 s@67@00))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1196
;  :arith-add-rows          1128
;  :arith-assert-diseq      131
;  :arith-assert-lower      552
;  :arith-assert-upper      285
;  :arith-bound-prop        77
;  :arith-conflicts         47
;  :arith-eq-adapter        241
;  :arith-fixed-eqs         177
;  :arith-offset-eqs        50
;  :arith-pivots            455
;  :conflicts               79
;  :datatype-accessor-ax    76
;  :datatype-constructor-ax 9
;  :datatype-occurs-check   46
;  :datatype-splits         9
;  :decisions               138
;  :del-clause              1727
;  :final-checks            47
;  :interface-eqs           9
;  :max-generation          6
;  :max-memory              4.90
;  :memory                  4.87
;  :mk-bool-var             3251
;  :mk-clause               1792
;  :num-allocs              196054
;  :num-checks              99
;  :propagations            682
;  :quant-instantiations    881
;  :rlimit-count            265060
;  :time                    0.00)
; [then-branch: 66 | 1 < |P@69@00| && t@68@00 < V@66@00 && 0 <= t@68@00 && s@67@00 < V@66@00 && 0 <= s@67@00 | live]
; [else-branch: 66 | !(1 < |P@69@00| && t@68@00 < V@66@00 && 0 <= t@68@00 && s@67@00 < V@66@00 && 0 <= s@67@00) | live]
(push) ; 7
; [then-branch: 66 | 1 < |P@69@00| && t@68@00 < V@66@00 && 0 <= t@68@00 && s@67@00 < V@66@00 && 0 <= s@67@00]
(assert (and
  (and
    (and (and (< 1 (Seq_length P@69@00)) (< t@68@00 V@66@00)) (<= 0 t@68@00))
    (< s@67@00 V@66@00))
  (<= 0 s@67@00)))
; [eval] (forall j: Int :: { Gf[P[j]] } 0 <= j && j < |P| - 1 ==> 0 < Gf[P[j]][P[j + 1]])
(declare-const j@143@00 Int)
(push) ; 8
; [eval] 0 <= j && j < |P| - 1 ==> 0 < Gf[P[j]][P[j + 1]]
; [eval] 0 <= j && j < |P| - 1
; [eval] 0 <= j
(push) ; 9
; [then-branch: 67 | 0 <= j@143@00 | live]
; [else-branch: 67 | !(0 <= j@143@00) | live]
(push) ; 10
; [then-branch: 67 | 0 <= j@143@00]
(assert (<= 0 j@143@00))
; [eval] j < |P| - 1
; [eval] |P| - 1
; [eval] |P|
(pop) ; 10
(push) ; 10
; [else-branch: 67 | !(0 <= j@143@00)]
(assert (not (<= 0 j@143@00)))
(pop) ; 10
(pop) ; 9
; Joined path conditions
; Joined path conditions
(push) ; 9
; [then-branch: 68 | j@143@00 < |P@69@00| - 1 && 0 <= j@143@00 | live]
; [else-branch: 68 | !(j@143@00 < |P@69@00| - 1 && 0 <= j@143@00) | live]
(push) ; 10
; [then-branch: 68 | j@143@00 < |P@69@00| - 1 && 0 <= j@143@00]
(assert (and (< j@143@00 (- (Seq_length P@69@00) 1)) (<= 0 j@143@00)))
; [eval] 0 < Gf[P[j]][P[j + 1]]
; [eval] Gf[P[j]][P[j + 1]]
; [eval] Gf[P[j]]
; [eval] P[j]
(set-option :timeout 0)
(push) ; 11
(assert (not (>= j@143@00 0)))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1198
;  :arith-add-rows          1128
;  :arith-assert-diseq      134
;  :arith-assert-lower      561
;  :arith-assert-upper      285
;  :arith-bound-prop        77
;  :arith-conflicts         47
;  :arith-eq-adapter        244
;  :arith-fixed-eqs         177
;  :arith-offset-eqs        50
;  :arith-pivots            456
;  :conflicts               79
;  :datatype-accessor-ax    76
;  :datatype-constructor-ax 9
;  :datatype-occurs-check   46
;  :datatype-splits         9
;  :decisions               138
;  :del-clause              1727
;  :final-checks            47
;  :interface-eqs           9
;  :max-generation          6
;  :max-memory              4.90
;  :memory                  4.88
;  :mk-bool-var             3288
;  :mk-clause               1826
;  :num-allocs              196439
;  :num-checks              100
;  :propagations            692
;  :quant-instantiations    892
;  :rlimit-count            265882)
(push) ; 11
(assert (not (< j@143@00 (Seq_length P@69@00))))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1198
;  :arith-add-rows          1128
;  :arith-assert-diseq      134
;  :arith-assert-lower      561
;  :arith-assert-upper      286
;  :arith-bound-prop        77
;  :arith-conflicts         48
;  :arith-eq-adapter        244
;  :arith-fixed-eqs         177
;  :arith-offset-eqs        50
;  :arith-pivots            456
;  :conflicts               80
;  :datatype-accessor-ax    76
;  :datatype-constructor-ax 9
;  :datatype-occurs-check   46
;  :datatype-splits         9
;  :decisions               138
;  :del-clause              1727
;  :final-checks            47
;  :interface-eqs           9
;  :max-generation          6
;  :max-memory              4.90
;  :memory                  4.87
;  :mk-bool-var             3289
;  :mk-clause               1826
;  :num-allocs              196516
;  :num-checks              101
;  :propagations            692
;  :quant-instantiations    892
;  :rlimit-count            265966)
(push) ; 11
(assert (not (>= (Seq_index P@69@00 j@143@00) 0)))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1198
;  :arith-add-rows          1128
;  :arith-assert-diseq      134
;  :arith-assert-lower      561
;  :arith-assert-upper      287
;  :arith-bound-prop        77
;  :arith-conflicts         48
;  :arith-eq-adapter        244
;  :arith-fixed-eqs         177
;  :arith-offset-eqs        50
;  :arith-pivots            456
;  :conflicts               81
;  :datatype-accessor-ax    76
;  :datatype-constructor-ax 9
;  :datatype-occurs-check   46
;  :datatype-splits         9
;  :decisions               138
;  :del-clause              1727
;  :final-checks            47
;  :interface-eqs           9
;  :max-generation          6
;  :max-memory              4.90
;  :memory                  4.87
;  :mk-bool-var             3292
;  :mk-clause               1826
;  :num-allocs              196613
;  :num-checks              102
;  :propagations            692
;  :quant-instantiations    894
;  :rlimit-count            266111)
(push) ; 11
(assert (not (< (Seq_index P@69@00 j@143@00) (Seq_length Gf@65@00))))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1198
;  :arith-add-rows          1130
;  :arith-assert-diseq      134
;  :arith-assert-lower      563
;  :arith-assert-upper      288
;  :arith-bound-prop        77
;  :arith-conflicts         49
;  :arith-eq-adapter        244
;  :arith-fixed-eqs         177
;  :arith-offset-eqs        50
;  :arith-pivots            458
;  :conflicts               82
;  :datatype-accessor-ax    76
;  :datatype-constructor-ax 9
;  :datatype-occurs-check   46
;  :datatype-splits         9
;  :decisions               138
;  :del-clause              1727
;  :final-checks            47
;  :interface-eqs           9
;  :max-generation          6
;  :max-memory              4.90
;  :memory                  4.87
;  :mk-bool-var             3296
;  :mk-clause               1826
;  :num-allocs              196716
;  :num-checks              103
;  :propagations            692
;  :quant-instantiations    896
;  :rlimit-count            266289)
; [eval] P[j + 1]
; [eval] j + 1
(push) ; 11
(assert (not (>= (+ j@143@00 1) 0)))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1198
;  :arith-add-rows          1130
;  :arith-assert-diseq      134
;  :arith-assert-lower      563
;  :arith-assert-upper      289
;  :arith-bound-prop        77
;  :arith-conflicts         50
;  :arith-eq-adapter        244
;  :arith-fixed-eqs         177
;  :arith-offset-eqs        50
;  :arith-pivots            458
;  :conflicts               83
;  :datatype-accessor-ax    76
;  :datatype-constructor-ax 9
;  :datatype-occurs-check   46
;  :datatype-splits         9
;  :decisions               138
;  :del-clause              1727
;  :final-checks            47
;  :interface-eqs           9
;  :max-generation          6
;  :max-memory              4.90
;  :memory                  4.86
;  :mk-bool-var             3297
;  :mk-clause               1826
;  :num-allocs              196795
;  :num-checks              104
;  :propagations            692
;  :quant-instantiations    896
;  :rlimit-count            266353)
(push) ; 11
(assert (not (< (+ j@143@00 1) (Seq_length P@69@00))))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1198
;  :arith-add-rows          1130
;  :arith-assert-diseq      134
;  :arith-assert-lower      563
;  :arith-assert-upper      289
;  :arith-bound-prop        77
;  :arith-conflicts         50
;  :arith-eq-adapter        244
;  :arith-fixed-eqs         177
;  :arith-offset-eqs        50
;  :arith-pivots            458
;  :conflicts               83
;  :datatype-accessor-ax    76
;  :datatype-constructor-ax 9
;  :datatype-occurs-check   46
;  :datatype-splits         9
;  :decisions               138
;  :del-clause              1727
;  :final-checks            47
;  :interface-eqs           9
;  :max-generation          6
;  :max-memory              4.90
;  :memory                  4.86
;  :mk-bool-var             3297
;  :mk-clause               1826
;  :num-allocs              196821
;  :num-checks              105
;  :propagations            692
;  :quant-instantiations    896
;  :rlimit-count            266377)
(push) ; 11
(assert (not (>= (Seq_index P@69@00 (+ j@143@00 1)) 0)))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1198
;  :arith-add-rows          1131
;  :arith-assert-diseq      134
;  :arith-assert-lower      563
;  :arith-assert-upper      290
;  :arith-bound-prop        77
;  :arith-conflicts         50
;  :arith-eq-adapter        244
;  :arith-fixed-eqs         177
;  :arith-offset-eqs        50
;  :arith-pivots            458
;  :conflicts               84
;  :datatype-accessor-ax    76
;  :datatype-constructor-ax 9
;  :datatype-occurs-check   46
;  :datatype-splits         9
;  :decisions               138
;  :del-clause              1727
;  :final-checks            47
;  :interface-eqs           9
;  :max-generation          6
;  :max-memory              4.90
;  :memory                  4.86
;  :mk-bool-var             3300
;  :mk-clause               1826
;  :num-allocs              196925
;  :num-checks              106
;  :propagations            692
;  :quant-instantiations    898
;  :rlimit-count            266542)
(push) ; 11
(assert (not (<
  (Seq_index P@69@00 (+ j@143@00 1))
  (Seq_length (Seq_index Gf@65@00 (Seq_index P@69@00 j@143@00))))))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1215
;  :arith-add-rows          1162
;  :arith-assert-diseq      143
;  :arith-assert-lower      592
;  :arith-assert-upper      297
;  :arith-bound-prop        77
;  :arith-conflicts         52
;  :arith-eq-adapter        250
;  :arith-fixed-eqs         182
;  :arith-offset-eqs        51
;  :arith-pivots            467
;  :conflicts               92
;  :datatype-accessor-ax    76
;  :datatype-constructor-ax 9
;  :datatype-occurs-check   46
;  :datatype-splits         9
;  :decisions               145
;  :del-clause              1883
;  :final-checks            47
;  :interface-eqs           9
;  :max-generation          6
;  :max-memory              4.90
;  :memory                  4.89
;  :mk-bool-var             3491
;  :mk-clause               1982
;  :num-allocs              198086
;  :num-checks              107
;  :propagations            747
;  :quant-instantiations    969
;  :rlimit-count            269756
;  :time                    0.00)
(pop) ; 10
(push) ; 10
; [else-branch: 68 | !(j@143@00 < |P@69@00| - 1 && 0 <= j@143@00)]
(assert (not (and (< j@143@00 (- (Seq_length P@69@00) 1)) (<= 0 j@143@00))))
(pop) ; 10
(pop) ; 9
; Joined path conditions
; Joined path conditions
(pop) ; 8
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 7
(push) ; 7
; [else-branch: 66 | !(1 < |P@69@00| && t@68@00 < V@66@00 && 0 <= t@68@00 && s@67@00 < V@66@00 && 0 <= s@67@00)]
(assert (not
  (and
    (and
      (and (and (< 1 (Seq_length P@69@00)) (< t@68@00 V@66@00)) (<= 0 t@68@00))
      (< s@67@00 V@66@00))
    (<= 0 s@67@00))))
(pop) ; 7
(pop) ; 6
; Joined path conditions
; Joined path conditions
(pop) ; 5
(push) ; 5
; [else-branch: 61 | !(1 < |P@69@00| && t@68@00 < V@66@00 && 0 <= t@68@00 && s@67@00 < V@66@00 && 0 <= s@67@00 ==> valid_graph_vertices1(_, this@63@00, P@69@00, V@66@00))]
(assert (not
  (implies
    (and
      (and
        (and (and (< 1 (Seq_length P@69@00)) (< t@68@00 V@66@00)) (<= 0 t@68@00))
        (< s@67@00 V@66@00))
      (<= 0 s@67@00))
    (valid_graph_vertices1 $Snap.unit this@63@00 P@69@00 V@66@00))))
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (implies
  (and
    (implies
      (and
        (and
          (and
            (and (< 1 (Seq_length P@69@00)) (< t@68@00 V@66@00))
            (<= 0 t@68@00))
          (< s@67@00 V@66@00))
        (<= 0 s@67@00))
      (valid_graph_vertices1 $Snap.unit this@63@00 P@69@00 V@66@00))
    (and
      (and
        (and (and (< 1 (Seq_length P@69@00)) (< t@68@00 V@66@00)) (<= 0 t@68@00))
        (< s@67@00 V@66@00))
      (<= 0 s@67@00)))
  (valid_graph_vertices1 $Snap.unit this@63@00 P@69@00 V@66@00)))
; Joined path conditions
(pop) ; 3
(push) ; 3
; [else-branch: 55 | !(1 < |P@69@00| && t@68@00 < V@66@00 && 0 <= t@68@00 && s@67@00 < V@66@00 && 0 <= s@67@00 ==> P@69@00[0] != P@69@00[|P@69@00| - 1])]
(assert (not
  (implies
    (and
      (and
        (and (and (< 1 (Seq_length P@69@00)) (< t@68@00 V@66@00)) (<= 0 t@68@00))
        (< s@67@00 V@66@00))
      (<= 0 s@67@00))
    (not
      (= (Seq_index P@69@00 0) (Seq_index P@69@00 (- (Seq_length P@69@00) 1)))))))
(pop) ; 3
(pop) ; 2
; Joined path conditions
(assert (implies
  (implies
    (and
      (and
        (and (and (< 1 (Seq_length P@69@00)) (< t@68@00 V@66@00)) (<= 0 t@68@00))
        (< s@67@00 V@66@00))
      (<= 0 s@67@00))
    (not
      (= (Seq_index P@69@00 0) (Seq_index P@69@00 (- (Seq_length P@69@00) 1)))))
  (and
    (implies
      (and
        (and
          (and
            (and (< 1 (Seq_length P@69@00)) (< t@68@00 V@66@00))
            (<= 0 t@68@00))
          (< s@67@00 V@66@00))
        (<= 0 s@67@00))
      (not
        (= (Seq_index P@69@00 0) (Seq_index P@69@00 (- (Seq_length P@69@00) 1)))))
    (implies
      (and
        (implies
          (and
            (and
              (and
                (and (< 1 (Seq_length P@69@00)) (< t@68@00 V@66@00))
                (<= 0 t@68@00))
              (< s@67@00 V@66@00))
            (<= 0 s@67@00))
          (valid_graph_vertices1 $Snap.unit this@63@00 P@69@00 V@66@00))
        (and
          (and
            (and
              (and (< 1 (Seq_length P@69@00)) (< t@68@00 V@66@00))
              (<= 0 t@68@00))
            (< s@67@00 V@66@00))
          (<= 0 s@67@00)))
      (valid_graph_vertices1 $Snap.unit this@63@00 P@69@00 V@66@00)))))
; Joined path conditions
(assert (=
  result@70@00
  (and
    (and
      (implies
        (and
          (and
            (and
              (and (< 1 (Seq_length P@69@00)) (< t@68@00 V@66@00))
              (<= 0 t@68@00))
            (< s@67@00 V@66@00))
          (<= 0 s@67@00))
        (forall ((j@143@00 Int)) (!
          (implies
            (and (< j@143@00 (- (Seq_length P@69@00) 1)) (<= 0 j@143@00))
            (<
              0
              (Seq_index
                (Seq_index Gf@65@00 (Seq_index P@69@00 j@143@00))
                (Seq_index P@69@00 (+ j@143@00 1)))))
          :pattern ((Seq_index Gf@65@00 (Seq_index P@69@00 j@143@00)))
          :qid |prog.l<no position>|)))
      (implies
        (and
          (and
            (and
              (and (< 1 (Seq_length P@69@00)) (< t@68@00 V@66@00))
              (<= 0 t@68@00))
            (< s@67@00 V@66@00))
          (<= 0 s@67@00))
        (valid_graph_vertices1 $Snap.unit this@63@00 P@69@00 V@66@00)))
    (implies
      (and
        (and
          (and
            (and (< 1 (Seq_length P@69@00)) (< t@68@00 V@66@00))
            (<= 0 t@68@00))
          (< s@67@00 V@66@00))
        (<= 0 s@67@00))
      (not
        (= (Seq_index P@69@00 0) (Seq_index P@69@00 (- (Seq_length P@69@00) 1))))))))
(pop) ; 1
(assert (forall ((s@$ $Snap) (this@63@00 $Ref) (G@64@00 Seq<Seq<Int>>) (Gf@65@00 Seq<Seq<Int>>) (V@66@00 Int) (s@67@00 Int) (t@68@00 Int) (P@69@00 Seq<Int>)) (!
  (implies
    (and
      (not (= this@63@00 $Ref.null))
      (SquareIntMatrix $Snap.unit this@63@00 G@64@00 V@66@00)
      (SquareIntMatrix $Snap.unit this@63@00 Gf@65@00 V@66@00)
      (FlowNetwork $Snap.unit this@63@00 G@64@00 V@66@00 s@67@00 t@68@00)
      (FlowNetwork $Snap.unit this@63@00 Gf@65@00 V@66@00 s@67@00 t@68@00)
      (ValidFlow ($Snap.combine
        $Snap.unit
        ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) this@63@00 G@64@00 Gf@65@00 V@66@00 s@67@00 t@68@00))
    (=
      (AugPath s@$ this@63@00 G@64@00 Gf@65@00 V@66@00 s@67@00 t@68@00 P@69@00)
      (and
        (and
          (implies
            (and
              (and
                (and (and (<= 0 s@67@00) (< s@67@00 V@66@00)) (<= 0 t@68@00))
                (< t@68@00 V@66@00))
              (< 1 (Seq_length P@69@00)))
            (not
              (=
                (Seq_index P@69@00 0)
                (Seq_index P@69@00 (- (Seq_length P@69@00) 1)))))
          (implies
            (and
              (and
                (and (and (<= 0 s@67@00) (< s@67@00 V@66@00)) (<= 0 t@68@00))
                (< t@68@00 V@66@00))
              (< 1 (Seq_length P@69@00)))
            (valid_graph_vertices1 $Snap.unit this@63@00 P@69@00 V@66@00)))
        (implies
          (and
            (and
              (and (and (<= 0 s@67@00) (< s@67@00 V@66@00)) (<= 0 t@68@00))
              (< t@68@00 V@66@00))
            (< 1 (Seq_length P@69@00)))
          (forall ((j Int)) (!
            (implies
              (and (<= 0 j) (< j (- (Seq_length P@69@00) 1)))
              (<
                0
                (Seq_index
                  (Seq_index Gf@65@00 (Seq_index P@69@00 j))
                  (Seq_index P@69@00 (+ j 1)))))
            :pattern ((Seq_index Gf@65@00 (Seq_index P@69@00 j)))
            ))))))
  :pattern ((AugPath s@$ this@63@00 G@64@00 Gf@65@00 V@66@00 s@67@00 t@68@00 P@69@00))
  )))
; ---------- FUNCTION opt_get----------
(declare-fun opt1@71@00 () option<any>)
(declare-fun result@72@00 () any)
; ----- Well-definedness of specifications -----
(push) ; 1
(assert (= s@$ $Snap.unit))
; [eval] opt1 != (None(): option[any])
; [eval] (None(): option[any])
(assert (not (= opt1@71@00 (as None<option<any>>  option<any>))))
(declare-const $t@144@00 $Snap)
(assert (= $t@144@00 $Snap.unit))
; [eval] (some(result): option[any]) == opt1
; [eval] (some(result): option[any])
(assert (= (some<option<any>> result@72@00) opt1@71@00))
(pop) ; 1
(assert (forall ((s@$ $Snap) (opt1@71@00 option<any>)) (!
  (= (opt_get%limited s@$ opt1@71@00) (opt_get s@$ opt1@71@00))
  :pattern ((opt_get s@$ opt1@71@00))
  )))
(assert (forall ((s@$ $Snap) (opt1@71@00 option<any>)) (!
  (opt_get%stateless opt1@71@00)
  :pattern ((opt_get%limited s@$ opt1@71@00))
  )))
(assert (forall ((s@$ $Snap) (opt1@71@00 option<any>)) (!
  (let ((result@72@00 (opt_get%limited s@$ opt1@71@00))) (implies
    (not (= opt1@71@00 (as None<option<any>>  option<any>)))
    (= (some<option<any>> result@72@00) opt1@71@00)))
  :pattern ((opt_get%limited s@$ opt1@71@00))
  )))
; ----- Verification of function body and postcondition -----
(push) ; 1
(assert (= s@$ $Snap.unit))
(assert (not (= opt1@71@00 (as None<option<any>>  option<any>))))
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
; [eval] (option_get(opt1): any)
(assert (= result@72@00 (option_get<any> opt1@71@00)))
; [eval] (some(result): option[any]) == opt1
; [eval] (some(result): option[any])
(set-option :timeout 0)
(push) ; 2
(assert (not (= (some<option<any>> result@72@00) opt1@71@00)))
(check-sat)
; unsat
(pop) ; 2
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1219
;  :arith-add-rows          1162
;  :arith-assert-diseq      143
;  :arith-assert-lower      592
;  :arith-assert-upper      297
;  :arith-bound-prop        77
;  :arith-conflicts         52
;  :arith-eq-adapter        250
;  :arith-fixed-eqs         182
;  :arith-offset-eqs        51
;  :arith-pivots            472
;  :conflicts               93
;  :datatype-accessor-ax    77
;  :datatype-constructor-ax 9
;  :datatype-occurs-check   47
;  :datatype-splits         9
;  :decisions               145
;  :del-clause              1982
;  :final-checks            48
;  :interface-eqs           9
;  :max-generation          6
;  :max-memory              4.90
;  :memory                  4.86
;  :mk-bool-var             3501
;  :mk-clause               1982
;  :num-allocs              199630
;  :num-checks              109
;  :propagations            747
;  :quant-instantiations    971
;  :rlimit-count            272498)
(assert (= (some<option<any>> result@72@00) opt1@71@00))
(pop) ; 1
(assert (forall ((s@$ $Snap) (opt1@71@00 option<any>)) (!
  (implies
    (not (= opt1@71@00 (as None<option<any>>  option<any>)))
    (= (opt_get s@$ opt1@71@00) (option_get<any> opt1@71@00)))
  :pattern ((opt_get s@$ opt1@71@00))
  )))
; ---------- FUNCTION NonNegativeCapacities1----------
(declare-fun this@73@00 () $Ref)
(declare-fun G@74@00 () option<array>)
(declare-fun V@75@00 () Int)
(declare-fun result@76@00 () Bool)
; ----- Well-definedness of specifications -----
(push) ; 1
(assert (= s@$ ($Snap.combine ($Snap.first s@$) ($Snap.second s@$))))
(assert (= ($Snap.first s@$) $Snap.unit))
; [eval] this != null
(assert (not (= this@73@00 $Ref.null)))
(assert (= ($Snap.second s@$) $Snap.unit))
; [eval] SquareIntMatrix1(this, G, V)
(push) ; 2
; [eval] this != null
; [eval] G != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 3
(assert (not (not (= G@74@00 (as None<option<array>>  option<array>)))))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1227
;  :arith-add-rows          1162
;  :arith-assert-diseq      143
;  :arith-assert-lower      592
;  :arith-assert-upper      297
;  :arith-bound-prop        77
;  :arith-conflicts         52
;  :arith-eq-adapter        250
;  :arith-fixed-eqs         182
;  :arith-offset-eqs        51
;  :arith-pivots            472
;  :conflicts               93
;  :datatype-accessor-ax    79
;  :datatype-constructor-ax 9
;  :datatype-occurs-check   48
;  :datatype-splits         9
;  :decisions               145
;  :del-clause              1982
;  :final-checks            49
;  :interface-eqs           9
;  :max-generation          6
;  :max-memory              4.90
;  :memory                  4.86
;  :mk-bool-var             3507
;  :mk-clause               1982
;  :num-allocs              200314
;  :num-checks              110
;  :propagations            747
;  :quant-instantiations    971
;  :rlimit-count            273241)
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; [eval] G != (None(): option[array])
; [eval] (None(): option[array])
(set-option :timeout 0)
(push) ; 3
(assert (not (not (= G@74@00 (as None<option<array>>  option<array>)))))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1228
;  :arith-add-rows          1162
;  :arith-assert-diseq      143
;  :arith-assert-lower      592
;  :arith-assert-upper      297
;  :arith-bound-prop        77
;  :arith-conflicts         52
;  :arith-eq-adapter        250
;  :arith-fixed-eqs         182
;  :arith-offset-eqs        51
;  :arith-pivots            472
;  :conflicts               93
;  :datatype-accessor-ax    79
;  :datatype-constructor-ax 9
;  :datatype-occurs-check   50
;  :datatype-splits         9
;  :decisions               145
;  :del-clause              1982
;  :final-checks            51
;  :interface-eqs           9
;  :max-generation          6
;  :max-memory              4.90
;  :memory                  4.86
;  :mk-bool-var             3508
;  :mk-clause               1982
;  :num-allocs              201039
;  :num-checks              112
;  :propagations            747
;  :quant-instantiations    971
;  :rlimit-count            273966)
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; [eval] G != (None(): option[array])
; [eval] (None(): option[array])
(set-option :timeout 0)
(push) ; 3
(assert (not (not (= G@74@00 (as None<option<array>>  option<array>)))))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1229
;  :arith-add-rows          1162
;  :arith-assert-diseq      143
;  :arith-assert-lower      592
;  :arith-assert-upper      297
;  :arith-bound-prop        77
;  :arith-conflicts         52
;  :arith-eq-adapter        250
;  :arith-fixed-eqs         182
;  :arith-offset-eqs        51
;  :arith-pivots            472
;  :conflicts               93
;  :datatype-accessor-ax    79
;  :datatype-constructor-ax 9
;  :datatype-occurs-check   52
;  :datatype-splits         9
;  :decisions               145
;  :del-clause              1982
;  :final-checks            53
;  :interface-eqs           9
;  :max-generation          6
;  :max-memory              4.90
;  :memory                  4.86
;  :mk-bool-var             3509
;  :mk-clause               1982
;  :num-allocs              201761
;  :num-checks              114
;  :propagations            747
;  :quant-instantiations    971
;  :rlimit-count            274691)
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; [eval] G != (None(): option[array])
; [eval] (None(): option[array])
(set-option :timeout 0)
(push) ; 3
(assert (not (not (= G@74@00 (as None<option<array>>  option<array>)))))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1230
;  :arith-add-rows          1162
;  :arith-assert-diseq      143
;  :arith-assert-lower      592
;  :arith-assert-upper      297
;  :arith-bound-prop        77
;  :arith-conflicts         52
;  :arith-eq-adapter        250
;  :arith-fixed-eqs         182
;  :arith-offset-eqs        51
;  :arith-pivots            472
;  :conflicts               93
;  :datatype-accessor-ax    79
;  :datatype-constructor-ax 9
;  :datatype-occurs-check   54
;  :datatype-splits         9
;  :decisions               145
;  :del-clause              1982
;  :final-checks            55
;  :interface-eqs           9
;  :max-generation          6
;  :max-memory              4.90
;  :memory                  4.86
;  :mk-bool-var             3510
;  :mk-clause               1982
;  :num-allocs              202483
;  :num-checks              116
;  :propagations            747
;  :quant-instantiations    971
;  :rlimit-count            275416)
(pop) ; 2
(pop) ; 1
; ---------- FUNCTION as_any----------
(declare-fun t@77@00 () any)
(declare-fun result@78@00 () any)
; ----- Well-definedness of specifications -----
(push) ; 1
(declare-const $t@145@00 $Snap)
(assert (= $t@145@00 $Snap.unit))
; [eval] any_as(result) == t
; [eval] any_as(result)
(push) ; 2
(pop) ; 2
; Joined path conditions
(assert (= (any_as $Snap.unit result@78@00) t@77@00))
(pop) ; 1
(assert (forall ((s@$ $Snap) (t@77@00 any)) (!
  (= (as_any%limited s@$ t@77@00) (as_any s@$ t@77@00))
  :pattern ((as_any s@$ t@77@00))
  )))
(assert (forall ((s@$ $Snap) (t@77@00 any)) (!
  (as_any%stateless t@77@00)
  :pattern ((as_any%limited s@$ t@77@00))
  )))
(assert (forall ((s@$ $Snap) (t@77@00 any)) (!
  (let ((result@78@00 (as_any%limited s@$ t@77@00))) (=
    (any_as $Snap.unit result@78@00)
    t@77@00))
  :pattern ((as_any%limited s@$ t@77@00))
  )))
; ---------- FUNCTION valid_graph_vertices----------
(declare-fun this@79@00 () $Ref)
(declare-fun p@80@00 () option<array>)
(declare-fun V@81@00 () Int)
(declare-fun result@82@00 () Bool)
; ----- Well-definedness of specifications -----
(push) ; 1
(assert (= s@$ ($Snap.combine ($Snap.first s@$) ($Snap.second s@$))))
(assert (= ($Snap.first s@$) $Snap.unit))
; [eval] this != null
(assert (not (= this@79@00 $Ref.null)))
(assert (=
  ($Snap.second s@$)
  ($Snap.combine
    ($Snap.first ($Snap.second s@$))
    ($Snap.second ($Snap.second s@$)))))
(assert (= ($Snap.first ($Snap.second s@$)) $Snap.unit))
; [eval] p != (None(): option[array])
; [eval] (None(): option[array])
(assert (not (= p@80@00 (as None<option<array>>  option<array>))))
(assert (=
  ($Snap.second ($Snap.second s@$))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second s@$)))
    ($Snap.second ($Snap.second ($Snap.second s@$))))))
(assert (= ($Snap.first ($Snap.second ($Snap.second s@$))) $Snap.unit))
; [eval] alen(opt_get1(p)) == V
; [eval] alen(opt_get1(p))
; [eval] opt_get1(p)
(push) ; 2
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 2
; Joined path conditions
(assert (= (alen<Int> (opt_get1 $Snap.unit p@80@00)) V@81@00))
(declare-const i1@146@00 Int)
(push) ; 2
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 3
; [then-branch: 69 | 0 <= i1@146@00 | live]
; [else-branch: 69 | !(0 <= i1@146@00) | live]
(push) ; 4
; [then-branch: 69 | 0 <= i1@146@00]
(assert (<= 0 i1@146@00))
; [eval] i1 < V
(pop) ; 4
(push) ; 4
; [else-branch: 69 | !(0 <= i1@146@00)]
(assert (not (<= 0 i1@146@00)))
(pop) ; 4
(pop) ; 3
; Joined path conditions
; Joined path conditions
(assert (and (< i1@146@00 V@81@00) (<= 0 i1@146@00)))
; [eval] aloc(opt_get1(p), i1)
; [eval] opt_get1(p)
(push) ; 3
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 3
; Joined path conditions
(push) ; 3
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 4
(assert (not (< i1@146@00 (alen<Int> (opt_get1 $Snap.unit p@80@00)))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1254
;  :arith-add-rows          1163
;  :arith-assert-diseq      143
;  :arith-assert-lower      595
;  :arith-assert-upper      299
;  :arith-bound-prop        77
;  :arith-conflicts         52
;  :arith-eq-adapter        251
;  :arith-fixed-eqs         183
;  :arith-offset-eqs        51
;  :arith-pivots            474
;  :conflicts               93
;  :datatype-accessor-ax    84
;  :datatype-constructor-ax 9
;  :datatype-occurs-check   54
;  :datatype-splits         9
;  :decisions               145
;  :del-clause              1982
;  :final-checks            55
;  :interface-eqs           9
;  :max-generation          6
;  :max-memory              4.90
;  :memory                  4.86
;  :mk-bool-var             3532
;  :mk-clause               1982
;  :num-allocs              203340
;  :num-checks              117
;  :propagations            747
;  :quant-instantiations    976
;  :rlimit-count            276594)
(assert (< i1@146@00 (alen<Int> (opt_get1 $Snap.unit p@80@00))))
(pop) ; 3
; Joined path conditions
(assert (< i1@146@00 (alen<Int> (opt_get1 $Snap.unit p@80@00))))
(declare-const $k@147@00 $Perm)
(assert ($Perm.isReadVar $k@147@00 $Perm.Write))
(pop) ; 2
(declare-fun inv@148@00 ($Snap $Ref option<array> Int $Ref) Int)
; Nested auxiliary terms: globals
(assert ($Perm.isReadVar $k@147@00 $Perm.Write))
; Nested auxiliary terms: non-globals
(assert (forall ((i1@146@00 Int)) (!
  (< i1@146@00 (alen<Int> (opt_get1 $Snap.unit p@80@00)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@80@00) i1@146@00))
  :qid |int-aux|)))
(push) ; 2
(assert (not (forall ((i1@146@00 Int)) (!
  (implies
    (and (< i1@146@00 V@81@00) (<= 0 i1@146@00))
    (or (= $k@147@00 $Perm.No) (< $Perm.No $k@147@00)))
  
  ))))
(check-sat)
; unsat
(pop) ; 2
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1256
;  :arith-add-rows          1163
;  :arith-assert-diseq      144
;  :arith-assert-lower      597
;  :arith-assert-upper      300
;  :arith-bound-prop        77
;  :arith-conflicts         52
;  :arith-eq-adapter        252
;  :arith-fixed-eqs         183
;  :arith-offset-eqs        51
;  :arith-pivots            476
;  :conflicts               94
;  :datatype-accessor-ax    85
;  :datatype-constructor-ax 9
;  :datatype-occurs-check   54
;  :datatype-splits         9
;  :decisions               145
;  :del-clause              1982
;  :final-checks            55
;  :interface-eqs           9
;  :max-generation          6
;  :max-memory              4.90
;  :memory                  4.86
;  :mk-bool-var             3539
;  :mk-clause               1984
;  :num-allocs              203827
;  :num-checks              118
;  :propagations            748
;  :quant-instantiations    976
;  :rlimit-count            277169)
; Check receiver injectivity
(push) ; 2
(assert (not (forall ((i11@146@00 Int) (i12@146@00 Int)) (!
  (implies
    (and
      (and (and (< i11@146@00 V@81@00) (<= 0 i11@146@00)) (< $Perm.No $k@147@00))
      (and (and (< i12@146@00 V@81@00) (<= 0 i12@146@00)) (< $Perm.No $k@147@00))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@80@00) i11@146@00)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@80@00) i12@146@00)))
    (= i11@146@00 i12@146@00))
  
  :qid |int-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 2
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1276
;  :arith-add-rows          1185
;  :arith-assert-diseq      145
;  :arith-assert-lower      603
;  :arith-assert-upper      305
;  :arith-bound-prop        79
;  :arith-conflicts         53
;  :arith-eq-adapter        254
;  :arith-fixed-eqs         184
;  :arith-offset-eqs        52
;  :arith-pivots            488
;  :conflicts               96
;  :datatype-accessor-ax    85
;  :datatype-constructor-ax 9
;  :datatype-occurs-check   54
;  :datatype-splits         9
;  :decisions               146
;  :del-clause              1999
;  :final-checks            55
;  :interface-eqs           9
;  :max-generation          6
;  :max-memory              4.90
;  :memory                  4.86
;  :mk-bool-var             3563
;  :mk-clause               2001
;  :num-allocs              204186
;  :num-checks              119
;  :propagations            763
;  :quant-instantiations    986
;  :rlimit-count            278327)
; Definitional axioms for inverse functions
(assert (forall ((i1@146@00 Int)) (!
  (implies
    (and (and (< i1@146@00 V@81@00) (<= 0 i1@146@00)) (< $Perm.No $k@147@00))
    (=
      (inv@148@00 s@$ this@79@00 p@80@00 V@81@00 (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit p@80@00) i1@146@00))
      i1@146@00))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@80@00) i1@146@00))
  )))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (< (inv@148@00 s@$ this@79@00 p@80@00 V@81@00 r) V@81@00)
        (<= 0 (inv@148@00 s@$ this@79@00 p@80@00 V@81@00 r)))
      (< $Perm.No $k@147@00))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@80@00) (inv@148@00 s@$ this@79@00 p@80@00 V@81@00 r))
      r))
  :pattern ((inv@148@00 s@$ this@79@00 p@80@00 V@81@00 r))
  :qid |int-fctOfInv|)))
; Permissions are non-negative
(assert (forall ((i1@146@00 Int)) (!
  (<= $Perm.No $k@147@00)
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@80@00) i1@146@00))
  :qid |int-permAtLeastZero|)))
; Field permissions are at most one
(assert (forall ((i1@146@00 Int)) (!
  (<= $k@147@00 $Perm.Write)
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@80@00) i1@146@00))
  :qid |int-permAtMostOne|)))
; Permission implies non-null receiver
(assert (forall ((i1@146@00 Int)) (!
  (implies
    (and (and (< i1@146@00 V@81@00) (<= 0 i1@146@00)) (< $Perm.No $k@147@00))
    (not
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@80@00) i1@146@00)
        $Ref.null)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@80@00) i1@146@00))
  :qid |int-permImpliesNonNull|)))
(declare-fun sm@149@00 ($Snap $Ref option<array> Int) $FVF<Int>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and
        (< (inv@148@00 s@$ this@79@00 p@80@00 V@81@00 r) V@81@00)
        (<= 0 (inv@148@00 s@$ this@79@00 p@80@00 V@81@00 r)))
      (< $Perm.No $k@147@00)
      false)
    (=
      ($FVF.lookup_int (sm@149@00 s@$ this@79@00 p@80@00 V@81@00) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second s@$)))) r)))
  :pattern (($FVF.lookup_int (sm@149@00 s@$ this@79@00 p@80@00 V@81@00) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second s@$)))) r))
  :qid |qp.fvfValDef7|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second s@$)))) r) r)
  :pattern (($FVF.lookup_int (sm@149@00 s@$ this@79@00 p@80@00 V@81@00) r))
  :qid |qp.fvfResTrgDef8|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (< (inv@148@00 s@$ this@79@00 p@80@00 V@81@00 r) V@81@00)
      (<= 0 (inv@148@00 s@$ this@79@00 p@80@00 V@81@00 r)))
    ($FVF.loc_int ($FVF.lookup_int (sm@149@00 s@$ this@79@00 p@80@00 V@81@00) r) r))
  :pattern ((inv@148@00 s@$ this@79@00 p@80@00 V@81@00 r))
  )))
(pop) ; 1
(assert (forall ((s@$ $Snap) (this@79@00 $Ref) (p@80@00 option<array>) (V@81@00 Int)) (!
  (=
    (valid_graph_vertices%limited s@$ this@79@00 p@80@00 V@81@00)
    (valid_graph_vertices s@$ this@79@00 p@80@00 V@81@00))
  :pattern ((valid_graph_vertices s@$ this@79@00 p@80@00 V@81@00))
  )))
(assert (forall ((s@$ $Snap) (this@79@00 $Ref) (p@80@00 option<array>) (V@81@00 Int)) (!
  (valid_graph_vertices%stateless this@79@00 p@80@00 V@81@00)
  :pattern ((valid_graph_vertices%limited s@$ this@79@00 p@80@00 V@81@00))
  )))
; ----- Verification of function body and postcondition -----
(push) ; 1
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (< (inv@148@00 s@$ this@79@00 p@80@00 V@81@00 r) V@81@00)
        (<= 0 (inv@148@00 s@$ this@79@00 p@80@00 V@81@00 r)))
      (< $Perm.No $k@147@00))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@80@00) (inv@148@00 s@$ this@79@00 p@80@00 V@81@00 r))
      r))
  :pattern ((inv@148@00 s@$ this@79@00 p@80@00 V@81@00 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and
        (< (inv@148@00 s@$ this@79@00 p@80@00 V@81@00 r) V@81@00)
        (<= 0 (inv@148@00 s@$ this@79@00 p@80@00 V@81@00 r)))
      (< $Perm.No $k@147@00)
      false)
    (=
      ($FVF.lookup_int (sm@149@00 s@$ this@79@00 p@80@00 V@81@00) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second s@$)))) r)))
  :pattern (($FVF.lookup_int (sm@149@00 s@$ this@79@00 p@80@00 V@81@00) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second s@$)))) r))
  :qid |qp.fvfValDef7|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second s@$)))) r) r)
  :pattern (($FVF.lookup_int (sm@149@00 s@$ this@79@00 p@80@00 V@81@00) r))
  :qid |qp.fvfResTrgDef8|)))
(assert (forall ((i1@146@00 Int)) (!
  (implies
    (and (and (< i1@146@00 V@81@00) (<= 0 i1@146@00)) (< $Perm.No $k@147@00))
    (=
      (inv@148@00 s@$ this@79@00 p@80@00 V@81@00 (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit p@80@00) i1@146@00))
      i1@146@00))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@80@00) i1@146@00))
  )))
(assert (forall ((i1@146@00 Int)) (!
  (<= $Perm.No $k@147@00)
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@80@00) i1@146@00))
  :qid |int-permAtLeastZero|)))
(assert (forall ((i1@146@00 Int)) (!
  (<= $k@147@00 $Perm.Write)
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@80@00) i1@146@00))
  :qid |int-permAtMostOne|)))
(assert (forall ((i1@146@00 Int)) (!
  (implies
    (and (and (< i1@146@00 V@81@00) (<= 0 i1@146@00)) (< $Perm.No $k@147@00))
    (not
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@80@00) i1@146@00)
        $Ref.null)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@80@00) i1@146@00))
  :qid |int-permImpliesNonNull|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (< (inv@148@00 s@$ this@79@00 p@80@00 V@81@00 r) V@81@00)
      (<= 0 (inv@148@00 s@$ this@79@00 p@80@00 V@81@00 r)))
    ($FVF.loc_int ($FVF.lookup_int (sm@149@00 s@$ this@79@00 p@80@00 V@81@00) r) r))
  :pattern ((inv@148@00 s@$ this@79@00 p@80@00 V@81@00 r))
  )))
(assert ($Perm.isReadVar $k@147@00 $Perm.Write))
(assert (= s@$ ($Snap.combine ($Snap.first s@$) ($Snap.second s@$))))
(assert (= ($Snap.first s@$) $Snap.unit))
(assert (not (= this@79@00 $Ref.null)))
(assert (=
  ($Snap.second s@$)
  ($Snap.combine
    ($Snap.first ($Snap.second s@$))
    ($Snap.second ($Snap.second s@$)))))
(assert (= ($Snap.first ($Snap.second s@$)) $Snap.unit))
(assert (not (= p@80@00 (as None<option<array>>  option<array>))))
(assert (=
  ($Snap.second ($Snap.second s@$))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second s@$)))
    ($Snap.second ($Snap.second ($Snap.second s@$))))))
(assert (= ($Snap.first ($Snap.second ($Snap.second s@$))) $Snap.unit))
(assert (= (alen<Int> (opt_get1 $Snap.unit p@80@00)) V@81@00))
(assert (forall ((i1@146@00 Int)) (!
  (< i1@146@00 (alen<Int> (opt_get1 $Snap.unit p@80@00)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@80@00) i1@146@00))
  :qid |int-aux|)))
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
; [eval] (forall unknown1: Int :: { aloc(opt_get1(p), unknown1) } 0 <= unknown1 && unknown1 < alen(opt_get1(p)) ==> 0 <= aloc(opt_get1(p), unknown1).int) && (forall unknown1: Int :: { aloc(opt_get1(p), unknown1) } 0 <= unknown1 && unknown1 < alen(opt_get1(p)) ==> aloc(opt_get1(p), unknown1).int < V)
; [eval] (forall unknown1: Int :: { aloc(opt_get1(p), unknown1) } 0 <= unknown1 && unknown1 < alen(opt_get1(p)) ==> 0 <= aloc(opt_get1(p), unknown1).int)
(declare-const unknown1@150@00 Int)
(push) ; 2
; [eval] 0 <= unknown1 && unknown1 < alen(opt_get1(p)) ==> 0 <= aloc(opt_get1(p), unknown1).int
; [eval] 0 <= unknown1 && unknown1 < alen(opt_get1(p))
; [eval] 0 <= unknown1
(push) ; 3
; [then-branch: 70 | 0 <= unknown1@150@00 | live]
; [else-branch: 70 | !(0 <= unknown1@150@00) | live]
(push) ; 4
; [then-branch: 70 | 0 <= unknown1@150@00]
(assert (<= 0 unknown1@150@00))
; [eval] unknown1 < alen(opt_get1(p))
; [eval] alen(opt_get1(p))
; [eval] opt_get1(p)
(push) ; 5
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 5
; Joined path conditions
(pop) ; 4
(push) ; 4
; [else-branch: 70 | !(0 <= unknown1@150@00)]
(assert (not (<= 0 unknown1@150@00)))
(pop) ; 4
(pop) ; 3
; Joined path conditions
; Joined path conditions
(push) ; 3
; [then-branch: 71 | unknown1@150@00 < alen[Int](opt_get1(_, p@80@00)) && 0 <= unknown1@150@00 | live]
; [else-branch: 71 | !(unknown1@150@00 < alen[Int](opt_get1(_, p@80@00)) && 0 <= unknown1@150@00) | live]
(push) ; 4
; [then-branch: 71 | unknown1@150@00 < alen[Int](opt_get1(_, p@80@00)) && 0 <= unknown1@150@00]
(assert (and
  (< unknown1@150@00 (alen<Int> (opt_get1 $Snap.unit p@80@00)))
  (<= 0 unknown1@150@00)))
; [eval] 0 <= aloc(opt_get1(p), unknown1).int
; [eval] aloc(opt_get1(p), unknown1)
; [eval] opt_get1(p)
(push) ; 5
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 5
; Joined path conditions
(push) ; 5
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(pop) ; 5
; Joined path conditions
(assert ($FVF.loc_int ($FVF.lookup_int (sm@149@00 s@$ this@79@00 p@80@00 V@81@00) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit p@80@00) unknown1@150@00)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit p@80@00) unknown1@150@00)))
(set-option :timeout 0)
(push) ; 5
(assert (not (ite
  (and
    (<
      (inv@148@00 s@$ this@79@00 p@80@00 V@81@00 (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit p@80@00) unknown1@150@00))
      V@81@00)
    (<=
      0
      (inv@148@00 s@$ this@79@00 p@80@00 V@81@00 (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit p@80@00) unknown1@150@00))))
  (< $Perm.No $k@147@00)
  false)))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1316
;  :arith-add-rows          1189
;  :arith-assert-diseq      146
;  :arith-assert-lower      610
;  :arith-assert-upper      310
;  :arith-bound-prop        82
;  :arith-conflicts         53
;  :arith-eq-adapter        257
;  :arith-fixed-eqs         186
;  :arith-offset-eqs        55
;  :arith-pivots            491
;  :conflicts               97
;  :datatype-accessor-ax    90
;  :datatype-constructor-ax 10
;  :datatype-occurs-check   57
;  :datatype-splits         10
;  :decisions               147
;  :del-clause              2003
;  :final-checks            57
;  :interface-eqs           9
;  :max-generation          6
;  :max-memory              4.90
;  :memory                  4.88
;  :mk-bool-var             3614
;  :mk-clause               2011
;  :num-allocs              207017
;  :num-checks              121
;  :propagations            768
;  :quant-instantiations    1001
;  :rlimit-count            282892)
(pop) ; 4
(push) ; 4
; [else-branch: 71 | !(unknown1@150@00 < alen[Int](opt_get1(_, p@80@00)) && 0 <= unknown1@150@00)]
(assert (not
  (and
    (< unknown1@150@00 (alen<Int> (opt_get1 $Snap.unit p@80@00)))
    (<= 0 unknown1@150@00))))
(pop) ; 4
(pop) ; 3
; Joined path conditions
(assert (implies
  (and
    (< unknown1@150@00 (alen<Int> (opt_get1 $Snap.unit p@80@00)))
    (<= 0 unknown1@150@00))
  (and
    (< unknown1@150@00 (alen<Int> (opt_get1 $Snap.unit p@80@00)))
    (<= 0 unknown1@150@00)
    ($FVF.loc_int ($FVF.lookup_int (sm@149@00 s@$ this@79@00 p@80@00 V@81@00) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit p@80@00) unknown1@150@00)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit p@80@00) unknown1@150@00)))))
; Joined path conditions
(pop) ; 2
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((unknown1@150@00 Int)) (!
  (implies
    (and
      (< unknown1@150@00 (alen<Int> (opt_get1 $Snap.unit p@80@00)))
      (<= 0 unknown1@150@00))
    (and
      (< unknown1@150@00 (alen<Int> (opt_get1 $Snap.unit p@80@00)))
      (<= 0 unknown1@150@00)
      ($FVF.loc_int ($FVF.lookup_int (sm@149@00 s@$ this@79@00 p@80@00 V@81@00) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit p@80@00) unknown1@150@00)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit p@80@00) unknown1@150@00))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@80@00) unknown1@150@00))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(push) ; 2
; [then-branch: 72 | QA unknown1@150@00 :: unknown1@150@00 < alen[Int](opt_get1(_, p@80@00)) && 0 <= unknown1@150@00 ==> 0 <= Lookup(int,sm@149@00(s@$, this@79@00, p@80@00, V@81@00),aloc((_, _), opt_get1(_, p@80@00), unknown1@150@00)) | live]
; [else-branch: 72 | !(QA unknown1@150@00 :: unknown1@150@00 < alen[Int](opt_get1(_, p@80@00)) && 0 <= unknown1@150@00 ==> 0 <= Lookup(int,sm@149@00(s@$, this@79@00, p@80@00, V@81@00),aloc((_, _), opt_get1(_, p@80@00), unknown1@150@00))) | live]
(push) ; 3
; [then-branch: 72 | QA unknown1@150@00 :: unknown1@150@00 < alen[Int](opt_get1(_, p@80@00)) && 0 <= unknown1@150@00 ==> 0 <= Lookup(int,sm@149@00(s@$, this@79@00, p@80@00, V@81@00),aloc((_, _), opt_get1(_, p@80@00), unknown1@150@00))]
(assert (forall ((unknown1@150@00 Int)) (!
  (implies
    (and
      (< unknown1@150@00 (alen<Int> (opt_get1 $Snap.unit p@80@00)))
      (<= 0 unknown1@150@00))
    (<=
      0
      ($FVF.lookup_int (sm@149@00 s@$ this@79@00 p@80@00 V@81@00) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit p@80@00) unknown1@150@00))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@80@00) unknown1@150@00))
  :qid |prog.l<no position>|)))
; [eval] (forall unknown1: Int :: { aloc(opt_get1(p), unknown1) } 0 <= unknown1 && unknown1 < alen(opt_get1(p)) ==> aloc(opt_get1(p), unknown1).int < V)
(declare-const unknown1@151@00 Int)
(push) ; 4
; [eval] 0 <= unknown1 && unknown1 < alen(opt_get1(p)) ==> aloc(opt_get1(p), unknown1).int < V
; [eval] 0 <= unknown1 && unknown1 < alen(opt_get1(p))
; [eval] 0 <= unknown1
(push) ; 5
; [then-branch: 73 | 0 <= unknown1@151@00 | live]
; [else-branch: 73 | !(0 <= unknown1@151@00) | live]
(push) ; 6
; [then-branch: 73 | 0 <= unknown1@151@00]
(assert (<= 0 unknown1@151@00))
; [eval] unknown1 < alen(opt_get1(p))
; [eval] alen(opt_get1(p))
; [eval] opt_get1(p)
(push) ; 7
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 7
; Joined path conditions
(pop) ; 6
(push) ; 6
; [else-branch: 73 | !(0 <= unknown1@151@00)]
(assert (not (<= 0 unknown1@151@00)))
(pop) ; 6
(pop) ; 5
; Joined path conditions
; Joined path conditions
(push) ; 5
; [then-branch: 74 | unknown1@151@00 < alen[Int](opt_get1(_, p@80@00)) && 0 <= unknown1@151@00 | live]
; [else-branch: 74 | !(unknown1@151@00 < alen[Int](opt_get1(_, p@80@00)) && 0 <= unknown1@151@00) | live]
(push) ; 6
; [then-branch: 74 | unknown1@151@00 < alen[Int](opt_get1(_, p@80@00)) && 0 <= unknown1@151@00]
(assert (and
  (< unknown1@151@00 (alen<Int> (opt_get1 $Snap.unit p@80@00)))
  (<= 0 unknown1@151@00)))
; [eval] aloc(opt_get1(p), unknown1).int < V
; [eval] aloc(opt_get1(p), unknown1)
; [eval] opt_get1(p)
(push) ; 7
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 7
; Joined path conditions
(push) ; 7
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(pop) ; 7
; Joined path conditions
(assert ($FVF.loc_int ($FVF.lookup_int (sm@149@00 s@$ this@79@00 p@80@00 V@81@00) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit p@80@00) unknown1@151@00)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit p@80@00) unknown1@151@00)))
(push) ; 7
(assert (not (ite
  (and
    (<
      (inv@148@00 s@$ this@79@00 p@80@00 V@81@00 (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit p@80@00) unknown1@151@00))
      V@81@00)
    (<=
      0
      (inv@148@00 s@$ this@79@00 p@80@00 V@81@00 (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit p@80@00) unknown1@151@00))))
  (< $Perm.No $k@147@00)
  false)))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1330
;  :arith-add-rows          1194
;  :arith-assert-diseq      146
;  :arith-assert-lower      615
;  :arith-assert-upper      313
;  :arith-bound-prop        85
;  :arith-conflicts         53
;  :arith-eq-adapter        259
;  :arith-fixed-eqs         188
;  :arith-offset-eqs        58
;  :arith-pivots            497
;  :conflicts               98
;  :datatype-accessor-ax    90
;  :datatype-constructor-ax 10
;  :datatype-occurs-check   57
;  :datatype-splits         10
;  :decisions               147
;  :del-clause              2011
;  :final-checks            57
;  :interface-eqs           9
;  :max-generation          6
;  :max-memory              4.90
;  :memory                  4.88
;  :mk-bool-var             3641
;  :mk-clause               2019
;  :num-allocs              207867
;  :num-checks              122
;  :propagations            772
;  :quant-instantiations    1013
;  :rlimit-count            284506)
(pop) ; 6
(push) ; 6
; [else-branch: 74 | !(unknown1@151@00 < alen[Int](opt_get1(_, p@80@00)) && 0 <= unknown1@151@00)]
(assert (not
  (and
    (< unknown1@151@00 (alen<Int> (opt_get1 $Snap.unit p@80@00)))
    (<= 0 unknown1@151@00))))
(pop) ; 6
(pop) ; 5
; Joined path conditions
(assert (implies
  (and
    (< unknown1@151@00 (alen<Int> (opt_get1 $Snap.unit p@80@00)))
    (<= 0 unknown1@151@00))
  (and
    (< unknown1@151@00 (alen<Int> (opt_get1 $Snap.unit p@80@00)))
    (<= 0 unknown1@151@00)
    ($FVF.loc_int ($FVF.lookup_int (sm@149@00 s@$ this@79@00 p@80@00 V@81@00) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit p@80@00) unknown1@151@00)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit p@80@00) unknown1@151@00)))))
; Joined path conditions
(pop) ; 4
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((unknown1@151@00 Int)) (!
  (implies
    (and
      (< unknown1@151@00 (alen<Int> (opt_get1 $Snap.unit p@80@00)))
      (<= 0 unknown1@151@00))
    (and
      (< unknown1@151@00 (alen<Int> (opt_get1 $Snap.unit p@80@00)))
      (<= 0 unknown1@151@00)
      ($FVF.loc_int ($FVF.lookup_int (sm@149@00 s@$ this@79@00 p@80@00 V@81@00) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit p@80@00) unknown1@151@00)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit p@80@00) unknown1@151@00))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@80@00) unknown1@151@00))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 3
(push) ; 3
; [else-branch: 72 | !(QA unknown1@150@00 :: unknown1@150@00 < alen[Int](opt_get1(_, p@80@00)) && 0 <= unknown1@150@00 ==> 0 <= Lookup(int,sm@149@00(s@$, this@79@00, p@80@00, V@81@00),aloc((_, _), opt_get1(_, p@80@00), unknown1@150@00)))]
(assert (not
  (forall ((unknown1@150@00 Int)) (!
    (implies
      (and
        (< unknown1@150@00 (alen<Int> (opt_get1 $Snap.unit p@80@00)))
        (<= 0 unknown1@150@00))
      (<=
        0
        ($FVF.lookup_int (sm@149@00 s@$ this@79@00 p@80@00 V@81@00) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit p@80@00) unknown1@150@00))))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@80@00) unknown1@150@00))
    :qid |prog.l<no position>|))))
(pop) ; 3
(pop) ; 2
; Joined path conditions
(assert (implies
  (forall ((unknown1@150@00 Int)) (!
    (implies
      (and
        (< unknown1@150@00 (alen<Int> (opt_get1 $Snap.unit p@80@00)))
        (<= 0 unknown1@150@00))
      (<=
        0
        ($FVF.lookup_int (sm@149@00 s@$ this@79@00 p@80@00 V@81@00) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit p@80@00) unknown1@150@00))))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@80@00) unknown1@150@00))
    :qid |prog.l<no position>|))
  (and
    (forall ((unknown1@150@00 Int)) (!
      (implies
        (and
          (< unknown1@150@00 (alen<Int> (opt_get1 $Snap.unit p@80@00)))
          (<= 0 unknown1@150@00))
        (<=
          0
          ($FVF.lookup_int (sm@149@00 s@$ this@79@00 p@80@00 V@81@00) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit p@80@00) unknown1@150@00))))
      :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@80@00) unknown1@150@00))
      :qid |prog.l<no position>|))
    (forall ((unknown1@151@00 Int)) (!
      (implies
        (and
          (< unknown1@151@00 (alen<Int> (opt_get1 $Snap.unit p@80@00)))
          (<= 0 unknown1@151@00))
        (and
          (< unknown1@151@00 (alen<Int> (opt_get1 $Snap.unit p@80@00)))
          (<= 0 unknown1@151@00)
          ($FVF.loc_int ($FVF.lookup_int (sm@149@00 s@$ this@79@00 p@80@00 V@81@00) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit p@80@00) unknown1@151@00)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit p@80@00) unknown1@151@00))))
      :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@80@00) unknown1@151@00))
      :qid |prog.l<no position>-aux|)))))
; Joined path conditions
(assert (=
  result@82@00
  (and
    (forall ((unknown1@151@00 Int)) (!
      (implies
        (and
          (< unknown1@151@00 (alen<Int> (opt_get1 $Snap.unit p@80@00)))
          (<= 0 unknown1@151@00))
        (<
          ($FVF.lookup_int (sm@149@00 s@$ this@79@00 p@80@00 V@81@00) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit p@80@00) unknown1@151@00))
          V@81@00))
      :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@80@00) unknown1@151@00))
      :qid |prog.l<no position>|))
    (forall ((unknown1@150@00 Int)) (!
      (implies
        (and
          (< unknown1@150@00 (alen<Int> (opt_get1 $Snap.unit p@80@00)))
          (<= 0 unknown1@150@00))
        (<=
          0
          ($FVF.lookup_int (sm@149@00 s@$ this@79@00 p@80@00 V@81@00) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit p@80@00) unknown1@150@00))))
      :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@80@00) unknown1@150@00))
      :qid |prog.l<no position>|)))))
(pop) ; 1
(assert (forall ((s@$ $Snap) (this@79@00 $Ref) (p@80@00 option<array>) (V@81@00 Int)) (!
  (and
    (forall ((i1@146@00 Int)) (!
      (implies
        (and (and (< i1@146@00 V@81@00) (<= 0 i1@146@00)) (< $Perm.No $k@147@00))
        (=
          (inv@148@00 s@$ this@79@00 p@80@00 V@81@00 (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit p@80@00) i1@146@00))
          i1@146@00))
      :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@80@00) i1@146@00))
      ))
    (forall ((r $Ref)) (!
      (implies
        (and
          (and
            (< (inv@148@00 s@$ this@79@00 p@80@00 V@81@00 r) V@81@00)
            (<= 0 (inv@148@00 s@$ this@79@00 p@80@00 V@81@00 r)))
          (< $Perm.No $k@147@00))
        (=
          (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@80@00) (inv@148@00 s@$ this@79@00 p@80@00 V@81@00 r))
          r))
      :pattern ((inv@148@00 s@$ this@79@00 p@80@00 V@81@00 r))
      :qid |int-fctOfInv|))
    (forall ((r $Ref)) (!
      (implies
        (ite
          (and
            (< (inv@148@00 s@$ this@79@00 p@80@00 V@81@00 r) V@81@00)
            (<= 0 (inv@148@00 s@$ this@79@00 p@80@00 V@81@00 r)))
          (< $Perm.No $k@147@00)
          false)
        (=
          ($FVF.lookup_int (sm@149@00 s@$ this@79@00 p@80@00 V@81@00) r)
          ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second s@$)))) r)))
      :pattern (($FVF.lookup_int (sm@149@00 s@$ this@79@00 p@80@00 V@81@00) r))
      :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second s@$)))) r))
      :qid |qp.fvfValDef7|))
    (forall ((r $Ref)) (!
      ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second s@$)))) r) r)
      :pattern (($FVF.lookup_int (sm@149@00 s@$ this@79@00 p@80@00 V@81@00) r))
      :qid |qp.fvfResTrgDef8|))
    ($Perm.isReadVar $k@147@00 $Perm.Write)
    (implies
      (and
        (not (= this@79@00 $Ref.null))
        (not (= p@80@00 (as None<option<array>>  option<array>)))
        (= (alen<Int> (opt_get1 $Snap.unit p@80@00)) V@81@00))
      (=
        (valid_graph_vertices s@$ this@79@00 p@80@00 V@81@00)
        (and
          (forall ((unknown1 Int)) (!
            (implies
              (and
                (<= 0 unknown1)
                (< unknown1 (alen<Int> (opt_get1 $Snap.unit p@80@00))))
              (<=
                0
                ($FVF.lookup_int (sm@149@00 s@$ this@79@00 p@80@00 V@81@00) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit p@80@00) unknown1))))
            :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@80@00) unknown1))
            ))
          (forall ((unknown1 Int)) (!
            (implies
              (and
                (<= 0 unknown1)
                (< unknown1 (alen<Int> (opt_get1 $Snap.unit p@80@00))))
              (<
                ($FVF.lookup_int (sm@149@00 s@$ this@79@00 p@80@00 V@81@00) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit p@80@00) unknown1))
                V@81@00))
            :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@80@00) unknown1))
            ))))))
  :pattern ((valid_graph_vertices s@$ this@79@00 p@80@00 V@81@00))
  )))
; ---------- FUNCTION type----------
(declare-fun type1@83@00 () $Ref)
(declare-fun result@84@00 () Int)
; ----- Well-definedness of specifications -----
(push) ; 1
(declare-const $t@152@00 $Snap)
(assert (= $t@152@00 ($Snap.combine ($Snap.first $t@152@00) ($Snap.second $t@152@00))))
(assert (= ($Snap.first $t@152@00) $Snap.unit))
; [eval] 0 <= result
(assert (<= 0 result@84@00))
(assert (=
  ($Snap.second $t@152@00)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@152@00))
    ($Snap.second ($Snap.second $t@152@00)))))
(assert (= ($Snap.first ($Snap.second $t@152@00)) $Snap.unit))
; [eval] result < 2 + 1
; [eval] 2 + 1
(assert (< result@84@00 3))
(assert (=
  ($Snap.second ($Snap.second $t@152@00))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second $t@152@00)))
    ($Snap.second ($Snap.second ($Snap.second $t@152@00))))))
(assert (= ($Snap.first ($Snap.second ($Snap.second $t@152@00))) $Snap.unit))
; [eval] type1 == null ==> result == 0
; [eval] type1 == null
(push) ; 2
(set-option :timeout 10)
(push) ; 3
(assert (not (not (= type1@83@00 $Ref.null))))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1351
;  :arith-add-rows          1195
;  :arith-assert-diseq      146
;  :arith-assert-lower      616
;  :arith-assert-upper      314
;  :arith-bound-prop        85
;  :arith-conflicts         53
;  :arith-eq-adapter        259
;  :arith-fixed-eqs         188
;  :arith-offset-eqs        58
;  :arith-pivots            500
;  :conflicts               98
;  :datatype-accessor-ax    94
;  :datatype-constructor-ax 11
;  :datatype-occurs-check   59
;  :datatype-splits         11
;  :decisions               148
;  :del-clause              2019
;  :final-checks            59
;  :interface-eqs           9
;  :max-generation          6
;  :max-memory              4.90
;  :memory                  4.88
;  :mk-bool-var             3652
;  :mk-clause               2019
;  :num-allocs              209913
;  :num-checks              123
;  :propagations            772
;  :quant-instantiations    1013
;  :rlimit-count            288396)
(push) ; 3
(assert (not (= type1@83@00 $Ref.null)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1353
;  :arith-add-rows          1195
;  :arith-assert-diseq      146
;  :arith-assert-lower      616
;  :arith-assert-upper      314
;  :arith-bound-prop        85
;  :arith-conflicts         53
;  :arith-eq-adapter        259
;  :arith-fixed-eqs         188
;  :arith-offset-eqs        58
;  :arith-pivots            500
;  :conflicts               98
;  :datatype-accessor-ax    94
;  :datatype-constructor-ax 12
;  :datatype-occurs-check   61
;  :datatype-splits         12
;  :decisions               149
;  :del-clause              2019
;  :final-checks            61
;  :interface-eqs           9
;  :max-generation          6
;  :max-memory              4.90
;  :memory                  4.88
;  :mk-bool-var             3654
;  :mk-clause               2019
;  :num-allocs              210315
;  :num-checks              124
;  :propagations            772
;  :quant-instantiations    1013
;  :rlimit-count            288831)
; [then-branch: 75 | type1@83@00 == Null | live]
; [else-branch: 75 | type1@83@00 != Null | live]
(push) ; 3
; [then-branch: 75 | type1@83@00 == Null]
(assert (= type1@83@00 $Ref.null))
; [eval] result == 0
(pop) ; 3
(push) ; 3
; [else-branch: 75 | type1@83@00 != Null]
(assert (not (= type1@83@00 $Ref.null)))
(pop) ; 3
(pop) ; 2
; Joined path conditions
; Joined path conditions
(assert (implies (= type1@83@00 $Ref.null) (= result@84@00 0)))
(assert (= ($Snap.second ($Snap.second ($Snap.second $t@152@00))) $Snap.unit))
; [eval] type1 != null ==> result != 0
; [eval] type1 != null
(push) ; 2
(push) ; 3
(assert (not (= type1@83@00 $Ref.null)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1354
;  :arith-add-rows          1195
;  :arith-assert-diseq      147
;  :arith-assert-lower      617
;  :arith-assert-upper      314
;  :arith-bound-prop        85
;  :arith-conflicts         53
;  :arith-eq-adapter        260
;  :arith-fixed-eqs         188
;  :arith-offset-eqs        58
;  :arith-pivots            500
;  :conflicts               98
;  :datatype-accessor-ax    94
;  :datatype-constructor-ax 12
;  :datatype-occurs-check   62
;  :datatype-splits         12
;  :decisions               150
;  :del-clause              2019
;  :final-checks            62
;  :interface-eqs           9
;  :max-generation          6
;  :max-memory              4.90
;  :memory                  4.88
;  :mk-bool-var             3658
;  :mk-clause               2022
;  :num-allocs              210803
;  :num-checks              125
;  :propagations            773
;  :quant-instantiations    1013
;  :rlimit-count            289411)
(push) ; 3
(assert (not (not (= type1@83@00 $Ref.null))))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1356
;  :arith-add-rows          1195
;  :arith-assert-diseq      147
;  :arith-assert-lower      617
;  :arith-assert-upper      315
;  :arith-bound-prop        85
;  :arith-conflicts         53
;  :arith-eq-adapter        260
;  :arith-fixed-eqs         188
;  :arith-offset-eqs        58
;  :arith-pivots            500
;  :conflicts               98
;  :datatype-accessor-ax    94
;  :datatype-constructor-ax 12
;  :datatype-occurs-check   63
;  :datatype-splits         12
;  :decisions               150
;  :del-clause              2019
;  :final-checks            63
;  :interface-eqs           9
;  :max-generation          6
;  :max-memory              4.90
;  :memory                  4.88
;  :mk-bool-var             3658
;  :mk-clause               2022
;  :num-allocs              211204
;  :num-checks              126
;  :propagations            775
;  :quant-instantiations    1013
;  :rlimit-count            289814)
; [then-branch: 76 | type1@83@00 != Null | live]
; [else-branch: 76 | type1@83@00 == Null | live]
(push) ; 3
; [then-branch: 76 | type1@83@00 != Null]
(assert (not (= type1@83@00 $Ref.null)))
; [eval] result != 0
(pop) ; 3
(push) ; 3
; [else-branch: 76 | type1@83@00 == Null]
(assert (= type1@83@00 $Ref.null))
(pop) ; 3
(pop) ; 2
; Joined path conditions
; Joined path conditions
(assert (implies (not (= type1@83@00 $Ref.null)) (not (= result@84@00 0))))
(pop) ; 1
(assert (forall ((s@$ $Snap) (type1@83@00 $Ref)) (!
  (= (type%limited s@$ type1@83@00) (type s@$ type1@83@00))
  :pattern ((type s@$ type1@83@00))
  )))
(assert (forall ((s@$ $Snap) (type1@83@00 $Ref)) (!
  (type%stateless type1@83@00)
  :pattern ((type%limited s@$ type1@83@00))
  )))
(assert (forall ((s@$ $Snap) (type1@83@00 $Ref)) (!
  (let ((result@84@00 (type%limited s@$ type1@83@00))) (and
    (<= 0 result@84@00)
    (< result@84@00 3)
    (implies (= type1@83@00 $Ref.null) (= result@84@00 0))
    (implies (not (= type1@83@00 $Ref.null)) (not (= result@84@00 0)))))
  :pattern ((type%limited s@$ type1@83@00))
  )))
; ---------- FUNCTION subtype----------
(declare-fun subtype1@85@00 () Int)
(declare-fun subtype2@86@00 () Int)
(declare-fun result@87@00 () Bool)
; ----- Well-definedness of specifications -----
(push) ; 1
(assert (= s@$ ($Snap.combine ($Snap.first s@$) ($Snap.second s@$))))
(assert (= ($Snap.first s@$) $Snap.unit))
; [eval] 0 <= subtype1
(assert (<= 0 subtype1@85@00))
(assert (=
  ($Snap.second s@$)
  ($Snap.combine
    ($Snap.first ($Snap.second s@$))
    ($Snap.second ($Snap.second s@$)))))
(assert (= ($Snap.first ($Snap.second s@$)) $Snap.unit))
; [eval] subtype1 < 2 + 1
; [eval] 2 + 1
(assert (< subtype1@85@00 3))
(assert (=
  ($Snap.second ($Snap.second s@$))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second s@$)))
    ($Snap.second ($Snap.second ($Snap.second s@$))))))
(assert (= ($Snap.first ($Snap.second ($Snap.second s@$))) $Snap.unit))
; [eval] 0 <= subtype2
(assert (<= 0 subtype2@86@00))
(assert (= ($Snap.second ($Snap.second ($Snap.second s@$))) $Snap.unit))
; [eval] subtype2 <= 2
(assert (<= subtype2@86@00 2))
(pop) ; 1
(assert (forall ((s@$ $Snap) (subtype1@85@00 Int) (subtype2@86@00 Int)) (!
  (=
    (subtype%limited s@$ subtype1@85@00 subtype2@86@00)
    (subtype s@$ subtype1@85@00 subtype2@86@00))
  :pattern ((subtype s@$ subtype1@85@00 subtype2@86@00))
  )))
(assert (forall ((s@$ $Snap) (subtype1@85@00 Int) (subtype2@86@00 Int)) (!
  (subtype%stateless subtype1@85@00 subtype2@86@00)
  :pattern ((subtype%limited s@$ subtype1@85@00 subtype2@86@00))
  )))
; ----- Verification of function body and postcondition -----
(push) ; 1
(assert (= s@$ ($Snap.combine ($Snap.first s@$) ($Snap.second s@$))))
(assert (= ($Snap.first s@$) $Snap.unit))
(assert (<= 0 subtype1@85@00))
(assert (=
  ($Snap.second s@$)
  ($Snap.combine
    ($Snap.first ($Snap.second s@$))
    ($Snap.second ($Snap.second s@$)))))
(assert (= ($Snap.first ($Snap.second s@$)) $Snap.unit))
(assert (< subtype1@85@00 3))
(assert (=
  ($Snap.second ($Snap.second s@$))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second s@$)))
    ($Snap.second ($Snap.second ($Snap.second s@$))))))
(assert (= ($Snap.first ($Snap.second ($Snap.second s@$))) $Snap.unit))
(assert (<= 0 subtype2@86@00))
(assert (= ($Snap.second ($Snap.second ($Snap.second s@$))) $Snap.unit))
(assert (<= subtype2@86@00 2))
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
; [eval] (subtype1 == 2 ==> subtype2 == 2) && (subtype1 == 1 ==> subtype2 == 1)
; [eval] subtype1 == 2 ==> subtype2 == 2
; [eval] subtype1 == 2
(push) ; 2
(set-option :timeout 10)
(push) ; 3
(assert (not (not (= subtype1@85@00 2))))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1376
;  :arith-add-rows          1195
;  :arith-assert-diseq      147
;  :arith-assert-lower      620
;  :arith-assert-upper      318
;  :arith-bound-prop        85
;  :arith-conflicts         53
;  :arith-eq-adapter        261
;  :arith-fixed-eqs         188
;  :arith-offset-eqs        58
;  :arith-pivots            500
;  :conflicts               98
;  :datatype-accessor-ax    98
;  :datatype-constructor-ax 12
;  :datatype-occurs-check   65
;  :datatype-splits         12
;  :decisions               150
;  :del-clause              2025
;  :final-checks            65
;  :interface-eqs           9
;  :max-generation          6
;  :max-memory              4.90
;  :memory                  4.87
;  :mk-bool-var             3677
;  :mk-clause               2025
;  :num-allocs              212843
;  :num-checks              128
;  :propagations            777
;  :quant-instantiations    1013
;  :rlimit-count            291846)
(push) ; 3
(assert (not (= subtype1@85@00 2)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1376
;  :arith-add-rows          1195
;  :arith-assert-diseq      148
;  :arith-assert-lower      620
;  :arith-assert-upper      320
;  :arith-bound-prop        85
;  :arith-conflicts         53
;  :arith-eq-adapter        262
;  :arith-fixed-eqs         188
;  :arith-offset-eqs        58
;  :arith-pivots            500
;  :conflicts               98
;  :datatype-accessor-ax    98
;  :datatype-constructor-ax 12
;  :datatype-occurs-check   66
;  :datatype-splits         12
;  :decisions               150
;  :del-clause              2029
;  :final-checks            66
;  :interface-eqs           9
;  :max-generation          6
;  :max-memory              4.90
;  :memory                  4.87
;  :mk-bool-var             3680
;  :mk-clause               2029
;  :num-allocs              213241
;  :num-checks              129
;  :propagations            778
;  :quant-instantiations    1013
;  :rlimit-count            292273)
; [then-branch: 77 | subtype1@85@00 == 2 | live]
; [else-branch: 77 | subtype1@85@00 != 2 | live]
(push) ; 3
; [then-branch: 77 | subtype1@85@00 == 2]
(assert (= subtype1@85@00 2))
; [eval] subtype2 == 2
(pop) ; 3
(push) ; 3
; [else-branch: 77 | subtype1@85@00 != 2]
(assert (not (= subtype1@85@00 2)))
(pop) ; 3
(pop) ; 2
; Joined path conditions
; Joined path conditions
(push) ; 2
; [then-branch: 78 | subtype1@85@00 == 2 ==> subtype2@86@00 == 2 | live]
; [else-branch: 78 | !(subtype1@85@00 == 2 ==> subtype2@86@00 == 2) | live]
(push) ; 3
; [then-branch: 78 | subtype1@85@00 == 2 ==> subtype2@86@00 == 2]
(assert (implies (= subtype1@85@00 2) (= subtype2@86@00 2)))
; [eval] subtype1 == 1 ==> subtype2 == 1
; [eval] subtype1 == 1
(push) ; 4
(push) ; 5
(assert (not (not (= subtype1@85@00 1))))
(check-sat)
; unknown
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1377
;  :arith-add-rows          1195
;  :arith-assert-diseq      150
;  :arith-assert-lower      621
;  :arith-assert-upper      324
;  :arith-bound-prop        85
;  :arith-conflicts         53
;  :arith-eq-adapter        265
;  :arith-fixed-eqs         188
;  :arith-offset-eqs        58
;  :arith-pivots            500
;  :conflicts               98
;  :datatype-accessor-ax    98
;  :datatype-constructor-ax 12
;  :datatype-occurs-check   67
;  :datatype-splits         12
;  :decisions               151
;  :del-clause              2032
;  :final-checks            67
;  :interface-eqs           9
;  :max-generation          6
;  :max-memory              4.90
;  :memory                  4.88
;  :mk-bool-var             3688
;  :mk-clause               2039
;  :num-allocs              213736
;  :num-checks              130
;  :propagations            782
;  :quant-instantiations    1013
;  :rlimit-count            292820)
(push) ; 5
(assert (not (= subtype1@85@00 1)))
(check-sat)
; unknown
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1378
;  :arith-add-rows          1195
;  :arith-assert-diseq      153
;  :arith-assert-lower      621
;  :arith-assert-upper      328
;  :arith-bound-prop        85
;  :arith-conflicts         53
;  :arith-eq-adapter        266
;  :arith-fixed-eqs         189
;  :arith-offset-eqs        58
;  :arith-pivots            500
;  :conflicts               98
;  :datatype-accessor-ax    98
;  :datatype-constructor-ax 12
;  :datatype-occurs-check   68
;  :datatype-splits         12
;  :decisions               153
;  :del-clause              2039
;  :final-checks            68
;  :interface-eqs           9
;  :max-generation          6
;  :max-memory              4.90
;  :memory                  4.88
;  :mk-bool-var             3691
;  :mk-clause               2046
;  :num-allocs              214140
;  :num-checks              131
;  :propagations            786
;  :quant-instantiations    1013
;  :rlimit-count            293275)
; [then-branch: 79 | subtype1@85@00 == 1 | live]
; [else-branch: 79 | subtype1@85@00 != 1 | live]
(push) ; 5
; [then-branch: 79 | subtype1@85@00 == 1]
(assert (= subtype1@85@00 1))
; [eval] subtype2 == 1
(pop) ; 5
(push) ; 5
; [else-branch: 79 | subtype1@85@00 != 1]
(assert (not (= subtype1@85@00 1)))
(pop) ; 5
(pop) ; 4
; Joined path conditions
; Joined path conditions
(pop) ; 3
(push) ; 3
; [else-branch: 78 | !(subtype1@85@00 == 2 ==> subtype2@86@00 == 2)]
(assert (not (implies (= subtype1@85@00 2) (= subtype2@86@00 2))))
(pop) ; 3
(pop) ; 2
; Joined path conditions
(assert (implies
  (and (implies (= subtype1@85@00 2) (= subtype2@86@00 2)) (= subtype1@85@00 2))
  (= subtype2@86@00 2)))
; Joined path conditions
(assert (=
  result@87@00
  (and
    (implies (= subtype1@85@00 1) (= subtype2@86@00 1))
    (implies (= subtype1@85@00 2) (= subtype2@86@00 2)))))
(pop) ; 1
(assert (forall ((s@$ $Snap) (subtype1@85@00 Int) (subtype2@86@00 Int)) (!
  (implies
    (and
      (<= 0 subtype1@85@00)
      (< subtype1@85@00 3)
      (<= 0 subtype2@86@00)
      (<= subtype2@86@00 2))
    (=
      (subtype s@$ subtype1@85@00 subtype2@86@00)
      (and
        (implies (= subtype1@85@00 2) (= subtype2@86@00 2))
        (implies (= subtype1@85@00 1) (= subtype2@86@00 1)))))
  :pattern ((subtype s@$ subtype1@85@00 subtype2@86@00))
  )))
; ---------- FUNCTION matrixValues----------
(declare-fun this@88@00 () $Ref)
(declare-fun a2@89@00 () option<array>)
(declare-fun V@90@00 () Int)
(declare-fun result@91@00 () Seq<Seq<Int>>)
; ----- Well-definedness of specifications -----
(push) ; 1
(assert (= s@$ ($Snap.combine ($Snap.first s@$) ($Snap.second s@$))))
(assert (= ($Snap.first s@$) $Snap.unit))
; [eval] this != null
(assert (not (= this@88@00 $Ref.null)))
(assert (=
  ($Snap.second s@$)
  ($Snap.combine
    ($Snap.first ($Snap.second s@$))
    ($Snap.second ($Snap.second s@$)))))
(assert (= ($Snap.first ($Snap.second s@$)) $Snap.unit))
; [eval] a2 != (None(): option[array])
; [eval] (None(): option[array])
(assert (not (= a2@89@00 (as None<option<array>>  option<array>))))
(assert (=
  ($Snap.second ($Snap.second s@$))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second s@$)))
    ($Snap.second ($Snap.second ($Snap.second s@$))))))
(assert (= ($Snap.first ($Snap.second ($Snap.second s@$))) $Snap.unit))
; [eval] alen(opt_get1(a2)) == V
; [eval] alen(opt_get1(a2))
; [eval] opt_get1(a2)
(push) ; 2
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 2
; Joined path conditions
(assert (= (alen<Int> (opt_get1 $Snap.unit a2@89@00)) V@90@00))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second s@$)))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$)))))))
(declare-const i1@153@00 Int)
(push) ; 2
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 3
; [then-branch: 80 | 0 <= i1@153@00 | live]
; [else-branch: 80 | !(0 <= i1@153@00) | live]
(push) ; 4
; [then-branch: 80 | 0 <= i1@153@00]
(assert (<= 0 i1@153@00))
; [eval] i1 < V
(pop) ; 4
(push) ; 4
; [else-branch: 80 | !(0 <= i1@153@00)]
(assert (not (<= 0 i1@153@00)))
(pop) ; 4
(pop) ; 3
; Joined path conditions
; Joined path conditions
(assert (and (< i1@153@00 V@90@00) (<= 0 i1@153@00)))
; [eval] aloc(opt_get1(a2), i1)
; [eval] opt_get1(a2)
(push) ; 3
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 3
; Joined path conditions
(push) ; 3
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 4
(assert (not (< i1@153@00 (alen<Int> (opt_get1 $Snap.unit a2@89@00)))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1406
;  :arith-add-rows          1196
;  :arith-assert-diseq      153
;  :arith-assert-lower      624
;  :arith-assert-upper      330
;  :arith-bound-prop        85
;  :arith-conflicts         53
;  :arith-eq-adapter        267
;  :arith-fixed-eqs         190
;  :arith-offset-eqs        58
;  :arith-pivots            502
;  :conflicts               98
;  :datatype-accessor-ax    103
;  :datatype-constructor-ax 12
;  :datatype-occurs-check   68
;  :datatype-splits         12
;  :decisions               153
;  :del-clause              2046
;  :final-checks            68
;  :interface-eqs           9
;  :max-generation          6
;  :max-memory              4.91
;  :memory                  4.90
;  :mk-bool-var             3711
;  :mk-clause               2046
;  :num-allocs              214819
;  :num-checks              132
;  :propagations            786
;  :quant-instantiations    1018
;  :rlimit-count            294668)
(assert (< i1@153@00 (alen<Int> (opt_get1 $Snap.unit a2@89@00))))
(pop) ; 3
; Joined path conditions
(assert (< i1@153@00 (alen<Int> (opt_get1 $Snap.unit a2@89@00))))
(declare-const $k@154@00 $Perm)
(assert ($Perm.isReadVar $k@154@00 $Perm.Write))
(pop) ; 2
(declare-fun inv@155@00 ($Snap $Ref option<array> Int $Ref) Int)
; Nested auxiliary terms: globals
(assert ($Perm.isReadVar $k@154@00 $Perm.Write))
; Nested auxiliary terms: non-globals
(assert (forall ((i1@153@00 Int)) (!
  (< i1@153@00 (alen<Int> (opt_get1 $Snap.unit a2@89@00)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1@153@00))
  :qid |option$array$-aux|)))
(push) ; 2
(assert (not (forall ((i1@153@00 Int)) (!
  (implies
    (and (< i1@153@00 V@90@00) (<= 0 i1@153@00))
    (or (= $k@154@00 $Perm.No) (< $Perm.No $k@154@00)))
  
  ))))
(check-sat)
; unsat
(pop) ; 2
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1408
;  :arith-add-rows          1196
;  :arith-assert-diseq      154
;  :arith-assert-lower      626
;  :arith-assert-upper      331
;  :arith-bound-prop        85
;  :arith-conflicts         53
;  :arith-eq-adapter        268
;  :arith-fixed-eqs         190
;  :arith-offset-eqs        58
;  :arith-pivots            504
;  :conflicts               99
;  :datatype-accessor-ax    104
;  :datatype-constructor-ax 12
;  :datatype-occurs-check   68
;  :datatype-splits         12
;  :decisions               153
;  :del-clause              2046
;  :final-checks            68
;  :interface-eqs           9
;  :max-generation          6
;  :max-memory              4.91
;  :memory                  4.90
;  :mk-bool-var             3718
;  :mk-clause               2048
;  :num-allocs              215305
;  :num-checks              133
;  :propagations            787
;  :quant-instantiations    1018
;  :rlimit-count            295244)
; Check receiver injectivity
(push) ; 2
(assert (not (forall ((i11@153@00 Int) (i12@153@00 Int)) (!
  (implies
    (and
      (and (and (< i11@153@00 V@90@00) (<= 0 i11@153@00)) (< $Perm.No $k@154@00))
      (and (and (< i12@153@00 V@90@00) (<= 0 i12@153@00)) (< $Perm.No $k@154@00))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i11@153@00)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i12@153@00)))
    (= i11@153@00 i12@153@00))
  
  :qid |option$array$-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 2
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1438
;  :arith-add-rows          1206
;  :arith-assert-diseq      158
;  :arith-assert-lower      633
;  :arith-assert-upper      335
;  :arith-bound-prop        85
;  :arith-conflicts         55
;  :arith-eq-adapter        270
;  :arith-fixed-eqs         191
;  :arith-offset-eqs        59
;  :arith-pivots            510
;  :conflicts               102
;  :datatype-accessor-ax    104
;  :datatype-constructor-ax 12
;  :datatype-occurs-check   68
;  :datatype-splits         12
;  :decisions               155
;  :del-clause              2064
;  :final-checks            68
;  :interface-eqs           9
;  :max-generation          6
;  :max-memory              4.91
;  :memory                  4.89
;  :mk-bool-var             3746
;  :mk-clause               2066
;  :num-allocs              215662
;  :num-checks              134
;  :propagations            807
;  :quant-instantiations    1029
;  :rlimit-count            296292)
; Definitional axioms for inverse functions
(assert (forall ((i1@153@00 Int)) (!
  (implies
    (and (and (< i1@153@00 V@90@00) (<= 0 i1@153@00)) (< $Perm.No $k@154@00))
    (=
      (inv@155@00 s@$ this@88@00 a2@89@00 V@90@00 (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1@153@00))
      i1@153@00))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1@153@00))
  )))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (< (inv@155@00 s@$ this@88@00 a2@89@00 V@90@00 r) V@90@00)
        (<= 0 (inv@155@00 s@$ this@88@00 a2@89@00 V@90@00 r)))
      (< $Perm.No $k@154@00))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit a2@89@00) (inv@155@00 s@$ this@88@00 a2@89@00 V@90@00 r))
      r))
  :pattern ((inv@155@00 s@$ this@88@00 a2@89@00 V@90@00 r))
  :qid |option$array$-fctOfInv|)))
; Permissions are non-negative
(assert (forall ((i1@153@00 Int)) (!
  (<= $Perm.No $k@154@00)
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1@153@00))
  :qid |option$array$-permAtLeastZero|)))
; Field permissions are at most one
(assert (forall ((i1@153@00 Int)) (!
  (<= $k@154@00 $Perm.Write)
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1@153@00))
  :qid |option$array$-permAtMostOne|)))
; Permission implies non-null receiver
(assert (forall ((i1@153@00 Int)) (!
  (implies
    (and (and (< i1@153@00 V@90@00) (<= 0 i1@153@00)) (< $Perm.No $k@154@00))
    (not
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1@153@00)
        $Ref.null)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1@153@00))
  :qid |option$array$-permImpliesNonNull|)))
(declare-fun sm@156@00 ($Snap $Ref option<array> Int) $FVF<option<array>>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and
        (< (inv@155@00 s@$ this@88@00 a2@89@00 V@90@00 r) V@90@00)
        (<= 0 (inv@155@00 s@$ this@88@00 a2@89@00 V@90@00 r)))
      (< $Perm.No $k@154@00)
      false)
    (=
      ($FVF.lookup_option$array$ (sm@156@00 s@$ this@88@00 a2@89@00 V@90@00) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r)))
  :pattern (($FVF.lookup_option$array$ (sm@156@00 s@$ this@88@00 a2@89@00 V@90@00) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r))
  :qid |qp.fvfValDef9|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r)
  :pattern (($FVF.lookup_option$array$ (sm@156@00 s@$ this@88@00 a2@89@00 V@90@00) r))
  :qid |qp.fvfResTrgDef10|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (< (inv@155@00 s@$ this@88@00 a2@89@00 V@90@00 r) V@90@00)
      (<= 0 (inv@155@00 s@$ this@88@00 a2@89@00 V@90@00 r)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@156@00 s@$ this@88@00 a2@89@00 V@90@00) r) r))
  :pattern ((inv@155@00 s@$ this@88@00 a2@89@00 V@90@00 r))
  )))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$)))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$)))))
  $Snap.unit))
; [eval] (forall i1: Int :: { aloc(opt_get1(a2), i1) } 0 <= i1 && i1 < V ==> aloc(opt_get1(a2), i1).option$array$ != (None(): option[array]))
(declare-const i1@157@00 Int)
(push) ; 2
; [eval] 0 <= i1 && i1 < V ==> aloc(opt_get1(a2), i1).option$array$ != (None(): option[array])
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 3
; [then-branch: 81 | 0 <= i1@157@00 | live]
; [else-branch: 81 | !(0 <= i1@157@00) | live]
(push) ; 4
; [then-branch: 81 | 0 <= i1@157@00]
(assert (<= 0 i1@157@00))
; [eval] i1 < V
(pop) ; 4
(push) ; 4
; [else-branch: 81 | !(0 <= i1@157@00)]
(assert (not (<= 0 i1@157@00)))
(pop) ; 4
(pop) ; 3
; Joined path conditions
; Joined path conditions
(push) ; 3
; [then-branch: 82 | i1@157@00 < V@90@00 && 0 <= i1@157@00 | live]
; [else-branch: 82 | !(i1@157@00 < V@90@00 && 0 <= i1@157@00) | live]
(push) ; 4
; [then-branch: 82 | i1@157@00 < V@90@00 && 0 <= i1@157@00]
(assert (and (< i1@157@00 V@90@00) (<= 0 i1@157@00)))
; [eval] aloc(opt_get1(a2), i1).option$array$ != (None(): option[array])
; [eval] aloc(opt_get1(a2), i1)
; [eval] opt_get1(a2)
(push) ; 5
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 5
; Joined path conditions
(push) ; 5
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 6
(assert (not (< i1@157@00 (alen<Int> (opt_get1 $Snap.unit a2@89@00)))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1445
;  :arith-add-rows          1207
;  :arith-assert-diseq      158
;  :arith-assert-lower      635
;  :arith-assert-upper      338
;  :arith-bound-prop        85
;  :arith-conflicts         55
;  :arith-eq-adapter        271
;  :arith-fixed-eqs         192
;  :arith-offset-eqs        59
;  :arith-pivots            512
;  :conflicts               102
;  :datatype-accessor-ax    105
;  :datatype-constructor-ax 12
;  :datatype-occurs-check   68
;  :datatype-splits         12
;  :decisions               155
;  :del-clause              2064
;  :final-checks            68
;  :interface-eqs           9
;  :max-generation          6
;  :max-memory              4.91
;  :memory                  4.90
;  :mk-bool-var             3759
;  :mk-clause               2066
;  :num-allocs              216924
;  :num-checks              135
;  :propagations            807
;  :quant-instantiations    1029
;  :rlimit-count            298704)
(assert (< i1@157@00 (alen<Int> (opt_get1 $Snap.unit a2@89@00))))
(pop) ; 5
; Joined path conditions
(assert (< i1@157@00 (alen<Int> (opt_get1 $Snap.unit a2@89@00))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@156@00 s@$ this@88@00 a2@89@00 V@90@00) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1@157@00)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1@157@00)))
(push) ; 5
(assert (not (ite
  (and
    (<
      (inv@155@00 s@$ this@88@00 a2@89@00 V@90@00 (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1@157@00))
      V@90@00)
    (<=
      0
      (inv@155@00 s@$ this@88@00 a2@89@00 V@90@00 (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1@157@00))))
  (< $Perm.No $k@154@00)
  false)))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1458
;  :arith-add-rows          1210
;  :arith-assert-diseq      158
;  :arith-assert-lower      636
;  :arith-assert-upper      339
;  :arith-bound-prop        88
;  :arith-conflicts         55
;  :arith-eq-adapter        272
;  :arith-fixed-eqs         193
;  :arith-offset-eqs        62
;  :arith-pivots            513
;  :conflicts               103
;  :datatype-accessor-ax    105
;  :datatype-constructor-ax 12
;  :datatype-occurs-check   68
;  :datatype-splits         12
;  :decisions               155
;  :del-clause              2064
;  :final-checks            68
;  :interface-eqs           9
;  :max-generation          6
;  :max-memory              4.91
;  :memory                  4.90
;  :mk-bool-var             3777
;  :mk-clause               2074
;  :num-allocs              217194
;  :num-checks              136
;  :propagations            811
;  :quant-instantiations    1039
;  :rlimit-count            299328)
; [eval] (None(): option[array])
(pop) ; 4
(push) ; 4
; [else-branch: 82 | !(i1@157@00 < V@90@00 && 0 <= i1@157@00)]
(assert (not (and (< i1@157@00 V@90@00) (<= 0 i1@157@00))))
(pop) ; 4
(pop) ; 3
; Joined path conditions
(assert (implies
  (and (< i1@157@00 V@90@00) (<= 0 i1@157@00))
  (and
    (< i1@157@00 V@90@00)
    (<= 0 i1@157@00)
    (< i1@157@00 (alen<Int> (opt_get1 $Snap.unit a2@89@00)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@156@00 s@$ this@88@00 a2@89@00 V@90@00) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1@157@00)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1@157@00)))))
; Joined path conditions
(pop) ; 2
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@157@00 Int)) (!
  (implies
    (and (< i1@157@00 V@90@00) (<= 0 i1@157@00))
    (and
      (< i1@157@00 V@90@00)
      (<= 0 i1@157@00)
      (< i1@157@00 (alen<Int> (opt_get1 $Snap.unit a2@89@00)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@156@00 s@$ this@88@00 a2@89@00 V@90@00) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1@157@00)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1@157@00))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1@157@00))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(assert (forall ((i1@157@00 Int)) (!
  (implies
    (and (< i1@157@00 V@90@00) (<= 0 i1@157@00))
    (not
      (=
        ($FVF.lookup_option$array$ (sm@156@00 s@$ this@88@00 a2@89@00 V@90@00) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1@157@00))
        (as None<option<array>>  option<array>))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1@157@00))
  :qid |prog.l<no position>|)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$)))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$)))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$))))))
  $Snap.unit))
; [eval] (forall i1: Int :: { alen(opt_get1(aloc(opt_get1(a2), i1).option$array$)) } 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(a2), i1).option$array$)) == V)
(declare-const i1@158@00 Int)
(push) ; 2
; [eval] 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(a2), i1).option$array$)) == V
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 3
; [then-branch: 83 | 0 <= i1@158@00 | live]
; [else-branch: 83 | !(0 <= i1@158@00) | live]
(push) ; 4
; [then-branch: 83 | 0 <= i1@158@00]
(assert (<= 0 i1@158@00))
; [eval] i1 < V
(pop) ; 4
(push) ; 4
; [else-branch: 83 | !(0 <= i1@158@00)]
(assert (not (<= 0 i1@158@00)))
(pop) ; 4
(pop) ; 3
; Joined path conditions
; Joined path conditions
(push) ; 3
; [then-branch: 84 | i1@158@00 < V@90@00 && 0 <= i1@158@00 | live]
; [else-branch: 84 | !(i1@158@00 < V@90@00 && 0 <= i1@158@00) | live]
(push) ; 4
; [then-branch: 84 | i1@158@00 < V@90@00 && 0 <= i1@158@00]
(assert (and (< i1@158@00 V@90@00) (<= 0 i1@158@00)))
; [eval] alen(opt_get1(aloc(opt_get1(a2), i1).option$array$)) == V
; [eval] alen(opt_get1(aloc(opt_get1(a2), i1).option$array$))
; [eval] opt_get1(aloc(opt_get1(a2), i1).option$array$)
; [eval] aloc(opt_get1(a2), i1)
; [eval] opt_get1(a2)
(push) ; 5
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 5
; Joined path conditions
(push) ; 5
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 6
(assert (not (< i1@158@00 (alen<Int> (opt_get1 $Snap.unit a2@89@00)))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1465
;  :arith-add-rows          1212
;  :arith-assert-diseq      158
;  :arith-assert-lower      639
;  :arith-assert-upper      340
;  :arith-bound-prop        88
;  :arith-conflicts         55
;  :arith-eq-adapter        273
;  :arith-fixed-eqs         194
;  :arith-offset-eqs        62
;  :arith-pivots            518
;  :conflicts               103
;  :datatype-accessor-ax    106
;  :datatype-constructor-ax 12
;  :datatype-occurs-check   68
;  :datatype-splits         12
;  :decisions               155
;  :del-clause              2072
;  :final-checks            68
;  :interface-eqs           9
;  :max-generation          6
;  :max-memory              4.91
;  :memory                  4.90
;  :mk-bool-var             3785
;  :mk-clause               2074
;  :num-allocs              217782
;  :num-checks              137
;  :propagations            811
;  :quant-instantiations    1039
;  :rlimit-count            300525)
(assert (< i1@158@00 (alen<Int> (opt_get1 $Snap.unit a2@89@00))))
(pop) ; 5
; Joined path conditions
(assert (< i1@158@00 (alen<Int> (opt_get1 $Snap.unit a2@89@00))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@156@00 s@$ this@88@00 a2@89@00 V@90@00) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1@158@00)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1@158@00)))
(push) ; 5
(assert (not (ite
  (and
    (<
      (inv@155@00 s@$ this@88@00 a2@89@00 V@90@00 (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1@158@00))
      V@90@00)
    (<=
      0
      (inv@155@00 s@$ this@88@00 a2@89@00 V@90@00 (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1@158@00))))
  (< $Perm.No $k@154@00)
  false)))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1478
;  :arith-add-rows          1215
;  :arith-assert-diseq      158
;  :arith-assert-lower      640
;  :arith-assert-upper      341
;  :arith-bound-prop        91
;  :arith-conflicts         55
;  :arith-eq-adapter        274
;  :arith-fixed-eqs         195
;  :arith-offset-eqs        65
;  :arith-pivots            519
;  :conflicts               104
;  :datatype-accessor-ax    106
;  :datatype-constructor-ax 12
;  :datatype-occurs-check   68
;  :datatype-splits         12
;  :decisions               155
;  :del-clause              2072
;  :final-checks            68
;  :interface-eqs           9
;  :max-generation          6
;  :max-memory              4.91
;  :memory                  4.91
;  :mk-bool-var             3805
;  :mk-clause               2082
;  :num-allocs              218051
;  :num-checks              138
;  :propagations            815
;  :quant-instantiations    1051
;  :rlimit-count            301200)
(push) ; 5
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 6
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (sm@156@00 s@$ this@88@00 a2@89@00 V@90@00) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1@158@00))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1478
;  :arith-add-rows          1215
;  :arith-assert-diseq      158
;  :arith-assert-lower      640
;  :arith-assert-upper      341
;  :arith-bound-prop        91
;  :arith-conflicts         55
;  :arith-eq-adapter        274
;  :arith-fixed-eqs         195
;  :arith-offset-eqs        65
;  :arith-pivots            519
;  :conflicts               105
;  :datatype-accessor-ax    106
;  :datatype-constructor-ax 12
;  :datatype-occurs-check   68
;  :datatype-splits         12
;  :decisions               155
;  :del-clause              2072
;  :final-checks            68
;  :interface-eqs           9
;  :max-generation          6
;  :max-memory              4.91
;  :memory                  4.91
;  :mk-bool-var             3805
;  :mk-clause               2082
;  :num-allocs              218145
;  :num-checks              139
;  :propagations            815
;  :quant-instantiations    1051
;  :rlimit-count            301305)
(assert (not
  (=
    ($FVF.lookup_option$array$ (sm@156@00 s@$ this@88@00 a2@89@00 V@90@00) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1@158@00))
    (as None<option<array>>  option<array>))))
(pop) ; 5
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (sm@156@00 s@$ this@88@00 a2@89@00 V@90@00) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1@158@00))
    (as None<option<array>>  option<array>))))
(pop) ; 4
(push) ; 4
; [else-branch: 84 | !(i1@158@00 < V@90@00 && 0 <= i1@158@00)]
(assert (not (and (< i1@158@00 V@90@00) (<= 0 i1@158@00))))
(pop) ; 4
(pop) ; 3
; Joined path conditions
(assert (implies
  (and (< i1@158@00 V@90@00) (<= 0 i1@158@00))
  (and
    (< i1@158@00 V@90@00)
    (<= 0 i1@158@00)
    (< i1@158@00 (alen<Int> (opt_get1 $Snap.unit a2@89@00)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@156@00 s@$ this@88@00 a2@89@00 V@90@00) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1@158@00)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1@158@00))
    (not
      (=
        ($FVF.lookup_option$array$ (sm@156@00 s@$ this@88@00 a2@89@00 V@90@00) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1@158@00))
        (as None<option<array>>  option<array>))))))
; Joined path conditions
(pop) ; 2
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@158@00 Int)) (!
  (implies
    (and (< i1@158@00 V@90@00) (<= 0 i1@158@00))
    (and
      (< i1@158@00 V@90@00)
      (<= 0 i1@158@00)
      (< i1@158@00 (alen<Int> (opt_get1 $Snap.unit a2@89@00)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@156@00 s@$ this@88@00 a2@89@00 V@90@00) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1@158@00)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1@158@00))
      (not
        (=
          ($FVF.lookup_option$array$ (sm@156@00 s@$ this@88@00 a2@89@00 V@90@00) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1@158@00))
          (as None<option<array>>  option<array>)))))
  :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@156@00 s@$ this@88@00 a2@89@00 V@90@00) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1@158@00)))))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(assert (forall ((i1@158@00 Int)) (!
  (implies
    (and (< i1@158@00 V@90@00) (<= 0 i1@158@00))
    (=
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@156@00 s@$ this@88@00 a2@89@00 V@90@00) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1@158@00))))
      V@90@00))
  :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@156@00 s@$ this@88@00 a2@89@00 V@90@00) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1@158@00)))))
  :qid |prog.l<no position>|)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$)))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$)))))))
  $Snap.unit))
; [eval] (forall i1: Int :: { aloc(opt_get1(a2), i1) } (forall i2: Int :: { aloc(opt_get1(a2), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(a2), i1).option$array$ == aloc(opt_get1(a2), i2).option$array$ ==> i1 == i2))
(declare-const i1@159@00 Int)
(push) ; 2
; [eval] (forall i2: Int :: { aloc(opt_get1(a2), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(a2), i1).option$array$ == aloc(opt_get1(a2), i2).option$array$ ==> i1 == i2)
(declare-const i2@160@00 Int)
(push) ; 3
; [eval] 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(a2), i1).option$array$ == aloc(opt_get1(a2), i2).option$array$ ==> i1 == i2
; [eval] 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(a2), i1).option$array$ == aloc(opt_get1(a2), i2).option$array$
; [eval] 0 <= i1
(push) ; 4
; [then-branch: 85 | 0 <= i1@159@00 | live]
; [else-branch: 85 | !(0 <= i1@159@00) | live]
(push) ; 5
; [then-branch: 85 | 0 <= i1@159@00]
(assert (<= 0 i1@159@00))
; [eval] i1 < V
(push) ; 6
; [then-branch: 86 | i1@159@00 < V@90@00 | live]
; [else-branch: 86 | !(i1@159@00 < V@90@00) | live]
(push) ; 7
; [then-branch: 86 | i1@159@00 < V@90@00]
(assert (< i1@159@00 V@90@00))
; [eval] 0 <= i2
(push) ; 8
; [then-branch: 87 | 0 <= i2@160@00 | live]
; [else-branch: 87 | !(0 <= i2@160@00) | live]
(push) ; 9
; [then-branch: 87 | 0 <= i2@160@00]
(assert (<= 0 i2@160@00))
; [eval] i2 < V
(push) ; 10
; [then-branch: 88 | i2@160@00 < V@90@00 | live]
; [else-branch: 88 | !(i2@160@00 < V@90@00) | live]
(push) ; 11
; [then-branch: 88 | i2@160@00 < V@90@00]
(assert (< i2@160@00 V@90@00))
; [eval] aloc(opt_get1(a2), i1).option$array$ == aloc(opt_get1(a2), i2).option$array$
; [eval] aloc(opt_get1(a2), i1)
; [eval] opt_get1(a2)
(push) ; 12
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 12
; Joined path conditions
(push) ; 12
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 13
(assert (not (< i1@159@00 (alen<Int> (opt_get1 $Snap.unit a2@89@00)))))
(check-sat)
; unsat
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1485
;  :arith-add-rows          1218
;  :arith-assert-diseq      158
;  :arith-assert-lower      645
;  :arith-assert-upper      342
;  :arith-bound-prop        91
;  :arith-conflicts         55
;  :arith-eq-adapter        275
;  :arith-fixed-eqs         196
;  :arith-offset-eqs        65
;  :arith-pivots            525
;  :conflicts               105
;  :datatype-accessor-ax    107
;  :datatype-constructor-ax 12
;  :datatype-occurs-check   68
;  :datatype-splits         12
;  :decisions               155
;  :del-clause              2080
;  :final-checks            68
;  :interface-eqs           9
;  :max-generation          6
;  :max-memory              4.91
;  :memory                  4.91
;  :mk-bool-var             3815
;  :mk-clause               2082
;  :num-allocs              218912
;  :num-checks              140
;  :propagations            815
;  :quant-instantiations    1051
;  :rlimit-count            302752)
(assert (< i1@159@00 (alen<Int> (opt_get1 $Snap.unit a2@89@00))))
(pop) ; 12
; Joined path conditions
(assert (< i1@159@00 (alen<Int> (opt_get1 $Snap.unit a2@89@00))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@156@00 s@$ this@88@00 a2@89@00 V@90@00) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1@159@00)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1@159@00)))
(push) ; 12
(assert (not (ite
  (and
    (<
      (inv@155@00 s@$ this@88@00 a2@89@00 V@90@00 (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1@159@00))
      V@90@00)
    (<=
      0
      (inv@155@00 s@$ this@88@00 a2@89@00 V@90@00 (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1@159@00))))
  (< $Perm.No $k@154@00)
  false)))
(check-sat)
; unsat
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1498
;  :arith-add-rows          1221
;  :arith-assert-diseq      158
;  :arith-assert-lower      646
;  :arith-assert-upper      343
;  :arith-bound-prop        94
;  :arith-conflicts         55
;  :arith-eq-adapter        276
;  :arith-fixed-eqs         197
;  :arith-offset-eqs        68
;  :arith-pivots            526
;  :conflicts               106
;  :datatype-accessor-ax    107
;  :datatype-constructor-ax 12
;  :datatype-occurs-check   68
;  :datatype-splits         12
;  :decisions               155
;  :del-clause              2080
;  :final-checks            68
;  :interface-eqs           9
;  :max-generation          6
;  :max-memory              4.92
;  :memory                  4.91
;  :mk-bool-var             3835
;  :mk-clause               2090
;  :num-allocs              219178
;  :num-checks              141
;  :propagations            819
;  :quant-instantiations    1063
;  :rlimit-count            303427)
; [eval] aloc(opt_get1(a2), i2)
; [eval] opt_get1(a2)
(push) ; 12
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 12
; Joined path conditions
(push) ; 12
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 13
(assert (not (< i2@160@00 (alen<Int> (opt_get1 $Snap.unit a2@89@00)))))
(check-sat)
; unsat
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1498
;  :arith-add-rows          1221
;  :arith-assert-diseq      158
;  :arith-assert-lower      646
;  :arith-assert-upper      343
;  :arith-bound-prop        94
;  :arith-conflicts         55
;  :arith-eq-adapter        276
;  :arith-fixed-eqs         197
;  :arith-offset-eqs        68
;  :arith-pivots            526
;  :conflicts               106
;  :datatype-accessor-ax    107
;  :datatype-constructor-ax 12
;  :datatype-occurs-check   68
;  :datatype-splits         12
;  :decisions               155
;  :del-clause              2080
;  :final-checks            68
;  :interface-eqs           9
;  :max-generation          6
;  :max-memory              4.92
;  :memory                  4.91
;  :mk-bool-var             3835
;  :mk-clause               2090
;  :num-allocs              219204
;  :num-checks              142
;  :propagations            819
;  :quant-instantiations    1063
;  :rlimit-count            303457)
(assert (< i2@160@00 (alen<Int> (opt_get1 $Snap.unit a2@89@00))))
(pop) ; 12
; Joined path conditions
(assert (< i2@160@00 (alen<Int> (opt_get1 $Snap.unit a2@89@00))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@156@00 s@$ this@88@00 a2@89@00 V@90@00) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i2@160@00)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i2@160@00)))
(push) ; 12
(assert (not (ite
  (and
    (<
      (inv@155@00 s@$ this@88@00 a2@89@00 V@90@00 (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i2@160@00))
      V@90@00)
    (<=
      0
      (inv@155@00 s@$ this@88@00 a2@89@00 V@90@00 (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i2@160@00))))
  (< $Perm.No $k@154@00)
  false)))
(check-sat)
; unsat
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1508
;  :arith-add-rows          1229
;  :arith-assert-diseq      158
;  :arith-assert-lower      647
;  :arith-assert-upper      345
;  :arith-bound-prop        96
;  :arith-conflicts         56
;  :arith-eq-adapter        277
;  :arith-fixed-eqs         198
;  :arith-offset-eqs        71
;  :arith-pivots            528
;  :conflicts               107
;  :datatype-accessor-ax    107
;  :datatype-constructor-ax 12
;  :datatype-occurs-check   68
;  :datatype-splits         12
;  :decisions               155
;  :del-clause              2080
;  :final-checks            68
;  :interface-eqs           9
;  :max-generation          6
;  :max-memory              4.93
;  :memory                  4.92
;  :mk-bool-var             3854
;  :mk-clause               2097
;  :num-allocs              219481
;  :num-checks              143
;  :propagations            822
;  :quant-instantiations    1074
;  :rlimit-count            304193)
(pop) ; 11
(push) ; 11
; [else-branch: 88 | !(i2@160@00 < V@90@00)]
(assert (not (< i2@160@00 V@90@00)))
(pop) ; 11
(pop) ; 10
; Joined path conditions
(assert (implies
  (< i2@160@00 V@90@00)
  (and
    (< i2@160@00 V@90@00)
    (< i1@159@00 (alen<Int> (opt_get1 $Snap.unit a2@89@00)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@156@00 s@$ this@88@00 a2@89@00 V@90@00) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1@159@00)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1@159@00))
    (< i2@160@00 (alen<Int> (opt_get1 $Snap.unit a2@89@00)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@156@00 s@$ this@88@00 a2@89@00 V@90@00) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i2@160@00)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i2@160@00)))))
; Joined path conditions
(pop) ; 9
(push) ; 9
; [else-branch: 87 | !(0 <= i2@160@00)]
(assert (not (<= 0 i2@160@00)))
(pop) ; 9
(pop) ; 8
; Joined path conditions
(assert (implies
  (<= 0 i2@160@00)
  (and
    (<= 0 i2@160@00)
    (implies
      (< i2@160@00 V@90@00)
      (and
        (< i2@160@00 V@90@00)
        (< i1@159@00 (alen<Int> (opt_get1 $Snap.unit a2@89@00)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@156@00 s@$ this@88@00 a2@89@00 V@90@00) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1@159@00)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1@159@00))
        (< i2@160@00 (alen<Int> (opt_get1 $Snap.unit a2@89@00)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@156@00 s@$ this@88@00 a2@89@00 V@90@00) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i2@160@00)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i2@160@00)))))))
; Joined path conditions
(pop) ; 7
(push) ; 7
; [else-branch: 86 | !(i1@159@00 < V@90@00)]
(assert (not (< i1@159@00 V@90@00)))
(pop) ; 7
(pop) ; 6
; Joined path conditions
(assert (implies
  (< i1@159@00 V@90@00)
  (and
    (< i1@159@00 V@90@00)
    (implies
      (<= 0 i2@160@00)
      (and
        (<= 0 i2@160@00)
        (implies
          (< i2@160@00 V@90@00)
          (and
            (< i2@160@00 V@90@00)
            (< i1@159@00 (alen<Int> (opt_get1 $Snap.unit a2@89@00)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@156@00 s@$ this@88@00 a2@89@00 V@90@00) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1@159@00)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1@159@00))
            (< i2@160@00 (alen<Int> (opt_get1 $Snap.unit a2@89@00)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@156@00 s@$ this@88@00 a2@89@00 V@90@00) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i2@160@00)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i2@160@00)))))))))
; Joined path conditions
(pop) ; 5
(push) ; 5
; [else-branch: 85 | !(0 <= i1@159@00)]
(assert (not (<= 0 i1@159@00)))
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (implies
  (<= 0 i1@159@00)
  (and
    (<= 0 i1@159@00)
    (implies
      (< i1@159@00 V@90@00)
      (and
        (< i1@159@00 V@90@00)
        (implies
          (<= 0 i2@160@00)
          (and
            (<= 0 i2@160@00)
            (implies
              (< i2@160@00 V@90@00)
              (and
                (< i2@160@00 V@90@00)
                (< i1@159@00 (alen<Int> (opt_get1 $Snap.unit a2@89@00)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@156@00 s@$ this@88@00 a2@89@00 V@90@00) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1@159@00)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1@159@00))
                (< i2@160@00 (alen<Int> (opt_get1 $Snap.unit a2@89@00)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@156@00 s@$ this@88@00 a2@89@00 V@90@00) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i2@160@00)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i2@160@00)))))))))))
; Joined path conditions
(push) ; 4
; [then-branch: 89 | Lookup(option$array$,sm@156@00(s@$, this@88@00, a2@89@00, V@90@00),aloc((_, _), opt_get1(_, a2@89@00), i1@159@00)) == Lookup(option$array$,sm@156@00(s@$, this@88@00, a2@89@00, V@90@00),aloc((_, _), opt_get1(_, a2@89@00), i2@160@00)) && i2@160@00 < V@90@00 && 0 <= i2@160@00 && i1@159@00 < V@90@00 && 0 <= i1@159@00 | live]
; [else-branch: 89 | !(Lookup(option$array$,sm@156@00(s@$, this@88@00, a2@89@00, V@90@00),aloc((_, _), opt_get1(_, a2@89@00), i1@159@00)) == Lookup(option$array$,sm@156@00(s@$, this@88@00, a2@89@00, V@90@00),aloc((_, _), opt_get1(_, a2@89@00), i2@160@00)) && i2@160@00 < V@90@00 && 0 <= i2@160@00 && i1@159@00 < V@90@00 && 0 <= i1@159@00) | live]
(push) ; 5
; [then-branch: 89 | Lookup(option$array$,sm@156@00(s@$, this@88@00, a2@89@00, V@90@00),aloc((_, _), opt_get1(_, a2@89@00), i1@159@00)) == Lookup(option$array$,sm@156@00(s@$, this@88@00, a2@89@00, V@90@00),aloc((_, _), opt_get1(_, a2@89@00), i2@160@00)) && i2@160@00 < V@90@00 && 0 <= i2@160@00 && i1@159@00 < V@90@00 && 0 <= i1@159@00]
(assert (and
  (and
    (and
      (and
        (=
          ($FVF.lookup_option$array$ (sm@156@00 s@$ this@88@00 a2@89@00 V@90@00) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1@159@00))
          ($FVF.lookup_option$array$ (sm@156@00 s@$ this@88@00 a2@89@00 V@90@00) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i2@160@00)))
        (< i2@160@00 V@90@00))
      (<= 0 i2@160@00))
    (< i1@159@00 V@90@00))
  (<= 0 i1@159@00)))
; [eval] i1 == i2
(pop) ; 5
(push) ; 5
; [else-branch: 89 | !(Lookup(option$array$,sm@156@00(s@$, this@88@00, a2@89@00, V@90@00),aloc((_, _), opt_get1(_, a2@89@00), i1@159@00)) == Lookup(option$array$,sm@156@00(s@$, this@88@00, a2@89@00, V@90@00),aloc((_, _), opt_get1(_, a2@89@00), i2@160@00)) && i2@160@00 < V@90@00 && 0 <= i2@160@00 && i1@159@00 < V@90@00 && 0 <= i1@159@00)]
(assert (not
  (and
    (and
      (and
        (and
          (=
            ($FVF.lookup_option$array$ (sm@156@00 s@$ this@88@00 a2@89@00 V@90@00) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1@159@00))
            ($FVF.lookup_option$array$ (sm@156@00 s@$ this@88@00 a2@89@00 V@90@00) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i2@160@00)))
          (< i2@160@00 V@90@00))
        (<= 0 i2@160@00))
      (< i1@159@00 V@90@00))
    (<= 0 i1@159@00))))
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (implies
  (and
    (and
      (and
        (and
          (=
            ($FVF.lookup_option$array$ (sm@156@00 s@$ this@88@00 a2@89@00 V@90@00) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1@159@00))
            ($FVF.lookup_option$array$ (sm@156@00 s@$ this@88@00 a2@89@00 V@90@00) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i2@160@00)))
          (< i2@160@00 V@90@00))
        (<= 0 i2@160@00))
      (< i1@159@00 V@90@00))
    (<= 0 i1@159@00))
  (and
    (=
      ($FVF.lookup_option$array$ (sm@156@00 s@$ this@88@00 a2@89@00 V@90@00) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1@159@00))
      ($FVF.lookup_option$array$ (sm@156@00 s@$ this@88@00 a2@89@00 V@90@00) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i2@160@00)))
    (< i2@160@00 V@90@00)
    (<= 0 i2@160@00)
    (< i1@159@00 V@90@00)
    (<= 0 i1@159@00))))
; Joined path conditions
(pop) ; 3
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i2@160@00 Int)) (!
  (and
    (implies
      (<= 0 i1@159@00)
      (and
        (<= 0 i1@159@00)
        (implies
          (< i1@159@00 V@90@00)
          (and
            (< i1@159@00 V@90@00)
            (implies
              (<= 0 i2@160@00)
              (and
                (<= 0 i2@160@00)
                (implies
                  (< i2@160@00 V@90@00)
                  (and
                    (< i2@160@00 V@90@00)
                    (< i1@159@00 (alen<Int> (opt_get1 $Snap.unit a2@89@00)))
                    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@156@00 s@$ this@88@00 a2@89@00 V@90@00) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1@159@00)) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1@159@00))
                    (< i2@160@00 (alen<Int> (opt_get1 $Snap.unit a2@89@00)))
                    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@156@00 s@$ this@88@00 a2@89@00 V@90@00) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i2@160@00)) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i2@160@00))))))))))
    (implies
      (and
        (and
          (and
            (and
              (=
                ($FVF.lookup_option$array$ (sm@156@00 s@$ this@88@00 a2@89@00 V@90@00) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1@159@00))
                ($FVF.lookup_option$array$ (sm@156@00 s@$ this@88@00 a2@89@00 V@90@00) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i2@160@00)))
              (< i2@160@00 V@90@00))
            (<= 0 i2@160@00))
          (< i1@159@00 V@90@00))
        (<= 0 i1@159@00))
      (and
        (=
          ($FVF.lookup_option$array$ (sm@156@00 s@$ this@88@00 a2@89@00 V@90@00) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1@159@00))
          ($FVF.lookup_option$array$ (sm@156@00 s@$ this@88@00 a2@89@00 V@90@00) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i2@160@00)))
        (< i2@160@00 V@90@00)
        (<= 0 i2@160@00)
        (< i1@159@00 V@90@00)
        (<= 0 i1@159@00))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i2@160@00))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 2
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@159@00 Int)) (!
  (forall ((i2@160@00 Int)) (!
    (and
      (implies
        (<= 0 i1@159@00)
        (and
          (<= 0 i1@159@00)
          (implies
            (< i1@159@00 V@90@00)
            (and
              (< i1@159@00 V@90@00)
              (implies
                (<= 0 i2@160@00)
                (and
                  (<= 0 i2@160@00)
                  (implies
                    (< i2@160@00 V@90@00)
                    (and
                      (< i2@160@00 V@90@00)
                      (< i1@159@00 (alen<Int> (opt_get1 $Snap.unit a2@89@00)))
                      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@156@00 s@$ this@88@00 a2@89@00 V@90@00) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1@159@00)) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1@159@00))
                      (< i2@160@00 (alen<Int> (opt_get1 $Snap.unit a2@89@00)))
                      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@156@00 s@$ this@88@00 a2@89@00 V@90@00) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i2@160@00)) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i2@160@00))))))))))
      (implies
        (and
          (and
            (and
              (and
                (=
                  ($FVF.lookup_option$array$ (sm@156@00 s@$ this@88@00 a2@89@00 V@90@00) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1@159@00))
                  ($FVF.lookup_option$array$ (sm@156@00 s@$ this@88@00 a2@89@00 V@90@00) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i2@160@00)))
                (< i2@160@00 V@90@00))
              (<= 0 i2@160@00))
            (< i1@159@00 V@90@00))
          (<= 0 i1@159@00))
        (and
          (=
            ($FVF.lookup_option$array$ (sm@156@00 s@$ this@88@00 a2@89@00 V@90@00) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1@159@00))
            ($FVF.lookup_option$array$ (sm@156@00 s@$ this@88@00 a2@89@00 V@90@00) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i2@160@00)))
          (< i2@160@00 V@90@00)
          (<= 0 i2@160@00)
          (< i1@159@00 V@90@00)
          (<= 0 i1@159@00))))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i2@160@00))
    :qid |prog.l<no position>-aux|))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1@159@00))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(assert (forall ((i1@159@00 Int)) (!
  (forall ((i2@160@00 Int)) (!
    (implies
      (and
        (and
          (and
            (and
              (=
                ($FVF.lookup_option$array$ (sm@156@00 s@$ this@88@00 a2@89@00 V@90@00) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1@159@00))
                ($FVF.lookup_option$array$ (sm@156@00 s@$ this@88@00 a2@89@00 V@90@00) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i2@160@00)))
              (< i2@160@00 V@90@00))
            (<= 0 i2@160@00))
          (< i1@159@00 V@90@00))
        (<= 0 i1@159@00))
      (= i1@159@00 i2@160@00))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i2@160@00))
    :qid |prog.l<no position>|))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1@159@00))
  :qid |prog.l<no position>|)))
(declare-const i1@161@00 Int)
(declare-const j@162@00 Int)
(push) ; 2
; [eval] 0 <= i1 && i1 < V && (0 <= j && j < V)
; [eval] 0 <= i1
(push) ; 3
; [then-branch: 90 | 0 <= i1@161@00 | live]
; [else-branch: 90 | !(0 <= i1@161@00) | live]
(push) ; 4
; [then-branch: 90 | 0 <= i1@161@00]
(assert (<= 0 i1@161@00))
; [eval] i1 < V
(push) ; 5
; [then-branch: 91 | i1@161@00 < V@90@00 | live]
; [else-branch: 91 | !(i1@161@00 < V@90@00) | live]
(push) ; 6
; [then-branch: 91 | i1@161@00 < V@90@00]
(assert (< i1@161@00 V@90@00))
; [eval] 0 <= j
(push) ; 7
; [then-branch: 92 | 0 <= j@162@00 | live]
; [else-branch: 92 | !(0 <= j@162@00) | live]
(push) ; 8
; [then-branch: 92 | 0 <= j@162@00]
(assert (<= 0 j@162@00))
; [eval] j < V
(pop) ; 8
(push) ; 8
; [else-branch: 92 | !(0 <= j@162@00)]
(assert (not (<= 0 j@162@00)))
(pop) ; 8
(pop) ; 7
; Joined path conditions
; Joined path conditions
(pop) ; 6
(push) ; 6
; [else-branch: 91 | !(i1@161@00 < V@90@00)]
(assert (not (< i1@161@00 V@90@00)))
(pop) ; 6
(pop) ; 5
; Joined path conditions
; Joined path conditions
(pop) ; 4
(push) ; 4
; [else-branch: 90 | !(0 <= i1@161@00)]
(assert (not (<= 0 i1@161@00)))
(pop) ; 4
(pop) ; 3
; Joined path conditions
; Joined path conditions
(assert (and
  (and (and (< j@162@00 V@90@00) (<= 0 j@162@00)) (< i1@161@00 V@90@00))
  (<= 0 i1@161@00)))
; [eval] aloc(opt_get1(aloc(opt_get1(a2), i1).option$array$), j)
; [eval] opt_get1(aloc(opt_get1(a2), i1).option$array$)
; [eval] aloc(opt_get1(a2), i1)
; [eval] opt_get1(a2)
(push) ; 3
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 3
; Joined path conditions
(push) ; 3
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 4
(assert (not (< i1@161@00 (alen<Int> (opt_get1 $Snap.unit a2@89@00)))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1511
;  :arith-add-rows          1238
;  :arith-assert-diseq      158
;  :arith-assert-lower      656
;  :arith-assert-upper      348
;  :arith-bound-prop        96
;  :arith-conflicts         56
;  :arith-eq-adapter        280
;  :arith-fixed-eqs         201
;  :arith-offset-eqs        71
;  :arith-pivots            541
;  :conflicts               107
;  :datatype-accessor-ax    107
;  :datatype-constructor-ax 12
;  :datatype-occurs-check   68
;  :datatype-splits         12
;  :decisions               155
;  :del-clause              2119
;  :final-checks            68
;  :interface-eqs           9
;  :max-generation          6
;  :max-memory              4.93
;  :memory                  4.92
;  :mk-bool-var             3881
;  :mk-clause               2121
;  :num-allocs              220666
;  :num-checks              144
;  :propagations            822
;  :quant-instantiations    1074
;  :rlimit-count            307062)
(assert (< i1@161@00 (alen<Int> (opt_get1 $Snap.unit a2@89@00))))
(pop) ; 3
; Joined path conditions
(assert (< i1@161@00 (alen<Int> (opt_get1 $Snap.unit a2@89@00))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@156@00 s@$ this@88@00 a2@89@00 V@90@00) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1@161@00)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1@161@00)))
(push) ; 3
(assert (not (ite
  (and
    (<
      (inv@155@00 s@$ this@88@00 a2@89@00 V@90@00 (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1@161@00))
      V@90@00)
    (<=
      0
      (inv@155@00 s@$ this@88@00 a2@89@00 V@90@00 (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1@161@00))))
  (< $Perm.No $k@154@00)
  false)))
(check-sat)
; unsat
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1521
;  :arith-add-rows          1246
;  :arith-assert-diseq      158
;  :arith-assert-lower      657
;  :arith-assert-upper      350
;  :arith-bound-prop        98
;  :arith-conflicts         57
;  :arith-eq-adapter        281
;  :arith-fixed-eqs         202
;  :arith-offset-eqs        74
;  :arith-pivots            543
;  :conflicts               108
;  :datatype-accessor-ax    107
;  :datatype-constructor-ax 12
;  :datatype-occurs-check   68
;  :datatype-splits         12
;  :decisions               155
;  :del-clause              2119
;  :final-checks            68
;  :interface-eqs           9
;  :max-generation          6
;  :max-memory              4.93
;  :memory                  4.92
;  :mk-bool-var             3909
;  :mk-clause               2128
;  :num-allocs              221009
;  :num-checks              145
;  :propagations            825
;  :quant-instantiations    1089
;  :rlimit-count            308141)
(push) ; 3
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 4
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (sm@156@00 s@$ this@88@00 a2@89@00 V@90@00) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1@161@00))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1521
;  :arith-add-rows          1246
;  :arith-assert-diseq      158
;  :arith-assert-lower      657
;  :arith-assert-upper      350
;  :arith-bound-prop        98
;  :arith-conflicts         57
;  :arith-eq-adapter        281
;  :arith-fixed-eqs         202
;  :arith-offset-eqs        74
;  :arith-pivots            543
;  :conflicts               109
;  :datatype-accessor-ax    107
;  :datatype-constructor-ax 12
;  :datatype-occurs-check   68
;  :datatype-splits         12
;  :decisions               155
;  :del-clause              2119
;  :final-checks            68
;  :interface-eqs           9
;  :max-generation          6
;  :max-memory              4.93
;  :memory                  4.92
;  :mk-bool-var             3909
;  :mk-clause               2128
;  :num-allocs              221099
;  :num-checks              146
;  :propagations            825
;  :quant-instantiations    1089
;  :rlimit-count            308246)
(assert (not
  (=
    ($FVF.lookup_option$array$ (sm@156@00 s@$ this@88@00 a2@89@00 V@90@00) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1@161@00))
    (as None<option<array>>  option<array>))))
(pop) ; 3
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (sm@156@00 s@$ this@88@00 a2@89@00 V@90@00) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1@161@00))
    (as None<option<array>>  option<array>))))
(push) ; 3
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 4
(assert (not (<
  j@162@00
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@156@00 s@$ this@88@00 a2@89@00 V@90@00) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1@161@00)))))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1525
;  :arith-add-rows          1248
;  :arith-assert-diseq      158
;  :arith-assert-lower      659
;  :arith-assert-upper      350
;  :arith-bound-prop        100
;  :arith-conflicts         57
;  :arith-eq-adapter        282
;  :arith-fixed-eqs         202
;  :arith-offset-eqs        74
;  :arith-pivots            545
;  :conflicts               110
;  :datatype-accessor-ax    107
;  :datatype-constructor-ax 12
;  :datatype-occurs-check   68
;  :datatype-splits         12
;  :decisions               155
;  :del-clause              2125
;  :final-checks            68
;  :interface-eqs           9
;  :max-generation          6
;  :max-memory              4.93
;  :memory                  4.92
;  :mk-bool-var             3920
;  :mk-clause               2134
;  :num-allocs              221293
;  :num-checks              147
;  :propagations            825
;  :quant-instantiations    1096
;  :rlimit-count            308681)
(assert (<
  j@162@00
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@156@00 s@$ this@88@00 a2@89@00 V@90@00) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1@161@00))))))
(pop) ; 3
; Joined path conditions
(assert (<
  j@162@00
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@156@00 s@$ this@88@00 a2@89@00 V@90@00) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1@161@00))))))
(declare-const $k@163@00 $Perm)
(assert ($Perm.isReadVar $k@163@00 $Perm.Write))
(pop) ; 2
(declare-fun inv@164@00 ($Snap $Ref option<array> Int $Ref) Int)
(declare-fun inv@165@00 ($Snap $Ref option<array> Int $Ref) Int)
; Nested auxiliary terms: globals
(assert ($Perm.isReadVar $k@163@00 $Perm.Write))
; Nested auxiliary terms: non-globals
(assert (forall ((i1@161@00 Int) (j@162@00 Int)) (!
  (and
    (< i1@161@00 (alen<Int> (opt_get1 $Snap.unit a2@89@00)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@156@00 s@$ this@88@00 a2@89@00 V@90@00) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1@161@00)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1@161@00))
    (not
      (=
        ($FVF.lookup_option$array$ (sm@156@00 s@$ this@88@00 a2@89@00 V@90@00) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1@161@00))
        (as None<option<array>>  option<array>)))
    (<
      j@162@00
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@156@00 s@$ this@88@00 a2@89@00 V@90@00) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1@161@00))))))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@156@00 s@$ this@88@00 a2@89@00 V@90@00) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1@161@00))) j@162@00))
  :qid |int-aux|)))
(push) ; 2
(assert (not (forall ((i1@161@00 Int) (j@162@00 Int)) (!
  (implies
    (and
      (and (and (< j@162@00 V@90@00) (<= 0 j@162@00)) (< i1@161@00 V@90@00))
      (<= 0 i1@161@00))
    (or (= $k@163@00 $Perm.No) (< $Perm.No $k@163@00)))
  
  ))))
(check-sat)
; unsat
(pop) ; 2
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1525
;  :arith-add-rows          1250
;  :arith-assert-diseq      159
;  :arith-assert-lower      661
;  :arith-assert-upper      351
;  :arith-bound-prop        100
;  :arith-conflicts         57
;  :arith-eq-adapter        283
;  :arith-fixed-eqs         202
;  :arith-offset-eqs        74
;  :arith-pivots            549
;  :conflicts               111
;  :datatype-accessor-ax    107
;  :datatype-constructor-ax 12
;  :datatype-occurs-check   68
;  :datatype-splits         12
;  :decisions               155
;  :del-clause              2132
;  :final-checks            68
;  :interface-eqs           9
;  :max-generation          6
;  :max-memory              4.93
;  :memory                  4.92
;  :mk-bool-var             3929
;  :mk-clause               2136
;  :num-allocs              221888
;  :num-checks              148
;  :propagations            826
;  :quant-instantiations    1096
;  :rlimit-count            309666)
; Check receiver injectivity
(push) ; 2
(assert (not (forall ((i11@161@00 Int) (j1@162@00 Int) (i12@161@00 Int) (j2@162@00 Int)) (!
  (implies
    (and
      (and
        (and
          (and
            (and (< j1@162@00 V@90@00) (<= 0 j1@162@00))
            (< i11@161@00 V@90@00))
          (<= 0 i11@161@00))
        (< $Perm.No $k@163@00))
      (and
        (and
          (and
            (and (< j2@162@00 V@90@00) (<= 0 j2@162@00))
            (< i12@161@00 V@90@00))
          (<= 0 i12@161@00))
        (< $Perm.No $k@163@00))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@156@00 s@$ this@88@00 a2@89@00 V@90@00) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i11@161@00))) j1@162@00)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@156@00 s@$ this@88@00 a2@89@00 V@90@00) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i12@161@00))) j2@162@00)))
    (and (= i11@161@00 i12@161@00) (= j1@162@00 j2@162@00)))
  
  :qid |int-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 2
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1567
;  :arith-add-rows          1262
;  :arith-assert-diseq      159
;  :arith-assert-lower      673
;  :arith-assert-upper      357
;  :arith-bound-prop        102
;  :arith-conflicts         57
;  :arith-eq-adapter        290
;  :arith-fixed-eqs         205
;  :arith-offset-eqs        74
;  :arith-pivots            561
;  :conflicts               112
;  :datatype-accessor-ax    107
;  :datatype-constructor-ax 12
;  :datatype-occurs-check   68
;  :datatype-splits         12
;  :decisions               155
;  :del-clause              2192
;  :final-checks            68
;  :interface-eqs           9
;  :max-generation          6
;  :max-memory              4.97
;  :memory                  4.96
;  :mk-bool-var             4064
;  :mk-clause               2196
;  :num-allocs              222799
;  :num-checks              149
;  :propagations            848
;  :quant-instantiations    1154
;  :rlimit-count            312915)
; Definitional axioms for inverse functions
(assert (forall ((i1@161@00 Int) (j@162@00 Int)) (!
  (implies
    (and
      (and
        (and (and (< j@162@00 V@90@00) (<= 0 j@162@00)) (< i1@161@00 V@90@00))
        (<= 0 i1@161@00))
      (< $Perm.No $k@163@00))
    (and
      (=
        (inv@164@00 s@$ this@88@00 a2@89@00 V@90@00 (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@156@00 s@$ this@88@00 a2@89@00 V@90@00) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1@161@00))) j@162@00))
        i1@161@00)
      (=
        (inv@165@00 s@$ this@88@00 a2@89@00 V@90@00 (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@156@00 s@$ this@88@00 a2@89@00 V@90@00) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1@161@00))) j@162@00))
        j@162@00)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@156@00 s@$ this@88@00 a2@89@00 V@90@00) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1@161@00))) j@162@00))
  )))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and
          (and
            (< (inv@165@00 s@$ this@88@00 a2@89@00 V@90@00 r) V@90@00)
            (<= 0 (inv@165@00 s@$ this@88@00 a2@89@00 V@90@00 r)))
          (< (inv@164@00 s@$ this@88@00 a2@89@00 V@90@00 r) V@90@00))
        (<= 0 (inv@164@00 s@$ this@88@00 a2@89@00 V@90@00 r)))
      (< $Perm.No $k@163@00))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@156@00 s@$ this@88@00 a2@89@00 V@90@00) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit a2@89@00) (inv@164@00 s@$ this@88@00 a2@89@00 V@90@00 r)))) (inv@165@00 s@$ this@88@00 a2@89@00 V@90@00 r))
      r))
  :pattern ((inv@164@00 s@$ this@88@00 a2@89@00 V@90@00 r))
  :pattern ((inv@165@00 s@$ this@88@00 a2@89@00 V@90@00 r))
  :qid |int-fctOfInv|)))
; Permissions are non-negative
(assert (forall ((i1@161@00 Int) (j@162@00 Int)) (!
  (<= $Perm.No $k@163@00)
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@156@00 s@$ this@88@00 a2@89@00 V@90@00) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1@161@00))) j@162@00))
  :qid |int-permAtLeastZero|)))
; Field permissions are at most one
(assert (forall ((i1@161@00 Int) (j@162@00 Int)) (!
  (<= $k@163@00 $Perm.Write)
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@156@00 s@$ this@88@00 a2@89@00 V@90@00) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1@161@00))) j@162@00))
  :qid |int-permAtMostOne|)))
; Permission implies non-null receiver
(assert (forall ((i1@161@00 Int) (j@162@00 Int)) (!
  (implies
    (and
      (and
        (and (and (< j@162@00 V@90@00) (<= 0 j@162@00)) (< i1@161@00 V@90@00))
        (<= 0 i1@161@00))
      (< $Perm.No $k@163@00))
    (not
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@156@00 s@$ this@88@00 a2@89@00 V@90@00) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1@161@00))) j@162@00)
        $Ref.null)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@156@00 s@$ this@88@00 a2@89@00 V@90@00) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1@161@00))) j@162@00))
  :qid |int-permImpliesNonNull|)))
(declare-fun sm@166@00 ($Snap $Ref option<array> Int) $FVF<Int>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and
        (and
          (and
            (< (inv@165@00 s@$ this@88@00 a2@89@00 V@90@00 r) V@90@00)
            (<= 0 (inv@165@00 s@$ this@88@00 a2@89@00 V@90@00 r)))
          (< (inv@164@00 s@$ this@88@00 a2@89@00 V@90@00 r) V@90@00))
        (<= 0 (inv@164@00 s@$ this@88@00 a2@89@00 V@90@00 r)))
      (< $Perm.No $k@163@00)
      false)
    (=
      ($FVF.lookup_int (sm@166@00 s@$ this@88@00 a2@89@00 V@90@00) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$)))))))) r)))
  :pattern (($FVF.lookup_int (sm@166@00 s@$ this@88@00 a2@89@00 V@90@00) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$)))))))) r))
  :qid |qp.fvfValDef11|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$)))))))) r) r)
  :pattern (($FVF.lookup_int (sm@166@00 s@$ this@88@00 a2@89@00 V@90@00) r))
  :qid |qp.fvfResTrgDef12|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and
          (< (inv@165@00 s@$ this@88@00 a2@89@00 V@90@00 r) V@90@00)
          (<= 0 (inv@165@00 s@$ this@88@00 a2@89@00 V@90@00 r)))
        (< (inv@164@00 s@$ this@88@00 a2@89@00 V@90@00 r) V@90@00))
      (<= 0 (inv@164@00 s@$ this@88@00 a2@89@00 V@90@00 r)))
    ($FVF.loc_int ($FVF.lookup_int (sm@166@00 s@$ this@88@00 a2@89@00 V@90@00) r) r))
  :pattern ((inv@164@00 s@$ this@88@00 a2@89@00 V@90@00 r) (inv@165@00 s@$ this@88@00 a2@89@00 V@90@00 r))
  )))
(declare-const $t@167@00 $Snap)
(assert (= $t@167@00 ($Snap.combine ($Snap.first $t@167@00) ($Snap.second $t@167@00))))
(assert (= ($Snap.first $t@167@00) $Snap.unit))
; [eval] SquareIntMatrix(this, result, V)
(push) ; 2
; [eval] this != null
(pop) ; 2
; Joined path conditions
(assert (SquareIntMatrix $Snap.unit this@88@00 result@91@00 V@90@00))
(assert (= ($Snap.second $t@167@00) $Snap.unit))
; [eval] (forall i1: Int :: { result[i1] } { unknown(aloc(opt_get1(a2), i1).option$array$, 0, alen(opt_get1(aloc(opt_get1(a2), i1).option$array$))) } 0 <= i1 && i1 < V ==> result[i1] == unknown(aloc(opt_get1(a2), i1).option$array$, 0, alen(opt_get1(aloc(opt_get1(a2), i1).option$array$))))
(declare-const i1@168@00 Int)
(push) ; 2
; [eval] 0 <= i1 && i1 < V ==> result[i1] == unknown(aloc(opt_get1(a2), i1).option$array$, 0, alen(opt_get1(aloc(opt_get1(a2), i1).option$array$)))
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 3
; [then-branch: 93 | 0 <= i1@168@00 | live]
; [else-branch: 93 | !(0 <= i1@168@00) | live]
(push) ; 4
; [then-branch: 93 | 0 <= i1@168@00]
(assert (<= 0 i1@168@00))
; [eval] i1 < V
(pop) ; 4
(push) ; 4
; [else-branch: 93 | !(0 <= i1@168@00)]
(assert (not (<= 0 i1@168@00)))
(pop) ; 4
(pop) ; 3
; Joined path conditions
; Joined path conditions
(push) ; 3
; [then-branch: 94 | i1@168@00 < V@90@00 && 0 <= i1@168@00 | live]
; [else-branch: 94 | !(i1@168@00 < V@90@00 && 0 <= i1@168@00) | live]
(push) ; 4
; [then-branch: 94 | i1@168@00 < V@90@00 && 0 <= i1@168@00]
(assert (and (< i1@168@00 V@90@00) (<= 0 i1@168@00)))
; [eval] result[i1] == unknown(aloc(opt_get1(a2), i1).option$array$, 0, alen(opt_get1(aloc(opt_get1(a2), i1).option$array$)))
; [eval] result[i1]
(push) ; 5
(assert (not (>= i1@168@00 0)))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1580
;  :arith-add-rows          1264
;  :arith-assert-diseq      159
;  :arith-assert-lower      678
;  :arith-assert-upper      361
;  :arith-bound-prop        103
;  :arith-conflicts         57
;  :arith-eq-adapter        294
;  :arith-fixed-eqs         207
;  :arith-offset-eqs        74
;  :arith-pivots            564
;  :conflicts               112
;  :datatype-accessor-ax    108
;  :datatype-constructor-ax 12
;  :datatype-occurs-check   68
;  :datatype-splits         12
;  :decisions               155
;  :del-clause              2192
;  :final-checks            68
;  :interface-eqs           9
;  :max-generation          6
;  :max-memory              4.97
;  :memory                  4.97
;  :mk-bool-var             4102
;  :mk-clause               2217
;  :num-allocs              224267
;  :num-checks              150
;  :propagations            853
;  :quant-instantiations    1160
;  :rlimit-count            316633)
(push) ; 5
(assert (not (< i1@168@00 (Seq_length result@91@00))))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1580
;  :arith-add-rows          1266
;  :arith-assert-diseq      159
;  :arith-assert-lower      679
;  :arith-assert-upper      361
;  :arith-bound-prop        103
;  :arith-conflicts         58
;  :arith-eq-adapter        294
;  :arith-fixed-eqs         207
;  :arith-offset-eqs        74
;  :arith-pivots            564
;  :conflicts               113
;  :datatype-accessor-ax    108
;  :datatype-constructor-ax 12
;  :datatype-occurs-check   68
;  :datatype-splits         12
;  :decisions               155
;  :del-clause              2192
;  :final-checks            68
;  :interface-eqs           9
;  :max-generation          6
;  :max-memory              4.98
;  :memory                  4.97
;  :mk-bool-var             4103
;  :mk-clause               2217
;  :num-allocs              224351
;  :num-checks              151
;  :propagations            853
;  :quant-instantiations    1160
;  :rlimit-count            316727)
; [eval] unknown(aloc(opt_get1(a2), i1).option$array$, 0, alen(opt_get1(aloc(opt_get1(a2), i1).option$array$)))
; [eval] aloc(opt_get1(a2), i1)
; [eval] opt_get1(a2)
(push) ; 5
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 5
; Joined path conditions
(push) ; 5
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 6
(assert (not (< i1@168@00 (alen<Int> (opt_get1 $Snap.unit a2@89@00)))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1580
;  :arith-add-rows          1266
;  :arith-assert-diseq      159
;  :arith-assert-lower      679
;  :arith-assert-upper      361
;  :arith-bound-prop        103
;  :arith-conflicts         58
;  :arith-eq-adapter        294
;  :arith-fixed-eqs         207
;  :arith-offset-eqs        74
;  :arith-pivots            564
;  :conflicts               113
;  :datatype-accessor-ax    108
;  :datatype-constructor-ax 12
;  :datatype-occurs-check   68
;  :datatype-splits         12
;  :decisions               155
;  :del-clause              2192
;  :final-checks            68
;  :interface-eqs           9
;  :max-generation          6
;  :max-memory              4.98
;  :memory                  4.97
;  :mk-bool-var             4103
;  :mk-clause               2217
;  :num-allocs              224377
;  :num-checks              152
;  :propagations            853
;  :quant-instantiations    1160
;  :rlimit-count            316757)
(assert (< i1@168@00 (alen<Int> (opt_get1 $Snap.unit a2@89@00))))
(pop) ; 5
; Joined path conditions
(assert (< i1@168@00 (alen<Int> (opt_get1 $Snap.unit a2@89@00))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@156@00 s@$ this@88@00 a2@89@00 V@90@00) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1@168@00)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1@168@00)))
(push) ; 5
(assert (not (ite
  (and
    (<
      (inv@155@00 s@$ this@88@00 a2@89@00 V@90@00 (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1@168@00))
      V@90@00)
    (<=
      0
      (inv@155@00 s@$ this@88@00 a2@89@00 V@90@00 (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1@168@00))))
  (< $Perm.No $k@154@00)
  false)))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1592
;  :arith-add-rows          1273
;  :arith-assert-diseq      159
;  :arith-assert-lower      680
;  :arith-assert-upper      363
;  :arith-bound-prop        105
;  :arith-conflicts         59
;  :arith-eq-adapter        295
;  :arith-fixed-eqs         208
;  :arith-offset-eqs        77
;  :arith-pivots            566
;  :conflicts               114
;  :datatype-accessor-ax    108
;  :datatype-constructor-ax 12
;  :datatype-occurs-check   68
;  :datatype-splits         12
;  :decisions               155
;  :del-clause              2192
;  :final-checks            68
;  :interface-eqs           9
;  :max-generation          6
;  :max-memory              4.98
;  :memory                  4.97
;  :mk-bool-var             4132
;  :mk-clause               2224
;  :num-allocs              224725
;  :num-checks              153
;  :propagations            856
;  :quant-instantiations    1175
;  :rlimit-count            317842)
; [eval] alen(opt_get1(aloc(opt_get1(a2), i1).option$array$))
; [eval] opt_get1(aloc(opt_get1(a2), i1).option$array$)
; [eval] aloc(opt_get1(a2), i1)
; [eval] opt_get1(a2)
(push) ; 5
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 5
; Joined path conditions
(push) ; 5
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(pop) ; 5
; Joined path conditions
(push) ; 5
(assert (not (ite
  (and
    (<
      (inv@155@00 s@$ this@88@00 a2@89@00 V@90@00 (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1@168@00))
      V@90@00)
    (<=
      0
      (inv@155@00 s@$ this@88@00 a2@89@00 V@90@00 (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1@168@00))))
  (< $Perm.No $k@154@00)
  false)))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1592
;  :arith-add-rows          1273
;  :arith-assert-diseq      159
;  :arith-assert-lower      680
;  :arith-assert-upper      364
;  :arith-bound-prop        105
;  :arith-conflicts         60
;  :arith-eq-adapter        295
;  :arith-fixed-eqs         208
;  :arith-offset-eqs        77
;  :arith-pivots            566
;  :conflicts               115
;  :datatype-accessor-ax    108
;  :datatype-constructor-ax 12
;  :datatype-occurs-check   68
;  :datatype-splits         12
;  :decisions               155
;  :del-clause              2192
;  :final-checks            68
;  :interface-eqs           9
;  :max-generation          6
;  :max-memory              4.98
;  :memory                  4.97
;  :mk-bool-var             4132
;  :mk-clause               2224
;  :num-allocs              224820
;  :num-checks              154
;  :propagations            856
;  :quant-instantiations    1175
;  :rlimit-count            318027)
(push) ; 5
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 6
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (sm@156@00 s@$ this@88@00 a2@89@00 V@90@00) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1@168@00))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1592
;  :arith-add-rows          1273
;  :arith-assert-diseq      159
;  :arith-assert-lower      680
;  :arith-assert-upper      364
;  :arith-bound-prop        105
;  :arith-conflicts         60
;  :arith-eq-adapter        295
;  :arith-fixed-eqs         208
;  :arith-offset-eqs        77
;  :arith-pivots            566
;  :conflicts               116
;  :datatype-accessor-ax    108
;  :datatype-constructor-ax 12
;  :datatype-occurs-check   68
;  :datatype-splits         12
;  :decisions               155
;  :del-clause              2192
;  :final-checks            68
;  :interface-eqs           9
;  :max-generation          6
;  :max-memory              4.98
;  :memory                  4.97
;  :mk-bool-var             4132
;  :mk-clause               2224
;  :num-allocs              224910
;  :num-checks              155
;  :propagations            856
;  :quant-instantiations    1175
;  :rlimit-count            318132)
(assert (not
  (=
    ($FVF.lookup_option$array$ (sm@156@00 s@$ this@88@00 a2@89@00 V@90@00) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1@168@00))
    (as None<option<array>>  option<array>))))
(pop) ; 5
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (sm@156@00 s@$ this@88@00 a2@89@00 V@90@00) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1@168@00))
    (as None<option<array>>  option<array>))))
(push) ; 5
; [eval] a2 != (None(): option[array])
; [eval] (None(): option[array])
; [eval] 0 <= from
; [eval] from <= to
(push) ; 6
(assert (not (<=
  0
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@156@00 s@$ this@88@00 a2@89@00 V@90@00) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1@168@00)))))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1592
;  :arith-add-rows          1274
;  :arith-assert-diseq      159
;  :arith-assert-lower      680
;  :arith-assert-upper      365
;  :arith-bound-prop        105
;  :arith-conflicts         60
;  :arith-eq-adapter        296
;  :arith-fixed-eqs         208
;  :arith-offset-eqs        77
;  :arith-pivots            566
;  :conflicts               117
;  :datatype-accessor-ax    108
;  :datatype-constructor-ax 12
;  :datatype-occurs-check   68
;  :datatype-splits         12
;  :decisions               155
;  :del-clause              2196
;  :final-checks            68
;  :interface-eqs           9
;  :max-generation          6
;  :max-memory              4.98
;  :memory                  4.97
;  :mk-bool-var             4140
;  :mk-clause               2228
;  :num-allocs              225096
;  :num-checks              156
;  :propagations            856
;  :quant-instantiations    1180
;  :rlimit-count            318493)
(assert (<=
  0
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@156@00 s@$ this@88@00 a2@89@00 V@90@00) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1@168@00))))))
; [eval] to <= alen(opt_get1(a2))
; [eval] alen(opt_get1(a2))
; [eval] opt_get1(a2)
(push) ; 6
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 6
; Joined path conditions
(declare-const i1@169@00 Int)
(push) ; 6
; [eval] from <= i1 && i1 < to
; [eval] from <= i1
(push) ; 7
; [then-branch: 95 | 0 <= i1@169@00 | live]
; [else-branch: 95 | !(0 <= i1@169@00) | live]
(push) ; 8
; [then-branch: 95 | 0 <= i1@169@00]
(assert (<= 0 i1@169@00))
; [eval] i1 < to
(pop) ; 8
(push) ; 8
; [else-branch: 95 | !(0 <= i1@169@00)]
(assert (not (<= 0 i1@169@00)))
(pop) ; 8
(pop) ; 7
; Joined path conditions
; Joined path conditions
(assert (and
  (<
    i1@169@00
    (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@156@00 s@$ this@88@00 a2@89@00 V@90@00) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1@168@00)))))
  (<= 0 i1@169@00)))
(declare-const $k@170@00 $Perm)
(assert ($Perm.isReadVar $k@170@00 $Perm.Write))
; [eval] aloc(opt_get1(a2), i1)
; [eval] opt_get1(a2)
(push) ; 7
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 7
; Joined path conditions
(push) ; 7
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(pop) ; 7
; Joined path conditions
(pop) ; 6
(declare-fun inv@171@00 ($Snap $Ref option<array> Int Int $Ref) Int)
; Nested auxiliary terms: globals
(assert ($Perm.isReadVar $k@170@00 $Perm.Write))
; Nested auxiliary terms: non-globals
(push) ; 6
(assert (not (forall ((i1@169@00 Int)) (!
  (implies
    (and
      (<
        i1@169@00
        (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@156@00 s@$ this@88@00 a2@89@00 V@90@00) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1@168@00)))))
      (<= 0 i1@169@00))
    (or (= $k@170@00 $Perm.No) (< $Perm.No $k@170@00)))
  
  ))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1599
;  :arith-add-rows          1277
;  :arith-assert-diseq      161
;  :arith-assert-lower      688
;  :arith-assert-upper      368
;  :arith-bound-prop        105
;  :arith-conflicts         60
;  :arith-eq-adapter        299
;  :arith-fixed-eqs         209
;  :arith-offset-eqs        77
;  :arith-pivots            567
;  :conflicts               118
;  :datatype-accessor-ax    108
;  :datatype-constructor-ax 12
;  :datatype-occurs-check   68
;  :datatype-splits         12
;  :decisions               155
;  :del-clause              2198
;  :final-checks            68
;  :interface-eqs           9
;  :max-generation          6
;  :max-memory              4.98
;  :memory                  4.97
;  :mk-bool-var             4162
;  :mk-clause               2236
;  :num-allocs              225689
;  :num-checks              157
;  :propagations            860
;  :quant-instantiations    1187
;  :rlimit-count            319496)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 6
(assert (not (forall ((i11@169@00 Int) (i12@169@00 Int)) (!
  (implies
    (and
      (and
        (and
          (and
            (<
              i11@169@00
              (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@156@00 s@$ this@88@00 a2@89@00 V@90@00) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1@168@00)))))
            (<= 0 i11@169@00))
          ($FVF.loc_int ($FVF.lookup_int (sm@166@00 s@$ this@88@00 a2@89@00 V@90@00) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@156@00 s@$ this@88@00 a2@89@00 V@90@00) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1@168@00))) i11@169@00)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@156@00 s@$ this@88@00 a2@89@00 V@90@00) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1@168@00))) i11@169@00)))
        (< $Perm.No $k@170@00))
      (and
        (and
          (and
            (<
              i12@169@00
              (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@156@00 s@$ this@88@00 a2@89@00 V@90@00) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1@168@00)))))
            (<= 0 i12@169@00))
          ($FVF.loc_int ($FVF.lookup_int (sm@166@00 s@$ this@88@00 a2@89@00 V@90@00) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@156@00 s@$ this@88@00 a2@89@00 V@90@00) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1@168@00))) i12@169@00)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@156@00 s@$ this@88@00 a2@89@00 V@90@00) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1@168@00))) i12@169@00)))
        (< $Perm.No $k@170@00))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@156@00 s@$ this@88@00 a2@89@00 V@90@00) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1@168@00))) i11@169@00)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@156@00 s@$ this@88@00 a2@89@00 V@90@00) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1@168@00))) i12@169@00)))
    (= i11@169@00 i12@169@00))
  
  :qid |int-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1626
;  :arith-add-rows          1287
;  :arith-assert-diseq      163
;  :arith-assert-lower      691
;  :arith-assert-upper      369
;  :arith-bound-prop        107
;  :arith-conflicts         60
;  :arith-eq-adapter        300
;  :arith-fixed-eqs         209
;  :arith-offset-eqs        78
;  :arith-pivots            571
;  :conflicts               119
;  :datatype-accessor-ax    108
;  :datatype-constructor-ax 12
;  :datatype-occurs-check   68
;  :datatype-splits         12
;  :decisions               155
;  :del-clause              2227
;  :final-checks            68
;  :interface-eqs           9
;  :max-generation          6
;  :max-memory              4.98
;  :memory                  4.97
;  :mk-bool-var             4210
;  :mk-clause               2265
;  :num-allocs              226170
;  :num-checks              158
;  :propagations            876
;  :quant-instantiations    1206
;  :rlimit-count            320949)
; Definitional axioms for inverse functions
(assert (forall ((i1@169@00 Int)) (!
  (implies
    (and
      (and
        (<
          i1@169@00
          (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@156@00 s@$ this@88@00 a2@89@00 V@90@00) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1@168@00)))))
        (<= 0 i1@169@00))
      (< $Perm.No $k@170@00))
    (=
      (inv@171@00 s@$ this@88@00 a2@89@00 V@90@00 i1@168@00 (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@156@00 s@$ this@88@00 a2@89@00 V@90@00) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1@168@00))) i1@169@00))
      i1@169@00))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@156@00 s@$ this@88@00 a2@89@00 V@90@00) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1@168@00))) i1@169@00))
  :qid |int-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (<
          (inv@171@00 s@$ this@88@00 a2@89@00 V@90@00 i1@168@00 r)
          (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@156@00 s@$ this@88@00 a2@89@00 V@90@00) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1@168@00)))))
        (<= 0 (inv@171@00 s@$ this@88@00 a2@89@00 V@90@00 i1@168@00 r)))
      (< $Perm.No $k@170@00))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@156@00 s@$ this@88@00 a2@89@00 V@90@00) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1@168@00))) (inv@171@00 s@$ this@88@00 a2@89@00 V@90@00 i1@168@00 r))
      r))
  :pattern ((inv@171@00 s@$ this@88@00 a2@89@00 V@90@00 i1@168@00 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (<
        (inv@171@00 s@$ this@88@00 a2@89@00 V@90@00 i1@168@00 r)
        (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@156@00 s@$ this@88@00 a2@89@00 V@90@00) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1@168@00)))))
      (<= 0 (inv@171@00 s@$ this@88@00 a2@89@00 V@90@00 i1@168@00 r)))
    ($FVF.loc_int ($FVF.lookup_int (sm@166@00 s@$ this@88@00 a2@89@00 V@90@00) r) r))
  :pattern ((inv@171@00 s@$ this@88@00 a2@89@00 V@90@00 i1@168@00 r))
  )))
; Precomputing data for removing quantified permissions
(define-fun pTaken@172@00 ((r $Ref) (s@$ $Snap) (this@88@00 $Ref) (a2@89@00 option<array>) (V@90@00 Int) (i1@168@00 Int)) $Perm
  (ite
    (and
      (<
        (inv@171@00 s@$ this@88@00 a2@89@00 V@90@00 i1@168@00 r)
        (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@156@00 s@$ this@88@00 a2@89@00 V@90@00) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1@168@00)))))
      (<= 0 (inv@171@00 s@$ this@88@00 a2@89@00 V@90@00 i1@168@00 r)))
    ($Perm.min
      (ite
        (and
          (and
            (and
              (< (inv@165@00 s@$ this@88@00 a2@89@00 V@90@00 r) V@90@00)
              (<= 0 (inv@165@00 s@$ this@88@00 a2@89@00 V@90@00 r)))
            (< (inv@164@00 s@$ this@88@00 a2@89@00 V@90@00 r) V@90@00))
          (<= 0 (inv@164@00 s@$ this@88@00 a2@89@00 V@90@00 r)))
        $k@163@00
        $Perm.No)
      $k@170@00)
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Constrain original permissions $k@170@00
(assert (forall ((r $Ref)) (!
  (implies
    (not
      (=
        (ite
          (and
            (and
              (and
                (< (inv@165@00 s@$ this@88@00 a2@89@00 V@90@00 r) V@90@00)
                (<= 0 (inv@165@00 s@$ this@88@00 a2@89@00 V@90@00 r)))
              (< (inv@164@00 s@$ this@88@00 a2@89@00 V@90@00 r) V@90@00))
            (<= 0 (inv@164@00 s@$ this@88@00 a2@89@00 V@90@00 r)))
          $k@163@00
          $Perm.No)
        $Perm.No))
    (ite
      (and
        (and
          (and
            (< (inv@165@00 s@$ this@88@00 a2@89@00 V@90@00 r) V@90@00)
            (<= 0 (inv@165@00 s@$ this@88@00 a2@89@00 V@90@00 r)))
          (< (inv@164@00 s@$ this@88@00 a2@89@00 V@90@00 r) V@90@00))
        (<= 0 (inv@164@00 s@$ this@88@00 a2@89@00 V@90@00 r)))
      (<
        (ite
          (and
            (<
              (inv@171@00 s@$ this@88@00 a2@89@00 V@90@00 i1@168@00 r)
              (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@156@00 s@$ this@88@00 a2@89@00 V@90@00) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1@168@00)))))
            (<= 0 (inv@171@00 s@$ this@88@00 a2@89@00 V@90@00 i1@168@00 r)))
          $k@170@00
          $Perm.No)
        $k@163@00)
      (<
        (ite
          (and
            (<
              (inv@171@00 s@$ this@88@00 a2@89@00 V@90@00 i1@168@00 r)
              (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@156@00 s@$ this@88@00 a2@89@00 V@90@00) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1@168@00)))))
            (<= 0 (inv@171@00 s@$ this@88@00 a2@89@00 V@90@00 i1@168@00 r)))
          $k@170@00
          $Perm.No)
        $Perm.No)))
  :pattern ((inv@165@00 s@$ this@88@00 a2@89@00 V@90@00 r))
  :pattern ((inv@164@00 s@$ this@88@00 a2@89@00 V@90@00 r))
  :pattern ((inv@171@00 s@$ this@88@00 a2@89@00 V@90@00 i1@168@00 r))
  :qid |qp.srp13|)))
; Intermediate check if already taken enough permissions
(set-option :timeout 500)
(push) ; 6
(assert (not (forall ((r $Ref)) (!
  (implies
    (and
      (<
        (inv@171@00 s@$ this@88@00 a2@89@00 V@90@00 i1@168@00 r)
        (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@156@00 s@$ this@88@00 a2@89@00 V@90@00) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1@168@00)))))
      (<= 0 (inv@171@00 s@$ this@88@00 a2@89@00 V@90@00 i1@168@00 r)))
    (=
      (- $k@170@00 (pTaken@172@00 r s@$ this@88@00 a2@89@00 V@90@00 i1@168@00))
      $Perm.No))
  
  ))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1702
;  :arith-add-rows          1350
;  :arith-assert-diseq      177
;  :arith-assert-lower      729
;  :arith-assert-upper      384
;  :arith-bound-prop        114
;  :arith-conflicts         65
;  :arith-eq-adapter        322
;  :arith-fixed-eqs         216
;  :arith-offset-eqs        85
;  :arith-pivots            597
;  :conflicts               127
;  :datatype-accessor-ax    108
;  :datatype-constructor-ax 14
;  :datatype-occurs-check   71
;  :datatype-splits         14
;  :decisions               165
;  :del-clause              2315
;  :final-checks            70
;  :interface-eqs           9
;  :max-generation          6
;  :max-memory              5.03
;  :memory                  5.02
;  :minimized-lits          1
;  :mk-bool-var             4317
;  :mk-clause               2347
;  :num-allocs              228439
;  :num-checks              160
;  :propagations            929
;  :quant-instantiations    1222
;  :rlimit-count            326334
;  :time                    0.00)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-fun sm@173@00 ($Snap $Ref option<array> Int) $FVF<Int>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (iff
    (Set_in r ($FVF.domain_int (sm@173@00 s@$ this@88@00 a2@89@00 V@90@00)))
    (and
      (and
        (<
          (inv@171@00 s@$ this@88@00 a2@89@00 V@90@00 i1@168@00 r)
          (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@156@00 s@$ this@88@00 a2@89@00 V@90@00) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1@168@00)))))
        (<= 0 (inv@171@00 s@$ this@88@00 a2@89@00 V@90@00 i1@168@00 r)))
      (< $Perm.No $k@170@00)))
  :pattern ((Set_in r ($FVF.domain_int (sm@173@00 s@$ this@88@00 a2@89@00 V@90@00))))
  :qid |qp.fvfDomDef16|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and
          (<
            (inv@171@00 s@$ this@88@00 a2@89@00 V@90@00 i1@168@00 r)
            (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@156@00 s@$ this@88@00 a2@89@00 V@90@00) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1@168@00)))))
          (<= 0 (inv@171@00 s@$ this@88@00 a2@89@00 V@90@00 i1@168@00 r)))
        (< $Perm.No $k@170@00))
      (ite
        (and
          (and
            (and
              (< (inv@165@00 s@$ this@88@00 a2@89@00 V@90@00 r) V@90@00)
              (<= 0 (inv@165@00 s@$ this@88@00 a2@89@00 V@90@00 r)))
            (< (inv@164@00 s@$ this@88@00 a2@89@00 V@90@00 r) V@90@00))
          (<= 0 (inv@164@00 s@$ this@88@00 a2@89@00 V@90@00 r)))
        (< $Perm.No $k@163@00)
        false))
    (=
      ($FVF.lookup_int (sm@173@00 s@$ this@88@00 a2@89@00 V@90@00) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$)))))))) r)))
  :pattern (($FVF.lookup_int (sm@173@00 s@$ this@88@00 a2@89@00 V@90@00) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$)))))))) r))
  :qid |qp.fvfValDef14|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$)))))))) r) r)
  :pattern (($FVF.lookup_int (sm@173@00 s@$ this@88@00 a2@89@00 V@90@00) r))
  :qid |qp.fvfResTrgDef15|)))
(pop) ; 5
; Joined path conditions
(assert ($Perm.isReadVar $k@170@00 $Perm.Write))
(assert (forall ((i1@169@00 Int)) (!
  (implies
    (and
      (and
        (<
          i1@169@00
          (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@156@00 s@$ this@88@00 a2@89@00 V@90@00) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1@168@00)))))
        (<= 0 i1@169@00))
      (< $Perm.No $k@170@00))
    (=
      (inv@171@00 s@$ this@88@00 a2@89@00 V@90@00 i1@168@00 (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@156@00 s@$ this@88@00 a2@89@00 V@90@00) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1@168@00))) i1@169@00))
      i1@169@00))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@156@00 s@$ this@88@00 a2@89@00 V@90@00) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1@168@00))) i1@169@00))
  :qid |int-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (<
          (inv@171@00 s@$ this@88@00 a2@89@00 V@90@00 i1@168@00 r)
          (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@156@00 s@$ this@88@00 a2@89@00 V@90@00) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1@168@00)))))
        (<= 0 (inv@171@00 s@$ this@88@00 a2@89@00 V@90@00 i1@168@00 r)))
      (< $Perm.No $k@170@00))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@156@00 s@$ this@88@00 a2@89@00 V@90@00) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1@168@00))) (inv@171@00 s@$ this@88@00 a2@89@00 V@90@00 i1@168@00 r))
      r))
  :pattern ((inv@171@00 s@$ this@88@00 a2@89@00 V@90@00 i1@168@00 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (iff
    (Set_in r ($FVF.domain_int (sm@173@00 s@$ this@88@00 a2@89@00 V@90@00)))
    (and
      (and
        (<
          (inv@171@00 s@$ this@88@00 a2@89@00 V@90@00 i1@168@00 r)
          (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@156@00 s@$ this@88@00 a2@89@00 V@90@00) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1@168@00)))))
        (<= 0 (inv@171@00 s@$ this@88@00 a2@89@00 V@90@00 i1@168@00 r)))
      (< $Perm.No $k@170@00)))
  :pattern ((Set_in r ($FVF.domain_int (sm@173@00 s@$ this@88@00 a2@89@00 V@90@00))))
  :qid |qp.fvfDomDef16|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and
          (<
            (inv@171@00 s@$ this@88@00 a2@89@00 V@90@00 i1@168@00 r)
            (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@156@00 s@$ this@88@00 a2@89@00 V@90@00) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1@168@00)))))
          (<= 0 (inv@171@00 s@$ this@88@00 a2@89@00 V@90@00 i1@168@00 r)))
        (< $Perm.No $k@170@00))
      (ite
        (and
          (and
            (and
              (< (inv@165@00 s@$ this@88@00 a2@89@00 V@90@00 r) V@90@00)
              (<= 0 (inv@165@00 s@$ this@88@00 a2@89@00 V@90@00 r)))
            (< (inv@164@00 s@$ this@88@00 a2@89@00 V@90@00 r) V@90@00))
          (<= 0 (inv@164@00 s@$ this@88@00 a2@89@00 V@90@00 r)))
        (< $Perm.No $k@163@00)
        false))
    (=
      ($FVF.lookup_int (sm@173@00 s@$ this@88@00 a2@89@00 V@90@00) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$)))))))) r)))
  :pattern (($FVF.lookup_int (sm@173@00 s@$ this@88@00 a2@89@00 V@90@00) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$)))))))) r))
  :qid |qp.fvfValDef14|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$)))))))) r) r)
  :pattern (($FVF.lookup_int (sm@173@00 s@$ this@88@00 a2@89@00 V@90@00) r))
  :qid |qp.fvfResTrgDef15|)))
(assert (and
  (<=
    0
    (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@156@00 s@$ this@88@00 a2@89@00 V@90@00) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1@168@00)))))
  (forall ((r $Ref)) (!
    (implies
      (and
        (<
          (inv@171@00 s@$ this@88@00 a2@89@00 V@90@00 i1@168@00 r)
          (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@156@00 s@$ this@88@00 a2@89@00 V@90@00) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1@168@00)))))
        (<= 0 (inv@171@00 s@$ this@88@00 a2@89@00 V@90@00 i1@168@00 r)))
      ($FVF.loc_int ($FVF.lookup_int (sm@166@00 s@$ this@88@00 a2@89@00 V@90@00) r) r))
    :pattern ((inv@171@00 s@$ this@88@00 a2@89@00 V@90@00 i1@168@00 r))
    ))
  (forall ((r $Ref)) (!
    (implies
      (not
        (=
          (ite
            (and
              (and
                (and
                  (< (inv@165@00 s@$ this@88@00 a2@89@00 V@90@00 r) V@90@00)
                  (<= 0 (inv@165@00 s@$ this@88@00 a2@89@00 V@90@00 r)))
                (< (inv@164@00 s@$ this@88@00 a2@89@00 V@90@00 r) V@90@00))
              (<= 0 (inv@164@00 s@$ this@88@00 a2@89@00 V@90@00 r)))
            $k@163@00
            $Perm.No)
          $Perm.No))
      (ite
        (and
          (and
            (and
              (< (inv@165@00 s@$ this@88@00 a2@89@00 V@90@00 r) V@90@00)
              (<= 0 (inv@165@00 s@$ this@88@00 a2@89@00 V@90@00 r)))
            (< (inv@164@00 s@$ this@88@00 a2@89@00 V@90@00 r) V@90@00))
          (<= 0 (inv@164@00 s@$ this@88@00 a2@89@00 V@90@00 r)))
        (<
          (ite
            (and
              (<
                (inv@171@00 s@$ this@88@00 a2@89@00 V@90@00 i1@168@00 r)
                (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@156@00 s@$ this@88@00 a2@89@00 V@90@00) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1@168@00)))))
              (<= 0 (inv@171@00 s@$ this@88@00 a2@89@00 V@90@00 i1@168@00 r)))
            $k@170@00
            $Perm.No)
          $k@163@00)
        (<
          (ite
            (and
              (<
                (inv@171@00 s@$ this@88@00 a2@89@00 V@90@00 i1@168@00 r)
                (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@156@00 s@$ this@88@00 a2@89@00 V@90@00) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1@168@00)))))
              (<= 0 (inv@171@00 s@$ this@88@00 a2@89@00 V@90@00 i1@168@00 r)))
            $k@170@00
            $Perm.No)
          $Perm.No)))
    :pattern ((inv@165@00 s@$ this@88@00 a2@89@00 V@90@00 r))
    :pattern ((inv@164@00 s@$ this@88@00 a2@89@00 V@90@00 r))
    :pattern ((inv@171@00 s@$ this@88@00 a2@89@00 V@90@00 i1@168@00 r))
    :qid |qp.srp13|))))
(pop) ; 4
(push) ; 4
; [else-branch: 94 | !(i1@168@00 < V@90@00 && 0 <= i1@168@00)]
(assert (not (and (< i1@168@00 V@90@00) (<= 0 i1@168@00))))
(pop) ; 4
(pop) ; 3
; Joined path conditions
(assert ($Perm.isReadVar $k@170@00 $Perm.Write))
(assert (forall ((i1@169@00 Int)) (!
  (implies
    (and
      (and
        (<
          i1@169@00
          (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@156@00 s@$ this@88@00 a2@89@00 V@90@00) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1@168@00)))))
        (<= 0 i1@169@00))
      (< $Perm.No $k@170@00))
    (=
      (inv@171@00 s@$ this@88@00 a2@89@00 V@90@00 i1@168@00 (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@156@00 s@$ this@88@00 a2@89@00 V@90@00) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1@168@00))) i1@169@00))
      i1@169@00))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@156@00 s@$ this@88@00 a2@89@00 V@90@00) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1@168@00))) i1@169@00))
  :qid |int-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (<
          (inv@171@00 s@$ this@88@00 a2@89@00 V@90@00 i1@168@00 r)
          (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@156@00 s@$ this@88@00 a2@89@00 V@90@00) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1@168@00)))))
        (<= 0 (inv@171@00 s@$ this@88@00 a2@89@00 V@90@00 i1@168@00 r)))
      (< $Perm.No $k@170@00))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@156@00 s@$ this@88@00 a2@89@00 V@90@00) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1@168@00))) (inv@171@00 s@$ this@88@00 a2@89@00 V@90@00 i1@168@00 r))
      r))
  :pattern ((inv@171@00 s@$ this@88@00 a2@89@00 V@90@00 i1@168@00 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (iff
    (Set_in r ($FVF.domain_int (sm@173@00 s@$ this@88@00 a2@89@00 V@90@00)))
    (and
      (and
        (<
          (inv@171@00 s@$ this@88@00 a2@89@00 V@90@00 i1@168@00 r)
          (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@156@00 s@$ this@88@00 a2@89@00 V@90@00) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1@168@00)))))
        (<= 0 (inv@171@00 s@$ this@88@00 a2@89@00 V@90@00 i1@168@00 r)))
      (< $Perm.No $k@170@00)))
  :pattern ((Set_in r ($FVF.domain_int (sm@173@00 s@$ this@88@00 a2@89@00 V@90@00))))
  :qid |qp.fvfDomDef16|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and
          (<
            (inv@171@00 s@$ this@88@00 a2@89@00 V@90@00 i1@168@00 r)
            (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@156@00 s@$ this@88@00 a2@89@00 V@90@00) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1@168@00)))))
          (<= 0 (inv@171@00 s@$ this@88@00 a2@89@00 V@90@00 i1@168@00 r)))
        (< $Perm.No $k@170@00))
      (ite
        (and
          (and
            (and
              (< (inv@165@00 s@$ this@88@00 a2@89@00 V@90@00 r) V@90@00)
              (<= 0 (inv@165@00 s@$ this@88@00 a2@89@00 V@90@00 r)))
            (< (inv@164@00 s@$ this@88@00 a2@89@00 V@90@00 r) V@90@00))
          (<= 0 (inv@164@00 s@$ this@88@00 a2@89@00 V@90@00 r)))
        (< $Perm.No $k@163@00)
        false))
    (=
      ($FVF.lookup_int (sm@173@00 s@$ this@88@00 a2@89@00 V@90@00) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$)))))))) r)))
  :pattern (($FVF.lookup_int (sm@173@00 s@$ this@88@00 a2@89@00 V@90@00) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$)))))))) r))
  :qid |qp.fvfValDef14|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$)))))))) r) r)
  :pattern (($FVF.lookup_int (sm@173@00 s@$ this@88@00 a2@89@00 V@90@00) r))
  :qid |qp.fvfResTrgDef15|)))
(assert (implies
  (and (< i1@168@00 V@90@00) (<= 0 i1@168@00))
  (and
    (< i1@168@00 V@90@00)
    (<= 0 i1@168@00)
    (< i1@168@00 (alen<Int> (opt_get1 $Snap.unit a2@89@00)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@156@00 s@$ this@88@00 a2@89@00 V@90@00) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1@168@00)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1@168@00))
    (not
      (=
        ($FVF.lookup_option$array$ (sm@156@00 s@$ this@88@00 a2@89@00 V@90@00) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1@168@00))
        (as None<option<array>>  option<array>)))
    (<=
      0
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@156@00 s@$ this@88@00 a2@89@00 V@90@00) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1@168@00)))))
    (forall ((r $Ref)) (!
      (implies
        (and
          (<
            (inv@171@00 s@$ this@88@00 a2@89@00 V@90@00 i1@168@00 r)
            (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@156@00 s@$ this@88@00 a2@89@00 V@90@00) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1@168@00)))))
          (<= 0 (inv@171@00 s@$ this@88@00 a2@89@00 V@90@00 i1@168@00 r)))
        ($FVF.loc_int ($FVF.lookup_int (sm@166@00 s@$ this@88@00 a2@89@00 V@90@00) r) r))
      :pattern ((inv@171@00 s@$ this@88@00 a2@89@00 V@90@00 i1@168@00 r))
      ))
    (forall ((r $Ref)) (!
      (implies
        (not
          (=
            (ite
              (and
                (and
                  (and
                    (< (inv@165@00 s@$ this@88@00 a2@89@00 V@90@00 r) V@90@00)
                    (<= 0 (inv@165@00 s@$ this@88@00 a2@89@00 V@90@00 r)))
                  (< (inv@164@00 s@$ this@88@00 a2@89@00 V@90@00 r) V@90@00))
                (<= 0 (inv@164@00 s@$ this@88@00 a2@89@00 V@90@00 r)))
              $k@163@00
              $Perm.No)
            $Perm.No))
        (ite
          (and
            (and
              (and
                (< (inv@165@00 s@$ this@88@00 a2@89@00 V@90@00 r) V@90@00)
                (<= 0 (inv@165@00 s@$ this@88@00 a2@89@00 V@90@00 r)))
              (< (inv@164@00 s@$ this@88@00 a2@89@00 V@90@00 r) V@90@00))
            (<= 0 (inv@164@00 s@$ this@88@00 a2@89@00 V@90@00 r)))
          (<
            (ite
              (and
                (<
                  (inv@171@00 s@$ this@88@00 a2@89@00 V@90@00 i1@168@00 r)
                  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@156@00 s@$ this@88@00 a2@89@00 V@90@00) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1@168@00)))))
                (<= 0 (inv@171@00 s@$ this@88@00 a2@89@00 V@90@00 i1@168@00 r)))
              $k@170@00
              $Perm.No)
            $k@163@00)
          (<
            (ite
              (and
                (<
                  (inv@171@00 s@$ this@88@00 a2@89@00 V@90@00 i1@168@00 r)
                  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@156@00 s@$ this@88@00 a2@89@00 V@90@00) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1@168@00)))))
                (<= 0 (inv@171@00 s@$ this@88@00 a2@89@00 V@90@00 i1@168@00 r)))
              $k@170@00
              $Perm.No)
            $Perm.No)))
      :pattern ((inv@165@00 s@$ this@88@00 a2@89@00 V@90@00 r))
      :pattern ((inv@164@00 s@$ this@88@00 a2@89@00 V@90@00 r))
      :pattern ((inv@171@00 s@$ this@88@00 a2@89@00 V@90@00 i1@168@00 r))
      :qid |qp.srp13|)))))
; Joined path conditions
; [eval] result[i1]
(set-option :timeout 0)
(push) ; 3
(assert (not (>= i1@168@00 0)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1707
;  :arith-add-rows          1355
;  :arith-assert-diseq      180
;  :arith-assert-lower      732
;  :arith-assert-upper      387
;  :arith-bound-prop        115
;  :arith-conflicts         65
;  :arith-eq-adapter        323
;  :arith-fixed-eqs         216
;  :arith-offset-eqs        85
;  :arith-pivots            601
;  :conflicts               127
;  :datatype-accessor-ax    108
;  :datatype-constructor-ax 16
;  :datatype-occurs-check   74
;  :datatype-splits         16
;  :decisions               168
;  :del-clause              2331
;  :final-checks            72
;  :interface-eqs           9
;  :max-generation          6
;  :max-memory              5.04
;  :memory                  5.03
;  :minimized-lits          1
;  :mk-bool-var             4344
;  :mk-clause               2367
;  :num-allocs              230971
;  :num-checks              161
;  :propagations            936
;  :quant-instantiations    1223
;  :rlimit-count            331573)
(assert (>= i1@168@00 0))
(push) ; 3
(assert (not (< i1@168@00 (Seq_length result@91@00))))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1712
;  :arith-add-rows          1359
;  :arith-assert-diseq      182
;  :arith-assert-lower      735
;  :arith-assert-upper      389
;  :arith-bound-prop        116
;  :arith-conflicts         65
;  :arith-eq-adapter        323
;  :arith-fixed-eqs         216
;  :arith-offset-eqs        85
;  :arith-pivots            603
;  :conflicts               127
;  :datatype-accessor-ax    108
;  :datatype-constructor-ax 18
;  :datatype-occurs-check   77
;  :datatype-splits         18
;  :decisions               171
;  :del-clause              2340
;  :final-checks            74
;  :interface-eqs           9
;  :max-generation          6
;  :max-memory              5.04
;  :memory                  5.03
;  :minimized-lits          1
;  :mk-bool-var             4355
;  :mk-clause               2376
;  :num-allocs              231697
;  :num-checks              162
;  :propagations            942
;  :quant-instantiations    1224
;  :rlimit-count            332354)
(pop) ; 2
; Nested auxiliary terms: globals (aux)
(assert ($Perm.isReadVar $k@170@00 $Perm.Write))
(assert (forall ((i1@169@00 Int)) (!
  (implies
    (and
      (and
        (<
          i1@169@00
          (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@156@00 s@$ this@88@00 a2@89@00 V@90@00) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1@168@00)))))
        (<= 0 i1@169@00))
      (< $Perm.No $k@170@00))
    (=
      (inv@171@00 s@$ this@88@00 a2@89@00 V@90@00 i1@168@00 (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@156@00 s@$ this@88@00 a2@89@00 V@90@00) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1@168@00))) i1@169@00))
      i1@169@00))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@156@00 s@$ this@88@00 a2@89@00 V@90@00) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1@168@00))) i1@169@00))
  :qid |int-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (<
          (inv@171@00 s@$ this@88@00 a2@89@00 V@90@00 i1@168@00 r)
          (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@156@00 s@$ this@88@00 a2@89@00 V@90@00) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1@168@00)))))
        (<= 0 (inv@171@00 s@$ this@88@00 a2@89@00 V@90@00 i1@168@00 r)))
      (< $Perm.No $k@170@00))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@156@00 s@$ this@88@00 a2@89@00 V@90@00) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1@168@00))) (inv@171@00 s@$ this@88@00 a2@89@00 V@90@00 i1@168@00 r))
      r))
  :pattern ((inv@171@00 s@$ this@88@00 a2@89@00 V@90@00 i1@168@00 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (iff
    (Set_in r ($FVF.domain_int (sm@173@00 s@$ this@88@00 a2@89@00 V@90@00)))
    (and
      (and
        (<
          (inv@171@00 s@$ this@88@00 a2@89@00 V@90@00 i1@168@00 r)
          (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@156@00 s@$ this@88@00 a2@89@00 V@90@00) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1@168@00)))))
        (<= 0 (inv@171@00 s@$ this@88@00 a2@89@00 V@90@00 i1@168@00 r)))
      (< $Perm.No $k@170@00)))
  :pattern ((Set_in r ($FVF.domain_int (sm@173@00 s@$ this@88@00 a2@89@00 V@90@00))))
  :qid |qp.fvfDomDef16|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and
          (<
            (inv@171@00 s@$ this@88@00 a2@89@00 V@90@00 i1@168@00 r)
            (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@156@00 s@$ this@88@00 a2@89@00 V@90@00) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1@168@00)))))
          (<= 0 (inv@171@00 s@$ this@88@00 a2@89@00 V@90@00 i1@168@00 r)))
        (< $Perm.No $k@170@00))
      (ite
        (and
          (and
            (and
              (< (inv@165@00 s@$ this@88@00 a2@89@00 V@90@00 r) V@90@00)
              (<= 0 (inv@165@00 s@$ this@88@00 a2@89@00 V@90@00 r)))
            (< (inv@164@00 s@$ this@88@00 a2@89@00 V@90@00 r) V@90@00))
          (<= 0 (inv@164@00 s@$ this@88@00 a2@89@00 V@90@00 r)))
        (< $Perm.No $k@163@00)
        false))
    (=
      ($FVF.lookup_int (sm@173@00 s@$ this@88@00 a2@89@00 V@90@00) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$)))))))) r)))
  :pattern (($FVF.lookup_int (sm@173@00 s@$ this@88@00 a2@89@00 V@90@00) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$)))))))) r))
  :qid |qp.fvfValDef14|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$)))))))) r) r)
  :pattern (($FVF.lookup_int (sm@173@00 s@$ this@88@00 a2@89@00 V@90@00) r))
  :qid |qp.fvfResTrgDef15|)))
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@168@00 Int)) (!
  (>= i1@168@00 0)
  :pattern ()
  :qid |prog.l<no position>-aux|)))
(assert (forall ((i1@168@00 Int)) (!
  (>= i1@168@00 0)
  :pattern ((unknown%limited ($Snap.combine
    $Snap.unit
    ($Snap.combine
      $Snap.unit
      ($Snap.combine
        $Snap.unit
        ($Snap.combine
          $Snap.unit
          ($SortWrappers.$FVF<Int>To$Snap (sm@173@00 s@$ this@88@00 a2@89@00 V@90@00)))))) ($FVF.lookup_option$array$ (sm@156@00 s@$ this@88@00 a2@89@00 V@90@00) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1@168@00)) 0 (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@156@00 s@$ this@88@00 a2@89@00 V@90@00) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1@168@00))))))
  :qid |prog.l<no position>-aux|)))
(assert (forall ((i1@168@00 Int)) (!
  (implies
    (and (< i1@168@00 V@90@00) (<= 0 i1@168@00))
    (and
      (< i1@168@00 V@90@00)
      (<= 0 i1@168@00)
      (< i1@168@00 (alen<Int> (opt_get1 $Snap.unit a2@89@00)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@156@00 s@$ this@88@00 a2@89@00 V@90@00) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1@168@00)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1@168@00))
      (not
        (=
          ($FVF.lookup_option$array$ (sm@156@00 s@$ this@88@00 a2@89@00 V@90@00) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1@168@00))
          (as None<option<array>>  option<array>)))
      (<=
        0
        (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@156@00 s@$ this@88@00 a2@89@00 V@90@00) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1@168@00)))))
      (forall ((r $Ref)) (!
        (implies
          (and
            (<
              (inv@171@00 s@$ this@88@00 a2@89@00 V@90@00 i1@168@00 r)
              (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@156@00 s@$ this@88@00 a2@89@00 V@90@00) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1@168@00)))))
            (<= 0 (inv@171@00 s@$ this@88@00 a2@89@00 V@90@00 i1@168@00 r)))
          ($FVF.loc_int ($FVF.lookup_int (sm@166@00 s@$ this@88@00 a2@89@00 V@90@00) r) r))
        :pattern ((inv@171@00 s@$ this@88@00 a2@89@00 V@90@00 i1@168@00 r))
        ))
      (forall ((r $Ref)) (!
        (implies
          (not
            (=
              (ite
                (and
                  (and
                    (and
                      (< (inv@165@00 s@$ this@88@00 a2@89@00 V@90@00 r) V@90@00)
                      (<= 0 (inv@165@00 s@$ this@88@00 a2@89@00 V@90@00 r)))
                    (< (inv@164@00 s@$ this@88@00 a2@89@00 V@90@00 r) V@90@00))
                  (<= 0 (inv@164@00 s@$ this@88@00 a2@89@00 V@90@00 r)))
                $k@163@00
                $Perm.No)
              $Perm.No))
          (ite
            (and
              (and
                (and
                  (< (inv@165@00 s@$ this@88@00 a2@89@00 V@90@00 r) V@90@00)
                  (<= 0 (inv@165@00 s@$ this@88@00 a2@89@00 V@90@00 r)))
                (< (inv@164@00 s@$ this@88@00 a2@89@00 V@90@00 r) V@90@00))
              (<= 0 (inv@164@00 s@$ this@88@00 a2@89@00 V@90@00 r)))
            (<
              (ite
                (and
                  (<
                    (inv@171@00 s@$ this@88@00 a2@89@00 V@90@00 i1@168@00 r)
                    (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@156@00 s@$ this@88@00 a2@89@00 V@90@00) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1@168@00)))))
                  (<= 0 (inv@171@00 s@$ this@88@00 a2@89@00 V@90@00 i1@168@00 r)))
                $k@170@00
                $Perm.No)
              $k@163@00)
            (<
              (ite
                (and
                  (<
                    (inv@171@00 s@$ this@88@00 a2@89@00 V@90@00 i1@168@00 r)
                    (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@156@00 s@$ this@88@00 a2@89@00 V@90@00) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1@168@00)))))
                  (<= 0 (inv@171@00 s@$ this@88@00 a2@89@00 V@90@00 i1@168@00 r)))
                $k@170@00
                $Perm.No)
              $Perm.No)))
        :pattern ((inv@165@00 s@$ this@88@00 a2@89@00 V@90@00 r))
        :pattern ((inv@164@00 s@$ this@88@00 a2@89@00 V@90@00 r))
        :pattern ((inv@171@00 s@$ this@88@00 a2@89@00 V@90@00 i1@168@00 r))
        :qid |qp.srp13|))))
  :pattern ()
  :qid |prog.l<no position>-aux|)))
(assert (forall ((i1@168@00 Int)) (!
  (implies
    (and (< i1@168@00 V@90@00) (<= 0 i1@168@00))
    (and
      (< i1@168@00 V@90@00)
      (<= 0 i1@168@00)
      (< i1@168@00 (alen<Int> (opt_get1 $Snap.unit a2@89@00)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@156@00 s@$ this@88@00 a2@89@00 V@90@00) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1@168@00)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1@168@00))
      (not
        (=
          ($FVF.lookup_option$array$ (sm@156@00 s@$ this@88@00 a2@89@00 V@90@00) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1@168@00))
          (as None<option<array>>  option<array>)))
      (<=
        0
        (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@156@00 s@$ this@88@00 a2@89@00 V@90@00) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1@168@00)))))
      (forall ((r $Ref)) (!
        (implies
          (and
            (<
              (inv@171@00 s@$ this@88@00 a2@89@00 V@90@00 i1@168@00 r)
              (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@156@00 s@$ this@88@00 a2@89@00 V@90@00) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1@168@00)))))
            (<= 0 (inv@171@00 s@$ this@88@00 a2@89@00 V@90@00 i1@168@00 r)))
          ($FVF.loc_int ($FVF.lookup_int (sm@166@00 s@$ this@88@00 a2@89@00 V@90@00) r) r))
        :pattern ((inv@171@00 s@$ this@88@00 a2@89@00 V@90@00 i1@168@00 r))
        ))
      (forall ((r $Ref)) (!
        (implies
          (not
            (=
              (ite
                (and
                  (and
                    (and
                      (< (inv@165@00 s@$ this@88@00 a2@89@00 V@90@00 r) V@90@00)
                      (<= 0 (inv@165@00 s@$ this@88@00 a2@89@00 V@90@00 r)))
                    (< (inv@164@00 s@$ this@88@00 a2@89@00 V@90@00 r) V@90@00))
                  (<= 0 (inv@164@00 s@$ this@88@00 a2@89@00 V@90@00 r)))
                $k@163@00
                $Perm.No)
              $Perm.No))
          (ite
            (and
              (and
                (and
                  (< (inv@165@00 s@$ this@88@00 a2@89@00 V@90@00 r) V@90@00)
                  (<= 0 (inv@165@00 s@$ this@88@00 a2@89@00 V@90@00 r)))
                (< (inv@164@00 s@$ this@88@00 a2@89@00 V@90@00 r) V@90@00))
              (<= 0 (inv@164@00 s@$ this@88@00 a2@89@00 V@90@00 r)))
            (<
              (ite
                (and
                  (<
                    (inv@171@00 s@$ this@88@00 a2@89@00 V@90@00 i1@168@00 r)
                    (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@156@00 s@$ this@88@00 a2@89@00 V@90@00) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1@168@00)))))
                  (<= 0 (inv@171@00 s@$ this@88@00 a2@89@00 V@90@00 i1@168@00 r)))
                $k@170@00
                $Perm.No)
              $k@163@00)
            (<
              (ite
                (and
                  (<
                    (inv@171@00 s@$ this@88@00 a2@89@00 V@90@00 i1@168@00 r)
                    (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@156@00 s@$ this@88@00 a2@89@00 V@90@00) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1@168@00)))))
                  (<= 0 (inv@171@00 s@$ this@88@00 a2@89@00 V@90@00 i1@168@00 r)))
                $k@170@00
                $Perm.No)
              $Perm.No)))
        :pattern ((inv@165@00 s@$ this@88@00 a2@89@00 V@90@00 r))
        :pattern ((inv@164@00 s@$ this@88@00 a2@89@00 V@90@00 r))
        :pattern ((inv@171@00 s@$ this@88@00 a2@89@00 V@90@00 i1@168@00 r))
        :qid |qp.srp13|))))
  :pattern ((unknown%limited ($Snap.combine
    $Snap.unit
    ($Snap.combine
      $Snap.unit
      ($Snap.combine
        $Snap.unit
        ($Snap.combine
          $Snap.unit
          ($SortWrappers.$FVF<Int>To$Snap (sm@173@00 s@$ this@88@00 a2@89@00 V@90@00)))))) ($FVF.lookup_option$array$ (sm@156@00 s@$ this@88@00 a2@89@00 V@90@00) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1@168@00)) 0 (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@156@00 s@$ this@88@00 a2@89@00 V@90@00) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1@168@00))))))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(assert (forall ((i1@168@00 Int)) (!
  (implies
    (and (< i1@168@00 V@90@00) (<= 0 i1@168@00))
    (Seq_equal
      (Seq_index result@91@00 i1@168@00)
      (unknown_ ($Snap.combine
        $Snap.unit
        ($Snap.combine
          $Snap.unit
          ($Snap.combine
            $Snap.unit
            ($Snap.combine
              $Snap.unit
              ($SortWrappers.$FVF<Int>To$Snap (sm@173@00 s@$ this@88@00 a2@89@00 V@90@00)))))) ($FVF.lookup_option$array$ (sm@156@00 s@$ this@88@00 a2@89@00 V@90@00) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1@168@00)) 0 (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@156@00 s@$ this@88@00 a2@89@00 V@90@00) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1@168@00)))))))
  :pattern ()
  :pattern ((unknown%limited ($Snap.combine
    $Snap.unit
    ($Snap.combine
      $Snap.unit
      ($Snap.combine
        $Snap.unit
        ($Snap.combine
          $Snap.unit
          ($SortWrappers.$FVF<Int>To$Snap (sm@173@00 s@$ this@88@00 a2@89@00 V@90@00)))))) ($FVF.lookup_option$array$ (sm@156@00 s@$ this@88@00 a2@89@00 V@90@00) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1@168@00)) 0 (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@156@00 s@$ this@88@00 a2@89@00 V@90@00) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1@168@00))))))
  :qid |prog.l<no position>|)))
(pop) ; 1
(assert (forall ((s@$ $Snap) (this@88@00 $Ref) (a2@89@00 option<array>) (V@90@00 Int)) (!
  (Seq_equal
    (matrixValues%limited s@$ this@88@00 a2@89@00 V@90@00)
    (matrixValues s@$ this@88@00 a2@89@00 V@90@00))
  :pattern ((matrixValues s@$ this@88@00 a2@89@00 V@90@00))
  )))
(assert (forall ((s@$ $Snap) (this@88@00 $Ref) (a2@89@00 option<array>) (V@90@00 Int)) (!
  (matrixValues%stateless this@88@00 a2@89@00 V@90@00)
  :pattern ((matrixValues%limited s@$ this@88@00 a2@89@00 V@90@00))
  )))
(assert (forall ((s@$ $Snap) (this@88@00 $Ref) (a2@89@00 option<array>) (V@90@00 Int)) (!
  (let ((result@91@00 (matrixValues%limited s@$ this@88@00 a2@89@00 V@90@00))) (and
    (forall ((i1@153@00 Int)) (!
      (implies
        (and (and (< i1@153@00 V@90@00) (<= 0 i1@153@00)) (< $Perm.No $k@154@00))
        (=
          (inv@155@00 s@$ this@88@00 a2@89@00 V@90@00 (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1@153@00))
          i1@153@00))
      :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1@153@00))
      ))
    (forall ((r $Ref)) (!
      (implies
        (and
          (and
            (< (inv@155@00 s@$ this@88@00 a2@89@00 V@90@00 r) V@90@00)
            (<= 0 (inv@155@00 s@$ this@88@00 a2@89@00 V@90@00 r)))
          (< $Perm.No $k@154@00))
        (=
          (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit a2@89@00) (inv@155@00 s@$ this@88@00 a2@89@00 V@90@00 r))
          r))
      :pattern ((inv@155@00 s@$ this@88@00 a2@89@00 V@90@00 r))
      :qid |option$array$-fctOfInv|))
    (forall ((i1@161@00 Int) (j@162@00 Int)) (!
      (implies
        (and
          (and
            (and
              (and (< j@162@00 V@90@00) (<= 0 j@162@00))
              (< i1@161@00 V@90@00))
            (<= 0 i1@161@00))
          (< $Perm.No $k@163@00))
        (and
          (=
            (inv@164@00 s@$ this@88@00 a2@89@00 V@90@00 (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@156@00 s@$ this@88@00 a2@89@00 V@90@00) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1@161@00))) j@162@00))
            i1@161@00)
          (=
            (inv@165@00 s@$ this@88@00 a2@89@00 V@90@00 (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@156@00 s@$ this@88@00 a2@89@00 V@90@00) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1@161@00))) j@162@00))
            j@162@00)))
      :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@156@00 s@$ this@88@00 a2@89@00 V@90@00) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1@161@00))) j@162@00))
      ))
    (forall ((r $Ref)) (!
      (implies
        (and
          (and
            (and
              (and
                (< (inv@165@00 s@$ this@88@00 a2@89@00 V@90@00 r) V@90@00)
                (<= 0 (inv@165@00 s@$ this@88@00 a2@89@00 V@90@00 r)))
              (< (inv@164@00 s@$ this@88@00 a2@89@00 V@90@00 r) V@90@00))
            (<= 0 (inv@164@00 s@$ this@88@00 a2@89@00 V@90@00 r)))
          (< $Perm.No $k@163@00))
        (=
          (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@156@00 s@$ this@88@00 a2@89@00 V@90@00) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit a2@89@00) (inv@164@00 s@$ this@88@00 a2@89@00 V@90@00 r)))) (inv@165@00 s@$ this@88@00 a2@89@00 V@90@00 r))
          r))
      :pattern ((inv@164@00 s@$ this@88@00 a2@89@00 V@90@00 r))
      :pattern ((inv@165@00 s@$ this@88@00 a2@89@00 V@90@00 r))
      :qid |int-fctOfInv|))
    (forall ((r $Ref)) (!
      (implies
        (ite
          (and
            (< (inv@155@00 s@$ this@88@00 a2@89@00 V@90@00 r) V@90@00)
            (<= 0 (inv@155@00 s@$ this@88@00 a2@89@00 V@90@00 r)))
          (< $Perm.No $k@154@00)
          false)
        (=
          ($FVF.lookup_option$array$ (sm@156@00 s@$ this@88@00 a2@89@00 V@90@00) r)
          ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r)))
      :pattern (($FVF.lookup_option$array$ (sm@156@00 s@$ this@88@00 a2@89@00 V@90@00) r))
      :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r))
      :qid |qp.fvfValDef9|))
    (forall ((r $Ref)) (!
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r)
      :pattern (($FVF.lookup_option$array$ (sm@156@00 s@$ this@88@00 a2@89@00 V@90@00) r))
      :qid |qp.fvfResTrgDef10|))
    (forall ((r $Ref)) (!
      ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$)))))))) r) r)
      :pattern (($FVF.lookup_int (sm@173@00 s@$ this@88@00 a2@89@00 V@90@00) r))
      :qid |qp.fvfResTrgDef15|))
    ($Perm.isReadVar $k@154@00 $Perm.Write)
    ($Perm.isReadVar $k@163@00 $Perm.Write)
    ($Perm.isReadVar $k@170@00 $Perm.Write)
    (implies
      (and
        (not (= this@88@00 $Ref.null))
        (not (= a2@89@00 (as None<option<array>>  option<array>)))
        (= (alen<Int> (opt_get1 $Snap.unit a2@89@00)) V@90@00)
        (forall ((i1 Int)) (!
          (implies
            (and (<= 0 i1) (< i1 V@90@00))
            (not
              (=
                ($FVF.lookup_option$array$ (sm@156@00 s@$ this@88@00 a2@89@00 V@90@00) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1))
                (as None<option<array>>  option<array>))))
          :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1))
          ))
        (forall ((i1 Int)) (!
          (implies
            (and (<= 0 i1) (< i1 V@90@00))
            (=
              (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@156@00 s@$ this@88@00 a2@89@00 V@90@00) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1))))
              V@90@00))
          :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@156@00 s@$ this@88@00 a2@89@00 V@90@00) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1)))))
          ))
        (forall ((i1 Int)) (!
          (forall ((i2 Int)) (!
            (implies
              (and
                (and
                  (and (and (<= 0 i1) (< i1 V@90@00)) (<= 0 i2))
                  (< i2 V@90@00))
                (=
                  ($FVF.lookup_option$array$ (sm@156@00 s@$ this@88@00 a2@89@00 V@90@00) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1))
                  ($FVF.lookup_option$array$ (sm@156@00 s@$ this@88@00 a2@89@00 V@90@00) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i2))))
              (= i1 i2))
            :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i2))
            ))
          :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1))
          )))
      (and
        (SquareIntMatrix $Snap.unit this@88@00 result@91@00 V@90@00)
        (forall ((i1 Int)) (!
          (implies
            (and (<= 0 i1) (< i1 V@90@00))
            (Seq_equal
              (Seq_index result@91@00 i1)
              (unknown_ ($Snap.combine
                $Snap.unit
                ($Snap.combine
                  $Snap.unit
                  ($Snap.combine
                    $Snap.unit
                    ($Snap.combine
                      $Snap.unit
                      ($SortWrappers.$FVF<Int>To$Snap (sm@173@00 s@$ this@88@00 a2@89@00 V@90@00)))))) ($FVF.lookup_option$array$ (sm@156@00 s@$ this@88@00 a2@89@00 V@90@00) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1)) 0 (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@156@00 s@$ this@88@00 a2@89@00 V@90@00) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1)))))))
          :pattern ((Seq_index result@91@00 i1))
          :pattern ((unknown%limited ($Snap.combine
            $Snap.unit
            ($Snap.combine
              $Snap.unit
              ($Snap.combine
                $Snap.unit
                ($Snap.combine
                  $Snap.unit
                  ($SortWrappers.$FVF<Int>To$Snap (sm@173@00 s@$ this@88@00 a2@89@00 V@90@00)))))) ($FVF.lookup_option$array$ (sm@156@00 s@$ this@88@00 a2@89@00 V@90@00) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1)) 0 (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@156@00 s@$ this@88@00 a2@89@00 V@90@00) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1))))))
          ))))))
  :pattern ((matrixValues%limited s@$ this@88@00 a2@89@00 V@90@00))
  )))
; ---------- FUNCTION ExAugPath----------
(declare-fun this@92@00 () $Ref)
(declare-fun G@93@00 () Seq<Seq<Int>>)
(declare-fun Gf@94@00 () Seq<Seq<Int>>)
(declare-fun V@95@00 () Int)
(declare-fun s@96@00 () Int)
(declare-fun t@97@00 () Int)
(declare-fun result@98@00 () Bool)
; ----- Well-definedness of specifications -----
(push) ; 1
(assert (= s@$ ($Snap.combine ($Snap.first s@$) ($Snap.second s@$))))
(assert (= ($Snap.first s@$) $Snap.unit))
; [eval] this != null
(assert (not (= this@92@00 $Ref.null)))
(assert (=
  ($Snap.second s@$)
  ($Snap.combine
    ($Snap.first ($Snap.second s@$))
    ($Snap.second ($Snap.second s@$)))))
(assert (= ($Snap.first ($Snap.second s@$)) $Snap.unit))
; [eval] SquareIntMatrix(this, G, V)
(push) ; 2
; [eval] this != null
(pop) ; 2
; Joined path conditions
(assert (SquareIntMatrix $Snap.unit this@92@00 G@93@00 V@95@00))
(assert (=
  ($Snap.second ($Snap.second s@$))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second s@$)))
    ($Snap.second ($Snap.second ($Snap.second s@$))))))
(assert (= ($Snap.first ($Snap.second ($Snap.second s@$))) $Snap.unit))
; [eval] SquareIntMatrix(this, Gf, V)
(push) ; 2
; [eval] this != null
(pop) ; 2
; Joined path conditions
(assert (SquareIntMatrix $Snap.unit this@92@00 Gf@94@00 V@95@00))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second s@$)))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$)))))))
(assert (= ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$)))) $Snap.unit))
; [eval] FlowNetwork(this, G, V, s, t)
(push) ; 2
; [eval] this != null
(pop) ; 2
; Joined path conditions
(assert (FlowNetwork $Snap.unit this@92@00 G@93@00 V@95@00 s@96@00 t@97@00))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$)))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$)))))
  $Snap.unit))
; [eval] FlowNetwork(this, Gf, V, s, t)
(push) ; 2
; [eval] this != null
(pop) ; 2
; Joined path conditions
(assert (FlowNetwork $Snap.unit this@92@00 Gf@94@00 V@95@00 s@96@00 t@97@00))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$)))))
  $Snap.unit))
; [eval] ValidFlow(this, G, Gf, V, s, t)
(push) ; 2
; [eval] this != null
; [eval] SquareIntMatrix(this, Gf, V)
(push) ; 3
; [eval] this != null
(pop) ; 3
; Joined path conditions
; [eval] FlowNetwork(this, G, V, s, t)
(push) ; 3
; [eval] this != null
(pop) ; 3
; Joined path conditions
; [eval] FlowNetwork(this, Gf, V, s, t)
(push) ; 3
; [eval] this != null
(pop) ; 3
; Joined path conditions
(pop) ; 2
; Joined path conditions
(assert (ValidFlow ($Snap.combine
  $Snap.unit
  ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) this@92@00 G@93@00 Gf@94@00 V@95@00 s@96@00 t@97@00))
(pop) ; 1
(assert (forall ((s@$ $Snap) (this@92@00 $Ref) (G@93@00 Seq<Seq<Int>>) (Gf@94@00 Seq<Seq<Int>>) (V@95@00 Int) (s@96@00 Int) (t@97@00 Int)) (!
  (=
    (ExAugPath%limited s@$ this@92@00 G@93@00 Gf@94@00 V@95@00 s@96@00 t@97@00)
    (ExAugPath s@$ this@92@00 G@93@00 Gf@94@00 V@95@00 s@96@00 t@97@00))
  :pattern ((ExAugPath s@$ this@92@00 G@93@00 Gf@94@00 V@95@00 s@96@00 t@97@00))
  )))
(assert (forall ((s@$ $Snap) (this@92@00 $Ref) (G@93@00 Seq<Seq<Int>>) (Gf@94@00 Seq<Seq<Int>>) (V@95@00 Int) (s@96@00 Int) (t@97@00 Int)) (!
  (ExAugPath%stateless this@92@00 G@93@00 Gf@94@00 V@95@00 s@96@00 t@97@00)
  :pattern ((ExAugPath%limited s@$ this@92@00 G@93@00 Gf@94@00 V@95@00 s@96@00 t@97@00))
  )))
; ----- Verification of function body and postcondition -----
(push) ; 1
(assert (= s@$ ($Snap.combine ($Snap.first s@$) ($Snap.second s@$))))
(assert (= ($Snap.first s@$) $Snap.unit))
(assert (not (= this@92@00 $Ref.null)))
(assert (=
  ($Snap.second s@$)
  ($Snap.combine
    ($Snap.first ($Snap.second s@$))
    ($Snap.second ($Snap.second s@$)))))
(assert (= ($Snap.first ($Snap.second s@$)) $Snap.unit))
(assert (SquareIntMatrix $Snap.unit this@92@00 G@93@00 V@95@00))
(assert (=
  ($Snap.second ($Snap.second s@$))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second s@$)))
    ($Snap.second ($Snap.second ($Snap.second s@$))))))
(assert (= ($Snap.first ($Snap.second ($Snap.second s@$))) $Snap.unit))
(assert (SquareIntMatrix $Snap.unit this@92@00 Gf@94@00 V@95@00))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second s@$)))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$)))))))
(assert (= ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$)))) $Snap.unit))
(assert (FlowNetwork $Snap.unit this@92@00 G@93@00 V@95@00 s@96@00 t@97@00))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$)))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$)))))
  $Snap.unit))
(assert (FlowNetwork $Snap.unit this@92@00 Gf@94@00 V@95@00 s@96@00 t@97@00))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$)))))
  $Snap.unit))
(assert (ValidFlow ($Snap.combine
  $Snap.unit
  ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) this@92@00 G@93@00 Gf@94@00 V@95@00 s@96@00 t@97@00))
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
; [eval] (exists P: Seq[Int] :: { AugPath(this, G, Gf, V, s, t, P) } { |P| } AugPath(this, G, Gf, V, s, t, P) && |P| <= V)
(declare-const P@174@00 Seq<Int>)
(push) ; 2
; [eval] AugPath(this, G, Gf, V, s, t, P) && |P| <= V
; [eval] AugPath(this, G, Gf, V, s, t, P)
(push) ; 3
; [eval] this != null
; [eval] SquareIntMatrix(this, G, V)
(push) ; 4
; [eval] this != null
(pop) ; 4
; Joined path conditions
; [eval] SquareIntMatrix(this, Gf, V)
(push) ; 4
; [eval] this != null
(pop) ; 4
; Joined path conditions
; [eval] FlowNetwork(this, G, V, s, t)
(push) ; 4
; [eval] this != null
(pop) ; 4
; Joined path conditions
; [eval] FlowNetwork(this, Gf, V, s, t)
(push) ; 4
; [eval] this != null
(pop) ; 4
; Joined path conditions
; [eval] ValidFlow(this, G, Gf, V, s, t)
(push) ; 4
; [eval] this != null
; [eval] SquareIntMatrix(this, Gf, V)
(push) ; 5
; [eval] this != null
(pop) ; 5
; Joined path conditions
; [eval] FlowNetwork(this, G, V, s, t)
(push) ; 5
; [eval] this != null
(pop) ; 5
; Joined path conditions
; [eval] FlowNetwork(this, Gf, V, s, t)
(push) ; 5
; [eval] this != null
(pop) ; 5
; Joined path conditions
(pop) ; 4
; Joined path conditions
(pop) ; 3
; Joined path conditions
(push) ; 3
; [then-branch: 96 | AugPath((_, (_, (_, (_, (_, _))))), this@92@00, G@93@00, Gf@94@00, V@95@00, s@96@00, t@97@00, P@174@00) | live]
; [else-branch: 96 | !(AugPath((_, (_, (_, (_, (_, _))))), this@92@00, G@93@00, Gf@94@00, V@95@00, s@96@00, t@97@00, P@174@00)) | live]
(push) ; 4
; [then-branch: 96 | AugPath((_, (_, (_, (_, (_, _))))), this@92@00, G@93@00, Gf@94@00, V@95@00, s@96@00, t@97@00, P@174@00)]
(assert (AugPath ($Snap.combine
  $Snap.unit
  ($Snap.combine
    $Snap.unit
    ($Snap.combine
      $Snap.unit
      ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))))) this@92@00 G@93@00 Gf@94@00 V@95@00 s@96@00 t@97@00 P@174@00))
; [eval] |P| <= V
; [eval] |P|
(pop) ; 4
(push) ; 4
; [else-branch: 96 | !(AugPath((_, (_, (_, (_, (_, _))))), this@92@00, G@93@00, Gf@94@00, V@95@00, s@96@00, t@97@00, P@174@00))]
(assert (not
  (AugPath ($Snap.combine
    $Snap.unit
    ($Snap.combine
      $Snap.unit
      ($Snap.combine
        $Snap.unit
        ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))))) this@92@00 G@93@00 Gf@94@00 V@95@00 s@96@00 t@97@00 P@174@00)))
(pop) ; 4
(pop) ; 3
; Joined path conditions
; Joined path conditions
(pop) ; 2
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
; Nested auxiliary terms: non-globals (tlq)
(assert (=
  result@98@00
  (exists ((P@174@00 Seq<Int>)) (!
    (and
      (<= (Seq_length P@174@00) V@95@00)
      (AugPath ($Snap.combine
        $Snap.unit
        ($Snap.combine
          $Snap.unit
          ($Snap.combine
            $Snap.unit
            ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))))) this@92@00 G@93@00 Gf@94@00 V@95@00 s@96@00 t@97@00 P@174@00))
    :pattern ((AugPath%limited ($Snap.combine
      $Snap.unit
      ($Snap.combine
        $Snap.unit
        ($Snap.combine
          $Snap.unit
          ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))))) this@92@00 G@93@00 Gf@94@00 V@95@00 s@96@00 t@97@00 P@174@00))
    :pattern ((Seq_length P@174@00))
    :qid |prog.l<no position>|))))
(pop) ; 1
(assert (forall ((s@$ $Snap) (this@92@00 $Ref) (G@93@00 Seq<Seq<Int>>) (Gf@94@00 Seq<Seq<Int>>) (V@95@00 Int) (s@96@00 Int) (t@97@00 Int)) (!
  (implies
    (and
      (not (= this@92@00 $Ref.null))
      (SquareIntMatrix $Snap.unit this@92@00 G@93@00 V@95@00)
      (SquareIntMatrix $Snap.unit this@92@00 Gf@94@00 V@95@00)
      (FlowNetwork $Snap.unit this@92@00 G@93@00 V@95@00 s@96@00 t@97@00)
      (FlowNetwork $Snap.unit this@92@00 Gf@94@00 V@95@00 s@96@00 t@97@00)
      (ValidFlow ($Snap.combine
        $Snap.unit
        ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) this@92@00 G@93@00 Gf@94@00 V@95@00 s@96@00 t@97@00))
    (=
      (ExAugPath s@$ this@92@00 G@93@00 Gf@94@00 V@95@00 s@96@00 t@97@00)
      (exists ((P Seq<Int>)) (!
        (and
          (AugPath ($Snap.combine
            $Snap.unit
            ($Snap.combine
              $Snap.unit
              ($Snap.combine
                $Snap.unit
                ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))))) this@92@00 G@93@00 Gf@94@00 V@95@00 s@96@00 t@97@00 P)
          (<= (Seq_length P) V@95@00))
        :pattern ((AugPath%limited ($Snap.combine
          $Snap.unit
          ($Snap.combine
            $Snap.unit
            ($Snap.combine
              $Snap.unit
              ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))))) this@92@00 G@93@00 Gf@94@00 V@95@00 s@96@00 t@97@00 P))
        :pattern ((Seq_length P))
        ))))
  :pattern ((ExAugPath s@$ this@92@00 G@93@00 Gf@94@00 V@95@00 s@96@00 t@97@00))
  )))
; ---------- FUNCTION opt_or_else----------
(declare-fun opt1@99@00 () option<any>)
(declare-fun alt@100@00 () any)
(declare-fun result@101@00 () any)
; ----- Well-definedness of specifications -----
(push) ; 1
(declare-const $t@175@00 $Snap)
(assert (= $t@175@00 ($Snap.combine ($Snap.first $t@175@00) ($Snap.second $t@175@00))))
(assert (= ($Snap.first $t@175@00) $Snap.unit))
; [eval] opt1 == (None(): option[any]) ==> result == alt
; [eval] opt1 == (None(): option[any])
; [eval] (None(): option[any])
(push) ; 2
(set-option :timeout 10)
(push) ; 3
(assert (not (not (= opt1@99@00 (as None<option<any>>  option<any>)))))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1830
;  :arith-add-rows          1432
;  :arith-assert-diseq      191
;  :arith-assert-lower      776
;  :arith-assert-upper      411
;  :arith-bound-prop        122
;  :arith-conflicts         69
;  :arith-eq-adapter        338
;  :arith-fixed-eqs         224
;  :arith-offset-eqs        87
;  :arith-pivots            631
;  :conflicts               133
;  :datatype-accessor-ax    123
;  :datatype-constructor-ax 20
;  :datatype-occurs-check   82
;  :datatype-splits         20
;  :decisions               181
;  :del-clause              2683
;  :final-checks            78
;  :interface-eqs           9
;  :max-generation          6
;  :max-memory              5.25
;  :memory                  5.21
;  :minimized-lits          1
;  :mk-bool-var             4754
;  :mk-clause               2683
;  :num-allocs              239309
;  :num-checks              164
;  :propagations            1065
;  :quant-instantiations    1336
;  :rlimit-count            348056)
(push) ; 3
(assert (not (= opt1@99@00 (as None<option<any>>  option<any>))))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1832
;  :arith-add-rows          1432
;  :arith-assert-diseq      191
;  :arith-assert-lower      776
;  :arith-assert-upper      411
;  :arith-bound-prop        122
;  :arith-conflicts         69
;  :arith-eq-adapter        338
;  :arith-fixed-eqs         224
;  :arith-offset-eqs        87
;  :arith-pivots            631
;  :conflicts               133
;  :datatype-accessor-ax    123
;  :datatype-constructor-ax 21
;  :datatype-occurs-check   84
;  :datatype-splits         21
;  :decisions               182
;  :del-clause              2683
;  :final-checks            80
;  :interface-eqs           9
;  :max-generation          6
;  :max-memory              5.25
;  :memory                  5.21
;  :minimized-lits          1
;  :mk-bool-var             4756
;  :mk-clause               2683
;  :num-allocs              239694
;  :num-checks              165
;  :propagations            1065
;  :quant-instantiations    1336
;  :rlimit-count            348497)
; [then-branch: 97 | opt1@99@00 == None[option[any]] | live]
; [else-branch: 97 | opt1@99@00 != None[option[any]] | live]
(push) ; 3
; [then-branch: 97 | opt1@99@00 == None[option[any]]]
(assert (= opt1@99@00 (as None<option<any>>  option<any>)))
; [eval] result == alt
(pop) ; 3
(push) ; 3
; [else-branch: 97 | opt1@99@00 != None[option[any]]]
(assert (not (= opt1@99@00 (as None<option<any>>  option<any>))))
(pop) ; 3
(pop) ; 2
; Joined path conditions
; Joined path conditions
(assert (implies
  (= opt1@99@00 (as None<option<any>>  option<any>))
  (= result@101@00 alt@100@00)))
(assert (= ($Snap.second $t@175@00) $Snap.unit))
; [eval] opt1 != (None(): option[any]) ==> result == opt_get(opt1)
; [eval] opt1 != (None(): option[any])
; [eval] (None(): option[any])
(push) ; 2
(push) ; 3
(assert (not (= opt1@99@00 (as None<option<any>>  option<any>))))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1833
;  :arith-add-rows          1432
;  :arith-assert-diseq      191
;  :arith-assert-lower      776
;  :arith-assert-upper      411
;  :arith-bound-prop        122
;  :arith-conflicts         69
;  :arith-eq-adapter        338
;  :arith-fixed-eqs         224
;  :arith-offset-eqs        87
;  :arith-pivots            631
;  :conflicts               133
;  :datatype-accessor-ax    123
;  :datatype-constructor-ax 21
;  :datatype-occurs-check   85
;  :datatype-splits         21
;  :decisions               182
;  :del-clause              2683
;  :final-checks            81
;  :interface-eqs           9
;  :max-generation          6
;  :max-memory              5.25
;  :memory                  5.21
;  :minimized-lits          1
;  :mk-bool-var             4759
;  :mk-clause               2684
;  :num-allocs              240150
;  :num-checks              166
;  :propagations            1065
;  :quant-instantiations    1336
;  :rlimit-count            349049)
(push) ; 3
(assert (not (not (= opt1@99@00 (as None<option<any>>  option<any>)))))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1835
;  :arith-add-rows          1432
;  :arith-assert-diseq      191
;  :arith-assert-lower      776
;  :arith-assert-upper      411
;  :arith-bound-prop        122
;  :arith-conflicts         69
;  :arith-eq-adapter        338
;  :arith-fixed-eqs         224
;  :arith-offset-eqs        87
;  :arith-pivots            631
;  :conflicts               133
;  :datatype-accessor-ax    123
;  :datatype-constructor-ax 21
;  :datatype-occurs-check   86
;  :datatype-splits         21
;  :decisions               182
;  :del-clause              2683
;  :final-checks            82
;  :interface-eqs           9
;  :max-generation          6
;  :max-memory              5.25
;  :memory                  5.21
;  :minimized-lits          1
;  :mk-bool-var             4759
;  :mk-clause               2684
;  :num-allocs              240553
;  :num-checks              167
;  :propagations            1066
;  :quant-instantiations    1336
;  :rlimit-count            349455)
; [then-branch: 98 | opt1@99@00 != None[option[any]] | live]
; [else-branch: 98 | opt1@99@00 == None[option[any]] | live]
(push) ; 3
; [then-branch: 98 | opt1@99@00 != None[option[any]]]
(assert (not (= opt1@99@00 (as None<option<any>>  option<any>))))
; [eval] result == opt_get(opt1)
; [eval] opt_get(opt1)
(push) ; 4
; [eval] opt1 != (None(): option[any])
; [eval] (None(): option[any])
(pop) ; 4
; Joined path conditions
(pop) ; 3
(push) ; 3
; [else-branch: 98 | opt1@99@00 == None[option[any]]]
(assert (= opt1@99@00 (as None<option<any>>  option<any>)))
(pop) ; 3
(pop) ; 2
; Joined path conditions
; Joined path conditions
(assert (implies
  (not (= opt1@99@00 (as None<option<any>>  option<any>)))
  (= result@101@00 (opt_get $Snap.unit opt1@99@00))))
(pop) ; 1
(assert (forall ((s@$ $Snap) (opt1@99@00 option<any>) (alt@100@00 any)) (!
  (=
    (opt_or_else%limited s@$ opt1@99@00 alt@100@00)
    (opt_or_else s@$ opt1@99@00 alt@100@00))
  :pattern ((opt_or_else s@$ opt1@99@00 alt@100@00))
  )))
(assert (forall ((s@$ $Snap) (opt1@99@00 option<any>) (alt@100@00 any)) (!
  (opt_or_else%stateless opt1@99@00 alt@100@00)
  :pattern ((opt_or_else%limited s@$ opt1@99@00 alt@100@00))
  )))
(assert (forall ((s@$ $Snap) (opt1@99@00 option<any>) (alt@100@00 any)) (!
  (let ((result@101@00 (opt_or_else%limited s@$ opt1@99@00 alt@100@00))) (and
    (implies
      (= opt1@99@00 (as None<option<any>>  option<any>))
      (= result@101@00 alt@100@00))
    (implies
      (not (= opt1@99@00 (as None<option<any>>  option<any>)))
      (= result@101@00 (opt_get $Snap.unit opt1@99@00)))))
  :pattern ((opt_or_else%limited s@$ opt1@99@00 alt@100@00))
  )))
; ----- Verification of function body and postcondition -----
(push) ; 1
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
; [eval] (opt1 == (None(): option[any]) ? alt : opt_get(opt1))
; [eval] opt1 == (None(): option[any])
; [eval] (None(): option[any])
(push) ; 2
(set-option :timeout 10)
(push) ; 3
(assert (not (not (= opt1@99@00 (as None<option<any>>  option<any>)))))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1836
;  :arith-add-rows          1432
;  :arith-assert-diseq      191
;  :arith-assert-lower      776
;  :arith-assert-upper      411
;  :arith-bound-prop        122
;  :arith-conflicts         69
;  :arith-eq-adapter        338
;  :arith-fixed-eqs         224
;  :arith-offset-eqs        87
;  :arith-pivots            631
;  :conflicts               133
;  :datatype-accessor-ax    123
;  :datatype-constructor-ax 21
;  :datatype-occurs-check   86
;  :datatype-splits         21
;  :decisions               182
;  :del-clause              2684
;  :final-checks            84
;  :interface-eqs           9
;  :max-generation          6
;  :max-memory              5.25
;  :memory                  5.21
;  :minimized-lits          1
;  :mk-bool-var             4763
;  :mk-clause               2684
;  :num-allocs              241641
;  :num-checks              169
;  :propagations            1066
;  :quant-instantiations    1336
;  :rlimit-count            350733)
(push) ; 3
(assert (not (= opt1@99@00 (as None<option<any>>  option<any>))))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1836
;  :arith-add-rows          1432
;  :arith-assert-diseq      191
;  :arith-assert-lower      776
;  :arith-assert-upper      411
;  :arith-bound-prop        122
;  :arith-conflicts         69
;  :arith-eq-adapter        338
;  :arith-fixed-eqs         224
;  :arith-offset-eqs        87
;  :arith-pivots            631
;  :conflicts               133
;  :datatype-accessor-ax    123
;  :datatype-constructor-ax 21
;  :datatype-occurs-check   86
;  :datatype-splits         21
;  :decisions               182
;  :del-clause              2684
;  :final-checks            85
;  :interface-eqs           9
;  :max-generation          6
;  :max-memory              5.25
;  :memory                  5.21
;  :minimized-lits          1
;  :mk-bool-var             4764
;  :mk-clause               2684
;  :num-allocs              242010
;  :num-checks              170
;  :propagations            1066
;  :quant-instantiations    1336
;  :rlimit-count            351142)
; [then-branch: 99 | opt1@99@00 == None[option[any]] | live]
; [else-branch: 99 | opt1@99@00 != None[option[any]] | live]
(push) ; 3
; [then-branch: 99 | opt1@99@00 == None[option[any]]]
(assert (= opt1@99@00 (as None<option<any>>  option<any>)))
(pop) ; 3
(push) ; 3
; [else-branch: 99 | opt1@99@00 != None[option[any]]]
(assert (not (= opt1@99@00 (as None<option<any>>  option<any>))))
; [eval] opt_get(opt1)
(push) ; 4
; [eval] opt1 != (None(): option[any])
; [eval] (None(): option[any])
(pop) ; 4
; Joined path conditions
(pop) ; 3
(pop) ; 2
; Joined path conditions
; Joined path conditions
(assert (=
  result@101@00
  (ite
    (= opt1@99@00 (as None<option<any>>  option<any>))
    alt@100@00
    (opt_get $Snap.unit opt1@99@00))))
; [eval] opt1 == (None(): option[any]) ==> result == alt
; [eval] opt1 == (None(): option[any])
; [eval] (None(): option[any])
(push) ; 2
(push) ; 3
(assert (not (not (= opt1@99@00 (as None<option<any>>  option<any>)))))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1839
;  :arith-add-rows          1432
;  :arith-assert-diseq      191
;  :arith-assert-lower      776
;  :arith-assert-upper      411
;  :arith-bound-prop        122
;  :arith-conflicts         69
;  :arith-eq-adapter        338
;  :arith-fixed-eqs         224
;  :arith-offset-eqs        87
;  :arith-pivots            631
;  :conflicts               133
;  :datatype-accessor-ax    124
;  :datatype-constructor-ax 21
;  :datatype-occurs-check   87
;  :datatype-splits         21
;  :decisions               182
;  :del-clause              2684
;  :final-checks            86
;  :interface-eqs           9
;  :max-generation          6
;  :max-memory              5.25
;  :memory                  5.21
;  :minimized-lits          1
;  :mk-bool-var             4769
;  :mk-clause               2686
;  :num-allocs              242549
;  :num-checks              171
;  :propagations            1067
;  :quant-instantiations    1336
;  :rlimit-count            351701)
(push) ; 3
(assert (not (= opt1@99@00 (as None<option<any>>  option<any>))))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1843
;  :arith-add-rows          1432
;  :arith-assert-diseq      191
;  :arith-assert-lower      776
;  :arith-assert-upper      411
;  :arith-bound-prop        122
;  :arith-conflicts         69
;  :arith-eq-adapter        338
;  :arith-fixed-eqs         224
;  :arith-offset-eqs        87
;  :arith-pivots            631
;  :conflicts               133
;  :datatype-accessor-ax    124
;  :datatype-constructor-ax 21
;  :datatype-occurs-check   88
;  :datatype-splits         21
;  :decisions               182
;  :del-clause              2684
;  :final-checks            87
;  :interface-eqs           9
;  :max-generation          6
;  :max-memory              5.25
;  :memory                  5.21
;  :minimized-lits          1
;  :mk-bool-var             4773
;  :mk-clause               2686
;  :num-allocs              242999
;  :num-checks              172
;  :propagations            1068
;  :quant-instantiations    1340
;  :rlimit-count            352197)
; [then-branch: 100 | opt1@99@00 == None[option[any]] | live]
; [else-branch: 100 | opt1@99@00 != None[option[any]] | live]
(push) ; 3
; [then-branch: 100 | opt1@99@00 == None[option[any]]]
(assert (= opt1@99@00 (as None<option<any>>  option<any>)))
; [eval] result == alt
(pop) ; 3
(push) ; 3
; [else-branch: 100 | opt1@99@00 != None[option[any]]]
(assert (not (= opt1@99@00 (as None<option<any>>  option<any>))))
(pop) ; 3
(pop) ; 2
; Joined path conditions
; Joined path conditions
(set-option :timeout 0)
(push) ; 2
(assert (not (implies
  (= opt1@99@00 (as None<option<any>>  option<any>))
  (= result@101@00 alt@100@00))))
(check-sat)
; unsat
(pop) ; 2
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1846
;  :arith-add-rows          1432
;  :arith-assert-diseq      191
;  :arith-assert-lower      776
;  :arith-assert-upper      411
;  :arith-bound-prop        122
;  :arith-conflicts         69
;  :arith-eq-adapter        338
;  :arith-fixed-eqs         224
;  :arith-offset-eqs        87
;  :arith-pivots            631
;  :conflicts               134
;  :datatype-accessor-ax    124
;  :datatype-constructor-ax 21
;  :datatype-occurs-check   88
;  :datatype-splits         21
;  :decisions               182
;  :del-clause              2684
;  :final-checks            87
;  :interface-eqs           9
;  :max-generation          6
;  :max-memory              5.25
;  :memory                  5.21
;  :minimized-lits          1
;  :mk-bool-var             4774
;  :mk-clause               2686
;  :num-allocs              243084
;  :num-checks              173
;  :propagations            1069
;  :quant-instantiations    1340
;  :rlimit-count            352303)
(assert (implies
  (= opt1@99@00 (as None<option<any>>  option<any>))
  (= result@101@00 alt@100@00)))
; [eval] opt1 != (None(): option[any]) ==> result == opt_get(opt1)
; [eval] opt1 != (None(): option[any])
; [eval] (None(): option[any])
(push) ; 2
(set-option :timeout 10)
(push) ; 3
(assert (not (= opt1@99@00 (as None<option<any>>  option<any>))))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1851
;  :arith-add-rows          1432
;  :arith-assert-diseq      191
;  :arith-assert-lower      776
;  :arith-assert-upper      411
;  :arith-bound-prop        122
;  :arith-conflicts         69
;  :arith-eq-adapter        338
;  :arith-fixed-eqs         224
;  :arith-offset-eqs        87
;  :arith-pivots            631
;  :conflicts               134
;  :datatype-accessor-ax    124
;  :datatype-constructor-ax 21
;  :datatype-occurs-check   89
;  :datatype-splits         21
;  :decisions               182
;  :del-clause              2684
;  :final-checks            88
;  :interface-eqs           9
;  :max-generation          6
;  :max-memory              5.25
;  :memory                  5.21
;  :minimized-lits          1
;  :mk-bool-var             4779
;  :mk-clause               2687
;  :num-allocs              243581
;  :num-checks              174
;  :propagations            1070
;  :quant-instantiations    1344
;  :rlimit-count            352863)
(push) ; 3
(assert (not (not (= opt1@99@00 (as None<option<any>>  option<any>)))))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1854
;  :arith-add-rows          1432
;  :arith-assert-diseq      191
;  :arith-assert-lower      776
;  :arith-assert-upper      411
;  :arith-bound-prop        122
;  :arith-conflicts         69
;  :arith-eq-adapter        338
;  :arith-fixed-eqs         224
;  :arith-offset-eqs        87
;  :arith-pivots            631
;  :conflicts               134
;  :datatype-accessor-ax    124
;  :datatype-constructor-ax 21
;  :datatype-occurs-check   90
;  :datatype-splits         21
;  :decisions               182
;  :del-clause              2684
;  :final-checks            89
;  :interface-eqs           9
;  :max-generation          6
;  :max-memory              5.25
;  :memory                  5.21
;  :minimized-lits          1
;  :mk-bool-var             4779
;  :mk-clause               2687
;  :num-allocs              243965
;  :num-checks              175
;  :propagations            1072
;  :quant-instantiations    1344
;  :rlimit-count            353272)
; [then-branch: 101 | opt1@99@00 != None[option[any]] | live]
; [else-branch: 101 | opt1@99@00 == None[option[any]] | live]
(push) ; 3
; [then-branch: 101 | opt1@99@00 != None[option[any]]]
(assert (not (= opt1@99@00 (as None<option<any>>  option<any>))))
; [eval] result == opt_get(opt1)
; [eval] opt_get(opt1)
(push) ; 4
; [eval] opt1 != (None(): option[any])
; [eval] (None(): option[any])
(pop) ; 4
; Joined path conditions
(pop) ; 3
(push) ; 3
; [else-branch: 101 | opt1@99@00 == None[option[any]]]
(assert (= opt1@99@00 (as None<option<any>>  option<any>)))
(pop) ; 3
(pop) ; 2
; Joined path conditions
; Joined path conditions
(set-option :timeout 0)
(push) ; 2
(assert (not (implies
  (not (= opt1@99@00 (as None<option<any>>  option<any>)))
  (= result@101@00 (opt_get $Snap.unit opt1@99@00)))))
(check-sat)
; unsat
(pop) ; 2
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1860
;  :arith-add-rows          1432
;  :arith-assert-diseq      191
;  :arith-assert-lower      776
;  :arith-assert-upper      411
;  :arith-bound-prop        122
;  :arith-conflicts         69
;  :arith-eq-adapter        338
;  :arith-fixed-eqs         224
;  :arith-offset-eqs        87
;  :arith-pivots            631
;  :conflicts               135
;  :datatype-accessor-ax    124
;  :datatype-constructor-ax 21
;  :datatype-occurs-check   90
;  :datatype-splits         21
;  :decisions               182
;  :del-clause              2684
;  :final-checks            89
;  :interface-eqs           9
;  :max-generation          6
;  :max-memory              5.25
;  :memory                  5.20
;  :minimized-lits          1
;  :mk-bool-var             4784
;  :mk-clause               2687
;  :num-allocs              244112
;  :num-checks              176
;  :propagations            1074
;  :quant-instantiations    1348
;  :rlimit-count            353518)
(assert (implies
  (not (= opt1@99@00 (as None<option<any>>  option<any>)))
  (= result@101@00 (opt_get $Snap.unit opt1@99@00))))
(pop) ; 1
(assert (forall ((s@$ $Snap) (opt1@99@00 option<any>) (alt@100@00 any)) (!
  (=
    (opt_or_else s@$ opt1@99@00 alt@100@00)
    (ite
      (= opt1@99@00 (as None<option<any>>  option<any>))
      alt@100@00
      (opt_get $Snap.unit opt1@99@00)))
  :pattern ((opt_or_else s@$ opt1@99@00 alt@100@00))
  )))
; ---------- FUNCTION FlowNetwork1----------
(declare-fun this@102@00 () $Ref)
(declare-fun G@103@00 () option<array>)
(declare-fun V@104@00 () Int)
(declare-fun s@105@00 () Int)
(declare-fun t@106@00 () Int)
(declare-fun result@107@00 () Bool)
; ----- Well-definedness of specifications -----
(push) ; 1
(assert (= s@$ ($Snap.combine ($Snap.first s@$) ($Snap.second s@$))))
(assert (= ($Snap.first s@$) $Snap.unit))
; [eval] this != null
(assert (not (= this@102@00 $Ref.null)))
(assert (=
  ($Snap.second s@$)
  ($Snap.combine
    ($Snap.first ($Snap.second s@$))
    ($Snap.second ($Snap.second s@$)))))
(assert (= ($Snap.first ($Snap.second s@$)) $Snap.unit))
; [eval] G != (None(): option[array])
; [eval] (None(): option[array])
(assert (not (= G@103@00 (as None<option<array>>  option<array>))))
(assert (=
  ($Snap.second ($Snap.second s@$))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second s@$)))
    ($Snap.second ($Snap.second ($Snap.second s@$))))))
(assert (= ($Snap.first ($Snap.second ($Snap.second s@$))) $Snap.unit))
; [eval] alen(opt_get1(G)) == V
; [eval] alen(opt_get1(G))
; [eval] opt_get1(G)
(push) ; 2
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 2
; Joined path conditions
(assert (= (alen<Int> (opt_get1 $Snap.unit G@103@00)) V@104@00))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second s@$)))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$)))))))
(declare-const i1@176@00 Int)
(push) ; 2
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 3
; [then-branch: 102 | 0 <= i1@176@00 | live]
; [else-branch: 102 | !(0 <= i1@176@00) | live]
(push) ; 4
; [then-branch: 102 | 0 <= i1@176@00]
(assert (<= 0 i1@176@00))
; [eval] i1 < V
(pop) ; 4
(push) ; 4
; [else-branch: 102 | !(0 <= i1@176@00)]
(assert (not (<= 0 i1@176@00)))
(pop) ; 4
(pop) ; 3
; Joined path conditions
; Joined path conditions
(assert (and (< i1@176@00 V@104@00) (<= 0 i1@176@00)))
; [eval] aloc(opt_get1(G), i1)
; [eval] opt_get1(G)
(push) ; 3
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 3
; Joined path conditions
(push) ; 3
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 4
(assert (not (< i1@176@00 (alen<Int> (opt_get1 $Snap.unit G@103@00)))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1888
;  :arith-add-rows          1432
;  :arith-assert-diseq      191
;  :arith-assert-lower      779
;  :arith-assert-upper      413
;  :arith-bound-prop        122
;  :arith-conflicts         69
;  :arith-eq-adapter        339
;  :arith-fixed-eqs         225
;  :arith-offset-eqs        87
;  :arith-pivots            632
;  :conflicts               135
;  :datatype-accessor-ax    129
;  :datatype-constructor-ax 21
;  :datatype-occurs-check   90
;  :datatype-splits         21
;  :decisions               182
;  :del-clause              2687
;  :final-checks            89
;  :interface-eqs           9
;  :max-generation          6
;  :max-memory              5.25
;  :memory                  5.21
;  :minimized-lits          1
;  :mk-bool-var             4804
;  :mk-clause               2687
;  :num-allocs              244728
;  :num-checks              177
;  :propagations            1074
;  :quant-instantiations    1353
;  :rlimit-count            354562)
(assert (< i1@176@00 (alen<Int> (opt_get1 $Snap.unit G@103@00))))
(pop) ; 3
; Joined path conditions
(assert (< i1@176@00 (alen<Int> (opt_get1 $Snap.unit G@103@00))))
(declare-const $k@177@00 $Perm)
(assert ($Perm.isReadVar $k@177@00 $Perm.Write))
(pop) ; 2
(declare-fun inv@178@00 ($Snap $Ref option<array> Int Int Int $Ref) Int)
; Nested auxiliary terms: globals
(assert ($Perm.isReadVar $k@177@00 $Perm.Write))
; Nested auxiliary terms: non-globals
(assert (forall ((i1@176@00 Int)) (!
  (< i1@176@00 (alen<Int> (opt_get1 $Snap.unit G@103@00)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@176@00))
  :qid |option$array$-aux|)))
(push) ; 2
(assert (not (forall ((i1@176@00 Int)) (!
  (implies
    (and (< i1@176@00 V@104@00) (<= 0 i1@176@00))
    (or (= $k@177@00 $Perm.No) (< $Perm.No $k@177@00)))
  
  ))))
(check-sat)
; unsat
(pop) ; 2
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1890
;  :arith-add-rows          1432
;  :arith-assert-diseq      192
;  :arith-assert-lower      781
;  :arith-assert-upper      414
;  :arith-bound-prop        122
;  :arith-conflicts         69
;  :arith-eq-adapter        340
;  :arith-fixed-eqs         225
;  :arith-offset-eqs        87
;  :arith-pivots            633
;  :conflicts               136
;  :datatype-accessor-ax    130
;  :datatype-constructor-ax 21
;  :datatype-occurs-check   90
;  :datatype-splits         21
;  :decisions               182
;  :del-clause              2687
;  :final-checks            89
;  :interface-eqs           9
;  :max-generation          6
;  :max-memory              5.25
;  :memory                  5.21
;  :minimized-lits          1
;  :mk-bool-var             4811
;  :mk-clause               2689
;  :num-allocs              245214
;  :num-checks              178
;  :propagations            1075
;  :quant-instantiations    1353
;  :rlimit-count            355133)
; Check receiver injectivity
(push) ; 2
(assert (not (forall ((i11@176@00 Int) (i12@176@00 Int)) (!
  (implies
    (and
      (and
        (and (< i11@176@00 V@104@00) (<= 0 i11@176@00))
        (< $Perm.No $k@177@00))
      (and
        (and (< i12@176@00 V@104@00) (<= 0 i12@176@00))
        (< $Perm.No $k@177@00))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@103@00) i11@176@00)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@103@00) i12@176@00)))
    (= i11@176@00 i12@176@00))
  
  :qid |option$array$-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 2
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1911
;  :arith-add-rows          1445
;  :arith-assert-diseq      195
;  :arith-assert-lower      788
;  :arith-assert-upper      418
;  :arith-bound-prop        122
;  :arith-conflicts         71
;  :arith-eq-adapter        342
;  :arith-fixed-eqs         226
;  :arith-offset-eqs        88
;  :arith-pivots            641
;  :conflicts               139
;  :datatype-accessor-ax    130
;  :datatype-constructor-ax 21
;  :datatype-occurs-check   90
;  :datatype-splits         21
;  :decisions               184
;  :del-clause              2702
;  :final-checks            89
;  :interface-eqs           9
;  :max-generation          6
;  :max-memory              5.25
;  :memory                  5.22
;  :minimized-lits          1
;  :mk-bool-var             4836
;  :mk-clause               2704
;  :num-allocs              245572
;  :num-checks              179
;  :propagations            1090
;  :quant-instantiations    1363
;  :rlimit-count            356183)
; Definitional axioms for inverse functions
(assert (forall ((i1@176@00 Int)) (!
  (implies
    (and (and (< i1@176@00 V@104@00) (<= 0 i1@176@00)) (< $Perm.No $k@177@00))
    (=
      (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@176@00))
      i1@176@00))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@176@00))
  )))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      (< $Perm.No $k@177@00))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@103@00) (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
      r))
  :pattern ((inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
  :qid |option$array$-fctOfInv|)))
; Permissions are non-negative
(assert (forall ((i1@176@00 Int)) (!
  (<= $Perm.No $k@177@00)
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@176@00))
  :qid |option$array$-permAtLeastZero|)))
; Field permissions are at most one
(assert (forall ((i1@176@00 Int)) (!
  (<= $k@177@00 $Perm.Write)
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@176@00))
  :qid |option$array$-permAtMostOne|)))
; Permission implies non-null receiver
(assert (forall ((i1@176@00 Int)) (!
  (implies
    (and (and (< i1@176@00 V@104@00) (<= 0 i1@176@00)) (< $Perm.No $k@177@00))
    (not
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@176@00)
        $Ref.null)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@176@00))
  :qid |option$array$-permImpliesNonNull|)))
(declare-fun sm@179@00 ($Snap $Ref option<array> Int Int Int) $FVF<option<array>>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      (< $Perm.No $k@177@00)
      false)
    (=
      ($FVF.lookup_option$array$ (sm@179@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r)))
  :pattern (($FVF.lookup_option$array$ (sm@179@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r))
  :qid |qp.fvfValDef17|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r)
  :pattern (($FVF.lookup_option$array$ (sm@179@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :qid |qp.fvfResTrgDef18|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (<
        (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
        V@104@00)
      (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@179@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r) r))
  :pattern ((inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
  )))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$)))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$)))))
  $Snap.unit))
; [eval] (forall i1: Int :: { aloc(opt_get1(G), i1) } 0 <= i1 && i1 < V ==> aloc(opt_get1(G), i1).option$array$ != (None(): option[array]))
(declare-const i1@180@00 Int)
(push) ; 2
; [eval] 0 <= i1 && i1 < V ==> aloc(opt_get1(G), i1).option$array$ != (None(): option[array])
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 3
; [then-branch: 103 | 0 <= i1@180@00 | live]
; [else-branch: 103 | !(0 <= i1@180@00) | live]
(push) ; 4
; [then-branch: 103 | 0 <= i1@180@00]
(assert (<= 0 i1@180@00))
; [eval] i1 < V
(pop) ; 4
(push) ; 4
; [else-branch: 103 | !(0 <= i1@180@00)]
(assert (not (<= 0 i1@180@00)))
(pop) ; 4
(pop) ; 3
; Joined path conditions
; Joined path conditions
(push) ; 3
; [then-branch: 104 | i1@180@00 < V@104@00 && 0 <= i1@180@00 | live]
; [else-branch: 104 | !(i1@180@00 < V@104@00 && 0 <= i1@180@00) | live]
(push) ; 4
; [then-branch: 104 | i1@180@00 < V@104@00 && 0 <= i1@180@00]
(assert (and (< i1@180@00 V@104@00) (<= 0 i1@180@00)))
; [eval] aloc(opt_get1(G), i1).option$array$ != (None(): option[array])
; [eval] aloc(opt_get1(G), i1)
; [eval] opt_get1(G)
(push) ; 5
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 5
; Joined path conditions
(push) ; 5
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 6
(assert (not (< i1@180@00 (alen<Int> (opt_get1 $Snap.unit G@103@00)))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1918
;  :arith-add-rows          1446
;  :arith-assert-diseq      195
;  :arith-assert-lower      790
;  :arith-assert-upper      421
;  :arith-bound-prop        122
;  :arith-conflicts         71
;  :arith-eq-adapter        343
;  :arith-fixed-eqs         227
;  :arith-offset-eqs        88
;  :arith-pivots            643
;  :conflicts               139
;  :datatype-accessor-ax    131
;  :datatype-constructor-ax 21
;  :datatype-occurs-check   90
;  :datatype-splits         21
;  :decisions               184
;  :del-clause              2702
;  :final-checks            89
;  :interface-eqs           9
;  :max-generation          6
;  :max-memory              5.25
;  :memory                  5.22
;  :minimized-lits          1
;  :mk-bool-var             4849
;  :mk-clause               2704
;  :num-allocs              246873
;  :num-checks              180
;  :propagations            1090
;  :quant-instantiations    1363
;  :rlimit-count            358595)
(assert (< i1@180@00 (alen<Int> (opt_get1 $Snap.unit G@103@00))))
(pop) ; 5
; Joined path conditions
(assert (< i1@180@00 (alen<Int> (opt_get1 $Snap.unit G@103@00))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@179@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@180@00)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@180@00)))
(push) ; 5
(assert (not (ite
  (and
    (<
      (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@180@00))
      V@104@00)
    (<=
      0
      (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@180@00))))
  (< $Perm.No $k@177@00)
  false)))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1930
;  :arith-add-rows          1449
;  :arith-assert-diseq      195
;  :arith-assert-lower      791
;  :arith-assert-upper      422
;  :arith-bound-prop        125
;  :arith-conflicts         71
;  :arith-eq-adapter        344
;  :arith-fixed-eqs         228
;  :arith-offset-eqs        91
;  :arith-pivots            644
;  :conflicts               140
;  :datatype-accessor-ax    131
;  :datatype-constructor-ax 21
;  :datatype-occurs-check   90
;  :datatype-splits         21
;  :decisions               184
;  :del-clause              2702
;  :final-checks            89
;  :interface-eqs           9
;  :max-generation          6
;  :max-memory              5.25
;  :memory                  5.23
;  :minimized-lits          1
;  :mk-bool-var             4866
;  :mk-clause               2712
;  :num-allocs              247146
;  :num-checks              181
;  :propagations            1094
;  :quant-instantiations    1373
;  :rlimit-count            359217)
; [eval] (None(): option[array])
(pop) ; 4
(push) ; 4
; [else-branch: 104 | !(i1@180@00 < V@104@00 && 0 <= i1@180@00)]
(assert (not (and (< i1@180@00 V@104@00) (<= 0 i1@180@00))))
(pop) ; 4
(pop) ; 3
; Joined path conditions
(assert (implies
  (and (< i1@180@00 V@104@00) (<= 0 i1@180@00))
  (and
    (< i1@180@00 V@104@00)
    (<= 0 i1@180@00)
    (< i1@180@00 (alen<Int> (opt_get1 $Snap.unit G@103@00)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@179@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@180@00)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@180@00)))))
; Joined path conditions
(pop) ; 2
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@180@00 Int)) (!
  (implies
    (and (< i1@180@00 V@104@00) (<= 0 i1@180@00))
    (and
      (< i1@180@00 V@104@00)
      (<= 0 i1@180@00)
      (< i1@180@00 (alen<Int> (opt_get1 $Snap.unit G@103@00)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@179@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@180@00)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@180@00))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@180@00))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(assert (forall ((i1@180@00 Int)) (!
  (implies
    (and (< i1@180@00 V@104@00) (<= 0 i1@180@00))
    (not
      (=
        ($FVF.lookup_option$array$ (sm@179@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@180@00))
        (as None<option<array>>  option<array>))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@180@00))
  :qid |prog.l<no position>|)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$)))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$)))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$))))))
  $Snap.unit))
; [eval] (forall i1: Int :: { alen(opt_get1(aloc(opt_get1(G), i1).option$array$)) } 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(G), i1).option$array$)) == V)
(declare-const i1@181@00 Int)
(push) ; 2
; [eval] 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(G), i1).option$array$)) == V
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 3
; [then-branch: 105 | 0 <= i1@181@00 | live]
; [else-branch: 105 | !(0 <= i1@181@00) | live]
(push) ; 4
; [then-branch: 105 | 0 <= i1@181@00]
(assert (<= 0 i1@181@00))
; [eval] i1 < V
(pop) ; 4
(push) ; 4
; [else-branch: 105 | !(0 <= i1@181@00)]
(assert (not (<= 0 i1@181@00)))
(pop) ; 4
(pop) ; 3
; Joined path conditions
; Joined path conditions
(push) ; 3
; [then-branch: 106 | i1@181@00 < V@104@00 && 0 <= i1@181@00 | live]
; [else-branch: 106 | !(i1@181@00 < V@104@00 && 0 <= i1@181@00) | live]
(push) ; 4
; [then-branch: 106 | i1@181@00 < V@104@00 && 0 <= i1@181@00]
(assert (and (< i1@181@00 V@104@00) (<= 0 i1@181@00)))
; [eval] alen(opt_get1(aloc(opt_get1(G), i1).option$array$)) == V
; [eval] alen(opt_get1(aloc(opt_get1(G), i1).option$array$))
; [eval] opt_get1(aloc(opt_get1(G), i1).option$array$)
; [eval] aloc(opt_get1(G), i1)
; [eval] opt_get1(G)
(push) ; 5
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 5
; Joined path conditions
(push) ; 5
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 6
(assert (not (< i1@181@00 (alen<Int> (opt_get1 $Snap.unit G@103@00)))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1937
;  :arith-add-rows          1451
;  :arith-assert-diseq      195
;  :arith-assert-lower      793
;  :arith-assert-upper      424
;  :arith-bound-prop        125
;  :arith-conflicts         71
;  :arith-eq-adapter        345
;  :arith-fixed-eqs         229
;  :arith-offset-eqs        91
;  :arith-pivots            649
;  :conflicts               140
;  :datatype-accessor-ax    132
;  :datatype-constructor-ax 21
;  :datatype-occurs-check   90
;  :datatype-splits         21
;  :decisions               184
;  :del-clause              2710
;  :final-checks            89
;  :interface-eqs           9
;  :max-generation          6
;  :max-memory              5.25
;  :memory                  5.23
;  :minimized-lits          1
;  :mk-bool-var             4874
;  :mk-clause               2712
;  :num-allocs              247753
;  :num-checks              182
;  :propagations            1094
;  :quant-instantiations    1373
;  :rlimit-count            360410)
(assert (< i1@181@00 (alen<Int> (opt_get1 $Snap.unit G@103@00))))
(pop) ; 5
; Joined path conditions
(assert (< i1@181@00 (alen<Int> (opt_get1 $Snap.unit G@103@00))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@179@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@181@00)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@181@00)))
(push) ; 5
(assert (not (ite
  (and
    (<
      (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@181@00))
      V@104@00)
    (<=
      0
      (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@181@00))))
  (< $Perm.No $k@177@00)
  false)))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1950
;  :arith-add-rows          1454
;  :arith-assert-diseq      195
;  :arith-assert-lower      794
;  :arith-assert-upper      425
;  :arith-bound-prop        128
;  :arith-conflicts         71
;  :arith-eq-adapter        346
;  :arith-fixed-eqs         230
;  :arith-offset-eqs        94
;  :arith-pivots            650
;  :conflicts               141
;  :datatype-accessor-ax    132
;  :datatype-constructor-ax 21
;  :datatype-occurs-check   90
;  :datatype-splits         21
;  :decisions               184
;  :del-clause              2710
;  :final-checks            89
;  :interface-eqs           9
;  :max-generation          6
;  :max-memory              5.25
;  :memory                  5.23
;  :minimized-lits          1
;  :mk-bool-var             4894
;  :mk-clause               2720
;  :num-allocs              248027
;  :num-checks              183
;  :propagations            1098
;  :quant-instantiations    1385
;  :rlimit-count            361081)
(push) ; 5
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 6
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (sm@179@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@181@00))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1950
;  :arith-add-rows          1454
;  :arith-assert-diseq      195
;  :arith-assert-lower      794
;  :arith-assert-upper      425
;  :arith-bound-prop        128
;  :arith-conflicts         71
;  :arith-eq-adapter        346
;  :arith-fixed-eqs         230
;  :arith-offset-eqs        94
;  :arith-pivots            650
;  :conflicts               142
;  :datatype-accessor-ax    132
;  :datatype-constructor-ax 21
;  :datatype-occurs-check   90
;  :datatype-splits         21
;  :decisions               184
;  :del-clause              2710
;  :final-checks            89
;  :interface-eqs           9
;  :max-generation          6
;  :max-memory              5.25
;  :memory                  5.23
;  :minimized-lits          1
;  :mk-bool-var             4894
;  :mk-clause               2720
;  :num-allocs              248122
;  :num-checks              184
;  :propagations            1098
;  :quant-instantiations    1385
;  :rlimit-count            361186)
(assert (not
  (=
    ($FVF.lookup_option$array$ (sm@179@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@181@00))
    (as None<option<array>>  option<array>))))
(pop) ; 5
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (sm@179@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@181@00))
    (as None<option<array>>  option<array>))))
(pop) ; 4
(push) ; 4
; [else-branch: 106 | !(i1@181@00 < V@104@00 && 0 <= i1@181@00)]
(assert (not (and (< i1@181@00 V@104@00) (<= 0 i1@181@00))))
(pop) ; 4
(pop) ; 3
; Joined path conditions
(assert (implies
  (and (< i1@181@00 V@104@00) (<= 0 i1@181@00))
  (and
    (< i1@181@00 V@104@00)
    (<= 0 i1@181@00)
    (< i1@181@00 (alen<Int> (opt_get1 $Snap.unit G@103@00)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@179@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@181@00)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@181@00))
    (not
      (=
        ($FVF.lookup_option$array$ (sm@179@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@181@00))
        (as None<option<array>>  option<array>))))))
; Joined path conditions
(pop) ; 2
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@181@00 Int)) (!
  (implies
    (and (< i1@181@00 V@104@00) (<= 0 i1@181@00))
    (and
      (< i1@181@00 V@104@00)
      (<= 0 i1@181@00)
      (< i1@181@00 (alen<Int> (opt_get1 $Snap.unit G@103@00)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@179@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@181@00)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@181@00))
      (not
        (=
          ($FVF.lookup_option$array$ (sm@179@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@181@00))
          (as None<option<array>>  option<array>)))))
  :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@179@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@181@00)))))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(assert (forall ((i1@181@00 Int)) (!
  (implies
    (and (< i1@181@00 V@104@00) (<= 0 i1@181@00))
    (=
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@179@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@181@00))))
      V@104@00))
  :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@179@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@181@00)))))
  :qid |prog.l<no position>|)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$)))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$)))))))
  $Snap.unit))
; [eval] (forall i1: Int :: { aloc(opt_get1(G), i1) } (forall i2: Int :: { aloc(opt_get1(G), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(G), i1).option$array$ == aloc(opt_get1(G), i2).option$array$ ==> i1 == i2))
(declare-const i1@182@00 Int)
(push) ; 2
; [eval] (forall i2: Int :: { aloc(opt_get1(G), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(G), i1).option$array$ == aloc(opt_get1(G), i2).option$array$ ==> i1 == i2)
(declare-const i2@183@00 Int)
(push) ; 3
; [eval] 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(G), i1).option$array$ == aloc(opt_get1(G), i2).option$array$ ==> i1 == i2
; [eval] 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(G), i1).option$array$ == aloc(opt_get1(G), i2).option$array$
; [eval] 0 <= i1
(push) ; 4
; [then-branch: 107 | 0 <= i1@182@00 | live]
; [else-branch: 107 | !(0 <= i1@182@00) | live]
(push) ; 5
; [then-branch: 107 | 0 <= i1@182@00]
(assert (<= 0 i1@182@00))
; [eval] i1 < V
(push) ; 6
; [then-branch: 108 | i1@182@00 < V@104@00 | live]
; [else-branch: 108 | !(i1@182@00 < V@104@00) | live]
(push) ; 7
; [then-branch: 108 | i1@182@00 < V@104@00]
(assert (< i1@182@00 V@104@00))
; [eval] 0 <= i2
(push) ; 8
; [then-branch: 109 | 0 <= i2@183@00 | live]
; [else-branch: 109 | !(0 <= i2@183@00) | live]
(push) ; 9
; [then-branch: 109 | 0 <= i2@183@00]
(assert (<= 0 i2@183@00))
; [eval] i2 < V
(push) ; 10
; [then-branch: 110 | i2@183@00 < V@104@00 | live]
; [else-branch: 110 | !(i2@183@00 < V@104@00) | live]
(push) ; 11
; [then-branch: 110 | i2@183@00 < V@104@00]
(assert (< i2@183@00 V@104@00))
; [eval] aloc(opt_get1(G), i1).option$array$ == aloc(opt_get1(G), i2).option$array$
; [eval] aloc(opt_get1(G), i1)
; [eval] opt_get1(G)
(push) ; 12
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 12
; Joined path conditions
(push) ; 12
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 13
(assert (not (< i1@182@00 (alen<Int> (opt_get1 $Snap.unit G@103@00)))))
(check-sat)
; unsat
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1957
;  :arith-add-rows          1455
;  :arith-assert-diseq      195
;  :arith-assert-lower      797
;  :arith-assert-upper      428
;  :arith-bound-prop        128
;  :arith-conflicts         71
;  :arith-eq-adapter        347
;  :arith-fixed-eqs         231
;  :arith-offset-eqs        94
;  :arith-pivots            655
;  :conflicts               142
;  :datatype-accessor-ax    133
;  :datatype-constructor-ax 21
;  :datatype-occurs-check   90
;  :datatype-splits         21
;  :decisions               184
;  :del-clause              2718
;  :final-checks            89
;  :interface-eqs           9
;  :max-generation          6
;  :max-memory              5.25
;  :memory                  5.23
;  :minimized-lits          1
;  :mk-bool-var             4904
;  :mk-clause               2720
;  :num-allocs              248929
;  :num-checks              185
;  :propagations            1098
;  :quant-instantiations    1385
;  :rlimit-count            362589)
(assert (< i1@182@00 (alen<Int> (opt_get1 $Snap.unit G@103@00))))
(pop) ; 12
; Joined path conditions
(assert (< i1@182@00 (alen<Int> (opt_get1 $Snap.unit G@103@00))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@179@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@182@00)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@182@00)))
(push) ; 12
(assert (not (ite
  (and
    (<
      (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@182@00))
      V@104@00)
    (<=
      0
      (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@182@00))))
  (< $Perm.No $k@177@00)
  false)))
(check-sat)
; unsat
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1962
;  :arith-add-rows          1460
;  :arith-assert-diseq      195
;  :arith-assert-lower      799
;  :arith-assert-upper      429
;  :arith-bound-prop        129
;  :arith-conflicts         72
;  :arith-eq-adapter        348
;  :arith-fixed-eqs         232
;  :arith-offset-eqs        94
;  :arith-pivots            657
;  :conflicts               143
;  :datatype-accessor-ax    133
;  :datatype-constructor-ax 21
;  :datatype-occurs-check   90
;  :datatype-splits         21
;  :decisions               184
;  :del-clause              2718
;  :final-checks            89
;  :interface-eqs           9
;  :max-generation          6
;  :max-memory              5.25
;  :memory                  5.23
;  :minimized-lits          1
;  :mk-bool-var             4924
;  :mk-clause               2727
;  :num-allocs              249204
;  :num-checks              186
;  :propagations            1098
;  :quant-instantiations    1397
;  :rlimit-count            363300)
; [eval] aloc(opt_get1(G), i2)
; [eval] opt_get1(G)
(push) ; 12
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 12
; Joined path conditions
(push) ; 12
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 13
(assert (not (< i2@183@00 (alen<Int> (opt_get1 $Snap.unit G@103@00)))))
(check-sat)
; unsat
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1962
;  :arith-add-rows          1460
;  :arith-assert-diseq      195
;  :arith-assert-lower      799
;  :arith-assert-upper      429
;  :arith-bound-prop        129
;  :arith-conflicts         72
;  :arith-eq-adapter        348
;  :arith-fixed-eqs         232
;  :arith-offset-eqs        94
;  :arith-pivots            657
;  :conflicts               143
;  :datatype-accessor-ax    133
;  :datatype-constructor-ax 21
;  :datatype-occurs-check   90
;  :datatype-splits         21
;  :decisions               184
;  :del-clause              2718
;  :final-checks            89
;  :interface-eqs           9
;  :max-generation          6
;  :max-memory              5.25
;  :memory                  5.23
;  :minimized-lits          1
;  :mk-bool-var             4924
;  :mk-clause               2727
;  :num-allocs              249236
;  :num-checks              187
;  :propagations            1098
;  :quant-instantiations    1397
;  :rlimit-count            363330)
(assert (< i2@183@00 (alen<Int> (opt_get1 $Snap.unit G@103@00))))
(pop) ; 12
; Joined path conditions
(assert (< i2@183@00 (alen<Int> (opt_get1 $Snap.unit G@103@00))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@179@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@103@00) i2@183@00)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@103@00) i2@183@00)))
(push) ; 12
(assert (not (ite
  (and
    (<
      (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@103@00) i2@183@00))
      V@104@00)
    (<=
      0
      (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@103@00) i2@183@00))))
  (< $Perm.No $k@177@00)
  false)))
(check-sat)
; unsat
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1972
;  :arith-add-rows          1467
;  :arith-assert-diseq      195
;  :arith-assert-lower      800
;  :arith-assert-upper      431
;  :arith-bound-prop        131
;  :arith-conflicts         73
;  :arith-eq-adapter        349
;  :arith-fixed-eqs         233
;  :arith-offset-eqs        97
;  :arith-pivots            659
;  :conflicts               144
;  :datatype-accessor-ax    133
;  :datatype-constructor-ax 21
;  :datatype-occurs-check   90
;  :datatype-splits         21
;  :decisions               184
;  :del-clause              2718
;  :final-checks            89
;  :interface-eqs           9
;  :max-generation          6
;  :max-memory              5.25
;  :memory                  5.23
;  :minimized-lits          1
;  :mk-bool-var             4943
;  :mk-clause               2734
;  :num-allocs              249516
;  :num-checks              188
;  :propagations            1101
;  :quant-instantiations    1408
;  :rlimit-count            364047)
(pop) ; 11
(push) ; 11
; [else-branch: 110 | !(i2@183@00 < V@104@00)]
(assert (not (< i2@183@00 V@104@00)))
(pop) ; 11
(pop) ; 10
; Joined path conditions
(assert (implies
  (< i2@183@00 V@104@00)
  (and
    (< i2@183@00 V@104@00)
    (< i1@182@00 (alen<Int> (opt_get1 $Snap.unit G@103@00)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@179@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@182@00)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@182@00))
    (< i2@183@00 (alen<Int> (opt_get1 $Snap.unit G@103@00)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@179@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@103@00) i2@183@00)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@103@00) i2@183@00)))))
; Joined path conditions
(pop) ; 9
(push) ; 9
; [else-branch: 109 | !(0 <= i2@183@00)]
(assert (not (<= 0 i2@183@00)))
(pop) ; 9
(pop) ; 8
; Joined path conditions
(assert (implies
  (<= 0 i2@183@00)
  (and
    (<= 0 i2@183@00)
    (implies
      (< i2@183@00 V@104@00)
      (and
        (< i2@183@00 V@104@00)
        (< i1@182@00 (alen<Int> (opt_get1 $Snap.unit G@103@00)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@179@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@182@00)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@182@00))
        (< i2@183@00 (alen<Int> (opt_get1 $Snap.unit G@103@00)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@179@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@103@00) i2@183@00)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@103@00) i2@183@00)))))))
; Joined path conditions
(pop) ; 7
(push) ; 7
; [else-branch: 108 | !(i1@182@00 < V@104@00)]
(assert (not (< i1@182@00 V@104@00)))
(pop) ; 7
(pop) ; 6
; Joined path conditions
(assert (implies
  (< i1@182@00 V@104@00)
  (and
    (< i1@182@00 V@104@00)
    (implies
      (<= 0 i2@183@00)
      (and
        (<= 0 i2@183@00)
        (implies
          (< i2@183@00 V@104@00)
          (and
            (< i2@183@00 V@104@00)
            (< i1@182@00 (alen<Int> (opt_get1 $Snap.unit G@103@00)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@179@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@182@00)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@182@00))
            (< i2@183@00 (alen<Int> (opt_get1 $Snap.unit G@103@00)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@179@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@103@00) i2@183@00)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@103@00) i2@183@00)))))))))
; Joined path conditions
(pop) ; 5
(push) ; 5
; [else-branch: 107 | !(0 <= i1@182@00)]
(assert (not (<= 0 i1@182@00)))
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (implies
  (<= 0 i1@182@00)
  (and
    (<= 0 i1@182@00)
    (implies
      (< i1@182@00 V@104@00)
      (and
        (< i1@182@00 V@104@00)
        (implies
          (<= 0 i2@183@00)
          (and
            (<= 0 i2@183@00)
            (implies
              (< i2@183@00 V@104@00)
              (and
                (< i2@183@00 V@104@00)
                (< i1@182@00 (alen<Int> (opt_get1 $Snap.unit G@103@00)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@179@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@182@00)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@182@00))
                (< i2@183@00 (alen<Int> (opt_get1 $Snap.unit G@103@00)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@179@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@103@00) i2@183@00)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@103@00) i2@183@00)))))))))))
; Joined path conditions
(push) ; 4
; [then-branch: 111 | Lookup(option$array$,sm@179@00(s@$, this@102@00, G@103@00, V@104@00, s@105@00, t@106@00),aloc((_, _), opt_get1(_, G@103@00), i1@182@00)) == Lookup(option$array$,sm@179@00(s@$, this@102@00, G@103@00, V@104@00, s@105@00, t@106@00),aloc((_, _), opt_get1(_, G@103@00), i2@183@00)) && i2@183@00 < V@104@00 && 0 <= i2@183@00 && i1@182@00 < V@104@00 && 0 <= i1@182@00 | live]
; [else-branch: 111 | !(Lookup(option$array$,sm@179@00(s@$, this@102@00, G@103@00, V@104@00, s@105@00, t@106@00),aloc((_, _), opt_get1(_, G@103@00), i1@182@00)) == Lookup(option$array$,sm@179@00(s@$, this@102@00, G@103@00, V@104@00, s@105@00, t@106@00),aloc((_, _), opt_get1(_, G@103@00), i2@183@00)) && i2@183@00 < V@104@00 && 0 <= i2@183@00 && i1@182@00 < V@104@00 && 0 <= i1@182@00) | live]
(push) ; 5
; [then-branch: 111 | Lookup(option$array$,sm@179@00(s@$, this@102@00, G@103@00, V@104@00, s@105@00, t@106@00),aloc((_, _), opt_get1(_, G@103@00), i1@182@00)) == Lookup(option$array$,sm@179@00(s@$, this@102@00, G@103@00, V@104@00, s@105@00, t@106@00),aloc((_, _), opt_get1(_, G@103@00), i2@183@00)) && i2@183@00 < V@104@00 && 0 <= i2@183@00 && i1@182@00 < V@104@00 && 0 <= i1@182@00]
(assert (and
  (and
    (and
      (and
        (=
          ($FVF.lookup_option$array$ (sm@179@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@182@00))
          ($FVF.lookup_option$array$ (sm@179@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@103@00) i2@183@00)))
        (< i2@183@00 V@104@00))
      (<= 0 i2@183@00))
    (< i1@182@00 V@104@00))
  (<= 0 i1@182@00)))
; [eval] i1 == i2
(pop) ; 5
(push) ; 5
; [else-branch: 111 | !(Lookup(option$array$,sm@179@00(s@$, this@102@00, G@103@00, V@104@00, s@105@00, t@106@00),aloc((_, _), opt_get1(_, G@103@00), i1@182@00)) == Lookup(option$array$,sm@179@00(s@$, this@102@00, G@103@00, V@104@00, s@105@00, t@106@00),aloc((_, _), opt_get1(_, G@103@00), i2@183@00)) && i2@183@00 < V@104@00 && 0 <= i2@183@00 && i1@182@00 < V@104@00 && 0 <= i1@182@00)]
(assert (not
  (and
    (and
      (and
        (and
          (=
            ($FVF.lookup_option$array$ (sm@179@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@182@00))
            ($FVF.lookup_option$array$ (sm@179@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@103@00) i2@183@00)))
          (< i2@183@00 V@104@00))
        (<= 0 i2@183@00))
      (< i1@182@00 V@104@00))
    (<= 0 i1@182@00))))
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (implies
  (and
    (and
      (and
        (and
          (=
            ($FVF.lookup_option$array$ (sm@179@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@182@00))
            ($FVF.lookup_option$array$ (sm@179@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@103@00) i2@183@00)))
          (< i2@183@00 V@104@00))
        (<= 0 i2@183@00))
      (< i1@182@00 V@104@00))
    (<= 0 i1@182@00))
  (and
    (=
      ($FVF.lookup_option$array$ (sm@179@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@182@00))
      ($FVF.lookup_option$array$ (sm@179@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@103@00) i2@183@00)))
    (< i2@183@00 V@104@00)
    (<= 0 i2@183@00)
    (< i1@182@00 V@104@00)
    (<= 0 i1@182@00))))
; Joined path conditions
(pop) ; 3
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i2@183@00 Int)) (!
  (and
    (implies
      (<= 0 i1@182@00)
      (and
        (<= 0 i1@182@00)
        (implies
          (< i1@182@00 V@104@00)
          (and
            (< i1@182@00 V@104@00)
            (implies
              (<= 0 i2@183@00)
              (and
                (<= 0 i2@183@00)
                (implies
                  (< i2@183@00 V@104@00)
                  (and
                    (< i2@183@00 V@104@00)
                    (< i1@182@00 (alen<Int> (opt_get1 $Snap.unit G@103@00)))
                    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@179@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@182@00)) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@182@00))
                    (< i2@183@00 (alen<Int> (opt_get1 $Snap.unit G@103@00)))
                    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@179@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit G@103@00) i2@183@00)) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit G@103@00) i2@183@00))))))))))
    (implies
      (and
        (and
          (and
            (and
              (=
                ($FVF.lookup_option$array$ (sm@179@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@182@00))
                ($FVF.lookup_option$array$ (sm@179@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@103@00) i2@183@00)))
              (< i2@183@00 V@104@00))
            (<= 0 i2@183@00))
          (< i1@182@00 V@104@00))
        (<= 0 i1@182@00))
      (and
        (=
          ($FVF.lookup_option$array$ (sm@179@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@182@00))
          ($FVF.lookup_option$array$ (sm@179@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@103@00) i2@183@00)))
        (< i2@183@00 V@104@00)
        (<= 0 i2@183@00)
        (< i1@182@00 V@104@00)
        (<= 0 i1@182@00))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@103@00) i2@183@00))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 2
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@182@00 Int)) (!
  (forall ((i2@183@00 Int)) (!
    (and
      (implies
        (<= 0 i1@182@00)
        (and
          (<= 0 i1@182@00)
          (implies
            (< i1@182@00 V@104@00)
            (and
              (< i1@182@00 V@104@00)
              (implies
                (<= 0 i2@183@00)
                (and
                  (<= 0 i2@183@00)
                  (implies
                    (< i2@183@00 V@104@00)
                    (and
                      (< i2@183@00 V@104@00)
                      (< i1@182@00 (alen<Int> (opt_get1 $Snap.unit G@103@00)))
                      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@179@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@182@00)) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@182@00))
                      (< i2@183@00 (alen<Int> (opt_get1 $Snap.unit G@103@00)))
                      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@179@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit G@103@00) i2@183@00)) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit G@103@00) i2@183@00))))))))))
      (implies
        (and
          (and
            (and
              (and
                (=
                  ($FVF.lookup_option$array$ (sm@179@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@182@00))
                  ($FVF.lookup_option$array$ (sm@179@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit G@103@00) i2@183@00)))
                (< i2@183@00 V@104@00))
              (<= 0 i2@183@00))
            (< i1@182@00 V@104@00))
          (<= 0 i1@182@00))
        (and
          (=
            ($FVF.lookup_option$array$ (sm@179@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@182@00))
            ($FVF.lookup_option$array$ (sm@179@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@103@00) i2@183@00)))
          (< i2@183@00 V@104@00)
          (<= 0 i2@183@00)
          (< i1@182@00 V@104@00)
          (<= 0 i1@182@00))))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@103@00) i2@183@00))
    :qid |prog.l<no position>-aux|))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@182@00))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(assert (forall ((i1@182@00 Int)) (!
  (forall ((i2@183@00 Int)) (!
    (implies
      (and
        (and
          (and
            (and
              (=
                ($FVF.lookup_option$array$ (sm@179@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@182@00))
                ($FVF.lookup_option$array$ (sm@179@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@103@00) i2@183@00)))
              (< i2@183@00 V@104@00))
            (<= 0 i2@183@00))
          (< i1@182@00 V@104@00))
        (<= 0 i1@182@00))
      (= i1@182@00 i2@183@00))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@103@00) i2@183@00))
    :qid |prog.l<no position>|))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@182@00))
  :qid |prog.l<no position>|)))
(declare-const i1@184@00 Int)
(declare-const j@185@00 Int)
(push) ; 2
; [eval] 0 <= i1 && i1 < V && (0 <= j && j < V)
; [eval] 0 <= i1
(push) ; 3
; [then-branch: 112 | 0 <= i1@184@00 | live]
; [else-branch: 112 | !(0 <= i1@184@00) | live]
(push) ; 4
; [then-branch: 112 | 0 <= i1@184@00]
(assert (<= 0 i1@184@00))
; [eval] i1 < V
(push) ; 5
; [then-branch: 113 | i1@184@00 < V@104@00 | live]
; [else-branch: 113 | !(i1@184@00 < V@104@00) | live]
(push) ; 6
; [then-branch: 113 | i1@184@00 < V@104@00]
(assert (< i1@184@00 V@104@00))
; [eval] 0 <= j
(push) ; 7
; [then-branch: 114 | 0 <= j@185@00 | live]
; [else-branch: 114 | !(0 <= j@185@00) | live]
(push) ; 8
; [then-branch: 114 | 0 <= j@185@00]
(assert (<= 0 j@185@00))
; [eval] j < V
(pop) ; 8
(push) ; 8
; [else-branch: 114 | !(0 <= j@185@00)]
(assert (not (<= 0 j@185@00)))
(pop) ; 8
(pop) ; 7
; Joined path conditions
; Joined path conditions
(pop) ; 6
(push) ; 6
; [else-branch: 113 | !(i1@184@00 < V@104@00)]
(assert (not (< i1@184@00 V@104@00)))
(pop) ; 6
(pop) ; 5
; Joined path conditions
; Joined path conditions
(pop) ; 4
(push) ; 4
; [else-branch: 112 | !(0 <= i1@184@00)]
(assert (not (<= 0 i1@184@00)))
(pop) ; 4
(pop) ; 3
; Joined path conditions
; Joined path conditions
(assert (and
  (and (and (< j@185@00 V@104@00) (<= 0 j@185@00)) (< i1@184@00 V@104@00))
  (<= 0 i1@184@00)))
; [eval] aloc(opt_get1(aloc(opt_get1(G), i1).option$array$), j)
; [eval] opt_get1(aloc(opt_get1(G), i1).option$array$)
; [eval] aloc(opt_get1(G), i1)
; [eval] opt_get1(G)
(push) ; 3
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 3
; Joined path conditions
(push) ; 3
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 4
(assert (not (< i1@184@00 (alen<Int> (opt_get1 $Snap.unit G@103@00)))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1975
;  :arith-add-rows          1476
;  :arith-assert-diseq      195
;  :arith-assert-lower      806
;  :arith-assert-upper      437
;  :arith-bound-prop        131
;  :arith-conflicts         73
;  :arith-eq-adapter        352
;  :arith-fixed-eqs         236
;  :arith-offset-eqs        97
;  :arith-pivots            671
;  :conflicts               144
;  :datatype-accessor-ax    133
;  :datatype-constructor-ax 21
;  :datatype-occurs-check   90
;  :datatype-splits         21
;  :decisions               184
;  :del-clause              2756
;  :final-checks            89
;  :interface-eqs           9
;  :max-generation          6
;  :max-memory              5.25
;  :memory                  5.23
;  :minimized-lits          1
;  :mk-bool-var             4970
;  :mk-clause               2758
;  :num-allocs              250849
;  :num-checks              189
;  :propagations            1101
;  :quant-instantiations    1408
;  :rlimit-count            366851)
(assert (< i1@184@00 (alen<Int> (opt_get1 $Snap.unit G@103@00))))
(pop) ; 3
; Joined path conditions
(assert (< i1@184@00 (alen<Int> (opt_get1 $Snap.unit G@103@00))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@179@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@184@00)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@184@00)))
(push) ; 3
(assert (not (ite
  (and
    (<
      (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@184@00))
      V@104@00)
    (<=
      0
      (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@184@00))))
  (< $Perm.No $k@177@00)
  false)))
(check-sat)
; unsat
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1979
;  :arith-add-rows          1481
;  :arith-assert-diseq      195
;  :arith-assert-lower      808
;  :arith-assert-upper      438
;  :arith-bound-prop        132
;  :arith-conflicts         74
;  :arith-eq-adapter        353
;  :arith-fixed-eqs         237
;  :arith-offset-eqs        97
;  :arith-pivots            673
;  :conflicts               145
;  :datatype-accessor-ax    133
;  :datatype-constructor-ax 21
;  :datatype-occurs-check   90
;  :datatype-splits         21
;  :decisions               184
;  :del-clause              2756
;  :final-checks            89
;  :interface-eqs           9
;  :max-generation          6
;  :max-memory              5.25
;  :memory                  5.23
;  :minimized-lits          1
;  :mk-bool-var             4998
;  :mk-clause               2765
;  :num-allocs              251187
;  :num-checks              190
;  :propagations            1101
;  :quant-instantiations    1423
;  :rlimit-count            367887)
(push) ; 3
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 4
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (sm@179@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@184@00))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1979
;  :arith-add-rows          1481
;  :arith-assert-diseq      195
;  :arith-assert-lower      808
;  :arith-assert-upper      438
;  :arith-bound-prop        132
;  :arith-conflicts         74
;  :arith-eq-adapter        353
;  :arith-fixed-eqs         237
;  :arith-offset-eqs        97
;  :arith-pivots            673
;  :conflicts               146
;  :datatype-accessor-ax    133
;  :datatype-constructor-ax 21
;  :datatype-occurs-check   90
;  :datatype-splits         21
;  :decisions               184
;  :del-clause              2756
;  :final-checks            89
;  :interface-eqs           9
;  :max-generation          6
;  :max-memory              5.25
;  :memory                  5.23
;  :minimized-lits          1
;  :mk-bool-var             4998
;  :mk-clause               2765
;  :num-allocs              251281
;  :num-checks              191
;  :propagations            1101
;  :quant-instantiations    1423
;  :rlimit-count            367992)
(assert (not
  (=
    ($FVF.lookup_option$array$ (sm@179@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@184@00))
    (as None<option<array>>  option<array>))))
(pop) ; 3
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (sm@179@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@184@00))
    (as None<option<array>>  option<array>))))
(push) ; 3
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 4
(assert (not (<
  j@185@00
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@179@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@184@00)))))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1985
;  :arith-add-rows          1486
;  :arith-assert-diseq      195
;  :arith-assert-lower      811
;  :arith-assert-upper      439
;  :arith-bound-prop        132
;  :arith-conflicts         75
;  :arith-eq-adapter        354
;  :arith-fixed-eqs         238
;  :arith-offset-eqs        97
;  :arith-pivots            677
;  :conflicts               147
;  :datatype-accessor-ax    133
;  :datatype-constructor-ax 21
;  :datatype-occurs-check   90
;  :datatype-splits         21
;  :decisions               184
;  :del-clause              2760
;  :final-checks            89
;  :interface-eqs           9
;  :max-generation          6
;  :max-memory              5.25
;  :memory                  5.24
;  :minimized-lits          1
;  :mk-bool-var             5009
;  :mk-clause               2769
;  :num-allocs              251488
;  :num-checks              192
;  :propagations            1103
;  :quant-instantiations    1430
;  :rlimit-count            368517)
(assert (<
  j@185@00
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@179@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@184@00))))))
(pop) ; 3
; Joined path conditions
(assert (<
  j@185@00
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@179@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@184@00))))))
(declare-const $k@186@00 $Perm)
(assert ($Perm.isReadVar $k@186@00 $Perm.Write))
(pop) ; 2
(declare-fun inv@187@00 ($Snap $Ref option<array> Int Int Int $Ref) Int)
(declare-fun inv@188@00 ($Snap $Ref option<array> Int Int Int $Ref) Int)
; Nested auxiliary terms: globals
(assert ($Perm.isReadVar $k@186@00 $Perm.Write))
; Nested auxiliary terms: non-globals
(assert (forall ((i1@184@00 Int) (j@185@00 Int)) (!
  (and
    (< i1@184@00 (alen<Int> (opt_get1 $Snap.unit G@103@00)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@179@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@184@00)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@184@00))
    (not
      (=
        ($FVF.lookup_option$array$ (sm@179@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@184@00))
        (as None<option<array>>  option<array>)))
    (<
      j@185@00
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@179@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@184@00))))))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@179@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@184@00))) j@185@00))
  :qid |int-aux|)))
(push) ; 2
(assert (not (forall ((i1@184@00 Int) (j@185@00 Int)) (!
  (implies
    (and
      (and (and (< j@185@00 V@104@00) (<= 0 j@185@00)) (< i1@184@00 V@104@00))
      (<= 0 i1@184@00))
    (or (= $k@186@00 $Perm.No) (< $Perm.No $k@186@00)))
  
  ))))
(check-sat)
; unsat
(pop) ; 2
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1985
;  :arith-add-rows          1488
;  :arith-assert-diseq      196
;  :arith-assert-lower      813
;  :arith-assert-upper      440
;  :arith-bound-prop        132
;  :arith-conflicts         75
;  :arith-eq-adapter        355
;  :arith-fixed-eqs         238
;  :arith-offset-eqs        97
;  :arith-pivots            680
;  :conflicts               148
;  :datatype-accessor-ax    133
;  :datatype-constructor-ax 21
;  :datatype-occurs-check   90
;  :datatype-splits         21
;  :decisions               184
;  :del-clause              2767
;  :final-checks            89
;  :interface-eqs           9
;  :max-generation          6
;  :max-memory              5.25
;  :memory                  5.24
;  :minimized-lits          1
;  :mk-bool-var             5018
;  :mk-clause               2771
;  :num-allocs              252072
;  :num-checks              193
;  :propagations            1104
;  :quant-instantiations    1430
;  :rlimit-count            369474)
; Check receiver injectivity
(push) ; 2
(assert (not (forall ((i11@184@00 Int) (j1@185@00 Int) (i12@184@00 Int) (j2@185@00 Int)) (!
  (implies
    (and
      (and
        (and
          (and
            (and (< j1@185@00 V@104@00) (<= 0 j1@185@00))
            (< i11@184@00 V@104@00))
          (<= 0 i11@184@00))
        (< $Perm.No $k@186@00))
      (and
        (and
          (and
            (and (< j2@185@00 V@104@00) (<= 0 j2@185@00))
            (< i12@184@00 V@104@00))
          (<= 0 i12@184@00))
        (< $Perm.No $k@186@00))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@179@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@103@00) i11@184@00))) j1@185@00)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@179@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@103@00) i12@184@00))) j2@185@00)))
    (and (= i11@184@00 i12@184@00) (= j1@185@00 j2@185@00)))
  
  :qid |int-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 2
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               2035
;  :arith-add-rows          1509
;  :arith-assert-diseq      196
;  :arith-assert-lower      825
;  :arith-assert-upper      448
;  :arith-bound-prop        136
;  :arith-conflicts         75
;  :arith-eq-adapter        362
;  :arith-fixed-eqs         242
;  :arith-offset-eqs        101
;  :arith-pivots            694
;  :conflicts               149
;  :datatype-accessor-ax    133
;  :datatype-constructor-ax 21
;  :datatype-occurs-check   90
;  :datatype-splits         21
;  :decisions               184
;  :del-clause              2827
;  :final-checks            89
;  :interface-eqs           9
;  :max-generation          6
;  :max-memory              5.26
;  :memory                  5.25
;  :minimized-lits          1
;  :mk-bool-var             5153
;  :mk-clause               2831
;  :num-allocs              252975
;  :num-checks              194
;  :propagations            1132
;  :quant-instantiations    1488
;  :rlimit-count            372858)
; Definitional axioms for inverse functions
(assert (forall ((i1@184@00 Int) (j@185@00 Int)) (!
  (implies
    (and
      (and
        (and (and (< j@185@00 V@104@00) (<= 0 j@185@00)) (< i1@184@00 V@104@00))
        (<= 0 i1@184@00))
      (< $Perm.No $k@186@00))
    (and
      (=
        (inv@187@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@179@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@184@00))) j@185@00))
        i1@184@00)
      (=
        (inv@188@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@179@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@184@00))) j@185@00))
        j@185@00)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@179@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@184@00))) j@185@00))
  )))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and
          (and
            (<
              (inv@188@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
              V@104@00)
            (<=
              0
              (inv@188@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
          (<
            (inv@187@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
            V@104@00))
        (<= 0 (inv@187@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      (< $Perm.No $k@186@00))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@179@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@103@00) (inv@187@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))) (inv@188@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
      r))
  :pattern ((inv@187@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
  :pattern ((inv@188@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
  :qid |int-fctOfInv|)))
; Permissions are non-negative
(assert (forall ((i1@184@00 Int) (j@185@00 Int)) (!
  (<= $Perm.No $k@186@00)
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@179@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@184@00))) j@185@00))
  :qid |int-permAtLeastZero|)))
; Field permissions are at most one
(assert (forall ((i1@184@00 Int) (j@185@00 Int)) (!
  (<= $k@186@00 $Perm.Write)
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@179@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@184@00))) j@185@00))
  :qid |int-permAtMostOne|)))
; Permission implies non-null receiver
(assert (forall ((i1@184@00 Int) (j@185@00 Int)) (!
  (implies
    (and
      (and
        (and (and (< j@185@00 V@104@00) (<= 0 j@185@00)) (< i1@184@00 V@104@00))
        (<= 0 i1@184@00))
      (< $Perm.No $k@186@00))
    (not
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@179@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@184@00))) j@185@00)
        $Ref.null)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@179@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@184@00))) j@185@00))
  :qid |int-permImpliesNonNull|)))
(declare-fun sm@189@00 ($Snap $Ref option<array> Int Int Int) $FVF<Int>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and
        (and
          (and
            (<
              (inv@188@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
              V@104@00)
            (<=
              0
              (inv@188@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
          (<
            (inv@187@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
            V@104@00))
        (<= 0 (inv@187@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      (< $Perm.No $k@186@00)
      false)
    (=
      ($FVF.lookup_int (sm@189@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$)))))))) r)))
  :pattern (($FVF.lookup_int (sm@189@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$)))))))) r))
  :qid |qp.fvfValDef19|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$)))))))) r) r)
  :pattern (($FVF.lookup_int (sm@189@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :qid |qp.fvfResTrgDef20|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and
          (<
            (inv@188@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
            V@104@00)
          (<=
            0
            (inv@188@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
        (<
          (inv@187@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00))
      (<= 0 (inv@187@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
    ($FVF.loc_int ($FVF.lookup_int (sm@189@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r) r))
  :pattern ((inv@187@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r) (inv@188@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
  )))
(pop) ; 1
(assert (forall ((s@$ $Snap) (this@102@00 $Ref) (G@103@00 option<array>) (V@104@00 Int) (s@105@00 Int) (t@106@00 Int)) (!
  (=
    (FlowNetwork1%limited s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00)
    (FlowNetwork1 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00))
  :pattern ((FlowNetwork1 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00))
  )))
(assert (forall ((s@$ $Snap) (this@102@00 $Ref) (G@103@00 option<array>) (V@104@00 Int) (s@105@00 Int) (t@106@00 Int)) (!
  (FlowNetwork1%stateless this@102@00 G@103@00 V@104@00 s@105@00 t@106@00)
  :pattern ((FlowNetwork1%limited s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00))
  )))
; ----- Verification of function body and postcondition -----
(push) ; 1
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and
          (and
            (<
              (inv@188@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
              V@104@00)
            (<=
              0
              (inv@188@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
          (<
            (inv@187@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
            V@104@00))
        (<= 0 (inv@187@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      (< $Perm.No $k@186@00))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@179@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@103@00) (inv@187@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))) (inv@188@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
      r))
  :pattern ((inv@187@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
  :pattern ((inv@188@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and
        (and
          (and
            (<
              (inv@188@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
              V@104@00)
            (<=
              0
              (inv@188@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
          (<
            (inv@187@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
            V@104@00))
        (<= 0 (inv@187@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      (< $Perm.No $k@186@00)
      false)
    (=
      ($FVF.lookup_int (sm@189@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$)))))))) r)))
  :pattern (($FVF.lookup_int (sm@189@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$)))))))) r))
  :qid |qp.fvfValDef19|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$)))))))) r) r)
  :pattern (($FVF.lookup_int (sm@189@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :qid |qp.fvfResTrgDef20|)))
(assert (forall ((i1@184@00 Int) (j@185@00 Int)) (!
  (implies
    (and
      (and
        (and (and (< j@185@00 V@104@00) (<= 0 j@185@00)) (< i1@184@00 V@104@00))
        (<= 0 i1@184@00))
      (< $Perm.No $k@186@00))
    (and
      (=
        (inv@187@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@179@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@184@00))) j@185@00))
        i1@184@00)
      (=
        (inv@188@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@179@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@184@00))) j@185@00))
        j@185@00)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@179@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@184@00))) j@185@00))
  )))
(assert (forall ((i1@184@00 Int) (j@185@00 Int)) (!
  (<= $Perm.No $k@186@00)
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@179@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@184@00))) j@185@00))
  :qid |int-permAtLeastZero|)))
(assert (forall ((i1@184@00 Int) (j@185@00 Int)) (!
  (<= $k@186@00 $Perm.Write)
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@179@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@184@00))) j@185@00))
  :qid |int-permAtMostOne|)))
(assert (forall ((i1@184@00 Int) (j@185@00 Int)) (!
  (implies
    (and
      (and
        (and (and (< j@185@00 V@104@00) (<= 0 j@185@00)) (< i1@184@00 V@104@00))
        (<= 0 i1@184@00))
      (< $Perm.No $k@186@00))
    (not
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@179@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@184@00))) j@185@00)
        $Ref.null)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@179@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@184@00))) j@185@00))
  :qid |int-permImpliesNonNull|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and
          (<
            (inv@188@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
            V@104@00)
          (<=
            0
            (inv@188@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
        (<
          (inv@187@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00))
      (<= 0 (inv@187@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
    ($FVF.loc_int ($FVF.lookup_int (sm@189@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r) r))
  :pattern ((inv@187@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r) (inv@188@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
  )))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      (< $Perm.No $k@177@00))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@103@00) (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
      r))
  :pattern ((inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
  :qid |option$array$-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      (< $Perm.No $k@177@00)
      false)
    (=
      ($FVF.lookup_option$array$ (sm@179@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r)))
  :pattern (($FVF.lookup_option$array$ (sm@179@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r))
  :qid |qp.fvfValDef17|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r)
  :pattern (($FVF.lookup_option$array$ (sm@179@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :qid |qp.fvfResTrgDef18|)))
(assert ($Perm.isReadVar $k@186@00 $Perm.Write))
(assert (forall ((i1@176@00 Int)) (!
  (implies
    (and (and (< i1@176@00 V@104@00) (<= 0 i1@176@00)) (< $Perm.No $k@177@00))
    (=
      (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@176@00))
      i1@176@00))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@176@00))
  )))
(assert (forall ((i1@176@00 Int)) (!
  (<= $Perm.No $k@177@00)
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@176@00))
  :qid |option$array$-permAtLeastZero|)))
(assert (forall ((i1@176@00 Int)) (!
  (<= $k@177@00 $Perm.Write)
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@176@00))
  :qid |option$array$-permAtMostOne|)))
(assert (forall ((i1@176@00 Int)) (!
  (implies
    (and (and (< i1@176@00 V@104@00) (<= 0 i1@176@00)) (< $Perm.No $k@177@00))
    (not
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@176@00)
        $Ref.null)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@176@00))
  :qid |option$array$-permImpliesNonNull|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (<
        (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
        V@104@00)
      (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@179@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r) r))
  :pattern ((inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
  )))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$)))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$)))))
  $Snap.unit))
(assert (forall ((i1@180@00 Int)) (!
  (implies
    (and (< i1@180@00 V@104@00) (<= 0 i1@180@00))
    (and
      (< i1@180@00 V@104@00)
      (<= 0 i1@180@00)
      (< i1@180@00 (alen<Int> (opt_get1 $Snap.unit G@103@00)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@179@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@180@00)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@180@00))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@180@00))
  :qid |prog.l<no position>-aux|)))
(assert (forall ((i1@180@00 Int)) (!
  (implies
    (and (< i1@180@00 V@104@00) (<= 0 i1@180@00))
    (not
      (=
        ($FVF.lookup_option$array$ (sm@179@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@180@00))
        (as None<option<array>>  option<array>))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@180@00))
  :qid |prog.l<no position>|)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$)))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$)))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$))))))
  $Snap.unit))
(assert (forall ((i1@181@00 Int)) (!
  (implies
    (and (< i1@181@00 V@104@00) (<= 0 i1@181@00))
    (and
      (< i1@181@00 V@104@00)
      (<= 0 i1@181@00)
      (< i1@181@00 (alen<Int> (opt_get1 $Snap.unit G@103@00)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@179@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@181@00)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@181@00))
      (not
        (=
          ($FVF.lookup_option$array$ (sm@179@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@181@00))
          (as None<option<array>>  option<array>)))))
  :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@179@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@181@00)))))
  :qid |prog.l<no position>-aux|)))
(assert (forall ((i1@181@00 Int)) (!
  (implies
    (and (< i1@181@00 V@104@00) (<= 0 i1@181@00))
    (=
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@179@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@181@00))))
      V@104@00))
  :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@179@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@181@00)))))
  :qid |prog.l<no position>|)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$)))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$)))))))
  $Snap.unit))
(assert (forall ((i1@182@00 Int)) (!
  (forall ((i2@183@00 Int)) (!
    (and
      (implies
        (<= 0 i1@182@00)
        (and
          (<= 0 i1@182@00)
          (implies
            (< i1@182@00 V@104@00)
            (and
              (< i1@182@00 V@104@00)
              (implies
                (<= 0 i2@183@00)
                (and
                  (<= 0 i2@183@00)
                  (implies
                    (< i2@183@00 V@104@00)
                    (and
                      (< i2@183@00 V@104@00)
                      (< i1@182@00 (alen<Int> (opt_get1 $Snap.unit G@103@00)))
                      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@179@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@182@00)) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@182@00))
                      (< i2@183@00 (alen<Int> (opt_get1 $Snap.unit G@103@00)))
                      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@179@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit G@103@00) i2@183@00)) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit G@103@00) i2@183@00))))))))))
      (implies
        (and
          (and
            (and
              (and
                (=
                  ($FVF.lookup_option$array$ (sm@179@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@182@00))
                  ($FVF.lookup_option$array$ (sm@179@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit G@103@00) i2@183@00)))
                (< i2@183@00 V@104@00))
              (<= 0 i2@183@00))
            (< i1@182@00 V@104@00))
          (<= 0 i1@182@00))
        (and
          (=
            ($FVF.lookup_option$array$ (sm@179@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@182@00))
            ($FVF.lookup_option$array$ (sm@179@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@103@00) i2@183@00)))
          (< i2@183@00 V@104@00)
          (<= 0 i2@183@00)
          (< i1@182@00 V@104@00)
          (<= 0 i1@182@00))))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@103@00) i2@183@00))
    :qid |prog.l<no position>-aux|))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@182@00))
  :qid |prog.l<no position>-aux|)))
(assert (forall ((i1@182@00 Int)) (!
  (forall ((i2@183@00 Int)) (!
    (implies
      (and
        (and
          (and
            (and
              (=
                ($FVF.lookup_option$array$ (sm@179@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@182@00))
                ($FVF.lookup_option$array$ (sm@179@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@103@00) i2@183@00)))
              (< i2@183@00 V@104@00))
            (<= 0 i2@183@00))
          (< i1@182@00 V@104@00))
        (<= 0 i1@182@00))
      (= i1@182@00 i2@183@00))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@103@00) i2@183@00))
    :qid |prog.l<no position>|))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@182@00))
  :qid |prog.l<no position>|)))
(assert (forall ((i1@184@00 Int) (j@185@00 Int)) (!
  (and
    (< i1@184@00 (alen<Int> (opt_get1 $Snap.unit G@103@00)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@179@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@184@00)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@184@00))
    (not
      (=
        ($FVF.lookup_option$array$ (sm@179@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@184@00))
        (as None<option<array>>  option<array>)))
    (<
      j@185@00
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@179@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@184@00))))))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@179@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@184@00))) j@185@00))
  :qid |int-aux|)))
(assert ($Perm.isReadVar $k@177@00 $Perm.Write))
(assert (= s@$ ($Snap.combine ($Snap.first s@$) ($Snap.second s@$))))
(assert (= ($Snap.first s@$) $Snap.unit))
(assert (not (= this@102@00 $Ref.null)))
(assert (=
  ($Snap.second s@$)
  ($Snap.combine
    ($Snap.first ($Snap.second s@$))
    ($Snap.second ($Snap.second s@$)))))
(assert (= ($Snap.first ($Snap.second s@$)) $Snap.unit))
(assert (not (= G@103@00 (as None<option<array>>  option<array>))))
(assert (=
  ($Snap.second ($Snap.second s@$))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second s@$)))
    ($Snap.second ($Snap.second ($Snap.second s@$))))))
(assert (= ($Snap.first ($Snap.second ($Snap.second s@$))) $Snap.unit))
(assert (= (alen<Int> (opt_get1 $Snap.unit G@103@00)) V@104@00))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second s@$)))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$)))))))
(assert (forall ((i1@176@00 Int)) (!
  (< i1@176@00 (alen<Int> (opt_get1 $Snap.unit G@103@00)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@176@00))
  :qid |option$array$-aux|)))
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
; [eval] 0 <= s && s < V && 0 <= t && t < V && SquareIntMatrix1(this, G, V) && NonNegativeCapacities1(this, G, V)
; [eval] 0 <= s
(push) ; 2
; [then-branch: 115 | 0 <= s@105@00 | live]
; [else-branch: 115 | !(0 <= s@105@00) | live]
(push) ; 3
; [then-branch: 115 | 0 <= s@105@00]
(assert (<= 0 s@105@00))
; [eval] s < V
(push) ; 4
; [then-branch: 116 | s@105@00 < V@104@00 | live]
; [else-branch: 116 | !(s@105@00 < V@104@00) | live]
(push) ; 5
; [then-branch: 116 | s@105@00 < V@104@00]
(assert (< s@105@00 V@104@00))
; [eval] 0 <= t
(push) ; 6
; [then-branch: 117 | 0 <= t@106@00 | live]
; [else-branch: 117 | !(0 <= t@106@00) | live]
(push) ; 7
; [then-branch: 117 | 0 <= t@106@00]
(assert (<= 0 t@106@00))
; [eval] t < V
(push) ; 8
; [then-branch: 118 | t@106@00 < V@104@00 | live]
; [else-branch: 118 | !(t@106@00 < V@104@00) | live]
(push) ; 9
; [then-branch: 118 | t@106@00 < V@104@00]
(assert (< t@106@00 V@104@00))
; [eval] SquareIntMatrix1(this, G, V)
(push) ; 10
; [eval] this != null
; [eval] G != (None(): option[array])
; [eval] (None(): option[array])
; [eval] alen(opt_get1(G)) == V
; [eval] alen(opt_get1(G))
; [eval] opt_get1(G)
(push) ; 11
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 11
; Joined path conditions
(declare-const i1@190@00 Int)
(push) ; 11
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 12
; [then-branch: 119 | 0 <= i1@190@00 | live]
; [else-branch: 119 | !(0 <= i1@190@00) | live]
(push) ; 13
; [then-branch: 119 | 0 <= i1@190@00]
(assert (<= 0 i1@190@00))
; [eval] i1 < V
(pop) ; 13
(push) ; 13
; [else-branch: 119 | !(0 <= i1@190@00)]
(assert (not (<= 0 i1@190@00)))
(pop) ; 13
(pop) ; 12
; Joined path conditions
; Joined path conditions
(assert (and (< i1@190@00 V@104@00) (<= 0 i1@190@00)))
(declare-const $k@191@00 $Perm)
(assert ($Perm.isReadVar $k@191@00 $Perm.Write))
; [eval] aloc(opt_get1(G), i1)
; [eval] opt_get1(G)
(push) ; 12
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 12
; Joined path conditions
(push) ; 12
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 13
(assert (not (< i1@190@00 (alen<Int> (opt_get1 $Snap.unit G@103@00)))))
(check-sat)
; unsat
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               2088
;  :arith-add-rows          1512
;  :arith-assert-diseq      199
;  :arith-assert-lower      837
;  :arith-assert-upper      456
;  :arith-bound-prop        136
;  :arith-conflicts         75
;  :arith-eq-adapter        366
;  :arith-fixed-eqs         243
;  :arith-offset-eqs        101
;  :arith-pivots            696
;  :conflicts               149
;  :datatype-accessor-ax    142
;  :datatype-constructor-ax 23
;  :datatype-occurs-check   93
;  :datatype-splits         23
;  :decisions               186
;  :del-clause              2835
;  :final-checks            91
;  :interface-eqs           9
;  :max-generation          6
;  :max-memory              5.27
;  :memory                  5.26
;  :minimized-lits          1
;  :mk-bool-var             5220
;  :mk-clause               2837
;  :num-allocs              258615
;  :num-checks              196
;  :propagations            1135
;  :quant-instantiations    1493
;  :rlimit-count            384536)
(assert (< i1@190@00 (alen<Int> (opt_get1 $Snap.unit G@103@00))))
(pop) ; 12
; Joined path conditions
(assert (< i1@190@00 (alen<Int> (opt_get1 $Snap.unit G@103@00))))
(pop) ; 11
(declare-fun inv@192@00 ($Snap $Ref option<array> Int Int Int $Ref) Int)
; Nested auxiliary terms: globals
(assert ($Perm.isReadVar $k@191@00 $Perm.Write))
; Nested auxiliary terms: non-globals
(assert (forall ((i1@190@00 Int)) (!
  (< i1@190@00 (alen<Int> (opt_get1 $Snap.unit G@103@00)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@190@00))
  :qid |option$array$-aux|)))
(push) ; 11
(assert (not (forall ((i1@190@00 Int)) (!
  (implies
    (and (< i1@190@00 V@104@00) (<= 0 i1@190@00))
    (or (= $k@191@00 $Perm.No) (< $Perm.No $k@191@00)))
  
  ))))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               2088
;  :arith-add-rows          1513
;  :arith-assert-diseq      200
;  :arith-assert-lower      839
;  :arith-assert-upper      457
;  :arith-bound-prop        136
;  :arith-conflicts         75
;  :arith-eq-adapter        367
;  :arith-fixed-eqs         243
;  :arith-offset-eqs        101
;  :arith-pivots            696
;  :conflicts               150
;  :datatype-accessor-ax    142
;  :datatype-constructor-ax 23
;  :datatype-occurs-check   93
;  :datatype-splits         23
;  :decisions               186
;  :del-clause              2837
;  :final-checks            91
;  :interface-eqs           9
;  :max-generation          6
;  :max-memory              5.27
;  :memory                  5.26
;  :minimized-lits          1
;  :mk-bool-var             5227
;  :mk-clause               2839
;  :num-allocs              259053
;  :num-checks              197
;  :propagations            1136
;  :quant-instantiations    1493
;  :rlimit-count            385082)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 11
(assert (not (forall ((i11@190@00 Int) (i12@190@00 Int)) (!
  (implies
    (and
      (and
        (and
          (and (< i11@190@00 V@104@00) (<= 0 i11@190@00))
          ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@179@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@103@00) i11@190@00)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@103@00) i11@190@00)))
        (< $Perm.No $k@191@00))
      (and
        (and
          (and (< i12@190@00 V@104@00) (<= 0 i12@190@00))
          ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@179@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@103@00) i12@190@00)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@103@00) i12@190@00)))
        (< $Perm.No $k@191@00))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@103@00) i11@190@00)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@103@00) i12@190@00)))
    (= i11@190@00 i12@190@00))
  
  :qid |option$array$-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               2096
;  :arith-add-rows          1520
;  :arith-assert-diseq      201
;  :arith-assert-lower      843
;  :arith-assert-upper      457
;  :arith-bound-prop        136
;  :arith-conflicts         75
;  :arith-eq-adapter        368
;  :arith-fixed-eqs         243
;  :arith-offset-eqs        101
;  :arith-pivots            698
;  :conflicts               151
;  :datatype-accessor-ax    142
;  :datatype-constructor-ax 23
;  :datatype-occurs-check   93
;  :datatype-splits         23
;  :decisions               186
;  :del-clause              2844
;  :final-checks            91
;  :interface-eqs           9
;  :max-generation          6
;  :max-memory              5.27
;  :memory                  5.25
;  :minimized-lits          1
;  :mk-bool-var             5250
;  :mk-clause               2846
;  :num-allocs              259476
;  :num-checks              198
;  :propagations            1136
;  :quant-instantiations    1506
;  :rlimit-count            385973)
; Definitional axioms for inverse functions
(assert (forall ((i1@190@00 Int)) (!
  (implies
    (and (and (< i1@190@00 V@104@00) (<= 0 i1@190@00)) (< $Perm.No $k@191@00))
    (=
      (inv@192@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@190@00))
      i1@190@00))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@190@00))
  :qid |option$array$-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (<
          (inv@192@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@192@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      (< $Perm.No $k@191@00))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@103@00) (inv@192@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
      r))
  :pattern ((inv@192@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
  :qid |option$array$-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (<
        (inv@192@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
        V@104@00)
      (<= 0 (inv@192@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@179@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r) r))
  :pattern ((inv@192@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
  )))
; Precomputing data for removing quantified permissions
(define-fun pTaken@193@00 ((r $Ref) (s@$ $Snap) (this@102@00 $Ref) (G@103@00 option<array>) (V@104@00 Int) (s@105@00 Int) (t@106@00 Int)) $Perm
  (ite
    (and
      (<
        (inv@192@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
        V@104@00)
      (<= 0 (inv@192@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
    ($Perm.min
      (ite
        (and
          (<
            (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
            V@104@00)
          (<=
            0
            (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
        $k@177@00
        $Perm.No)
      $k@191@00)
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Constrain original permissions $k@191@00
(assert (forall ((r $Ref)) (!
  (implies
    (not
      (=
        (ite
          (and
            (<
              (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
              V@104@00)
            (<=
              0
              (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
          $k@177@00
          $Perm.No)
        $Perm.No))
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      (<
        (ite
          (and
            (<
              (inv@192@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
              V@104@00)
            (<=
              0
              (inv@192@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
          $k@191@00
          $Perm.No)
        $k@177@00)
      (<
        (ite
          (and
            (<
              (inv@192@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
              V@104@00)
            (<=
              0
              (inv@192@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
          $k@191@00
          $Perm.No)
        $Perm.No)))
  :pattern ((inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
  :pattern ((inv@192@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
  :qid |qp.srp21|)))
; Intermediate check if already taken enough permissions
(set-option :timeout 500)
(push) ; 11
(assert (not (forall ((r $Ref)) (!
  (implies
    (and
      (<
        (inv@192@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
        V@104@00)
      (<= 0 (inv@192@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
    (=
      (-
        $k@191@00
        (pTaken@193@00 r s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00))
      $Perm.No))
  
  ))))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               2142
;  :arith-add-rows          1542
;  :arith-assert-diseq      209
;  :arith-assert-lower      856
;  :arith-assert-upper      466
;  :arith-bound-prop        138
;  :arith-conflicts         78
;  :arith-eq-adapter        383
;  :arith-fixed-eqs         248
;  :arith-offset-eqs        102
;  :arith-pivots            713
;  :conflicts               157
;  :datatype-accessor-ax    142
;  :datatype-constructor-ax 27
;  :datatype-occurs-check   94
;  :datatype-splits         23
;  :decisions               193
;  :del-clause              2894
;  :final-checks            92
;  :interface-eqs           9
;  :max-generation          6
;  :max-memory              5.28
;  :memory                  5.27
;  :minimized-lits          3
;  :mk-bool-var             5326
;  :mk-clause               2894
;  :num-allocs              261360
;  :num-checks              200
;  :propagations            1157
;  :quant-instantiations    1525
;  :rlimit-count            389679)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-fun sm@194@00 ($Snap $Ref option<array> Int Int Int) $FVF<option<array>>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (iff
    (Set_in r ($FVF.domain_option$array$ (sm@194@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00)))
    (and
      (and
        (<
          (inv@192@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@192@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      (< $Perm.No $k@191@00)))
  :pattern ((Set_in r ($FVF.domain_option$array$ (sm@194@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00))))
  :qid |qp.fvfDomDef24|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and
          (<
            (inv@192@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
            V@104@00)
          (<=
            0
            (inv@192@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
        (< $Perm.No $k@191@00))
      (ite
        (and
          (<
            (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
            V@104@00)
          (<=
            0
            (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
        (< $Perm.No $k@177@00)
        false))
    (=
      ($FVF.lookup_option$array$ (sm@194@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r)))
  :pattern (($FVF.lookup_option$array$ (sm@194@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r))
  :qid |qp.fvfValDef22|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r)
  :pattern (($FVF.lookup_option$array$ (sm@194@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :qid |qp.fvfResTrgDef23|)))
; [eval] (forall i1: Int :: 0 <= i1 && i1 < V ==> aloc(opt_get1(G), i1).option$array$ != (None(): option[array]))
(declare-const i1@195@00 Int)
(push) ; 11
; [eval] 0 <= i1 && i1 < V ==> aloc(opt_get1(G), i1).option$array$ != (None(): option[array])
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 12
; [then-branch: 120 | 0 <= i1@195@00 | live]
; [else-branch: 120 | !(0 <= i1@195@00) | live]
(push) ; 13
; [then-branch: 120 | 0 <= i1@195@00]
(assert (<= 0 i1@195@00))
; [eval] i1 < V
(pop) ; 13
(push) ; 13
; [else-branch: 120 | !(0 <= i1@195@00)]
(assert (not (<= 0 i1@195@00)))
(pop) ; 13
(pop) ; 12
; Joined path conditions
; Joined path conditions
(push) ; 12
; [then-branch: 121 | i1@195@00 < V@104@00 && 0 <= i1@195@00 | live]
; [else-branch: 121 | !(i1@195@00 < V@104@00 && 0 <= i1@195@00) | live]
(push) ; 13
; [then-branch: 121 | i1@195@00 < V@104@00 && 0 <= i1@195@00]
(assert (and (< i1@195@00 V@104@00) (<= 0 i1@195@00)))
; [eval] aloc(opt_get1(G), i1).option$array$ != (None(): option[array])
; [eval] aloc(opt_get1(G), i1)
; [eval] opt_get1(G)
(push) ; 14
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 14
; Joined path conditions
(push) ; 14
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 15
(assert (not (< i1@195@00 (alen<Int> (opt_get1 $Snap.unit G@103@00)))))
(check-sat)
; unsat
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               2142
;  :arith-add-rows          1543
;  :arith-assert-diseq      209
;  :arith-assert-lower      857
;  :arith-assert-upper      467
;  :arith-bound-prop        138
;  :arith-conflicts         78
;  :arith-eq-adapter        383
;  :arith-fixed-eqs         248
;  :arith-offset-eqs        102
;  :arith-pivots            714
;  :conflicts               157
;  :datatype-accessor-ax    142
;  :datatype-constructor-ax 27
;  :datatype-occurs-check   94
;  :datatype-splits         23
;  :decisions               193
;  :del-clause              2894
;  :final-checks            92
;  :interface-eqs           9
;  :max-generation          6
;  :max-memory              5.28
;  :memory                  5.27
;  :minimized-lits          3
;  :mk-bool-var             5331
;  :mk-clause               2894
;  :num-allocs              261990
;  :num-checks              201
;  :propagations            1157
;  :quant-instantiations    1525
;  :rlimit-count            390931)
(assert (< i1@195@00 (alen<Int> (opt_get1 $Snap.unit G@103@00))))
(pop) ; 14
; Joined path conditions
(assert (< i1@195@00 (alen<Int> (opt_get1 $Snap.unit G@103@00))))
(declare-fun sm@196@00 ($Snap $Ref option<array> Int Int Int) $FVF<option<array>>)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      (< $Perm.No $k@177@00)
      false)
    (=
      ($FVF.lookup_option$array$ (sm@196@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r)))
  :pattern (($FVF.lookup_option$array$ (sm@196@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r))
  :qid |qp.fvfValDef25|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r)
  :pattern (($FVF.lookup_option$array$ (sm@196@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :qid |qp.fvfResTrgDef26|)))
(declare-const pm@197@00 $FPM)
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@197@00  $FPM) r)
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      $k@177@00
      $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@197@00  $FPM) r))
  :qid |qp.resPrmSumDef27|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@196@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@197@00  $FPM) r))
  :qid |qp.resTrgDef28|)))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@196@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@195@00)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@195@00)))
(push) ; 14
(assert (not (<
  $Perm.No
  ($FVF.perm_option$array$ (as pm@197@00  $FPM) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@195@00)))))
(check-sat)
; unsat
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               2158
;  :arith-add-rows          1556
;  :arith-assert-diseq      210
;  :arith-assert-lower      860
;  :arith-assert-upper      471
;  :arith-bound-prop        141
;  :arith-conflicts         79
;  :arith-eq-adapter        386
;  :arith-fixed-eqs         251
;  :arith-offset-eqs        103
;  :arith-pivots            717
;  :conflicts               158
;  :datatype-accessor-ax    142
;  :datatype-constructor-ax 27
;  :datatype-occurs-check   94
;  :datatype-splits         23
;  :decisions               193
;  :del-clause              2898
;  :final-checks            92
;  :interface-eqs           9
;  :max-generation          6
;  :max-memory              5.30
;  :memory                  5.29
;  :minimized-lits          3
;  :mk-bool-var             5388
;  :mk-clause               2927
;  :num-allocs              263041
;  :num-checks              202
;  :propagations            1163
;  :quant-instantiations    1549
;  :rlimit-count            393542)
; [eval] (None(): option[array])
(pop) ; 13
(push) ; 13
; [else-branch: 121 | !(i1@195@00 < V@104@00 && 0 <= i1@195@00)]
(assert (not (and (< i1@195@00 V@104@00) (<= 0 i1@195@00))))
(pop) ; 13
(pop) ; 12
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      (< $Perm.No $k@177@00)
      false)
    (=
      ($FVF.lookup_option$array$ (sm@196@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r)))
  :pattern (($FVF.lookup_option$array$ (sm@196@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r))
  :qid |qp.fvfValDef25|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r)
  :pattern (($FVF.lookup_option$array$ (sm@196@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :qid |qp.fvfResTrgDef26|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@197@00  $FPM) r)
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      $k@177@00
      $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@197@00  $FPM) r))
  :qid |qp.resPrmSumDef27|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@196@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@197@00  $FPM) r))
  :qid |qp.resTrgDef28|)))
(assert (implies
  (and (< i1@195@00 V@104@00) (<= 0 i1@195@00))
  (and
    (< i1@195@00 V@104@00)
    (<= 0 i1@195@00)
    (< i1@195@00 (alen<Int> (opt_get1 $Snap.unit G@103@00)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@196@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@195@00)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@195@00)))))
; Joined path conditions
(pop) ; 11
; Nested auxiliary terms: globals (aux)
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      (< $Perm.No $k@177@00)
      false)
    (=
      ($FVF.lookup_option$array$ (sm@196@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r)))
  :pattern (($FVF.lookup_option$array$ (sm@196@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r))
  :qid |qp.fvfValDef25|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r)
  :pattern (($FVF.lookup_option$array$ (sm@196@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :qid |qp.fvfResTrgDef26|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@197@00  $FPM) r)
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      $k@177@00
      $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@197@00  $FPM) r))
  :qid |qp.resPrmSumDef27|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@196@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@197@00  $FPM) r))
  :qid |qp.resTrgDef28|)))
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
; Nested auxiliary terms: non-globals (tlq)
(push) ; 11
(assert (not (forall ((i1@195@00 Int)) (!
  (implies
    (and (< i1@195@00 V@104@00) (<= 0 i1@195@00))
    (not
      (=
        ($FVF.lookup_option$array$ (sm@196@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@195@00))
        (as None<option<array>>  option<array>))))
  
  :qid |prog.l<no position>|))))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               2179
;  :arith-add-rows          1572
;  :arith-assert-diseq      210
;  :arith-assert-lower      864
;  :arith-assert-upper      474
;  :arith-bound-prop        143
;  :arith-conflicts         80
;  :arith-eq-adapter        388
;  :arith-fixed-eqs         253
;  :arith-offset-eqs        103
;  :arith-pivots            726
;  :conflicts               162
;  :datatype-accessor-ax    142
;  :datatype-constructor-ax 29
;  :datatype-occurs-check   94
;  :datatype-splits         23
;  :decisions               196
;  :del-clause              2961
;  :final-checks            92
;  :interface-eqs           9
;  :max-generation          6
;  :max-memory              5.30
;  :memory                  5.29
;  :minimized-lits          3
;  :mk-bool-var             5441
;  :mk-clause               2961
;  :num-allocs              264235
;  :num-checks              203
;  :propagations            1173
;  :quant-instantiations    1571
;  :rlimit-count            396382)
(assert (forall ((i1@195@00 Int)) (!
  (implies
    (and (< i1@195@00 V@104@00) (<= 0 i1@195@00))
    (not
      (=
        ($FVF.lookup_option$array$ (sm@196@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@195@00))
        (as None<option<array>>  option<array>))))
  
  :qid |prog.l<no position>|)))
; [eval] (forall i1: Int :: 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(G), i1).option$array$)) == V)
(declare-const i1@198@00 Int)
(push) ; 11
; [eval] 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(G), i1).option$array$)) == V
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 12
; [then-branch: 122 | 0 <= i1@198@00 | live]
; [else-branch: 122 | !(0 <= i1@198@00) | live]
(push) ; 13
; [then-branch: 122 | 0 <= i1@198@00]
(assert (<= 0 i1@198@00))
; [eval] i1 < V
(pop) ; 13
(push) ; 13
; [else-branch: 122 | !(0 <= i1@198@00)]
(assert (not (<= 0 i1@198@00)))
(pop) ; 13
(pop) ; 12
; Joined path conditions
; Joined path conditions
(push) ; 12
; [then-branch: 123 | i1@198@00 < V@104@00 && 0 <= i1@198@00 | live]
; [else-branch: 123 | !(i1@198@00 < V@104@00 && 0 <= i1@198@00) | live]
(push) ; 13
; [then-branch: 123 | i1@198@00 < V@104@00 && 0 <= i1@198@00]
(assert (and (< i1@198@00 V@104@00) (<= 0 i1@198@00)))
; [eval] alen(opt_get1(aloc(opt_get1(G), i1).option$array$)) == V
; [eval] alen(opt_get1(aloc(opt_get1(G), i1).option$array$))
; [eval] opt_get1(aloc(opt_get1(G), i1).option$array$)
; [eval] aloc(opt_get1(G), i1)
; [eval] opt_get1(G)
(push) ; 14
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 14
; Joined path conditions
(push) ; 14
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 15
(assert (not (< i1@198@00 (alen<Int> (opt_get1 $Snap.unit G@103@00)))))
(check-sat)
; unsat
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               2179
;  :arith-add-rows          1573
;  :arith-assert-diseq      210
;  :arith-assert-lower      866
;  :arith-assert-upper      474
;  :arith-bound-prop        143
;  :arith-conflicts         80
;  :arith-eq-adapter        388
;  :arith-fixed-eqs         253
;  :arith-offset-eqs        103
;  :arith-pivots            727
;  :conflicts               162
;  :datatype-accessor-ax    142
;  :datatype-constructor-ax 29
;  :datatype-occurs-check   94
;  :datatype-splits         23
;  :decisions               196
;  :del-clause              2961
;  :final-checks            92
;  :interface-eqs           9
;  :max-generation          6
;  :max-memory              5.33
;  :memory                  5.32
;  :minimized-lits          3
;  :mk-bool-var             5444
;  :mk-clause               2961
;  :num-allocs              264571
;  :num-checks              204
;  :propagations            1173
;  :quant-instantiations    1571
;  :rlimit-count            396875)
(assert (< i1@198@00 (alen<Int> (opt_get1 $Snap.unit G@103@00))))
(pop) ; 14
; Joined path conditions
(assert (< i1@198@00 (alen<Int> (opt_get1 $Snap.unit G@103@00))))
(declare-fun sm@199@00 ($Snap $Ref option<array> Int Int Int) $FVF<option<array>>)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      (< $Perm.No $k@177@00)
      false)
    (=
      ($FVF.lookup_option$array$ (sm@199@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r)))
  :pattern (($FVF.lookup_option$array$ (sm@199@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r))
  :qid |qp.fvfValDef29|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r)
  :pattern (($FVF.lookup_option$array$ (sm@199@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :qid |qp.fvfResTrgDef30|)))
(declare-const pm@200@00 $FPM)
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@200@00  $FPM) r)
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      $k@177@00
      $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@200@00  $FPM) r))
  :qid |qp.resPrmSumDef31|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@199@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@200@00  $FPM) r))
  :qid |qp.resTrgDef32|)))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@199@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@198@00)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@198@00)))
(push) ; 14
(assert (not (<
  $Perm.No
  ($FVF.perm_option$array$ (as pm@200@00  $FPM) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@198@00)))))
(check-sat)
; unsat
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               2198
;  :arith-add-rows          1586
;  :arith-assert-diseq      211
;  :arith-assert-lower      869
;  :arith-assert-upper      478
;  :arith-bound-prop        146
;  :arith-conflicts         81
;  :arith-eq-adapter        391
;  :arith-fixed-eqs         256
;  :arith-offset-eqs        108
;  :arith-pivots            730
;  :conflicts               163
;  :datatype-accessor-ax    142
;  :datatype-constructor-ax 29
;  :datatype-occurs-check   94
;  :datatype-splits         23
;  :decisions               196
;  :del-clause              2965
;  :final-checks            92
;  :interface-eqs           9
;  :max-generation          6
;  :max-memory              5.34
;  :memory                  5.34
;  :minimized-lits          3
;  :mk-bool-var             5502
;  :mk-clause               2995
;  :num-allocs              265644
;  :num-checks              205
;  :propagations            1179
;  :quant-instantiations    1597
;  :rlimit-count            399549)
(push) ; 14
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 15
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (sm@199@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@198@00))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               2208
;  :arith-add-rows          1586
;  :arith-assert-diseq      211
;  :arith-assert-lower      869
;  :arith-assert-upper      479
;  :arith-bound-prop        146
;  :arith-conflicts         82
;  :arith-eq-adapter        391
;  :arith-fixed-eqs         256
;  :arith-offset-eqs        108
;  :arith-pivots            730
;  :conflicts               167
;  :datatype-accessor-ax    142
;  :datatype-constructor-ax 31
;  :datatype-occurs-check   94
;  :datatype-splits         23
;  :decisions               199
;  :del-clause              2965
;  :final-checks            92
;  :interface-eqs           9
;  :max-generation          6
;  :max-memory              5.34
;  :memory                  5.34
;  :minimized-lits          3
;  :mk-bool-var             5503
;  :mk-clause               2995
;  :num-allocs              265737
;  :num-checks              206
;  :propagations            1186
;  :quant-instantiations    1597
;  :rlimit-count            399715)
(assert (not
  (=
    ($FVF.lookup_option$array$ (sm@199@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@198@00))
    (as None<option<array>>  option<array>))))
(pop) ; 14
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (sm@199@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@198@00))
    (as None<option<array>>  option<array>))))
(pop) ; 13
(push) ; 13
; [else-branch: 123 | !(i1@198@00 < V@104@00 && 0 <= i1@198@00)]
(assert (not (and (< i1@198@00 V@104@00) (<= 0 i1@198@00))))
(pop) ; 13
(pop) ; 12
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      (< $Perm.No $k@177@00)
      false)
    (=
      ($FVF.lookup_option$array$ (sm@199@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r)))
  :pattern (($FVF.lookup_option$array$ (sm@199@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r))
  :qid |qp.fvfValDef29|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r)
  :pattern (($FVF.lookup_option$array$ (sm@199@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :qid |qp.fvfResTrgDef30|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@200@00  $FPM) r)
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      $k@177@00
      $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@200@00  $FPM) r))
  :qid |qp.resPrmSumDef31|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@199@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@200@00  $FPM) r))
  :qid |qp.resTrgDef32|)))
(assert (implies
  (and (< i1@198@00 V@104@00) (<= 0 i1@198@00))
  (and
    (< i1@198@00 V@104@00)
    (<= 0 i1@198@00)
    (< i1@198@00 (alen<Int> (opt_get1 $Snap.unit G@103@00)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@199@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@198@00)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@198@00))
    (not
      (=
        ($FVF.lookup_option$array$ (sm@199@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@198@00))
        (as None<option<array>>  option<array>))))))
; Joined path conditions
(pop) ; 11
; Nested auxiliary terms: globals (aux)
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      (< $Perm.No $k@177@00)
      false)
    (=
      ($FVF.lookup_option$array$ (sm@199@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r)))
  :pattern (($FVF.lookup_option$array$ (sm@199@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r))
  :qid |qp.fvfValDef29|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r)
  :pattern (($FVF.lookup_option$array$ (sm@199@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :qid |qp.fvfResTrgDef30|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@200@00  $FPM) r)
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      $k@177@00
      $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@200@00  $FPM) r))
  :qid |qp.resPrmSumDef31|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@199@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@200@00  $FPM) r))
  :qid |qp.resTrgDef32|)))
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
; Nested auxiliary terms: non-globals (tlq)
(push) ; 11
(assert (not (forall ((i1@198@00 Int)) (!
  (implies
    (and (< i1@198@00 V@104@00) (<= 0 i1@198@00))
    (=
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@199@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@198@00))))
      V@104@00))
  
  :qid |prog.l<no position>|))))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               2243
;  :arith-add-rows          1606
;  :arith-assert-diseq      213
;  :arith-assert-lower      874
;  :arith-assert-upper      482
;  :arith-bound-prop        149
;  :arith-conflicts         83
;  :arith-eq-adapter        394
;  :arith-fixed-eqs         258
;  :arith-offset-eqs        111
;  :arith-pivots            740
;  :conflicts               172
;  :datatype-accessor-ax    142
;  :datatype-constructor-ax 33
;  :datatype-occurs-check   94
;  :datatype-splits         23
;  :decisions               203
;  :del-clause              3035
;  :final-checks            92
;  :interface-eqs           9
;  :max-generation          6
;  :max-memory              5.34
;  :memory                  5.33
;  :minimized-lits          3
;  :mk-bool-var             5567
;  :mk-clause               3035
;  :num-allocs              267003
;  :num-checks              207
;  :propagations            1206
;  :quant-instantiations    1628
;  :rlimit-count            402909)
(assert (forall ((i1@198@00 Int)) (!
  (implies
    (and (< i1@198@00 V@104@00) (<= 0 i1@198@00))
    (=
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@199@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@198@00))))
      V@104@00))
  
  :qid |prog.l<no position>|)))
; [eval] (forall i1: Int :: (forall i2: Int :: { aloc(opt_get1(G), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(G), i1).option$array$ == aloc(opt_get1(G), i2).option$array$ ==> i1 == i2))
(declare-const i1@201@00 Int)
(push) ; 11
; [eval] (forall i2: Int :: { aloc(opt_get1(G), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(G), i1).option$array$ == aloc(opt_get1(G), i2).option$array$ ==> i1 == i2)
(declare-const i2@202@00 Int)
(push) ; 12
; [eval] 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(G), i1).option$array$ == aloc(opt_get1(G), i2).option$array$ ==> i1 == i2
; [eval] 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(G), i1).option$array$ == aloc(opt_get1(G), i2).option$array$
; [eval] 0 <= i1
(push) ; 13
; [then-branch: 124 | 0 <= i1@201@00 | live]
; [else-branch: 124 | !(0 <= i1@201@00) | live]
(push) ; 14
; [then-branch: 124 | 0 <= i1@201@00]
(assert (<= 0 i1@201@00))
; [eval] i1 < V
(push) ; 15
; [then-branch: 125 | i1@201@00 < V@104@00 | live]
; [else-branch: 125 | !(i1@201@00 < V@104@00) | live]
(push) ; 16
; [then-branch: 125 | i1@201@00 < V@104@00]
(assert (< i1@201@00 V@104@00))
; [eval] 0 <= i2
(push) ; 17
; [then-branch: 126 | 0 <= i2@202@00 | live]
; [else-branch: 126 | !(0 <= i2@202@00) | live]
(push) ; 18
; [then-branch: 126 | 0 <= i2@202@00]
(assert (<= 0 i2@202@00))
; [eval] i2 < V
(push) ; 19
; [then-branch: 127 | i2@202@00 < V@104@00 | live]
; [else-branch: 127 | !(i2@202@00 < V@104@00) | live]
(push) ; 20
; [then-branch: 127 | i2@202@00 < V@104@00]
(assert (< i2@202@00 V@104@00))
; [eval] aloc(opt_get1(G), i1).option$array$ == aloc(opt_get1(G), i2).option$array$
; [eval] aloc(opt_get1(G), i1)
; [eval] opt_get1(G)
(push) ; 21
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 21
; Joined path conditions
(push) ; 21
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 22
(assert (not (< i1@201@00 (alen<Int> (opt_get1 $Snap.unit G@103@00)))))
(check-sat)
; unsat
(pop) ; 22
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               2243
;  :arith-add-rows          1608
;  :arith-assert-diseq      213
;  :arith-assert-lower      877
;  :arith-assert-upper      483
;  :arith-bound-prop        149
;  :arith-conflicts         83
;  :arith-eq-adapter        394
;  :arith-fixed-eqs         258
;  :arith-offset-eqs        111
;  :arith-pivots            741
;  :conflicts               172
;  :datatype-accessor-ax    142
;  :datatype-constructor-ax 33
;  :datatype-occurs-check   94
;  :datatype-splits         23
;  :decisions               203
;  :del-clause              3035
;  :final-checks            92
;  :interface-eqs           9
;  :max-generation          6
;  :max-memory              5.34
;  :memory                  5.34
;  :minimized-lits          3
;  :mk-bool-var             5572
;  :mk-clause               3035
;  :num-allocs              267599
;  :num-checks              208
;  :propagations            1206
;  :quant-instantiations    1628
;  :rlimit-count            403558)
(assert (< i1@201@00 (alen<Int> (opt_get1 $Snap.unit G@103@00))))
(pop) ; 21
; Joined path conditions
(assert (< i1@201@00 (alen<Int> (opt_get1 $Snap.unit G@103@00))))
(declare-fun sm@203@00 ($Snap $Ref option<array> Int Int Int) $FVF<option<array>>)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      (< $Perm.No $k@177@00)
      false)
    (=
      ($FVF.lookup_option$array$ (sm@203@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r)))
  :pattern (($FVF.lookup_option$array$ (sm@203@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r))
  :qid |qp.fvfValDef33|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r)
  :pattern (($FVF.lookup_option$array$ (sm@203@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :qid |qp.fvfResTrgDef34|)))
(declare-const pm@204@00 $FPM)
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@204@00  $FPM) r)
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      $k@177@00
      $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@204@00  $FPM) r))
  :qid |qp.resPrmSumDef35|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@203@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@204@00  $FPM) r))
  :qid |qp.resTrgDef36|)))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@203@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@201@00)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@201@00)))
(push) ; 21
(assert (not (<
  $Perm.No
  ($FVF.perm_option$array$ (as pm@204@00  $FPM) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@201@00)))))
(check-sat)
; unsat
(pop) ; 21
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               2265
;  :arith-add-rows          1622
;  :arith-assert-diseq      214
;  :arith-assert-lower      882
;  :arith-assert-upper      488
;  :arith-bound-prop        152
;  :arith-conflicts         84
;  :arith-eq-adapter        398
;  :arith-fixed-eqs         262
;  :arith-offset-eqs        114
;  :arith-pivots            745
;  :conflicts               173
;  :datatype-accessor-ax    142
;  :datatype-constructor-ax 33
;  :datatype-occurs-check   94
;  :datatype-splits         23
;  :decisions               203
;  :del-clause              3039
;  :final-checks            92
;  :interface-eqs           9
;  :max-generation          6
;  :max-memory              5.36
;  :memory                  5.35
;  :minimized-lits          3
;  :mk-bool-var             5642
;  :mk-clause               3072
;  :num-allocs              268716
;  :num-checks              209
;  :propagations            1212
;  :quant-instantiations    1661
;  :rlimit-count            406376)
; [eval] aloc(opt_get1(G), i2)
; [eval] opt_get1(G)
(push) ; 21
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 21
; Joined path conditions
(push) ; 21
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 22
(assert (not (< i2@202@00 (alen<Int> (opt_get1 $Snap.unit G@103@00)))))
(check-sat)
; unsat
(pop) ; 22
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               2265
;  :arith-add-rows          1622
;  :arith-assert-diseq      214
;  :arith-assert-lower      882
;  :arith-assert-upper      488
;  :arith-bound-prop        152
;  :arith-conflicts         84
;  :arith-eq-adapter        398
;  :arith-fixed-eqs         262
;  :arith-offset-eqs        114
;  :arith-pivots            745
;  :conflicts               173
;  :datatype-accessor-ax    142
;  :datatype-constructor-ax 33
;  :datatype-occurs-check   94
;  :datatype-splits         23
;  :decisions               203
;  :del-clause              3039
;  :final-checks            92
;  :interface-eqs           9
;  :max-generation          6
;  :max-memory              5.36
;  :memory                  5.35
;  :minimized-lits          3
;  :mk-bool-var             5642
;  :mk-clause               3072
;  :num-allocs              268742
;  :num-checks              210
;  :propagations            1212
;  :quant-instantiations    1661
;  :rlimit-count            406406)
(assert (< i2@202@00 (alen<Int> (opt_get1 $Snap.unit G@103@00))))
(pop) ; 21
; Joined path conditions
(assert (< i2@202@00 (alen<Int> (opt_get1 $Snap.unit G@103@00))))
(declare-fun sm@205@00 ($Snap $Ref option<array> Int Int Int) $FVF<option<array>>)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      (< $Perm.No $k@177@00)
      false)
    (=
      ($FVF.lookup_option$array$ (sm@205@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r)))
  :pattern (($FVF.lookup_option$array$ (sm@205@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r))
  :qid |qp.fvfValDef37|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r)
  :pattern (($FVF.lookup_option$array$ (sm@205@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :qid |qp.fvfResTrgDef38|)))
(declare-const pm@206@00 $FPM)
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@206@00  $FPM) r)
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      $k@177@00
      $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@206@00  $FPM) r))
  :qid |qp.resPrmSumDef39|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@205@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@206@00  $FPM) r))
  :qid |qp.resTrgDef40|)))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@205@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@103@00) i2@202@00)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@103@00) i2@202@00)))
(push) ; 21
(assert (not (<
  $Perm.No
  ($FVF.perm_option$array$ (as pm@206@00  $FPM) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@103@00) i2@202@00)))))
(check-sat)
; unsat
(pop) ; 21
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               2280
;  :arith-add-rows          1635
;  :arith-assert-diseq      215
;  :arith-assert-lower      888
;  :arith-assert-upper      492
;  :arith-bound-prop        154
;  :arith-conflicts         85
;  :arith-eq-adapter        403
;  :arith-fixed-eqs         266
;  :arith-offset-eqs        114
;  :arith-pivots            749
;  :conflicts               174
;  :datatype-accessor-ax    142
;  :datatype-constructor-ax 33
;  :datatype-occurs-check   94
;  :datatype-splits         23
;  :decisions               203
;  :del-clause              3043
;  :final-checks            92
;  :interface-eqs           9
;  :max-generation          6
;  :max-memory              5.38
;  :memory                  5.38
;  :minimized-lits          3
;  :mk-bool-var             5730
;  :mk-clause               3131
;  :num-allocs              269931
;  :num-checks              211
;  :propagations            1221
;  :quant-instantiations    1699
;  :rlimit-count            409493)
(pop) ; 20
(push) ; 20
; [else-branch: 127 | !(i2@202@00 < V@104@00)]
(assert (not (< i2@202@00 V@104@00)))
(pop) ; 20
(pop) ; 19
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      (< $Perm.No $k@177@00)
      false)
    (=
      ($FVF.lookup_option$array$ (sm@203@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r)))
  :pattern (($FVF.lookup_option$array$ (sm@203@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r))
  :qid |qp.fvfValDef33|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r)
  :pattern (($FVF.lookup_option$array$ (sm@203@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :qid |qp.fvfResTrgDef34|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@204@00  $FPM) r)
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      $k@177@00
      $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@204@00  $FPM) r))
  :qid |qp.resPrmSumDef35|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@203@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@204@00  $FPM) r))
  :qid |qp.resTrgDef36|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      (< $Perm.No $k@177@00)
      false)
    (=
      ($FVF.lookup_option$array$ (sm@205@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r)))
  :pattern (($FVF.lookup_option$array$ (sm@205@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r))
  :qid |qp.fvfValDef37|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r)
  :pattern (($FVF.lookup_option$array$ (sm@205@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :qid |qp.fvfResTrgDef38|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@206@00  $FPM) r)
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      $k@177@00
      $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@206@00  $FPM) r))
  :qid |qp.resPrmSumDef39|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@205@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@206@00  $FPM) r))
  :qid |qp.resTrgDef40|)))
(assert (implies
  (< i2@202@00 V@104@00)
  (and
    (< i2@202@00 V@104@00)
    (< i1@201@00 (alen<Int> (opt_get1 $Snap.unit G@103@00)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@203@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@201@00)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@201@00))
    (< i2@202@00 (alen<Int> (opt_get1 $Snap.unit G@103@00)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@205@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@103@00) i2@202@00)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@103@00) i2@202@00)))))
; Joined path conditions
(pop) ; 18
(push) ; 18
; [else-branch: 126 | !(0 <= i2@202@00)]
(assert (not (<= 0 i2@202@00)))
(pop) ; 18
(pop) ; 17
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      (< $Perm.No $k@177@00)
      false)
    (=
      ($FVF.lookup_option$array$ (sm@203@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r)))
  :pattern (($FVF.lookup_option$array$ (sm@203@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r))
  :qid |qp.fvfValDef33|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r)
  :pattern (($FVF.lookup_option$array$ (sm@203@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :qid |qp.fvfResTrgDef34|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@204@00  $FPM) r)
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      $k@177@00
      $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@204@00  $FPM) r))
  :qid |qp.resPrmSumDef35|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@203@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@204@00  $FPM) r))
  :qid |qp.resTrgDef36|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      (< $Perm.No $k@177@00)
      false)
    (=
      ($FVF.lookup_option$array$ (sm@205@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r)))
  :pattern (($FVF.lookup_option$array$ (sm@205@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r))
  :qid |qp.fvfValDef37|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r)
  :pattern (($FVF.lookup_option$array$ (sm@205@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :qid |qp.fvfResTrgDef38|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@206@00  $FPM) r)
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      $k@177@00
      $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@206@00  $FPM) r))
  :qid |qp.resPrmSumDef39|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@205@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@206@00  $FPM) r))
  :qid |qp.resTrgDef40|)))
(assert (implies
  (<= 0 i2@202@00)
  (and
    (<= 0 i2@202@00)
    (implies
      (< i2@202@00 V@104@00)
      (and
        (< i2@202@00 V@104@00)
        (< i1@201@00 (alen<Int> (opt_get1 $Snap.unit G@103@00)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@203@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@201@00)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@201@00))
        (< i2@202@00 (alen<Int> (opt_get1 $Snap.unit G@103@00)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@205@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@103@00) i2@202@00)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@103@00) i2@202@00)))))))
; Joined path conditions
(pop) ; 16
(push) ; 16
; [else-branch: 125 | !(i1@201@00 < V@104@00)]
(assert (not (< i1@201@00 V@104@00)))
(pop) ; 16
(pop) ; 15
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      (< $Perm.No $k@177@00)
      false)
    (=
      ($FVF.lookup_option$array$ (sm@203@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r)))
  :pattern (($FVF.lookup_option$array$ (sm@203@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r))
  :qid |qp.fvfValDef33|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r)
  :pattern (($FVF.lookup_option$array$ (sm@203@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :qid |qp.fvfResTrgDef34|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@204@00  $FPM) r)
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      $k@177@00
      $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@204@00  $FPM) r))
  :qid |qp.resPrmSumDef35|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@203@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@204@00  $FPM) r))
  :qid |qp.resTrgDef36|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      (< $Perm.No $k@177@00)
      false)
    (=
      ($FVF.lookup_option$array$ (sm@205@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r)))
  :pattern (($FVF.lookup_option$array$ (sm@205@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r))
  :qid |qp.fvfValDef37|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r)
  :pattern (($FVF.lookup_option$array$ (sm@205@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :qid |qp.fvfResTrgDef38|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@206@00  $FPM) r)
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      $k@177@00
      $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@206@00  $FPM) r))
  :qid |qp.resPrmSumDef39|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@205@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@206@00  $FPM) r))
  :qid |qp.resTrgDef40|)))
(assert (implies
  (< i1@201@00 V@104@00)
  (and
    (< i1@201@00 V@104@00)
    (implies
      (<= 0 i2@202@00)
      (and
        (<= 0 i2@202@00)
        (implies
          (< i2@202@00 V@104@00)
          (and
            (< i2@202@00 V@104@00)
            (< i1@201@00 (alen<Int> (opt_get1 $Snap.unit G@103@00)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@203@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@201@00)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@201@00))
            (< i2@202@00 (alen<Int> (opt_get1 $Snap.unit G@103@00)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@205@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@103@00) i2@202@00)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@103@00) i2@202@00)))))))))
; Joined path conditions
(pop) ; 14
(push) ; 14
; [else-branch: 124 | !(0 <= i1@201@00)]
(assert (not (<= 0 i1@201@00)))
(pop) ; 14
(pop) ; 13
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      (< $Perm.No $k@177@00)
      false)
    (=
      ($FVF.lookup_option$array$ (sm@203@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r)))
  :pattern (($FVF.lookup_option$array$ (sm@203@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r))
  :qid |qp.fvfValDef33|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r)
  :pattern (($FVF.lookup_option$array$ (sm@203@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :qid |qp.fvfResTrgDef34|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@204@00  $FPM) r)
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      $k@177@00
      $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@204@00  $FPM) r))
  :qid |qp.resPrmSumDef35|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@203@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@204@00  $FPM) r))
  :qid |qp.resTrgDef36|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      (< $Perm.No $k@177@00)
      false)
    (=
      ($FVF.lookup_option$array$ (sm@205@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r)))
  :pattern (($FVF.lookup_option$array$ (sm@205@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r))
  :qid |qp.fvfValDef37|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r)
  :pattern (($FVF.lookup_option$array$ (sm@205@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :qid |qp.fvfResTrgDef38|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@206@00  $FPM) r)
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      $k@177@00
      $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@206@00  $FPM) r))
  :qid |qp.resPrmSumDef39|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@205@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@206@00  $FPM) r))
  :qid |qp.resTrgDef40|)))
(assert (implies
  (<= 0 i1@201@00)
  (and
    (<= 0 i1@201@00)
    (implies
      (< i1@201@00 V@104@00)
      (and
        (< i1@201@00 V@104@00)
        (implies
          (<= 0 i2@202@00)
          (and
            (<= 0 i2@202@00)
            (implies
              (< i2@202@00 V@104@00)
              (and
                (< i2@202@00 V@104@00)
                (< i1@201@00 (alen<Int> (opt_get1 $Snap.unit G@103@00)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@203@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@201@00)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@201@00))
                (< i2@202@00 (alen<Int> (opt_get1 $Snap.unit G@103@00)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@205@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@103@00) i2@202@00)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@103@00) i2@202@00)))))))))))
; Joined path conditions
(push) ; 13
; [then-branch: 128 | Lookup(option$array$,sm@203@00(s@$, this@102@00, G@103@00, V@104@00, s@105@00, t@106@00),aloc((_, _), opt_get1(_, G@103@00), i1@201@00)) == Lookup(option$array$,sm@205@00(s@$, this@102@00, G@103@00, V@104@00, s@105@00, t@106@00),aloc((_, _), opt_get1(_, G@103@00), i2@202@00)) && i2@202@00 < V@104@00 && 0 <= i2@202@00 && i1@201@00 < V@104@00 && 0 <= i1@201@00 | live]
; [else-branch: 128 | !(Lookup(option$array$,sm@203@00(s@$, this@102@00, G@103@00, V@104@00, s@105@00, t@106@00),aloc((_, _), opt_get1(_, G@103@00), i1@201@00)) == Lookup(option$array$,sm@205@00(s@$, this@102@00, G@103@00, V@104@00, s@105@00, t@106@00),aloc((_, _), opt_get1(_, G@103@00), i2@202@00)) && i2@202@00 < V@104@00 && 0 <= i2@202@00 && i1@201@00 < V@104@00 && 0 <= i1@201@00) | live]
(push) ; 14
; [then-branch: 128 | Lookup(option$array$,sm@203@00(s@$, this@102@00, G@103@00, V@104@00, s@105@00, t@106@00),aloc((_, _), opt_get1(_, G@103@00), i1@201@00)) == Lookup(option$array$,sm@205@00(s@$, this@102@00, G@103@00, V@104@00, s@105@00, t@106@00),aloc((_, _), opt_get1(_, G@103@00), i2@202@00)) && i2@202@00 < V@104@00 && 0 <= i2@202@00 && i1@201@00 < V@104@00 && 0 <= i1@201@00]
(assert (and
  (and
    (and
      (and
        (=
          ($FVF.lookup_option$array$ (sm@203@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@201@00))
          ($FVF.lookup_option$array$ (sm@205@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@103@00) i2@202@00)))
        (< i2@202@00 V@104@00))
      (<= 0 i2@202@00))
    (< i1@201@00 V@104@00))
  (<= 0 i1@201@00)))
; [eval] i1 == i2
(pop) ; 14
(push) ; 14
; [else-branch: 128 | !(Lookup(option$array$,sm@203@00(s@$, this@102@00, G@103@00, V@104@00, s@105@00, t@106@00),aloc((_, _), opt_get1(_, G@103@00), i1@201@00)) == Lookup(option$array$,sm@205@00(s@$, this@102@00, G@103@00, V@104@00, s@105@00, t@106@00),aloc((_, _), opt_get1(_, G@103@00), i2@202@00)) && i2@202@00 < V@104@00 && 0 <= i2@202@00 && i1@201@00 < V@104@00 && 0 <= i1@201@00)]
(assert (not
  (and
    (and
      (and
        (and
          (=
            ($FVF.lookup_option$array$ (sm@203@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@201@00))
            ($FVF.lookup_option$array$ (sm@205@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@103@00) i2@202@00)))
          (< i2@202@00 V@104@00))
        (<= 0 i2@202@00))
      (< i1@201@00 V@104@00))
    (<= 0 i1@201@00))))
(pop) ; 14
(pop) ; 13
; Joined path conditions
(assert (implies
  (and
    (and
      (and
        (and
          (=
            ($FVF.lookup_option$array$ (sm@203@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@201@00))
            ($FVF.lookup_option$array$ (sm@205@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@103@00) i2@202@00)))
          (< i2@202@00 V@104@00))
        (<= 0 i2@202@00))
      (< i1@201@00 V@104@00))
    (<= 0 i1@201@00))
  (and
    (=
      ($FVF.lookup_option$array$ (sm@203@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@201@00))
      ($FVF.lookup_option$array$ (sm@205@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@103@00) i2@202@00)))
    (< i2@202@00 V@104@00)
    (<= 0 i2@202@00)
    (< i1@201@00 V@104@00)
    (<= 0 i1@201@00))))
; Joined path conditions
(pop) ; 12
; Nested auxiliary terms: globals (aux)
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      (< $Perm.No $k@177@00)
      false)
    (=
      ($FVF.lookup_option$array$ (sm@203@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r)))
  :pattern (($FVF.lookup_option$array$ (sm@203@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r))
  :qid |qp.fvfValDef33|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r)
  :pattern (($FVF.lookup_option$array$ (sm@203@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :qid |qp.fvfResTrgDef34|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@204@00  $FPM) r)
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      $k@177@00
      $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@204@00  $FPM) r))
  :qid |qp.resPrmSumDef35|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@203@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@204@00  $FPM) r))
  :qid |qp.resTrgDef36|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      (< $Perm.No $k@177@00)
      false)
    (=
      ($FVF.lookup_option$array$ (sm@205@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r)))
  :pattern (($FVF.lookup_option$array$ (sm@205@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r))
  :qid |qp.fvfValDef37|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r)
  :pattern (($FVF.lookup_option$array$ (sm@205@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :qid |qp.fvfResTrgDef38|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@206@00  $FPM) r)
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      $k@177@00
      $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@206@00  $FPM) r))
  :qid |qp.resPrmSumDef39|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@205@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@206@00  $FPM) r))
  :qid |qp.resTrgDef40|)))
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i2@202@00 Int)) (!
  (and
    (implies
      (<= 0 i1@201@00)
      (and
        (<= 0 i1@201@00)
        (implies
          (< i1@201@00 V@104@00)
          (and
            (< i1@201@00 V@104@00)
            (implies
              (<= 0 i2@202@00)
              (and
                (<= 0 i2@202@00)
                (implies
                  (< i2@202@00 V@104@00)
                  (and
                    (< i2@202@00 V@104@00)
                    (< i1@201@00 (alen<Int> (opt_get1 $Snap.unit G@103@00)))
                    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@203@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@201@00)) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@201@00))
                    (< i2@202@00 (alen<Int> (opt_get1 $Snap.unit G@103@00)))
                    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@205@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit G@103@00) i2@202@00)) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit G@103@00) i2@202@00))))))))))
    (implies
      (and
        (and
          (and
            (and
              (=
                ($FVF.lookup_option$array$ (sm@203@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@201@00))
                ($FVF.lookup_option$array$ (sm@205@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@103@00) i2@202@00)))
              (< i2@202@00 V@104@00))
            (<= 0 i2@202@00))
          (< i1@201@00 V@104@00))
        (<= 0 i1@201@00))
      (and
        (=
          ($FVF.lookup_option$array$ (sm@203@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@201@00))
          ($FVF.lookup_option$array$ (sm@205@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@103@00) i2@202@00)))
        (< i2@202@00 V@104@00)
        (<= 0 i2@202@00)
        (< i1@201@00 V@104@00)
        (<= 0 i1@201@00))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@103@00) i2@202@00))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 11
; Nested auxiliary terms: globals (aux)
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      (< $Perm.No $k@177@00)
      false)
    (=
      ($FVF.lookup_option$array$ (sm@203@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r)))
  :pattern (($FVF.lookup_option$array$ (sm@203@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r))
  :qid |qp.fvfValDef33|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r)
  :pattern (($FVF.lookup_option$array$ (sm@203@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :qid |qp.fvfResTrgDef34|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@204@00  $FPM) r)
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      $k@177@00
      $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@204@00  $FPM) r))
  :qid |qp.resPrmSumDef35|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@203@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@204@00  $FPM) r))
  :qid |qp.resTrgDef36|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      (< $Perm.No $k@177@00)
      false)
    (=
      ($FVF.lookup_option$array$ (sm@205@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r)))
  :pattern (($FVF.lookup_option$array$ (sm@205@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r))
  :qid |qp.fvfValDef37|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r)
  :pattern (($FVF.lookup_option$array$ (sm@205@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :qid |qp.fvfResTrgDef38|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@206@00  $FPM) r)
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      $k@177@00
      $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@206@00  $FPM) r))
  :qid |qp.resPrmSumDef39|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@205@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@206@00  $FPM) r))
  :qid |qp.resTrgDef40|)))
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
; Nested auxiliary terms: non-globals (tlq)
(push) ; 11
(assert (not (forall ((i1@201@00 Int)) (!
  (forall ((i2@202@00 Int)) (!
    (implies
      (and
        (and
          (and
            (and
              (=
                ($FVF.lookup_option$array$ (sm@203@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@201@00))
                ($FVF.lookup_option$array$ (sm@205@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@103@00) i2@202@00)))
              (< i2@202@00 V@104@00))
            (<= 0 i2@202@00))
          (< i1@201@00 V@104@00))
        (<= 0 i1@201@00))
      (= i1@201@00 i2@202@00))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@103@00) i2@202@00))
    :qid |prog.l<no position>|))
  
  :qid |prog.l<no position>|))))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               2332
;  :arith-add-rows          1679
;  :arith-assert-diseq      217
;  :arith-assert-lower      904
;  :arith-assert-upper      499
;  :arith-bound-prop        160
;  :arith-conflicts         87
;  :arith-eq-adapter        410
;  :arith-fixed-eqs         272
;  :arith-offset-eqs        117
;  :arith-pivots            774
;  :conflicts               180
;  :datatype-accessor-ax    142
;  :datatype-constructor-ax 35
;  :datatype-occurs-check   94
;  :datatype-splits         23
;  :decisions               208
;  :del-clause              3238
;  :final-checks            92
;  :interface-eqs           9
;  :max-generation          6
;  :max-memory              5.38
;  :memory                  5.37
;  :minimized-lits          3
;  :mk-bool-var             5899
;  :mk-clause               3238
;  :num-allocs              274531
;  :num-checks              212
;  :propagations            1254
;  :quant-instantiations    1766
;  :rlimit-count            419817
;  :time                    0.00)
(assert (forall ((i1@201@00 Int)) (!
  (forall ((i2@202@00 Int)) (!
    (implies
      (and
        (and
          (and
            (and
              (=
                ($FVF.lookup_option$array$ (sm@203@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@201@00))
                ($FVF.lookup_option$array$ (sm@205@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@103@00) i2@202@00)))
              (< i2@202@00 V@104@00))
            (<= 0 i2@202@00))
          (< i1@201@00 V@104@00))
        (<= 0 i1@201@00))
      (= i1@201@00 i2@202@00))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@103@00) i2@202@00))
    :qid |prog.l<no position>|))
  
  :qid |prog.l<no position>|)))
(declare-const i1@207@00 Int)
(declare-const j@208@00 Int)
(push) ; 11
; [eval] 0 <= i1 && i1 < V && (0 <= j && j < V)
; [eval] 0 <= i1
(push) ; 12
; [then-branch: 129 | 0 <= i1@207@00 | live]
; [else-branch: 129 | !(0 <= i1@207@00) | live]
(push) ; 13
; [then-branch: 129 | 0 <= i1@207@00]
(assert (<= 0 i1@207@00))
; [eval] i1 < V
(push) ; 14
; [then-branch: 130 | i1@207@00 < V@104@00 | live]
; [else-branch: 130 | !(i1@207@00 < V@104@00) | live]
(push) ; 15
; [then-branch: 130 | i1@207@00 < V@104@00]
(assert (< i1@207@00 V@104@00))
; [eval] 0 <= j
(push) ; 16
; [then-branch: 131 | 0 <= j@208@00 | live]
; [else-branch: 131 | !(0 <= j@208@00) | live]
(push) ; 17
; [then-branch: 131 | 0 <= j@208@00]
(assert (<= 0 j@208@00))
; [eval] j < V
(pop) ; 17
(push) ; 17
; [else-branch: 131 | !(0 <= j@208@00)]
(assert (not (<= 0 j@208@00)))
(pop) ; 17
(pop) ; 16
; Joined path conditions
; Joined path conditions
(pop) ; 15
(push) ; 15
; [else-branch: 130 | !(i1@207@00 < V@104@00)]
(assert (not (< i1@207@00 V@104@00)))
(pop) ; 15
(pop) ; 14
; Joined path conditions
; Joined path conditions
(pop) ; 13
(push) ; 13
; [else-branch: 129 | !(0 <= i1@207@00)]
(assert (not (<= 0 i1@207@00)))
(pop) ; 13
(pop) ; 12
; Joined path conditions
; Joined path conditions
(assert (and
  (and (and (< j@208@00 V@104@00) (<= 0 j@208@00)) (< i1@207@00 V@104@00))
  (<= 0 i1@207@00)))
(declare-const $k@209@00 $Perm)
(assert ($Perm.isReadVar $k@209@00 $Perm.Write))
; [eval] aloc(opt_get1(aloc(opt_get1(G), i1).option$array$), j)
; [eval] opt_get1(aloc(opt_get1(G), i1).option$array$)
; [eval] aloc(opt_get1(G), i1)
; [eval] opt_get1(G)
(push) ; 12
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 12
; Joined path conditions
(push) ; 12
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 13
(assert (not (< i1@207@00 (alen<Int> (opt_get1 $Snap.unit G@103@00)))))
(check-sat)
; unsat
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               2332
;  :arith-add-rows          1682
;  :arith-assert-diseq      218
;  :arith-assert-lower      911
;  :arith-assert-upper      501
;  :arith-bound-prop        160
;  :arith-conflicts         87
;  :arith-eq-adapter        411
;  :arith-fixed-eqs         272
;  :arith-offset-eqs        117
;  :arith-pivots            776
;  :conflicts               180
;  :datatype-accessor-ax    142
;  :datatype-constructor-ax 35
;  :datatype-occurs-check   94
;  :datatype-splits         23
;  :decisions               208
;  :del-clause              3238
;  :final-checks            92
;  :interface-eqs           9
;  :max-generation          6
;  :max-memory              5.38
;  :memory                  5.38
;  :minimized-lits          3
;  :mk-bool-var             5910
;  :mk-clause               3240
;  :num-allocs              275236
;  :num-checks              213
;  :propagations            1255
;  :quant-instantiations    1766
;  :rlimit-count            420947)
(assert (< i1@207@00 (alen<Int> (opt_get1 $Snap.unit G@103@00))))
(pop) ; 12
; Joined path conditions
(assert (< i1@207@00 (alen<Int> (opt_get1 $Snap.unit G@103@00))))
(declare-fun sm@210@00 ($Snap $Ref option<array> Int Int Int) $FVF<option<array>>)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      (< $Perm.No $k@177@00)
      false)
    (=
      ($FVF.lookup_option$array$ (sm@210@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r)))
  :pattern (($FVF.lookup_option$array$ (sm@210@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r))
  :qid |qp.fvfValDef41|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r)
  :pattern (($FVF.lookup_option$array$ (sm@210@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :qid |qp.fvfResTrgDef42|)))
(declare-const pm@211@00 $FPM)
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@211@00  $FPM) r)
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      $k@177@00
      $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@211@00  $FPM) r))
  :qid |qp.resPrmSumDef43|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@210@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@211@00  $FPM) r))
  :qid |qp.resTrgDef44|)))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@210@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@207@00)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@207@00)))
(push) ; 12
(assert (not (<
  $Perm.No
  ($FVF.perm_option$array$ (as pm@211@00  $FPM) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@207@00)))))
(check-sat)
; unsat
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               2348
;  :arith-add-rows          1693
;  :arith-assert-diseq      219
;  :arith-assert-lower      916
;  :arith-assert-upper      506
;  :arith-bound-prop        162
;  :arith-conflicts         88
;  :arith-eq-adapter        415
;  :arith-fixed-eqs         276
;  :arith-offset-eqs        117
;  :arith-pivots            780
;  :conflicts               181
;  :datatype-accessor-ax    142
;  :datatype-constructor-ax 35
;  :datatype-occurs-check   94
;  :datatype-splits         23
;  :decisions               208
;  :del-clause              3242
;  :final-checks            92
;  :interface-eqs           9
;  :max-generation          6
;  :max-memory              5.44
;  :memory                  5.40
;  :minimized-lits          3
;  :mk-bool-var             5983
;  :mk-clause               3279
;  :num-allocs              276397
;  :num-checks              214
;  :propagations            1258
;  :quant-instantiations    1802
;  :rlimit-count            423883)
(push) ; 12
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 13
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (sm@210@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@207@00))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               2369
;  :arith-add-rows          1698
;  :arith-assert-diseq      219
;  :arith-assert-lower      917
;  :arith-assert-upper      507
;  :arith-bound-prop        164
;  :arith-conflicts         89
;  :arith-eq-adapter        415
;  :arith-fixed-eqs         276
;  :arith-offset-eqs        120
;  :arith-pivots            781
;  :conflicts               185
;  :datatype-accessor-ax    142
;  :datatype-constructor-ax 37
;  :datatype-occurs-check   94
;  :datatype-splits         23
;  :decisions               211
;  :del-clause              3244
;  :final-checks            92
;  :interface-eqs           9
;  :max-generation          6
;  :max-memory              5.44
;  :memory                  5.40
;  :minimized-lits          3
;  :mk-bool-var             5984
;  :mk-clause               3281
;  :num-allocs              276503
;  :num-checks              215
;  :propagations            1275
;  :quant-instantiations    1802
;  :rlimit-count            424181)
(assert (not
  (=
    ($FVF.lookup_option$array$ (sm@210@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@207@00))
    (as None<option<array>>  option<array>))))
(pop) ; 12
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (sm@210@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@207@00))
    (as None<option<array>>  option<array>))))
(push) ; 12
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 13
(assert (not (<
  j@208@00
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@210@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@207@00)))))))
(check-sat)
; unsat
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               2425
;  :arith-add-rows          1708
;  :arith-assert-diseq      219
;  :arith-assert-lower      921
;  :arith-assert-upper      509
;  :arith-bound-prop        166
;  :arith-conflicts         91
;  :arith-eq-adapter        417
;  :arith-fixed-eqs         277
;  :arith-offset-eqs        123
;  :arith-pivots            785
;  :conflicts               189
;  :datatype-accessor-ax    142
;  :datatype-constructor-ax 39
;  :datatype-occurs-check   94
;  :datatype-splits         23
;  :decisions               214
;  :del-clause              3247
;  :final-checks            92
;  :interface-eqs           9
;  :max-generation          6
;  :max-memory              5.44
;  :memory                  5.40
;  :minimized-lits          3
;  :mk-bool-var             5999
;  :mk-clause               3284
;  :num-allocs              276716
;  :num-checks              216
;  :propagations            1307
;  :quant-instantiations    1808
;  :rlimit-count            424933)
(assert (<
  j@208@00
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@210@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@207@00))))))
(pop) ; 12
; Joined path conditions
(assert (<
  j@208@00
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@210@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@207@00))))))
(pop) ; 11
(declare-fun inv@212@00 ($Snap $Ref option<array> Int Int Int $Ref) Int)
(declare-fun inv@213@00 ($Snap $Ref option<array> Int Int Int $Ref) Int)
; Nested auxiliary terms: globals
(assert ($Perm.isReadVar $k@209@00 $Perm.Write))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      (< $Perm.No $k@177@00)
      false)
    (=
      ($FVF.lookup_option$array$ (sm@210@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r)))
  :pattern (($FVF.lookup_option$array$ (sm@210@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r))
  :qid |qp.fvfValDef41|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r)
  :pattern (($FVF.lookup_option$array$ (sm@210@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :qid |qp.fvfResTrgDef42|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@211@00  $FPM) r)
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      $k@177@00
      $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@211@00  $FPM) r))
  :qid |qp.resPrmSumDef43|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@210@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@211@00  $FPM) r))
  :qid |qp.resTrgDef44|)))
; Nested auxiliary terms: non-globals
(assert (forall ((i1@207@00 Int) (j@208@00 Int)) (!
  (and
    (< i1@207@00 (alen<Int> (opt_get1 $Snap.unit G@103@00)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@210@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@207@00)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@207@00))
    (not
      (=
        ($FVF.lookup_option$array$ (sm@210@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@207@00))
        (as None<option<array>>  option<array>)))
    (<
      j@208@00
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@210@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@207@00))))))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@210@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@207@00))) j@208@00))
  :qid |int-aux|)))
(push) ; 11
(assert (not (forall ((i1@207@00 Int) (j@208@00 Int)) (!
  (implies
    (and
      (and (and (< j@208@00 V@104@00) (<= 0 j@208@00)) (< i1@207@00 V@104@00))
      (<= 0 i1@207@00))
    (or (= $k@209@00 $Perm.No) (< $Perm.No $k@209@00)))
  
  ))))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               2425
;  :arith-add-rows          1713
;  :arith-assert-diseq      220
;  :arith-assert-lower      923
;  :arith-assert-upper      510
;  :arith-bound-prop        166
;  :arith-conflicts         91
;  :arith-eq-adapter        418
;  :arith-fixed-eqs         277
;  :arith-offset-eqs        123
;  :arith-pivots            789
;  :conflicts               190
;  :datatype-accessor-ax    142
;  :datatype-constructor-ax 39
;  :datatype-occurs-check   94
;  :datatype-splits         23
;  :decisions               214
;  :del-clause              3284
;  :final-checks            92
;  :interface-eqs           9
;  :max-generation          6
;  :max-memory              5.44
;  :memory                  5.40
;  :minimized-lits          3
;  :mk-bool-var             6012
;  :mk-clause               3286
;  :num-allocs              277790
;  :num-checks              217
;  :propagations            1308
;  :quant-instantiations    1808
;  :rlimit-count            427055)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 11
(assert (not (forall ((i11@207@00 Int) (j1@208@00 Int) (i12@207@00 Int) (j2@208@00 Int)) (!
  (implies
    (and
      (and
        (and
          (and
            (and
              (and (< j1@208@00 V@104@00) (<= 0 j1@208@00))
              (< i11@207@00 V@104@00))
            (<= 0 i11@207@00))
          ($FVF.loc_int ($FVF.lookup_int (sm@189@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@210@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@103@00) i11@207@00))) j1@208@00)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@210@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@103@00) i11@207@00))) j1@208@00)))
        (< $Perm.No $k@209@00))
      (and
        (and
          (and
            (and
              (and (< j2@208@00 V@104@00) (<= 0 j2@208@00))
              (< i12@207@00 V@104@00))
            (<= 0 i12@207@00))
          ($FVF.loc_int ($FVF.lookup_int (sm@189@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@210@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@103@00) i12@207@00))) j2@208@00)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@210@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@103@00) i12@207@00))) j2@208@00)))
        (< $Perm.No $k@209@00))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@210@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@103@00) i11@207@00))) j1@208@00)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@210@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@103@00) i12@207@00))) j2@208@00)))
    (and (= i11@207@00 i12@207@00) (= j1@208@00 j2@208@00)))
  
  :qid |int-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               2556
;  :arith-add-rows          1821
;  :arith-assert-diseq      222
;  :arith-assert-lower      950
;  :arith-assert-upper      528
;  :arith-bound-prop        176
;  :arith-conflicts         93
;  :arith-eq-adapter        431
;  :arith-fixed-eqs         289
;  :arith-offset-eqs        141
;  :arith-pivots            824
;  :conflicts               197
;  :datatype-accessor-ax    142
;  :datatype-constructor-ax 41
;  :datatype-occurs-check   94
;  :datatype-splits         23
;  :decisions               220
;  :del-clause              3416
;  :final-checks            92
;  :interface-eqs           9
;  :max-generation          6
;  :max-memory              5.52
;  :memory                  5.50
;  :minimized-lits          6
;  :mk-bool-var             6241
;  :mk-clause               3418
;  :num-allocs              279294
;  :num-checks              218
;  :propagations            1367
;  :quant-instantiations    1911
;  :rlimit-count            433778
;  :time                    0.00)
; Definitional axioms for inverse functions
(assert (forall ((i1@207@00 Int) (j@208@00 Int)) (!
  (implies
    (and
      (and
        (and (and (< j@208@00 V@104@00) (<= 0 j@208@00)) (< i1@207@00 V@104@00))
        (<= 0 i1@207@00))
      (< $Perm.No $k@209@00))
    (and
      (=
        (inv@212@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@210@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@207@00))) j@208@00))
        i1@207@00)
      (=
        (inv@213@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@210@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@207@00))) j@208@00))
        j@208@00)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@210@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@207@00))) j@208@00))
  :qid |int-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and
          (and
            (<
              (inv@213@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
              V@104@00)
            (<=
              0
              (inv@213@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
          (<
            (inv@212@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
            V@104@00))
        (<= 0 (inv@212@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      (< $Perm.No $k@209@00))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@210@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@103@00) (inv@212@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))) (inv@213@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
      r))
  :pattern ((inv@212@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
  :pattern ((inv@213@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and
          (<
            (inv@213@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
            V@104@00)
          (<=
            0
            (inv@213@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
        (<
          (inv@212@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00))
      (<= 0 (inv@212@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
    ($FVF.loc_int ($FVF.lookup_int (sm@189@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r) r))
  :pattern ((inv@212@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r) (inv@213@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
  )))
; Precomputing data for removing quantified permissions
(define-fun pTaken@214@00 ((r $Ref) (s@$ $Snap) (this@102@00 $Ref) (G@103@00 option<array>) (V@104@00 Int) (s@105@00 Int) (t@106@00 Int)) $Perm
  (ite
    (and
      (and
        (and
          (<
            (inv@213@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
            V@104@00)
          (<=
            0
            (inv@213@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
        (<
          (inv@212@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00))
      (<= 0 (inv@212@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
    ($Perm.min
      (ite
        (and
          (and
            (and
              (<
                (inv@188@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                V@104@00)
              (<=
                0
                (inv@188@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
            (<
              (inv@187@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
              V@104@00))
          (<=
            0
            (inv@187@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
        $k@186@00
        $Perm.No)
      $k@209@00)
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Constrain original permissions $k@209@00
(assert (forall ((r $Ref)) (!
  (implies
    (not
      (=
        (ite
          (and
            (and
              (and
                (<
                  (inv@188@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                  V@104@00)
                (<=
                  0
                  (inv@188@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
              (<
                (inv@187@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                V@104@00))
            (<=
              0
              (inv@187@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
          $k@186@00
          $Perm.No)
        $Perm.No))
    (ite
      (and
        (and
          (and
            (<
              (inv@188@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
              V@104@00)
            (<=
              0
              (inv@188@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
          (<
            (inv@187@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
            V@104@00))
        (<= 0 (inv@187@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      (<
        (ite
          (and
            (and
              (and
                (<
                  (inv@213@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                  V@104@00)
                (<=
                  0
                  (inv@213@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
              (<
                (inv@212@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                V@104@00))
            (<=
              0
              (inv@212@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
          $k@209@00
          $Perm.No)
        $k@186@00)
      (<
        (ite
          (and
            (and
              (and
                (<
                  (inv@213@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                  V@104@00)
                (<=
                  0
                  (inv@213@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
              (<
                (inv@212@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                V@104@00))
            (<=
              0
              (inv@212@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
          $k@209@00
          $Perm.No)
        $Perm.No)))
  :pattern ((inv@188@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
  :pattern ((inv@187@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
  :pattern ((inv@213@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
  :pattern ((inv@212@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
  :qid |qp.srp45|)))
; Intermediate check if already taken enough permissions
(set-option :timeout 500)
(push) ; 11
(assert (not (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and
          (<
            (inv@213@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
            V@104@00)
          (<=
            0
            (inv@213@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
        (<
          (inv@212@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00))
      (<= 0 (inv@212@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
    (=
      (-
        $k@209@00
        (pTaken@214@00 r s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00))
      $Perm.No))
  
  ))))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               2725
;  :arith-add-rows          1931
;  :arith-assert-diseq      231
;  :arith-assert-lower      985
;  :arith-assert-upper      559
;  :arith-bound-prop        188
;  :arith-conflicts         99
;  :arith-eq-adapter        458
;  :arith-fixed-eqs         304
;  :arith-offset-eqs        146
;  :arith-pivots            871
;  :conflicts               206
;  :datatype-accessor-ax    142
;  :datatype-constructor-ax 45
;  :datatype-occurs-check   95
;  :datatype-splits         23
;  :decisions               230
;  :del-clause              3555
;  :final-checks            93
;  :interface-eqs           9
;  :max-generation          6
;  :max-memory              5.55
;  :memory                  5.54
;  :minimized-lits          7
;  :mk-bool-var             6464
;  :mk-clause               3557
;  :num-allocs              282138
;  :num-checks              220
;  :propagations            1465
;  :quant-instantiations    1991
;  :rlimit-count            442447
;  :time                    0.00)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-fun sm@215@00 ($Snap $Ref option<array> Int Int Int) $FVF<Int>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (iff
    (Set_in r ($FVF.domain_int (sm@215@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00)))
    (and
      (and
        (and
          (and
            (<
              (inv@213@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
              V@104@00)
            (<=
              0
              (inv@213@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
          (<
            (inv@212@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
            V@104@00))
        (<= 0 (inv@212@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      (< $Perm.No $k@209@00)))
  :pattern ((Set_in r ($FVF.domain_int (sm@215@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00))))
  :qid |qp.fvfDomDef48|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and
          (and
            (and
              (<
                (inv@213@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                V@104@00)
              (<=
                0
                (inv@213@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
            (<
              (inv@212@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
              V@104@00))
          (<=
            0
            (inv@212@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
        (< $Perm.No $k@209@00))
      (ite
        (and
          (and
            (and
              (<
                (inv@188@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                V@104@00)
              (<=
                0
                (inv@188@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
            (<
              (inv@187@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
              V@104@00))
          (<=
            0
            (inv@187@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
        (< $Perm.No $k@186@00)
        false))
    (=
      ($FVF.lookup_int (sm@215@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$)))))))) r)))
  :pattern (($FVF.lookup_int (sm@215@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$)))))))) r))
  :qid |qp.fvfValDef46|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$)))))))) r) r)
  :pattern (($FVF.lookup_int (sm@215@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :qid |qp.fvfResTrgDef47|)))
(pop) ; 10
; Joined path conditions
(assert ($Perm.isReadVar $k@191@00 $Perm.Write))
(assert (forall ((i1@190@00 Int)) (!
  (implies
    (and (and (< i1@190@00 V@104@00) (<= 0 i1@190@00)) (< $Perm.No $k@191@00))
    (=
      (inv@192@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@190@00))
      i1@190@00))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@190@00))
  :qid |option$array$-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (<
          (inv@192@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@192@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      (< $Perm.No $k@191@00))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@103@00) (inv@192@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
      r))
  :pattern ((inv@192@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
  :qid |option$array$-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (iff
    (Set_in r ($FVF.domain_option$array$ (sm@194@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00)))
    (and
      (and
        (<
          (inv@192@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@192@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      (< $Perm.No $k@191@00)))
  :pattern ((Set_in r ($FVF.domain_option$array$ (sm@194@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00))))
  :qid |qp.fvfDomDef24|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and
          (<
            (inv@192@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
            V@104@00)
          (<=
            0
            (inv@192@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
        (< $Perm.No $k@191@00))
      (ite
        (and
          (<
            (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
            V@104@00)
          (<=
            0
            (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
        (< $Perm.No $k@177@00)
        false))
    (=
      ($FVF.lookup_option$array$ (sm@194@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r)))
  :pattern (($FVF.lookup_option$array$ (sm@194@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r))
  :qid |qp.fvfValDef22|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r)
  :pattern (($FVF.lookup_option$array$ (sm@194@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :qid |qp.fvfResTrgDef23|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      (< $Perm.No $k@177@00)
      false)
    (=
      ($FVF.lookup_option$array$ (sm@196@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r)))
  :pattern (($FVF.lookup_option$array$ (sm@196@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r))
  :qid |qp.fvfValDef25|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r)
  :pattern (($FVF.lookup_option$array$ (sm@196@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :qid |qp.fvfResTrgDef26|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@197@00  $FPM) r)
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      $k@177@00
      $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@197@00  $FPM) r))
  :qid |qp.resPrmSumDef27|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@196@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@197@00  $FPM) r))
  :qid |qp.resTrgDef28|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      (< $Perm.No $k@177@00)
      false)
    (=
      ($FVF.lookup_option$array$ (sm@199@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r)))
  :pattern (($FVF.lookup_option$array$ (sm@199@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r))
  :qid |qp.fvfValDef29|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r)
  :pattern (($FVF.lookup_option$array$ (sm@199@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :qid |qp.fvfResTrgDef30|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@200@00  $FPM) r)
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      $k@177@00
      $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@200@00  $FPM) r))
  :qid |qp.resPrmSumDef31|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@199@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@200@00  $FPM) r))
  :qid |qp.resTrgDef32|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      (< $Perm.No $k@177@00)
      false)
    (=
      ($FVF.lookup_option$array$ (sm@203@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r)))
  :pattern (($FVF.lookup_option$array$ (sm@203@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r))
  :qid |qp.fvfValDef33|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r)
  :pattern (($FVF.lookup_option$array$ (sm@203@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :qid |qp.fvfResTrgDef34|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@204@00  $FPM) r)
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      $k@177@00
      $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@204@00  $FPM) r))
  :qid |qp.resPrmSumDef35|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@203@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@204@00  $FPM) r))
  :qid |qp.resTrgDef36|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      (< $Perm.No $k@177@00)
      false)
    (=
      ($FVF.lookup_option$array$ (sm@205@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r)))
  :pattern (($FVF.lookup_option$array$ (sm@205@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r))
  :qid |qp.fvfValDef37|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r)
  :pattern (($FVF.lookup_option$array$ (sm@205@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :qid |qp.fvfResTrgDef38|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@206@00  $FPM) r)
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      $k@177@00
      $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@206@00  $FPM) r))
  :qid |qp.resPrmSumDef39|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@205@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@206@00  $FPM) r))
  :qid |qp.resTrgDef40|)))
(assert ($Perm.isReadVar $k@209@00 $Perm.Write))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      (< $Perm.No $k@177@00)
      false)
    (=
      ($FVF.lookup_option$array$ (sm@210@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r)))
  :pattern (($FVF.lookup_option$array$ (sm@210@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r))
  :qid |qp.fvfValDef41|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r)
  :pattern (($FVF.lookup_option$array$ (sm@210@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :qid |qp.fvfResTrgDef42|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@211@00  $FPM) r)
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      $k@177@00
      $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@211@00  $FPM) r))
  :qid |qp.resPrmSumDef43|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@210@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@211@00  $FPM) r))
  :qid |qp.resTrgDef44|)))
(assert (forall ((i1@207@00 Int) (j@208@00 Int)) (!
  (implies
    (and
      (and
        (and (and (< j@208@00 V@104@00) (<= 0 j@208@00)) (< i1@207@00 V@104@00))
        (<= 0 i1@207@00))
      (< $Perm.No $k@209@00))
    (and
      (=
        (inv@212@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@210@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@207@00))) j@208@00))
        i1@207@00)
      (=
        (inv@213@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@210@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@207@00))) j@208@00))
        j@208@00)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@210@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@207@00))) j@208@00))
  :qid |int-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and
          (and
            (<
              (inv@213@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
              V@104@00)
            (<=
              0
              (inv@213@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
          (<
            (inv@212@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
            V@104@00))
        (<= 0 (inv@212@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      (< $Perm.No $k@209@00))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@210@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@103@00) (inv@212@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))) (inv@213@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
      r))
  :pattern ((inv@212@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
  :pattern ((inv@213@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (iff
    (Set_in r ($FVF.domain_int (sm@215@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00)))
    (and
      (and
        (and
          (and
            (<
              (inv@213@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
              V@104@00)
            (<=
              0
              (inv@213@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
          (<
            (inv@212@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
            V@104@00))
        (<= 0 (inv@212@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      (< $Perm.No $k@209@00)))
  :pattern ((Set_in r ($FVF.domain_int (sm@215@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00))))
  :qid |qp.fvfDomDef48|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and
          (and
            (and
              (<
                (inv@213@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                V@104@00)
              (<=
                0
                (inv@213@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
            (<
              (inv@212@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
              V@104@00))
          (<=
            0
            (inv@212@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
        (< $Perm.No $k@209@00))
      (ite
        (and
          (and
            (and
              (<
                (inv@188@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                V@104@00)
              (<=
                0
                (inv@188@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
            (<
              (inv@187@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
              V@104@00))
          (<=
            0
            (inv@187@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
        (< $Perm.No $k@186@00)
        false))
    (=
      ($FVF.lookup_int (sm@215@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$)))))))) r)))
  :pattern (($FVF.lookup_int (sm@215@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$)))))))) r))
  :qid |qp.fvfValDef46|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$)))))))) r) r)
  :pattern (($FVF.lookup_int (sm@215@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :qid |qp.fvfResTrgDef47|)))
(assert (and
  (forall ((i1@190@00 Int)) (!
    (< i1@190@00 (alen<Int> (opt_get1 $Snap.unit G@103@00)))
    :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@190@00))
    :qid |option$array$-aux|))
  (forall ((r $Ref)) (!
    (implies
      (and
        (<
          (inv@192@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@192@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@179@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r) r))
    :pattern ((inv@192@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
    ))
  (forall ((r $Ref)) (!
    (implies
      (not
        (=
          (ite
            (and
              (<
                (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                V@104@00)
              (<=
                0
                (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
            $k@177@00
            $Perm.No)
          $Perm.No))
      (ite
        (and
          (<
            (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
            V@104@00)
          (<=
            0
            (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
        (<
          (ite
            (and
              (<
                (inv@192@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                V@104@00)
              (<=
                0
                (inv@192@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
            $k@191@00
            $Perm.No)
          $k@177@00)
        (<
          (ite
            (and
              (<
                (inv@192@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                V@104@00)
              (<=
                0
                (inv@192@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
            $k@191@00
            $Perm.No)
          $Perm.No)))
    :pattern ((inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
    :pattern ((inv@192@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
    :qid |qp.srp21|))
  (forall ((i1@195@00 Int)) (!
    (implies
      (and (< i1@195@00 V@104@00) (<= 0 i1@195@00))
      (not
        (=
          ($FVF.lookup_option$array$ (sm@196@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@195@00))
          (as None<option<array>>  option<array>))))
    
    :qid |prog.l<no position>|))
  (forall ((i1@198@00 Int)) (!
    (implies
      (and (< i1@198@00 V@104@00) (<= 0 i1@198@00))
      (=
        (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@199@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@198@00))))
        V@104@00))
    
    :qid |prog.l<no position>|))
  (forall ((i1@201@00 Int)) (!
    (forall ((i2@202@00 Int)) (!
      (implies
        (and
          (and
            (and
              (and
                (=
                  ($FVF.lookup_option$array$ (sm@203@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@201@00))
                  ($FVF.lookup_option$array$ (sm@205@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit G@103@00) i2@202@00)))
                (< i2@202@00 V@104@00))
              (<= 0 i2@202@00))
            (< i1@201@00 V@104@00))
          (<= 0 i1@201@00))
        (= i1@201@00 i2@202@00))
      :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@103@00) i2@202@00))
      :qid |prog.l<no position>|))
    
    :qid |prog.l<no position>|))
  (forall ((i1@207@00 Int) (j@208@00 Int)) (!
    (and
      (< i1@207@00 (alen<Int> (opt_get1 $Snap.unit G@103@00)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@210@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@207@00)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@207@00))
      (not
        (=
          ($FVF.lookup_option$array$ (sm@210@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@207@00))
          (as None<option<array>>  option<array>)))
      (<
        j@208@00
        (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@210@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@207@00))))))
    :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@210@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@207@00))) j@208@00))
    :qid |int-aux|))
  (forall ((r $Ref)) (!
    (implies
      (and
        (and
          (and
            (<
              (inv@213@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
              V@104@00)
            (<=
              0
              (inv@213@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
          (<
            (inv@212@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
            V@104@00))
        (<= 0 (inv@212@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      ($FVF.loc_int ($FVF.lookup_int (sm@189@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r) r))
    :pattern ((inv@212@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r) (inv@213@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
    ))
  (forall ((r $Ref)) (!
    (implies
      (not
        (=
          (ite
            (and
              (and
                (and
                  (<
                    (inv@188@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                    V@104@00)
                  (<=
                    0
                    (inv@188@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
                (<
                  (inv@187@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                  V@104@00))
              (<=
                0
                (inv@187@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
            $k@186@00
            $Perm.No)
          $Perm.No))
      (ite
        (and
          (and
            (and
              (<
                (inv@188@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                V@104@00)
              (<=
                0
                (inv@188@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
            (<
              (inv@187@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
              V@104@00))
          (<=
            0
            (inv@187@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
        (<
          (ite
            (and
              (and
                (and
                  (<
                    (inv@213@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                    V@104@00)
                  (<=
                    0
                    (inv@213@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
                (<
                  (inv@212@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                  V@104@00))
              (<=
                0
                (inv@212@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
            $k@209@00
            $Perm.No)
          $k@186@00)
        (<
          (ite
            (and
              (and
                (and
                  (<
                    (inv@213@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                    V@104@00)
                  (<=
                    0
                    (inv@213@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
                (<
                  (inv@212@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                  V@104@00))
              (<=
                0
                (inv@212@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
            $k@209@00
            $Perm.No)
          $Perm.No)))
    :pattern ((inv@188@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
    :pattern ((inv@187@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
    :pattern ((inv@213@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
    :pattern ((inv@212@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
    :qid |qp.srp45|))))
(push) ; 10
; [then-branch: 132 | SquareIntMatrix1((_, (_, (_, (sm@194@00(s@$, this@102@00, G@103@00, V@104@00, s@105@00, t@106@00), (_, (_, (_, sm@215@00(s@$, this@102@00, G@103@00, V@104@00, s@105@00, t@106@00)))))))), this@102@00, G@103@00, V@104@00) | live]
; [else-branch: 132 | !(SquareIntMatrix1((_, (_, (_, (sm@194@00(s@$, this@102@00, G@103@00, V@104@00, s@105@00, t@106@00), (_, (_, (_, sm@215@00(s@$, this@102@00, G@103@00, V@104@00, s@105@00, t@106@00)))))))), this@102@00, G@103@00, V@104@00)) | live]
(push) ; 11
; [then-branch: 132 | SquareIntMatrix1((_, (_, (_, (sm@194@00(s@$, this@102@00, G@103@00, V@104@00, s@105@00, t@106@00), (_, (_, (_, sm@215@00(s@$, this@102@00, G@103@00, V@104@00, s@105@00, t@106@00)))))))), this@102@00, G@103@00, V@104@00)]
(assert (SquareIntMatrix1 ($Snap.combine
  $Snap.unit
  ($Snap.combine
    $Snap.unit
    ($Snap.combine
      $Snap.unit
      ($Snap.combine
        ($SortWrappers.$FVF<option<array>>To$Snap (sm@194@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00))
        ($Snap.combine
          $Snap.unit
          ($Snap.combine
            $Snap.unit
            ($Snap.combine
              $Snap.unit
              ($SortWrappers.$FVF<Int>To$Snap (sm@215@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00))))))))) this@102@00 G@103@00 V@104@00))
; [eval] NonNegativeCapacities1(this, G, V)
(push) ; 12
; [eval] this != null
; [eval] SquareIntMatrix1(this, G, V)
(push) ; 13
; [eval] this != null
; [eval] G != (None(): option[array])
; [eval] (None(): option[array])
; [eval] alen(opt_get1(G)) == V
; [eval] alen(opt_get1(G))
; [eval] opt_get1(G)
(push) ; 14
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 14
; Joined path conditions
(declare-const i1@216@00 Int)
(push) ; 14
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 15
; [then-branch: 133 | 0 <= i1@216@00 | live]
; [else-branch: 133 | !(0 <= i1@216@00) | live]
(push) ; 16
; [then-branch: 133 | 0 <= i1@216@00]
(assert (<= 0 i1@216@00))
; [eval] i1 < V
(pop) ; 16
(push) ; 16
; [else-branch: 133 | !(0 <= i1@216@00)]
(assert (not (<= 0 i1@216@00)))
(pop) ; 16
(pop) ; 15
; Joined path conditions
; Joined path conditions
(assert (and (< i1@216@00 V@104@00) (<= 0 i1@216@00)))
(declare-const $k@217@00 $Perm)
(assert ($Perm.isReadVar $k@217@00 $Perm.Write))
; [eval] aloc(opt_get1(G), i1)
; [eval] opt_get1(G)
(push) ; 15
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 15
; Joined path conditions
(push) ; 15
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 16
(assert (not (< i1@216@00 (alen<Int> (opt_get1 $Snap.unit G@103@00)))))
(check-sat)
; unsat
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               2742
;  :arith-add-rows          1936
;  :arith-assert-diseq      236
;  :arith-assert-lower      996
;  :arith-assert-upper      565
;  :arith-bound-prop        188
;  :arith-conflicts         99
;  :arith-eq-adapter        464
;  :arith-fixed-eqs         304
;  :arith-offset-eqs        146
;  :arith-pivots            871
;  :conflicts               206
;  :datatype-accessor-ax    149
;  :datatype-constructor-ax 45
;  :datatype-occurs-check   95
;  :datatype-splits         23
;  :decisions               230
;  :del-clause              3557
;  :final-checks            93
;  :interface-eqs           9
;  :max-generation          6
;  :max-memory              5.56
;  :memory                  5.56
;  :minimized-lits          7
;  :mk-bool-var             6562
;  :mk-clause               3615
;  :num-allocs              288918
;  :num-checks              221
;  :propagations            1484
;  :quant-instantiations    1996
;  :rlimit-count            457949)
(assert (< i1@216@00 (alen<Int> (opt_get1 $Snap.unit G@103@00))))
(pop) ; 15
; Joined path conditions
(assert (< i1@216@00 (alen<Int> (opt_get1 $Snap.unit G@103@00))))
(pop) ; 14
(declare-fun inv@218@00 ($Snap $Ref option<array> Int Int Int $Ref) Int)
; Nested auxiliary terms: globals
(assert ($Perm.isReadVar $k@217@00 $Perm.Write))
; Nested auxiliary terms: non-globals
(assert (forall ((i1@216@00 Int)) (!
  (< i1@216@00 (alen<Int> (opt_get1 $Snap.unit G@103@00)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@216@00))
  :qid |option$array$-aux|)))
(push) ; 14
(assert (not (forall ((i1@216@00 Int)) (!
  (implies
    (and (< i1@216@00 V@104@00) (<= 0 i1@216@00))
    (or (= $k@217@00 $Perm.No) (< $Perm.No $k@217@00)))
  
  ))))
(check-sat)
; unsat
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               2742
;  :arith-add-rows          1937
;  :arith-assert-diseq      237
;  :arith-assert-lower      998
;  :arith-assert-upper      566
;  :arith-bound-prop        188
;  :arith-conflicts         99
;  :arith-eq-adapter        465
;  :arith-fixed-eqs         304
;  :arith-offset-eqs        146
;  :arith-pivots            871
;  :conflicts               207
;  :datatype-accessor-ax    149
;  :datatype-constructor-ax 45
;  :datatype-occurs-check   95
;  :datatype-splits         23
;  :decisions               230
;  :del-clause              3559
;  :final-checks            93
;  :interface-eqs           9
;  :max-generation          6
;  :max-memory              5.56
;  :memory                  5.55
;  :minimized-lits          7
;  :mk-bool-var             6569
;  :mk-clause               3617
;  :num-allocs              289364
;  :num-checks              222
;  :propagations            1485
;  :quant-instantiations    1996
;  :rlimit-count            458488)
(declare-fun sm@219@00 ($Snap $Ref option<array> Int Int Int) $FVF<option<array>>)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      (< $Perm.No $k@177@00)
      false)
    (=
      ($FVF.lookup_option$array$ (sm@219@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r)))
  :pattern (($FVF.lookup_option$array$ (sm@219@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r))
  :qid |qp.fvfValDef49|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r)
  :pattern (($FVF.lookup_option$array$ (sm@219@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :qid |qp.fvfResTrgDef50|)))
; Check receiver injectivity
(push) ; 14
(assert (not (forall ((i11@216@00 Int) (i12@216@00 Int)) (!
  (implies
    (and
      (and
        (and
          (and (< i11@216@00 V@104@00) (<= 0 i11@216@00))
          ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@219@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@103@00) i11@216@00)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@103@00) i11@216@00)))
        (< $Perm.No $k@217@00))
      (and
        (and
          (and (< i12@216@00 V@104@00) (<= 0 i12@216@00))
          ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@219@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@103@00) i12@216@00)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@103@00) i12@216@00)))
        (< $Perm.No $k@217@00))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@103@00) i11@216@00)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@103@00) i12@216@00)))
    (= i11@216@00 i12@216@00))
  
  :qid |option$array$-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               2757
;  :arith-add-rows          1944
;  :arith-assert-diseq      238
;  :arith-assert-lower      1002
;  :arith-assert-upper      566
;  :arith-bound-prop        188
;  :arith-conflicts         99
;  :arith-eq-adapter        466
;  :arith-fixed-eqs         304
;  :arith-offset-eqs        146
;  :arith-pivots            873
;  :conflicts               208
;  :datatype-accessor-ax    149
;  :datatype-constructor-ax 45
;  :datatype-occurs-check   95
;  :datatype-splits         23
;  :decisions               230
;  :del-clause              3566
;  :final-checks            93
;  :interface-eqs           9
;  :max-generation          6
;  :max-memory              5.57
;  :memory                  5.56
;  :minimized-lits          7
;  :mk-bool-var             6604
;  :mk-clause               3624
;  :num-allocs              290220
;  :num-checks              223
;  :propagations            1485
;  :quant-instantiations    2020
;  :rlimit-count            460408)
; Definitional axioms for inverse functions
(assert (forall ((i1@216@00 Int)) (!
  (implies
    (and (and (< i1@216@00 V@104@00) (<= 0 i1@216@00)) (< $Perm.No $k@217@00))
    (=
      (inv@218@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@216@00))
      i1@216@00))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@216@00))
  :qid |option$array$-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (<
          (inv@218@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@218@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      (< $Perm.No $k@217@00))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@103@00) (inv@218@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
      r))
  :pattern ((inv@218@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
  :qid |option$array$-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (<
        (inv@218@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
        V@104@00)
      (<= 0 (inv@218@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@219@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r) r))
  :pattern ((inv@218@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
  )))
; Precomputing data for removing quantified permissions
(define-fun pTaken@220@00 ((r $Ref) (s@$ $Snap) (this@102@00 $Ref) (G@103@00 option<array>) (V@104@00 Int) (s@105@00 Int) (t@106@00 Int)) $Perm
  (ite
    (and
      (<
        (inv@218@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
        V@104@00)
      (<= 0 (inv@218@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
    ($Perm.min
      (ite
        (and
          (<
            (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
            V@104@00)
          (<=
            0
            (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
        $k@177@00
        $Perm.No)
      $k@217@00)
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Constrain original permissions $k@217@00
(assert (forall ((r $Ref)) (!
  (implies
    (not
      (=
        (ite
          (and
            (<
              (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
              V@104@00)
            (<=
              0
              (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
          $k@177@00
          $Perm.No)
        $Perm.No))
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      (<
        (ite
          (and
            (<
              (inv@218@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
              V@104@00)
            (<=
              0
              (inv@218@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
          $k@217@00
          $Perm.No)
        $k@177@00)
      (<
        (ite
          (and
            (<
              (inv@218@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
              V@104@00)
            (<=
              0
              (inv@218@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
          $k@217@00
          $Perm.No)
        $Perm.No)))
  :pattern ((inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
  :pattern ((inv@218@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
  :qid |qp.srp51|)))
; Intermediate check if already taken enough permissions
(set-option :timeout 500)
(push) ; 14
(assert (not (forall ((r $Ref)) (!
  (implies
    (and
      (<
        (inv@218@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
        V@104@00)
      (<= 0 (inv@218@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
    (=
      (-
        $k@217@00
        (pTaken@220@00 r s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00))
      $Perm.No))
  
  ))))
(check-sat)
; unsat
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               2917
;  :arith-add-rows          2022
;  :arith-assert-diseq      249
;  :arith-assert-lower      1034
;  :arith-assert-upper      585
;  :arith-bound-prop        200
;  :arith-conflicts         101
;  :arith-eq-adapter        497
;  :arith-fixed-eqs         314
;  :arith-offset-eqs        148
;  :arith-pivots            903
;  :conflicts               215
;  :datatype-accessor-ax    149
;  :datatype-constructor-ax 51
;  :datatype-occurs-check   106
;  :datatype-splits         25
;  :decisions               241
;  :del-clause              3688
;  :final-checks            95
;  :interface-eqs           9
;  :max-generation          6
;  :max-memory              5.60
;  :memory                  5.59
;  :minimized-lits          8
;  :mk-bool-var             6793
;  :mk-clause               3744
;  :num-allocs              292794
;  :num-checks              225
;  :propagations            1602
;  :quant-instantiations    2069
;  :rlimit-count            466274
;  :time                    0.00)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-fun sm@221@00 ($Snap $Ref option<array> Int Int Int) $FVF<option<array>>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (iff
    (Set_in r ($FVF.domain_option$array$ (sm@221@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00)))
    (and
      (and
        (<
          (inv@218@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@218@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      (< $Perm.No $k@217@00)))
  :pattern ((Set_in r ($FVF.domain_option$array$ (sm@221@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00))))
  :qid |qp.fvfDomDef54|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and
          (<
            (inv@218@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
            V@104@00)
          (<=
            0
            (inv@218@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
        (< $Perm.No $k@217@00))
      (ite
        (and
          (<
            (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
            V@104@00)
          (<=
            0
            (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
        (< $Perm.No $k@177@00)
        false))
    (=
      ($FVF.lookup_option$array$ (sm@221@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r)))
  :pattern (($FVF.lookup_option$array$ (sm@221@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r))
  :qid |qp.fvfValDef52|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r)
  :pattern (($FVF.lookup_option$array$ (sm@221@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :qid |qp.fvfResTrgDef53|)))
; [eval] (forall i1: Int :: 0 <= i1 && i1 < V ==> aloc(opt_get1(G), i1).option$array$ != (None(): option[array]))
(declare-const i1@222@00 Int)
(push) ; 14
; [eval] 0 <= i1 && i1 < V ==> aloc(opt_get1(G), i1).option$array$ != (None(): option[array])
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 15
; [then-branch: 134 | 0 <= i1@222@00 | live]
; [else-branch: 134 | !(0 <= i1@222@00) | live]
(push) ; 16
; [then-branch: 134 | 0 <= i1@222@00]
(assert (<= 0 i1@222@00))
; [eval] i1 < V
(pop) ; 16
(push) ; 16
; [else-branch: 134 | !(0 <= i1@222@00)]
(assert (not (<= 0 i1@222@00)))
(pop) ; 16
(pop) ; 15
; Joined path conditions
; Joined path conditions
(push) ; 15
; [then-branch: 135 | i1@222@00 < V@104@00 && 0 <= i1@222@00 | live]
; [else-branch: 135 | !(i1@222@00 < V@104@00 && 0 <= i1@222@00) | live]
(push) ; 16
; [then-branch: 135 | i1@222@00 < V@104@00 && 0 <= i1@222@00]
(assert (and (< i1@222@00 V@104@00) (<= 0 i1@222@00)))
; [eval] aloc(opt_get1(G), i1).option$array$ != (None(): option[array])
; [eval] aloc(opt_get1(G), i1)
; [eval] opt_get1(G)
(push) ; 17
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 17
; Joined path conditions
(push) ; 17
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 18
(assert (not (< i1@222@00 (alen<Int> (opt_get1 $Snap.unit G@103@00)))))
(check-sat)
; unsat
(pop) ; 18
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               2917
;  :arith-add-rows          2023
;  :arith-assert-diseq      249
;  :arith-assert-lower      1035
;  :arith-assert-upper      586
;  :arith-bound-prop        200
;  :arith-conflicts         101
;  :arith-eq-adapter        497
;  :arith-fixed-eqs         314
;  :arith-offset-eqs        148
;  :arith-pivots            903
;  :conflicts               215
;  :datatype-accessor-ax    149
;  :datatype-constructor-ax 51
;  :datatype-occurs-check   106
;  :datatype-splits         25
;  :decisions               241
;  :del-clause              3688
;  :final-checks            95
;  :interface-eqs           9
;  :max-generation          6
;  :max-memory              5.60
;  :memory                  5.59
;  :minimized-lits          8
;  :mk-bool-var             6798
;  :mk-clause               3744
;  :num-allocs              293437
;  :num-checks              226
;  :propagations            1602
;  :quant-instantiations    2069
;  :rlimit-count            467505)
(assert (< i1@222@00 (alen<Int> (opt_get1 $Snap.unit G@103@00))))
(pop) ; 17
; Joined path conditions
(assert (< i1@222@00 (alen<Int> (opt_get1 $Snap.unit G@103@00))))
(declare-fun sm@223@00 ($Snap $Ref option<array> Int Int Int) $FVF<option<array>>)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      (< $Perm.No $k@177@00)
      false)
    (=
      ($FVF.lookup_option$array$ (sm@223@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r)))
  :pattern (($FVF.lookup_option$array$ (sm@223@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r))
  :qid |qp.fvfValDef55|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r)
  :pattern (($FVF.lookup_option$array$ (sm@223@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :qid |qp.fvfResTrgDef56|)))
(declare-const pm@224@00 $FPM)
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@224@00  $FPM) r)
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      $k@177@00
      $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@224@00  $FPM) r))
  :qid |qp.resPrmSumDef57|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@223@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@224@00  $FPM) r))
  :qid |qp.resTrgDef58|)))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@223@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@222@00)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@222@00)))
(push) ; 17
(assert (not (<
  $Perm.No
  ($FVF.perm_option$array$ (as pm@224@00  $FPM) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@222@00)))))
(check-sat)
; unsat
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               2939
;  :arith-add-rows          2038
;  :arith-assert-diseq      250
;  :arith-assert-lower      1042
;  :arith-assert-upper      591
;  :arith-bound-prop        203
;  :arith-conflicts         102
;  :arith-eq-adapter        502
;  :arith-fixed-eqs         319
;  :arith-offset-eqs        148
;  :arith-pivots            908
;  :conflicts               216
;  :datatype-accessor-ax    149
;  :datatype-constructor-ax 51
;  :datatype-occurs-check   106
;  :datatype-splits         25
;  :decisions               241
;  :del-clause              3692
;  :final-checks            95
;  :interface-eqs           9
;  :max-generation          6
;  :max-memory              5.61
;  :memory                  5.60
;  :minimized-lits          8
;  :mk-bool-var             6898
;  :mk-clause               3806
;  :num-allocs              294700
;  :num-checks              227
;  :propagations            1605
;  :quant-instantiations    2115
;  :rlimit-count            470798)
; [eval] (None(): option[array])
(pop) ; 16
(push) ; 16
; [else-branch: 135 | !(i1@222@00 < V@104@00 && 0 <= i1@222@00)]
(assert (not (and (< i1@222@00 V@104@00) (<= 0 i1@222@00))))
(pop) ; 16
(pop) ; 15
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      (< $Perm.No $k@177@00)
      false)
    (=
      ($FVF.lookup_option$array$ (sm@223@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r)))
  :pattern (($FVF.lookup_option$array$ (sm@223@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r))
  :qid |qp.fvfValDef55|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r)
  :pattern (($FVF.lookup_option$array$ (sm@223@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :qid |qp.fvfResTrgDef56|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@224@00  $FPM) r)
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      $k@177@00
      $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@224@00  $FPM) r))
  :qid |qp.resPrmSumDef57|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@223@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@224@00  $FPM) r))
  :qid |qp.resTrgDef58|)))
(assert (implies
  (and (< i1@222@00 V@104@00) (<= 0 i1@222@00))
  (and
    (< i1@222@00 V@104@00)
    (<= 0 i1@222@00)
    (< i1@222@00 (alen<Int> (opt_get1 $Snap.unit G@103@00)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@223@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@222@00)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@222@00)))))
; Joined path conditions
(pop) ; 14
; Nested auxiliary terms: globals (aux)
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      (< $Perm.No $k@177@00)
      false)
    (=
      ($FVF.lookup_option$array$ (sm@223@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r)))
  :pattern (($FVF.lookup_option$array$ (sm@223@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r))
  :qid |qp.fvfValDef55|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r)
  :pattern (($FVF.lookup_option$array$ (sm@223@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :qid |qp.fvfResTrgDef56|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@224@00  $FPM) r)
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      $k@177@00
      $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@224@00  $FPM) r))
  :qid |qp.resPrmSumDef57|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@223@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@224@00  $FPM) r))
  :qid |qp.resTrgDef58|)))
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
; Nested auxiliary terms: non-globals (tlq)
(push) ; 14
(assert (not (forall ((i1@222@00 Int)) (!
  (implies
    (and (< i1@222@00 V@104@00) (<= 0 i1@222@00))
    (not
      (=
        ($FVF.lookup_option$array$ (sm@223@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@222@00))
        (as None<option<array>>  option<array>))))
  
  :qid |prog.l<no position>|))))
(check-sat)
; unsat
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               2972
;  :arith-add-rows          2061
;  :arith-assert-diseq      250
;  :arith-assert-lower      1049
;  :arith-assert-upper      596
;  :arith-bound-prop        206
;  :arith-conflicts         103
;  :arith-eq-adapter        506
;  :arith-fixed-eqs         323
;  :arith-offset-eqs        148
;  :arith-pivots            923
;  :conflicts               221
;  :datatype-accessor-ax    149
;  :datatype-constructor-ax 53
;  :datatype-occurs-check   106
;  :datatype-splits         25
;  :decisions               245
;  :del-clause              3815
;  :final-checks            95
;  :interface-eqs           9
;  :max-generation          6
;  :max-memory              5.61
;  :memory                  5.60
;  :minimized-lits          8
;  :mk-bool-var             6993
;  :mk-clause               3871
;  :num-allocs              296104
;  :num-checks              228
;  :propagations            1623
;  :quant-instantiations    2159
;  :rlimit-count            474494)
(assert (forall ((i1@222@00 Int)) (!
  (implies
    (and (< i1@222@00 V@104@00) (<= 0 i1@222@00))
    (not
      (=
        ($FVF.lookup_option$array$ (sm@223@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@222@00))
        (as None<option<array>>  option<array>))))
  
  :qid |prog.l<no position>|)))
; [eval] (forall i1: Int :: 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(G), i1).option$array$)) == V)
(declare-const i1@225@00 Int)
(push) ; 14
; [eval] 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(G), i1).option$array$)) == V
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 15
; [then-branch: 136 | 0 <= i1@225@00 | live]
; [else-branch: 136 | !(0 <= i1@225@00) | live]
(push) ; 16
; [then-branch: 136 | 0 <= i1@225@00]
(assert (<= 0 i1@225@00))
; [eval] i1 < V
(pop) ; 16
(push) ; 16
; [else-branch: 136 | !(0 <= i1@225@00)]
(assert (not (<= 0 i1@225@00)))
(pop) ; 16
(pop) ; 15
; Joined path conditions
; Joined path conditions
(push) ; 15
; [then-branch: 137 | i1@225@00 < V@104@00 && 0 <= i1@225@00 | live]
; [else-branch: 137 | !(i1@225@00 < V@104@00 && 0 <= i1@225@00) | live]
(push) ; 16
; [then-branch: 137 | i1@225@00 < V@104@00 && 0 <= i1@225@00]
(assert (and (< i1@225@00 V@104@00) (<= 0 i1@225@00)))
; [eval] alen(opt_get1(aloc(opt_get1(G), i1).option$array$)) == V
; [eval] alen(opt_get1(aloc(opt_get1(G), i1).option$array$))
; [eval] opt_get1(aloc(opt_get1(G), i1).option$array$)
; [eval] aloc(opt_get1(G), i1)
; [eval] opt_get1(G)
(push) ; 17
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 17
; Joined path conditions
(push) ; 17
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 18
(assert (not (< i1@225@00 (alen<Int> (opt_get1 $Snap.unit G@103@00)))))
(check-sat)
; unsat
(pop) ; 18
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               2972
;  :arith-add-rows          2062
;  :arith-assert-diseq      250
;  :arith-assert-lower      1051
;  :arith-assert-upper      596
;  :arith-bound-prop        206
;  :arith-conflicts         103
;  :arith-eq-adapter        506
;  :arith-fixed-eqs         323
;  :arith-offset-eqs        148
;  :arith-pivots            923
;  :conflicts               221
;  :datatype-accessor-ax    149
;  :datatype-constructor-ax 53
;  :datatype-occurs-check   106
;  :datatype-splits         25
;  :decisions               245
;  :del-clause              3815
;  :final-checks            95
;  :interface-eqs           9
;  :max-generation          6
;  :max-memory              5.61
;  :memory                  5.60
;  :minimized-lits          8
;  :mk-bool-var             6996
;  :mk-clause               3871
;  :num-allocs              296429
;  :num-checks              229
;  :propagations            1623
;  :quant-instantiations    2159
;  :rlimit-count            474982)
(assert (< i1@225@00 (alen<Int> (opt_get1 $Snap.unit G@103@00))))
(pop) ; 17
; Joined path conditions
(assert (< i1@225@00 (alen<Int> (opt_get1 $Snap.unit G@103@00))))
(declare-fun sm@226@00 ($Snap $Ref option<array> Int Int Int) $FVF<option<array>>)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      (< $Perm.No $k@177@00)
      false)
    (=
      ($FVF.lookup_option$array$ (sm@226@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r)))
  :pattern (($FVF.lookup_option$array$ (sm@226@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r))
  :qid |qp.fvfValDef59|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r)
  :pattern (($FVF.lookup_option$array$ (sm@226@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :qid |qp.fvfResTrgDef60|)))
(declare-const pm@227@00 $FPM)
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@227@00  $FPM) r)
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      $k@177@00
      $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@227@00  $FPM) r))
  :qid |qp.resPrmSumDef61|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@226@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@227@00  $FPM) r))
  :qid |qp.resTrgDef62|)))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@226@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@225@00)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@225@00)))
(push) ; 17
(assert (not (<
  $Perm.No
  ($FVF.perm_option$array$ (as pm@227@00  $FPM) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@225@00)))))
(check-sat)
; unsat
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               2992
;  :arith-add-rows          2077
;  :arith-assert-diseq      251
;  :arith-assert-lower      1058
;  :arith-assert-upper      601
;  :arith-bound-prop        209
;  :arith-conflicts         104
;  :arith-eq-adapter        511
;  :arith-fixed-eqs         328
;  :arith-offset-eqs        148
;  :arith-pivots            928
;  :conflicts               222
;  :datatype-accessor-ax    149
;  :datatype-constructor-ax 53
;  :datatype-occurs-check   106
;  :datatype-splits         25
;  :decisions               245
;  :del-clause              3819
;  :final-checks            95
;  :interface-eqs           9
;  :max-generation          6
;  :max-memory              5.61
;  :memory                  5.61
;  :minimized-lits          8
;  :mk-bool-var             7096
;  :mk-clause               3934
;  :num-allocs              297702
;  :num-checks              230
;  :propagations            1626
;  :quant-instantiations    2207
;  :rlimit-count            478332)
(push) ; 17
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 18
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (sm@226@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@225@00))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 18
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               3003
;  :arith-add-rows          2084
;  :arith-assert-diseq      251
;  :arith-assert-lower      1059
;  :arith-assert-upper      602
;  :arith-bound-prop        212
;  :arith-conflicts         105
;  :arith-eq-adapter        511
;  :arith-fixed-eqs         328
;  :arith-offset-eqs        151
;  :arith-pivots            929
;  :conflicts               227
;  :datatype-accessor-ax    149
;  :datatype-constructor-ax 55
;  :datatype-occurs-check   106
;  :datatype-splits         25
;  :decisions               249
;  :del-clause              3822
;  :final-checks            95
;  :interface-eqs           9
;  :max-generation          6
;  :max-memory              5.61
;  :memory                  5.60
;  :minimized-lits          8
;  :mk-bool-var             7097
;  :mk-clause               3937
;  :num-allocs              297806
;  :num-checks              231
;  :propagations            1653
;  :quant-instantiations    2207
;  :rlimit-count            478674)
(assert (not
  (=
    ($FVF.lookup_option$array$ (sm@226@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@225@00))
    (as None<option<array>>  option<array>))))
(pop) ; 17
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (sm@226@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@225@00))
    (as None<option<array>>  option<array>))))
(pop) ; 16
(push) ; 16
; [else-branch: 137 | !(i1@225@00 < V@104@00 && 0 <= i1@225@00)]
(assert (not (and (< i1@225@00 V@104@00) (<= 0 i1@225@00))))
(pop) ; 16
(pop) ; 15
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      (< $Perm.No $k@177@00)
      false)
    (=
      ($FVF.lookup_option$array$ (sm@226@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r)))
  :pattern (($FVF.lookup_option$array$ (sm@226@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r))
  :qid |qp.fvfValDef59|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r)
  :pattern (($FVF.lookup_option$array$ (sm@226@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :qid |qp.fvfResTrgDef60|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@227@00  $FPM) r)
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      $k@177@00
      $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@227@00  $FPM) r))
  :qid |qp.resPrmSumDef61|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@226@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@227@00  $FPM) r))
  :qid |qp.resTrgDef62|)))
(assert (implies
  (and (< i1@225@00 V@104@00) (<= 0 i1@225@00))
  (and
    (< i1@225@00 V@104@00)
    (<= 0 i1@225@00)
    (< i1@225@00 (alen<Int> (opt_get1 $Snap.unit G@103@00)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@226@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@225@00)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@225@00))
    (not
      (=
        ($FVF.lookup_option$array$ (sm@226@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@225@00))
        (as None<option<array>>  option<array>))))))
; Joined path conditions
(pop) ; 14
; Nested auxiliary terms: globals (aux)
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      (< $Perm.No $k@177@00)
      false)
    (=
      ($FVF.lookup_option$array$ (sm@226@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r)))
  :pattern (($FVF.lookup_option$array$ (sm@226@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r))
  :qid |qp.fvfValDef59|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r)
  :pattern (($FVF.lookup_option$array$ (sm@226@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :qid |qp.fvfResTrgDef60|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@227@00  $FPM) r)
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      $k@177@00
      $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@227@00  $FPM) r))
  :qid |qp.resPrmSumDef61|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@226@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@227@00  $FPM) r))
  :qid |qp.resTrgDef62|)))
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
; Nested auxiliary terms: non-globals (tlq)
(push) ; 14
(assert (not (forall ((i1@225@00 Int)) (!
  (implies
    (and (< i1@225@00 V@104@00) (<= 0 i1@225@00))
    (=
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@226@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@225@00))))
      V@104@00))
  
  :qid |prog.l<no position>|))))
(check-sat)
; unsat
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               3065
;  :arith-add-rows          2108
;  :arith-assert-diseq      252
;  :arith-assert-lower      1068
;  :arith-assert-upper      606
;  :arith-bound-prop        215
;  :arith-conflicts         106
;  :arith-eq-adapter        516
;  :arith-fixed-eqs         332
;  :arith-offset-eqs        151
;  :arith-pivots            944
;  :conflicts               233
;  :datatype-accessor-ax    149
;  :datatype-constructor-ax 57
;  :datatype-occurs-check   106
;  :datatype-splits         25
;  :decisions               254
;  :del-clause              3950
;  :final-checks            95
;  :interface-eqs           9
;  :max-generation          6
;  :max-memory              5.62
;  :memory                  5.61
;  :minimized-lits          8
;  :mk-bool-var             7201
;  :mk-clause               4006
;  :num-allocs              299241
;  :num-checks              232
;  :propagations            1686
;  :quant-instantiations    2258
;  :rlimit-count            482676)
(assert (forall ((i1@225@00 Int)) (!
  (implies
    (and (< i1@225@00 V@104@00) (<= 0 i1@225@00))
    (=
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@226@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@225@00))))
      V@104@00))
  
  :qid |prog.l<no position>|)))
; [eval] (forall i1: Int :: (forall i2: Int :: { aloc(opt_get1(G), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(G), i1).option$array$ == aloc(opt_get1(G), i2).option$array$ ==> i1 == i2))
(declare-const i1@228@00 Int)
(push) ; 14
; [eval] (forall i2: Int :: { aloc(opt_get1(G), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(G), i1).option$array$ == aloc(opt_get1(G), i2).option$array$ ==> i1 == i2)
(declare-const i2@229@00 Int)
(push) ; 15
; [eval] 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(G), i1).option$array$ == aloc(opt_get1(G), i2).option$array$ ==> i1 == i2
; [eval] 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(G), i1).option$array$ == aloc(opt_get1(G), i2).option$array$
; [eval] 0 <= i1
(push) ; 16
; [then-branch: 138 | 0 <= i1@228@00 | live]
; [else-branch: 138 | !(0 <= i1@228@00) | live]
(push) ; 17
; [then-branch: 138 | 0 <= i1@228@00]
(assert (<= 0 i1@228@00))
; [eval] i1 < V
(push) ; 18
; [then-branch: 139 | i1@228@00 < V@104@00 | live]
; [else-branch: 139 | !(i1@228@00 < V@104@00) | live]
(push) ; 19
; [then-branch: 139 | i1@228@00 < V@104@00]
(assert (< i1@228@00 V@104@00))
; [eval] 0 <= i2
(push) ; 20
; [then-branch: 140 | 0 <= i2@229@00 | live]
; [else-branch: 140 | !(0 <= i2@229@00) | live]
(push) ; 21
; [then-branch: 140 | 0 <= i2@229@00]
(assert (<= 0 i2@229@00))
; [eval] i2 < V
(push) ; 22
; [then-branch: 141 | i2@229@00 < V@104@00 | live]
; [else-branch: 141 | !(i2@229@00 < V@104@00) | live]
(push) ; 23
; [then-branch: 141 | i2@229@00 < V@104@00]
(assert (< i2@229@00 V@104@00))
; [eval] aloc(opt_get1(G), i1).option$array$ == aloc(opt_get1(G), i2).option$array$
; [eval] aloc(opt_get1(G), i1)
; [eval] opt_get1(G)
(push) ; 24
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 24
; Joined path conditions
(push) ; 24
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 25
(assert (not (< i1@228@00 (alen<Int> (opt_get1 $Snap.unit G@103@00)))))
(check-sat)
; unsat
(pop) ; 25
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               3065
;  :arith-add-rows          2110
;  :arith-assert-diseq      252
;  :arith-assert-lower      1071
;  :arith-assert-upper      607
;  :arith-bound-prop        215
;  :arith-conflicts         106
;  :arith-eq-adapter        516
;  :arith-fixed-eqs         332
;  :arith-offset-eqs        151
;  :arith-pivots            945
;  :conflicts               233
;  :datatype-accessor-ax    149
;  :datatype-constructor-ax 57
;  :datatype-occurs-check   106
;  :datatype-splits         25
;  :decisions               254
;  :del-clause              3950
;  :final-checks            95
;  :interface-eqs           9
;  :max-generation          6
;  :max-memory              5.62
;  :memory                  5.61
;  :minimized-lits          8
;  :mk-bool-var             7206
;  :mk-clause               4006
;  :num-allocs              299785
;  :num-checks              233
;  :propagations            1686
;  :quant-instantiations    2258
;  :rlimit-count            483325)
(assert (< i1@228@00 (alen<Int> (opt_get1 $Snap.unit G@103@00))))
(pop) ; 24
; Joined path conditions
(assert (< i1@228@00 (alen<Int> (opt_get1 $Snap.unit G@103@00))))
(declare-fun sm@230@00 ($Snap $Ref option<array> Int Int Int) $FVF<option<array>>)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      (< $Perm.No $k@177@00)
      false)
    (=
      ($FVF.lookup_option$array$ (sm@230@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r)))
  :pattern (($FVF.lookup_option$array$ (sm@230@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r))
  :qid |qp.fvfValDef63|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r)
  :pattern (($FVF.lookup_option$array$ (sm@230@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :qid |qp.fvfResTrgDef64|)))
(declare-const pm@231@00 $FPM)
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@231@00  $FPM) r)
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      $k@177@00
      $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@231@00  $FPM) r))
  :qid |qp.resPrmSumDef65|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@230@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@231@00  $FPM) r))
  :qid |qp.resTrgDef66|)))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@230@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@228@00)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@228@00)))
(push) ; 24
(assert (not (<
  $Perm.No
  ($FVF.perm_option$array$ (as pm@231@00  $FPM) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@228@00)))))
(check-sat)
; unsat
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               3097
;  :arith-add-rows          2130
;  :arith-assert-diseq      253
;  :arith-assert-lower      1079
;  :arith-assert-upper      614
;  :arith-bound-prop        219
;  :arith-conflicts         107
;  :arith-eq-adapter        522
;  :arith-fixed-eqs         338
;  :arith-offset-eqs        156
;  :arith-pivots            951
;  :conflicts               234
;  :datatype-accessor-ax    149
;  :datatype-constructor-ax 57
;  :datatype-occurs-check   106
;  :datatype-splits         25
;  :decisions               254
;  :del-clause              3954
;  :final-checks            95
;  :interface-eqs           9
;  :max-generation          6
;  :max-memory              5.64
;  :memory                  5.63
;  :minimized-lits          8
;  :mk-bool-var             7317
;  :mk-clause               4072
;  :num-allocs              301145
;  :num-checks              234
;  :propagations            1692
;  :quant-instantiations    2313
;  :rlimit-count            486854)
; [eval] aloc(opt_get1(G), i2)
; [eval] opt_get1(G)
(push) ; 24
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 24
; Joined path conditions
(push) ; 24
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 25
(assert (not (< i2@229@00 (alen<Int> (opt_get1 $Snap.unit G@103@00)))))
(check-sat)
; unsat
(pop) ; 25
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               3097
;  :arith-add-rows          2130
;  :arith-assert-diseq      253
;  :arith-assert-lower      1079
;  :arith-assert-upper      614
;  :arith-bound-prop        219
;  :arith-conflicts         107
;  :arith-eq-adapter        522
;  :arith-fixed-eqs         338
;  :arith-offset-eqs        156
;  :arith-pivots            951
;  :conflicts               234
;  :datatype-accessor-ax    149
;  :datatype-constructor-ax 57
;  :datatype-occurs-check   106
;  :datatype-splits         25
;  :decisions               254
;  :del-clause              3954
;  :final-checks            95
;  :interface-eqs           9
;  :max-generation          6
;  :max-memory              5.64
;  :memory                  5.63
;  :minimized-lits          8
;  :mk-bool-var             7317
;  :mk-clause               4072
;  :num-allocs              301177
;  :num-checks              235
;  :propagations            1692
;  :quant-instantiations    2313
;  :rlimit-count            486884)
(assert (< i2@229@00 (alen<Int> (opt_get1 $Snap.unit G@103@00))))
(pop) ; 24
; Joined path conditions
(assert (< i2@229@00 (alen<Int> (opt_get1 $Snap.unit G@103@00))))
(declare-fun sm@232@00 ($Snap $Ref option<array> Int Int Int) $FVF<option<array>>)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      (< $Perm.No $k@177@00)
      false)
    (=
      ($FVF.lookup_option$array$ (sm@232@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r)))
  :pattern (($FVF.lookup_option$array$ (sm@232@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r))
  :qid |qp.fvfValDef67|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r)
  :pattern (($FVF.lookup_option$array$ (sm@232@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :qid |qp.fvfResTrgDef68|)))
(declare-const pm@233@00 $FPM)
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@233@00  $FPM) r)
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      $k@177@00
      $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@233@00  $FPM) r))
  :qid |qp.resPrmSumDef69|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@232@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@233@00  $FPM) r))
  :qid |qp.resTrgDef70|)))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@232@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@103@00) i2@229@00)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@103@00) i2@229@00)))
(push) ; 24
(assert (not (<
  $Perm.No
  ($FVF.perm_option$array$ (as pm@233@00  $FPM) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@103@00) i2@229@00)))))
(check-sat)
; unsat
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               3121
;  :arith-add-rows          2148
;  :arith-assert-diseq      254
;  :arith-assert-lower      1088
;  :arith-assert-upper      620
;  :arith-bound-prop        222
;  :arith-conflicts         108
;  :arith-eq-adapter        529
;  :arith-fixed-eqs         344
;  :arith-offset-eqs        156
;  :arith-pivots            957
;  :conflicts               235
;  :datatype-accessor-ax    149
;  :datatype-constructor-ax 57
;  :datatype-occurs-check   106
;  :datatype-splits         25
;  :decisions               254
;  :del-clause              3958
;  :final-checks            95
;  :interface-eqs           9
;  :max-generation          6
;  :max-memory              5.71
;  :memory                  5.70
;  :minimized-lits          8
;  :mk-bool-var             7442
;  :mk-clause               4154
;  :num-allocs              302640
;  :num-checks              236
;  :propagations            1701
;  :quant-instantiations    2373
;  :rlimit-count            490686)
(pop) ; 23
(push) ; 23
; [else-branch: 141 | !(i2@229@00 < V@104@00)]
(assert (not (< i2@229@00 V@104@00)))
(pop) ; 23
(pop) ; 22
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      (< $Perm.No $k@177@00)
      false)
    (=
      ($FVF.lookup_option$array$ (sm@230@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r)))
  :pattern (($FVF.lookup_option$array$ (sm@230@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r))
  :qid |qp.fvfValDef63|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r)
  :pattern (($FVF.lookup_option$array$ (sm@230@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :qid |qp.fvfResTrgDef64|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@231@00  $FPM) r)
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      $k@177@00
      $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@231@00  $FPM) r))
  :qid |qp.resPrmSumDef65|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@230@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@231@00  $FPM) r))
  :qid |qp.resTrgDef66|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      (< $Perm.No $k@177@00)
      false)
    (=
      ($FVF.lookup_option$array$ (sm@232@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r)))
  :pattern (($FVF.lookup_option$array$ (sm@232@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r))
  :qid |qp.fvfValDef67|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r)
  :pattern (($FVF.lookup_option$array$ (sm@232@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :qid |qp.fvfResTrgDef68|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@233@00  $FPM) r)
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      $k@177@00
      $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@233@00  $FPM) r))
  :qid |qp.resPrmSumDef69|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@232@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@233@00  $FPM) r))
  :qid |qp.resTrgDef70|)))
(assert (implies
  (< i2@229@00 V@104@00)
  (and
    (< i2@229@00 V@104@00)
    (< i1@228@00 (alen<Int> (opt_get1 $Snap.unit G@103@00)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@230@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@228@00)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@228@00))
    (< i2@229@00 (alen<Int> (opt_get1 $Snap.unit G@103@00)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@232@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@103@00) i2@229@00)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@103@00) i2@229@00)))))
; Joined path conditions
(pop) ; 21
(push) ; 21
; [else-branch: 140 | !(0 <= i2@229@00)]
(assert (not (<= 0 i2@229@00)))
(pop) ; 21
(pop) ; 20
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      (< $Perm.No $k@177@00)
      false)
    (=
      ($FVF.lookup_option$array$ (sm@230@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r)))
  :pattern (($FVF.lookup_option$array$ (sm@230@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r))
  :qid |qp.fvfValDef63|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r)
  :pattern (($FVF.lookup_option$array$ (sm@230@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :qid |qp.fvfResTrgDef64|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@231@00  $FPM) r)
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      $k@177@00
      $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@231@00  $FPM) r))
  :qid |qp.resPrmSumDef65|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@230@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@231@00  $FPM) r))
  :qid |qp.resTrgDef66|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      (< $Perm.No $k@177@00)
      false)
    (=
      ($FVF.lookup_option$array$ (sm@232@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r)))
  :pattern (($FVF.lookup_option$array$ (sm@232@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r))
  :qid |qp.fvfValDef67|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r)
  :pattern (($FVF.lookup_option$array$ (sm@232@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :qid |qp.fvfResTrgDef68|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@233@00  $FPM) r)
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      $k@177@00
      $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@233@00  $FPM) r))
  :qid |qp.resPrmSumDef69|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@232@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@233@00  $FPM) r))
  :qid |qp.resTrgDef70|)))
(assert (implies
  (<= 0 i2@229@00)
  (and
    (<= 0 i2@229@00)
    (implies
      (< i2@229@00 V@104@00)
      (and
        (< i2@229@00 V@104@00)
        (< i1@228@00 (alen<Int> (opt_get1 $Snap.unit G@103@00)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@230@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@228@00)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@228@00))
        (< i2@229@00 (alen<Int> (opt_get1 $Snap.unit G@103@00)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@232@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@103@00) i2@229@00)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@103@00) i2@229@00)))))))
; Joined path conditions
(pop) ; 19
(push) ; 19
; [else-branch: 139 | !(i1@228@00 < V@104@00)]
(assert (not (< i1@228@00 V@104@00)))
(pop) ; 19
(pop) ; 18
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      (< $Perm.No $k@177@00)
      false)
    (=
      ($FVF.lookup_option$array$ (sm@230@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r)))
  :pattern (($FVF.lookup_option$array$ (sm@230@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r))
  :qid |qp.fvfValDef63|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r)
  :pattern (($FVF.lookup_option$array$ (sm@230@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :qid |qp.fvfResTrgDef64|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@231@00  $FPM) r)
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      $k@177@00
      $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@231@00  $FPM) r))
  :qid |qp.resPrmSumDef65|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@230@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@231@00  $FPM) r))
  :qid |qp.resTrgDef66|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      (< $Perm.No $k@177@00)
      false)
    (=
      ($FVF.lookup_option$array$ (sm@232@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r)))
  :pattern (($FVF.lookup_option$array$ (sm@232@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r))
  :qid |qp.fvfValDef67|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r)
  :pattern (($FVF.lookup_option$array$ (sm@232@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :qid |qp.fvfResTrgDef68|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@233@00  $FPM) r)
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      $k@177@00
      $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@233@00  $FPM) r))
  :qid |qp.resPrmSumDef69|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@232@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@233@00  $FPM) r))
  :qid |qp.resTrgDef70|)))
(assert (implies
  (< i1@228@00 V@104@00)
  (and
    (< i1@228@00 V@104@00)
    (implies
      (<= 0 i2@229@00)
      (and
        (<= 0 i2@229@00)
        (implies
          (< i2@229@00 V@104@00)
          (and
            (< i2@229@00 V@104@00)
            (< i1@228@00 (alen<Int> (opt_get1 $Snap.unit G@103@00)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@230@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@228@00)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@228@00))
            (< i2@229@00 (alen<Int> (opt_get1 $Snap.unit G@103@00)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@232@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@103@00) i2@229@00)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@103@00) i2@229@00)))))))))
; Joined path conditions
(pop) ; 17
(push) ; 17
; [else-branch: 138 | !(0 <= i1@228@00)]
(assert (not (<= 0 i1@228@00)))
(pop) ; 17
(pop) ; 16
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      (< $Perm.No $k@177@00)
      false)
    (=
      ($FVF.lookup_option$array$ (sm@230@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r)))
  :pattern (($FVF.lookup_option$array$ (sm@230@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r))
  :qid |qp.fvfValDef63|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r)
  :pattern (($FVF.lookup_option$array$ (sm@230@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :qid |qp.fvfResTrgDef64|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@231@00  $FPM) r)
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      $k@177@00
      $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@231@00  $FPM) r))
  :qid |qp.resPrmSumDef65|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@230@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@231@00  $FPM) r))
  :qid |qp.resTrgDef66|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      (< $Perm.No $k@177@00)
      false)
    (=
      ($FVF.lookup_option$array$ (sm@232@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r)))
  :pattern (($FVF.lookup_option$array$ (sm@232@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r))
  :qid |qp.fvfValDef67|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r)
  :pattern (($FVF.lookup_option$array$ (sm@232@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :qid |qp.fvfResTrgDef68|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@233@00  $FPM) r)
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      $k@177@00
      $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@233@00  $FPM) r))
  :qid |qp.resPrmSumDef69|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@232@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@233@00  $FPM) r))
  :qid |qp.resTrgDef70|)))
(assert (implies
  (<= 0 i1@228@00)
  (and
    (<= 0 i1@228@00)
    (implies
      (< i1@228@00 V@104@00)
      (and
        (< i1@228@00 V@104@00)
        (implies
          (<= 0 i2@229@00)
          (and
            (<= 0 i2@229@00)
            (implies
              (< i2@229@00 V@104@00)
              (and
                (< i2@229@00 V@104@00)
                (< i1@228@00 (alen<Int> (opt_get1 $Snap.unit G@103@00)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@230@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@228@00)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@228@00))
                (< i2@229@00 (alen<Int> (opt_get1 $Snap.unit G@103@00)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@232@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@103@00) i2@229@00)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@103@00) i2@229@00)))))))))))
; Joined path conditions
(push) ; 16
; [then-branch: 142 | Lookup(option$array$,sm@230@00(s@$, this@102@00, G@103@00, V@104@00, s@105@00, t@106@00),aloc((_, _), opt_get1(_, G@103@00), i1@228@00)) == Lookup(option$array$,sm@232@00(s@$, this@102@00, G@103@00, V@104@00, s@105@00, t@106@00),aloc((_, _), opt_get1(_, G@103@00), i2@229@00)) && i2@229@00 < V@104@00 && 0 <= i2@229@00 && i1@228@00 < V@104@00 && 0 <= i1@228@00 | live]
; [else-branch: 142 | !(Lookup(option$array$,sm@230@00(s@$, this@102@00, G@103@00, V@104@00, s@105@00, t@106@00),aloc((_, _), opt_get1(_, G@103@00), i1@228@00)) == Lookup(option$array$,sm@232@00(s@$, this@102@00, G@103@00, V@104@00, s@105@00, t@106@00),aloc((_, _), opt_get1(_, G@103@00), i2@229@00)) && i2@229@00 < V@104@00 && 0 <= i2@229@00 && i1@228@00 < V@104@00 && 0 <= i1@228@00) | live]
(push) ; 17
; [then-branch: 142 | Lookup(option$array$,sm@230@00(s@$, this@102@00, G@103@00, V@104@00, s@105@00, t@106@00),aloc((_, _), opt_get1(_, G@103@00), i1@228@00)) == Lookup(option$array$,sm@232@00(s@$, this@102@00, G@103@00, V@104@00, s@105@00, t@106@00),aloc((_, _), opt_get1(_, G@103@00), i2@229@00)) && i2@229@00 < V@104@00 && 0 <= i2@229@00 && i1@228@00 < V@104@00 && 0 <= i1@228@00]
(assert (and
  (and
    (and
      (and
        (=
          ($FVF.lookup_option$array$ (sm@230@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@228@00))
          ($FVF.lookup_option$array$ (sm@232@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@103@00) i2@229@00)))
        (< i2@229@00 V@104@00))
      (<= 0 i2@229@00))
    (< i1@228@00 V@104@00))
  (<= 0 i1@228@00)))
; [eval] i1 == i2
(pop) ; 17
(push) ; 17
; [else-branch: 142 | !(Lookup(option$array$,sm@230@00(s@$, this@102@00, G@103@00, V@104@00, s@105@00, t@106@00),aloc((_, _), opt_get1(_, G@103@00), i1@228@00)) == Lookup(option$array$,sm@232@00(s@$, this@102@00, G@103@00, V@104@00, s@105@00, t@106@00),aloc((_, _), opt_get1(_, G@103@00), i2@229@00)) && i2@229@00 < V@104@00 && 0 <= i2@229@00 && i1@228@00 < V@104@00 && 0 <= i1@228@00)]
(assert (not
  (and
    (and
      (and
        (and
          (=
            ($FVF.lookup_option$array$ (sm@230@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@228@00))
            ($FVF.lookup_option$array$ (sm@232@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@103@00) i2@229@00)))
          (< i2@229@00 V@104@00))
        (<= 0 i2@229@00))
      (< i1@228@00 V@104@00))
    (<= 0 i1@228@00))))
(pop) ; 17
(pop) ; 16
; Joined path conditions
(assert (implies
  (and
    (and
      (and
        (and
          (=
            ($FVF.lookup_option$array$ (sm@230@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@228@00))
            ($FVF.lookup_option$array$ (sm@232@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@103@00) i2@229@00)))
          (< i2@229@00 V@104@00))
        (<= 0 i2@229@00))
      (< i1@228@00 V@104@00))
    (<= 0 i1@228@00))
  (and
    (=
      ($FVF.lookup_option$array$ (sm@230@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@228@00))
      ($FVF.lookup_option$array$ (sm@232@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@103@00) i2@229@00)))
    (< i2@229@00 V@104@00)
    (<= 0 i2@229@00)
    (< i1@228@00 V@104@00)
    (<= 0 i1@228@00))))
; Joined path conditions
(pop) ; 15
; Nested auxiliary terms: globals (aux)
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      (< $Perm.No $k@177@00)
      false)
    (=
      ($FVF.lookup_option$array$ (sm@230@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r)))
  :pattern (($FVF.lookup_option$array$ (sm@230@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r))
  :qid |qp.fvfValDef63|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r)
  :pattern (($FVF.lookup_option$array$ (sm@230@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :qid |qp.fvfResTrgDef64|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@231@00  $FPM) r)
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      $k@177@00
      $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@231@00  $FPM) r))
  :qid |qp.resPrmSumDef65|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@230@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@231@00  $FPM) r))
  :qid |qp.resTrgDef66|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      (< $Perm.No $k@177@00)
      false)
    (=
      ($FVF.lookup_option$array$ (sm@232@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r)))
  :pattern (($FVF.lookup_option$array$ (sm@232@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r))
  :qid |qp.fvfValDef67|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r)
  :pattern (($FVF.lookup_option$array$ (sm@232@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :qid |qp.fvfResTrgDef68|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@233@00  $FPM) r)
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      $k@177@00
      $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@233@00  $FPM) r))
  :qid |qp.resPrmSumDef69|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@232@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@233@00  $FPM) r))
  :qid |qp.resTrgDef70|)))
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i2@229@00 Int)) (!
  (and
    (implies
      (<= 0 i1@228@00)
      (and
        (<= 0 i1@228@00)
        (implies
          (< i1@228@00 V@104@00)
          (and
            (< i1@228@00 V@104@00)
            (implies
              (<= 0 i2@229@00)
              (and
                (<= 0 i2@229@00)
                (implies
                  (< i2@229@00 V@104@00)
                  (and
                    (< i2@229@00 V@104@00)
                    (< i1@228@00 (alen<Int> (opt_get1 $Snap.unit G@103@00)))
                    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@230@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@228@00)) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@228@00))
                    (< i2@229@00 (alen<Int> (opt_get1 $Snap.unit G@103@00)))
                    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@232@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit G@103@00) i2@229@00)) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit G@103@00) i2@229@00))))))))))
    (implies
      (and
        (and
          (and
            (and
              (=
                ($FVF.lookup_option$array$ (sm@230@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@228@00))
                ($FVF.lookup_option$array$ (sm@232@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@103@00) i2@229@00)))
              (< i2@229@00 V@104@00))
            (<= 0 i2@229@00))
          (< i1@228@00 V@104@00))
        (<= 0 i1@228@00))
      (and
        (=
          ($FVF.lookup_option$array$ (sm@230@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@228@00))
          ($FVF.lookup_option$array$ (sm@232@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@103@00) i2@229@00)))
        (< i2@229@00 V@104@00)
        (<= 0 i2@229@00)
        (< i1@228@00 V@104@00)
        (<= 0 i1@228@00))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@103@00) i2@229@00))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 14
; Nested auxiliary terms: globals (aux)
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      (< $Perm.No $k@177@00)
      false)
    (=
      ($FVF.lookup_option$array$ (sm@230@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r)))
  :pattern (($FVF.lookup_option$array$ (sm@230@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r))
  :qid |qp.fvfValDef63|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r)
  :pattern (($FVF.lookup_option$array$ (sm@230@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :qid |qp.fvfResTrgDef64|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@231@00  $FPM) r)
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      $k@177@00
      $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@231@00  $FPM) r))
  :qid |qp.resPrmSumDef65|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@230@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@231@00  $FPM) r))
  :qid |qp.resTrgDef66|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      (< $Perm.No $k@177@00)
      false)
    (=
      ($FVF.lookup_option$array$ (sm@232@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r)))
  :pattern (($FVF.lookup_option$array$ (sm@232@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r))
  :qid |qp.fvfValDef67|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r)
  :pattern (($FVF.lookup_option$array$ (sm@232@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :qid |qp.fvfResTrgDef68|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@233@00  $FPM) r)
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      $k@177@00
      $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@233@00  $FPM) r))
  :qid |qp.resPrmSumDef69|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@232@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@233@00  $FPM) r))
  :qid |qp.resTrgDef70|)))
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
; Nested auxiliary terms: non-globals (tlq)
(push) ; 14
(assert (not (forall ((i1@228@00 Int)) (!
  (forall ((i2@229@00 Int)) (!
    (implies
      (and
        (and
          (and
            (and
              (=
                ($FVF.lookup_option$array$ (sm@230@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@228@00))
                ($FVF.lookup_option$array$ (sm@232@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@103@00) i2@229@00)))
              (< i2@229@00 V@104@00))
            (<= 0 i2@229@00))
          (< i1@228@00 V@104@00))
        (<= 0 i1@228@00))
      (= i1@228@00 i2@229@00))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@103@00) i2@229@00))
    :qid |prog.l<no position>|))
  
  :qid |prog.l<no position>|))))
(check-sat)
; unsat
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               3225
;  :arith-add-rows          2238
;  :arith-assert-diseq      256
;  :arith-assert-lower      1109
;  :arith-assert-upper      634
;  :arith-bound-prop        233
;  :arith-conflicts         110
;  :arith-eq-adapter        541
;  :arith-fixed-eqs         355
;  :arith-offset-eqs        164
;  :arith-pivots            999
;  :conflicts               242
;  :datatype-accessor-ax    149
;  :datatype-constructor-ax 59
;  :datatype-occurs-check   106
;  :datatype-splits         25
;  :decisions               260
;  :del-clause              4265
;  :final-checks            95
;  :interface-eqs           9
;  :max-generation          6
;  :max-memory              5.72
;  :memory                  5.70
;  :minimized-lits          8
;  :mk-bool-var             7703
;  :mk-clause               4321
;  :num-allocs              307745
;  :num-checks              237
;  :propagations            1757
;  :quant-instantiations    2485
;  :rlimit-count            503230
;  :time                    0.00)
(assert (forall ((i1@228@00 Int)) (!
  (forall ((i2@229@00 Int)) (!
    (implies
      (and
        (and
          (and
            (and
              (=
                ($FVF.lookup_option$array$ (sm@230@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@228@00))
                ($FVF.lookup_option$array$ (sm@232@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@103@00) i2@229@00)))
              (< i2@229@00 V@104@00))
            (<= 0 i2@229@00))
          (< i1@228@00 V@104@00))
        (<= 0 i1@228@00))
      (= i1@228@00 i2@229@00))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@103@00) i2@229@00))
    :qid |prog.l<no position>|))
  
  :qid |prog.l<no position>|)))
(declare-const i1@234@00 Int)
(declare-const j@235@00 Int)
(push) ; 14
; [eval] 0 <= i1 && i1 < V && (0 <= j && j < V)
; [eval] 0 <= i1
(push) ; 15
; [then-branch: 143 | 0 <= i1@234@00 | live]
; [else-branch: 143 | !(0 <= i1@234@00) | live]
(push) ; 16
; [then-branch: 143 | 0 <= i1@234@00]
(assert (<= 0 i1@234@00))
; [eval] i1 < V
(push) ; 17
; [then-branch: 144 | i1@234@00 < V@104@00 | live]
; [else-branch: 144 | !(i1@234@00 < V@104@00) | live]
(push) ; 18
; [then-branch: 144 | i1@234@00 < V@104@00]
(assert (< i1@234@00 V@104@00))
; [eval] 0 <= j
(push) ; 19
; [then-branch: 145 | 0 <= j@235@00 | live]
; [else-branch: 145 | !(0 <= j@235@00) | live]
(push) ; 20
; [then-branch: 145 | 0 <= j@235@00]
(assert (<= 0 j@235@00))
; [eval] j < V
(pop) ; 20
(push) ; 20
; [else-branch: 145 | !(0 <= j@235@00)]
(assert (not (<= 0 j@235@00)))
(pop) ; 20
(pop) ; 19
; Joined path conditions
; Joined path conditions
(pop) ; 18
(push) ; 18
; [else-branch: 144 | !(i1@234@00 < V@104@00)]
(assert (not (< i1@234@00 V@104@00)))
(pop) ; 18
(pop) ; 17
; Joined path conditions
; Joined path conditions
(pop) ; 16
(push) ; 16
; [else-branch: 143 | !(0 <= i1@234@00)]
(assert (not (<= 0 i1@234@00)))
(pop) ; 16
(pop) ; 15
; Joined path conditions
; Joined path conditions
(assert (and
  (and (and (< j@235@00 V@104@00) (<= 0 j@235@00)) (< i1@234@00 V@104@00))
  (<= 0 i1@234@00)))
(declare-const $k@236@00 $Perm)
(assert ($Perm.isReadVar $k@236@00 $Perm.Write))
; [eval] aloc(opt_get1(aloc(opt_get1(G), i1).option$array$), j)
; [eval] opt_get1(aloc(opt_get1(G), i1).option$array$)
; [eval] aloc(opt_get1(G), i1)
; [eval] opt_get1(G)
(push) ; 15
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 15
; Joined path conditions
(push) ; 15
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 16
(assert (not (< i1@234@00 (alen<Int> (opt_get1 $Snap.unit G@103@00)))))
(check-sat)
; unsat
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               3225
;  :arith-add-rows          2241
;  :arith-assert-diseq      257
;  :arith-assert-lower      1117
;  :arith-assert-upper      635
;  :arith-bound-prop        233
;  :arith-conflicts         110
;  :arith-eq-adapter        542
;  :arith-fixed-eqs         355
;  :arith-offset-eqs        164
;  :arith-pivots            999
;  :conflicts               242
;  :datatype-accessor-ax    149
;  :datatype-constructor-ax 59
;  :datatype-occurs-check   106
;  :datatype-splits         25
;  :decisions               260
;  :del-clause              4265
;  :final-checks            95
;  :interface-eqs           9
;  :max-generation          6
;  :max-memory              5.72
;  :memory                  5.70
;  :minimized-lits          8
;  :mk-bool-var             7714
;  :mk-clause               4323
;  :num-allocs              308429
;  :num-checks              238
;  :propagations            1758
;  :quant-instantiations    2485
;  :rlimit-count            504358)
(assert (< i1@234@00 (alen<Int> (opt_get1 $Snap.unit G@103@00))))
(pop) ; 15
; Joined path conditions
(assert (< i1@234@00 (alen<Int> (opt_get1 $Snap.unit G@103@00))))
(declare-fun sm@237@00 ($Snap $Ref option<array> Int Int Int) $FVF<option<array>>)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      (< $Perm.No $k@177@00)
      false)
    (=
      ($FVF.lookup_option$array$ (sm@237@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r)))
  :pattern (($FVF.lookup_option$array$ (sm@237@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r))
  :qid |qp.fvfValDef71|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r)
  :pattern (($FVF.lookup_option$array$ (sm@237@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :qid |qp.fvfResTrgDef72|)))
(declare-const pm@238@00 $FPM)
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@238@00  $FPM) r)
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      $k@177@00
      $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@238@00  $FPM) r))
  :qid |qp.resPrmSumDef73|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@237@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@238@00  $FPM) r))
  :qid |qp.resTrgDef74|)))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@237@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@234@00)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@234@00)))
(push) ; 15
(assert (not (<
  $Perm.No
  ($FVF.perm_option$array$ (as pm@238@00  $FPM) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@234@00)))))
(check-sat)
; unsat
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               3250
;  :arith-add-rows          2257
;  :arith-assert-diseq      258
;  :arith-assert-lower      1126
;  :arith-assert-upper      641
;  :arith-bound-prop        236
;  :arith-conflicts         111
;  :arith-eq-adapter        548
;  :arith-fixed-eqs         361
;  :arith-offset-eqs        164
;  :arith-pivots            1005
;  :conflicts               243
;  :datatype-accessor-ax    149
;  :datatype-constructor-ax 59
;  :datatype-occurs-check   106
;  :datatype-splits         25
;  :decisions               260
;  :del-clause              4269
;  :final-checks            95
;  :interface-eqs           9
;  :max-generation          6
;  :max-memory              5.73
;  :memory                  5.72
;  :minimized-lits          8
;  :mk-bool-var             7829
;  :mk-clause               4391
;  :num-allocs              309809
;  :num-checks              239
;  :propagations            1761
;  :quant-instantiations    2543
;  :rlimit-count            508004)
(push) ; 15
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 16
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (sm@237@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@234@00))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               3262
;  :arith-add-rows          2264
;  :arith-assert-diseq      258
;  :arith-assert-lower      1127
;  :arith-assert-upper      642
;  :arith-bound-prop        239
;  :arith-conflicts         112
;  :arith-eq-adapter        548
;  :arith-fixed-eqs         361
;  :arith-offset-eqs        169
;  :arith-pivots            1006
;  :conflicts               248
;  :datatype-accessor-ax    149
;  :datatype-constructor-ax 61
;  :datatype-occurs-check   106
;  :datatype-splits         25
;  :decisions               264
;  :del-clause              4272
;  :final-checks            95
;  :interface-eqs           9
;  :max-generation          6
;  :max-memory              5.73
;  :memory                  5.72
;  :minimized-lits          8
;  :mk-bool-var             7830
;  :mk-clause               4394
;  :num-allocs              309915
;  :num-checks              240
;  :propagations            1791
;  :quant-instantiations    2543
;  :rlimit-count            508352)
(assert (not
  (=
    ($FVF.lookup_option$array$ (sm@237@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@234@00))
    (as None<option<array>>  option<array>))))
(pop) ; 15
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (sm@237@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@234@00))
    (as None<option<array>>  option<array>))))
(push) ; 15
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 16
(assert (not (<
  j@235@00
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@237@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@234@00)))))))
(check-sat)
; unsat
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               3355
;  :arith-add-rows          2278
;  :arith-assert-diseq      258
;  :arith-assert-lower      1131
;  :arith-assert-upper      644
;  :arith-bound-prop        242
;  :arith-conflicts         114
;  :arith-eq-adapter        551
;  :arith-fixed-eqs         362
;  :arith-offset-eqs        174
;  :arith-pivots            1010
;  :conflicts               253
;  :datatype-accessor-ax    149
;  :datatype-constructor-ax 63
;  :datatype-occurs-check   106
;  :datatype-splits         25
;  :decisions               268
;  :del-clause              4278
;  :final-checks            95
;  :interface-eqs           9
;  :max-generation          6
;  :max-memory              5.73
;  :memory                  5.72
;  :minimized-lits          8
;  :mk-bool-var             7852
;  :mk-clause               4400
;  :num-allocs              310171
;  :num-checks              241
;  :propagations            1847
;  :quant-instantiations    2550
;  :rlimit-count            509302)
(assert (<
  j@235@00
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@237@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@234@00))))))
(pop) ; 15
; Joined path conditions
(assert (<
  j@235@00
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@237@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@234@00))))))
(pop) ; 14
(declare-fun inv@239@00 ($Snap $Ref option<array> Int Int Int $Ref) Int)
(declare-fun inv@240@00 ($Snap $Ref option<array> Int Int Int $Ref) Int)
; Nested auxiliary terms: globals
(assert ($Perm.isReadVar $k@236@00 $Perm.Write))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      (< $Perm.No $k@177@00)
      false)
    (=
      ($FVF.lookup_option$array$ (sm@237@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r)))
  :pattern (($FVF.lookup_option$array$ (sm@237@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r))
  :qid |qp.fvfValDef71|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r)
  :pattern (($FVF.lookup_option$array$ (sm@237@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :qid |qp.fvfResTrgDef72|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@238@00  $FPM) r)
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      $k@177@00
      $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@238@00  $FPM) r))
  :qid |qp.resPrmSumDef73|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@237@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@238@00  $FPM) r))
  :qid |qp.resTrgDef74|)))
; Nested auxiliary terms: non-globals
(assert (forall ((i1@234@00 Int) (j@235@00 Int)) (!
  (and
    (< i1@234@00 (alen<Int> (opt_get1 $Snap.unit G@103@00)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@237@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@234@00)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@234@00))
    (not
      (=
        ($FVF.lookup_option$array$ (sm@237@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@234@00))
        (as None<option<array>>  option<array>)))
    (<
      j@235@00
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@237@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@234@00))))))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@237@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@234@00))) j@235@00))
  :qid |int-aux|)))
(push) ; 14
(assert (not (forall ((i1@234@00 Int) (j@235@00 Int)) (!
  (implies
    (and
      (and (and (< j@235@00 V@104@00) (<= 0 j@235@00)) (< i1@234@00 V@104@00))
      (<= 0 i1@234@00))
    (or (= $k@236@00 $Perm.No) (< $Perm.No $k@236@00)))
  
  ))))
(check-sat)
; unsat
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               3355
;  :arith-add-rows          2284
;  :arith-assert-diseq      259
;  :arith-assert-lower      1133
;  :arith-assert-upper      645
;  :arith-bound-prop        242
;  :arith-conflicts         114
;  :arith-eq-adapter        552
;  :arith-fixed-eqs         362
;  :arith-offset-eqs        174
;  :arith-pivots            1016
;  :conflicts               254
;  :datatype-accessor-ax    149
;  :datatype-constructor-ax 63
;  :datatype-occurs-check   106
;  :datatype-splits         25
;  :decisions               268
;  :del-clause              4344
;  :final-checks            95
;  :interface-eqs           9
;  :max-generation          6
;  :max-memory              5.73
;  :memory                  5.71
;  :minimized-lits          8
;  :mk-bool-var             7865
;  :mk-clause               4402
;  :num-allocs              311262
;  :num-checks              242
;  :propagations            1848
;  :quant-instantiations    2550
;  :rlimit-count            511453)
(declare-fun sm@241@00 ($Snap $Ref option<array> Int Int Int) $FVF<Int>)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and
        (and
          (and
            (<
              (inv@188@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
              V@104@00)
            (<=
              0
              (inv@188@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
          (<
            (inv@187@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
            V@104@00))
        (<= 0 (inv@187@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      (< $Perm.No $k@186@00)
      false)
    (=
      ($FVF.lookup_int (sm@241@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$)))))))) r)))
  :pattern (($FVF.lookup_int (sm@241@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$)))))))) r))
  :qid |qp.fvfValDef75|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$)))))))) r) r)
  :pattern (($FVF.lookup_int (sm@241@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :qid |qp.fvfResTrgDef76|)))
; Check receiver injectivity
(push) ; 14
(assert (not (forall ((i11@234@00 Int) (j1@235@00 Int) (i12@234@00 Int) (j2@235@00 Int)) (!
  (implies
    (and
      (and
        (and
          (and
            (and
              (and (< j1@235@00 V@104@00) (<= 0 j1@235@00))
              (< i11@234@00 V@104@00))
            (<= 0 i11@234@00))
          ($FVF.loc_int ($FVF.lookup_int (sm@241@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@237@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@103@00) i11@234@00))) j1@235@00)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@237@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@103@00) i11@234@00))) j1@235@00)))
        (< $Perm.No $k@236@00))
      (and
        (and
          (and
            (and
              (and (< j2@235@00 V@104@00) (<= 0 j2@235@00))
              (< i12@234@00 V@104@00))
            (<= 0 i12@234@00))
          ($FVF.loc_int ($FVF.lookup_int (sm@241@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@237@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@103@00) i12@234@00))) j2@235@00)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@237@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@103@00) i12@234@00))) j2@235@00)))
        (< $Perm.No $k@236@00))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@237@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@103@00) i11@234@00))) j1@235@00)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@237@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@103@00) i12@234@00))) j2@235@00)))
    (and (= i11@234@00 i12@234@00) (= j1@235@00 j2@235@00)))
  
  :qid |int-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               3593
;  :arith-add-rows          2426
;  :arith-assert-diseq      261
;  :arith-assert-lower      1172
;  :arith-assert-upper      674
;  :arith-bound-prop        256
;  :arith-conflicts         117
;  :arith-eq-adapter        575
;  :arith-fixed-eqs         382
;  :arith-offset-eqs        194
;  :arith-pivots            1065
;  :conflicts               262
;  :datatype-accessor-ax    149
;  :datatype-constructor-ax 65
;  :datatype-occurs-check   106
;  :datatype-splits         25
;  :decisions               277
;  :del-clause              4587
;  :final-checks            95
;  :interface-eqs           9
;  :max-generation          6
;  :max-memory              5.89
;  :memory                  5.86
;  :minimized-lits          8
;  :mk-bool-var             8250
;  :mk-clause               4645
;  :num-allocs              313929
;  :num-checks              243
;  :propagations            1969
;  :quant-instantiations    2709
;  :rlimit-count            521650
;  :time                    0.00)
; Definitional axioms for inverse functions
(assert (forall ((i1@234@00 Int) (j@235@00 Int)) (!
  (implies
    (and
      (and
        (and (and (< j@235@00 V@104@00) (<= 0 j@235@00)) (< i1@234@00 V@104@00))
        (<= 0 i1@234@00))
      (< $Perm.No $k@236@00))
    (and
      (=
        (inv@239@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@237@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@234@00))) j@235@00))
        i1@234@00)
      (=
        (inv@240@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@237@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@234@00))) j@235@00))
        j@235@00)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@237@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@234@00))) j@235@00))
  :qid |int-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and
          (and
            (<
              (inv@240@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
              V@104@00)
            (<=
              0
              (inv@240@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
          (<
            (inv@239@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
            V@104@00))
        (<= 0 (inv@239@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      (< $Perm.No $k@236@00))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@237@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@103@00) (inv@239@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))) (inv@240@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
      r))
  :pattern ((inv@239@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
  :pattern ((inv@240@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and
          (<
            (inv@240@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
            V@104@00)
          (<=
            0
            (inv@240@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
        (<
          (inv@239@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00))
      (<= 0 (inv@239@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
    ($FVF.loc_int ($FVF.lookup_int (sm@241@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r) r))
  :pattern ((inv@239@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r) (inv@240@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
  )))
; Precomputing data for removing quantified permissions
(define-fun pTaken@242@00 ((r $Ref) (s@$ $Snap) (this@102@00 $Ref) (G@103@00 option<array>) (V@104@00 Int) (s@105@00 Int) (t@106@00 Int)) $Perm
  (ite
    (and
      (and
        (and
          (<
            (inv@240@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
            V@104@00)
          (<=
            0
            (inv@240@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
        (<
          (inv@239@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00))
      (<= 0 (inv@239@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
    ($Perm.min
      (ite
        (and
          (and
            (and
              (<
                (inv@188@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                V@104@00)
              (<=
                0
                (inv@188@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
            (<
              (inv@187@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
              V@104@00))
          (<=
            0
            (inv@187@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
        $k@186@00
        $Perm.No)
      $k@236@00)
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Constrain original permissions $k@236@00
(assert (forall ((r $Ref)) (!
  (implies
    (not
      (=
        (ite
          (and
            (and
              (and
                (<
                  (inv@188@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                  V@104@00)
                (<=
                  0
                  (inv@188@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
              (<
                (inv@187@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                V@104@00))
            (<=
              0
              (inv@187@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
          $k@186@00
          $Perm.No)
        $Perm.No))
    (ite
      (and
        (and
          (and
            (<
              (inv@188@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
              V@104@00)
            (<=
              0
              (inv@188@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
          (<
            (inv@187@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
            V@104@00))
        (<= 0 (inv@187@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      (<
        (ite
          (and
            (and
              (and
                (<
                  (inv@240@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                  V@104@00)
                (<=
                  0
                  (inv@240@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
              (<
                (inv@239@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                V@104@00))
            (<=
              0
              (inv@239@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
          $k@236@00
          $Perm.No)
        $k@186@00)
      (<
        (ite
          (and
            (and
              (and
                (<
                  (inv@240@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                  V@104@00)
                (<=
                  0
                  (inv@240@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
              (<
                (inv@239@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                V@104@00))
            (<=
              0
              (inv@239@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
          $k@236@00
          $Perm.No)
        $Perm.No)))
  :pattern ((inv@188@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
  :pattern ((inv@187@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
  :pattern ((inv@240@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
  :pattern ((inv@239@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
  :qid |qp.srp77|)))
; Intermediate check if already taken enough permissions
(set-option :timeout 500)
(push) ; 14
(assert (not (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and
          (<
            (inv@240@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
            V@104@00)
          (<=
            0
            (inv@240@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
        (<
          (inv@239@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00))
      (<= 0 (inv@239@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
    (=
      (-
        $k@236@00
        (pTaken@242@00 r s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00))
      $Perm.No))
  
  ))))
(check-sat)
; unsat
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               3938
;  :arith-add-rows          2597
;  :arith-assert-diseq      270
;  :arith-assert-lower      1228
;  :arith-assert-upper      709
;  :arith-bound-prop        272
;  :arith-conflicts         124
;  :arith-eq-adapter        619
;  :arith-fixed-eqs         406
;  :arith-offset-eqs        224
;  :arith-pivots            1120
;  :conflicts               274
;  :datatype-accessor-ax    149
;  :datatype-constructor-ax 71
;  :datatype-occurs-check   117
;  :datatype-splits         27
;  :decisions               293
;  :del-clause              4857
;  :final-checks            97
;  :interface-eqs           9
;  :max-generation          6
;  :max-memory              5.91
;  :memory                  5.89
;  :minimized-lits          10
;  :mk-bool-var             8669
;  :mk-clause               4915
;  :num-allocs              317698
;  :num-checks              245
;  :propagations            2117
;  :quant-instantiations    2842
;  :rlimit-count            532945
;  :time                    0.00)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-fun sm@243@00 ($Snap $Ref option<array> Int Int Int) $FVF<Int>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (iff
    (Set_in r ($FVF.domain_int (sm@243@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00)))
    (and
      (and
        (and
          (and
            (<
              (inv@240@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
              V@104@00)
            (<=
              0
              (inv@240@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
          (<
            (inv@239@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
            V@104@00))
        (<= 0 (inv@239@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      (< $Perm.No $k@236@00)))
  :pattern ((Set_in r ($FVF.domain_int (sm@243@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00))))
  :qid |qp.fvfDomDef80|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and
          (and
            (and
              (<
                (inv@240@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                V@104@00)
              (<=
                0
                (inv@240@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
            (<
              (inv@239@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
              V@104@00))
          (<=
            0
            (inv@239@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
        (< $Perm.No $k@236@00))
      (ite
        (and
          (and
            (and
              (<
                (inv@188@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                V@104@00)
              (<=
                0
                (inv@188@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
            (<
              (inv@187@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
              V@104@00))
          (<=
            0
            (inv@187@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
        (< $Perm.No $k@186@00)
        false))
    (=
      ($FVF.lookup_int (sm@243@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$)))))))) r)))
  :pattern (($FVF.lookup_int (sm@243@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$)))))))) r))
  :qid |qp.fvfValDef78|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$)))))))) r) r)
  :pattern (($FVF.lookup_int (sm@243@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :qid |qp.fvfResTrgDef79|)))
(pop) ; 13
; Joined path conditions
(assert ($Perm.isReadVar $k@217@00 $Perm.Write))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      (< $Perm.No $k@177@00)
      false)
    (=
      ($FVF.lookup_option$array$ (sm@219@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r)))
  :pattern (($FVF.lookup_option$array$ (sm@219@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r))
  :qid |qp.fvfValDef49|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r)
  :pattern (($FVF.lookup_option$array$ (sm@219@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :qid |qp.fvfResTrgDef50|)))
(assert (forall ((i1@216@00 Int)) (!
  (implies
    (and (and (< i1@216@00 V@104@00) (<= 0 i1@216@00)) (< $Perm.No $k@217@00))
    (=
      (inv@218@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@216@00))
      i1@216@00))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@216@00))
  :qid |option$array$-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (<
          (inv@218@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@218@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      (< $Perm.No $k@217@00))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@103@00) (inv@218@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
      r))
  :pattern ((inv@218@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
  :qid |option$array$-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (iff
    (Set_in r ($FVF.domain_option$array$ (sm@221@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00)))
    (and
      (and
        (<
          (inv@218@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@218@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      (< $Perm.No $k@217@00)))
  :pattern ((Set_in r ($FVF.domain_option$array$ (sm@221@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00))))
  :qid |qp.fvfDomDef54|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and
          (<
            (inv@218@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
            V@104@00)
          (<=
            0
            (inv@218@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
        (< $Perm.No $k@217@00))
      (ite
        (and
          (<
            (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
            V@104@00)
          (<=
            0
            (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
        (< $Perm.No $k@177@00)
        false))
    (=
      ($FVF.lookup_option$array$ (sm@221@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r)))
  :pattern (($FVF.lookup_option$array$ (sm@221@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r))
  :qid |qp.fvfValDef52|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r)
  :pattern (($FVF.lookup_option$array$ (sm@221@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :qid |qp.fvfResTrgDef53|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      (< $Perm.No $k@177@00)
      false)
    (=
      ($FVF.lookup_option$array$ (sm@223@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r)))
  :pattern (($FVF.lookup_option$array$ (sm@223@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r))
  :qid |qp.fvfValDef55|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r)
  :pattern (($FVF.lookup_option$array$ (sm@223@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :qid |qp.fvfResTrgDef56|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@224@00  $FPM) r)
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      $k@177@00
      $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@224@00  $FPM) r))
  :qid |qp.resPrmSumDef57|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@223@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@224@00  $FPM) r))
  :qid |qp.resTrgDef58|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      (< $Perm.No $k@177@00)
      false)
    (=
      ($FVF.lookup_option$array$ (sm@226@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r)))
  :pattern (($FVF.lookup_option$array$ (sm@226@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r))
  :qid |qp.fvfValDef59|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r)
  :pattern (($FVF.lookup_option$array$ (sm@226@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :qid |qp.fvfResTrgDef60|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@227@00  $FPM) r)
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      $k@177@00
      $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@227@00  $FPM) r))
  :qid |qp.resPrmSumDef61|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@226@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@227@00  $FPM) r))
  :qid |qp.resTrgDef62|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      (< $Perm.No $k@177@00)
      false)
    (=
      ($FVF.lookup_option$array$ (sm@230@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r)))
  :pattern (($FVF.lookup_option$array$ (sm@230@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r))
  :qid |qp.fvfValDef63|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r)
  :pattern (($FVF.lookup_option$array$ (sm@230@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :qid |qp.fvfResTrgDef64|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@231@00  $FPM) r)
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      $k@177@00
      $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@231@00  $FPM) r))
  :qid |qp.resPrmSumDef65|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@230@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@231@00  $FPM) r))
  :qid |qp.resTrgDef66|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      (< $Perm.No $k@177@00)
      false)
    (=
      ($FVF.lookup_option$array$ (sm@232@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r)))
  :pattern (($FVF.lookup_option$array$ (sm@232@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r))
  :qid |qp.fvfValDef67|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r)
  :pattern (($FVF.lookup_option$array$ (sm@232@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :qid |qp.fvfResTrgDef68|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@233@00  $FPM) r)
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      $k@177@00
      $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@233@00  $FPM) r))
  :qid |qp.resPrmSumDef69|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@232@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@233@00  $FPM) r))
  :qid |qp.resTrgDef70|)))
(assert ($Perm.isReadVar $k@236@00 $Perm.Write))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      (< $Perm.No $k@177@00)
      false)
    (=
      ($FVF.lookup_option$array$ (sm@237@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r)))
  :pattern (($FVF.lookup_option$array$ (sm@237@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r))
  :qid |qp.fvfValDef71|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r)
  :pattern (($FVF.lookup_option$array$ (sm@237@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :qid |qp.fvfResTrgDef72|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@238@00  $FPM) r)
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      $k@177@00
      $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@238@00  $FPM) r))
  :qid |qp.resPrmSumDef73|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@237@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@238@00  $FPM) r))
  :qid |qp.resTrgDef74|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and
        (and
          (and
            (<
              (inv@188@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
              V@104@00)
            (<=
              0
              (inv@188@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
          (<
            (inv@187@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
            V@104@00))
        (<= 0 (inv@187@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      (< $Perm.No $k@186@00)
      false)
    (=
      ($FVF.lookup_int (sm@241@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$)))))))) r)))
  :pattern (($FVF.lookup_int (sm@241@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$)))))))) r))
  :qid |qp.fvfValDef75|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$)))))))) r) r)
  :pattern (($FVF.lookup_int (sm@241@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :qid |qp.fvfResTrgDef76|)))
(assert (forall ((i1@234@00 Int) (j@235@00 Int)) (!
  (implies
    (and
      (and
        (and (and (< j@235@00 V@104@00) (<= 0 j@235@00)) (< i1@234@00 V@104@00))
        (<= 0 i1@234@00))
      (< $Perm.No $k@236@00))
    (and
      (=
        (inv@239@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@237@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@234@00))) j@235@00))
        i1@234@00)
      (=
        (inv@240@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@237@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@234@00))) j@235@00))
        j@235@00)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@237@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@234@00))) j@235@00))
  :qid |int-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and
          (and
            (<
              (inv@240@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
              V@104@00)
            (<=
              0
              (inv@240@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
          (<
            (inv@239@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
            V@104@00))
        (<= 0 (inv@239@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      (< $Perm.No $k@236@00))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@237@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@103@00) (inv@239@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))) (inv@240@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
      r))
  :pattern ((inv@239@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
  :pattern ((inv@240@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (iff
    (Set_in r ($FVF.domain_int (sm@243@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00)))
    (and
      (and
        (and
          (and
            (<
              (inv@240@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
              V@104@00)
            (<=
              0
              (inv@240@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
          (<
            (inv@239@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
            V@104@00))
        (<= 0 (inv@239@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      (< $Perm.No $k@236@00)))
  :pattern ((Set_in r ($FVF.domain_int (sm@243@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00))))
  :qid |qp.fvfDomDef80|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and
          (and
            (and
              (<
                (inv@240@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                V@104@00)
              (<=
                0
                (inv@240@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
            (<
              (inv@239@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
              V@104@00))
          (<=
            0
            (inv@239@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
        (< $Perm.No $k@236@00))
      (ite
        (and
          (and
            (and
              (<
                (inv@188@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                V@104@00)
              (<=
                0
                (inv@188@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
            (<
              (inv@187@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
              V@104@00))
          (<=
            0
            (inv@187@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
        (< $Perm.No $k@186@00)
        false))
    (=
      ($FVF.lookup_int (sm@243@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$)))))))) r)))
  :pattern (($FVF.lookup_int (sm@243@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$)))))))) r))
  :qid |qp.fvfValDef78|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$)))))))) r) r)
  :pattern (($FVF.lookup_int (sm@243@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :qid |qp.fvfResTrgDef79|)))
(assert (and
  (forall ((i1@216@00 Int)) (!
    (< i1@216@00 (alen<Int> (opt_get1 $Snap.unit G@103@00)))
    :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@216@00))
    :qid |option$array$-aux|))
  (forall ((r $Ref)) (!
    (implies
      (and
        (<
          (inv@218@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@218@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@219@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r) r))
    :pattern ((inv@218@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
    ))
  (forall ((r $Ref)) (!
    (implies
      (not
        (=
          (ite
            (and
              (<
                (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                V@104@00)
              (<=
                0
                (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
            $k@177@00
            $Perm.No)
          $Perm.No))
      (ite
        (and
          (<
            (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
            V@104@00)
          (<=
            0
            (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
        (<
          (ite
            (and
              (<
                (inv@218@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                V@104@00)
              (<=
                0
                (inv@218@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
            $k@217@00
            $Perm.No)
          $k@177@00)
        (<
          (ite
            (and
              (<
                (inv@218@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                V@104@00)
              (<=
                0
                (inv@218@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
            $k@217@00
            $Perm.No)
          $Perm.No)))
    :pattern ((inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
    :pattern ((inv@218@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
    :qid |qp.srp51|))
  (forall ((i1@222@00 Int)) (!
    (implies
      (and (< i1@222@00 V@104@00) (<= 0 i1@222@00))
      (not
        (=
          ($FVF.lookup_option$array$ (sm@223@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@222@00))
          (as None<option<array>>  option<array>))))
    
    :qid |prog.l<no position>|))
  (forall ((i1@225@00 Int)) (!
    (implies
      (and (< i1@225@00 V@104@00) (<= 0 i1@225@00))
      (=
        (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@226@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@225@00))))
        V@104@00))
    
    :qid |prog.l<no position>|))
  (forall ((i1@228@00 Int)) (!
    (forall ((i2@229@00 Int)) (!
      (implies
        (and
          (and
            (and
              (and
                (=
                  ($FVF.lookup_option$array$ (sm@230@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@228@00))
                  ($FVF.lookup_option$array$ (sm@232@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit G@103@00) i2@229@00)))
                (< i2@229@00 V@104@00))
              (<= 0 i2@229@00))
            (< i1@228@00 V@104@00))
          (<= 0 i1@228@00))
        (= i1@228@00 i2@229@00))
      :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@103@00) i2@229@00))
      :qid |prog.l<no position>|))
    
    :qid |prog.l<no position>|))
  (forall ((i1@234@00 Int) (j@235@00 Int)) (!
    (and
      (< i1@234@00 (alen<Int> (opt_get1 $Snap.unit G@103@00)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@237@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@234@00)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@234@00))
      (not
        (=
          ($FVF.lookup_option$array$ (sm@237@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@234@00))
          (as None<option<array>>  option<array>)))
      (<
        j@235@00
        (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@237@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@234@00))))))
    :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@237@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@234@00))) j@235@00))
    :qid |int-aux|))
  (forall ((r $Ref)) (!
    (implies
      (and
        (and
          (and
            (<
              (inv@240@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
              V@104@00)
            (<=
              0
              (inv@240@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
          (<
            (inv@239@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
            V@104@00))
        (<= 0 (inv@239@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      ($FVF.loc_int ($FVF.lookup_int (sm@241@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r) r))
    :pattern ((inv@239@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r) (inv@240@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
    ))
  (forall ((r $Ref)) (!
    (implies
      (not
        (=
          (ite
            (and
              (and
                (and
                  (<
                    (inv@188@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                    V@104@00)
                  (<=
                    0
                    (inv@188@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
                (<
                  (inv@187@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                  V@104@00))
              (<=
                0
                (inv@187@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
            $k@186@00
            $Perm.No)
          $Perm.No))
      (ite
        (and
          (and
            (and
              (<
                (inv@188@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                V@104@00)
              (<=
                0
                (inv@188@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
            (<
              (inv@187@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
              V@104@00))
          (<=
            0
            (inv@187@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
        (<
          (ite
            (and
              (and
                (and
                  (<
                    (inv@240@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                    V@104@00)
                  (<=
                    0
                    (inv@240@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
                (<
                  (inv@239@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                  V@104@00))
              (<=
                0
                (inv@239@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
            $k@236@00
            $Perm.No)
          $k@186@00)
        (<
          (ite
            (and
              (and
                (and
                  (<
                    (inv@240@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                    V@104@00)
                  (<=
                    0
                    (inv@240@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
                (<
                  (inv@239@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                  V@104@00))
              (<=
                0
                (inv@239@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
            $k@236@00
            $Perm.No)
          $Perm.No)))
    :pattern ((inv@188@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
    :pattern ((inv@187@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
    :pattern ((inv@240@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
    :pattern ((inv@239@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
    :qid |qp.srp77|))))
(set-option :timeout 0)
(push) ; 13
(assert (not (SquareIntMatrix1 ($Snap.combine
  $Snap.unit
  ($Snap.combine
    $Snap.unit
    ($Snap.combine
      $Snap.unit
      ($Snap.combine
        ($SortWrappers.$FVF<option<array>>To$Snap (sm@221@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00))
        ($Snap.combine
          $Snap.unit
          ($Snap.combine
            $Snap.unit
            ($Snap.combine
              $Snap.unit
              ($SortWrappers.$FVF<Int>To$Snap (sm@243@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00))))))))) this@102@00 G@103@00 V@104@00)))
(check-sat)
; unsat
(pop) ; 13
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               4561
;  :arith-add-rows          3079
;  :arith-assert-diseq      280
;  :arith-assert-lower      1332
;  :arith-assert-upper      779
;  :arith-bound-prop        330
;  :arith-conflicts         132
;  :arith-eq-adapter        675
;  :arith-fixed-eqs         456
;  :arith-offset-eqs        286
;  :arith-pivots            1242
;  :conflicts               292
;  :datatype-accessor-ax    157
;  :datatype-constructor-ax 77
;  :datatype-occurs-check   117
;  :datatype-splits         27
;  :decisions               364
;  :del-clause              6597
;  :final-checks            97
;  :interface-eqs           9
;  :max-generation          6
;  :max-memory              6.74
;  :memory                  6.64
;  :minimized-lits          10
;  :mk-bool-var             10641
;  :mk-clause               6657
;  :num-allocs              332307
;  :num-checks              246
;  :propagations            2549
;  :quant-instantiations    3455
;  :rlimit-count            574956
;  :time                    0.01)
(assert (SquareIntMatrix1 ($Snap.combine
  $Snap.unit
  ($Snap.combine
    $Snap.unit
    ($Snap.combine
      $Snap.unit
      ($Snap.combine
        ($SortWrappers.$FVF<option<array>>To$Snap (sm@221@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00))
        ($Snap.combine
          $Snap.unit
          ($Snap.combine
            $Snap.unit
            ($Snap.combine
              $Snap.unit
              ($SortWrappers.$FVF<Int>To$Snap (sm@243@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00))))))))) this@102@00 G@103@00 V@104@00))
(pop) ; 12
; Joined path conditions
(assert ($Perm.isReadVar $k@217@00 $Perm.Write))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      (< $Perm.No $k@177@00)
      false)
    (=
      ($FVF.lookup_option$array$ (sm@219@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r)))
  :pattern (($FVF.lookup_option$array$ (sm@219@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r))
  :qid |qp.fvfValDef49|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r)
  :pattern (($FVF.lookup_option$array$ (sm@219@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :qid |qp.fvfResTrgDef50|)))
(assert (forall ((i1@216@00 Int)) (!
  (implies
    (and (and (< i1@216@00 V@104@00) (<= 0 i1@216@00)) (< $Perm.No $k@217@00))
    (=
      (inv@218@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@216@00))
      i1@216@00))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@216@00))
  :qid |option$array$-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (<
          (inv@218@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@218@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      (< $Perm.No $k@217@00))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@103@00) (inv@218@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
      r))
  :pattern ((inv@218@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
  :qid |option$array$-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (iff
    (Set_in r ($FVF.domain_option$array$ (sm@221@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00)))
    (and
      (and
        (<
          (inv@218@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@218@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      (< $Perm.No $k@217@00)))
  :pattern ((Set_in r ($FVF.domain_option$array$ (sm@221@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00))))
  :qid |qp.fvfDomDef54|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and
          (<
            (inv@218@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
            V@104@00)
          (<=
            0
            (inv@218@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
        (< $Perm.No $k@217@00))
      (ite
        (and
          (<
            (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
            V@104@00)
          (<=
            0
            (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
        (< $Perm.No $k@177@00)
        false))
    (=
      ($FVF.lookup_option$array$ (sm@221@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r)))
  :pattern (($FVF.lookup_option$array$ (sm@221@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r))
  :qid |qp.fvfValDef52|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r)
  :pattern (($FVF.lookup_option$array$ (sm@221@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :qid |qp.fvfResTrgDef53|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      (< $Perm.No $k@177@00)
      false)
    (=
      ($FVF.lookup_option$array$ (sm@223@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r)))
  :pattern (($FVF.lookup_option$array$ (sm@223@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r))
  :qid |qp.fvfValDef55|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r)
  :pattern (($FVF.lookup_option$array$ (sm@223@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :qid |qp.fvfResTrgDef56|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@224@00  $FPM) r)
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      $k@177@00
      $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@224@00  $FPM) r))
  :qid |qp.resPrmSumDef57|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@223@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@224@00  $FPM) r))
  :qid |qp.resTrgDef58|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      (< $Perm.No $k@177@00)
      false)
    (=
      ($FVF.lookup_option$array$ (sm@226@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r)))
  :pattern (($FVF.lookup_option$array$ (sm@226@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r))
  :qid |qp.fvfValDef59|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r)
  :pattern (($FVF.lookup_option$array$ (sm@226@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :qid |qp.fvfResTrgDef60|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@227@00  $FPM) r)
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      $k@177@00
      $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@227@00  $FPM) r))
  :qid |qp.resPrmSumDef61|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@226@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@227@00  $FPM) r))
  :qid |qp.resTrgDef62|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      (< $Perm.No $k@177@00)
      false)
    (=
      ($FVF.lookup_option$array$ (sm@230@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r)))
  :pattern (($FVF.lookup_option$array$ (sm@230@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r))
  :qid |qp.fvfValDef63|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r)
  :pattern (($FVF.lookup_option$array$ (sm@230@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :qid |qp.fvfResTrgDef64|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@231@00  $FPM) r)
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      $k@177@00
      $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@231@00  $FPM) r))
  :qid |qp.resPrmSumDef65|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@230@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@231@00  $FPM) r))
  :qid |qp.resTrgDef66|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      (< $Perm.No $k@177@00)
      false)
    (=
      ($FVF.lookup_option$array$ (sm@232@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r)))
  :pattern (($FVF.lookup_option$array$ (sm@232@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r))
  :qid |qp.fvfValDef67|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r)
  :pattern (($FVF.lookup_option$array$ (sm@232@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :qid |qp.fvfResTrgDef68|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@233@00  $FPM) r)
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      $k@177@00
      $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@233@00  $FPM) r))
  :qid |qp.resPrmSumDef69|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@232@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@233@00  $FPM) r))
  :qid |qp.resTrgDef70|)))
(assert ($Perm.isReadVar $k@236@00 $Perm.Write))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      (< $Perm.No $k@177@00)
      false)
    (=
      ($FVF.lookup_option$array$ (sm@237@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r)))
  :pattern (($FVF.lookup_option$array$ (sm@237@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r))
  :qid |qp.fvfValDef71|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r)
  :pattern (($FVF.lookup_option$array$ (sm@237@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :qid |qp.fvfResTrgDef72|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@238@00  $FPM) r)
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      $k@177@00
      $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@238@00  $FPM) r))
  :qid |qp.resPrmSumDef73|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@237@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@238@00  $FPM) r))
  :qid |qp.resTrgDef74|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and
        (and
          (and
            (<
              (inv@188@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
              V@104@00)
            (<=
              0
              (inv@188@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
          (<
            (inv@187@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
            V@104@00))
        (<= 0 (inv@187@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      (< $Perm.No $k@186@00)
      false)
    (=
      ($FVF.lookup_int (sm@241@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$)))))))) r)))
  :pattern (($FVF.lookup_int (sm@241@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$)))))))) r))
  :qid |qp.fvfValDef75|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$)))))))) r) r)
  :pattern (($FVF.lookup_int (sm@241@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :qid |qp.fvfResTrgDef76|)))
(assert (forall ((i1@234@00 Int) (j@235@00 Int)) (!
  (implies
    (and
      (and
        (and (and (< j@235@00 V@104@00) (<= 0 j@235@00)) (< i1@234@00 V@104@00))
        (<= 0 i1@234@00))
      (< $Perm.No $k@236@00))
    (and
      (=
        (inv@239@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@237@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@234@00))) j@235@00))
        i1@234@00)
      (=
        (inv@240@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@237@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@234@00))) j@235@00))
        j@235@00)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@237@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@234@00))) j@235@00))
  :qid |int-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and
          (and
            (<
              (inv@240@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
              V@104@00)
            (<=
              0
              (inv@240@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
          (<
            (inv@239@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
            V@104@00))
        (<= 0 (inv@239@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      (< $Perm.No $k@236@00))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@237@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@103@00) (inv@239@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))) (inv@240@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
      r))
  :pattern ((inv@239@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
  :pattern ((inv@240@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (iff
    (Set_in r ($FVF.domain_int (sm@243@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00)))
    (and
      (and
        (and
          (and
            (<
              (inv@240@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
              V@104@00)
            (<=
              0
              (inv@240@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
          (<
            (inv@239@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
            V@104@00))
        (<= 0 (inv@239@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      (< $Perm.No $k@236@00)))
  :pattern ((Set_in r ($FVF.domain_int (sm@243@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00))))
  :qid |qp.fvfDomDef80|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and
          (and
            (and
              (<
                (inv@240@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                V@104@00)
              (<=
                0
                (inv@240@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
            (<
              (inv@239@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
              V@104@00))
          (<=
            0
            (inv@239@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
        (< $Perm.No $k@236@00))
      (ite
        (and
          (and
            (and
              (<
                (inv@188@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                V@104@00)
              (<=
                0
                (inv@188@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
            (<
              (inv@187@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
              V@104@00))
          (<=
            0
            (inv@187@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
        (< $Perm.No $k@186@00)
        false))
    (=
      ($FVF.lookup_int (sm@243@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$)))))))) r)))
  :pattern (($FVF.lookup_int (sm@243@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$)))))))) r))
  :qid |qp.fvfValDef78|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$)))))))) r) r)
  :pattern (($FVF.lookup_int (sm@243@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :qid |qp.fvfResTrgDef79|)))
(assert (and
  (forall ((i1@216@00 Int)) (!
    (< i1@216@00 (alen<Int> (opt_get1 $Snap.unit G@103@00)))
    :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@216@00))
    :qid |option$array$-aux|))
  (forall ((r $Ref)) (!
    (implies
      (and
        (<
          (inv@218@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@218@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@219@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r) r))
    :pattern ((inv@218@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
    ))
  (forall ((r $Ref)) (!
    (implies
      (not
        (=
          (ite
            (and
              (<
                (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                V@104@00)
              (<=
                0
                (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
            $k@177@00
            $Perm.No)
          $Perm.No))
      (ite
        (and
          (<
            (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
            V@104@00)
          (<=
            0
            (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
        (<
          (ite
            (and
              (<
                (inv@218@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                V@104@00)
              (<=
                0
                (inv@218@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
            $k@217@00
            $Perm.No)
          $k@177@00)
        (<
          (ite
            (and
              (<
                (inv@218@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                V@104@00)
              (<=
                0
                (inv@218@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
            $k@217@00
            $Perm.No)
          $Perm.No)))
    :pattern ((inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
    :pattern ((inv@218@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
    :qid |qp.srp51|))
  (forall ((i1@222@00 Int)) (!
    (implies
      (and (< i1@222@00 V@104@00) (<= 0 i1@222@00))
      (not
        (=
          ($FVF.lookup_option$array$ (sm@223@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@222@00))
          (as None<option<array>>  option<array>))))
    
    :qid |prog.l<no position>|))
  (forall ((i1@225@00 Int)) (!
    (implies
      (and (< i1@225@00 V@104@00) (<= 0 i1@225@00))
      (=
        (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@226@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@225@00))))
        V@104@00))
    
    :qid |prog.l<no position>|))
  (forall ((i1@228@00 Int)) (!
    (forall ((i2@229@00 Int)) (!
      (implies
        (and
          (and
            (and
              (and
                (=
                  ($FVF.lookup_option$array$ (sm@230@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@228@00))
                  ($FVF.lookup_option$array$ (sm@232@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit G@103@00) i2@229@00)))
                (< i2@229@00 V@104@00))
              (<= 0 i2@229@00))
            (< i1@228@00 V@104@00))
          (<= 0 i1@228@00))
        (= i1@228@00 i2@229@00))
      :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@103@00) i2@229@00))
      :qid |prog.l<no position>|))
    
    :qid |prog.l<no position>|))
  (forall ((i1@234@00 Int) (j@235@00 Int)) (!
    (and
      (< i1@234@00 (alen<Int> (opt_get1 $Snap.unit G@103@00)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@237@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@234@00)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@234@00))
      (not
        (=
          ($FVF.lookup_option$array$ (sm@237@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@234@00))
          (as None<option<array>>  option<array>)))
      (<
        j@235@00
        (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@237@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@234@00))))))
    :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@237@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@234@00))) j@235@00))
    :qid |int-aux|))
  (forall ((r $Ref)) (!
    (implies
      (and
        (and
          (and
            (<
              (inv@240@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
              V@104@00)
            (<=
              0
              (inv@240@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
          (<
            (inv@239@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
            V@104@00))
        (<= 0 (inv@239@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      ($FVF.loc_int ($FVF.lookup_int (sm@241@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r) r))
    :pattern ((inv@239@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r) (inv@240@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
    ))
  (forall ((r $Ref)) (!
    (implies
      (not
        (=
          (ite
            (and
              (and
                (and
                  (<
                    (inv@188@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                    V@104@00)
                  (<=
                    0
                    (inv@188@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
                (<
                  (inv@187@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                  V@104@00))
              (<=
                0
                (inv@187@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
            $k@186@00
            $Perm.No)
          $Perm.No))
      (ite
        (and
          (and
            (and
              (<
                (inv@188@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                V@104@00)
              (<=
                0
                (inv@188@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
            (<
              (inv@187@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
              V@104@00))
          (<=
            0
            (inv@187@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
        (<
          (ite
            (and
              (and
                (and
                  (<
                    (inv@240@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                    V@104@00)
                  (<=
                    0
                    (inv@240@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
                (<
                  (inv@239@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                  V@104@00))
              (<=
                0
                (inv@239@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
            $k@236@00
            $Perm.No)
          $k@186@00)
        (<
          (ite
            (and
              (and
                (and
                  (<
                    (inv@240@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                    V@104@00)
                  (<=
                    0
                    (inv@240@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
                (<
                  (inv@239@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                  V@104@00))
              (<=
                0
                (inv@239@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
            $k@236@00
            $Perm.No)
          $Perm.No)))
    :pattern ((inv@188@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
    :pattern ((inv@187@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
    :pattern ((inv@240@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
    :pattern ((inv@239@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
    :qid |qp.srp77|))
  (SquareIntMatrix1 ($Snap.combine
    $Snap.unit
    ($Snap.combine
      $Snap.unit
      ($Snap.combine
        $Snap.unit
        ($Snap.combine
          ($SortWrappers.$FVF<option<array>>To$Snap (sm@221@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00))
          ($Snap.combine
            $Snap.unit
            ($Snap.combine
              $Snap.unit
              ($Snap.combine
                $Snap.unit
                ($SortWrappers.$FVF<Int>To$Snap (sm@243@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00))))))))) this@102@00 G@103@00 V@104@00)))
(pop) ; 11
(push) ; 11
; [else-branch: 132 | !(SquareIntMatrix1((_, (_, (_, (sm@194@00(s@$, this@102@00, G@103@00, V@104@00, s@105@00, t@106@00), (_, (_, (_, sm@215@00(s@$, this@102@00, G@103@00, V@104@00, s@105@00, t@106@00)))))))), this@102@00, G@103@00, V@104@00))]
(assert (not
  (SquareIntMatrix1 ($Snap.combine
    $Snap.unit
    ($Snap.combine
      $Snap.unit
      ($Snap.combine
        $Snap.unit
        ($Snap.combine
          ($SortWrappers.$FVF<option<array>>To$Snap (sm@194@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00))
          ($Snap.combine
            $Snap.unit
            ($Snap.combine
              $Snap.unit
              ($Snap.combine
                $Snap.unit
                ($SortWrappers.$FVF<Int>To$Snap (sm@215@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00))))))))) this@102@00 G@103@00 V@104@00)))
(pop) ; 11
(pop) ; 10
; Joined path conditions
(assert ($Perm.isReadVar $k@217@00 $Perm.Write))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      (< $Perm.No $k@177@00)
      false)
    (=
      ($FVF.lookup_option$array$ (sm@219@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r)))
  :pattern (($FVF.lookup_option$array$ (sm@219@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r))
  :qid |qp.fvfValDef49|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r)
  :pattern (($FVF.lookup_option$array$ (sm@219@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :qid |qp.fvfResTrgDef50|)))
(assert (forall ((i1@216@00 Int)) (!
  (implies
    (and (and (< i1@216@00 V@104@00) (<= 0 i1@216@00)) (< $Perm.No $k@217@00))
    (=
      (inv@218@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@216@00))
      i1@216@00))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@216@00))
  :qid |option$array$-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (<
          (inv@218@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@218@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      (< $Perm.No $k@217@00))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@103@00) (inv@218@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
      r))
  :pattern ((inv@218@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
  :qid |option$array$-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (iff
    (Set_in r ($FVF.domain_option$array$ (sm@221@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00)))
    (and
      (and
        (<
          (inv@218@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@218@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      (< $Perm.No $k@217@00)))
  :pattern ((Set_in r ($FVF.domain_option$array$ (sm@221@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00))))
  :qid |qp.fvfDomDef54|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and
          (<
            (inv@218@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
            V@104@00)
          (<=
            0
            (inv@218@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
        (< $Perm.No $k@217@00))
      (ite
        (and
          (<
            (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
            V@104@00)
          (<=
            0
            (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
        (< $Perm.No $k@177@00)
        false))
    (=
      ($FVF.lookup_option$array$ (sm@221@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r)))
  :pattern (($FVF.lookup_option$array$ (sm@221@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r))
  :qid |qp.fvfValDef52|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r)
  :pattern (($FVF.lookup_option$array$ (sm@221@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :qid |qp.fvfResTrgDef53|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      (< $Perm.No $k@177@00)
      false)
    (=
      ($FVF.lookup_option$array$ (sm@223@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r)))
  :pattern (($FVF.lookup_option$array$ (sm@223@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r))
  :qid |qp.fvfValDef55|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r)
  :pattern (($FVF.lookup_option$array$ (sm@223@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :qid |qp.fvfResTrgDef56|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@224@00  $FPM) r)
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      $k@177@00
      $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@224@00  $FPM) r))
  :qid |qp.resPrmSumDef57|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@223@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@224@00  $FPM) r))
  :qid |qp.resTrgDef58|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      (< $Perm.No $k@177@00)
      false)
    (=
      ($FVF.lookup_option$array$ (sm@226@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r)))
  :pattern (($FVF.lookup_option$array$ (sm@226@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r))
  :qid |qp.fvfValDef59|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r)
  :pattern (($FVF.lookup_option$array$ (sm@226@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :qid |qp.fvfResTrgDef60|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@227@00  $FPM) r)
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      $k@177@00
      $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@227@00  $FPM) r))
  :qid |qp.resPrmSumDef61|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@226@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@227@00  $FPM) r))
  :qid |qp.resTrgDef62|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      (< $Perm.No $k@177@00)
      false)
    (=
      ($FVF.lookup_option$array$ (sm@230@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r)))
  :pattern (($FVF.lookup_option$array$ (sm@230@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r))
  :qid |qp.fvfValDef63|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r)
  :pattern (($FVF.lookup_option$array$ (sm@230@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :qid |qp.fvfResTrgDef64|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@231@00  $FPM) r)
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      $k@177@00
      $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@231@00  $FPM) r))
  :qid |qp.resPrmSumDef65|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@230@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@231@00  $FPM) r))
  :qid |qp.resTrgDef66|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      (< $Perm.No $k@177@00)
      false)
    (=
      ($FVF.lookup_option$array$ (sm@232@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r)))
  :pattern (($FVF.lookup_option$array$ (sm@232@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r))
  :qid |qp.fvfValDef67|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r)
  :pattern (($FVF.lookup_option$array$ (sm@232@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :qid |qp.fvfResTrgDef68|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@233@00  $FPM) r)
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      $k@177@00
      $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@233@00  $FPM) r))
  :qid |qp.resPrmSumDef69|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@232@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@233@00  $FPM) r))
  :qid |qp.resTrgDef70|)))
(assert ($Perm.isReadVar $k@236@00 $Perm.Write))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      (< $Perm.No $k@177@00)
      false)
    (=
      ($FVF.lookup_option$array$ (sm@237@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r)))
  :pattern (($FVF.lookup_option$array$ (sm@237@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r))
  :qid |qp.fvfValDef71|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r)
  :pattern (($FVF.lookup_option$array$ (sm@237@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :qid |qp.fvfResTrgDef72|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@238@00  $FPM) r)
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      $k@177@00
      $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@238@00  $FPM) r))
  :qid |qp.resPrmSumDef73|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@237@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@238@00  $FPM) r))
  :qid |qp.resTrgDef74|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and
        (and
          (and
            (<
              (inv@188@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
              V@104@00)
            (<=
              0
              (inv@188@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
          (<
            (inv@187@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
            V@104@00))
        (<= 0 (inv@187@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      (< $Perm.No $k@186@00)
      false)
    (=
      ($FVF.lookup_int (sm@241@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$)))))))) r)))
  :pattern (($FVF.lookup_int (sm@241@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$)))))))) r))
  :qid |qp.fvfValDef75|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$)))))))) r) r)
  :pattern (($FVF.lookup_int (sm@241@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :qid |qp.fvfResTrgDef76|)))
(assert (forall ((i1@234@00 Int) (j@235@00 Int)) (!
  (implies
    (and
      (and
        (and (and (< j@235@00 V@104@00) (<= 0 j@235@00)) (< i1@234@00 V@104@00))
        (<= 0 i1@234@00))
      (< $Perm.No $k@236@00))
    (and
      (=
        (inv@239@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@237@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@234@00))) j@235@00))
        i1@234@00)
      (=
        (inv@240@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@237@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@234@00))) j@235@00))
        j@235@00)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@237@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@234@00))) j@235@00))
  :qid |int-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and
          (and
            (<
              (inv@240@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
              V@104@00)
            (<=
              0
              (inv@240@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
          (<
            (inv@239@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
            V@104@00))
        (<= 0 (inv@239@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      (< $Perm.No $k@236@00))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@237@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@103@00) (inv@239@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))) (inv@240@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
      r))
  :pattern ((inv@239@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
  :pattern ((inv@240@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (iff
    (Set_in r ($FVF.domain_int (sm@243@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00)))
    (and
      (and
        (and
          (and
            (<
              (inv@240@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
              V@104@00)
            (<=
              0
              (inv@240@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
          (<
            (inv@239@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
            V@104@00))
        (<= 0 (inv@239@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      (< $Perm.No $k@236@00)))
  :pattern ((Set_in r ($FVF.domain_int (sm@243@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00))))
  :qid |qp.fvfDomDef80|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and
          (and
            (and
              (<
                (inv@240@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                V@104@00)
              (<=
                0
                (inv@240@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
            (<
              (inv@239@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
              V@104@00))
          (<=
            0
            (inv@239@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
        (< $Perm.No $k@236@00))
      (ite
        (and
          (and
            (and
              (<
                (inv@188@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                V@104@00)
              (<=
                0
                (inv@188@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
            (<
              (inv@187@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
              V@104@00))
          (<=
            0
            (inv@187@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
        (< $Perm.No $k@186@00)
        false))
    (=
      ($FVF.lookup_int (sm@243@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$)))))))) r)))
  :pattern (($FVF.lookup_int (sm@243@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$)))))))) r))
  :qid |qp.fvfValDef78|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$)))))))) r) r)
  :pattern (($FVF.lookup_int (sm@243@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :qid |qp.fvfResTrgDef79|)))
(assert (implies
  (SquareIntMatrix1 ($Snap.combine
    $Snap.unit
    ($Snap.combine
      $Snap.unit
      ($Snap.combine
        $Snap.unit
        ($Snap.combine
          ($SortWrappers.$FVF<option<array>>To$Snap (sm@194@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00))
          ($Snap.combine
            $Snap.unit
            ($Snap.combine
              $Snap.unit
              ($Snap.combine
                $Snap.unit
                ($SortWrappers.$FVF<Int>To$Snap (sm@215@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00))))))))) this@102@00 G@103@00 V@104@00)
  (and
    (SquareIntMatrix1 ($Snap.combine
      $Snap.unit
      ($Snap.combine
        $Snap.unit
        ($Snap.combine
          $Snap.unit
          ($Snap.combine
            ($SortWrappers.$FVF<option<array>>To$Snap (sm@194@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00))
            ($Snap.combine
              $Snap.unit
              ($Snap.combine
                $Snap.unit
                ($Snap.combine
                  $Snap.unit
                  ($SortWrappers.$FVF<Int>To$Snap (sm@215@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00))))))))) this@102@00 G@103@00 V@104@00)
    (forall ((i1@216@00 Int)) (!
      (< i1@216@00 (alen<Int> (opt_get1 $Snap.unit G@103@00)))
      :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@216@00))
      :qid |option$array$-aux|))
    (forall ((r $Ref)) (!
      (implies
        (and
          (<
            (inv@218@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
            V@104@00)
          (<=
            0
            (inv@218@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@219@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r) r))
      :pattern ((inv@218@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
      ))
    (forall ((r $Ref)) (!
      (implies
        (not
          (=
            (ite
              (and
                (<
                  (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                  V@104@00)
                (<=
                  0
                  (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
              $k@177@00
              $Perm.No)
            $Perm.No))
        (ite
          (and
            (<
              (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
              V@104@00)
            (<=
              0
              (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
          (<
            (ite
              (and
                (<
                  (inv@218@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                  V@104@00)
                (<=
                  0
                  (inv@218@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
              $k@217@00
              $Perm.No)
            $k@177@00)
          (<
            (ite
              (and
                (<
                  (inv@218@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                  V@104@00)
                (<=
                  0
                  (inv@218@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
              $k@217@00
              $Perm.No)
            $Perm.No)))
      :pattern ((inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
      :pattern ((inv@218@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
      :qid |qp.srp51|))
    (forall ((i1@222@00 Int)) (!
      (implies
        (and (< i1@222@00 V@104@00) (<= 0 i1@222@00))
        (not
          (=
            ($FVF.lookup_option$array$ (sm@223@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@222@00))
            (as None<option<array>>  option<array>))))
      
      :qid |prog.l<no position>|))
    (forall ((i1@225@00 Int)) (!
      (implies
        (and (< i1@225@00 V@104@00) (<= 0 i1@225@00))
        (=
          (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@226@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@225@00))))
          V@104@00))
      
      :qid |prog.l<no position>|))
    (forall ((i1@228@00 Int)) (!
      (forall ((i2@229@00 Int)) (!
        (implies
          (and
            (and
              (and
                (and
                  (=
                    ($FVF.lookup_option$array$ (sm@230@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@228@00))
                    ($FVF.lookup_option$array$ (sm@232@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit G@103@00) i2@229@00)))
                  (< i2@229@00 V@104@00))
                (<= 0 i2@229@00))
              (< i1@228@00 V@104@00))
            (<= 0 i1@228@00))
          (= i1@228@00 i2@229@00))
        :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@103@00) i2@229@00))
        :qid |prog.l<no position>|))
      
      :qid |prog.l<no position>|))
    (forall ((i1@234@00 Int) (j@235@00 Int)) (!
      (and
        (< i1@234@00 (alen<Int> (opt_get1 $Snap.unit G@103@00)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@237@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@234@00)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@234@00))
        (not
          (=
            ($FVF.lookup_option$array$ (sm@237@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@234@00))
            (as None<option<array>>  option<array>)))
        (<
          j@235@00
          (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@237@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@234@00))))))
      :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@237@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@234@00))) j@235@00))
      :qid |int-aux|))
    (forall ((r $Ref)) (!
      (implies
        (and
          (and
            (and
              (<
                (inv@240@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                V@104@00)
              (<=
                0
                (inv@240@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
            (<
              (inv@239@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
              V@104@00))
          (<=
            0
            (inv@239@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
        ($FVF.loc_int ($FVF.lookup_int (sm@241@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r) r))
      :pattern ((inv@239@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r) (inv@240@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
      ))
    (forall ((r $Ref)) (!
      (implies
        (not
          (=
            (ite
              (and
                (and
                  (and
                    (<
                      (inv@188@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                      V@104@00)
                    (<=
                      0
                      (inv@188@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
                  (<
                    (inv@187@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                    V@104@00))
                (<=
                  0
                  (inv@187@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
              $k@186@00
              $Perm.No)
            $Perm.No))
        (ite
          (and
            (and
              (and
                (<
                  (inv@188@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                  V@104@00)
                (<=
                  0
                  (inv@188@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
              (<
                (inv@187@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                V@104@00))
            (<=
              0
              (inv@187@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
          (<
            (ite
              (and
                (and
                  (and
                    (<
                      (inv@240@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                      V@104@00)
                    (<=
                      0
                      (inv@240@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
                  (<
                    (inv@239@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                    V@104@00))
                (<=
                  0
                  (inv@239@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
              $k@236@00
              $Perm.No)
            $k@186@00)
          (<
            (ite
              (and
                (and
                  (and
                    (<
                      (inv@240@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                      V@104@00)
                    (<=
                      0
                      (inv@240@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
                  (<
                    (inv@239@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                    V@104@00))
                (<=
                  0
                  (inv@239@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
              $k@236@00
              $Perm.No)
            $Perm.No)))
      :pattern ((inv@188@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
      :pattern ((inv@187@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
      :pattern ((inv@240@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
      :pattern ((inv@239@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
      :qid |qp.srp77|))
    (SquareIntMatrix1 ($Snap.combine
      $Snap.unit
      ($Snap.combine
        $Snap.unit
        ($Snap.combine
          $Snap.unit
          ($Snap.combine
            ($SortWrappers.$FVF<option<array>>To$Snap (sm@221@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00))
            ($Snap.combine
              $Snap.unit
              ($Snap.combine
                $Snap.unit
                ($Snap.combine
                  $Snap.unit
                  ($SortWrappers.$FVF<Int>To$Snap (sm@243@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00))))))))) this@102@00 G@103@00 V@104@00))))
; Joined path conditions
(pop) ; 9
(push) ; 9
; [else-branch: 118 | !(t@106@00 < V@104@00)]
(assert (not (< t@106@00 V@104@00)))
(pop) ; 9
(pop) ; 8
; Joined path conditions
(assert ($Perm.isReadVar $k@191@00 $Perm.Write))
(assert (forall ((i1@190@00 Int)) (!
  (implies
    (and (and (< i1@190@00 V@104@00) (<= 0 i1@190@00)) (< $Perm.No $k@191@00))
    (=
      (inv@192@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@190@00))
      i1@190@00))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@190@00))
  :qid |option$array$-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (<
          (inv@192@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@192@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      (< $Perm.No $k@191@00))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@103@00) (inv@192@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
      r))
  :pattern ((inv@192@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
  :qid |option$array$-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (iff
    (Set_in r ($FVF.domain_option$array$ (sm@194@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00)))
    (and
      (and
        (<
          (inv@192@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@192@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      (< $Perm.No $k@191@00)))
  :pattern ((Set_in r ($FVF.domain_option$array$ (sm@194@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00))))
  :qid |qp.fvfDomDef24|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and
          (<
            (inv@192@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
            V@104@00)
          (<=
            0
            (inv@192@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
        (< $Perm.No $k@191@00))
      (ite
        (and
          (<
            (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
            V@104@00)
          (<=
            0
            (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
        (< $Perm.No $k@177@00)
        false))
    (=
      ($FVF.lookup_option$array$ (sm@194@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r)))
  :pattern (($FVF.lookup_option$array$ (sm@194@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r))
  :qid |qp.fvfValDef22|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r)
  :pattern (($FVF.lookup_option$array$ (sm@194@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :qid |qp.fvfResTrgDef23|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      (< $Perm.No $k@177@00)
      false)
    (=
      ($FVF.lookup_option$array$ (sm@196@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r)))
  :pattern (($FVF.lookup_option$array$ (sm@196@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r))
  :qid |qp.fvfValDef25|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r)
  :pattern (($FVF.lookup_option$array$ (sm@196@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :qid |qp.fvfResTrgDef26|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@197@00  $FPM) r)
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      $k@177@00
      $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@197@00  $FPM) r))
  :qid |qp.resPrmSumDef27|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@196@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@197@00  $FPM) r))
  :qid |qp.resTrgDef28|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      (< $Perm.No $k@177@00)
      false)
    (=
      ($FVF.lookup_option$array$ (sm@199@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r)))
  :pattern (($FVF.lookup_option$array$ (sm@199@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r))
  :qid |qp.fvfValDef29|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r)
  :pattern (($FVF.lookup_option$array$ (sm@199@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :qid |qp.fvfResTrgDef30|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@200@00  $FPM) r)
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      $k@177@00
      $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@200@00  $FPM) r))
  :qid |qp.resPrmSumDef31|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@199@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@200@00  $FPM) r))
  :qid |qp.resTrgDef32|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      (< $Perm.No $k@177@00)
      false)
    (=
      ($FVF.lookup_option$array$ (sm@203@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r)))
  :pattern (($FVF.lookup_option$array$ (sm@203@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r))
  :qid |qp.fvfValDef33|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r)
  :pattern (($FVF.lookup_option$array$ (sm@203@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :qid |qp.fvfResTrgDef34|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@204@00  $FPM) r)
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      $k@177@00
      $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@204@00  $FPM) r))
  :qid |qp.resPrmSumDef35|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@203@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@204@00  $FPM) r))
  :qid |qp.resTrgDef36|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      (< $Perm.No $k@177@00)
      false)
    (=
      ($FVF.lookup_option$array$ (sm@205@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r)))
  :pattern (($FVF.lookup_option$array$ (sm@205@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r))
  :qid |qp.fvfValDef37|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r)
  :pattern (($FVF.lookup_option$array$ (sm@205@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :qid |qp.fvfResTrgDef38|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@206@00  $FPM) r)
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      $k@177@00
      $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@206@00  $FPM) r))
  :qid |qp.resPrmSumDef39|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@205@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@206@00  $FPM) r))
  :qid |qp.resTrgDef40|)))
(assert ($Perm.isReadVar $k@209@00 $Perm.Write))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      (< $Perm.No $k@177@00)
      false)
    (=
      ($FVF.lookup_option$array$ (sm@210@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r)))
  :pattern (($FVF.lookup_option$array$ (sm@210@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r))
  :qid |qp.fvfValDef41|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r)
  :pattern (($FVF.lookup_option$array$ (sm@210@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :qid |qp.fvfResTrgDef42|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@211@00  $FPM) r)
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      $k@177@00
      $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@211@00  $FPM) r))
  :qid |qp.resPrmSumDef43|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@210@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@211@00  $FPM) r))
  :qid |qp.resTrgDef44|)))
(assert (forall ((i1@207@00 Int) (j@208@00 Int)) (!
  (implies
    (and
      (and
        (and (and (< j@208@00 V@104@00) (<= 0 j@208@00)) (< i1@207@00 V@104@00))
        (<= 0 i1@207@00))
      (< $Perm.No $k@209@00))
    (and
      (=
        (inv@212@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@210@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@207@00))) j@208@00))
        i1@207@00)
      (=
        (inv@213@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@210@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@207@00))) j@208@00))
        j@208@00)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@210@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@207@00))) j@208@00))
  :qid |int-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and
          (and
            (<
              (inv@213@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
              V@104@00)
            (<=
              0
              (inv@213@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
          (<
            (inv@212@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
            V@104@00))
        (<= 0 (inv@212@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      (< $Perm.No $k@209@00))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@210@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@103@00) (inv@212@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))) (inv@213@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
      r))
  :pattern ((inv@212@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
  :pattern ((inv@213@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (iff
    (Set_in r ($FVF.domain_int (sm@215@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00)))
    (and
      (and
        (and
          (and
            (<
              (inv@213@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
              V@104@00)
            (<=
              0
              (inv@213@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
          (<
            (inv@212@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
            V@104@00))
        (<= 0 (inv@212@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      (< $Perm.No $k@209@00)))
  :pattern ((Set_in r ($FVF.domain_int (sm@215@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00))))
  :qid |qp.fvfDomDef48|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and
          (and
            (and
              (<
                (inv@213@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                V@104@00)
              (<=
                0
                (inv@213@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
            (<
              (inv@212@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
              V@104@00))
          (<=
            0
            (inv@212@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
        (< $Perm.No $k@209@00))
      (ite
        (and
          (and
            (and
              (<
                (inv@188@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                V@104@00)
              (<=
                0
                (inv@188@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
            (<
              (inv@187@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
              V@104@00))
          (<=
            0
            (inv@187@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
        (< $Perm.No $k@186@00)
        false))
    (=
      ($FVF.lookup_int (sm@215@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$)))))))) r)))
  :pattern (($FVF.lookup_int (sm@215@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$)))))))) r))
  :qid |qp.fvfValDef46|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$)))))))) r) r)
  :pattern (($FVF.lookup_int (sm@215@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :qid |qp.fvfResTrgDef47|)))
(assert ($Perm.isReadVar $k@217@00 $Perm.Write))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      (< $Perm.No $k@177@00)
      false)
    (=
      ($FVF.lookup_option$array$ (sm@219@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r)))
  :pattern (($FVF.lookup_option$array$ (sm@219@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r))
  :qid |qp.fvfValDef49|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r)
  :pattern (($FVF.lookup_option$array$ (sm@219@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :qid |qp.fvfResTrgDef50|)))
(assert (forall ((i1@216@00 Int)) (!
  (implies
    (and (and (< i1@216@00 V@104@00) (<= 0 i1@216@00)) (< $Perm.No $k@217@00))
    (=
      (inv@218@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@216@00))
      i1@216@00))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@216@00))
  :qid |option$array$-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (<
          (inv@218@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@218@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      (< $Perm.No $k@217@00))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@103@00) (inv@218@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
      r))
  :pattern ((inv@218@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
  :qid |option$array$-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (iff
    (Set_in r ($FVF.domain_option$array$ (sm@221@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00)))
    (and
      (and
        (<
          (inv@218@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@218@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      (< $Perm.No $k@217@00)))
  :pattern ((Set_in r ($FVF.domain_option$array$ (sm@221@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00))))
  :qid |qp.fvfDomDef54|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and
          (<
            (inv@218@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
            V@104@00)
          (<=
            0
            (inv@218@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
        (< $Perm.No $k@217@00))
      (ite
        (and
          (<
            (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
            V@104@00)
          (<=
            0
            (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
        (< $Perm.No $k@177@00)
        false))
    (=
      ($FVF.lookup_option$array$ (sm@221@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r)))
  :pattern (($FVF.lookup_option$array$ (sm@221@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r))
  :qid |qp.fvfValDef52|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r)
  :pattern (($FVF.lookup_option$array$ (sm@221@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :qid |qp.fvfResTrgDef53|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      (< $Perm.No $k@177@00)
      false)
    (=
      ($FVF.lookup_option$array$ (sm@223@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r)))
  :pattern (($FVF.lookup_option$array$ (sm@223@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r))
  :qid |qp.fvfValDef55|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r)
  :pattern (($FVF.lookup_option$array$ (sm@223@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :qid |qp.fvfResTrgDef56|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@224@00  $FPM) r)
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      $k@177@00
      $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@224@00  $FPM) r))
  :qid |qp.resPrmSumDef57|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@223@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@224@00  $FPM) r))
  :qid |qp.resTrgDef58|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      (< $Perm.No $k@177@00)
      false)
    (=
      ($FVF.lookup_option$array$ (sm@226@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r)))
  :pattern (($FVF.lookup_option$array$ (sm@226@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r))
  :qid |qp.fvfValDef59|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r)
  :pattern (($FVF.lookup_option$array$ (sm@226@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :qid |qp.fvfResTrgDef60|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@227@00  $FPM) r)
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      $k@177@00
      $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@227@00  $FPM) r))
  :qid |qp.resPrmSumDef61|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@226@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@227@00  $FPM) r))
  :qid |qp.resTrgDef62|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      (< $Perm.No $k@177@00)
      false)
    (=
      ($FVF.lookup_option$array$ (sm@230@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r)))
  :pattern (($FVF.lookup_option$array$ (sm@230@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r))
  :qid |qp.fvfValDef63|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r)
  :pattern (($FVF.lookup_option$array$ (sm@230@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :qid |qp.fvfResTrgDef64|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@231@00  $FPM) r)
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      $k@177@00
      $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@231@00  $FPM) r))
  :qid |qp.resPrmSumDef65|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@230@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@231@00  $FPM) r))
  :qid |qp.resTrgDef66|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      (< $Perm.No $k@177@00)
      false)
    (=
      ($FVF.lookup_option$array$ (sm@232@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r)))
  :pattern (($FVF.lookup_option$array$ (sm@232@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r))
  :qid |qp.fvfValDef67|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r)
  :pattern (($FVF.lookup_option$array$ (sm@232@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :qid |qp.fvfResTrgDef68|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@233@00  $FPM) r)
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      $k@177@00
      $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@233@00  $FPM) r))
  :qid |qp.resPrmSumDef69|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@232@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@233@00  $FPM) r))
  :qid |qp.resTrgDef70|)))
(assert ($Perm.isReadVar $k@236@00 $Perm.Write))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      (< $Perm.No $k@177@00)
      false)
    (=
      ($FVF.lookup_option$array$ (sm@237@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r)))
  :pattern (($FVF.lookup_option$array$ (sm@237@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r))
  :qid |qp.fvfValDef71|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r)
  :pattern (($FVF.lookup_option$array$ (sm@237@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :qid |qp.fvfResTrgDef72|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@238@00  $FPM) r)
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      $k@177@00
      $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@238@00  $FPM) r))
  :qid |qp.resPrmSumDef73|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@237@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@238@00  $FPM) r))
  :qid |qp.resTrgDef74|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and
        (and
          (and
            (<
              (inv@188@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
              V@104@00)
            (<=
              0
              (inv@188@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
          (<
            (inv@187@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
            V@104@00))
        (<= 0 (inv@187@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      (< $Perm.No $k@186@00)
      false)
    (=
      ($FVF.lookup_int (sm@241@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$)))))))) r)))
  :pattern (($FVF.lookup_int (sm@241@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$)))))))) r))
  :qid |qp.fvfValDef75|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$)))))))) r) r)
  :pattern (($FVF.lookup_int (sm@241@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :qid |qp.fvfResTrgDef76|)))
(assert (forall ((i1@234@00 Int) (j@235@00 Int)) (!
  (implies
    (and
      (and
        (and (and (< j@235@00 V@104@00) (<= 0 j@235@00)) (< i1@234@00 V@104@00))
        (<= 0 i1@234@00))
      (< $Perm.No $k@236@00))
    (and
      (=
        (inv@239@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@237@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@234@00))) j@235@00))
        i1@234@00)
      (=
        (inv@240@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@237@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@234@00))) j@235@00))
        j@235@00)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@237@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@234@00))) j@235@00))
  :qid |int-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and
          (and
            (<
              (inv@240@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
              V@104@00)
            (<=
              0
              (inv@240@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
          (<
            (inv@239@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
            V@104@00))
        (<= 0 (inv@239@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      (< $Perm.No $k@236@00))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@237@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@103@00) (inv@239@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))) (inv@240@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
      r))
  :pattern ((inv@239@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
  :pattern ((inv@240@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (iff
    (Set_in r ($FVF.domain_int (sm@243@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00)))
    (and
      (and
        (and
          (and
            (<
              (inv@240@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
              V@104@00)
            (<=
              0
              (inv@240@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
          (<
            (inv@239@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
            V@104@00))
        (<= 0 (inv@239@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      (< $Perm.No $k@236@00)))
  :pattern ((Set_in r ($FVF.domain_int (sm@243@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00))))
  :qid |qp.fvfDomDef80|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and
          (and
            (and
              (<
                (inv@240@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                V@104@00)
              (<=
                0
                (inv@240@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
            (<
              (inv@239@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
              V@104@00))
          (<=
            0
            (inv@239@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
        (< $Perm.No $k@236@00))
      (ite
        (and
          (and
            (and
              (<
                (inv@188@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                V@104@00)
              (<=
                0
                (inv@188@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
            (<
              (inv@187@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
              V@104@00))
          (<=
            0
            (inv@187@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
        (< $Perm.No $k@186@00)
        false))
    (=
      ($FVF.lookup_int (sm@243@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$)))))))) r)))
  :pattern (($FVF.lookup_int (sm@243@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$)))))))) r))
  :qid |qp.fvfValDef78|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$)))))))) r) r)
  :pattern (($FVF.lookup_int (sm@243@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :qid |qp.fvfResTrgDef79|)))
(assert (implies
  (< t@106@00 V@104@00)
  (and
    (< t@106@00 V@104@00)
    (forall ((i1@190@00 Int)) (!
      (< i1@190@00 (alen<Int> (opt_get1 $Snap.unit G@103@00)))
      :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@190@00))
      :qid |option$array$-aux|))
    (forall ((r $Ref)) (!
      (implies
        (and
          (<
            (inv@192@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
            V@104@00)
          (<=
            0
            (inv@192@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@179@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r) r))
      :pattern ((inv@192@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
      ))
    (forall ((r $Ref)) (!
      (implies
        (not
          (=
            (ite
              (and
                (<
                  (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                  V@104@00)
                (<=
                  0
                  (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
              $k@177@00
              $Perm.No)
            $Perm.No))
        (ite
          (and
            (<
              (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
              V@104@00)
            (<=
              0
              (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
          (<
            (ite
              (and
                (<
                  (inv@192@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                  V@104@00)
                (<=
                  0
                  (inv@192@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
              $k@191@00
              $Perm.No)
            $k@177@00)
          (<
            (ite
              (and
                (<
                  (inv@192@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                  V@104@00)
                (<=
                  0
                  (inv@192@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
              $k@191@00
              $Perm.No)
            $Perm.No)))
      :pattern ((inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
      :pattern ((inv@192@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
      :qid |qp.srp21|))
    (forall ((i1@195@00 Int)) (!
      (implies
        (and (< i1@195@00 V@104@00) (<= 0 i1@195@00))
        (not
          (=
            ($FVF.lookup_option$array$ (sm@196@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@195@00))
            (as None<option<array>>  option<array>))))
      
      :qid |prog.l<no position>|))
    (forall ((i1@198@00 Int)) (!
      (implies
        (and (< i1@198@00 V@104@00) (<= 0 i1@198@00))
        (=
          (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@199@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@198@00))))
          V@104@00))
      
      :qid |prog.l<no position>|))
    (forall ((i1@201@00 Int)) (!
      (forall ((i2@202@00 Int)) (!
        (implies
          (and
            (and
              (and
                (and
                  (=
                    ($FVF.lookup_option$array$ (sm@203@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@201@00))
                    ($FVF.lookup_option$array$ (sm@205@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit G@103@00) i2@202@00)))
                  (< i2@202@00 V@104@00))
                (<= 0 i2@202@00))
              (< i1@201@00 V@104@00))
            (<= 0 i1@201@00))
          (= i1@201@00 i2@202@00))
        :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@103@00) i2@202@00))
        :qid |prog.l<no position>|))
      
      :qid |prog.l<no position>|))
    (forall ((i1@207@00 Int) (j@208@00 Int)) (!
      (and
        (< i1@207@00 (alen<Int> (opt_get1 $Snap.unit G@103@00)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@210@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@207@00)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@207@00))
        (not
          (=
            ($FVF.lookup_option$array$ (sm@210@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@207@00))
            (as None<option<array>>  option<array>)))
        (<
          j@208@00
          (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@210@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@207@00))))))
      :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@210@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@207@00))) j@208@00))
      :qid |int-aux|))
    (forall ((r $Ref)) (!
      (implies
        (and
          (and
            (and
              (<
                (inv@213@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                V@104@00)
              (<=
                0
                (inv@213@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
            (<
              (inv@212@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
              V@104@00))
          (<=
            0
            (inv@212@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
        ($FVF.loc_int ($FVF.lookup_int (sm@189@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r) r))
      :pattern ((inv@212@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r) (inv@213@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
      ))
    (forall ((r $Ref)) (!
      (implies
        (not
          (=
            (ite
              (and
                (and
                  (and
                    (<
                      (inv@188@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                      V@104@00)
                    (<=
                      0
                      (inv@188@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
                  (<
                    (inv@187@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                    V@104@00))
                (<=
                  0
                  (inv@187@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
              $k@186@00
              $Perm.No)
            $Perm.No))
        (ite
          (and
            (and
              (and
                (<
                  (inv@188@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                  V@104@00)
                (<=
                  0
                  (inv@188@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
              (<
                (inv@187@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                V@104@00))
            (<=
              0
              (inv@187@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
          (<
            (ite
              (and
                (and
                  (and
                    (<
                      (inv@213@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                      V@104@00)
                    (<=
                      0
                      (inv@213@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
                  (<
                    (inv@212@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                    V@104@00))
                (<=
                  0
                  (inv@212@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
              $k@209@00
              $Perm.No)
            $k@186@00)
          (<
            (ite
              (and
                (and
                  (and
                    (<
                      (inv@213@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                      V@104@00)
                    (<=
                      0
                      (inv@213@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
                  (<
                    (inv@212@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                    V@104@00))
                (<=
                  0
                  (inv@212@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
              $k@209@00
              $Perm.No)
            $Perm.No)))
      :pattern ((inv@188@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
      :pattern ((inv@187@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
      :pattern ((inv@213@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
      :pattern ((inv@212@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
      :qid |qp.srp45|))
    (implies
      (SquareIntMatrix1 ($Snap.combine
        $Snap.unit
        ($Snap.combine
          $Snap.unit
          ($Snap.combine
            $Snap.unit
            ($Snap.combine
              ($SortWrappers.$FVF<option<array>>To$Snap (sm@194@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00))
              ($Snap.combine
                $Snap.unit
                ($Snap.combine
                  $Snap.unit
                  ($Snap.combine
                    $Snap.unit
                    ($SortWrappers.$FVF<Int>To$Snap (sm@215@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00))))))))) this@102@00 G@103@00 V@104@00)
      (and
        (SquareIntMatrix1 ($Snap.combine
          $Snap.unit
          ($Snap.combine
            $Snap.unit
            ($Snap.combine
              $Snap.unit
              ($Snap.combine
                ($SortWrappers.$FVF<option<array>>To$Snap (sm@194@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00))
                ($Snap.combine
                  $Snap.unit
                  ($Snap.combine
                    $Snap.unit
                    ($Snap.combine
                      $Snap.unit
                      ($SortWrappers.$FVF<Int>To$Snap (sm@215@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00))))))))) this@102@00 G@103@00 V@104@00)
        (forall ((i1@216@00 Int)) (!
          (< i1@216@00 (alen<Int> (opt_get1 $Snap.unit G@103@00)))
          :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@216@00))
          :qid |option$array$-aux|))
        (forall ((r $Ref)) (!
          (implies
            (and
              (<
                (inv@218@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                V@104@00)
              (<=
                0
                (inv@218@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@219@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r) r))
          :pattern ((inv@218@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
          ))
        (forall ((r $Ref)) (!
          (implies
            (not
              (=
                (ite
                  (and
                    (<
                      (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                      V@104@00)
                    (<=
                      0
                      (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
                  $k@177@00
                  $Perm.No)
                $Perm.No))
            (ite
              (and
                (<
                  (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                  V@104@00)
                (<=
                  0
                  (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
              (<
                (ite
                  (and
                    (<
                      (inv@218@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                      V@104@00)
                    (<=
                      0
                      (inv@218@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
                  $k@217@00
                  $Perm.No)
                $k@177@00)
              (<
                (ite
                  (and
                    (<
                      (inv@218@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                      V@104@00)
                    (<=
                      0
                      (inv@218@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
                  $k@217@00
                  $Perm.No)
                $Perm.No)))
          :pattern ((inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
          :pattern ((inv@218@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
          :qid |qp.srp51|))
        (forall ((i1@222@00 Int)) (!
          (implies
            (and (< i1@222@00 V@104@00) (<= 0 i1@222@00))
            (not
              (=
                ($FVF.lookup_option$array$ (sm@223@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@222@00))
                (as None<option<array>>  option<array>))))
          
          :qid |prog.l<no position>|))
        (forall ((i1@225@00 Int)) (!
          (implies
            (and (< i1@225@00 V@104@00) (<= 0 i1@225@00))
            (=
              (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@226@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@225@00))))
              V@104@00))
          
          :qid |prog.l<no position>|))
        (forall ((i1@228@00 Int)) (!
          (forall ((i2@229@00 Int)) (!
            (implies
              (and
                (and
                  (and
                    (and
                      (=
                        ($FVF.lookup_option$array$ (sm@230@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
                          $Snap.unit
                          $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@228@00))
                        ($FVF.lookup_option$array$ (sm@232@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
                          $Snap.unit
                          $Snap.unit) (opt_get1 $Snap.unit G@103@00) i2@229@00)))
                      (< i2@229@00 V@104@00))
                    (<= 0 i2@229@00))
                  (< i1@228@00 V@104@00))
                (<= 0 i1@228@00))
              (= i1@228@00 i2@229@00))
            :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@103@00) i2@229@00))
            :qid |prog.l<no position>|))
          
          :qid |prog.l<no position>|))
        (forall ((i1@234@00 Int) (j@235@00 Int)) (!
          (and
            (< i1@234@00 (alen<Int> (opt_get1 $Snap.unit G@103@00)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@237@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@234@00)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@234@00))
            (not
              (=
                ($FVF.lookup_option$array$ (sm@237@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@234@00))
                (as None<option<array>>  option<array>)))
            (<
              j@235@00
              (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@237@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@234@00))))))
          :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@237@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@234@00))) j@235@00))
          :qid |int-aux|))
        (forall ((r $Ref)) (!
          (implies
            (and
              (and
                (and
                  (<
                    (inv@240@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                    V@104@00)
                  (<=
                    0
                    (inv@240@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
                (<
                  (inv@239@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                  V@104@00))
              (<=
                0
                (inv@239@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
            ($FVF.loc_int ($FVF.lookup_int (sm@241@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r) r))
          :pattern ((inv@239@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r) (inv@240@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
          ))
        (forall ((r $Ref)) (!
          (implies
            (not
              (=
                (ite
                  (and
                    (and
                      (and
                        (<
                          (inv@188@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                          V@104@00)
                        (<=
                          0
                          (inv@188@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
                      (<
                        (inv@187@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                        V@104@00))
                    (<=
                      0
                      (inv@187@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
                  $k@186@00
                  $Perm.No)
                $Perm.No))
            (ite
              (and
                (and
                  (and
                    (<
                      (inv@188@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                      V@104@00)
                    (<=
                      0
                      (inv@188@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
                  (<
                    (inv@187@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                    V@104@00))
                (<=
                  0
                  (inv@187@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
              (<
                (ite
                  (and
                    (and
                      (and
                        (<
                          (inv@240@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                          V@104@00)
                        (<=
                          0
                          (inv@240@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
                      (<
                        (inv@239@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                        V@104@00))
                    (<=
                      0
                      (inv@239@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
                  $k@236@00
                  $Perm.No)
                $k@186@00)
              (<
                (ite
                  (and
                    (and
                      (and
                        (<
                          (inv@240@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                          V@104@00)
                        (<=
                          0
                          (inv@240@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
                      (<
                        (inv@239@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                        V@104@00))
                    (<=
                      0
                      (inv@239@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
                  $k@236@00
                  $Perm.No)
                $Perm.No)))
          :pattern ((inv@188@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
          :pattern ((inv@187@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
          :pattern ((inv@240@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
          :pattern ((inv@239@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
          :qid |qp.srp77|))
        (SquareIntMatrix1 ($Snap.combine
          $Snap.unit
          ($Snap.combine
            $Snap.unit
            ($Snap.combine
              $Snap.unit
              ($Snap.combine
                ($SortWrappers.$FVF<option<array>>To$Snap (sm@221@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00))
                ($Snap.combine
                  $Snap.unit
                  ($Snap.combine
                    $Snap.unit
                    ($Snap.combine
                      $Snap.unit
                      ($SortWrappers.$FVF<Int>To$Snap (sm@243@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00))))))))) this@102@00 G@103@00 V@104@00))))))
; Joined path conditions
(pop) ; 7
(push) ; 7
; [else-branch: 117 | !(0 <= t@106@00)]
(assert (not (<= 0 t@106@00)))
(pop) ; 7
(pop) ; 6
; Joined path conditions
(assert ($Perm.isReadVar $k@191@00 $Perm.Write))
(assert (forall ((i1@190@00 Int)) (!
  (implies
    (and (and (< i1@190@00 V@104@00) (<= 0 i1@190@00)) (< $Perm.No $k@191@00))
    (=
      (inv@192@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@190@00))
      i1@190@00))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@190@00))
  :qid |option$array$-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (<
          (inv@192@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@192@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      (< $Perm.No $k@191@00))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@103@00) (inv@192@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
      r))
  :pattern ((inv@192@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
  :qid |option$array$-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (iff
    (Set_in r ($FVF.domain_option$array$ (sm@194@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00)))
    (and
      (and
        (<
          (inv@192@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@192@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      (< $Perm.No $k@191@00)))
  :pattern ((Set_in r ($FVF.domain_option$array$ (sm@194@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00))))
  :qid |qp.fvfDomDef24|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and
          (<
            (inv@192@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
            V@104@00)
          (<=
            0
            (inv@192@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
        (< $Perm.No $k@191@00))
      (ite
        (and
          (<
            (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
            V@104@00)
          (<=
            0
            (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
        (< $Perm.No $k@177@00)
        false))
    (=
      ($FVF.lookup_option$array$ (sm@194@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r)))
  :pattern (($FVF.lookup_option$array$ (sm@194@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r))
  :qid |qp.fvfValDef22|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r)
  :pattern (($FVF.lookup_option$array$ (sm@194@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :qid |qp.fvfResTrgDef23|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      (< $Perm.No $k@177@00)
      false)
    (=
      ($FVF.lookup_option$array$ (sm@196@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r)))
  :pattern (($FVF.lookup_option$array$ (sm@196@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r))
  :qid |qp.fvfValDef25|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r)
  :pattern (($FVF.lookup_option$array$ (sm@196@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :qid |qp.fvfResTrgDef26|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@197@00  $FPM) r)
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      $k@177@00
      $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@197@00  $FPM) r))
  :qid |qp.resPrmSumDef27|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@196@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@197@00  $FPM) r))
  :qid |qp.resTrgDef28|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      (< $Perm.No $k@177@00)
      false)
    (=
      ($FVF.lookup_option$array$ (sm@199@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r)))
  :pattern (($FVF.lookup_option$array$ (sm@199@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r))
  :qid |qp.fvfValDef29|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r)
  :pattern (($FVF.lookup_option$array$ (sm@199@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :qid |qp.fvfResTrgDef30|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@200@00  $FPM) r)
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      $k@177@00
      $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@200@00  $FPM) r))
  :qid |qp.resPrmSumDef31|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@199@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@200@00  $FPM) r))
  :qid |qp.resTrgDef32|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      (< $Perm.No $k@177@00)
      false)
    (=
      ($FVF.lookup_option$array$ (sm@203@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r)))
  :pattern (($FVF.lookup_option$array$ (sm@203@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r))
  :qid |qp.fvfValDef33|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r)
  :pattern (($FVF.lookup_option$array$ (sm@203@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :qid |qp.fvfResTrgDef34|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@204@00  $FPM) r)
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      $k@177@00
      $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@204@00  $FPM) r))
  :qid |qp.resPrmSumDef35|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@203@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@204@00  $FPM) r))
  :qid |qp.resTrgDef36|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      (< $Perm.No $k@177@00)
      false)
    (=
      ($FVF.lookup_option$array$ (sm@205@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r)))
  :pattern (($FVF.lookup_option$array$ (sm@205@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r))
  :qid |qp.fvfValDef37|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r)
  :pattern (($FVF.lookup_option$array$ (sm@205@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :qid |qp.fvfResTrgDef38|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@206@00  $FPM) r)
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      $k@177@00
      $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@206@00  $FPM) r))
  :qid |qp.resPrmSumDef39|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@205@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@206@00  $FPM) r))
  :qid |qp.resTrgDef40|)))
(assert ($Perm.isReadVar $k@209@00 $Perm.Write))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      (< $Perm.No $k@177@00)
      false)
    (=
      ($FVF.lookup_option$array$ (sm@210@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r)))
  :pattern (($FVF.lookup_option$array$ (sm@210@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r))
  :qid |qp.fvfValDef41|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r)
  :pattern (($FVF.lookup_option$array$ (sm@210@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :qid |qp.fvfResTrgDef42|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@211@00  $FPM) r)
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      $k@177@00
      $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@211@00  $FPM) r))
  :qid |qp.resPrmSumDef43|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@210@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@211@00  $FPM) r))
  :qid |qp.resTrgDef44|)))
(assert (forall ((i1@207@00 Int) (j@208@00 Int)) (!
  (implies
    (and
      (and
        (and (and (< j@208@00 V@104@00) (<= 0 j@208@00)) (< i1@207@00 V@104@00))
        (<= 0 i1@207@00))
      (< $Perm.No $k@209@00))
    (and
      (=
        (inv@212@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@210@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@207@00))) j@208@00))
        i1@207@00)
      (=
        (inv@213@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@210@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@207@00))) j@208@00))
        j@208@00)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@210@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@207@00))) j@208@00))
  :qid |int-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and
          (and
            (<
              (inv@213@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
              V@104@00)
            (<=
              0
              (inv@213@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
          (<
            (inv@212@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
            V@104@00))
        (<= 0 (inv@212@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      (< $Perm.No $k@209@00))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@210@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@103@00) (inv@212@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))) (inv@213@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
      r))
  :pattern ((inv@212@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
  :pattern ((inv@213@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (iff
    (Set_in r ($FVF.domain_int (sm@215@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00)))
    (and
      (and
        (and
          (and
            (<
              (inv@213@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
              V@104@00)
            (<=
              0
              (inv@213@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
          (<
            (inv@212@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
            V@104@00))
        (<= 0 (inv@212@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      (< $Perm.No $k@209@00)))
  :pattern ((Set_in r ($FVF.domain_int (sm@215@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00))))
  :qid |qp.fvfDomDef48|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and
          (and
            (and
              (<
                (inv@213@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                V@104@00)
              (<=
                0
                (inv@213@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
            (<
              (inv@212@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
              V@104@00))
          (<=
            0
            (inv@212@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
        (< $Perm.No $k@209@00))
      (ite
        (and
          (and
            (and
              (<
                (inv@188@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                V@104@00)
              (<=
                0
                (inv@188@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
            (<
              (inv@187@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
              V@104@00))
          (<=
            0
            (inv@187@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
        (< $Perm.No $k@186@00)
        false))
    (=
      ($FVF.lookup_int (sm@215@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$)))))))) r)))
  :pattern (($FVF.lookup_int (sm@215@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$)))))))) r))
  :qid |qp.fvfValDef46|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$)))))))) r) r)
  :pattern (($FVF.lookup_int (sm@215@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :qid |qp.fvfResTrgDef47|)))
(assert ($Perm.isReadVar $k@217@00 $Perm.Write))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      (< $Perm.No $k@177@00)
      false)
    (=
      ($FVF.lookup_option$array$ (sm@219@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r)))
  :pattern (($FVF.lookup_option$array$ (sm@219@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r))
  :qid |qp.fvfValDef49|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r)
  :pattern (($FVF.lookup_option$array$ (sm@219@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :qid |qp.fvfResTrgDef50|)))
(assert (forall ((i1@216@00 Int)) (!
  (implies
    (and (and (< i1@216@00 V@104@00) (<= 0 i1@216@00)) (< $Perm.No $k@217@00))
    (=
      (inv@218@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@216@00))
      i1@216@00))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@216@00))
  :qid |option$array$-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (<
          (inv@218@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@218@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      (< $Perm.No $k@217@00))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@103@00) (inv@218@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
      r))
  :pattern ((inv@218@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
  :qid |option$array$-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (iff
    (Set_in r ($FVF.domain_option$array$ (sm@221@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00)))
    (and
      (and
        (<
          (inv@218@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@218@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      (< $Perm.No $k@217@00)))
  :pattern ((Set_in r ($FVF.domain_option$array$ (sm@221@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00))))
  :qid |qp.fvfDomDef54|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and
          (<
            (inv@218@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
            V@104@00)
          (<=
            0
            (inv@218@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
        (< $Perm.No $k@217@00))
      (ite
        (and
          (<
            (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
            V@104@00)
          (<=
            0
            (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
        (< $Perm.No $k@177@00)
        false))
    (=
      ($FVF.lookup_option$array$ (sm@221@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r)))
  :pattern (($FVF.lookup_option$array$ (sm@221@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r))
  :qid |qp.fvfValDef52|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r)
  :pattern (($FVF.lookup_option$array$ (sm@221@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :qid |qp.fvfResTrgDef53|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      (< $Perm.No $k@177@00)
      false)
    (=
      ($FVF.lookup_option$array$ (sm@223@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r)))
  :pattern (($FVF.lookup_option$array$ (sm@223@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r))
  :qid |qp.fvfValDef55|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r)
  :pattern (($FVF.lookup_option$array$ (sm@223@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :qid |qp.fvfResTrgDef56|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@224@00  $FPM) r)
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      $k@177@00
      $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@224@00  $FPM) r))
  :qid |qp.resPrmSumDef57|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@223@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@224@00  $FPM) r))
  :qid |qp.resTrgDef58|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      (< $Perm.No $k@177@00)
      false)
    (=
      ($FVF.lookup_option$array$ (sm@226@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r)))
  :pattern (($FVF.lookup_option$array$ (sm@226@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r))
  :qid |qp.fvfValDef59|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r)
  :pattern (($FVF.lookup_option$array$ (sm@226@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :qid |qp.fvfResTrgDef60|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@227@00  $FPM) r)
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      $k@177@00
      $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@227@00  $FPM) r))
  :qid |qp.resPrmSumDef61|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@226@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@227@00  $FPM) r))
  :qid |qp.resTrgDef62|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      (< $Perm.No $k@177@00)
      false)
    (=
      ($FVF.lookup_option$array$ (sm@230@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r)))
  :pattern (($FVF.lookup_option$array$ (sm@230@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r))
  :qid |qp.fvfValDef63|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r)
  :pattern (($FVF.lookup_option$array$ (sm@230@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :qid |qp.fvfResTrgDef64|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@231@00  $FPM) r)
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      $k@177@00
      $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@231@00  $FPM) r))
  :qid |qp.resPrmSumDef65|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@230@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@231@00  $FPM) r))
  :qid |qp.resTrgDef66|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      (< $Perm.No $k@177@00)
      false)
    (=
      ($FVF.lookup_option$array$ (sm@232@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r)))
  :pattern (($FVF.lookup_option$array$ (sm@232@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r))
  :qid |qp.fvfValDef67|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r)
  :pattern (($FVF.lookup_option$array$ (sm@232@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :qid |qp.fvfResTrgDef68|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@233@00  $FPM) r)
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      $k@177@00
      $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@233@00  $FPM) r))
  :qid |qp.resPrmSumDef69|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@232@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@233@00  $FPM) r))
  :qid |qp.resTrgDef70|)))
(assert ($Perm.isReadVar $k@236@00 $Perm.Write))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      (< $Perm.No $k@177@00)
      false)
    (=
      ($FVF.lookup_option$array$ (sm@237@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r)))
  :pattern (($FVF.lookup_option$array$ (sm@237@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r))
  :qid |qp.fvfValDef71|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r)
  :pattern (($FVF.lookup_option$array$ (sm@237@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :qid |qp.fvfResTrgDef72|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@238@00  $FPM) r)
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      $k@177@00
      $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@238@00  $FPM) r))
  :qid |qp.resPrmSumDef73|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@237@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@238@00  $FPM) r))
  :qid |qp.resTrgDef74|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and
        (and
          (and
            (<
              (inv@188@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
              V@104@00)
            (<=
              0
              (inv@188@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
          (<
            (inv@187@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
            V@104@00))
        (<= 0 (inv@187@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      (< $Perm.No $k@186@00)
      false)
    (=
      ($FVF.lookup_int (sm@241@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$)))))))) r)))
  :pattern (($FVF.lookup_int (sm@241@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$)))))))) r))
  :qid |qp.fvfValDef75|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$)))))))) r) r)
  :pattern (($FVF.lookup_int (sm@241@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :qid |qp.fvfResTrgDef76|)))
(assert (forall ((i1@234@00 Int) (j@235@00 Int)) (!
  (implies
    (and
      (and
        (and (and (< j@235@00 V@104@00) (<= 0 j@235@00)) (< i1@234@00 V@104@00))
        (<= 0 i1@234@00))
      (< $Perm.No $k@236@00))
    (and
      (=
        (inv@239@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@237@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@234@00))) j@235@00))
        i1@234@00)
      (=
        (inv@240@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@237@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@234@00))) j@235@00))
        j@235@00)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@237@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@234@00))) j@235@00))
  :qid |int-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and
          (and
            (<
              (inv@240@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
              V@104@00)
            (<=
              0
              (inv@240@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
          (<
            (inv@239@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
            V@104@00))
        (<= 0 (inv@239@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      (< $Perm.No $k@236@00))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@237@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@103@00) (inv@239@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))) (inv@240@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
      r))
  :pattern ((inv@239@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
  :pattern ((inv@240@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (iff
    (Set_in r ($FVF.domain_int (sm@243@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00)))
    (and
      (and
        (and
          (and
            (<
              (inv@240@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
              V@104@00)
            (<=
              0
              (inv@240@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
          (<
            (inv@239@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
            V@104@00))
        (<= 0 (inv@239@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      (< $Perm.No $k@236@00)))
  :pattern ((Set_in r ($FVF.domain_int (sm@243@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00))))
  :qid |qp.fvfDomDef80|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and
          (and
            (and
              (<
                (inv@240@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                V@104@00)
              (<=
                0
                (inv@240@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
            (<
              (inv@239@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
              V@104@00))
          (<=
            0
            (inv@239@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
        (< $Perm.No $k@236@00))
      (ite
        (and
          (and
            (and
              (<
                (inv@188@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                V@104@00)
              (<=
                0
                (inv@188@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
            (<
              (inv@187@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
              V@104@00))
          (<=
            0
            (inv@187@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
        (< $Perm.No $k@186@00)
        false))
    (=
      ($FVF.lookup_int (sm@243@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$)))))))) r)))
  :pattern (($FVF.lookup_int (sm@243@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$)))))))) r))
  :qid |qp.fvfValDef78|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$)))))))) r) r)
  :pattern (($FVF.lookup_int (sm@243@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :qid |qp.fvfResTrgDef79|)))
(assert (implies
  (<= 0 t@106@00)
  (and
    (<= 0 t@106@00)
    (implies
      (< t@106@00 V@104@00)
      (and
        (< t@106@00 V@104@00)
        (forall ((i1@190@00 Int)) (!
          (< i1@190@00 (alen<Int> (opt_get1 $Snap.unit G@103@00)))
          :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@190@00))
          :qid |option$array$-aux|))
        (forall ((r $Ref)) (!
          (implies
            (and
              (<
                (inv@192@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                V@104@00)
              (<=
                0
                (inv@192@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@179@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r) r))
          :pattern ((inv@192@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
          ))
        (forall ((r $Ref)) (!
          (implies
            (not
              (=
                (ite
                  (and
                    (<
                      (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                      V@104@00)
                    (<=
                      0
                      (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
                  $k@177@00
                  $Perm.No)
                $Perm.No))
            (ite
              (and
                (<
                  (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                  V@104@00)
                (<=
                  0
                  (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
              (<
                (ite
                  (and
                    (<
                      (inv@192@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                      V@104@00)
                    (<=
                      0
                      (inv@192@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
                  $k@191@00
                  $Perm.No)
                $k@177@00)
              (<
                (ite
                  (and
                    (<
                      (inv@192@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                      V@104@00)
                    (<=
                      0
                      (inv@192@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
                  $k@191@00
                  $Perm.No)
                $Perm.No)))
          :pattern ((inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
          :pattern ((inv@192@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
          :qid |qp.srp21|))
        (forall ((i1@195@00 Int)) (!
          (implies
            (and (< i1@195@00 V@104@00) (<= 0 i1@195@00))
            (not
              (=
                ($FVF.lookup_option$array$ (sm@196@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@195@00))
                (as None<option<array>>  option<array>))))
          
          :qid |prog.l<no position>|))
        (forall ((i1@198@00 Int)) (!
          (implies
            (and (< i1@198@00 V@104@00) (<= 0 i1@198@00))
            (=
              (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@199@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@198@00))))
              V@104@00))
          
          :qid |prog.l<no position>|))
        (forall ((i1@201@00 Int)) (!
          (forall ((i2@202@00 Int)) (!
            (implies
              (and
                (and
                  (and
                    (and
                      (=
                        ($FVF.lookup_option$array$ (sm@203@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
                          $Snap.unit
                          $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@201@00))
                        ($FVF.lookup_option$array$ (sm@205@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
                          $Snap.unit
                          $Snap.unit) (opt_get1 $Snap.unit G@103@00) i2@202@00)))
                      (< i2@202@00 V@104@00))
                    (<= 0 i2@202@00))
                  (< i1@201@00 V@104@00))
                (<= 0 i1@201@00))
              (= i1@201@00 i2@202@00))
            :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@103@00) i2@202@00))
            :qid |prog.l<no position>|))
          
          :qid |prog.l<no position>|))
        (forall ((i1@207@00 Int) (j@208@00 Int)) (!
          (and
            (< i1@207@00 (alen<Int> (opt_get1 $Snap.unit G@103@00)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@210@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@207@00)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@207@00))
            (not
              (=
                ($FVF.lookup_option$array$ (sm@210@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@207@00))
                (as None<option<array>>  option<array>)))
            (<
              j@208@00
              (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@210@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@207@00))))))
          :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@210@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@207@00))) j@208@00))
          :qid |int-aux|))
        (forall ((r $Ref)) (!
          (implies
            (and
              (and
                (and
                  (<
                    (inv@213@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                    V@104@00)
                  (<=
                    0
                    (inv@213@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
                (<
                  (inv@212@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                  V@104@00))
              (<=
                0
                (inv@212@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
            ($FVF.loc_int ($FVF.lookup_int (sm@189@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r) r))
          :pattern ((inv@212@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r) (inv@213@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
          ))
        (forall ((r $Ref)) (!
          (implies
            (not
              (=
                (ite
                  (and
                    (and
                      (and
                        (<
                          (inv@188@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                          V@104@00)
                        (<=
                          0
                          (inv@188@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
                      (<
                        (inv@187@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                        V@104@00))
                    (<=
                      0
                      (inv@187@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
                  $k@186@00
                  $Perm.No)
                $Perm.No))
            (ite
              (and
                (and
                  (and
                    (<
                      (inv@188@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                      V@104@00)
                    (<=
                      0
                      (inv@188@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
                  (<
                    (inv@187@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                    V@104@00))
                (<=
                  0
                  (inv@187@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
              (<
                (ite
                  (and
                    (and
                      (and
                        (<
                          (inv@213@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                          V@104@00)
                        (<=
                          0
                          (inv@213@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
                      (<
                        (inv@212@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                        V@104@00))
                    (<=
                      0
                      (inv@212@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
                  $k@209@00
                  $Perm.No)
                $k@186@00)
              (<
                (ite
                  (and
                    (and
                      (and
                        (<
                          (inv@213@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                          V@104@00)
                        (<=
                          0
                          (inv@213@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
                      (<
                        (inv@212@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                        V@104@00))
                    (<=
                      0
                      (inv@212@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
                  $k@209@00
                  $Perm.No)
                $Perm.No)))
          :pattern ((inv@188@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
          :pattern ((inv@187@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
          :pattern ((inv@213@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
          :pattern ((inv@212@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
          :qid |qp.srp45|))
        (implies
          (SquareIntMatrix1 ($Snap.combine
            $Snap.unit
            ($Snap.combine
              $Snap.unit
              ($Snap.combine
                $Snap.unit
                ($Snap.combine
                  ($SortWrappers.$FVF<option<array>>To$Snap (sm@194@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00))
                  ($Snap.combine
                    $Snap.unit
                    ($Snap.combine
                      $Snap.unit
                      ($Snap.combine
                        $Snap.unit
                        ($SortWrappers.$FVF<Int>To$Snap (sm@215@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00))))))))) this@102@00 G@103@00 V@104@00)
          (and
            (SquareIntMatrix1 ($Snap.combine
              $Snap.unit
              ($Snap.combine
                $Snap.unit
                ($Snap.combine
                  $Snap.unit
                  ($Snap.combine
                    ($SortWrappers.$FVF<option<array>>To$Snap (sm@194@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00))
                    ($Snap.combine
                      $Snap.unit
                      ($Snap.combine
                        $Snap.unit
                        ($Snap.combine
                          $Snap.unit
                          ($SortWrappers.$FVF<Int>To$Snap (sm@215@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00))))))))) this@102@00 G@103@00 V@104@00)
            (forall ((i1@216@00 Int)) (!
              (< i1@216@00 (alen<Int> (opt_get1 $Snap.unit G@103@00)))
              :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@216@00))
              :qid |option$array$-aux|))
            (forall ((r $Ref)) (!
              (implies
                (and
                  (<
                    (inv@218@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                    V@104@00)
                  (<=
                    0
                    (inv@218@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@219@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r) r))
              :pattern ((inv@218@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
              ))
            (forall ((r $Ref)) (!
              (implies
                (not
                  (=
                    (ite
                      (and
                        (<
                          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                          V@104@00)
                        (<=
                          0
                          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
                      $k@177@00
                      $Perm.No)
                    $Perm.No))
                (ite
                  (and
                    (<
                      (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                      V@104@00)
                    (<=
                      0
                      (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
                  (<
                    (ite
                      (and
                        (<
                          (inv@218@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                          V@104@00)
                        (<=
                          0
                          (inv@218@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
                      $k@217@00
                      $Perm.No)
                    $k@177@00)
                  (<
                    (ite
                      (and
                        (<
                          (inv@218@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                          V@104@00)
                        (<=
                          0
                          (inv@218@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
                      $k@217@00
                      $Perm.No)
                    $Perm.No)))
              :pattern ((inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
              :pattern ((inv@218@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
              :qid |qp.srp51|))
            (forall ((i1@222@00 Int)) (!
              (implies
                (and (< i1@222@00 V@104@00) (<= 0 i1@222@00))
                (not
                  (=
                    ($FVF.lookup_option$array$ (sm@223@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@222@00))
                    (as None<option<array>>  option<array>))))
              
              :qid |prog.l<no position>|))
            (forall ((i1@225@00 Int)) (!
              (implies
                (and (< i1@225@00 V@104@00) (<= 0 i1@225@00))
                (=
                  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@226@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@225@00))))
                  V@104@00))
              
              :qid |prog.l<no position>|))
            (forall ((i1@228@00 Int)) (!
              (forall ((i2@229@00 Int)) (!
                (implies
                  (and
                    (and
                      (and
                        (and
                          (=
                            ($FVF.lookup_option$array$ (sm@230@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
                              $Snap.unit
                              $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@228@00))
                            ($FVF.lookup_option$array$ (sm@232@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
                              $Snap.unit
                              $Snap.unit) (opt_get1 $Snap.unit G@103@00) i2@229@00)))
                          (< i2@229@00 V@104@00))
                        (<= 0 i2@229@00))
                      (< i1@228@00 V@104@00))
                    (<= 0 i1@228@00))
                  (= i1@228@00 i2@229@00))
                :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@103@00) i2@229@00))
                :qid |prog.l<no position>|))
              
              :qid |prog.l<no position>|))
            (forall ((i1@234@00 Int) (j@235@00 Int)) (!
              (and
                (< i1@234@00 (alen<Int> (opt_get1 $Snap.unit G@103@00)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@237@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@234@00)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@234@00))
                (not
                  (=
                    ($FVF.lookup_option$array$ (sm@237@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@234@00))
                    (as None<option<array>>  option<array>)))
                (<
                  j@235@00
                  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@237@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@234@00))))))
              :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@237@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@234@00))) j@235@00))
              :qid |int-aux|))
            (forall ((r $Ref)) (!
              (implies
                (and
                  (and
                    (and
                      (<
                        (inv@240@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                        V@104@00)
                      (<=
                        0
                        (inv@240@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
                    (<
                      (inv@239@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                      V@104@00))
                  (<=
                    0
                    (inv@239@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
                ($FVF.loc_int ($FVF.lookup_int (sm@241@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r) r))
              :pattern ((inv@239@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r) (inv@240@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
              ))
            (forall ((r $Ref)) (!
              (implies
                (not
                  (=
                    (ite
                      (and
                        (and
                          (and
                            (<
                              (inv@188@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                              V@104@00)
                            (<=
                              0
                              (inv@188@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
                          (<
                            (inv@187@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                            V@104@00))
                        (<=
                          0
                          (inv@187@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
                      $k@186@00
                      $Perm.No)
                    $Perm.No))
                (ite
                  (and
                    (and
                      (and
                        (<
                          (inv@188@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                          V@104@00)
                        (<=
                          0
                          (inv@188@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
                      (<
                        (inv@187@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                        V@104@00))
                    (<=
                      0
                      (inv@187@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
                  (<
                    (ite
                      (and
                        (and
                          (and
                            (<
                              (inv@240@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                              V@104@00)
                            (<=
                              0
                              (inv@240@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
                          (<
                            (inv@239@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                            V@104@00))
                        (<=
                          0
                          (inv@239@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
                      $k@236@00
                      $Perm.No)
                    $k@186@00)
                  (<
                    (ite
                      (and
                        (and
                          (and
                            (<
                              (inv@240@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                              V@104@00)
                            (<=
                              0
                              (inv@240@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
                          (<
                            (inv@239@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                            V@104@00))
                        (<=
                          0
                          (inv@239@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
                      $k@236@00
                      $Perm.No)
                    $Perm.No)))
              :pattern ((inv@188@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
              :pattern ((inv@187@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
              :pattern ((inv@240@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
              :pattern ((inv@239@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
              :qid |qp.srp77|))
            (SquareIntMatrix1 ($Snap.combine
              $Snap.unit
              ($Snap.combine
                $Snap.unit
                ($Snap.combine
                  $Snap.unit
                  ($Snap.combine
                    ($SortWrappers.$FVF<option<array>>To$Snap (sm@221@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00))
                    ($Snap.combine
                      $Snap.unit
                      ($Snap.combine
                        $Snap.unit
                        ($Snap.combine
                          $Snap.unit
                          ($SortWrappers.$FVF<Int>To$Snap (sm@243@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00))))))))) this@102@00 G@103@00 V@104@00))))))))
; Joined path conditions
(pop) ; 5
(push) ; 5
; [else-branch: 116 | !(s@105@00 < V@104@00)]
(assert (not (< s@105@00 V@104@00)))
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert ($Perm.isReadVar $k@191@00 $Perm.Write))
(assert (forall ((i1@190@00 Int)) (!
  (implies
    (and (and (< i1@190@00 V@104@00) (<= 0 i1@190@00)) (< $Perm.No $k@191@00))
    (=
      (inv@192@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@190@00))
      i1@190@00))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@190@00))
  :qid |option$array$-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (<
          (inv@192@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@192@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      (< $Perm.No $k@191@00))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@103@00) (inv@192@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
      r))
  :pattern ((inv@192@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
  :qid |option$array$-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (iff
    (Set_in r ($FVF.domain_option$array$ (sm@194@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00)))
    (and
      (and
        (<
          (inv@192@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@192@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      (< $Perm.No $k@191@00)))
  :pattern ((Set_in r ($FVF.domain_option$array$ (sm@194@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00))))
  :qid |qp.fvfDomDef24|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and
          (<
            (inv@192@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
            V@104@00)
          (<=
            0
            (inv@192@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
        (< $Perm.No $k@191@00))
      (ite
        (and
          (<
            (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
            V@104@00)
          (<=
            0
            (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
        (< $Perm.No $k@177@00)
        false))
    (=
      ($FVF.lookup_option$array$ (sm@194@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r)))
  :pattern (($FVF.lookup_option$array$ (sm@194@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r))
  :qid |qp.fvfValDef22|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r)
  :pattern (($FVF.lookup_option$array$ (sm@194@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :qid |qp.fvfResTrgDef23|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      (< $Perm.No $k@177@00)
      false)
    (=
      ($FVF.lookup_option$array$ (sm@196@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r)))
  :pattern (($FVF.lookup_option$array$ (sm@196@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r))
  :qid |qp.fvfValDef25|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r)
  :pattern (($FVF.lookup_option$array$ (sm@196@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :qid |qp.fvfResTrgDef26|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@197@00  $FPM) r)
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      $k@177@00
      $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@197@00  $FPM) r))
  :qid |qp.resPrmSumDef27|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@196@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@197@00  $FPM) r))
  :qid |qp.resTrgDef28|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      (< $Perm.No $k@177@00)
      false)
    (=
      ($FVF.lookup_option$array$ (sm@199@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r)))
  :pattern (($FVF.lookup_option$array$ (sm@199@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r))
  :qid |qp.fvfValDef29|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r)
  :pattern (($FVF.lookup_option$array$ (sm@199@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :qid |qp.fvfResTrgDef30|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@200@00  $FPM) r)
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      $k@177@00
      $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@200@00  $FPM) r))
  :qid |qp.resPrmSumDef31|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@199@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@200@00  $FPM) r))
  :qid |qp.resTrgDef32|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      (< $Perm.No $k@177@00)
      false)
    (=
      ($FVF.lookup_option$array$ (sm@203@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r)))
  :pattern (($FVF.lookup_option$array$ (sm@203@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r))
  :qid |qp.fvfValDef33|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r)
  :pattern (($FVF.lookup_option$array$ (sm@203@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :qid |qp.fvfResTrgDef34|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@204@00  $FPM) r)
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      $k@177@00
      $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@204@00  $FPM) r))
  :qid |qp.resPrmSumDef35|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@203@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@204@00  $FPM) r))
  :qid |qp.resTrgDef36|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      (< $Perm.No $k@177@00)
      false)
    (=
      ($FVF.lookup_option$array$ (sm@205@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r)))
  :pattern (($FVF.lookup_option$array$ (sm@205@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r))
  :qid |qp.fvfValDef37|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r)
  :pattern (($FVF.lookup_option$array$ (sm@205@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :qid |qp.fvfResTrgDef38|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@206@00  $FPM) r)
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      $k@177@00
      $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@206@00  $FPM) r))
  :qid |qp.resPrmSumDef39|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@205@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@206@00  $FPM) r))
  :qid |qp.resTrgDef40|)))
(assert ($Perm.isReadVar $k@209@00 $Perm.Write))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      (< $Perm.No $k@177@00)
      false)
    (=
      ($FVF.lookup_option$array$ (sm@210@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r)))
  :pattern (($FVF.lookup_option$array$ (sm@210@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r))
  :qid |qp.fvfValDef41|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r)
  :pattern (($FVF.lookup_option$array$ (sm@210@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :qid |qp.fvfResTrgDef42|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@211@00  $FPM) r)
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      $k@177@00
      $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@211@00  $FPM) r))
  :qid |qp.resPrmSumDef43|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@210@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@211@00  $FPM) r))
  :qid |qp.resTrgDef44|)))
(assert (forall ((i1@207@00 Int) (j@208@00 Int)) (!
  (implies
    (and
      (and
        (and (and (< j@208@00 V@104@00) (<= 0 j@208@00)) (< i1@207@00 V@104@00))
        (<= 0 i1@207@00))
      (< $Perm.No $k@209@00))
    (and
      (=
        (inv@212@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@210@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@207@00))) j@208@00))
        i1@207@00)
      (=
        (inv@213@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@210@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@207@00))) j@208@00))
        j@208@00)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@210@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@207@00))) j@208@00))
  :qid |int-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and
          (and
            (<
              (inv@213@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
              V@104@00)
            (<=
              0
              (inv@213@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
          (<
            (inv@212@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
            V@104@00))
        (<= 0 (inv@212@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      (< $Perm.No $k@209@00))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@210@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@103@00) (inv@212@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))) (inv@213@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
      r))
  :pattern ((inv@212@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
  :pattern ((inv@213@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (iff
    (Set_in r ($FVF.domain_int (sm@215@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00)))
    (and
      (and
        (and
          (and
            (<
              (inv@213@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
              V@104@00)
            (<=
              0
              (inv@213@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
          (<
            (inv@212@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
            V@104@00))
        (<= 0 (inv@212@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      (< $Perm.No $k@209@00)))
  :pattern ((Set_in r ($FVF.domain_int (sm@215@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00))))
  :qid |qp.fvfDomDef48|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and
          (and
            (and
              (<
                (inv@213@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                V@104@00)
              (<=
                0
                (inv@213@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
            (<
              (inv@212@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
              V@104@00))
          (<=
            0
            (inv@212@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
        (< $Perm.No $k@209@00))
      (ite
        (and
          (and
            (and
              (<
                (inv@188@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                V@104@00)
              (<=
                0
                (inv@188@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
            (<
              (inv@187@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
              V@104@00))
          (<=
            0
            (inv@187@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
        (< $Perm.No $k@186@00)
        false))
    (=
      ($FVF.lookup_int (sm@215@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$)))))))) r)))
  :pattern (($FVF.lookup_int (sm@215@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$)))))))) r))
  :qid |qp.fvfValDef46|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$)))))))) r) r)
  :pattern (($FVF.lookup_int (sm@215@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :qid |qp.fvfResTrgDef47|)))
(assert ($Perm.isReadVar $k@217@00 $Perm.Write))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      (< $Perm.No $k@177@00)
      false)
    (=
      ($FVF.lookup_option$array$ (sm@219@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r)))
  :pattern (($FVF.lookup_option$array$ (sm@219@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r))
  :qid |qp.fvfValDef49|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r)
  :pattern (($FVF.lookup_option$array$ (sm@219@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :qid |qp.fvfResTrgDef50|)))
(assert (forall ((i1@216@00 Int)) (!
  (implies
    (and (and (< i1@216@00 V@104@00) (<= 0 i1@216@00)) (< $Perm.No $k@217@00))
    (=
      (inv@218@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@216@00))
      i1@216@00))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@216@00))
  :qid |option$array$-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (<
          (inv@218@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@218@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      (< $Perm.No $k@217@00))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@103@00) (inv@218@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
      r))
  :pattern ((inv@218@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
  :qid |option$array$-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (iff
    (Set_in r ($FVF.domain_option$array$ (sm@221@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00)))
    (and
      (and
        (<
          (inv@218@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@218@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      (< $Perm.No $k@217@00)))
  :pattern ((Set_in r ($FVF.domain_option$array$ (sm@221@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00))))
  :qid |qp.fvfDomDef54|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and
          (<
            (inv@218@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
            V@104@00)
          (<=
            0
            (inv@218@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
        (< $Perm.No $k@217@00))
      (ite
        (and
          (<
            (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
            V@104@00)
          (<=
            0
            (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
        (< $Perm.No $k@177@00)
        false))
    (=
      ($FVF.lookup_option$array$ (sm@221@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r)))
  :pattern (($FVF.lookup_option$array$ (sm@221@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r))
  :qid |qp.fvfValDef52|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r)
  :pattern (($FVF.lookup_option$array$ (sm@221@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :qid |qp.fvfResTrgDef53|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      (< $Perm.No $k@177@00)
      false)
    (=
      ($FVF.lookup_option$array$ (sm@223@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r)))
  :pattern (($FVF.lookup_option$array$ (sm@223@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r))
  :qid |qp.fvfValDef55|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r)
  :pattern (($FVF.lookup_option$array$ (sm@223@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :qid |qp.fvfResTrgDef56|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@224@00  $FPM) r)
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      $k@177@00
      $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@224@00  $FPM) r))
  :qid |qp.resPrmSumDef57|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@223@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@224@00  $FPM) r))
  :qid |qp.resTrgDef58|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      (< $Perm.No $k@177@00)
      false)
    (=
      ($FVF.lookup_option$array$ (sm@226@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r)))
  :pattern (($FVF.lookup_option$array$ (sm@226@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r))
  :qid |qp.fvfValDef59|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r)
  :pattern (($FVF.lookup_option$array$ (sm@226@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :qid |qp.fvfResTrgDef60|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@227@00  $FPM) r)
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      $k@177@00
      $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@227@00  $FPM) r))
  :qid |qp.resPrmSumDef61|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@226@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@227@00  $FPM) r))
  :qid |qp.resTrgDef62|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      (< $Perm.No $k@177@00)
      false)
    (=
      ($FVF.lookup_option$array$ (sm@230@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r)))
  :pattern (($FVF.lookup_option$array$ (sm@230@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r))
  :qid |qp.fvfValDef63|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r)
  :pattern (($FVF.lookup_option$array$ (sm@230@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :qid |qp.fvfResTrgDef64|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@231@00  $FPM) r)
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      $k@177@00
      $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@231@00  $FPM) r))
  :qid |qp.resPrmSumDef65|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@230@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@231@00  $FPM) r))
  :qid |qp.resTrgDef66|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      (< $Perm.No $k@177@00)
      false)
    (=
      ($FVF.lookup_option$array$ (sm@232@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r)))
  :pattern (($FVF.lookup_option$array$ (sm@232@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r))
  :qid |qp.fvfValDef67|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r)
  :pattern (($FVF.lookup_option$array$ (sm@232@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :qid |qp.fvfResTrgDef68|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@233@00  $FPM) r)
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      $k@177@00
      $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@233@00  $FPM) r))
  :qid |qp.resPrmSumDef69|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@232@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@233@00  $FPM) r))
  :qid |qp.resTrgDef70|)))
(assert ($Perm.isReadVar $k@236@00 $Perm.Write))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      (< $Perm.No $k@177@00)
      false)
    (=
      ($FVF.lookup_option$array$ (sm@237@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r)))
  :pattern (($FVF.lookup_option$array$ (sm@237@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r))
  :qid |qp.fvfValDef71|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r)
  :pattern (($FVF.lookup_option$array$ (sm@237@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :qid |qp.fvfResTrgDef72|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@238@00  $FPM) r)
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      $k@177@00
      $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@238@00  $FPM) r))
  :qid |qp.resPrmSumDef73|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@237@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@238@00  $FPM) r))
  :qid |qp.resTrgDef74|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and
        (and
          (and
            (<
              (inv@188@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
              V@104@00)
            (<=
              0
              (inv@188@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
          (<
            (inv@187@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
            V@104@00))
        (<= 0 (inv@187@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      (< $Perm.No $k@186@00)
      false)
    (=
      ($FVF.lookup_int (sm@241@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$)))))))) r)))
  :pattern (($FVF.lookup_int (sm@241@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$)))))))) r))
  :qid |qp.fvfValDef75|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$)))))))) r) r)
  :pattern (($FVF.lookup_int (sm@241@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :qid |qp.fvfResTrgDef76|)))
(assert (forall ((i1@234@00 Int) (j@235@00 Int)) (!
  (implies
    (and
      (and
        (and (and (< j@235@00 V@104@00) (<= 0 j@235@00)) (< i1@234@00 V@104@00))
        (<= 0 i1@234@00))
      (< $Perm.No $k@236@00))
    (and
      (=
        (inv@239@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@237@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@234@00))) j@235@00))
        i1@234@00)
      (=
        (inv@240@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@237@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@234@00))) j@235@00))
        j@235@00)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@237@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@234@00))) j@235@00))
  :qid |int-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and
          (and
            (<
              (inv@240@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
              V@104@00)
            (<=
              0
              (inv@240@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
          (<
            (inv@239@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
            V@104@00))
        (<= 0 (inv@239@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      (< $Perm.No $k@236@00))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@237@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@103@00) (inv@239@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))) (inv@240@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
      r))
  :pattern ((inv@239@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
  :pattern ((inv@240@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (iff
    (Set_in r ($FVF.domain_int (sm@243@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00)))
    (and
      (and
        (and
          (and
            (<
              (inv@240@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
              V@104@00)
            (<=
              0
              (inv@240@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
          (<
            (inv@239@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
            V@104@00))
        (<= 0 (inv@239@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      (< $Perm.No $k@236@00)))
  :pattern ((Set_in r ($FVF.domain_int (sm@243@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00))))
  :qid |qp.fvfDomDef80|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and
          (and
            (and
              (<
                (inv@240@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                V@104@00)
              (<=
                0
                (inv@240@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
            (<
              (inv@239@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
              V@104@00))
          (<=
            0
            (inv@239@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
        (< $Perm.No $k@236@00))
      (ite
        (and
          (and
            (and
              (<
                (inv@188@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                V@104@00)
              (<=
                0
                (inv@188@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
            (<
              (inv@187@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
              V@104@00))
          (<=
            0
            (inv@187@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
        (< $Perm.No $k@186@00)
        false))
    (=
      ($FVF.lookup_int (sm@243@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$)))))))) r)))
  :pattern (($FVF.lookup_int (sm@243@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$)))))))) r))
  :qid |qp.fvfValDef78|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$)))))))) r) r)
  :pattern (($FVF.lookup_int (sm@243@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :qid |qp.fvfResTrgDef79|)))
(assert (implies
  (< s@105@00 V@104@00)
  (and
    (< s@105@00 V@104@00)
    (implies
      (<= 0 t@106@00)
      (and
        (<= 0 t@106@00)
        (implies
          (< t@106@00 V@104@00)
          (and
            (< t@106@00 V@104@00)
            (forall ((i1@190@00 Int)) (!
              (< i1@190@00 (alen<Int> (opt_get1 $Snap.unit G@103@00)))
              :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@190@00))
              :qid |option$array$-aux|))
            (forall ((r $Ref)) (!
              (implies
                (and
                  (<
                    (inv@192@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                    V@104@00)
                  (<=
                    0
                    (inv@192@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@179@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r) r))
              :pattern ((inv@192@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
              ))
            (forall ((r $Ref)) (!
              (implies
                (not
                  (=
                    (ite
                      (and
                        (<
                          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                          V@104@00)
                        (<=
                          0
                          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
                      $k@177@00
                      $Perm.No)
                    $Perm.No))
                (ite
                  (and
                    (<
                      (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                      V@104@00)
                    (<=
                      0
                      (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
                  (<
                    (ite
                      (and
                        (<
                          (inv@192@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                          V@104@00)
                        (<=
                          0
                          (inv@192@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
                      $k@191@00
                      $Perm.No)
                    $k@177@00)
                  (<
                    (ite
                      (and
                        (<
                          (inv@192@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                          V@104@00)
                        (<=
                          0
                          (inv@192@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
                      $k@191@00
                      $Perm.No)
                    $Perm.No)))
              :pattern ((inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
              :pattern ((inv@192@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
              :qid |qp.srp21|))
            (forall ((i1@195@00 Int)) (!
              (implies
                (and (< i1@195@00 V@104@00) (<= 0 i1@195@00))
                (not
                  (=
                    ($FVF.lookup_option$array$ (sm@196@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@195@00))
                    (as None<option<array>>  option<array>))))
              
              :qid |prog.l<no position>|))
            (forall ((i1@198@00 Int)) (!
              (implies
                (and (< i1@198@00 V@104@00) (<= 0 i1@198@00))
                (=
                  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@199@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@198@00))))
                  V@104@00))
              
              :qid |prog.l<no position>|))
            (forall ((i1@201@00 Int)) (!
              (forall ((i2@202@00 Int)) (!
                (implies
                  (and
                    (and
                      (and
                        (and
                          (=
                            ($FVF.lookup_option$array$ (sm@203@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
                              $Snap.unit
                              $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@201@00))
                            ($FVF.lookup_option$array$ (sm@205@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
                              $Snap.unit
                              $Snap.unit) (opt_get1 $Snap.unit G@103@00) i2@202@00)))
                          (< i2@202@00 V@104@00))
                        (<= 0 i2@202@00))
                      (< i1@201@00 V@104@00))
                    (<= 0 i1@201@00))
                  (= i1@201@00 i2@202@00))
                :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@103@00) i2@202@00))
                :qid |prog.l<no position>|))
              
              :qid |prog.l<no position>|))
            (forall ((i1@207@00 Int) (j@208@00 Int)) (!
              (and
                (< i1@207@00 (alen<Int> (opt_get1 $Snap.unit G@103@00)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@210@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@207@00)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@207@00))
                (not
                  (=
                    ($FVF.lookup_option$array$ (sm@210@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@207@00))
                    (as None<option<array>>  option<array>)))
                (<
                  j@208@00
                  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@210@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@207@00))))))
              :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@210@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@207@00))) j@208@00))
              :qid |int-aux|))
            (forall ((r $Ref)) (!
              (implies
                (and
                  (and
                    (and
                      (<
                        (inv@213@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                        V@104@00)
                      (<=
                        0
                        (inv@213@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
                    (<
                      (inv@212@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                      V@104@00))
                  (<=
                    0
                    (inv@212@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
                ($FVF.loc_int ($FVF.lookup_int (sm@189@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r) r))
              :pattern ((inv@212@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r) (inv@213@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
              ))
            (forall ((r $Ref)) (!
              (implies
                (not
                  (=
                    (ite
                      (and
                        (and
                          (and
                            (<
                              (inv@188@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                              V@104@00)
                            (<=
                              0
                              (inv@188@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
                          (<
                            (inv@187@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                            V@104@00))
                        (<=
                          0
                          (inv@187@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
                      $k@186@00
                      $Perm.No)
                    $Perm.No))
                (ite
                  (and
                    (and
                      (and
                        (<
                          (inv@188@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                          V@104@00)
                        (<=
                          0
                          (inv@188@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
                      (<
                        (inv@187@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                        V@104@00))
                    (<=
                      0
                      (inv@187@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
                  (<
                    (ite
                      (and
                        (and
                          (and
                            (<
                              (inv@213@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                              V@104@00)
                            (<=
                              0
                              (inv@213@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
                          (<
                            (inv@212@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                            V@104@00))
                        (<=
                          0
                          (inv@212@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
                      $k@209@00
                      $Perm.No)
                    $k@186@00)
                  (<
                    (ite
                      (and
                        (and
                          (and
                            (<
                              (inv@213@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                              V@104@00)
                            (<=
                              0
                              (inv@213@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
                          (<
                            (inv@212@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                            V@104@00))
                        (<=
                          0
                          (inv@212@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
                      $k@209@00
                      $Perm.No)
                    $Perm.No)))
              :pattern ((inv@188@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
              :pattern ((inv@187@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
              :pattern ((inv@213@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
              :pattern ((inv@212@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
              :qid |qp.srp45|))
            (implies
              (SquareIntMatrix1 ($Snap.combine
                $Snap.unit
                ($Snap.combine
                  $Snap.unit
                  ($Snap.combine
                    $Snap.unit
                    ($Snap.combine
                      ($SortWrappers.$FVF<option<array>>To$Snap (sm@194@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00))
                      ($Snap.combine
                        $Snap.unit
                        ($Snap.combine
                          $Snap.unit
                          ($Snap.combine
                            $Snap.unit
                            ($SortWrappers.$FVF<Int>To$Snap (sm@215@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00))))))))) this@102@00 G@103@00 V@104@00)
              (and
                (SquareIntMatrix1 ($Snap.combine
                  $Snap.unit
                  ($Snap.combine
                    $Snap.unit
                    ($Snap.combine
                      $Snap.unit
                      ($Snap.combine
                        ($SortWrappers.$FVF<option<array>>To$Snap (sm@194@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00))
                        ($Snap.combine
                          $Snap.unit
                          ($Snap.combine
                            $Snap.unit
                            ($Snap.combine
                              $Snap.unit
                              ($SortWrappers.$FVF<Int>To$Snap (sm@215@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00))))))))) this@102@00 G@103@00 V@104@00)
                (forall ((i1@216@00 Int)) (!
                  (< i1@216@00 (alen<Int> (opt_get1 $Snap.unit G@103@00)))
                  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@216@00))
                  :qid |option$array$-aux|))
                (forall ((r $Ref)) (!
                  (implies
                    (and
                      (<
                        (inv@218@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                        V@104@00)
                      (<=
                        0
                        (inv@218@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
                    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@219@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r) r))
                  :pattern ((inv@218@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
                  ))
                (forall ((r $Ref)) (!
                  (implies
                    (not
                      (=
                        (ite
                          (and
                            (<
                              (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                              V@104@00)
                            (<=
                              0
                              (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
                          $k@177@00
                          $Perm.No)
                        $Perm.No))
                    (ite
                      (and
                        (<
                          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                          V@104@00)
                        (<=
                          0
                          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
                      (<
                        (ite
                          (and
                            (<
                              (inv@218@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                              V@104@00)
                            (<=
                              0
                              (inv@218@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
                          $k@217@00
                          $Perm.No)
                        $k@177@00)
                      (<
                        (ite
                          (and
                            (<
                              (inv@218@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                              V@104@00)
                            (<=
                              0
                              (inv@218@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
                          $k@217@00
                          $Perm.No)
                        $Perm.No)))
                  :pattern ((inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
                  :pattern ((inv@218@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
                  :qid |qp.srp51|))
                (forall ((i1@222@00 Int)) (!
                  (implies
                    (and (< i1@222@00 V@104@00) (<= 0 i1@222@00))
                    (not
                      (=
                        ($FVF.lookup_option$array$ (sm@223@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
                          $Snap.unit
                          $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@222@00))
                        (as None<option<array>>  option<array>))))
                  
                  :qid |prog.l<no position>|))
                (forall ((i1@225@00 Int)) (!
                  (implies
                    (and (< i1@225@00 V@104@00) (<= 0 i1@225@00))
                    (=
                      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@226@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@225@00))))
                      V@104@00))
                  
                  :qid |prog.l<no position>|))
                (forall ((i1@228@00 Int)) (!
                  (forall ((i2@229@00 Int)) (!
                    (implies
                      (and
                        (and
                          (and
                            (and
                              (=
                                ($FVF.lookup_option$array$ (sm@230@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
                                  $Snap.unit
                                  $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@228@00))
                                ($FVF.lookup_option$array$ (sm@232@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
                                  $Snap.unit
                                  $Snap.unit) (opt_get1 $Snap.unit G@103@00) i2@229@00)))
                              (< i2@229@00 V@104@00))
                            (<= 0 i2@229@00))
                          (< i1@228@00 V@104@00))
                        (<= 0 i1@228@00))
                      (= i1@228@00 i2@229@00))
                    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@103@00) i2@229@00))
                    :qid |prog.l<no position>|))
                  
                  :qid |prog.l<no position>|))
                (forall ((i1@234@00 Int) (j@235@00 Int)) (!
                  (and
                    (< i1@234@00 (alen<Int> (opt_get1 $Snap.unit G@103@00)))
                    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@237@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@234@00)) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@234@00))
                    (not
                      (=
                        ($FVF.lookup_option$array$ (sm@237@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
                          $Snap.unit
                          $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@234@00))
                        (as None<option<array>>  option<array>)))
                    (<
                      j@235@00
                      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@237@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@234@00))))))
                  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@237@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@234@00))) j@235@00))
                  :qid |int-aux|))
                (forall ((r $Ref)) (!
                  (implies
                    (and
                      (and
                        (and
                          (<
                            (inv@240@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                            V@104@00)
                          (<=
                            0
                            (inv@240@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
                        (<
                          (inv@239@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                          V@104@00))
                      (<=
                        0
                        (inv@239@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
                    ($FVF.loc_int ($FVF.lookup_int (sm@241@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r) r))
                  :pattern ((inv@239@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r) (inv@240@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
                  ))
                (forall ((r $Ref)) (!
                  (implies
                    (not
                      (=
                        (ite
                          (and
                            (and
                              (and
                                (<
                                  (inv@188@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                                  V@104@00)
                                (<=
                                  0
                                  (inv@188@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
                              (<
                                (inv@187@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                                V@104@00))
                            (<=
                              0
                              (inv@187@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
                          $k@186@00
                          $Perm.No)
                        $Perm.No))
                    (ite
                      (and
                        (and
                          (and
                            (<
                              (inv@188@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                              V@104@00)
                            (<=
                              0
                              (inv@188@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
                          (<
                            (inv@187@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                            V@104@00))
                        (<=
                          0
                          (inv@187@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
                      (<
                        (ite
                          (and
                            (and
                              (and
                                (<
                                  (inv@240@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                                  V@104@00)
                                (<=
                                  0
                                  (inv@240@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
                              (<
                                (inv@239@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                                V@104@00))
                            (<=
                              0
                              (inv@239@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
                          $k@236@00
                          $Perm.No)
                        $k@186@00)
                      (<
                        (ite
                          (and
                            (and
                              (and
                                (<
                                  (inv@240@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                                  V@104@00)
                                (<=
                                  0
                                  (inv@240@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
                              (<
                                (inv@239@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                                V@104@00))
                            (<=
                              0
                              (inv@239@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
                          $k@236@00
                          $Perm.No)
                        $Perm.No)))
                  :pattern ((inv@188@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
                  :pattern ((inv@187@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
                  :pattern ((inv@240@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
                  :pattern ((inv@239@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
                  :qid |qp.srp77|))
                (SquareIntMatrix1 ($Snap.combine
                  $Snap.unit
                  ($Snap.combine
                    $Snap.unit
                    ($Snap.combine
                      $Snap.unit
                      ($Snap.combine
                        ($SortWrappers.$FVF<option<array>>To$Snap (sm@221@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00))
                        ($Snap.combine
                          $Snap.unit
                          ($Snap.combine
                            $Snap.unit
                            ($Snap.combine
                              $Snap.unit
                              ($SortWrappers.$FVF<Int>To$Snap (sm@243@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00))))))))) this@102@00 G@103@00 V@104@00))))))))))
; Joined path conditions
(pop) ; 3
(push) ; 3
; [else-branch: 115 | !(0 <= s@105@00)]
(assert (not (<= 0 s@105@00)))
(pop) ; 3
(pop) ; 2
; Joined path conditions
(assert ($Perm.isReadVar $k@191@00 $Perm.Write))
(assert (forall ((i1@190@00 Int)) (!
  (implies
    (and (and (< i1@190@00 V@104@00) (<= 0 i1@190@00)) (< $Perm.No $k@191@00))
    (=
      (inv@192@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@190@00))
      i1@190@00))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@190@00))
  :qid |option$array$-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (<
          (inv@192@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@192@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      (< $Perm.No $k@191@00))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@103@00) (inv@192@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
      r))
  :pattern ((inv@192@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
  :qid |option$array$-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (iff
    (Set_in r ($FVF.domain_option$array$ (sm@194@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00)))
    (and
      (and
        (<
          (inv@192@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@192@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      (< $Perm.No $k@191@00)))
  :pattern ((Set_in r ($FVF.domain_option$array$ (sm@194@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00))))
  :qid |qp.fvfDomDef24|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and
          (<
            (inv@192@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
            V@104@00)
          (<=
            0
            (inv@192@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
        (< $Perm.No $k@191@00))
      (ite
        (and
          (<
            (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
            V@104@00)
          (<=
            0
            (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
        (< $Perm.No $k@177@00)
        false))
    (=
      ($FVF.lookup_option$array$ (sm@194@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r)))
  :pattern (($FVF.lookup_option$array$ (sm@194@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r))
  :qid |qp.fvfValDef22|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r)
  :pattern (($FVF.lookup_option$array$ (sm@194@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :qid |qp.fvfResTrgDef23|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      (< $Perm.No $k@177@00)
      false)
    (=
      ($FVF.lookup_option$array$ (sm@196@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r)))
  :pattern (($FVF.lookup_option$array$ (sm@196@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r))
  :qid |qp.fvfValDef25|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r)
  :pattern (($FVF.lookup_option$array$ (sm@196@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :qid |qp.fvfResTrgDef26|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@197@00  $FPM) r)
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      $k@177@00
      $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@197@00  $FPM) r))
  :qid |qp.resPrmSumDef27|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@196@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@197@00  $FPM) r))
  :qid |qp.resTrgDef28|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      (< $Perm.No $k@177@00)
      false)
    (=
      ($FVF.lookup_option$array$ (sm@199@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r)))
  :pattern (($FVF.lookup_option$array$ (sm@199@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r))
  :qid |qp.fvfValDef29|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r)
  :pattern (($FVF.lookup_option$array$ (sm@199@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :qid |qp.fvfResTrgDef30|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@200@00  $FPM) r)
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      $k@177@00
      $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@200@00  $FPM) r))
  :qid |qp.resPrmSumDef31|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@199@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@200@00  $FPM) r))
  :qid |qp.resTrgDef32|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      (< $Perm.No $k@177@00)
      false)
    (=
      ($FVF.lookup_option$array$ (sm@203@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r)))
  :pattern (($FVF.lookup_option$array$ (sm@203@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r))
  :qid |qp.fvfValDef33|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r)
  :pattern (($FVF.lookup_option$array$ (sm@203@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :qid |qp.fvfResTrgDef34|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@204@00  $FPM) r)
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      $k@177@00
      $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@204@00  $FPM) r))
  :qid |qp.resPrmSumDef35|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@203@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@204@00  $FPM) r))
  :qid |qp.resTrgDef36|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      (< $Perm.No $k@177@00)
      false)
    (=
      ($FVF.lookup_option$array$ (sm@205@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r)))
  :pattern (($FVF.lookup_option$array$ (sm@205@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r))
  :qid |qp.fvfValDef37|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r)
  :pattern (($FVF.lookup_option$array$ (sm@205@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :qid |qp.fvfResTrgDef38|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@206@00  $FPM) r)
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      $k@177@00
      $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@206@00  $FPM) r))
  :qid |qp.resPrmSumDef39|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@205@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@206@00  $FPM) r))
  :qid |qp.resTrgDef40|)))
(assert ($Perm.isReadVar $k@209@00 $Perm.Write))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      (< $Perm.No $k@177@00)
      false)
    (=
      ($FVF.lookup_option$array$ (sm@210@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r)))
  :pattern (($FVF.lookup_option$array$ (sm@210@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r))
  :qid |qp.fvfValDef41|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r)
  :pattern (($FVF.lookup_option$array$ (sm@210@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :qid |qp.fvfResTrgDef42|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@211@00  $FPM) r)
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      $k@177@00
      $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@211@00  $FPM) r))
  :qid |qp.resPrmSumDef43|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@210@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@211@00  $FPM) r))
  :qid |qp.resTrgDef44|)))
(assert (forall ((i1@207@00 Int) (j@208@00 Int)) (!
  (implies
    (and
      (and
        (and (and (< j@208@00 V@104@00) (<= 0 j@208@00)) (< i1@207@00 V@104@00))
        (<= 0 i1@207@00))
      (< $Perm.No $k@209@00))
    (and
      (=
        (inv@212@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@210@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@207@00))) j@208@00))
        i1@207@00)
      (=
        (inv@213@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@210@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@207@00))) j@208@00))
        j@208@00)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@210@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@207@00))) j@208@00))
  :qid |int-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and
          (and
            (<
              (inv@213@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
              V@104@00)
            (<=
              0
              (inv@213@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
          (<
            (inv@212@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
            V@104@00))
        (<= 0 (inv@212@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      (< $Perm.No $k@209@00))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@210@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@103@00) (inv@212@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))) (inv@213@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
      r))
  :pattern ((inv@212@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
  :pattern ((inv@213@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (iff
    (Set_in r ($FVF.domain_int (sm@215@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00)))
    (and
      (and
        (and
          (and
            (<
              (inv@213@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
              V@104@00)
            (<=
              0
              (inv@213@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
          (<
            (inv@212@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
            V@104@00))
        (<= 0 (inv@212@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      (< $Perm.No $k@209@00)))
  :pattern ((Set_in r ($FVF.domain_int (sm@215@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00))))
  :qid |qp.fvfDomDef48|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and
          (and
            (and
              (<
                (inv@213@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                V@104@00)
              (<=
                0
                (inv@213@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
            (<
              (inv@212@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
              V@104@00))
          (<=
            0
            (inv@212@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
        (< $Perm.No $k@209@00))
      (ite
        (and
          (and
            (and
              (<
                (inv@188@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                V@104@00)
              (<=
                0
                (inv@188@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
            (<
              (inv@187@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
              V@104@00))
          (<=
            0
            (inv@187@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
        (< $Perm.No $k@186@00)
        false))
    (=
      ($FVF.lookup_int (sm@215@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$)))))))) r)))
  :pattern (($FVF.lookup_int (sm@215@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$)))))))) r))
  :qid |qp.fvfValDef46|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$)))))))) r) r)
  :pattern (($FVF.lookup_int (sm@215@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :qid |qp.fvfResTrgDef47|)))
(assert ($Perm.isReadVar $k@217@00 $Perm.Write))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      (< $Perm.No $k@177@00)
      false)
    (=
      ($FVF.lookup_option$array$ (sm@219@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r)))
  :pattern (($FVF.lookup_option$array$ (sm@219@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r))
  :qid |qp.fvfValDef49|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r)
  :pattern (($FVF.lookup_option$array$ (sm@219@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :qid |qp.fvfResTrgDef50|)))
(assert (forall ((i1@216@00 Int)) (!
  (implies
    (and (and (< i1@216@00 V@104@00) (<= 0 i1@216@00)) (< $Perm.No $k@217@00))
    (=
      (inv@218@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@216@00))
      i1@216@00))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@216@00))
  :qid |option$array$-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (<
          (inv@218@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@218@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      (< $Perm.No $k@217@00))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@103@00) (inv@218@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
      r))
  :pattern ((inv@218@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
  :qid |option$array$-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (iff
    (Set_in r ($FVF.domain_option$array$ (sm@221@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00)))
    (and
      (and
        (<
          (inv@218@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@218@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      (< $Perm.No $k@217@00)))
  :pattern ((Set_in r ($FVF.domain_option$array$ (sm@221@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00))))
  :qid |qp.fvfDomDef54|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and
          (<
            (inv@218@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
            V@104@00)
          (<=
            0
            (inv@218@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
        (< $Perm.No $k@217@00))
      (ite
        (and
          (<
            (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
            V@104@00)
          (<=
            0
            (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
        (< $Perm.No $k@177@00)
        false))
    (=
      ($FVF.lookup_option$array$ (sm@221@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r)))
  :pattern (($FVF.lookup_option$array$ (sm@221@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r))
  :qid |qp.fvfValDef52|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r)
  :pattern (($FVF.lookup_option$array$ (sm@221@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :qid |qp.fvfResTrgDef53|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      (< $Perm.No $k@177@00)
      false)
    (=
      ($FVF.lookup_option$array$ (sm@223@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r)))
  :pattern (($FVF.lookup_option$array$ (sm@223@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r))
  :qid |qp.fvfValDef55|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r)
  :pattern (($FVF.lookup_option$array$ (sm@223@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :qid |qp.fvfResTrgDef56|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@224@00  $FPM) r)
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      $k@177@00
      $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@224@00  $FPM) r))
  :qid |qp.resPrmSumDef57|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@223@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@224@00  $FPM) r))
  :qid |qp.resTrgDef58|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      (< $Perm.No $k@177@00)
      false)
    (=
      ($FVF.lookup_option$array$ (sm@226@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r)))
  :pattern (($FVF.lookup_option$array$ (sm@226@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r))
  :qid |qp.fvfValDef59|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r)
  :pattern (($FVF.lookup_option$array$ (sm@226@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :qid |qp.fvfResTrgDef60|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@227@00  $FPM) r)
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      $k@177@00
      $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@227@00  $FPM) r))
  :qid |qp.resPrmSumDef61|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@226@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@227@00  $FPM) r))
  :qid |qp.resTrgDef62|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      (< $Perm.No $k@177@00)
      false)
    (=
      ($FVF.lookup_option$array$ (sm@230@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r)))
  :pattern (($FVF.lookup_option$array$ (sm@230@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r))
  :qid |qp.fvfValDef63|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r)
  :pattern (($FVF.lookup_option$array$ (sm@230@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :qid |qp.fvfResTrgDef64|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@231@00  $FPM) r)
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      $k@177@00
      $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@231@00  $FPM) r))
  :qid |qp.resPrmSumDef65|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@230@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@231@00  $FPM) r))
  :qid |qp.resTrgDef66|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      (< $Perm.No $k@177@00)
      false)
    (=
      ($FVF.lookup_option$array$ (sm@232@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r)))
  :pattern (($FVF.lookup_option$array$ (sm@232@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r))
  :qid |qp.fvfValDef67|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r)
  :pattern (($FVF.lookup_option$array$ (sm@232@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :qid |qp.fvfResTrgDef68|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@233@00  $FPM) r)
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      $k@177@00
      $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@233@00  $FPM) r))
  :qid |qp.resPrmSumDef69|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@232@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@233@00  $FPM) r))
  :qid |qp.resTrgDef70|)))
(assert ($Perm.isReadVar $k@236@00 $Perm.Write))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      (< $Perm.No $k@177@00)
      false)
    (=
      ($FVF.lookup_option$array$ (sm@237@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r)))
  :pattern (($FVF.lookup_option$array$ (sm@237@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r))
  :qid |qp.fvfValDef71|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r)
  :pattern (($FVF.lookup_option$array$ (sm@237@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :qid |qp.fvfResTrgDef72|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@238@00  $FPM) r)
    (ite
      (and
        (<
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00)
        (<= 0 (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      $k@177@00
      $Perm.No))
  :pattern (($FVF.perm_option$array$ (as pm@238@00  $FPM) r))
  :qid |qp.resPrmSumDef73|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@237@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@238@00  $FPM) r))
  :qid |qp.resTrgDef74|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and
        (and
          (and
            (<
              (inv@188@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
              V@104@00)
            (<=
              0
              (inv@188@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
          (<
            (inv@187@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
            V@104@00))
        (<= 0 (inv@187@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      (< $Perm.No $k@186@00)
      false)
    (=
      ($FVF.lookup_int (sm@241@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$)))))))) r)))
  :pattern (($FVF.lookup_int (sm@241@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$)))))))) r))
  :qid |qp.fvfValDef75|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$)))))))) r) r)
  :pattern (($FVF.lookup_int (sm@241@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :qid |qp.fvfResTrgDef76|)))
(assert (forall ((i1@234@00 Int) (j@235@00 Int)) (!
  (implies
    (and
      (and
        (and (and (< j@235@00 V@104@00) (<= 0 j@235@00)) (< i1@234@00 V@104@00))
        (<= 0 i1@234@00))
      (< $Perm.No $k@236@00))
    (and
      (=
        (inv@239@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@237@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@234@00))) j@235@00))
        i1@234@00)
      (=
        (inv@240@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@237@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@234@00))) j@235@00))
        j@235@00)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@237@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@234@00))) j@235@00))
  :qid |int-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and
          (and
            (<
              (inv@240@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
              V@104@00)
            (<=
              0
              (inv@240@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
          (<
            (inv@239@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
            V@104@00))
        (<= 0 (inv@239@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      (< $Perm.No $k@236@00))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@237@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@103@00) (inv@239@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))) (inv@240@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
      r))
  :pattern ((inv@239@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
  :pattern ((inv@240@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (iff
    (Set_in r ($FVF.domain_int (sm@243@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00)))
    (and
      (and
        (and
          (and
            (<
              (inv@240@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
              V@104@00)
            (<=
              0
              (inv@240@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
          (<
            (inv@239@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
            V@104@00))
        (<= 0 (inv@239@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
      (< $Perm.No $k@236@00)))
  :pattern ((Set_in r ($FVF.domain_int (sm@243@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00))))
  :qid |qp.fvfDomDef80|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and
          (and
            (and
              (<
                (inv@240@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                V@104@00)
              (<=
                0
                (inv@240@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
            (<
              (inv@239@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
              V@104@00))
          (<=
            0
            (inv@239@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
        (< $Perm.No $k@236@00))
      (ite
        (and
          (and
            (and
              (<
                (inv@188@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                V@104@00)
              (<=
                0
                (inv@188@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
            (<
              (inv@187@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
              V@104@00))
          (<=
            0
            (inv@187@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
        (< $Perm.No $k@186@00)
        false))
    (=
      ($FVF.lookup_int (sm@243@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$)))))))) r)))
  :pattern (($FVF.lookup_int (sm@243@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$)))))))) r))
  :qid |qp.fvfValDef78|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$)))))))) r) r)
  :pattern (($FVF.lookup_int (sm@243@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
  :qid |qp.fvfResTrgDef79|)))
(assert (implies
  (<= 0 s@105@00)
  (and
    (<= 0 s@105@00)
    (implies
      (< s@105@00 V@104@00)
      (and
        (< s@105@00 V@104@00)
        (implies
          (<= 0 t@106@00)
          (and
            (<= 0 t@106@00)
            (implies
              (< t@106@00 V@104@00)
              (and
                (< t@106@00 V@104@00)
                (forall ((i1@190@00 Int)) (!
                  (< i1@190@00 (alen<Int> (opt_get1 $Snap.unit G@103@00)))
                  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@190@00))
                  :qid |option$array$-aux|))
                (forall ((r $Ref)) (!
                  (implies
                    (and
                      (<
                        (inv@192@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                        V@104@00)
                      (<=
                        0
                        (inv@192@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
                    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@179@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r) r))
                  :pattern ((inv@192@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
                  ))
                (forall ((r $Ref)) (!
                  (implies
                    (not
                      (=
                        (ite
                          (and
                            (<
                              (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                              V@104@00)
                            (<=
                              0
                              (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
                          $k@177@00
                          $Perm.No)
                        $Perm.No))
                    (ite
                      (and
                        (<
                          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                          V@104@00)
                        (<=
                          0
                          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
                      (<
                        (ite
                          (and
                            (<
                              (inv@192@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                              V@104@00)
                            (<=
                              0
                              (inv@192@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
                          $k@191@00
                          $Perm.No)
                        $k@177@00)
                      (<
                        (ite
                          (and
                            (<
                              (inv@192@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                              V@104@00)
                            (<=
                              0
                              (inv@192@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
                          $k@191@00
                          $Perm.No)
                        $Perm.No)))
                  :pattern ((inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
                  :pattern ((inv@192@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
                  :qid |qp.srp21|))
                (forall ((i1@195@00 Int)) (!
                  (implies
                    (and (< i1@195@00 V@104@00) (<= 0 i1@195@00))
                    (not
                      (=
                        ($FVF.lookup_option$array$ (sm@196@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
                          $Snap.unit
                          $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@195@00))
                        (as None<option<array>>  option<array>))))
                  
                  :qid |prog.l<no position>|))
                (forall ((i1@198@00 Int)) (!
                  (implies
                    (and (< i1@198@00 V@104@00) (<= 0 i1@198@00))
                    (=
                      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@199@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@198@00))))
                      V@104@00))
                  
                  :qid |prog.l<no position>|))
                (forall ((i1@201@00 Int)) (!
                  (forall ((i2@202@00 Int)) (!
                    (implies
                      (and
                        (and
                          (and
                            (and
                              (=
                                ($FVF.lookup_option$array$ (sm@203@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
                                  $Snap.unit
                                  $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@201@00))
                                ($FVF.lookup_option$array$ (sm@205@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
                                  $Snap.unit
                                  $Snap.unit) (opt_get1 $Snap.unit G@103@00) i2@202@00)))
                              (< i2@202@00 V@104@00))
                            (<= 0 i2@202@00))
                          (< i1@201@00 V@104@00))
                        (<= 0 i1@201@00))
                      (= i1@201@00 i2@202@00))
                    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@103@00) i2@202@00))
                    :qid |prog.l<no position>|))
                  
                  :qid |prog.l<no position>|))
                (forall ((i1@207@00 Int) (j@208@00 Int)) (!
                  (and
                    (< i1@207@00 (alen<Int> (opt_get1 $Snap.unit G@103@00)))
                    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@210@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@207@00)) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@207@00))
                    (not
                      (=
                        ($FVF.lookup_option$array$ (sm@210@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
                          $Snap.unit
                          $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@207@00))
                        (as None<option<array>>  option<array>)))
                    (<
                      j@208@00
                      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@210@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@207@00))))))
                  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@210@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@207@00))) j@208@00))
                  :qid |int-aux|))
                (forall ((r $Ref)) (!
                  (implies
                    (and
                      (and
                        (and
                          (<
                            (inv@213@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                            V@104@00)
                          (<=
                            0
                            (inv@213@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
                        (<
                          (inv@212@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                          V@104@00))
                      (<=
                        0
                        (inv@212@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
                    ($FVF.loc_int ($FVF.lookup_int (sm@189@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r) r))
                  :pattern ((inv@212@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r) (inv@213@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
                  ))
                (forall ((r $Ref)) (!
                  (implies
                    (not
                      (=
                        (ite
                          (and
                            (and
                              (and
                                (<
                                  (inv@188@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                                  V@104@00)
                                (<=
                                  0
                                  (inv@188@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
                              (<
                                (inv@187@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                                V@104@00))
                            (<=
                              0
                              (inv@187@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
                          $k@186@00
                          $Perm.No)
                        $Perm.No))
                    (ite
                      (and
                        (and
                          (and
                            (<
                              (inv@188@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                              V@104@00)
                            (<=
                              0
                              (inv@188@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
                          (<
                            (inv@187@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                            V@104@00))
                        (<=
                          0
                          (inv@187@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
                      (<
                        (ite
                          (and
                            (and
                              (and
                                (<
                                  (inv@213@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                                  V@104@00)
                                (<=
                                  0
                                  (inv@213@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
                              (<
                                (inv@212@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                                V@104@00))
                            (<=
                              0
                              (inv@212@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
                          $k@209@00
                          $Perm.No)
                        $k@186@00)
                      (<
                        (ite
                          (and
                            (and
                              (and
                                (<
                                  (inv@213@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                                  V@104@00)
                                (<=
                                  0
                                  (inv@213@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
                              (<
                                (inv@212@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                                V@104@00))
                            (<=
                              0
                              (inv@212@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
                          $k@209@00
                          $Perm.No)
                        $Perm.No)))
                  :pattern ((inv@188@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
                  :pattern ((inv@187@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
                  :pattern ((inv@213@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
                  :pattern ((inv@212@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
                  :qid |qp.srp45|))
                (implies
                  (SquareIntMatrix1 ($Snap.combine
                    $Snap.unit
                    ($Snap.combine
                      $Snap.unit
                      ($Snap.combine
                        $Snap.unit
                        ($Snap.combine
                          ($SortWrappers.$FVF<option<array>>To$Snap (sm@194@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00))
                          ($Snap.combine
                            $Snap.unit
                            ($Snap.combine
                              $Snap.unit
                              ($Snap.combine
                                $Snap.unit
                                ($SortWrappers.$FVF<Int>To$Snap (sm@215@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00))))))))) this@102@00 G@103@00 V@104@00)
                  (and
                    (SquareIntMatrix1 ($Snap.combine
                      $Snap.unit
                      ($Snap.combine
                        $Snap.unit
                        ($Snap.combine
                          $Snap.unit
                          ($Snap.combine
                            ($SortWrappers.$FVF<option<array>>To$Snap (sm@194@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00))
                            ($Snap.combine
                              $Snap.unit
                              ($Snap.combine
                                $Snap.unit
                                ($Snap.combine
                                  $Snap.unit
                                  ($SortWrappers.$FVF<Int>To$Snap (sm@215@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00))))))))) this@102@00 G@103@00 V@104@00)
                    (forall ((i1@216@00 Int)) (!
                      (< i1@216@00 (alen<Int> (opt_get1 $Snap.unit G@103@00)))
                      :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@216@00))
                      :qid |option$array$-aux|))
                    (forall ((r $Ref)) (!
                      (implies
                        (and
                          (<
                            (inv@218@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                            V@104@00)
                          (<=
                            0
                            (inv@218@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
                        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@219@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r) r))
                      :pattern ((inv@218@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
                      ))
                    (forall ((r $Ref)) (!
                      (implies
                        (not
                          (=
                            (ite
                              (and
                                (<
                                  (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                                  V@104@00)
                                (<=
                                  0
                                  (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
                              $k@177@00
                              $Perm.No)
                            $Perm.No))
                        (ite
                          (and
                            (<
                              (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                              V@104@00)
                            (<=
                              0
                              (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
                          (<
                            (ite
                              (and
                                (<
                                  (inv@218@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                                  V@104@00)
                                (<=
                                  0
                                  (inv@218@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
                              $k@217@00
                              $Perm.No)
                            $k@177@00)
                          (<
                            (ite
                              (and
                                (<
                                  (inv@218@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                                  V@104@00)
                                (<=
                                  0
                                  (inv@218@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
                              $k@217@00
                              $Perm.No)
                            $Perm.No)))
                      :pattern ((inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
                      :pattern ((inv@218@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
                      :qid |qp.srp51|))
                    (forall ((i1@222@00 Int)) (!
                      (implies
                        (and (< i1@222@00 V@104@00) (<= 0 i1@222@00))
                        (not
                          (=
                            ($FVF.lookup_option$array$ (sm@223@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
                              $Snap.unit
                              $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@222@00))
                            (as None<option<array>>  option<array>))))
                      
                      :qid |prog.l<no position>|))
                    (forall ((i1@225@00 Int)) (!
                      (implies
                        (and (< i1@225@00 V@104@00) (<= 0 i1@225@00))
                        (=
                          (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@226@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
                            $Snap.unit
                            $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@225@00))))
                          V@104@00))
                      
                      :qid |prog.l<no position>|))
                    (forall ((i1@228@00 Int)) (!
                      (forall ((i2@229@00 Int)) (!
                        (implies
                          (and
                            (and
                              (and
                                (and
                                  (=
                                    ($FVF.lookup_option$array$ (sm@230@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
                                      $Snap.unit
                                      $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@228@00))
                                    ($FVF.lookup_option$array$ (sm@232@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
                                      $Snap.unit
                                      $Snap.unit) (opt_get1 $Snap.unit G@103@00) i2@229@00)))
                                  (< i2@229@00 V@104@00))
                                (<= 0 i2@229@00))
                              (< i1@228@00 V@104@00))
                            (<= 0 i1@228@00))
                          (= i1@228@00 i2@229@00))
                        :pattern ((aloc%limited ($Snap.combine
                          $Snap.unit
                          $Snap.unit) (opt_get1 $Snap.unit G@103@00) i2@229@00))
                        :qid |prog.l<no position>|))
                      
                      :qid |prog.l<no position>|))
                    (forall ((i1@234@00 Int) (j@235@00 Int)) (!
                      (and
                        (< i1@234@00 (alen<Int> (opt_get1 $Snap.unit G@103@00)))
                        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (sm@237@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
                          $Snap.unit
                          $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@234@00)) (aloc ($Snap.combine
                          $Snap.unit
                          $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@234@00))
                        (not
                          (=
                            ($FVF.lookup_option$array$ (sm@237@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
                              $Snap.unit
                              $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@234@00))
                            (as None<option<array>>  option<array>)))
                        (<
                          j@235@00
                          (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@237@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
                            $Snap.unit
                            $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@234@00))))))
                      :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@237@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@234@00))) j@235@00))
                      :qid |int-aux|))
                    (forall ((r $Ref)) (!
                      (implies
                        (and
                          (and
                            (and
                              (<
                                (inv@240@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                                V@104@00)
                              (<=
                                0
                                (inv@240@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
                            (<
                              (inv@239@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                              V@104@00))
                          (<=
                            0
                            (inv@239@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
                        ($FVF.loc_int ($FVF.lookup_int (sm@241@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r) r))
                      :pattern ((inv@239@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r) (inv@240@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
                      ))
                    (forall ((r $Ref)) (!
                      (implies
                        (not
                          (=
                            (ite
                              (and
                                (and
                                  (and
                                    (<
                                      (inv@188@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                                      V@104@00)
                                    (<=
                                      0
                                      (inv@188@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
                                  (<
                                    (inv@187@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                                    V@104@00))
                                (<=
                                  0
                                  (inv@187@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
                              $k@186@00
                              $Perm.No)
                            $Perm.No))
                        (ite
                          (and
                            (and
                              (and
                                (<
                                  (inv@188@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                                  V@104@00)
                                (<=
                                  0
                                  (inv@188@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
                              (<
                                (inv@187@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                                V@104@00))
                            (<=
                              0
                              (inv@187@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
                          (<
                            (ite
                              (and
                                (and
                                  (and
                                    (<
                                      (inv@240@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                                      V@104@00)
                                    (<=
                                      0
                                      (inv@240@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
                                  (<
                                    (inv@239@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                                    V@104@00))
                                (<=
                                  0
                                  (inv@239@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
                              $k@236@00
                              $Perm.No)
                            $k@186@00)
                          (<
                            (ite
                              (and
                                (and
                                  (and
                                    (<
                                      (inv@240@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                                      V@104@00)
                                    (<=
                                      0
                                      (inv@240@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
                                  (<
                                    (inv@239@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                                    V@104@00))
                                (<=
                                  0
                                  (inv@239@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
                              $k@236@00
                              $Perm.No)
                            $Perm.No)))
                      :pattern ((inv@188@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
                      :pattern ((inv@187@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
                      :pattern ((inv@240@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
                      :pattern ((inv@239@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
                      :qid |qp.srp77|))
                    (SquareIntMatrix1 ($Snap.combine
                      $Snap.unit
                      ($Snap.combine
                        $Snap.unit
                        ($Snap.combine
                          $Snap.unit
                          ($Snap.combine
                            ($SortWrappers.$FVF<option<array>>To$Snap (sm@221@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00))
                            ($Snap.combine
                              $Snap.unit
                              ($Snap.combine
                                $Snap.unit
                                ($Snap.combine
                                  $Snap.unit
                                  ($SortWrappers.$FVF<Int>To$Snap (sm@243@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00))))))))) this@102@00 G@103@00 V@104@00))))))))))))
; Joined path conditions
(assert (=
  result@107@00
  (and
    (and
      (and
        (and
          (and
            (NonNegativeCapacities1 ($Snap.combine $Snap.unit $Snap.unit) this@102@00 G@103@00 V@104@00)
            (SquareIntMatrix1 ($Snap.combine
              $Snap.unit
              ($Snap.combine
                $Snap.unit
                ($Snap.combine
                  $Snap.unit
                  ($Snap.combine
                    ($SortWrappers.$FVF<option<array>>To$Snap (sm@194@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00))
                    ($Snap.combine
                      $Snap.unit
                      ($Snap.combine
                        $Snap.unit
                        ($Snap.combine
                          $Snap.unit
                          ($SortWrappers.$FVF<Int>To$Snap (sm@215@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00))))))))) this@102@00 G@103@00 V@104@00))
          (< t@106@00 V@104@00))
        (<= 0 t@106@00))
      (< s@105@00 V@104@00))
    (<= 0 s@105@00))))
(pop) ; 1
(assert (forall ((s@$ $Snap) (this@102@00 $Ref) (G@103@00 option<array>) (V@104@00 Int) (s@105@00 Int) (t@106@00 Int)) (!
  (and
    (forall ((i1@176@00 Int)) (!
      (implies
        (and
          (and (< i1@176@00 V@104@00) (<= 0 i1@176@00))
          (< $Perm.No $k@177@00))
        (=
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@176@00))
          i1@176@00))
      :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@176@00))
      ))
    (forall ((r $Ref)) (!
      (implies
        (and
          (and
            (<
              (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
              V@104@00)
            (<=
              0
              (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
          (< $Perm.No $k@177@00))
        (=
          (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@103@00) (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
          r))
      :pattern ((inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
      :qid |option$array$-fctOfInv|))
    (forall ((i1@184@00 Int) (j@185@00 Int)) (!
      (implies
        (and
          (and
            (and
              (and (< j@185@00 V@104@00) (<= 0 j@185@00))
              (< i1@184@00 V@104@00))
            (<= 0 i1@184@00))
          (< $Perm.No $k@186@00))
        (and
          (=
            (inv@187@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@179@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@184@00))) j@185@00))
            i1@184@00)
          (=
            (inv@188@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@179@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@184@00))) j@185@00))
            j@185@00)))
      :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@179@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@184@00))) j@185@00))
      ))
    (forall ((r $Ref)) (!
      (implies
        (and
          (and
            (and
              (and
                (<
                  (inv@188@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                  V@104@00)
                (<=
                  0
                  (inv@188@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
              (<
                (inv@187@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                V@104@00))
            (<=
              0
              (inv@187@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
          (< $Perm.No $k@186@00))
        (=
          (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@179@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@103@00) (inv@187@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))) (inv@188@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
          r))
      :pattern ((inv@187@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
      :pattern ((inv@188@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
      :qid |int-fctOfInv|))
    (forall ((i1@190@00 Int)) (!
      (implies
        (and
          (and (< i1@190@00 V@104@00) (<= 0 i1@190@00))
          (< $Perm.No $k@191@00))
        (=
          (inv@192@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@190@00))
          i1@190@00))
      :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@190@00))
      :qid |option$array$-invOfFct|))
    (forall ((r $Ref)) (!
      (implies
        (and
          (and
            (<
              (inv@192@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
              V@104@00)
            (<=
              0
              (inv@192@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
          (< $Perm.No $k@191@00))
        (=
          (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@103@00) (inv@192@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
          r))
      :pattern ((inv@192@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
      :qid |option$array$-fctOfInv|))
    (forall ((i1@207@00 Int) (j@208@00 Int)) (!
      (implies
        (and
          (and
            (and
              (and (< j@208@00 V@104@00) (<= 0 j@208@00))
              (< i1@207@00 V@104@00))
            (<= 0 i1@207@00))
          (< $Perm.No $k@209@00))
        (and
          (=
            (inv@212@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@210@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@207@00))) j@208@00))
            i1@207@00)
          (=
            (inv@213@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@210@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@207@00))) j@208@00))
            j@208@00)))
      :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@210@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@207@00))) j@208@00))
      :qid |int-invOfFct|))
    (forall ((r $Ref)) (!
      (implies
        (and
          (and
            (and
              (and
                (<
                  (inv@213@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                  V@104@00)
                (<=
                  0
                  (inv@213@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
              (<
                (inv@212@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                V@104@00))
            (<=
              0
              (inv@212@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
          (< $Perm.No $k@209@00))
        (=
          (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@210@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@103@00) (inv@212@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))) (inv@213@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
          r))
      :pattern ((inv@212@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
      :pattern ((inv@213@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
      :qid |int-fctOfInv|))
    (forall ((r $Ref)) (!
      (implies
        (ite
          (and
            (<
              (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
              V@104@00)
            (<=
              0
              (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
          (< $Perm.No $k@177@00)
          false)
        (=
          ($FVF.lookup_option$array$ (sm@179@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r)
          ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r)))
      :pattern (($FVF.lookup_option$array$ (sm@179@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
      :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r))
      :qid |qp.fvfValDef17|))
    (forall ((r $Ref)) (!
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r)
      :pattern (($FVF.lookup_option$array$ (sm@179@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
      :qid |qp.fvfResTrgDef18|))
    (forall ((r $Ref)) (!
      (iff
        (Set_in r ($FVF.domain_option$array$ (sm@194@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00)))
        (and
          (and
            (<
              (inv@192@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
              V@104@00)
            (<=
              0
              (inv@192@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
          (< $Perm.No $k@191@00)))
      :pattern ((Set_in r ($FVF.domain_option$array$ (sm@194@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00))))
      :qid |qp.fvfDomDef24|))
    (forall ((r $Ref)) (!
      (implies
        (and
          (and
            (and
              (<
                (inv@192@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                V@104@00)
              (<=
                0
                (inv@192@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
            (< $Perm.No $k@191@00))
          (ite
            (and
              (<
                (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                V@104@00)
              (<=
                0
                (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
            (< $Perm.No $k@177@00)
            false))
        (=
          ($FVF.lookup_option$array$ (sm@194@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r)
          ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r)))
      :pattern (($FVF.lookup_option$array$ (sm@194@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
      :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r))
      :qid |qp.fvfValDef22|))
    (forall ((r $Ref)) (!
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r)
      :pattern (($FVF.lookup_option$array$ (sm@194@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
      :qid |qp.fvfResTrgDef23|))
    (forall ((r $Ref)) (!
      (implies
        (ite
          (and
            (<
              (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
              V@104@00)
            (<=
              0
              (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
          (< $Perm.No $k@177@00)
          false)
        (=
          ($FVF.lookup_option$array$ (sm@196@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r)
          ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r)))
      :pattern (($FVF.lookup_option$array$ (sm@196@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
      :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r))
      :qid |qp.fvfValDef25|))
    (forall ((r $Ref)) (!
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r)
      :pattern (($FVF.lookup_option$array$ (sm@196@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
      :qid |qp.fvfResTrgDef26|))
    (forall ((r $Ref)) (!
      (implies
        (ite
          (and
            (<
              (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
              V@104@00)
            (<=
              0
              (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
          (< $Perm.No $k@177@00)
          false)
        (=
          ($FVF.lookup_option$array$ (sm@199@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r)
          ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r)))
      :pattern (($FVF.lookup_option$array$ (sm@199@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
      :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r))
      :qid |qp.fvfValDef29|))
    (forall ((r $Ref)) (!
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r)
      :pattern (($FVF.lookup_option$array$ (sm@199@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
      :qid |qp.fvfResTrgDef30|))
    (forall ((r $Ref)) (!
      (implies
        (ite
          (and
            (<
              (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
              V@104@00)
            (<=
              0
              (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
          (< $Perm.No $k@177@00)
          false)
        (=
          ($FVF.lookup_option$array$ (sm@203@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r)
          ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r)))
      :pattern (($FVF.lookup_option$array$ (sm@203@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
      :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r))
      :qid |qp.fvfValDef33|))
    (forall ((r $Ref)) (!
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r)
      :pattern (($FVF.lookup_option$array$ (sm@203@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
      :qid |qp.fvfResTrgDef34|))
    (forall ((r $Ref)) (!
      (implies
        (ite
          (and
            (<
              (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
              V@104@00)
            (<=
              0
              (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
          (< $Perm.No $k@177@00)
          false)
        (=
          ($FVF.lookup_option$array$ (sm@205@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r)
          ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r)))
      :pattern (($FVF.lookup_option$array$ (sm@205@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
      :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r))
      :qid |qp.fvfValDef37|))
    (forall ((r $Ref)) (!
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r)
      :pattern (($FVF.lookup_option$array$ (sm@205@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
      :qid |qp.fvfResTrgDef38|))
    (forall ((r $Ref)) (!
      (implies
        (ite
          (and
            (<
              (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
              V@104@00)
            (<=
              0
              (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
          (< $Perm.No $k@177@00)
          false)
        (=
          ($FVF.lookup_option$array$ (sm@210@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r)
          ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r)))
      :pattern (($FVF.lookup_option$array$ (sm@210@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
      :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r))
      :qid |qp.fvfValDef41|))
    (forall ((r $Ref)) (!
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r)
      :pattern (($FVF.lookup_option$array$ (sm@210@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
      :qid |qp.fvfResTrgDef42|))
    (forall ((r $Ref)) (!
      (iff
        (Set_in r ($FVF.domain_int (sm@215@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00)))
        (and
          (and
            (and
              (and
                (<
                  (inv@213@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                  V@104@00)
                (<=
                  0
                  (inv@213@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
              (<
                (inv@212@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                V@104@00))
            (<=
              0
              (inv@212@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
          (< $Perm.No $k@209@00)))
      :pattern ((Set_in r ($FVF.domain_int (sm@215@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00))))
      :qid |qp.fvfDomDef48|))
    (forall ((r $Ref)) (!
      (implies
        (and
          (and
            (and
              (and
                (and
                  (<
                    (inv@213@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                    V@104@00)
                  (<=
                    0
                    (inv@213@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
                (<
                  (inv@212@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                  V@104@00))
              (<=
                0
                (inv@212@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
            (< $Perm.No $k@209@00))
          (ite
            (and
              (and
                (and
                  (<
                    (inv@188@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                    V@104@00)
                  (<=
                    0
                    (inv@188@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
                (<
                  (inv@187@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                  V@104@00))
              (<=
                0
                (inv@187@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
            (< $Perm.No $k@186@00)
            false))
        (=
          ($FVF.lookup_int (sm@215@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r)
          ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$)))))))) r)))
      :pattern (($FVF.lookup_int (sm@215@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
      :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$)))))))) r))
      :qid |qp.fvfValDef46|))
    (forall ((r $Ref)) (!
      ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$)))))))) r) r)
      :pattern (($FVF.lookup_int (sm@215@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
      :qid |qp.fvfResTrgDef47|))
    ($Perm.isReadVar $k@177@00 $Perm.Write)
    ($Perm.isReadVar $k@186@00 $Perm.Write)
    ($Perm.isReadVar $k@191@00 $Perm.Write)
    ($Perm.isReadVar $k@209@00 $Perm.Write)
    (implies
      (and
        (not (= this@102@00 $Ref.null))
        (not (= G@103@00 (as None<option<array>>  option<array>)))
        (= (alen<Int> (opt_get1 $Snap.unit G@103@00)) V@104@00)
        (forall ((i1 Int)) (!
          (implies
            (and (<= 0 i1) (< i1 V@104@00))
            (not
              (=
                ($FVF.lookup_option$array$ (sm@179@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1))
                (as None<option<array>>  option<array>))))
          :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1))
          ))
        (forall ((i1 Int)) (!
          (implies
            (and (<= 0 i1) (< i1 V@104@00))
            (=
              (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@179@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1))))
              V@104@00))
          :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@179@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1)))))
          ))
        (forall ((i1 Int)) (!
          (forall ((i2 Int)) (!
            (implies
              (and
                (and
                  (and (and (<= 0 i1) (< i1 V@104@00)) (<= 0 i2))
                  (< i2 V@104@00))
                (=
                  ($FVF.lookup_option$array$ (sm@179@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1))
                  ($FVF.lookup_option$array$ (sm@179@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit G@103@00) i2))))
              (= i1 i2))
            :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@103@00) i2))
            ))
          :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1))
          )))
      (=
        (FlowNetwork1 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00)
        (and
          (and
            (and
              (and (and (<= 0 s@105@00) (< s@105@00 V@104@00)) (<= 0 t@106@00))
              (< t@106@00 V@104@00))
            (SquareIntMatrix1 ($Snap.combine
              $Snap.unit
              ($Snap.combine
                $Snap.unit
                ($Snap.combine
                  $Snap.unit
                  ($Snap.combine
                    ($SortWrappers.$FVF<option<array>>To$Snap (sm@194@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00))
                    ($Snap.combine
                      $Snap.unit
                      ($Snap.combine
                        $Snap.unit
                        ($Snap.combine
                          $Snap.unit
                          ($SortWrappers.$FVF<Int>To$Snap (sm@215@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00))))))))) this@102@00 G@103@00 V@104@00))
          (NonNegativeCapacities1 ($Snap.combine $Snap.unit $Snap.unit) this@102@00 G@103@00 V@104@00)))))
  :pattern ((FlowNetwork1 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00))
  )))
; ---------- lock_inv_FordFulkerson ----------
(declare-const this@244@00 $Ref)
(push) ; 1
(declare-const $t@245@00 $Snap)
(assert (= $t@245@00 $Snap.unit))
(pop) ; 1
; ---------- lock_held_FordFulkerson ----------
(declare-const this@246@00 $Ref)
; ---------- lock_inv_Object ----------
(declare-const this@247@00 $Ref)
(push) ; 1
(declare-const $t@248@00 $Snap)
(assert (= $t@248@00 $Snap.unit))
(pop) ; 1
; ---------- lock_held_Object ----------
(declare-const this@249@00 $Ref)
