(get-info :version)
; (:version "4.8.6")
; Started: 2022-06-16 09:19:35
; Silicon.version: 1.1-SNAPSHOT (cd20cf02@(detached))
; Input file: -
; Verifier id: 00
; ------------------------------------------------------------
; Begin preamble
; ////////// Static preamble
; 
; ; /z3config.smt2
(set-option :print-success true) ; Boogie: false
(set-option :global-decls true) ; Boogie: default
(set-option :auto_config false) ; Usually a good idea
(set-option :smt.restart_strategy 0)
(set-option :smt.restart_factor |1.5|)
(set-option :smt.case_split 3)
(set-option :smt.delay_units true)
(set-option :smt.delay_units_threshold 16)
(set-option :nnf.sk_hack true)
(set-option :type_check true)
(set-option :smt.bv.reflect true)
(set-option :smt.mbqi false)
(set-option :smt.qi.eager_threshold 100)
(set-option :smt.qi.cost "(+ weight generation)")
(set-option :smt.qi.max_multi_patterns 1000)
(set-option :smt.phase_selection 0) ; default: 3, Boogie: 0
(set-option :sat.phase caching)
(set-option :sat.random_seed 0)
(set-option :nlsat.randomize true)
(set-option :nlsat.seed 0)
(set-option :nlsat.shuffle_vars false)
(set-option :fp.spacer.order_children 0) ; Not available with Z3 4.5
(set-option :fp.spacer.random_seed 0) ; Not available with Z3 4.5
(set-option :smt.arith.random_initial_value true) ; Boogie: true
(set-option :smt.random_seed 0)
(set-option :sls.random_offset true)
(set-option :sls.random_seed 0)
(set-option :sls.restart_init false)
(set-option :sls.walksat_ucb true)
(set-option :model.v2 true)
; 
; ; /preamble.smt2
(declare-datatypes () ((
    $Snap ($Snap.unit)
    ($Snap.combine ($Snap.first $Snap) ($Snap.second $Snap)))))
(declare-sort $Ref 0)
(declare-const $Ref.null $Ref)
(declare-sort $FPM)
(declare-sort $PPM)
(define-sort $Perm () Real)
(define-const $Perm.Write $Perm 1.0)
(define-const $Perm.No $Perm 0.0)
(define-fun $Perm.isValidVar ((p $Perm)) Bool
	(<= $Perm.No p))
(define-fun $Perm.isReadVar ((p $Perm) (ub $Perm)) Bool
    (and ($Perm.isValidVar p)
         (not (= p $Perm.No))
         (< p $Perm.Write)))
(define-fun $Perm.min ((p1 $Perm) (p2 $Perm)) Real
    (ite (<= p1 p2) p1 p2))
(define-fun $Math.min ((a Int) (b Int)) Int
    (ite (<= a b) a b))
(define-fun $Math.clip ((a Int)) Int
    (ite (< a 0) 0 a))
; ////////// Sorts
(declare-sort Seq<Seq<Int>>)
(declare-sort Seq<Int>)
(declare-sort Set<Int>)
(declare-sort Set<Bool>)
(declare-sort Set<option<array>>)
(declare-sort Set<$Ref>)
(declare-sort Set<$Snap>)
(declare-sort t_null)
(declare-sort any)
(declare-sort void)
(declare-sort option<any>)
(declare-sort option<array>)
(declare-sort array)
(declare-sort $FVF<Int>)
(declare-sort $FVF<option<array>>)
(declare-sort $FVF<Bool>)
(declare-sort $FVF<$Ref>)
; ////////// Sort wrappers
; Declaring additional sort wrappers
(declare-fun $SortWrappers.IntTo$Snap (Int) $Snap)
(declare-fun $SortWrappers.$SnapToInt ($Snap) Int)
(assert (forall ((x Int)) (!
    (= x ($SortWrappers.$SnapToInt($SortWrappers.IntTo$Snap x)))
    :pattern (($SortWrappers.IntTo$Snap x))
    :qid |$Snap.$SnapToIntTo$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.IntTo$Snap($SortWrappers.$SnapToInt x)))
    :pattern (($SortWrappers.$SnapToInt x))
    :qid |$Snap.IntTo$SnapToInt|
    )))
(declare-fun $SortWrappers.BoolTo$Snap (Bool) $Snap)
(declare-fun $SortWrappers.$SnapToBool ($Snap) Bool)
(assert (forall ((x Bool)) (!
    (= x ($SortWrappers.$SnapToBool($SortWrappers.BoolTo$Snap x)))
    :pattern (($SortWrappers.BoolTo$Snap x))
    :qid |$Snap.$SnapToBoolTo$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.BoolTo$Snap($SortWrappers.$SnapToBool x)))
    :pattern (($SortWrappers.$SnapToBool x))
    :qid |$Snap.BoolTo$SnapToBool|
    )))
(declare-fun $SortWrappers.$RefTo$Snap ($Ref) $Snap)
(declare-fun $SortWrappers.$SnapTo$Ref ($Snap) $Ref)
(assert (forall ((x $Ref)) (!
    (= x ($SortWrappers.$SnapTo$Ref($SortWrappers.$RefTo$Snap x)))
    :pattern (($SortWrappers.$RefTo$Snap x))
    :qid |$Snap.$SnapTo$RefTo$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.$RefTo$Snap($SortWrappers.$SnapTo$Ref x)))
    :pattern (($SortWrappers.$SnapTo$Ref x))
    :qid |$Snap.$RefTo$SnapTo$Ref|
    )))
(declare-fun $SortWrappers.$PermTo$Snap ($Perm) $Snap)
(declare-fun $SortWrappers.$SnapTo$Perm ($Snap) $Perm)
(assert (forall ((x $Perm)) (!
    (= x ($SortWrappers.$SnapTo$Perm($SortWrappers.$PermTo$Snap x)))
    :pattern (($SortWrappers.$PermTo$Snap x))
    :qid |$Snap.$SnapTo$PermTo$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.$PermTo$Snap($SortWrappers.$SnapTo$Perm x)))
    :pattern (($SortWrappers.$SnapTo$Perm x))
    :qid |$Snap.$PermTo$SnapTo$Perm|
    )))
; Declaring additional sort wrappers
(declare-fun $SortWrappers.Seq<Seq<Int>>To$Snap (Seq<Seq<Int>>) $Snap)
(declare-fun $SortWrappers.$SnapToSeq<Seq<Int>> ($Snap) Seq<Seq<Int>>)
(assert (forall ((x Seq<Seq<Int>>)) (!
    (= x ($SortWrappers.$SnapToSeq<Seq<Int>>($SortWrappers.Seq<Seq<Int>>To$Snap x)))
    :pattern (($SortWrappers.Seq<Seq<Int>>To$Snap x))
    :qid |$Snap.$SnapToSeq<Seq<Int>>To$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.Seq<Seq<Int>>To$Snap($SortWrappers.$SnapToSeq<Seq<Int>> x)))
    :pattern (($SortWrappers.$SnapToSeq<Seq<Int>> x))
    :qid |$Snap.Seq<Seq<Int>>To$SnapToSeq<Seq<Int>>|
    )))
(declare-fun $SortWrappers.Seq<Int>To$Snap (Seq<Int>) $Snap)
(declare-fun $SortWrappers.$SnapToSeq<Int> ($Snap) Seq<Int>)
(assert (forall ((x Seq<Int>)) (!
    (= x ($SortWrappers.$SnapToSeq<Int>($SortWrappers.Seq<Int>To$Snap x)))
    :pattern (($SortWrappers.Seq<Int>To$Snap x))
    :qid |$Snap.$SnapToSeq<Int>To$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.Seq<Int>To$Snap($SortWrappers.$SnapToSeq<Int> x)))
    :pattern (($SortWrappers.$SnapToSeq<Int> x))
    :qid |$Snap.Seq<Int>To$SnapToSeq<Int>|
    )))
; Declaring additional sort wrappers
(declare-fun $SortWrappers.Set<Int>To$Snap (Set<Int>) $Snap)
(declare-fun $SortWrappers.$SnapToSet<Int> ($Snap) Set<Int>)
(assert (forall ((x Set<Int>)) (!
    (= x ($SortWrappers.$SnapToSet<Int>($SortWrappers.Set<Int>To$Snap x)))
    :pattern (($SortWrappers.Set<Int>To$Snap x))
    :qid |$Snap.$SnapToSet<Int>To$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.Set<Int>To$Snap($SortWrappers.$SnapToSet<Int> x)))
    :pattern (($SortWrappers.$SnapToSet<Int> x))
    :qid |$Snap.Set<Int>To$SnapToSet<Int>|
    )))
(declare-fun $SortWrappers.Set<Bool>To$Snap (Set<Bool>) $Snap)
(declare-fun $SortWrappers.$SnapToSet<Bool> ($Snap) Set<Bool>)
(assert (forall ((x Set<Bool>)) (!
    (= x ($SortWrappers.$SnapToSet<Bool>($SortWrappers.Set<Bool>To$Snap x)))
    :pattern (($SortWrappers.Set<Bool>To$Snap x))
    :qid |$Snap.$SnapToSet<Bool>To$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.Set<Bool>To$Snap($SortWrappers.$SnapToSet<Bool> x)))
    :pattern (($SortWrappers.$SnapToSet<Bool> x))
    :qid |$Snap.Set<Bool>To$SnapToSet<Bool>|
    )))
(declare-fun $SortWrappers.Set<option<array>>To$Snap (Set<option<array>>) $Snap)
(declare-fun $SortWrappers.$SnapToSet<option<array>> ($Snap) Set<option<array>>)
(assert (forall ((x Set<option<array>>)) (!
    (= x ($SortWrappers.$SnapToSet<option<array>>($SortWrappers.Set<option<array>>To$Snap x)))
    :pattern (($SortWrappers.Set<option<array>>To$Snap x))
    :qid |$Snap.$SnapToSet<option<array>>To$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.Set<option<array>>To$Snap($SortWrappers.$SnapToSet<option<array>> x)))
    :pattern (($SortWrappers.$SnapToSet<option<array>> x))
    :qid |$Snap.Set<option<array>>To$SnapToSet<option<array>>|
    )))
(declare-fun $SortWrappers.Set<$Ref>To$Snap (Set<$Ref>) $Snap)
(declare-fun $SortWrappers.$SnapToSet<$Ref> ($Snap) Set<$Ref>)
(assert (forall ((x Set<$Ref>)) (!
    (= x ($SortWrappers.$SnapToSet<$Ref>($SortWrappers.Set<$Ref>To$Snap x)))
    :pattern (($SortWrappers.Set<$Ref>To$Snap x))
    :qid |$Snap.$SnapToSet<$Ref>To$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.Set<$Ref>To$Snap($SortWrappers.$SnapToSet<$Ref> x)))
    :pattern (($SortWrappers.$SnapToSet<$Ref> x))
    :qid |$Snap.Set<$Ref>To$SnapToSet<$Ref>|
    )))
(declare-fun $SortWrappers.Set<$Snap>To$Snap (Set<$Snap>) $Snap)
(declare-fun $SortWrappers.$SnapToSet<$Snap> ($Snap) Set<$Snap>)
(assert (forall ((x Set<$Snap>)) (!
    (= x ($SortWrappers.$SnapToSet<$Snap>($SortWrappers.Set<$Snap>To$Snap x)))
    :pattern (($SortWrappers.Set<$Snap>To$Snap x))
    :qid |$Snap.$SnapToSet<$Snap>To$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.Set<$Snap>To$Snap($SortWrappers.$SnapToSet<$Snap> x)))
    :pattern (($SortWrappers.$SnapToSet<$Snap> x))
    :qid |$Snap.Set<$Snap>To$SnapToSet<$Snap>|
    )))
; Declaring additional sort wrappers
(declare-fun $SortWrappers.t_nullTo$Snap (t_null) $Snap)
(declare-fun $SortWrappers.$SnapTot_null ($Snap) t_null)
(assert (forall ((x t_null)) (!
    (= x ($SortWrappers.$SnapTot_null($SortWrappers.t_nullTo$Snap x)))
    :pattern (($SortWrappers.t_nullTo$Snap x))
    :qid |$Snap.$SnapTot_nullTo$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.t_nullTo$Snap($SortWrappers.$SnapTot_null x)))
    :pattern (($SortWrappers.$SnapTot_null x))
    :qid |$Snap.t_nullTo$SnapTot_null|
    )))
(declare-fun $SortWrappers.anyTo$Snap (any) $Snap)
(declare-fun $SortWrappers.$SnapToany ($Snap) any)
(assert (forall ((x any)) (!
    (= x ($SortWrappers.$SnapToany($SortWrappers.anyTo$Snap x)))
    :pattern (($SortWrappers.anyTo$Snap x))
    :qid |$Snap.$SnapToanyTo$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.anyTo$Snap($SortWrappers.$SnapToany x)))
    :pattern (($SortWrappers.$SnapToany x))
    :qid |$Snap.anyTo$SnapToany|
    )))
(declare-fun $SortWrappers.voidTo$Snap (void) $Snap)
(declare-fun $SortWrappers.$SnapTovoid ($Snap) void)
(assert (forall ((x void)) (!
    (= x ($SortWrappers.$SnapTovoid($SortWrappers.voidTo$Snap x)))
    :pattern (($SortWrappers.voidTo$Snap x))
    :qid |$Snap.$SnapTovoidTo$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.voidTo$Snap($SortWrappers.$SnapTovoid x)))
    :pattern (($SortWrappers.$SnapTovoid x))
    :qid |$Snap.voidTo$SnapTovoid|
    )))
(declare-fun $SortWrappers.option<any>To$Snap (option<any>) $Snap)
(declare-fun $SortWrappers.$SnapTooption<any> ($Snap) option<any>)
(assert (forall ((x option<any>)) (!
    (= x ($SortWrappers.$SnapTooption<any>($SortWrappers.option<any>To$Snap x)))
    :pattern (($SortWrappers.option<any>To$Snap x))
    :qid |$Snap.$SnapTooption<any>To$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.option<any>To$Snap($SortWrappers.$SnapTooption<any> x)))
    :pattern (($SortWrappers.$SnapTooption<any> x))
    :qid |$Snap.option<any>To$SnapTooption<any>|
    )))
(declare-fun $SortWrappers.option<array>To$Snap (option<array>) $Snap)
(declare-fun $SortWrappers.$SnapTooption<array> ($Snap) option<array>)
(assert (forall ((x option<array>)) (!
    (= x ($SortWrappers.$SnapTooption<array>($SortWrappers.option<array>To$Snap x)))
    :pattern (($SortWrappers.option<array>To$Snap x))
    :qid |$Snap.$SnapTooption<array>To$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.option<array>To$Snap($SortWrappers.$SnapTooption<array> x)))
    :pattern (($SortWrappers.$SnapTooption<array> x))
    :qid |$Snap.option<array>To$SnapTooption<array>|
    )))
(declare-fun $SortWrappers.arrayTo$Snap (array) $Snap)
(declare-fun $SortWrappers.$SnapToarray ($Snap) array)
(assert (forall ((x array)) (!
    (= x ($SortWrappers.$SnapToarray($SortWrappers.arrayTo$Snap x)))
    :pattern (($SortWrappers.arrayTo$Snap x))
    :qid |$Snap.$SnapToarrayTo$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.arrayTo$Snap($SortWrappers.$SnapToarray x)))
    :pattern (($SortWrappers.$SnapToarray x))
    :qid |$Snap.arrayTo$SnapToarray|
    )))
; Declaring additional sort wrappers
(declare-fun $SortWrappers.$FVF<Int>To$Snap ($FVF<Int>) $Snap)
(declare-fun $SortWrappers.$SnapTo$FVF<Int> ($Snap) $FVF<Int>)
(assert (forall ((x $FVF<Int>)) (!
    (= x ($SortWrappers.$SnapTo$FVF<Int>($SortWrappers.$FVF<Int>To$Snap x)))
    :pattern (($SortWrappers.$FVF<Int>To$Snap x))
    :qid |$Snap.$SnapTo$FVF<Int>To$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.$FVF<Int>To$Snap($SortWrappers.$SnapTo$FVF<Int> x)))
    :pattern (($SortWrappers.$SnapTo$FVF<Int> x))
    :qid |$Snap.$FVF<Int>To$SnapTo$FVF<Int>|
    )))
(declare-fun $SortWrappers.$FVF<option<array>>To$Snap ($FVF<option<array>>) $Snap)
(declare-fun $SortWrappers.$SnapTo$FVF<option<array>> ($Snap) $FVF<option<array>>)
(assert (forall ((x $FVF<option<array>>)) (!
    (= x ($SortWrappers.$SnapTo$FVF<option<array>>($SortWrappers.$FVF<option<array>>To$Snap x)))
    :pattern (($SortWrappers.$FVF<option<array>>To$Snap x))
    :qid |$Snap.$SnapTo$FVF<option<array>>To$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.$FVF<option<array>>To$Snap($SortWrappers.$SnapTo$FVF<option<array>> x)))
    :pattern (($SortWrappers.$SnapTo$FVF<option<array>> x))
    :qid |$Snap.$FVF<option<array>>To$SnapTo$FVF<option<array>>|
    )))
(declare-fun $SortWrappers.$FVF<Bool>To$Snap ($FVF<Bool>) $Snap)
(declare-fun $SortWrappers.$SnapTo$FVF<Bool> ($Snap) $FVF<Bool>)
(assert (forall ((x $FVF<Bool>)) (!
    (= x ($SortWrappers.$SnapTo$FVF<Bool>($SortWrappers.$FVF<Bool>To$Snap x)))
    :pattern (($SortWrappers.$FVF<Bool>To$Snap x))
    :qid |$Snap.$SnapTo$FVF<Bool>To$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.$FVF<Bool>To$Snap($SortWrappers.$SnapTo$FVF<Bool> x)))
    :pattern (($SortWrappers.$SnapTo$FVF<Bool> x))
    :qid |$Snap.$FVF<Bool>To$SnapTo$FVF<Bool>|
    )))
(declare-fun $SortWrappers.$FVF<$Ref>To$Snap ($FVF<$Ref>) $Snap)
(declare-fun $SortWrappers.$SnapTo$FVF<$Ref> ($Snap) $FVF<$Ref>)
(assert (forall ((x $FVF<$Ref>)) (!
    (= x ($SortWrappers.$SnapTo$FVF<$Ref>($SortWrappers.$FVF<$Ref>To$Snap x)))
    :pattern (($SortWrappers.$FVF<$Ref>To$Snap x))
    :qid |$Snap.$SnapTo$FVF<$Ref>To$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.$FVF<$Ref>To$Snap($SortWrappers.$SnapTo$FVF<$Ref> x)))
    :pattern (($SortWrappers.$SnapTo$FVF<$Ref> x))
    :qid |$Snap.$FVF<$Ref>To$SnapTo$FVF<$Ref>|
    )))
; ////////// Symbols
(declare-fun Set_in (Int Set<Int>) Bool)
(declare-fun Set_card (Set<Int>) Int)
(declare-const Set_empty Set<Int>)
(declare-fun Set_singleton (Int) Set<Int>)
(declare-fun Set_unionone (Set<Int> Int) Set<Int>)
(declare-fun Set_union (Set<Int> Set<Int>) Set<Int>)
(declare-fun Set_disjoint (Set<Int> Set<Int>) Bool)
(declare-fun Set_difference (Set<Int> Set<Int>) Set<Int>)
(declare-fun Set_intersection (Set<Int> Set<Int>) Set<Int>)
(declare-fun Set_subset (Set<Int> Set<Int>) Bool)
(declare-fun Set_equal (Set<Int> Set<Int>) Bool)
(declare-fun Set_in (Bool Set<Bool>) Bool)
(declare-fun Set_card (Set<Bool>) Int)
(declare-const Set_empty Set<Bool>)
(declare-fun Set_singleton (Bool) Set<Bool>)
(declare-fun Set_unionone (Set<Bool> Bool) Set<Bool>)
(declare-fun Set_union (Set<Bool> Set<Bool>) Set<Bool>)
(declare-fun Set_disjoint (Set<Bool> Set<Bool>) Bool)
(declare-fun Set_difference (Set<Bool> Set<Bool>) Set<Bool>)
(declare-fun Set_intersection (Set<Bool> Set<Bool>) Set<Bool>)
(declare-fun Set_subset (Set<Bool> Set<Bool>) Bool)
(declare-fun Set_equal (Set<Bool> Set<Bool>) Bool)
(declare-fun Set_in (option<array> Set<option<array>>) Bool)
(declare-fun Set_card (Set<option<array>>) Int)
(declare-const Set_empty Set<option<array>>)
(declare-fun Set_singleton (option<array>) Set<option<array>>)
(declare-fun Set_unionone (Set<option<array>> option<array>) Set<option<array>>)
(declare-fun Set_union (Set<option<array>> Set<option<array>>) Set<option<array>>)
(declare-fun Set_disjoint (Set<option<array>> Set<option<array>>) Bool)
(declare-fun Set_difference (Set<option<array>> Set<option<array>>) Set<option<array>>)
(declare-fun Set_intersection (Set<option<array>> Set<option<array>>) Set<option<array>>)
(declare-fun Set_subset (Set<option<array>> Set<option<array>>) Bool)
(declare-fun Set_equal (Set<option<array>> Set<option<array>>) Bool)
(declare-fun Set_in ($Ref Set<$Ref>) Bool)
(declare-fun Set_card (Set<$Ref>) Int)
(declare-const Set_empty Set<$Ref>)
(declare-fun Set_singleton ($Ref) Set<$Ref>)
(declare-fun Set_unionone (Set<$Ref> $Ref) Set<$Ref>)
(declare-fun Set_union (Set<$Ref> Set<$Ref>) Set<$Ref>)
(declare-fun Set_disjoint (Set<$Ref> Set<$Ref>) Bool)
(declare-fun Set_difference (Set<$Ref> Set<$Ref>) Set<$Ref>)
(declare-fun Set_intersection (Set<$Ref> Set<$Ref>) Set<$Ref>)
(declare-fun Set_subset (Set<$Ref> Set<$Ref>) Bool)
(declare-fun Set_equal (Set<$Ref> Set<$Ref>) Bool)
(declare-fun Set_in ($Snap Set<$Snap>) Bool)
(declare-fun Set_card (Set<$Snap>) Int)
(declare-const Set_empty Set<$Snap>)
(declare-fun Set_singleton ($Snap) Set<$Snap>)
(declare-fun Set_unionone (Set<$Snap> $Snap) Set<$Snap>)
(declare-fun Set_union (Set<$Snap> Set<$Snap>) Set<$Snap>)
(declare-fun Set_disjoint (Set<$Snap> Set<$Snap>) Bool)
(declare-fun Set_difference (Set<$Snap> Set<$Snap>) Set<$Snap>)
(declare-fun Set_intersection (Set<$Snap> Set<$Snap>) Set<$Snap>)
(declare-fun Set_subset (Set<$Snap> Set<$Snap>) Bool)
(declare-fun Set_equal (Set<$Snap> Set<$Snap>) Bool)
(declare-fun Seq_length (Seq<Seq<Int>>) Int)
(declare-const Seq_empty Seq<Seq<Int>>)
(declare-fun Seq_singleton (Seq<Int>) Seq<Seq<Int>>)
(declare-fun Seq_build (Seq<Seq<Int>> Seq<Int>) Seq<Seq<Int>>)
(declare-fun Seq_index (Seq<Seq<Int>> Int) Seq<Int>)
(declare-fun Seq_append (Seq<Seq<Int>> Seq<Seq<Int>>) Seq<Seq<Int>>)
(declare-fun Seq_update (Seq<Seq<Int>> Int Seq<Int>) Seq<Seq<Int>>)
(declare-fun Seq_contains (Seq<Seq<Int>> Seq<Int>) Bool)
(declare-fun Seq_take (Seq<Seq<Int>> Int) Seq<Seq<Int>>)
(declare-fun Seq_drop (Seq<Seq<Int>> Int) Seq<Seq<Int>>)
(declare-fun Seq_equal (Seq<Seq<Int>> Seq<Seq<Int>>) Bool)
(declare-fun Seq_sameuntil (Seq<Seq<Int>> Seq<Seq<Int>> Int) Bool)
(declare-fun Seq_length (Seq<Int>) Int)
(declare-const Seq_empty Seq<Int>)
(declare-fun Seq_singleton (Int) Seq<Int>)
(declare-fun Seq_build (Seq<Int> Int) Seq<Int>)
(declare-fun Seq_index (Seq<Int> Int) Int)
(declare-fun Seq_append (Seq<Int> Seq<Int>) Seq<Int>)
(declare-fun Seq_update (Seq<Int> Int Int) Seq<Int>)
(declare-fun Seq_contains (Seq<Int> Int) Bool)
(declare-fun Seq_take (Seq<Int> Int) Seq<Int>)
(declare-fun Seq_drop (Seq<Int> Int) Seq<Int>)
(declare-fun Seq_equal (Seq<Int> Seq<Int>) Bool)
(declare-fun Seq_sameuntil (Seq<Int> Seq<Int> Int) Bool)
(declare-fun Seq_range (Int Int) Seq<Int>)
(declare-fun array_loc<Ref> (array Int) $Ref)
(declare-fun alen<Int> (array) Int)
(declare-fun loc_inv_1<array> ($Ref) array)
(declare-fun loc_inv_2<Int> ($Ref) Int)
(declare-const None<option<array>> option<array>)
(declare-fun some<option<array>> (array) option<array>)
(declare-fun option_get<array> (option<array>) array)
(declare-const v_null<t_null> t_null)
(declare-const None<option<any>> option<any>)
(declare-fun some<option<any>> (any) option<any>)
(declare-fun option_get<any> (option<any>) any)
(declare-const unit<void> void)
; /field_value_functions_declarations.smt2 [int: Int]
(declare-fun $FVF.domain_int ($FVF<Int>) Set<$Ref>)
(declare-fun $FVF.lookup_int ($FVF<Int> $Ref) Int)
(declare-fun $FVF.after_int ($FVF<Int> $FVF<Int>) Bool)
(declare-fun $FVF.loc_int (Int $Ref) Bool)
(declare-fun $FVF.perm_int ($FPM $Ref) $Perm)
(declare-const $fvfTOP_int $FVF<Int>)
; /field_value_functions_declarations.smt2 [option$array$: option[array]]
(declare-fun $FVF.domain_option$array$ ($FVF<option<array>>) Set<$Ref>)
(declare-fun $FVF.lookup_option$array$ ($FVF<option<array>> $Ref) option<array>)
(declare-fun $FVF.after_option$array$ ($FVF<option<array>> $FVF<option<array>>) Bool)
(declare-fun $FVF.loc_option$array$ (option<array> $Ref) Bool)
(declare-fun $FVF.perm_option$array$ ($FPM $Ref) $Perm)
(declare-const $fvfTOP_option$array$ $FVF<option<array>>)
; /field_value_functions_declarations.smt2 [bool: Bool]
(declare-fun $FVF.domain_bool ($FVF<Bool>) Set<$Ref>)
(declare-fun $FVF.lookup_bool ($FVF<Bool> $Ref) Bool)
(declare-fun $FVF.after_bool ($FVF<Bool> $FVF<Bool>) Bool)
(declare-fun $FVF.loc_bool (Bool $Ref) Bool)
(declare-fun $FVF.perm_bool ($FPM $Ref) $Perm)
(declare-const $fvfTOP_bool $FVF<Bool>)
; Declaring symbols related to program functions (from program analysis)
(declare-fun SquareIntMatrix ($Snap $Ref Seq<Seq<Int>> Int) Bool)
(declare-fun SquareIntMatrix%limited ($Snap $Ref Seq<Seq<Int>> Int) Bool)
(declare-fun SquareIntMatrix%stateless ($Ref Seq<Seq<Int>> Int) Bool)
(declare-fun NonNegativeCapacities ($Snap $Ref Seq<Seq<Int>> Int) Bool)
(declare-fun NonNegativeCapacities%limited ($Snap $Ref Seq<Seq<Int>> Int) Bool)
(declare-fun NonNegativeCapacities%stateless ($Ref Seq<Seq<Int>> Int) Bool)
(declare-fun FlowNetwork ($Snap $Ref Seq<Seq<Int>> Int Int Int) Bool)
(declare-fun FlowNetwork%limited ($Snap $Ref Seq<Seq<Int>> Int Int Int) Bool)
(declare-fun FlowNetwork%stateless ($Ref Seq<Seq<Int>> Int Int Int) Bool)
(declare-fun SumOutgoingFlow ($Snap $Ref Seq<Seq<Int>> Int Int Int) Int)
(declare-fun SumOutgoingFlow%limited ($Snap $Ref Seq<Seq<Int>> Int Int Int) Int)
(declare-fun SumOutgoingFlow%stateless ($Ref Seq<Seq<Int>> Int Int Int) Bool)
(declare-fun SumIncomingFlow ($Snap $Ref Seq<Seq<Int>> Int Int Int) Int)
(declare-fun SumIncomingFlow%limited ($Snap $Ref Seq<Seq<Int>> Int Int Int) Int)
(declare-fun SumIncomingFlow%stateless ($Ref Seq<Seq<Int>> Int Int Int) Bool)
(declare-fun CapacityConstraint ($Snap $Ref Seq<Seq<Int>> Seq<Seq<Int>> Int) Bool)
(declare-fun CapacityConstraint%limited ($Snap $Ref Seq<Seq<Int>> Seq<Seq<Int>> Int) Bool)
(declare-fun CapacityConstraint%stateless ($Ref Seq<Seq<Int>> Seq<Seq<Int>> Int) Bool)
(declare-fun FlowConservation ($Snap $Ref Seq<Seq<Int>> Int Int Int) Bool)
(declare-fun FlowConservation%limited ($Snap $Ref Seq<Seq<Int>> Int Int Int) Bool)
(declare-fun FlowConservation%stateless ($Ref Seq<Seq<Int>> Int Int Int) Bool)
(declare-fun aloc ($Snap array Int) $Ref)
(declare-fun aloc%limited ($Snap array Int) $Ref)
(declare-fun aloc%stateless (array Int) Bool)
(declare-fun opt_get1 ($Snap option<array>) array)
(declare-fun opt_get1%limited ($Snap option<array>) array)
(declare-fun opt_get1%stateless (option<array>) Bool)
(declare-fun valid_graph_vertices1 ($Snap $Ref Seq<Int> Int) Bool)
(declare-fun valid_graph_vertices1%limited ($Snap $Ref Seq<Int> Int) Bool)
(declare-fun valid_graph_vertices1%stateless ($Ref Seq<Int> Int) Bool)
(declare-fun ValidFlow ($Snap $Ref Seq<Seq<Int>> Seq<Seq<Int>> Int Int Int) Bool)
(declare-fun ValidFlow%limited ($Snap $Ref Seq<Seq<Int>> Seq<Seq<Int>> Int Int Int) Bool)
(declare-fun ValidFlow%stateless ($Ref Seq<Seq<Int>> Seq<Seq<Int>> Int Int Int) Bool)
(declare-fun SquareIntMatrix1 ($Snap $Ref option<array> Int) Bool)
(declare-fun SquareIntMatrix1%limited ($Snap $Ref option<array> Int) Bool)
(declare-fun SquareIntMatrix1%stateless ($Ref option<array> Int) Bool)
(declare-fun any_as ($Snap any) any)
(declare-fun any_as%limited ($Snap any) any)
(declare-fun any_as%stateless (any) Bool)
(declare-fun unknown_ ($Snap option<array> Int Int) Seq<Int>)
(declare-fun unknown%limited ($Snap option<array> Int Int) Seq<Int>)
(declare-fun unknown%stateless (option<array> Int Int) Bool)
(declare-fun AugPath ($Snap $Ref Seq<Seq<Int>> Seq<Seq<Int>> Int Int Int Seq<Int>) Bool)
(declare-fun AugPath%limited ($Snap $Ref Seq<Seq<Int>> Seq<Seq<Int>> Int Int Int Seq<Int>) Bool)
(declare-fun AugPath%stateless ($Ref Seq<Seq<Int>> Seq<Seq<Int>> Int Int Int Seq<Int>) Bool)
(declare-fun opt_get ($Snap option<any>) any)
(declare-fun opt_get%limited ($Snap option<any>) any)
(declare-fun opt_get%stateless (option<any>) Bool)
(declare-fun NonNegativeCapacities1 ($Snap $Ref option<array> Int) Bool)
(declare-fun NonNegativeCapacities1%limited ($Snap $Ref option<array> Int) Bool)
(declare-fun NonNegativeCapacities1%stateless ($Ref option<array> Int) Bool)
(declare-fun as_any ($Snap any) any)
(declare-fun as_any%limited ($Snap any) any)
(declare-fun as_any%stateless (any) Bool)
(declare-fun valid_graph_vertices ($Snap $Ref option<array> Int) Bool)
(declare-fun valid_graph_vertices%limited ($Snap $Ref option<array> Int) Bool)
(declare-fun valid_graph_vertices%stateless ($Ref option<array> Int) Bool)
(declare-fun type ($Snap $Ref) Int)
(declare-fun type%limited ($Snap $Ref) Int)
(declare-fun type%stateless ($Ref) Bool)
(declare-fun subtype ($Snap Int Int) Bool)
(declare-fun subtype%limited ($Snap Int Int) Bool)
(declare-fun subtype%stateless (Int Int) Bool)
(declare-fun matrixValues ($Snap $Ref option<array> Int) Seq<Seq<Int>>)
(declare-fun matrixValues%limited ($Snap $Ref option<array> Int) Seq<Seq<Int>>)
(declare-fun matrixValues%stateless ($Ref option<array> Int) Bool)
(declare-fun ExAugPath ($Snap $Ref Seq<Seq<Int>> Seq<Seq<Int>> Int Int Int) Bool)
(declare-fun ExAugPath%limited ($Snap $Ref Seq<Seq<Int>> Seq<Seq<Int>> Int Int Int) Bool)
(declare-fun ExAugPath%stateless ($Ref Seq<Seq<Int>> Seq<Seq<Int>> Int Int Int) Bool)
(declare-fun opt_or_else ($Snap option<any> any) any)
(declare-fun opt_or_else%limited ($Snap option<any> any) any)
(declare-fun opt_or_else%stateless (option<any> any) Bool)
(declare-fun FlowNetwork1 ($Snap $Ref option<array> Int Int Int) Bool)
(declare-fun FlowNetwork1%limited ($Snap $Ref option<array> Int Int Int) Bool)
(declare-fun FlowNetwork1%stateless ($Ref option<array> Int Int Int) Bool)
; Snapshot variable to be used during function verification
(declare-fun s@$ () $Snap)
; Declaring predicate trigger functions
(declare-fun lock_inv_FordFulkerson%trigger ($Snap $Ref) Bool)
(declare-fun lock_held_FordFulkerson%trigger ($Snap $Ref) Bool)
(declare-fun lock_inv_Object%trigger ($Snap $Ref) Bool)
(declare-fun lock_held_Object%trigger ($Snap $Ref) Bool)
; ////////// Uniqueness assumptions from domains
; ////////// Axioms
(assert (forall ((s Seq<Seq<Int>>)) (!
  (<= 0 (Seq_length s))
  :pattern ((Seq_length s))
  :qid |$Seq[Seq[Int]]_prog.seq_length_non_negative|)))
(assert (= (Seq_length (as Seq_empty  Seq<Seq<Int>>)) 0))
(assert (forall ((s Seq<Seq<Int>>)) (!
  (implies (= (Seq_length s) 0) (= s (as Seq_empty  Seq<Seq<Int>>)))
  :pattern ((Seq_length s))
  :qid |$Seq[Seq[Int]]_prog.only_empty_seq_length_zero|)))
(assert (forall ((e Seq<Int>)) (!
  (= (Seq_length (Seq_singleton e)) 1)
  :pattern ((Seq_length (Seq_singleton e)))
  :qid |$Seq[Seq[Int]]_prog.length_singleton_seq|)))
(assert (forall ((s Seq<Seq<Int>>) (e Seq<Int>)) (!
  (= (Seq_length (Seq_build s e)) (+ 1 (Seq_length s)))
  :pattern ((Seq_length (Seq_build s e)))
  :qid |$Seq[Seq[Int]]_prog.length_seq_build_inc_by_one|)))
(assert (forall ((s Seq<Seq<Int>>) (i Int) (e Seq<Int>)) (!
  (ite
    (= i (Seq_length s))
    (= (Seq_index (Seq_build s e) i) e)
    (= (Seq_index (Seq_build s e) i) (Seq_index s i)))
  :pattern ((Seq_index (Seq_build s e) i))
  :qid |$Seq[Seq[Int]]_prog.seq_index_over_build|)))
(assert (forall ((s1 Seq<Seq<Int>>) (s2 Seq<Seq<Int>>)) (!
  (implies
    (and
      (not (= s1 (as Seq_empty  Seq<Seq<Int>>)))
      (not (= s2 (as Seq_empty  Seq<Seq<Int>>))))
    (= (Seq_length (Seq_append s1 s2)) (+ (Seq_length s1) (Seq_length s2))))
  :pattern ((Seq_length (Seq_append s1 s2)))
  :qid |$Seq[Seq[Int]]_prog.seq_length_over_append|)))
(assert (forall ((e Seq<Int>)) (!
  (= (Seq_index (Seq_singleton e) 0) e)
  :pattern ((Seq_index (Seq_singleton e) 0))
  :qid |$Seq[Seq[Int]]_prog.seq_index_over_singleton|)))
(assert (forall ((e1 Seq<Int>) (e2 Seq<Int>)) (!
  (= (Seq_contains (Seq_singleton e1) e2) (= e1 e2))
  :pattern ((Seq_contains (Seq_singleton e1) e2))
  :qid |$Seq[Seq[Int]]_prog.seq_contains_over_singleton|)))
(assert (forall ((s Seq<Seq<Int>>)) (!
  (= (Seq_append (as Seq_empty  Seq<Seq<Int>>) s) s)
  :pattern ((Seq_append (as Seq_empty  Seq<Seq<Int>>) s))
  :qid |$Seq[Seq[Int]]_prog.seq_append_empty_left|)))
(assert (forall ((s Seq<Seq<Int>>)) (!
  (= (Seq_append s (as Seq_empty  Seq<Seq<Int>>)) s)
  :pattern ((Seq_append s (as Seq_empty  Seq<Seq<Int>>)))
  :qid |$Seq[Seq[Int]]_prog.seq_append_empty_right|)))
(assert (forall ((s1 Seq<Seq<Int>>) (s2 Seq<Seq<Int>>) (i Int)) (!
  (implies
    (and
      (not (= s1 (as Seq_empty  Seq<Seq<Int>>)))
      (not (= s2 (as Seq_empty  Seq<Seq<Int>>))))
    (ite
      (< i (Seq_length s1))
      (= (Seq_index (Seq_append s1 s2) i) (Seq_index s1 i))
      (= (Seq_index (Seq_append s1 s2) i) (Seq_index s2 (- i (Seq_length s1))))))
  :pattern ((Seq_index (Seq_append s1 s2) i))
  :pattern ((Seq_index s1 i) (Seq_append s1 s2))
  :qid |$Seq[Seq[Int]]_prog.seq_index_over_append|)))
(assert (forall ((s Seq<Seq<Int>>) (i Int) (e Seq<Int>)) (!
  (implies
    (and (<= 0 i) (< i (Seq_length s)))
    (= (Seq_length (Seq_update s i e)) (Seq_length s)))
  :pattern ((Seq_length (Seq_update s i e)))
  :qid |$Seq[Seq[Int]]_prog.seq_length_invariant_over_update|)))
(assert (forall ((s Seq<Seq<Int>>) (i Int) (e Seq<Int>) (j Int)) (!
  (ite
    (implies (and (<= 0 i) (< i (Seq_length s))) (= i j))
    (= (Seq_index (Seq_update s i e) j) e)
    (= (Seq_index (Seq_update s i e) j) (Seq_index s j)))
  :pattern ((Seq_index (Seq_update s i e) j))
  :qid |$Seq[Seq[Int]]_prog.seq_index_over_update|)))
(assert (forall ((s Seq<Seq<Int>>) (e Seq<Int>)) (!
  (=
    (Seq_contains s e)
    (exists ((i Int)) (!
      (and (<= 0 i) (and (< i (Seq_length s)) (= (Seq_index s i) e)))
      :pattern ((Seq_index s i))
      )))
  :pattern ((Seq_contains s e))
  :qid |$Seq[Seq[Int]]_prog.seq_element_contains_index_exists|)))
(assert (forall ((e Seq<Int>)) (!
  (not (Seq_contains (as Seq_empty  Seq<Seq<Int>>) e))
  :pattern ((Seq_contains (as Seq_empty  Seq<Seq<Int>>) e))
  :qid |$Seq[Seq[Int]]_prog.empty_seq_contains_nothing|)))
(assert (forall ((s1 Seq<Seq<Int>>) (s2 Seq<Seq<Int>>) (e Seq<Int>)) (!
  (=
    (Seq_contains (Seq_append s1 s2) e)
    (or (Seq_contains s1 e) (Seq_contains s2 e)))
  :pattern ((Seq_contains (Seq_append s1 s2) e))
  :qid |$Seq[Seq[Int]]_prog.seq_contains_over_append|)))
(assert (forall ((s Seq<Seq<Int>>) (e1 Seq<Int>) (e2 Seq<Int>)) (!
  (= (Seq_contains (Seq_build s e1) e2) (or (= e1 e2) (Seq_contains s e2)))
  :pattern ((Seq_contains (Seq_build s e1) e2))
  :qid |$Seq[Seq[Int]]_prog.seq_contains_over_build|)))
(assert (forall ((s Seq<Seq<Int>>) (n Int)) (!
  (implies (<= n 0) (= (Seq_take s n) (as Seq_empty  Seq<Seq<Int>>)))
  :pattern ((Seq_take s n))
  :qid |$Seq[Seq[Int]]_prog.seq_take_negative_length|)))
(assert (forall ((s Seq<Seq<Int>>) (n Int) (e Seq<Int>)) (!
  (=
    (Seq_contains (Seq_take s n) e)
    (exists ((i Int)) (!
      (and
        (<= 0 i)
        (and (< i n) (and (< i (Seq_length s)) (= (Seq_index s i) e))))
      :pattern ((Seq_index s i))
      )))
  :pattern ((Seq_contains (Seq_take s n) e))
  :qid |$Seq[Seq[Int]]_prog.seq_contains_over_take_index_exists|)))
(assert (forall ((s Seq<Seq<Int>>) (n Int)) (!
  (implies (<= n 0) (= (Seq_drop s n) s))
  :pattern ((Seq_drop s n))
  :qid |$Seq[Seq[Int]]_prog.seq_drop_negative_length|)))
(assert (forall ((s Seq<Seq<Int>>) (n Int) (e Seq<Int>)) (!
  (=
    (Seq_contains (Seq_drop s n) e)
    (exists ((i Int)) (!
      (and
        (<= 0 i)
        (and (<= n i) (and (< i (Seq_length s)) (= (Seq_index s i) e))))
      :pattern ((Seq_index s i))
      )))
  :pattern ((Seq_contains (Seq_drop s n) e))
  :qid |$Seq[Seq[Int]]_prog.seq_contains_over_drop_index_exists|)))
(assert (forall ((s1 Seq<Seq<Int>>) (s2 Seq<Seq<Int>>)) (!
  (=
    (Seq_equal s1 s2)
    (and
      (= (Seq_length s1) (Seq_length s2))
      (forall ((i Int)) (!
        (implies
          (and (<= 0 i) (< i (Seq_length s1)))
          (= (Seq_index s1 i) (Seq_index s2 i)))
        :pattern ((Seq_index s1 i))
        :pattern ((Seq_index s2 i))
        ))))
  :pattern ((Seq_equal s1 s2))
  :qid |$Seq[Seq[Int]]_prog.extensional_seq_equality|)))
(assert (forall ((s1 Seq<Seq<Int>>) (s2 Seq<Seq<Int>>)) (!
  (implies (Seq_equal s1 s2) (= s1 s2))
  :pattern ((Seq_equal s1 s2))
  :qid |$Seq[Seq[Int]]_prog.seq_equality_identity|)))
(assert (forall ((s1 Seq<Seq<Int>>) (s2 Seq<Seq<Int>>) (n Int)) (!
  (=
    (Seq_sameuntil s1 s2 n)
    (forall ((i Int)) (!
      (implies (and (<= 0 i) (< i n)) (= (Seq_index s1 i) (Seq_index s2 i)))
      :pattern ((Seq_index s1 i))
      :pattern ((Seq_index s2 i))
      )))
  :pattern ((Seq_sameuntil s1 s2 n))
  :qid |$Seq[Seq[Int]]_prog.extensional_seq_equality_prefix|)))
(assert (forall ((s Seq<Seq<Int>>) (n Int)) (!
  (implies
    (<= 0 n)
    (ite
      (<= n (Seq_length s))
      (= (Seq_length (Seq_take s n)) n)
      (= (Seq_length (Seq_take s n)) (Seq_length s))))
  :pattern ((Seq_length (Seq_take s n)))
  :qid |$Seq[Seq[Int]]_prog.seq_length_over_take|)))
(assert (forall ((s Seq<Seq<Int>>) (n Int) (i Int)) (!
  (implies
    (and (<= 0 i) (and (< i n) (< i (Seq_length s))))
    (= (Seq_index (Seq_take s n) i) (Seq_index s i)))
  :pattern ((Seq_index (Seq_take s n) i))
  :pattern ((Seq_index s i) (Seq_take s n))
  :qid |$Seq[Seq[Int]]_prog.seq_index_over_take|)))
(assert (forall ((s Seq<Seq<Int>>) (n Int)) (!
  (implies
    (<= 0 n)
    (ite
      (<= n (Seq_length s))
      (= (Seq_length (Seq_drop s n)) (- (Seq_length s) n))
      (= (Seq_length (Seq_drop s n)) 0)))
  :pattern ((Seq_length (Seq_drop s n)))
  :qid |$Seq[Seq[Int]]_prog.seq_length_over_drop|)))
(assert (forall ((s Seq<Seq<Int>>) (n Int) (i Int)) (!
  (implies
    (and (<= 0 n) (and (<= 0 i) (< i (- (Seq_length s) n))))
    (= (Seq_index (Seq_drop s n) i) (Seq_index s (+ i n))))
  :pattern ((Seq_index (Seq_drop s n) i))
  :qid |$Seq[Seq[Int]]_prog.seq_index_over_drop_1|)))
(assert (forall ((s Seq<Seq<Int>>) (n Int) (i Int)) (!
  (implies
    (and (<= 0 n) (and (<= n i) (< i (Seq_length s))))
    (= (Seq_index (Seq_drop s n) (- i n)) (Seq_index s i)))
  :pattern ((Seq_index s i) (Seq_drop s n))
  :qid |$Seq[Seq[Int]]_prog.seq_index_over_drop_2|)))
(assert (forall ((s Seq<Seq<Int>>) (i Int) (e Seq<Int>) (n Int)) (!
  (implies
    (and (<= 0 i) (and (< i n) (< n (Seq_length s))))
    (= (Seq_take (Seq_update s i e) n) (Seq_update (Seq_take s n) i e)))
  :pattern ((Seq_take (Seq_update s i e) n))
  :qid |$Seq[Seq[Int]]_prog.seq_take_over_update_1|)))
(assert (forall ((s Seq<Seq<Int>>) (i Int) (e Seq<Int>) (n Int)) (!
  (implies
    (and (<= n i) (< i (Seq_length s)))
    (= (Seq_take (Seq_update s i e) n) (Seq_take s n)))
  :pattern ((Seq_take (Seq_update s i e) n))
  :qid |$Seq[Seq[Int]]_prog.seq_take_over_update_2|)))
(assert (forall ((s Seq<Seq<Int>>) (i Int) (e Seq<Int>) (n Int)) (!
  (implies
    (and (<= 0 n) (and (<= n i) (< i (Seq_length s))))
    (= (Seq_drop (Seq_update s i e) n) (Seq_update (Seq_drop s n) (- i n) e)))
  :pattern ((Seq_drop (Seq_update s i e) n))
  :qid |$Seq[Seq[Int]]_prog.seq_drop_over_update_1|)))
(assert (forall ((s Seq<Seq<Int>>) (i Int) (e Seq<Int>) (n Int)) (!
  (implies
    (and (<= 0 i) (and (< i n) (< n (Seq_length s))))
    (= (Seq_drop (Seq_update s i e) n) (Seq_drop s n)))
  :pattern ((Seq_drop (Seq_update s i e) n))
  :qid |$Seq[Seq[Int]]_prog.seq_drop_over_update_2|)))
(assert (forall ((s Seq<Seq<Int>>) (e Seq<Int>) (n Int)) (!
  (implies
    (and (<= 0 n) (<= n (Seq_length s)))
    (= (Seq_drop (Seq_build s e) n) (Seq_build (Seq_drop s n) e)))
  :pattern ((Seq_drop (Seq_build s e) n))
  :qid |$Seq[Seq[Int]]_prog.seq_drop_over_build|)))
(assert (forall ((s Seq<Int>)) (!
  (<= 0 (Seq_length s))
  :pattern ((Seq_length s))
  :qid |$Seq[Int]_prog.seq_length_non_negative|)))
(assert (= (Seq_length (as Seq_empty  Seq<Int>)) 0))
(assert (forall ((s Seq<Int>)) (!
  (implies (= (Seq_length s) 0) (= s (as Seq_empty  Seq<Int>)))
  :pattern ((Seq_length s))
  :qid |$Seq[Int]_prog.only_empty_seq_length_zero|)))
(assert (forall ((e Int)) (!
  (= (Seq_length (Seq_singleton e)) 1)
  :pattern ((Seq_length (Seq_singleton e)))
  :qid |$Seq[Int]_prog.length_singleton_seq|)))
(assert (forall ((s Seq<Int>) (e Int)) (!
  (= (Seq_length (Seq_build s e)) (+ 1 (Seq_length s)))
  :pattern ((Seq_length (Seq_build s e)))
  :qid |$Seq[Int]_prog.length_seq_build_inc_by_one|)))
(assert (forall ((s Seq<Int>) (i Int) (e Int)) (!
  (ite
    (= i (Seq_length s))
    (= (Seq_index (Seq_build s e) i) e)
    (= (Seq_index (Seq_build s e) i) (Seq_index s i)))
  :pattern ((Seq_index (Seq_build s e) i))
  :qid |$Seq[Int]_prog.seq_index_over_build|)))
(assert (forall ((s1 Seq<Int>) (s2 Seq<Int>)) (!
  (implies
    (and
      (not (= s1 (as Seq_empty  Seq<Int>)))
      (not (= s2 (as Seq_empty  Seq<Int>))))
    (= (Seq_length (Seq_append s1 s2)) (+ (Seq_length s1) (Seq_length s2))))
  :pattern ((Seq_length (Seq_append s1 s2)))
  :qid |$Seq[Int]_prog.seq_length_over_append|)))
(assert (forall ((e Int)) (!
  (= (Seq_index (Seq_singleton e) 0) e)
  :pattern ((Seq_index (Seq_singleton e) 0))
  :qid |$Seq[Int]_prog.seq_index_over_singleton|)))
(assert (forall ((e1 Int) (e2 Int)) (!
  (= (Seq_contains (Seq_singleton e1) e2) (= e1 e2))
  :pattern ((Seq_contains (Seq_singleton e1) e2))
  :qid |$Seq[Int]_prog.seq_contains_over_singleton|)))
(assert (forall ((s Seq<Int>)) (!
  (= (Seq_append (as Seq_empty  Seq<Int>) s) s)
  :pattern ((Seq_append (as Seq_empty  Seq<Int>) s))
  :qid |$Seq[Int]_prog.seq_append_empty_left|)))
(assert (forall ((s Seq<Int>)) (!
  (= (Seq_append s (as Seq_empty  Seq<Int>)) s)
  :pattern ((Seq_append s (as Seq_empty  Seq<Int>)))
  :qid |$Seq[Int]_prog.seq_append_empty_right|)))
(assert (forall ((s1 Seq<Int>) (s2 Seq<Int>) (i Int)) (!
  (implies
    (and
      (not (= s1 (as Seq_empty  Seq<Int>)))
      (not (= s2 (as Seq_empty  Seq<Int>))))
    (ite
      (< i (Seq_length s1))
      (= (Seq_index (Seq_append s1 s2) i) (Seq_index s1 i))
      (= (Seq_index (Seq_append s1 s2) i) (Seq_index s2 (- i (Seq_length s1))))))
  :pattern ((Seq_index (Seq_append s1 s2) i))
  :pattern ((Seq_index s1 i) (Seq_append s1 s2))
  :qid |$Seq[Int]_prog.seq_index_over_append|)))
(assert (forall ((s Seq<Int>) (i Int) (e Int)) (!
  (implies
    (and (<= 0 i) (< i (Seq_length s)))
    (= (Seq_length (Seq_update s i e)) (Seq_length s)))
  :pattern ((Seq_length (Seq_update s i e)))
  :qid |$Seq[Int]_prog.seq_length_invariant_over_update|)))
(assert (forall ((s Seq<Int>) (i Int) (e Int) (j Int)) (!
  (ite
    (implies (and (<= 0 i) (< i (Seq_length s))) (= i j))
    (= (Seq_index (Seq_update s i e) j) e)
    (= (Seq_index (Seq_update s i e) j) (Seq_index s j)))
  :pattern ((Seq_index (Seq_update s i e) j))
  :qid |$Seq[Int]_prog.seq_index_over_update|)))
(assert (forall ((s Seq<Int>) (e Int)) (!
  (=
    (Seq_contains s e)
    (exists ((i Int)) (!
      (and (<= 0 i) (and (< i (Seq_length s)) (= (Seq_index s i) e)))
      :pattern ((Seq_index s i))
      )))
  :pattern ((Seq_contains s e))
  :qid |$Seq[Int]_prog.seq_element_contains_index_exists|)))
(assert (forall ((e Int)) (!
  (not (Seq_contains (as Seq_empty  Seq<Int>) e))
  :pattern ((Seq_contains (as Seq_empty  Seq<Int>) e))
  :qid |$Seq[Int]_prog.empty_seq_contains_nothing|)))
(assert (forall ((s1 Seq<Int>) (s2 Seq<Int>) (e Int)) (!
  (=
    (Seq_contains (Seq_append s1 s2) e)
    (or (Seq_contains s1 e) (Seq_contains s2 e)))
  :pattern ((Seq_contains (Seq_append s1 s2) e))
  :qid |$Seq[Int]_prog.seq_contains_over_append|)))
(assert (forall ((s Seq<Int>) (e1 Int) (e2 Int)) (!
  (= (Seq_contains (Seq_build s e1) e2) (or (= e1 e2) (Seq_contains s e2)))
  :pattern ((Seq_contains (Seq_build s e1) e2))
  :qid |$Seq[Int]_prog.seq_contains_over_build|)))
(assert (forall ((s Seq<Int>) (n Int)) (!
  (implies (<= n 0) (= (Seq_take s n) (as Seq_empty  Seq<Int>)))
  :pattern ((Seq_take s n))
  :qid |$Seq[Int]_prog.seq_take_negative_length|)))
(assert (forall ((s Seq<Int>) (n Int) (e Int)) (!
  (=
    (Seq_contains (Seq_take s n) e)
    (exists ((i Int)) (!
      (and
        (<= 0 i)
        (and (< i n) (and (< i (Seq_length s)) (= (Seq_index s i) e))))
      :pattern ((Seq_index s i))
      )))
  :pattern ((Seq_contains (Seq_take s n) e))
  :qid |$Seq[Int]_prog.seq_contains_over_take_index_exists|)))
(assert (forall ((s Seq<Int>) (n Int)) (!
  (implies (<= n 0) (= (Seq_drop s n) s))
  :pattern ((Seq_drop s n))
  :qid |$Seq[Int]_prog.seq_drop_negative_length|)))
(assert (forall ((s Seq<Int>) (n Int) (e Int)) (!
  (=
    (Seq_contains (Seq_drop s n) e)
    (exists ((i Int)) (!
      (and
        (<= 0 i)
        (and (<= n i) (and (< i (Seq_length s)) (= (Seq_index s i) e))))
      :pattern ((Seq_index s i))
      )))
  :pattern ((Seq_contains (Seq_drop s n) e))
  :qid |$Seq[Int]_prog.seq_contains_over_drop_index_exists|)))
(assert (forall ((s1 Seq<Int>) (s2 Seq<Int>)) (!
  (=
    (Seq_equal s1 s2)
    (and
      (= (Seq_length s1) (Seq_length s2))
      (forall ((i Int)) (!
        (implies
          (and (<= 0 i) (< i (Seq_length s1)))
          (= (Seq_index s1 i) (Seq_index s2 i)))
        :pattern ((Seq_index s1 i))
        :pattern ((Seq_index s2 i))
        ))))
  :pattern ((Seq_equal s1 s2))
  :qid |$Seq[Int]_prog.extensional_seq_equality|)))
(assert (forall ((s1 Seq<Int>) (s2 Seq<Int>)) (!
  (implies (Seq_equal s1 s2) (= s1 s2))
  :pattern ((Seq_equal s1 s2))
  :qid |$Seq[Int]_prog.seq_equality_identity|)))
(assert (forall ((s1 Seq<Int>) (s2 Seq<Int>) (n Int)) (!
  (=
    (Seq_sameuntil s1 s2 n)
    (forall ((i Int)) (!
      (implies (and (<= 0 i) (< i n)) (= (Seq_index s1 i) (Seq_index s2 i)))
      :pattern ((Seq_index s1 i))
      :pattern ((Seq_index s2 i))
      )))
  :pattern ((Seq_sameuntil s1 s2 n))
  :qid |$Seq[Int]_prog.extensional_seq_equality_prefix|)))
(assert (forall ((s Seq<Int>) (n Int)) (!
  (implies
    (<= 0 n)
    (ite
      (<= n (Seq_length s))
      (= (Seq_length (Seq_take s n)) n)
      (= (Seq_length (Seq_take s n)) (Seq_length s))))
  :pattern ((Seq_length (Seq_take s n)))
  :qid |$Seq[Int]_prog.seq_length_over_take|)))
(assert (forall ((s Seq<Int>) (n Int) (i Int)) (!
  (implies
    (and (<= 0 i) (and (< i n) (< i (Seq_length s))))
    (= (Seq_index (Seq_take s n) i) (Seq_index s i)))
  :pattern ((Seq_index (Seq_take s n) i))
  :pattern ((Seq_index s i) (Seq_take s n))
  :qid |$Seq[Int]_prog.seq_index_over_take|)))
(assert (forall ((s Seq<Int>) (n Int)) (!
  (implies
    (<= 0 n)
    (ite
      (<= n (Seq_length s))
      (= (Seq_length (Seq_drop s n)) (- (Seq_length s) n))
      (= (Seq_length (Seq_drop s n)) 0)))
  :pattern ((Seq_length (Seq_drop s n)))
  :qid |$Seq[Int]_prog.seq_length_over_drop|)))
(assert (forall ((s Seq<Int>) (n Int) (i Int)) (!
  (implies
    (and (<= 0 n) (and (<= 0 i) (< i (- (Seq_length s) n))))
    (= (Seq_index (Seq_drop s n) i) (Seq_index s (+ i n))))
  :pattern ((Seq_index (Seq_drop s n) i))
  :qid |$Seq[Int]_prog.seq_index_over_drop_1|)))
(assert (forall ((s Seq<Int>) (n Int) (i Int)) (!
  (implies
    (and (<= 0 n) (and (<= n i) (< i (Seq_length s))))
    (= (Seq_index (Seq_drop s n) (- i n)) (Seq_index s i)))
  :pattern ((Seq_index s i) (Seq_drop s n))
  :qid |$Seq[Int]_prog.seq_index_over_drop_2|)))
(assert (forall ((s Seq<Int>) (i Int) (e Int) (n Int)) (!
  (implies
    (and (<= 0 i) (and (< i n) (< n (Seq_length s))))
    (= (Seq_take (Seq_update s i e) n) (Seq_update (Seq_take s n) i e)))
  :pattern ((Seq_take (Seq_update s i e) n))
  :qid |$Seq[Int]_prog.seq_take_over_update_1|)))
(assert (forall ((s Seq<Int>) (i Int) (e Int) (n Int)) (!
  (implies
    (and (<= n i) (< i (Seq_length s)))
    (= (Seq_take (Seq_update s i e) n) (Seq_take s n)))
  :pattern ((Seq_take (Seq_update s i e) n))
  :qid |$Seq[Int]_prog.seq_take_over_update_2|)))
(assert (forall ((s Seq<Int>) (i Int) (e Int) (n Int)) (!
  (implies
    (and (<= 0 n) (and (<= n i) (< i (Seq_length s))))
    (= (Seq_drop (Seq_update s i e) n) (Seq_update (Seq_drop s n) (- i n) e)))
  :pattern ((Seq_drop (Seq_update s i e) n))
  :qid |$Seq[Int]_prog.seq_drop_over_update_1|)))
(assert (forall ((s Seq<Int>) (i Int) (e Int) (n Int)) (!
  (implies
    (and (<= 0 i) (and (< i n) (< n (Seq_length s))))
    (= (Seq_drop (Seq_update s i e) n) (Seq_drop s n)))
  :pattern ((Seq_drop (Seq_update s i e) n))
  :qid |$Seq[Int]_prog.seq_drop_over_update_2|)))
(assert (forall ((s Seq<Int>) (e Int) (n Int)) (!
  (implies
    (and (<= 0 n) (<= n (Seq_length s)))
    (= (Seq_drop (Seq_build s e) n) (Seq_build (Seq_drop s n) e)))
  :pattern ((Seq_drop (Seq_build s e) n))
  :qid |$Seq[Int]_prog.seq_drop_over_build|)))
(assert (forall ((min_ Int) (max Int)) (!
  (ite
    (< min_ max)
    (= (Seq_length (Seq_range min_ max)) (- max min_))
    (= (Seq_length (Seq_range min_ max)) 0))
  :pattern ((Seq_length (Seq_range min_ max)))
  :qid |$Seq[Int]_prog.ranged_seq_length|)))
(assert (forall ((min_ Int) (max Int) (i Int)) (!
  (implies
    (and (<= 0 i) (< i (- max min_)))
    (= (Seq_index (Seq_range min_ max) i) (+ min_ i)))
  :pattern ((Seq_index (Seq_range min_ max) i))
  :qid |$Seq[Int]_prog.ranged_seq_index|)))
(assert (forall ((min_ Int) (max Int) (e Int)) (!
  (= (Seq_contains (Seq_range min_ max) e) (and (<= min_ e) (< e max)))
  :pattern ((Seq_contains (Seq_range min_ max) e))
  :qid |$Seq[Int]_prog.ranged_seq_contains|)))
(assert (forall ((s Set<Int>)) (!
  (<= 0 (Set_card s))
  :pattern ((Set_card s))
  :qid |$Set[Int]_prog.card_non_negative|)))
(assert (forall ((e Int)) (!
  (not (Set_in e (as Set_empty  Set<Int>)))
  :pattern ((Set_in e (as Set_empty  Set<Int>)))
  :qid |$Set[Int]_prog.in_empty_set|)))
(assert (forall ((s Set<Int>)) (!
  (and
    (= (= (Set_card s) 0) (= s (as Set_empty  Set<Int>)))
    (implies
      (not (= (Set_card s) 0))
      (exists ((e Int)) (!
        (Set_in e s)
        :pattern ((Set_in e s))
        ))))
  :pattern ((Set_card s))
  :qid |$Set[Int]_prog.empty_set_cardinality|)))
(assert (forall ((e Int)) (!
  (Set_in e (Set_singleton e))
  :pattern ((Set_singleton e))
  :qid |$Set[Int]_prog.in_singleton_set|)))
(assert (forall ((e1 Int) (e2 Int)) (!
  (= (Set_in e1 (Set_singleton e2)) (= e1 e2))
  :pattern ((Set_in e1 (Set_singleton e2)))
  :qid |$Set[Int]_prog.in_singleton_set_equality|)))
(assert (forall ((e Int)) (!
  (= (Set_card (Set_singleton e)) 1)
  :pattern ((Set_card (Set_singleton e)))
  :qid |$Set[Int]_prog.singleton_set_cardinality|)))
(assert (forall ((s Set<Int>) (e Int)) (!
  (Set_in e (Set_unionone s e))
  :pattern ((Set_unionone s e))
  :qid |$Set[Int]_prog.in_unionone_same|)))
(assert (forall ((s Set<Int>) (e1 Int) (e2 Int)) (!
  (= (Set_in e1 (Set_unionone s e2)) (or (= e1 e2) (Set_in e1 s)))
  :pattern ((Set_in e1 (Set_unionone s e2)))
  :qid |$Set[Int]_prog.in_unionone_other|)))
(assert (forall ((s Set<Int>) (e1 Int) (e2 Int)) (!
  (implies (Set_in e1 s) (Set_in e1 (Set_unionone s e2)))
  :pattern ((Set_in e1 s) (Set_unionone s e2))
  :qid |$Set[Int]_prog.invariance_in_unionone|)))
(assert (forall ((s Set<Int>) (e Int)) (!
  (implies (Set_in e s) (= (Set_card (Set_unionone s e)) (Set_card s)))
  :pattern ((Set_card (Set_unionone s e)))
  :qid |$Set[Int]_prog.unionone_cardinality_invariant|)))
(assert (forall ((s Set<Int>) (e Int)) (!
  (implies
    (not (Set_in e s))
    (= (Set_card (Set_unionone s e)) (+ (Set_card s) 1)))
  :pattern ((Set_card (Set_unionone s e)))
  :qid |$Set[Int]_prog.unionone_cardinality_changed|)))
(assert (forall ((s1 Set<Int>) (s2 Set<Int>) (e Int)) (!
  (= (Set_in e (Set_union s1 s2)) (or (Set_in e s1) (Set_in e s2)))
  :pattern ((Set_in e (Set_union s1 s2)))
  :qid |$Set[Int]_prog.in_union_in_one|)))
(assert (forall ((s1 Set<Int>) (s2 Set<Int>) (e Int)) (!
  (implies (Set_in e s1) (Set_in e (Set_union s1 s2)))
  :pattern ((Set_in e s1) (Set_union s1 s2))
  :qid |$Set[Int]_prog.in_left_in_union|)))
(assert (forall ((s1 Set<Int>) (s2 Set<Int>) (e Int)) (!
  (implies (Set_in e s2) (Set_in e (Set_union s1 s2)))
  :pattern ((Set_in e s2) (Set_union s1 s2))
  :qid |$Set[Int]_prog.in_right_in_union|)))
(assert (forall ((s1 Set<Int>) (s2 Set<Int>) (e Int)) (!
  (= (Set_in e (Set_intersection s1 s2)) (and (Set_in e s1) (Set_in e s2)))
  :pattern ((Set_in e (Set_intersection s1 s2)))
  :pattern ((Set_intersection s1 s2) (Set_in e s1))
  :pattern ((Set_intersection s1 s2) (Set_in e s2))
  :qid |$Set[Int]_prog.in_intersection_in_both|)))
(assert (forall ((s1 Set<Int>) (s2 Set<Int>)) (!
  (= (Set_union s1 (Set_union s1 s2)) (Set_union s1 s2))
  :pattern ((Set_union s1 (Set_union s1 s2)))
  :qid |$Set[Int]_prog.union_left_idempotency|)))
(assert (forall ((s1 Set<Int>) (s2 Set<Int>)) (!
  (= (Set_union (Set_union s1 s2) s2) (Set_union s1 s2))
  :pattern ((Set_union (Set_union s1 s2) s2))
  :qid |$Set[Int]_prog.union_right_idempotency|)))
(assert (forall ((s1 Set<Int>) (s2 Set<Int>)) (!
  (= (Set_intersection s1 (Set_intersection s1 s2)) (Set_intersection s1 s2))
  :pattern ((Set_intersection s1 (Set_intersection s1 s2)))
  :qid |$Set[Int]_prog.intersection_left_idempotency|)))
(assert (forall ((s1 Set<Int>) (s2 Set<Int>)) (!
  (= (Set_intersection (Set_intersection s1 s2) s2) (Set_intersection s1 s2))
  :pattern ((Set_intersection (Set_intersection s1 s2) s2))
  :qid |$Set[Int]_prog.intersection_right_idempotency|)))
(assert (forall ((s1 Set<Int>) (s2 Set<Int>)) (!
  (=
    (+ (Set_card (Set_union s1 s2)) (Set_card (Set_intersection s1 s2)))
    (+ (Set_card s1) (Set_card s2)))
  :pattern ((Set_card (Set_union s1 s2)))
  :pattern ((Set_card (Set_intersection s1 s2)))
  :qid |$Set[Int]_prog.cardinality_sums|)))
(assert (forall ((s1 Set<Int>) (s2 Set<Int>) (e Int)) (!
  (= (Set_in e (Set_difference s1 s2)) (and (Set_in e s1) (not (Set_in e s2))))
  :pattern ((Set_in e (Set_difference s1 s2)))
  :qid |$Set[Int]_prog.in_difference|)))
(assert (forall ((s1 Set<Int>) (s2 Set<Int>) (e Int)) (!
  (implies (Set_in e s2) (not (Set_in e (Set_difference s1 s2))))
  :pattern ((Set_difference s1 s2) (Set_in e s2))
  :qid |$Set[Int]_prog.not_in_difference|)))
(assert (forall ((s1 Set<Int>) (s2 Set<Int>)) (!
  (=
    (Set_subset s1 s2)
    (forall ((e Int)) (!
      (implies (Set_in e s1) (Set_in e s2))
      :pattern ((Set_in e s1))
      :pattern ((Set_in e s2))
      )))
  :pattern ((Set_subset s1 s2))
  :qid |$Set[Int]_prog.subset_definition|)))
(assert (forall ((s1 Set<Int>) (s2 Set<Int>)) (!
  (=
    (Set_equal s1 s2)
    (forall ((e Int)) (!
      (= (Set_in e s1) (Set_in e s2))
      :pattern ((Set_in e s1))
      :pattern ((Set_in e s2))
      )))
  :pattern ((Set_equal s1 s2))
  :qid |$Set[Int]_prog.equality_definition|)))
(assert (forall ((s1 Set<Int>) (s2 Set<Int>)) (!
  (implies (Set_equal s1 s2) (= s1 s2))
  :pattern ((Set_equal s1 s2))
  :qid |$Set[Int]_prog.native_equality|)))
(assert (forall ((s1 Set<Int>) (s2 Set<Int>)) (!
  (=
    (Set_disjoint s1 s2)
    (forall ((e Int)) (!
      (or (not (Set_in e s1)) (not (Set_in e s2)))
      :pattern ((Set_in e s1))
      :pattern ((Set_in e s2))
      )))
  :pattern ((Set_disjoint s1 s2))
  :qid |$Set[Int]_prog.disjointness_definition|)))
(assert (forall ((s1 Set<Int>) (s2 Set<Int>)) (!
  (and
    (=
      (+
        (+ (Set_card (Set_difference s1 s2)) (Set_card (Set_difference s2 s1)))
        (Set_card (Set_intersection s1 s2)))
      (Set_card (Set_union s1 s2)))
    (=
      (Set_card (Set_difference s1 s2))
      (- (Set_card s1) (Set_card (Set_intersection s1 s2)))))
  :pattern ((Set_card (Set_difference s1 s2)))
  :qid |$Set[Int]_prog.cardinality_difference|)))
(assert (forall ((s Set<Bool>)) (!
  (<= 0 (Set_card s))
  :pattern ((Set_card s))
  :qid |$Set[Bool]_prog.card_non_negative|)))
(assert (forall ((e Bool)) (!
  (not (Set_in e (as Set_empty  Set<Bool>)))
  :pattern ((Set_in e (as Set_empty  Set<Bool>)))
  :qid |$Set[Bool]_prog.in_empty_set|)))
(assert (forall ((s Set<Bool>)) (!
  (and
    (= (= (Set_card s) 0) (= s (as Set_empty  Set<Bool>)))
    (implies
      (not (= (Set_card s) 0))
      (exists ((e Bool)) (!
        (Set_in e s)
        :pattern ((Set_in e s))
        ))))
  :pattern ((Set_card s))
  :qid |$Set[Bool]_prog.empty_set_cardinality|)))
(assert (forall ((e Bool)) (!
  (Set_in e (Set_singleton e))
  :pattern ((Set_singleton e))
  :qid |$Set[Bool]_prog.in_singleton_set|)))
(assert (forall ((e1 Bool) (e2 Bool)) (!
  (= (Set_in e1 (Set_singleton e2)) (= e1 e2))
  :pattern ((Set_in e1 (Set_singleton e2)))
  :qid |$Set[Bool]_prog.in_singleton_set_equality|)))
(assert (forall ((e Bool)) (!
  (= (Set_card (Set_singleton e)) 1)
  :pattern ((Set_card (Set_singleton e)))
  :qid |$Set[Bool]_prog.singleton_set_cardinality|)))
(assert (forall ((s Set<Bool>) (e Bool)) (!
  (Set_in e (Set_unionone s e))
  :pattern ((Set_unionone s e))
  :qid |$Set[Bool]_prog.in_unionone_same|)))
(assert (forall ((s Set<Bool>) (e1 Bool) (e2 Bool)) (!
  (= (Set_in e1 (Set_unionone s e2)) (or (= e1 e2) (Set_in e1 s)))
  :pattern ((Set_in e1 (Set_unionone s e2)))
  :qid |$Set[Bool]_prog.in_unionone_other|)))
(assert (forall ((s Set<Bool>) (e1 Bool) (e2 Bool)) (!
  (implies (Set_in e1 s) (Set_in e1 (Set_unionone s e2)))
  :pattern ((Set_in e1 s) (Set_unionone s e2))
  :qid |$Set[Bool]_prog.invariance_in_unionone|)))
(assert (forall ((s Set<Bool>) (e Bool)) (!
  (implies (Set_in e s) (= (Set_card (Set_unionone s e)) (Set_card s)))
  :pattern ((Set_card (Set_unionone s e)))
  :qid |$Set[Bool]_prog.unionone_cardinality_invariant|)))
(assert (forall ((s Set<Bool>) (e Bool)) (!
  (implies
    (not (Set_in e s))
    (= (Set_card (Set_unionone s e)) (+ (Set_card s) 1)))
  :pattern ((Set_card (Set_unionone s e)))
  :qid |$Set[Bool]_prog.unionone_cardinality_changed|)))
(assert (forall ((s1 Set<Bool>) (s2 Set<Bool>) (e Bool)) (!
  (= (Set_in e (Set_union s1 s2)) (or (Set_in e s1) (Set_in e s2)))
  :pattern ((Set_in e (Set_union s1 s2)))
  :qid |$Set[Bool]_prog.in_union_in_one|)))
(assert (forall ((s1 Set<Bool>) (s2 Set<Bool>) (e Bool)) (!
  (implies (Set_in e s1) (Set_in e (Set_union s1 s2)))
  :pattern ((Set_in e s1) (Set_union s1 s2))
  :qid |$Set[Bool]_prog.in_left_in_union|)))
(assert (forall ((s1 Set<Bool>) (s2 Set<Bool>) (e Bool)) (!
  (implies (Set_in e s2) (Set_in e (Set_union s1 s2)))
  :pattern ((Set_in e s2) (Set_union s1 s2))
  :qid |$Set[Bool]_prog.in_right_in_union|)))
(assert (forall ((s1 Set<Bool>) (s2 Set<Bool>) (e Bool)) (!
  (= (Set_in e (Set_intersection s1 s2)) (and (Set_in e s1) (Set_in e s2)))
  :pattern ((Set_in e (Set_intersection s1 s2)))
  :pattern ((Set_intersection s1 s2) (Set_in e s1))
  :pattern ((Set_intersection s1 s2) (Set_in e s2))
  :qid |$Set[Bool]_prog.in_intersection_in_both|)))
(assert (forall ((s1 Set<Bool>) (s2 Set<Bool>)) (!
  (= (Set_union s1 (Set_union s1 s2)) (Set_union s1 s2))
  :pattern ((Set_union s1 (Set_union s1 s2)))
  :qid |$Set[Bool]_prog.union_left_idempotency|)))
(assert (forall ((s1 Set<Bool>) (s2 Set<Bool>)) (!
  (= (Set_union (Set_union s1 s2) s2) (Set_union s1 s2))
  :pattern ((Set_union (Set_union s1 s2) s2))
  :qid |$Set[Bool]_prog.union_right_idempotency|)))
(assert (forall ((s1 Set<Bool>) (s2 Set<Bool>)) (!
  (= (Set_intersection s1 (Set_intersection s1 s2)) (Set_intersection s1 s2))
  :pattern ((Set_intersection s1 (Set_intersection s1 s2)))
  :qid |$Set[Bool]_prog.intersection_left_idempotency|)))
(assert (forall ((s1 Set<Bool>) (s2 Set<Bool>)) (!
  (= (Set_intersection (Set_intersection s1 s2) s2) (Set_intersection s1 s2))
  :pattern ((Set_intersection (Set_intersection s1 s2) s2))
  :qid |$Set[Bool]_prog.intersection_right_idempotency|)))
(assert (forall ((s1 Set<Bool>) (s2 Set<Bool>)) (!
  (=
    (+ (Set_card (Set_union s1 s2)) (Set_card (Set_intersection s1 s2)))
    (+ (Set_card s1) (Set_card s2)))
  :pattern ((Set_card (Set_union s1 s2)))
  :pattern ((Set_card (Set_intersection s1 s2)))
  :qid |$Set[Bool]_prog.cardinality_sums|)))
(assert (forall ((s1 Set<Bool>) (s2 Set<Bool>) (e Bool)) (!
  (= (Set_in e (Set_difference s1 s2)) (and (Set_in e s1) (not (Set_in e s2))))
  :pattern ((Set_in e (Set_difference s1 s2)))
  :qid |$Set[Bool]_prog.in_difference|)))
(assert (forall ((s1 Set<Bool>) (s2 Set<Bool>) (e Bool)) (!
  (implies (Set_in e s2) (not (Set_in e (Set_difference s1 s2))))
  :pattern ((Set_difference s1 s2) (Set_in e s2))
  :qid |$Set[Bool]_prog.not_in_difference|)))
(assert (forall ((s1 Set<Bool>) (s2 Set<Bool>)) (!
  (=
    (Set_subset s1 s2)
    (forall ((e Bool)) (!
      (implies (Set_in e s1) (Set_in e s2))
      :pattern ((Set_in e s1))
      :pattern ((Set_in e s2))
      )))
  :pattern ((Set_subset s1 s2))
  :qid |$Set[Bool]_prog.subset_definition|)))
(assert (forall ((s1 Set<Bool>) (s2 Set<Bool>)) (!
  (=
    (Set_equal s1 s2)
    (forall ((e Bool)) (!
      (= (Set_in e s1) (Set_in e s2))
      :pattern ((Set_in e s1))
      :pattern ((Set_in e s2))
      )))
  :pattern ((Set_equal s1 s2))
  :qid |$Set[Bool]_prog.equality_definition|)))
(assert (forall ((s1 Set<Bool>) (s2 Set<Bool>)) (!
  (implies (Set_equal s1 s2) (= s1 s2))
  :pattern ((Set_equal s1 s2))
  :qid |$Set[Bool]_prog.native_equality|)))
(assert (forall ((s1 Set<Bool>) (s2 Set<Bool>)) (!
  (=
    (Set_disjoint s1 s2)
    (forall ((e Bool)) (!
      (or (not (Set_in e s1)) (not (Set_in e s2)))
      :pattern ((Set_in e s1))
      :pattern ((Set_in e s2))
      )))
  :pattern ((Set_disjoint s1 s2))
  :qid |$Set[Bool]_prog.disjointness_definition|)))
(assert (forall ((s1 Set<Bool>) (s2 Set<Bool>)) (!
  (and
    (=
      (+
        (+ (Set_card (Set_difference s1 s2)) (Set_card (Set_difference s2 s1)))
        (Set_card (Set_intersection s1 s2)))
      (Set_card (Set_union s1 s2)))
    (=
      (Set_card (Set_difference s1 s2))
      (- (Set_card s1) (Set_card (Set_intersection s1 s2)))))
  :pattern ((Set_card (Set_difference s1 s2)))
  :qid |$Set[Bool]_prog.cardinality_difference|)))
(assert (forall ((s Set<option<array>>)) (!
  (<= 0 (Set_card s))
  :pattern ((Set_card s))
  :qid |$Set[option[array]]_prog.card_non_negative|)))
(assert (forall ((e option<array>)) (!
  (not (Set_in e (as Set_empty  Set<option<array>>)))
  :pattern ((Set_in e (as Set_empty  Set<option<array>>)))
  :qid |$Set[option[array]]_prog.in_empty_set|)))
(assert (forall ((s Set<option<array>>)) (!
  (and
    (= (= (Set_card s) 0) (= s (as Set_empty  Set<option<array>>)))
    (implies
      (not (= (Set_card s) 0))
      (exists ((e option<array>)) (!
        (Set_in e s)
        :pattern ((Set_in e s))
        ))))
  :pattern ((Set_card s))
  :qid |$Set[option[array]]_prog.empty_set_cardinality|)))
(assert (forall ((e option<array>)) (!
  (Set_in e (Set_singleton e))
  :pattern ((Set_singleton e))
  :qid |$Set[option[array]]_prog.in_singleton_set|)))
(assert (forall ((e1 option<array>) (e2 option<array>)) (!
  (= (Set_in e1 (Set_singleton e2)) (= e1 e2))
  :pattern ((Set_in e1 (Set_singleton e2)))
  :qid |$Set[option[array]]_prog.in_singleton_set_equality|)))
(assert (forall ((e option<array>)) (!
  (= (Set_card (Set_singleton e)) 1)
  :pattern ((Set_card (Set_singleton e)))
  :qid |$Set[option[array]]_prog.singleton_set_cardinality|)))
(assert (forall ((s Set<option<array>>) (e option<array>)) (!
  (Set_in e (Set_unionone s e))
  :pattern ((Set_unionone s e))
  :qid |$Set[option[array]]_prog.in_unionone_same|)))
(assert (forall ((s Set<option<array>>) (e1 option<array>) (e2 option<array>)) (!
  (= (Set_in e1 (Set_unionone s e2)) (or (= e1 e2) (Set_in e1 s)))
  :pattern ((Set_in e1 (Set_unionone s e2)))
  :qid |$Set[option[array]]_prog.in_unionone_other|)))
(assert (forall ((s Set<option<array>>) (e1 option<array>) (e2 option<array>)) (!
  (implies (Set_in e1 s) (Set_in e1 (Set_unionone s e2)))
  :pattern ((Set_in e1 s) (Set_unionone s e2))
  :qid |$Set[option[array]]_prog.invariance_in_unionone|)))
(assert (forall ((s Set<option<array>>) (e option<array>)) (!
  (implies (Set_in e s) (= (Set_card (Set_unionone s e)) (Set_card s)))
  :pattern ((Set_card (Set_unionone s e)))
  :qid |$Set[option[array]]_prog.unionone_cardinality_invariant|)))
(assert (forall ((s Set<option<array>>) (e option<array>)) (!
  (implies
    (not (Set_in e s))
    (= (Set_card (Set_unionone s e)) (+ (Set_card s) 1)))
  :pattern ((Set_card (Set_unionone s e)))
  :qid |$Set[option[array]]_prog.unionone_cardinality_changed|)))
(assert (forall ((s1 Set<option<array>>) (s2 Set<option<array>>) (e option<array>)) (!
  (= (Set_in e (Set_union s1 s2)) (or (Set_in e s1) (Set_in e s2)))
  :pattern ((Set_in e (Set_union s1 s2)))
  :qid |$Set[option[array]]_prog.in_union_in_one|)))
(assert (forall ((s1 Set<option<array>>) (s2 Set<option<array>>) (e option<array>)) (!
  (implies (Set_in e s1) (Set_in e (Set_union s1 s2)))
  :pattern ((Set_in e s1) (Set_union s1 s2))
  :qid |$Set[option[array]]_prog.in_left_in_union|)))
(assert (forall ((s1 Set<option<array>>) (s2 Set<option<array>>) (e option<array>)) (!
  (implies (Set_in e s2) (Set_in e (Set_union s1 s2)))
  :pattern ((Set_in e s2) (Set_union s1 s2))
  :qid |$Set[option[array]]_prog.in_right_in_union|)))
(assert (forall ((s1 Set<option<array>>) (s2 Set<option<array>>) (e option<array>)) (!
  (= (Set_in e (Set_intersection s1 s2)) (and (Set_in e s1) (Set_in e s2)))
  :pattern ((Set_in e (Set_intersection s1 s2)))
  :pattern ((Set_intersection s1 s2) (Set_in e s1))
  :pattern ((Set_intersection s1 s2) (Set_in e s2))
  :qid |$Set[option[array]]_prog.in_intersection_in_both|)))
(assert (forall ((s1 Set<option<array>>) (s2 Set<option<array>>)) (!
  (= (Set_union s1 (Set_union s1 s2)) (Set_union s1 s2))
  :pattern ((Set_union s1 (Set_union s1 s2)))
  :qid |$Set[option[array]]_prog.union_left_idempotency|)))
(assert (forall ((s1 Set<option<array>>) (s2 Set<option<array>>)) (!
  (= (Set_union (Set_union s1 s2) s2) (Set_union s1 s2))
  :pattern ((Set_union (Set_union s1 s2) s2))
  :qid |$Set[option[array]]_prog.union_right_idempotency|)))
(assert (forall ((s1 Set<option<array>>) (s2 Set<option<array>>)) (!
  (= (Set_intersection s1 (Set_intersection s1 s2)) (Set_intersection s1 s2))
  :pattern ((Set_intersection s1 (Set_intersection s1 s2)))
  :qid |$Set[option[array]]_prog.intersection_left_idempotency|)))
(assert (forall ((s1 Set<option<array>>) (s2 Set<option<array>>)) (!
  (= (Set_intersection (Set_intersection s1 s2) s2) (Set_intersection s1 s2))
  :pattern ((Set_intersection (Set_intersection s1 s2) s2))
  :qid |$Set[option[array]]_prog.intersection_right_idempotency|)))
(assert (forall ((s1 Set<option<array>>) (s2 Set<option<array>>)) (!
  (=
    (+ (Set_card (Set_union s1 s2)) (Set_card (Set_intersection s1 s2)))
    (+ (Set_card s1) (Set_card s2)))
  :pattern ((Set_card (Set_union s1 s2)))
  :pattern ((Set_card (Set_intersection s1 s2)))
  :qid |$Set[option[array]]_prog.cardinality_sums|)))
(assert (forall ((s1 Set<option<array>>) (s2 Set<option<array>>) (e option<array>)) (!
  (= (Set_in e (Set_difference s1 s2)) (and (Set_in e s1) (not (Set_in e s2))))
  :pattern ((Set_in e (Set_difference s1 s2)))
  :qid |$Set[option[array]]_prog.in_difference|)))
(assert (forall ((s1 Set<option<array>>) (s2 Set<option<array>>) (e option<array>)) (!
  (implies (Set_in e s2) (not (Set_in e (Set_difference s1 s2))))
  :pattern ((Set_difference s1 s2) (Set_in e s2))
  :qid |$Set[option[array]]_prog.not_in_difference|)))
(assert (forall ((s1 Set<option<array>>) (s2 Set<option<array>>)) (!
  (=
    (Set_subset s1 s2)
    (forall ((e option<array>)) (!
      (implies (Set_in e s1) (Set_in e s2))
      :pattern ((Set_in e s1))
      :pattern ((Set_in e s2))
      )))
  :pattern ((Set_subset s1 s2))
  :qid |$Set[option[array]]_prog.subset_definition|)))
(assert (forall ((s1 Set<option<array>>) (s2 Set<option<array>>)) (!
  (=
    (Set_equal s1 s2)
    (forall ((e option<array>)) (!
      (= (Set_in e s1) (Set_in e s2))
      :pattern ((Set_in e s1))
      :pattern ((Set_in e s2))
      )))
  :pattern ((Set_equal s1 s2))
  :qid |$Set[option[array]]_prog.equality_definition|)))
(assert (forall ((s1 Set<option<array>>) (s2 Set<option<array>>)) (!
  (implies (Set_equal s1 s2) (= s1 s2))
  :pattern ((Set_equal s1 s2))
  :qid |$Set[option[array]]_prog.native_equality|)))
(assert (forall ((s1 Set<option<array>>) (s2 Set<option<array>>)) (!
  (=
    (Set_disjoint s1 s2)
    (forall ((e option<array>)) (!
      (or (not (Set_in e s1)) (not (Set_in e s2)))
      :pattern ((Set_in e s1))
      :pattern ((Set_in e s2))
      )))
  :pattern ((Set_disjoint s1 s2))
  :qid |$Set[option[array]]_prog.disjointness_definition|)))
(assert (forall ((s1 Set<option<array>>) (s2 Set<option<array>>)) (!
  (and
    (=
      (+
        (+ (Set_card (Set_difference s1 s2)) (Set_card (Set_difference s2 s1)))
        (Set_card (Set_intersection s1 s2)))
      (Set_card (Set_union s1 s2)))
    (=
      (Set_card (Set_difference s1 s2))
      (- (Set_card s1) (Set_card (Set_intersection s1 s2)))))
  :pattern ((Set_card (Set_difference s1 s2)))
  :qid |$Set[option[array]]_prog.cardinality_difference|)))
(assert (forall ((s Set<$Ref>)) (!
  (<= 0 (Set_card s))
  :pattern ((Set_card s))
  :qid |$Set[Ref]_prog.card_non_negative|)))
(assert (forall ((e $Ref)) (!
  (not (Set_in e (as Set_empty  Set<$Ref>)))
  :pattern ((Set_in e (as Set_empty  Set<$Ref>)))
  :qid |$Set[Ref]_prog.in_empty_set|)))
(assert (forall ((s Set<$Ref>)) (!
  (and
    (= (= (Set_card s) 0) (= s (as Set_empty  Set<$Ref>)))
    (implies
      (not (= (Set_card s) 0))
      (exists ((e $Ref)) (!
        (Set_in e s)
        :pattern ((Set_in e s))
        ))))
  :pattern ((Set_card s))
  :qid |$Set[Ref]_prog.empty_set_cardinality|)))
(assert (forall ((e $Ref)) (!
  (Set_in e (Set_singleton e))
  :pattern ((Set_singleton e))
  :qid |$Set[Ref]_prog.in_singleton_set|)))
(assert (forall ((e1 $Ref) (e2 $Ref)) (!
  (= (Set_in e1 (Set_singleton e2)) (= e1 e2))
  :pattern ((Set_in e1 (Set_singleton e2)))
  :qid |$Set[Ref]_prog.in_singleton_set_equality|)))
(assert (forall ((e $Ref)) (!
  (= (Set_card (Set_singleton e)) 1)
  :pattern ((Set_card (Set_singleton e)))
  :qid |$Set[Ref]_prog.singleton_set_cardinality|)))
(assert (forall ((s Set<$Ref>) (e $Ref)) (!
  (Set_in e (Set_unionone s e))
  :pattern ((Set_unionone s e))
  :qid |$Set[Ref]_prog.in_unionone_same|)))
(assert (forall ((s Set<$Ref>) (e1 $Ref) (e2 $Ref)) (!
  (= (Set_in e1 (Set_unionone s e2)) (or (= e1 e2) (Set_in e1 s)))
  :pattern ((Set_in e1 (Set_unionone s e2)))
  :qid |$Set[Ref]_prog.in_unionone_other|)))
(assert (forall ((s Set<$Ref>) (e1 $Ref) (e2 $Ref)) (!
  (implies (Set_in e1 s) (Set_in e1 (Set_unionone s e2)))
  :pattern ((Set_in e1 s) (Set_unionone s e2))
  :qid |$Set[Ref]_prog.invariance_in_unionone|)))
(assert (forall ((s Set<$Ref>) (e $Ref)) (!
  (implies (Set_in e s) (= (Set_card (Set_unionone s e)) (Set_card s)))
  :pattern ((Set_card (Set_unionone s e)))
  :qid |$Set[Ref]_prog.unionone_cardinality_invariant|)))
(assert (forall ((s Set<$Ref>) (e $Ref)) (!
  (implies
    (not (Set_in e s))
    (= (Set_card (Set_unionone s e)) (+ (Set_card s) 1)))
  :pattern ((Set_card (Set_unionone s e)))
  :qid |$Set[Ref]_prog.unionone_cardinality_changed|)))
(assert (forall ((s1 Set<$Ref>) (s2 Set<$Ref>) (e $Ref)) (!
  (= (Set_in e (Set_union s1 s2)) (or (Set_in e s1) (Set_in e s2)))
  :pattern ((Set_in e (Set_union s1 s2)))
  :qid |$Set[Ref]_prog.in_union_in_one|)))
(assert (forall ((s1 Set<$Ref>) (s2 Set<$Ref>) (e $Ref)) (!
  (implies (Set_in e s1) (Set_in e (Set_union s1 s2)))
  :pattern ((Set_in e s1) (Set_union s1 s2))
  :qid |$Set[Ref]_prog.in_left_in_union|)))
(assert (forall ((s1 Set<$Ref>) (s2 Set<$Ref>) (e $Ref)) (!
  (implies (Set_in e s2) (Set_in e (Set_union s1 s2)))
  :pattern ((Set_in e s2) (Set_union s1 s2))
  :qid |$Set[Ref]_prog.in_right_in_union|)))
(assert (forall ((s1 Set<$Ref>) (s2 Set<$Ref>) (e $Ref)) (!
  (= (Set_in e (Set_intersection s1 s2)) (and (Set_in e s1) (Set_in e s2)))
  :pattern ((Set_in e (Set_intersection s1 s2)))
  :pattern ((Set_intersection s1 s2) (Set_in e s1))
  :pattern ((Set_intersection s1 s2) (Set_in e s2))
  :qid |$Set[Ref]_prog.in_intersection_in_both|)))
(assert (forall ((s1 Set<$Ref>) (s2 Set<$Ref>)) (!
  (= (Set_union s1 (Set_union s1 s2)) (Set_union s1 s2))
  :pattern ((Set_union s1 (Set_union s1 s2)))
  :qid |$Set[Ref]_prog.union_left_idempotency|)))
(assert (forall ((s1 Set<$Ref>) (s2 Set<$Ref>)) (!
  (= (Set_union (Set_union s1 s2) s2) (Set_union s1 s2))
  :pattern ((Set_union (Set_union s1 s2) s2))
  :qid |$Set[Ref]_prog.union_right_idempotency|)))
(assert (forall ((s1 Set<$Ref>) (s2 Set<$Ref>)) (!
  (= (Set_intersection s1 (Set_intersection s1 s2)) (Set_intersection s1 s2))
  :pattern ((Set_intersection s1 (Set_intersection s1 s2)))
  :qid |$Set[Ref]_prog.intersection_left_idempotency|)))
(assert (forall ((s1 Set<$Ref>) (s2 Set<$Ref>)) (!
  (= (Set_intersection (Set_intersection s1 s2) s2) (Set_intersection s1 s2))
  :pattern ((Set_intersection (Set_intersection s1 s2) s2))
  :qid |$Set[Ref]_prog.intersection_right_idempotency|)))
(assert (forall ((s1 Set<$Ref>) (s2 Set<$Ref>)) (!
  (=
    (+ (Set_card (Set_union s1 s2)) (Set_card (Set_intersection s1 s2)))
    (+ (Set_card s1) (Set_card s2)))
  :pattern ((Set_card (Set_union s1 s2)))
  :pattern ((Set_card (Set_intersection s1 s2)))
  :qid |$Set[Ref]_prog.cardinality_sums|)))
(assert (forall ((s1 Set<$Ref>) (s2 Set<$Ref>) (e $Ref)) (!
  (= (Set_in e (Set_difference s1 s2)) (and (Set_in e s1) (not (Set_in e s2))))
  :pattern ((Set_in e (Set_difference s1 s2)))
  :qid |$Set[Ref]_prog.in_difference|)))
(assert (forall ((s1 Set<$Ref>) (s2 Set<$Ref>) (e $Ref)) (!
  (implies (Set_in e s2) (not (Set_in e (Set_difference s1 s2))))
  :pattern ((Set_difference s1 s2) (Set_in e s2))
  :qid |$Set[Ref]_prog.not_in_difference|)))
(assert (forall ((s1 Set<$Ref>) (s2 Set<$Ref>)) (!
  (=
    (Set_subset s1 s2)
    (forall ((e $Ref)) (!
      (implies (Set_in e s1) (Set_in e s2))
      :pattern ((Set_in e s1))
      :pattern ((Set_in e s2))
      )))
  :pattern ((Set_subset s1 s2))
  :qid |$Set[Ref]_prog.subset_definition|)))
(assert (forall ((s1 Set<$Ref>) (s2 Set<$Ref>)) (!
  (=
    (Set_equal s1 s2)
    (forall ((e $Ref)) (!
      (= (Set_in e s1) (Set_in e s2))
      :pattern ((Set_in e s1))
      :pattern ((Set_in e s2))
      )))
  :pattern ((Set_equal s1 s2))
  :qid |$Set[Ref]_prog.equality_definition|)))
(assert (forall ((s1 Set<$Ref>) (s2 Set<$Ref>)) (!
  (implies (Set_equal s1 s2) (= s1 s2))
  :pattern ((Set_equal s1 s2))
  :qid |$Set[Ref]_prog.native_equality|)))
(assert (forall ((s1 Set<$Ref>) (s2 Set<$Ref>)) (!
  (=
    (Set_disjoint s1 s2)
    (forall ((e $Ref)) (!
      (or (not (Set_in e s1)) (not (Set_in e s2)))
      :pattern ((Set_in e s1))
      :pattern ((Set_in e s2))
      )))
  :pattern ((Set_disjoint s1 s2))
  :qid |$Set[Ref]_prog.disjointness_definition|)))
(assert (forall ((s1 Set<$Ref>) (s2 Set<$Ref>)) (!
  (and
    (=
      (+
        (+ (Set_card (Set_difference s1 s2)) (Set_card (Set_difference s2 s1)))
        (Set_card (Set_intersection s1 s2)))
      (Set_card (Set_union s1 s2)))
    (=
      (Set_card (Set_difference s1 s2))
      (- (Set_card s1) (Set_card (Set_intersection s1 s2)))))
  :pattern ((Set_card (Set_difference s1 s2)))
  :qid |$Set[Ref]_prog.cardinality_difference|)))
(assert (forall ((s Set<$Snap>)) (!
  (<= 0 (Set_card s))
  :pattern ((Set_card s))
  :qid |$Set[Snap]_prog.card_non_negative|)))
(assert (forall ((e $Snap)) (!
  (not (Set_in e (as Set_empty  Set<$Snap>)))
  :pattern ((Set_in e (as Set_empty  Set<$Snap>)))
  :qid |$Set[Snap]_prog.in_empty_set|)))
(assert (forall ((s Set<$Snap>)) (!
  (and
    (= (= (Set_card s) 0) (= s (as Set_empty  Set<$Snap>)))
    (implies
      (not (= (Set_card s) 0))
      (exists ((e $Snap)) (!
        (Set_in e s)
        :pattern ((Set_in e s))
        ))))
  :pattern ((Set_card s))
  :qid |$Set[Snap]_prog.empty_set_cardinality|)))
(assert (forall ((e $Snap)) (!
  (Set_in e (Set_singleton e))
  :pattern ((Set_singleton e))
  :qid |$Set[Snap]_prog.in_singleton_set|)))
(assert (forall ((e1 $Snap) (e2 $Snap)) (!
  (= (Set_in e1 (Set_singleton e2)) (= e1 e2))
  :pattern ((Set_in e1 (Set_singleton e2)))
  :qid |$Set[Snap]_prog.in_singleton_set_equality|)))
(assert (forall ((e $Snap)) (!
  (= (Set_card (Set_singleton e)) 1)
  :pattern ((Set_card (Set_singleton e)))
  :qid |$Set[Snap]_prog.singleton_set_cardinality|)))
(assert (forall ((s Set<$Snap>) (e $Snap)) (!
  (Set_in e (Set_unionone s e))
  :pattern ((Set_unionone s e))
  :qid |$Set[Snap]_prog.in_unionone_same|)))
(assert (forall ((s Set<$Snap>) (e1 $Snap) (e2 $Snap)) (!
  (= (Set_in e1 (Set_unionone s e2)) (or (= e1 e2) (Set_in e1 s)))
  :pattern ((Set_in e1 (Set_unionone s e2)))
  :qid |$Set[Snap]_prog.in_unionone_other|)))
(assert (forall ((s Set<$Snap>) (e1 $Snap) (e2 $Snap)) (!
  (implies (Set_in e1 s) (Set_in e1 (Set_unionone s e2)))
  :pattern ((Set_in e1 s) (Set_unionone s e2))
  :qid |$Set[Snap]_prog.invariance_in_unionone|)))
(assert (forall ((s Set<$Snap>) (e $Snap)) (!
  (implies (Set_in e s) (= (Set_card (Set_unionone s e)) (Set_card s)))
  :pattern ((Set_card (Set_unionone s e)))
  :qid |$Set[Snap]_prog.unionone_cardinality_invariant|)))
(assert (forall ((s Set<$Snap>) (e $Snap)) (!
  (implies
    (not (Set_in e s))
    (= (Set_card (Set_unionone s e)) (+ (Set_card s) 1)))
  :pattern ((Set_card (Set_unionone s e)))
  :qid |$Set[Snap]_prog.unionone_cardinality_changed|)))
(assert (forall ((s1 Set<$Snap>) (s2 Set<$Snap>) (e $Snap)) (!
  (= (Set_in e (Set_union s1 s2)) (or (Set_in e s1) (Set_in e s2)))
  :pattern ((Set_in e (Set_union s1 s2)))
  :qid |$Set[Snap]_prog.in_union_in_one|)))
(assert (forall ((s1 Set<$Snap>) (s2 Set<$Snap>) (e $Snap)) (!
  (implies (Set_in e s1) (Set_in e (Set_union s1 s2)))
  :pattern ((Set_in e s1) (Set_union s1 s2))
  :qid |$Set[Snap]_prog.in_left_in_union|)))
(assert (forall ((s1 Set<$Snap>) (s2 Set<$Snap>) (e $Snap)) (!
  (implies (Set_in e s2) (Set_in e (Set_union s1 s2)))
  :pattern ((Set_in e s2) (Set_union s1 s2))
  :qid |$Set[Snap]_prog.in_right_in_union|)))
(assert (forall ((s1 Set<$Snap>) (s2 Set<$Snap>) (e $Snap)) (!
  (= (Set_in e (Set_intersection s1 s2)) (and (Set_in e s1) (Set_in e s2)))
  :pattern ((Set_in e (Set_intersection s1 s2)))
  :pattern ((Set_intersection s1 s2) (Set_in e s1))
  :pattern ((Set_intersection s1 s2) (Set_in e s2))
  :qid |$Set[Snap]_prog.in_intersection_in_both|)))
(assert (forall ((s1 Set<$Snap>) (s2 Set<$Snap>)) (!
  (= (Set_union s1 (Set_union s1 s2)) (Set_union s1 s2))
  :pattern ((Set_union s1 (Set_union s1 s2)))
  :qid |$Set[Snap]_prog.union_left_idempotency|)))
(assert (forall ((s1 Set<$Snap>) (s2 Set<$Snap>)) (!
  (= (Set_union (Set_union s1 s2) s2) (Set_union s1 s2))
  :pattern ((Set_union (Set_union s1 s2) s2))
  :qid |$Set[Snap]_prog.union_right_idempotency|)))
(assert (forall ((s1 Set<$Snap>) (s2 Set<$Snap>)) (!
  (= (Set_intersection s1 (Set_intersection s1 s2)) (Set_intersection s1 s2))
  :pattern ((Set_intersection s1 (Set_intersection s1 s2)))
  :qid |$Set[Snap]_prog.intersection_left_idempotency|)))
(assert (forall ((s1 Set<$Snap>) (s2 Set<$Snap>)) (!
  (= (Set_intersection (Set_intersection s1 s2) s2) (Set_intersection s1 s2))
  :pattern ((Set_intersection (Set_intersection s1 s2) s2))
  :qid |$Set[Snap]_prog.intersection_right_idempotency|)))
(assert (forall ((s1 Set<$Snap>) (s2 Set<$Snap>)) (!
  (=
    (+ (Set_card (Set_union s1 s2)) (Set_card (Set_intersection s1 s2)))
    (+ (Set_card s1) (Set_card s2)))
  :pattern ((Set_card (Set_union s1 s2)))
  :pattern ((Set_card (Set_intersection s1 s2)))
  :qid |$Set[Snap]_prog.cardinality_sums|)))
(assert (forall ((s1 Set<$Snap>) (s2 Set<$Snap>) (e $Snap)) (!
  (= (Set_in e (Set_difference s1 s2)) (and (Set_in e s1) (not (Set_in e s2))))
  :pattern ((Set_in e (Set_difference s1 s2)))
  :qid |$Set[Snap]_prog.in_difference|)))
(assert (forall ((s1 Set<$Snap>) (s2 Set<$Snap>) (e $Snap)) (!
  (implies (Set_in e s2) (not (Set_in e (Set_difference s1 s2))))
  :pattern ((Set_difference s1 s2) (Set_in e s2))
  :qid |$Set[Snap]_prog.not_in_difference|)))
(assert (forall ((s1 Set<$Snap>) (s2 Set<$Snap>)) (!
  (=
    (Set_subset s1 s2)
    (forall ((e $Snap)) (!
      (implies (Set_in e s1) (Set_in e s2))
      :pattern ((Set_in e s1))
      :pattern ((Set_in e s2))
      )))
  :pattern ((Set_subset s1 s2))
  :qid |$Set[Snap]_prog.subset_definition|)))
(assert (forall ((s1 Set<$Snap>) (s2 Set<$Snap>)) (!
  (=
    (Set_equal s1 s2)
    (forall ((e $Snap)) (!
      (= (Set_in e s1) (Set_in e s2))
      :pattern ((Set_in e s1))
      :pattern ((Set_in e s2))
      )))
  :pattern ((Set_equal s1 s2))
  :qid |$Set[Snap]_prog.equality_definition|)))
(assert (forall ((s1 Set<$Snap>) (s2 Set<$Snap>)) (!
  (implies (Set_equal s1 s2) (= s1 s2))
  :pattern ((Set_equal s1 s2))
  :qid |$Set[Snap]_prog.native_equality|)))
(assert (forall ((s1 Set<$Snap>) (s2 Set<$Snap>)) (!
  (=
    (Set_disjoint s1 s2)
    (forall ((e $Snap)) (!
      (or (not (Set_in e s1)) (not (Set_in e s2)))
      :pattern ((Set_in e s1))
      :pattern ((Set_in e s2))
      )))
  :pattern ((Set_disjoint s1 s2))
  :qid |$Set[Snap]_prog.disjointness_definition|)))
(assert (forall ((s1 Set<$Snap>) (s2 Set<$Snap>)) (!
  (and
    (=
      (+
        (+ (Set_card (Set_difference s1 s2)) (Set_card (Set_difference s2 s1)))
        (Set_card (Set_intersection s1 s2)))
      (Set_card (Set_union s1 s2)))
    (=
      (Set_card (Set_difference s1 s2))
      (- (Set_card s1) (Set_card (Set_intersection s1 s2)))))
  :pattern ((Set_card (Set_difference s1 s2)))
  :qid |$Set[Snap]_prog.cardinality_difference|)))
(assert (forall ((a2 array)) (!
  (forall ((i1 Int)) (!
    (and
      (= (loc_inv_1<array> (array_loc<Ref> a2 i1)) a2)
      (= (loc_inv_2<Int> (array_loc<Ref> a2 i1)) i1))
    :pattern ((loc_inv_1<array> (array_loc<Ref> a2 i1)))
    :pattern ((loc_inv_2<Int> (array_loc<Ref> a2 i1)))
    ))
  
  )))
(assert (forall ((a2 array)) (!
  (>= (alen<Int> a2) 0)
  :pattern ((alen<Int> a2))
  )))
(assert (forall ((x1 array)) (!
  (not (= (as None<option<array>>  option<array>) (some<option<array>> x1)))
  :pattern ((some<option<array>> x1))
  )))
(assert (forall ((x1 array)) (!
  (= (option_get<array> (some<option<array>> x1)) x1)
  :pattern ((option_get<array> (some<option<array>> x1)))
  )))
(assert (forall ((opt1 option<array>)) (!
  (= (some<option<array>> (option_get<array> opt1)) opt1)
  :pattern ((some<option<array>> (option_get<array> opt1)))
  )))
(assert (forall ((v t_null)) (!
  (= (as v_null<t_null>  t_null) v)
  
  )))
(assert (forall ((x1 any)) (!
  (not (= (as None<option<any>>  option<any>) (some<option<any>> x1)))
  :pattern ((some<option<any>> x1))
  )))
(assert (forall ((x1 any)) (!
  (= (option_get<any> (some<option<any>> x1)) x1)
  :pattern ((option_get<any> (some<option<any>> x1)))
  )))
(assert (forall ((opt1 option<any>)) (!
  (= (some<option<any>> (option_get<any> opt1)) opt1)
  :pattern ((some<option<any>> (option_get<any> opt1)))
  )))
(assert (forall ((v void)) (!
  (= (as unit<void>  void) v)
  
  )))
; /field_value_functions_axioms.smt2 [int: Int]
(assert (forall ((vs $FVF<Int>) (ws $FVF<Int>)) (!
    (implies
      (and
        (Set_equal ($FVF.domain_int vs) ($FVF.domain_int ws))
        (forall ((x $Ref)) (!
          (implies
            (Set_in x ($FVF.domain_int vs))
            (= ($FVF.lookup_int vs x) ($FVF.lookup_int ws x)))
          :pattern (($FVF.lookup_int vs x) ($FVF.lookup_int ws x))
          :qid |qp.$FVF<Int>-eq-inner|
          )))
      (= vs ws))
    :pattern (($SortWrappers.$FVF<Int>To$Snap vs)
              ($SortWrappers.$FVF<Int>To$Snap ws)
              )
    :qid |qp.$FVF<Int>-eq-outer|
    )))
(assert (forall ((r $Ref) (pm $FPM)) (!
    ($Perm.isValidVar ($FVF.perm_int pm r))
    :pattern ($FVF.perm_int pm r))))
(assert (forall ((r $Ref) (f Int)) (!
    (= ($FVF.loc_int f r) true)
    :pattern ($FVF.loc_int f r))))
; /field_value_functions_axioms.smt2 [option$array$: option[array]]
(assert (forall ((vs $FVF<option<array>>) (ws $FVF<option<array>>)) (!
    (implies
      (and
        (Set_equal ($FVF.domain_option$array$ vs) ($FVF.domain_option$array$ ws))
        (forall ((x $Ref)) (!
          (implies
            (Set_in x ($FVF.domain_option$array$ vs))
            (= ($FVF.lookup_option$array$ vs x) ($FVF.lookup_option$array$ ws x)))
          :pattern (($FVF.lookup_option$array$ vs x) ($FVF.lookup_option$array$ ws x))
          :qid |qp.$FVF<option<array>>-eq-inner|
          )))
      (= vs ws))
    :pattern (($SortWrappers.$FVF<option<array>>To$Snap vs)
              ($SortWrappers.$FVF<option<array>>To$Snap ws)
              )
    :qid |qp.$FVF<option<array>>-eq-outer|
    )))
(assert (forall ((r $Ref) (pm $FPM)) (!
    ($Perm.isValidVar ($FVF.perm_option$array$ pm r))
    :pattern ($FVF.perm_option$array$ pm r))))
(assert (forall ((r $Ref) (f option<array>)) (!
    (= ($FVF.loc_option$array$ f r) true)
    :pattern ($FVF.loc_option$array$ f r))))
; /field_value_functions_axioms.smt2 [bool: Bool]
(assert (forall ((vs $FVF<Bool>) (ws $FVF<Bool>)) (!
    (implies
      (and
        (Set_equal ($FVF.domain_bool vs) ($FVF.domain_bool ws))
        (forall ((x $Ref)) (!
          (implies
            (Set_in x ($FVF.domain_bool vs))
            (= ($FVF.lookup_bool vs x) ($FVF.lookup_bool ws x)))
          :pattern (($FVF.lookup_bool vs x) ($FVF.lookup_bool ws x))
          :qid |qp.$FVF<Bool>-eq-inner|
          )))
      (= vs ws))
    :pattern (($SortWrappers.$FVF<Bool>To$Snap vs)
              ($SortWrappers.$FVF<Bool>To$Snap ws)
              )
    :qid |qp.$FVF<Bool>-eq-outer|
    )))
(assert (forall ((r $Ref) (pm $FPM)) (!
    ($Perm.isValidVar ($FVF.perm_bool pm r))
    :pattern ($FVF.perm_bool pm r))))
(assert (forall ((r $Ref) (f Bool)) (!
    (= ($FVF.loc_bool f r) true)
    :pattern ($FVF.loc_bool f r))))
; End preamble
; ------------------------------------------------------------
; State saturation: after preamble
(set-option :timeout 100)
(check-sat)
; unknown
; ------------------------------------------------------------
; Begin function- and predicate-related preamble
; Declaring symbols related to program functions (from verification)
(declare-fun $k@121@00 () $Perm)
(declare-fun $k@130@00 () $Perm)
(declare-fun inv@122@00 ($Snap $Ref option<array> Int $Ref) Int)
(declare-fun inv@131@00 ($Snap $Ref option<array> Int $Ref) Int)
(declare-fun inv@132@00 ($Snap $Ref option<array> Int $Ref) Int)
(declare-fun sm@123@00 ($Snap $Ref option<array> Int) $FVF<option<array>>)
(declare-fun $k@136@00 () $Perm)
(declare-fun inv@138@00 ($Snap option<array> Int Int $Ref) Int)
(declare-fun sm@139@00 ($Snap option<array> Int Int) $FVF<Int>)
(declare-fun $k@147@00 () $Perm)
(declare-fun inv@148@00 ($Snap $Ref option<array> Int $Ref) Int)
(declare-fun sm@149@00 ($Snap $Ref option<array> Int) $FVF<Int>)
(declare-fun $k@154@00 () $Perm)
(declare-fun $k@163@00 () $Perm)
(declare-fun $k@170@00 () $Perm)
(declare-fun inv@155@00 ($Snap $Ref option<array> Int $Ref) Int)
(declare-fun inv@164@00 ($Snap $Ref option<array> Int $Ref) Int)
(declare-fun inv@165@00 ($Snap $Ref option<array> Int $Ref) Int)
(declare-fun inv@171@00 ($Snap $Ref option<array> Int Int $Ref) Int)
(declare-fun sm@156@00 ($Snap $Ref option<array> Int) $FVF<option<array>>)
(declare-fun sm@173@00 ($Snap $Ref option<array> Int) $FVF<Int>)
(declare-fun $k@177@00 () $Perm)
(declare-fun $k@186@00 () $Perm)
(declare-fun inv@178@00 ($Snap $Ref option<array> Int Int Int $Ref) Int)
(declare-fun inv@187@00 ($Snap $Ref option<array> Int Int Int $Ref) Int)
(declare-fun inv@188@00 ($Snap $Ref option<array> Int Int Int $Ref) Int)
(declare-fun sm@179@00 ($Snap $Ref option<array> Int Int Int) $FVF<option<array>>)
(declare-fun $k@191@00 () $Perm)
(declare-fun $k@209@00 () $Perm)
(declare-fun inv@192@00 ($Snap $Ref option<array> Int Int Int $Ref) Int)
(declare-fun inv@212@00 ($Snap $Ref option<array> Int Int Int $Ref) Int)
(declare-fun inv@213@00 ($Snap $Ref option<array> Int Int Int $Ref) Int)
(declare-fun sm@194@00 ($Snap $Ref option<array> Int Int Int) $FVF<option<array>>)
(declare-fun sm@196@00 ($Snap $Ref option<array> Int Int Int) $FVF<option<array>>)
(declare-fun sm@199@00 ($Snap $Ref option<array> Int Int Int) $FVF<option<array>>)
(declare-fun sm@203@00 ($Snap $Ref option<array> Int Int Int) $FVF<option<array>>)
(declare-fun sm@205@00 ($Snap $Ref option<array> Int Int Int) $FVF<option<array>>)
(declare-fun sm@210@00 ($Snap $Ref option<array> Int Int Int) $FVF<option<array>>)
(declare-fun sm@215@00 ($Snap $Ref option<array> Int Int Int) $FVF<Int>)
(define-fun pTaken@172@00 ((r $Ref) (s@$ $Snap) (this@88@00 $Ref) (a2@89@00 option<array>) (V@90@00 Int) (i1@168@00 Int)) $Perm
  (ite
    (and
      (<
        (inv@171@00 s@$ this@88@00 a2@89@00 V@90@00 i1@168@00 r)
        (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@156@00 s@$ this@88@00 a2@89@00 V@90@00) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1@168@00)))))
      (<= 0 (inv@171@00 s@$ this@88@00 a2@89@00 V@90@00 i1@168@00 r)))
    ($Perm.min
      (ite
        (and
          (and
            (and
              (< (inv@165@00 s@$ this@88@00 a2@89@00 V@90@00 r) V@90@00)
              (<= 0 (inv@165@00 s@$ this@88@00 a2@89@00 V@90@00 r)))
            (< (inv@164@00 s@$ this@88@00 a2@89@00 V@90@00 r) V@90@00))
          (<= 0 (inv@164@00 s@$ this@88@00 a2@89@00 V@90@00 r)))
        $k@163@00
        $Perm.No)
      $k@170@00)
    $Perm.No))
(define-fun pTaken@193@00 ((r $Ref) (s@$ $Snap) (this@102@00 $Ref) (G@103@00 option<array>) (V@104@00 Int) (s@105@00 Int) (t@106@00 Int)) $Perm
  (ite
    (and
      (<
        (inv@192@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
        V@104@00)
      (<= 0 (inv@192@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
    ($Perm.min
      (ite
        (and
          (<
            (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
            V@104@00)
          (<=
            0
            (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
        $k@177@00
        $Perm.No)
      $k@191@00)
    $Perm.No))
(define-fun pTaken@214@00 ((r $Ref) (s@$ $Snap) (this@102@00 $Ref) (G@103@00 option<array>) (V@104@00 Int) (s@105@00 Int) (t@106@00 Int)) $Perm
  (ite
    (and
      (and
        (and
          (<
            (inv@213@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
            V@104@00)
          (<=
            0
            (inv@213@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
        (<
          (inv@212@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
          V@104@00))
      (<= 0 (inv@212@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
    ($Perm.min
      (ite
        (and
          (and
            (and
              (<
                (inv@188@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                V@104@00)
              (<=
                0
                (inv@188@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
            (<
              (inv@187@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
              V@104@00))
          (<=
            0
            (inv@187@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
        $k@186@00
        $Perm.No)
      $k@209@00)
    $Perm.No))
(declare-fun $unresolved@115@00 () $Snap)
(assert (forall ((s@$ $Snap) (this@0@00 $Ref) (G@1@00 Seq<Seq<Int>>) (V@2@00 Int)) (!
  (=
    (SquareIntMatrix%limited s@$ this@0@00 G@1@00 V@2@00)
    (SquareIntMatrix s@$ this@0@00 G@1@00 V@2@00))
  :pattern ((SquareIntMatrix s@$ this@0@00 G@1@00 V@2@00))
  )))
(assert (forall ((s@$ $Snap) (this@0@00 $Ref) (G@1@00 Seq<Seq<Int>>) (V@2@00 Int)) (!
  (SquareIntMatrix%stateless this@0@00 G@1@00 V@2@00)
  :pattern ((SquareIntMatrix%limited s@$ this@0@00 G@1@00 V@2@00))
  )))
(assert (forall ((s@$ $Snap) (this@0@00 $Ref) (G@1@00 Seq<Seq<Int>>) (V@2@00 Int)) (!
  (implies
    (not (= this@0@00 $Ref.null))
    (=
      (SquareIntMatrix s@$ this@0@00 G@1@00 V@2@00)
      (and
        (= (Seq_length G@1@00) V@2@00)
        (forall ((e Seq<Int>)) (!
          (implies (Seq_contains G@1@00 e) (= (Seq_length e) V@2@00))
          :pattern ((Seq_contains G@1@00 e))
          :pattern ((Seq_length e))
          )))))
  :pattern ((SquareIntMatrix s@$ this@0@00 G@1@00 V@2@00))
  )))
(assert (forall ((s@$ $Snap) (this@4@00 $Ref) (G@5@00 Seq<Seq<Int>>) (V@6@00 Int)) (!
  (=
    (NonNegativeCapacities%limited s@$ this@4@00 G@5@00 V@6@00)
    (NonNegativeCapacities s@$ this@4@00 G@5@00 V@6@00))
  :pattern ((NonNegativeCapacities s@$ this@4@00 G@5@00 V@6@00))
  )))
(assert (forall ((s@$ $Snap) (this@4@00 $Ref) (G@5@00 Seq<Seq<Int>>) (V@6@00 Int)) (!
  (NonNegativeCapacities%stateless this@4@00 G@5@00 V@6@00)
  :pattern ((NonNegativeCapacities%limited s@$ this@4@00 G@5@00 V@6@00))
  )))
(assert (forall ((s@$ $Snap) (this@4@00 $Ref) (G@5@00 Seq<Seq<Int>>) (V@6@00 Int)) (!
  (implies
    (and
      (not (= this@4@00 $Ref.null))
      (SquareIntMatrix $Snap.unit this@4@00 G@5@00 V@6@00))
    (=
      (NonNegativeCapacities s@$ this@4@00 G@5@00 V@6@00)
      (forall ((i1 Int)) (!
        (implies
          (and (<= 0 i1) (< i1 V@6@00))
          (forall ((j Int)) (!
            (implies
              (and (<= 0 j) (< j V@6@00))
              (< 0 (Seq_index (Seq_index G@5@00 i1) j)))
            :pattern ((Seq_index (Seq_index G@5@00 i1) j))
            )))
        :pattern ((Seq_index G@5@00 i1))
        ))))
  :pattern ((NonNegativeCapacities s@$ this@4@00 G@5@00 V@6@00))
  )))
(assert (forall ((s@$ $Snap) (this@8@00 $Ref) (G@9@00 Seq<Seq<Int>>) (V@10@00 Int) (s@11@00 Int) (t@12@00 Int)) (!
  (=
    (FlowNetwork%limited s@$ this@8@00 G@9@00 V@10@00 s@11@00 t@12@00)
    (FlowNetwork s@$ this@8@00 G@9@00 V@10@00 s@11@00 t@12@00))
  :pattern ((FlowNetwork s@$ this@8@00 G@9@00 V@10@00 s@11@00 t@12@00))
  )))
(assert (forall ((s@$ $Snap) (this@8@00 $Ref) (G@9@00 Seq<Seq<Int>>) (V@10@00 Int) (s@11@00 Int) (t@12@00 Int)) (!
  (FlowNetwork%stateless this@8@00 G@9@00 V@10@00 s@11@00 t@12@00)
  :pattern ((FlowNetwork%limited s@$ this@8@00 G@9@00 V@10@00 s@11@00 t@12@00))
  )))
(assert (forall ((s@$ $Snap) (this@8@00 $Ref) (G@9@00 Seq<Seq<Int>>) (V@10@00 Int) (s@11@00 Int) (t@12@00 Int)) (!
  (implies
    (not (= this@8@00 $Ref.null))
    (=
      (FlowNetwork s@$ this@8@00 G@9@00 V@10@00 s@11@00 t@12@00)
      (and
        (and
          (and
            (and (and (<= 0 s@11@00) (< s@11@00 V@10@00)) (<= 0 t@12@00))
            (< t@12@00 V@10@00))
          (SquareIntMatrix $Snap.unit this@8@00 G@9@00 V@10@00))
        (NonNegativeCapacities ($Snap.combine $Snap.unit $Snap.unit) this@8@00 G@9@00 V@10@00))))
  :pattern ((FlowNetwork s@$ this@8@00 G@9@00 V@10@00 s@11@00 t@12@00))
  )))
(assert (forall ((s@$ $Snap) (this@14@00 $Ref) (G@15@00 Seq<Seq<Int>>) (n@16@00 Int) (v@17@00 Int) (V@18@00 Int)) (!
  (=
    (SumOutgoingFlow%limited s@$ this@14@00 G@15@00 n@16@00 v@17@00 V@18@00)
    (SumOutgoingFlow s@$ this@14@00 G@15@00 n@16@00 v@17@00 V@18@00))
  :pattern ((SumOutgoingFlow s@$ this@14@00 G@15@00 n@16@00 v@17@00 V@18@00))
  )))
(assert (forall ((s@$ $Snap) (this@14@00 $Ref) (G@15@00 Seq<Seq<Int>>) (n@16@00 Int) (v@17@00 Int) (V@18@00 Int)) (!
  (SumOutgoingFlow%stateless this@14@00 G@15@00 n@16@00 v@17@00 V@18@00)
  :pattern ((SumOutgoingFlow%limited s@$ this@14@00 G@15@00 n@16@00 v@17@00 V@18@00))
  )))
(assert (forall ((s@$ $Snap) (this@14@00 $Ref) (G@15@00 Seq<Seq<Int>>) (n@16@00 Int) (v@17@00 Int) (V@18@00 Int)) (!
  (implies
    (and
      (not (= this@14@00 $Ref.null))
      (FlowNetwork $Snap.unit this@14@00 G@15@00 V@18@00 n@16@00 v@17@00))
    (=
      (SumOutgoingFlow s@$ this@14@00 G@15@00 n@16@00 v@17@00 V@18@00)
      (ite
        (< 0 n@16@00)
        (+
          (Seq_index (Seq_index G@15@00 v@17@00) n@16@00)
          (SumOutgoingFlow%limited ($Snap.combine $Snap.unit $Snap.unit) this@14@00 G@15@00 (-
            n@16@00
            1) v@17@00 V@18@00))
        0)))
  :pattern ((SumOutgoingFlow s@$ this@14@00 G@15@00 n@16@00 v@17@00 V@18@00))
  )))
(assert (forall ((s@$ $Snap) (this@20@00 $Ref) (G@21@00 Seq<Seq<Int>>) (n@22@00 Int) (v@23@00 Int) (V@24@00 Int)) (!
  (=
    (SumIncomingFlow%limited s@$ this@20@00 G@21@00 n@22@00 v@23@00 V@24@00)
    (SumIncomingFlow s@$ this@20@00 G@21@00 n@22@00 v@23@00 V@24@00))
  :pattern ((SumIncomingFlow s@$ this@20@00 G@21@00 n@22@00 v@23@00 V@24@00))
  )))
(assert (forall ((s@$ $Snap) (this@20@00 $Ref) (G@21@00 Seq<Seq<Int>>) (n@22@00 Int) (v@23@00 Int) (V@24@00 Int)) (!
  (SumIncomingFlow%stateless this@20@00 G@21@00 n@22@00 v@23@00 V@24@00)
  :pattern ((SumIncomingFlow%limited s@$ this@20@00 G@21@00 n@22@00 v@23@00 V@24@00))
  )))
(assert (forall ((s@$ $Snap) (this@20@00 $Ref) (G@21@00 Seq<Seq<Int>>) (n@22@00 Int) (v@23@00 Int) (V@24@00 Int)) (!
  (implies
    (and
      (not (= this@20@00 $Ref.null))
      (FlowNetwork $Snap.unit this@20@00 G@21@00 V@24@00 n@22@00 v@23@00))
    (=
      (SumIncomingFlow s@$ this@20@00 G@21@00 n@22@00 v@23@00 V@24@00)
      (ite
        (< 0 n@22@00)
        (+
          (Seq_index (Seq_index G@21@00 n@22@00) v@23@00)
          (SumIncomingFlow%limited ($Snap.combine $Snap.unit $Snap.unit) this@20@00 G@21@00 (-
            n@22@00
            1) v@23@00 V@24@00))
        0)))
  :pattern ((SumIncomingFlow s@$ this@20@00 G@21@00 n@22@00 v@23@00 V@24@00))
  )))
(assert (forall ((s@$ $Snap) (this@26@00 $Ref) (G@27@00 Seq<Seq<Int>>) (Gf@28@00 Seq<Seq<Int>>) (V@29@00 Int)) (!
  (=
    (CapacityConstraint%limited s@$ this@26@00 G@27@00 Gf@28@00 V@29@00)
    (CapacityConstraint s@$ this@26@00 G@27@00 Gf@28@00 V@29@00))
  :pattern ((CapacityConstraint s@$ this@26@00 G@27@00 Gf@28@00 V@29@00))
  )))
(assert (forall ((s@$ $Snap) (this@26@00 $Ref) (G@27@00 Seq<Seq<Int>>) (Gf@28@00 Seq<Seq<Int>>) (V@29@00 Int)) (!
  (CapacityConstraint%stateless this@26@00 G@27@00 Gf@28@00 V@29@00)
  :pattern ((CapacityConstraint%limited s@$ this@26@00 G@27@00 Gf@28@00 V@29@00))
  )))
(assert (forall ((s@$ $Snap) (this@26@00 $Ref) (G@27@00 Seq<Seq<Int>>) (Gf@28@00 Seq<Seq<Int>>) (V@29@00 Int)) (!
  (implies
    (and
      (not (= this@26@00 $Ref.null))
      (SquareIntMatrix $Snap.unit this@26@00 G@27@00 V@29@00)
      (SquareIntMatrix $Snap.unit this@26@00 Gf@28@00 V@29@00))
    (=
      (CapacityConstraint s@$ this@26@00 G@27@00 Gf@28@00 V@29@00)
      (forall ((i1 Int)) (!
        (implies
          (and (<= 0 i1) (< i1 V@29@00))
          (forall ((j Int)) (!
            (implies
              (and (<= 0 j) (< j V@29@00))
              (<=
                (Seq_index (Seq_index Gf@28@00 i1) j)
                (Seq_index (Seq_index G@27@00 i1) j)))
            :pattern ((Seq_index (Seq_index Gf@28@00 i1) j))
            :pattern ((Seq_index (Seq_index G@27@00 i1) j))
            )))
        :pattern ((Seq_index Gf@28@00 i1))
        :pattern ((Seq_index G@27@00 i1))
        ))))
  :pattern ((CapacityConstraint s@$ this@26@00 G@27@00 Gf@28@00 V@29@00))
  )))
(assert (forall ((s@$ $Snap) (this@31@00 $Ref) (G@32@00 Seq<Seq<Int>>) (V@33@00 Int) (s@34@00 Int) (t@35@00 Int)) (!
  (=
    (FlowConservation%limited s@$ this@31@00 G@32@00 V@33@00 s@34@00 t@35@00)
    (FlowConservation s@$ this@31@00 G@32@00 V@33@00 s@34@00 t@35@00))
  :pattern ((FlowConservation s@$ this@31@00 G@32@00 V@33@00 s@34@00 t@35@00))
  )))
(assert (forall ((s@$ $Snap) (this@31@00 $Ref) (G@32@00 Seq<Seq<Int>>) (V@33@00 Int) (s@34@00 Int) (t@35@00 Int)) (!
  (FlowConservation%stateless this@31@00 G@32@00 V@33@00 s@34@00 t@35@00)
  :pattern ((FlowConservation%limited s@$ this@31@00 G@32@00 V@33@00 s@34@00 t@35@00))
  )))
(assert (forall ((s@$ $Snap) (this@31@00 $Ref) (G@32@00 Seq<Seq<Int>>) (V@33@00 Int) (s@34@00 Int) (t@35@00 Int)) (!
  (implies
    (and
      (not (= this@31@00 $Ref.null))
      (FlowNetwork $Snap.unit this@31@00 G@32@00 V@33@00 s@34@00 t@35@00))
    (=
      (FlowConservation s@$ this@31@00 G@32@00 V@33@00 s@34@00 t@35@00)
      (and
        (and
          (<=
            (SumIncomingFlow ($Snap.combine $Snap.unit $Snap.unit) this@31@00 G@32@00 (-
              V@33@00
              1) s@34@00 V@33@00)
            (SumOutgoingFlow ($Snap.combine $Snap.unit $Snap.unit) this@31@00 G@32@00 (-
              V@33@00
              1) s@34@00 V@33@00))
          (<=
            (SumOutgoingFlow ($Snap.combine $Snap.unit $Snap.unit) this@31@00 G@32@00 (-
              V@33@00
              1) t@35@00 V@33@00)
            (SumIncomingFlow ($Snap.combine $Snap.unit $Snap.unit) this@31@00 G@32@00 (-
              V@33@00
              1) t@35@00 V@33@00)))
        (forall ((v Int) (fresh__1 Int)) (!
          (implies
            (and
              (and (and (<= 0 v) (< v V@33@00)) (not (= v s@34@00)))
              (not (= v t@35@00)))
            (=
              (SumIncomingFlow ($Snap.combine $Snap.unit $Snap.unit) this@31@00 G@32@00 (-
                V@33@00
                1) v V@33@00)
              (SumOutgoingFlow ($Snap.combine $Snap.unit $Snap.unit) this@31@00 G@32@00 (-
                V@33@00
                1) v V@33@00)))
          :pattern ((SumOutgoingFlow%limited $unresolved@115@00 this@31@00 G@32@00 fresh__1 v V@33@00))
          )))))
  :pattern ((FlowConservation s@$ this@31@00 G@32@00 V@33@00 s@34@00 t@35@00))
  )))
(assert (forall ((s@$ $Snap) (a2@37@00 array) (i1@38@00 Int)) (!
  (= (aloc%limited s@$ a2@37@00 i1@38@00) (aloc s@$ a2@37@00 i1@38@00))
  :pattern ((aloc s@$ a2@37@00 i1@38@00))
  )))
(assert (forall ((s@$ $Snap) (a2@37@00 array) (i1@38@00 Int)) (!
  (aloc%stateless a2@37@00 i1@38@00)
  :pattern ((aloc%limited s@$ a2@37@00 i1@38@00))
  )))
(assert (forall ((s@$ $Snap) (a2@37@00 array) (i1@38@00 Int)) (!
  (let ((result@39@00 (aloc%limited s@$ a2@37@00 i1@38@00))) (implies
    (and (<= 0 i1@38@00) (< i1@38@00 (alen<Int> a2@37@00)))
    (and
      (= (loc_inv_1<array> result@39@00) a2@37@00)
      (= (loc_inv_2<Int> result@39@00) i1@38@00))))
  :pattern ((aloc%limited s@$ a2@37@00 i1@38@00))
  )))
(assert (forall ((s@$ $Snap) (a2@37@00 array) (i1@38@00 Int)) (!
  (implies
    (and (<= 0 i1@38@00) (< i1@38@00 (alen<Int> a2@37@00)))
    (= (aloc s@$ a2@37@00 i1@38@00) (array_loc<Ref> a2@37@00 i1@38@00)))
  :pattern ((aloc s@$ a2@37@00 i1@38@00))
  )))
(assert (forall ((s@$ $Snap) (opt1@40@00 option<array>)) (!
  (= (opt_get1%limited s@$ opt1@40@00) (opt_get1 s@$ opt1@40@00))
  :pattern ((opt_get1 s@$ opt1@40@00))
  )))
(assert (forall ((s@$ $Snap) (opt1@40@00 option<array>)) (!
  (opt_get1%stateless opt1@40@00)
  :pattern ((opt_get1%limited s@$ opt1@40@00))
  )))
(assert (forall ((s@$ $Snap) (opt1@40@00 option<array>)) (!
  (let ((result@41@00 (opt_get1%limited s@$ opt1@40@00))) (implies
    (not (= opt1@40@00 (as None<option<array>>  option<array>)))
    (= (some<option<array>> result@41@00) opt1@40@00)))
  :pattern ((opt_get1%limited s@$ opt1@40@00))
  )))
(assert (forall ((s@$ $Snap) (opt1@40@00 option<array>)) (!
  (implies
    (not (= opt1@40@00 (as None<option<array>>  option<array>)))
    (= (opt_get1 s@$ opt1@40@00) (option_get<array> opt1@40@00)))
  :pattern ((opt_get1 s@$ opt1@40@00))
  )))
(assert (forall ((s@$ $Snap) (this@42@00 $Ref) (p@43@00 Seq<Int>) (V@44@00 Int)) (!
  (=
    (valid_graph_vertices1%limited s@$ this@42@00 p@43@00 V@44@00)
    (valid_graph_vertices1 s@$ this@42@00 p@43@00 V@44@00))
  :pattern ((valid_graph_vertices1 s@$ this@42@00 p@43@00 V@44@00))
  )))
(assert (forall ((s@$ $Snap) (this@42@00 $Ref) (p@43@00 Seq<Int>) (V@44@00 Int)) (!
  (valid_graph_vertices1%stateless this@42@00 p@43@00 V@44@00)
  :pattern ((valid_graph_vertices1%limited s@$ this@42@00 p@43@00 V@44@00))
  )))
(assert (forall ((s@$ $Snap) (this@42@00 $Ref) (p@43@00 Seq<Int>) (V@44@00 Int)) (!
  (implies
    (not (= this@42@00 $Ref.null))
    (=
      (valid_graph_vertices1 s@$ this@42@00 p@43@00 V@44@00)
      (and
        (forall ((unknown1 Int)) (!
          (implies
            (and (<= 0 unknown1) (< unknown1 (Seq_length p@43@00)))
            (<= 0 (Seq_index p@43@00 unknown1)))
          :pattern ((Seq_index p@43@00 unknown1))
          ))
        (forall ((unknown1 Int)) (!
          (implies
            (and (<= 0 unknown1) (< unknown1 (Seq_length p@43@00)))
            (< (Seq_index p@43@00 unknown1) V@44@00))
          :pattern ((Seq_index p@43@00 unknown1))
          )))))
  :pattern ((valid_graph_vertices1 s@$ this@42@00 p@43@00 V@44@00))
  )))
(assert (forall ((s@$ $Snap) (this@46@00 $Ref) (G@47@00 Seq<Seq<Int>>) (Gf@48@00 Seq<Seq<Int>>) (V@49@00 Int) (s@50@00 Int) (t@51@00 Int)) (!
  (=
    (ValidFlow%limited s@$ this@46@00 G@47@00 Gf@48@00 V@49@00 s@50@00 t@51@00)
    (ValidFlow s@$ this@46@00 G@47@00 Gf@48@00 V@49@00 s@50@00 t@51@00))
  :pattern ((ValidFlow s@$ this@46@00 G@47@00 Gf@48@00 V@49@00 s@50@00 t@51@00))
  )))
(assert (forall ((s@$ $Snap) (this@46@00 $Ref) (G@47@00 Seq<Seq<Int>>) (Gf@48@00 Seq<Seq<Int>>) (V@49@00 Int) (s@50@00 Int) (t@51@00 Int)) (!
  (ValidFlow%stateless this@46@00 G@47@00 Gf@48@00 V@49@00 s@50@00 t@51@00)
  :pattern ((ValidFlow%limited s@$ this@46@00 G@47@00 Gf@48@00 V@49@00 s@50@00 t@51@00))
  )))
(assert (forall ((s@$ $Snap) (this@46@00 $Ref) (G@47@00 Seq<Seq<Int>>) (Gf@48@00 Seq<Seq<Int>>) (V@49@00 Int) (s@50@00 Int) (t@51@00 Int)) (!
  (implies
    (and
      (not (= this@46@00 $Ref.null))
      (SquareIntMatrix $Snap.unit this@46@00 Gf@48@00 V@49@00)
      (FlowNetwork $Snap.unit this@46@00 G@47@00 V@49@00 s@50@00 t@51@00)
      (FlowNetwork $Snap.unit this@46@00 Gf@48@00 V@49@00 s@50@00 t@51@00))
    (=
      (ValidFlow s@$ this@46@00 G@47@00 Gf@48@00 V@49@00 s@50@00 t@51@00)
      (and
        (FlowConservation ($Snap.combine $Snap.unit $Snap.unit) this@46@00 G@47@00 V@49@00 s@50@00 t@51@00)
        (CapacityConstraint ($Snap.combine
          $Snap.unit
          ($Snap.combine $Snap.unit $Snap.unit)) this@46@00 G@47@00 Gf@48@00 V@49@00))))
  :pattern ((ValidFlow s@$ this@46@00 G@47@00 Gf@48@00 V@49@00 s@50@00 t@51@00))
  )))
(assert (forall ((s@$ $Snap) (this@53@00 $Ref) (G@54@00 option<array>) (V@55@00 Int)) (!
  (=
    (SquareIntMatrix1%limited s@$ this@53@00 G@54@00 V@55@00)
    (SquareIntMatrix1 s@$ this@53@00 G@54@00 V@55@00))
  :pattern ((SquareIntMatrix1 s@$ this@53@00 G@54@00 V@55@00))
  )))
(assert (forall ((s@$ $Snap) (this@53@00 $Ref) (G@54@00 option<array>) (V@55@00 Int)) (!
  (SquareIntMatrix1%stateless this@53@00 G@54@00 V@55@00)
  :pattern ((SquareIntMatrix1%limited s@$ this@53@00 G@54@00 V@55@00))
  )))
(assert (forall ((s@$ $Snap) (this@53@00 $Ref) (G@54@00 option<array>) (V@55@00 Int)) (!
  (and
    (forall ((i1@120@00 Int)) (!
      (implies
        (and (and (< i1@120@00 V@55@00) (<= 0 i1@120@00)) (< $Perm.No $k@121@00))
        (=
          (inv@122@00 s@$ this@53@00 G@54@00 V@55@00 (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@54@00) i1@120@00))
          i1@120@00))
      :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@54@00) i1@120@00))
      ))
    (forall ((r $Ref)) (!
      (implies
        (and
          (and
            (< (inv@122@00 s@$ this@53@00 G@54@00 V@55@00 r) V@55@00)
            (<= 0 (inv@122@00 s@$ this@53@00 G@54@00 V@55@00 r)))
          (< $Perm.No $k@121@00))
        (=
          (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@54@00) (inv@122@00 s@$ this@53@00 G@54@00 V@55@00 r))
          r))
      :pattern ((inv@122@00 s@$ this@53@00 G@54@00 V@55@00 r))
      :qid |option$array$-fctOfInv|))
    (forall ((i1@128@00 Int) (j@129@00 Int)) (!
      (implies
        (and
          (and
            (and
              (and (< j@129@00 V@55@00) (<= 0 j@129@00))
              (< i1@128@00 V@55@00))
            (<= 0 i1@128@00))
          (< $Perm.No $k@130@00))
        (and
          (=
            (inv@131@00 s@$ this@53@00 G@54@00 V@55@00 (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@123@00 s@$ this@53@00 G@54@00 V@55@00) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@54@00) i1@128@00))) j@129@00))
            i1@128@00)
          (=
            (inv@132@00 s@$ this@53@00 G@54@00 V@55@00 (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@123@00 s@$ this@53@00 G@54@00 V@55@00) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@54@00) i1@128@00))) j@129@00))
            j@129@00)))
      :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@123@00 s@$ this@53@00 G@54@00 V@55@00) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@54@00) i1@128@00))) j@129@00))
      ))
    (forall ((r $Ref)) (!
      (implies
        (and
          (and
            (and
              (and
                (< (inv@132@00 s@$ this@53@00 G@54@00 V@55@00 r) V@55@00)
                (<= 0 (inv@132@00 s@$ this@53@00 G@54@00 V@55@00 r)))
              (< (inv@131@00 s@$ this@53@00 G@54@00 V@55@00 r) V@55@00))
            (<= 0 (inv@131@00 s@$ this@53@00 G@54@00 V@55@00 r)))
          (< $Perm.No $k@130@00))
        (=
          (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@123@00 s@$ this@53@00 G@54@00 V@55@00) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@54@00) (inv@131@00 s@$ this@53@00 G@54@00 V@55@00 r)))) (inv@132@00 s@$ this@53@00 G@54@00 V@55@00 r))
          r))
      :pattern ((inv@131@00 s@$ this@53@00 G@54@00 V@55@00 r))
      :pattern ((inv@132@00 s@$ this@53@00 G@54@00 V@55@00 r))
      :qid |int-fctOfInv|))
    (forall ((r $Ref)) (!
      (implies
        (ite
          (and
            (< (inv@122@00 s@$ this@53@00 G@54@00 V@55@00 r) V@55@00)
            (<= 0 (inv@122@00 s@$ this@53@00 G@54@00 V@55@00 r)))
          (< $Perm.No $k@121@00)
          false)
        (=
          ($FVF.lookup_option$array$ (sm@123@00 s@$ this@53@00 G@54@00 V@55@00) r)
          ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r)))
      :pattern (($FVF.lookup_option$array$ (sm@123@00 s@$ this@53@00 G@54@00 V@55@00) r))
      :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r))
      :qid |qp.fvfValDef0|))
    (forall ((r $Ref)) (!
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r)
      :pattern (($FVF.lookup_option$array$ (sm@123@00 s@$ this@53@00 G@54@00 V@55@00) r))
      :qid |qp.fvfResTrgDef1|))
    ($Perm.isReadVar $k@121@00 $Perm.Write)
    ($Perm.isReadVar $k@130@00 $Perm.Write)
    (implies
      (and
        (not (= this@53@00 $Ref.null))
        (not (= G@54@00 (as None<option<array>>  option<array>)))
        (= (alen<Int> (opt_get1 $Snap.unit G@54@00)) V@55@00)
        (forall ((i1 Int)) (!
          (implies
            (and (<= 0 i1) (< i1 V@55@00))
            (not
              (=
                ($FVF.lookup_option$array$ (sm@123@00 s@$ this@53@00 G@54@00 V@55@00) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@54@00) i1))
                (as None<option<array>>  option<array>))))
          :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@54@00) i1))
          ))
        (forall ((i1 Int)) (!
          (implies
            (and (<= 0 i1) (< i1 V@55@00))
            (=
              (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@123@00 s@$ this@53@00 G@54@00 V@55@00) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit G@54@00) i1))))
              V@55@00))
          :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@123@00 s@$ this@53@00 G@54@00 V@55@00) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@54@00) i1)))))
          ))
        (forall ((i1 Int)) (!
          (forall ((i2 Int)) (!
            (implies
              (and
                (and
                  (and (and (<= 0 i1) (< i1 V@55@00)) (<= 0 i2))
                  (< i2 V@55@00))
                (=
                  ($FVF.lookup_option$array$ (sm@123@00 s@$ this@53@00 G@54@00 V@55@00) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit G@54@00) i1))
                  ($FVF.lookup_option$array$ (sm@123@00 s@$ this@53@00 G@54@00 V@55@00) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit G@54@00) i2))))
              (= i1 i2))
            :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@54@00) i2))
            ))
          :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@54@00) i1))
          )))
      (=
        (SquareIntMatrix1 s@$ this@53@00 G@54@00 V@55@00)
        (and
          (= (alen<Int> (opt_get1 $Snap.unit G@54@00)) V@55@00)
          (forall ((i1 Int)) (!
            (implies
              (and (<= 0 i1) (< i1 V@55@00))
              (=
                (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@123@00 s@$ this@53@00 G@54@00 V@55@00) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@54@00) i1))))
                V@55@00))
            :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@123@00 s@$ this@53@00 G@54@00 V@55@00) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@54@00) i1)))))
            ))))))
  :pattern ((SquareIntMatrix1 s@$ this@53@00 G@54@00 V@55@00))
  )))
(assert (forall ((s@$ $Snap) (t@57@00 any)) (!
  (= (any_as%limited s@$ t@57@00) (any_as s@$ t@57@00))
  :pattern ((any_as s@$ t@57@00))
  )))
(assert (forall ((s@$ $Snap) (t@57@00 any)) (!
  (any_as%stateless t@57@00)
  :pattern ((any_as%limited s@$ t@57@00))
  )))
(assert (forall ((s@$ $Snap) (a2@59@00 option<array>) (from@60@00 Int) (to@61@00 Int)) (!
  (Seq_equal
    (unknown%limited s@$ a2@59@00 from@60@00 to@61@00)
    (unknown_ s@$ a2@59@00 from@60@00 to@61@00))
  :pattern ((unknown_ s@$ a2@59@00 from@60@00 to@61@00))
  )))
(assert (forall ((s@$ $Snap) (a2@59@00 option<array>) (from@60@00 Int) (to@61@00 Int)) (!
  (unknown%stateless a2@59@00 from@60@00 to@61@00)
  :pattern ((unknown%limited s@$ a2@59@00 from@60@00 to@61@00))
  )))
(assert (forall ((s@$ $Snap) (a2@59@00 option<array>) (from@60@00 Int) (to@61@00 Int)) (!
  (let ((result@62@00 (unknown%limited s@$ a2@59@00 from@60@00 to@61@00))) (and
    (forall ((i1@135@00 Int)) (!
      (implies
        (and
          (and (< i1@135@00 to@61@00) (<= from@60@00 i1@135@00))
          (< $Perm.No $k@136@00))
        (=
          (inv@138@00 s@$ a2@59@00 from@60@00 to@61@00 (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit a2@59@00) i1@135@00))
          i1@135@00))
      :pattern (($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$))))) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit a2@59@00) i1@135@00)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit a2@59@00) i1@135@00)))
      ))
    (forall ((r $Ref)) (!
      (implies
        (and
          (and
            (< (inv@138@00 s@$ a2@59@00 from@60@00 to@61@00 r) to@61@00)
            (<= from@60@00 (inv@138@00 s@$ a2@59@00 from@60@00 to@61@00 r)))
          (< $Perm.No $k@136@00))
        (=
          (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit a2@59@00) (inv@138@00 s@$ a2@59@00 from@60@00 to@61@00 r))
          r))
      :pattern ((inv@138@00 s@$ a2@59@00 from@60@00 to@61@00 r))
      :qid |int-fctOfInv|))
    (forall ((r $Ref)) (!
      (implies
        (ite
          (and
            (< (inv@138@00 s@$ a2@59@00 from@60@00 to@61@00 r) to@61@00)
            (<= from@60@00 (inv@138@00 s@$ a2@59@00 from@60@00 to@61@00 r)))
          (< $Perm.No $k@136@00)
          false)
        (=
          ($FVF.lookup_int (sm@139@00 s@$ a2@59@00 from@60@00 to@61@00) r)
          ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$))))) r)))
      :pattern (($FVF.lookup_int (sm@139@00 s@$ a2@59@00 from@60@00 to@61@00) r))
      :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$))))) r))
      :qid |qp.fvfValDef5|))
    (forall ((r $Ref)) (!
      ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r)
      :pattern (($FVF.lookup_int (sm@139@00 s@$ a2@59@00 from@60@00 to@61@00) r))
      :qid |qp.fvfResTrgDef6|))
    ($Perm.isReadVar $k@136@00 $Perm.Write)
    (implies
      (and
        (not (= a2@59@00 (as None<option<array>>  option<array>)))
        (<= 0 from@60@00)
        (<= from@60@00 to@61@00)
        (<= to@61@00 (alen<Int> (opt_get1 $Snap.unit a2@59@00))))
      (and
        (= (Seq_length result@62@00) (- to@61@00 from@60@00))
        (forall ((i1 Int)) (!
          (implies
            (and (<= 0 i1) (< i1 (- to@61@00 from@60@00)))
            (=
              (Seq_index result@62@00 i1)
              ($FVF.lookup_int (sm@139@00 s@$ a2@59@00 from@60@00 to@61@00) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit a2@59@00) (+ i1 from@60@00)))))
          :pattern ((Seq_index result@62@00 i1))
          ))
        (forall ((i1 Int)) (!
          (implies
            (and (<= from@60@00 i1) (< i1 to@61@00))
            (=
              ($FVF.lookup_int (sm@139@00 s@$ a2@59@00 from@60@00 to@61@00) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit a2@59@00) i1))
              (Seq_index result@62@00 (- i1 from@60@00))))
          :pattern (($FVF.lookup_int (sm@139@00 s@$ a2@59@00 from@60@00 to@61@00) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit a2@59@00) i1)))
          ))))))
  :pattern ((unknown%limited s@$ a2@59@00 from@60@00 to@61@00))
  )))
(assert (forall ((s@$ $Snap) (this@63@00 $Ref) (G@64@00 Seq<Seq<Int>>) (Gf@65@00 Seq<Seq<Int>>) (V@66@00 Int) (s@67@00 Int) (t@68@00 Int) (P@69@00 Seq<Int>)) (!
  (=
    (AugPath%limited s@$ this@63@00 G@64@00 Gf@65@00 V@66@00 s@67@00 t@68@00 P@69@00)
    (AugPath s@$ this@63@00 G@64@00 Gf@65@00 V@66@00 s@67@00 t@68@00 P@69@00))
  :pattern ((AugPath s@$ this@63@00 G@64@00 Gf@65@00 V@66@00 s@67@00 t@68@00 P@69@00))
  )))
(assert (forall ((s@$ $Snap) (this@63@00 $Ref) (G@64@00 Seq<Seq<Int>>) (Gf@65@00 Seq<Seq<Int>>) (V@66@00 Int) (s@67@00 Int) (t@68@00 Int) (P@69@00 Seq<Int>)) (!
  (AugPath%stateless this@63@00 G@64@00 Gf@65@00 V@66@00 s@67@00 t@68@00 P@69@00)
  :pattern ((AugPath%limited s@$ this@63@00 G@64@00 Gf@65@00 V@66@00 s@67@00 t@68@00 P@69@00))
  )))
(assert (forall ((s@$ $Snap) (this@63@00 $Ref) (G@64@00 Seq<Seq<Int>>) (Gf@65@00 Seq<Seq<Int>>) (V@66@00 Int) (s@67@00 Int) (t@68@00 Int) (P@69@00 Seq<Int>)) (!
  (implies
    (and
      (not (= this@63@00 $Ref.null))
      (SquareIntMatrix $Snap.unit this@63@00 G@64@00 V@66@00)
      (SquareIntMatrix $Snap.unit this@63@00 Gf@65@00 V@66@00)
      (FlowNetwork $Snap.unit this@63@00 G@64@00 V@66@00 s@67@00 t@68@00)
      (FlowNetwork $Snap.unit this@63@00 Gf@65@00 V@66@00 s@67@00 t@68@00)
      (ValidFlow ($Snap.combine
        $Snap.unit
        ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) this@63@00 G@64@00 Gf@65@00 V@66@00 s@67@00 t@68@00))
    (=
      (AugPath s@$ this@63@00 G@64@00 Gf@65@00 V@66@00 s@67@00 t@68@00 P@69@00)
      (and
        (and
          (implies
            (and
              (and
                (and (and (<= 0 s@67@00) (< s@67@00 V@66@00)) (<= 0 t@68@00))
                (< t@68@00 V@66@00))
              (< 1 (Seq_length P@69@00)))
            (not
              (=
                (Seq_index P@69@00 0)
                (Seq_index P@69@00 (- (Seq_length P@69@00) 1)))))
          (implies
            (and
              (and
                (and (and (<= 0 s@67@00) (< s@67@00 V@66@00)) (<= 0 t@68@00))
                (< t@68@00 V@66@00))
              (< 1 (Seq_length P@69@00)))
            (valid_graph_vertices1 $Snap.unit this@63@00 P@69@00 V@66@00)))
        (implies
          (and
            (and
              (and (and (<= 0 s@67@00) (< s@67@00 V@66@00)) (<= 0 t@68@00))
              (< t@68@00 V@66@00))
            (< 1 (Seq_length P@69@00)))
          (forall ((j Int)) (!
            (implies
              (and (<= 0 j) (< j (- (Seq_length P@69@00) 1)))
              (<
                0
                (Seq_index
                  (Seq_index Gf@65@00 (Seq_index P@69@00 j))
                  (Seq_index P@69@00 (+ j 1)))))
            :pattern ((Seq_index Gf@65@00 (Seq_index P@69@00 j)))
            ))))))
  :pattern ((AugPath s@$ this@63@00 G@64@00 Gf@65@00 V@66@00 s@67@00 t@68@00 P@69@00))
  )))
(assert (forall ((s@$ $Snap) (opt1@71@00 option<any>)) (!
  (= (opt_get%limited s@$ opt1@71@00) (opt_get s@$ opt1@71@00))
  :pattern ((opt_get s@$ opt1@71@00))
  )))
(assert (forall ((s@$ $Snap) (opt1@71@00 option<any>)) (!
  (opt_get%stateless opt1@71@00)
  :pattern ((opt_get%limited s@$ opt1@71@00))
  )))
(assert (forall ((s@$ $Snap) (opt1@71@00 option<any>)) (!
  (let ((result@72@00 (opt_get%limited s@$ opt1@71@00))) (implies
    (not (= opt1@71@00 (as None<option<any>>  option<any>)))
    (= (some<option<any>> result@72@00) opt1@71@00)))
  :pattern ((opt_get%limited s@$ opt1@71@00))
  )))
(assert (forall ((s@$ $Snap) (opt1@71@00 option<any>)) (!
  (implies
    (not (= opt1@71@00 (as None<option<any>>  option<any>)))
    (= (opt_get s@$ opt1@71@00) (option_get<any> opt1@71@00)))
  :pattern ((opt_get s@$ opt1@71@00))
  )))
(assert (forall ((s@$ $Snap) (t@77@00 any)) (!
  (= (as_any%limited s@$ t@77@00) (as_any s@$ t@77@00))
  :pattern ((as_any s@$ t@77@00))
  )))
(assert (forall ((s@$ $Snap) (t@77@00 any)) (!
  (as_any%stateless t@77@00)
  :pattern ((as_any%limited s@$ t@77@00))
  )))
(assert (forall ((s@$ $Snap) (t@77@00 any)) (!
  (let ((result@78@00 (as_any%limited s@$ t@77@00))) (=
    (any_as $Snap.unit result@78@00)
    t@77@00))
  :pattern ((as_any%limited s@$ t@77@00))
  )))
(assert (forall ((s@$ $Snap) (this@79@00 $Ref) (p@80@00 option<array>) (V@81@00 Int)) (!
  (=
    (valid_graph_vertices%limited s@$ this@79@00 p@80@00 V@81@00)
    (valid_graph_vertices s@$ this@79@00 p@80@00 V@81@00))
  :pattern ((valid_graph_vertices s@$ this@79@00 p@80@00 V@81@00))
  )))
(assert (forall ((s@$ $Snap) (this@79@00 $Ref) (p@80@00 option<array>) (V@81@00 Int)) (!
  (valid_graph_vertices%stateless this@79@00 p@80@00 V@81@00)
  :pattern ((valid_graph_vertices%limited s@$ this@79@00 p@80@00 V@81@00))
  )))
(assert (forall ((s@$ $Snap) (this@79@00 $Ref) (p@80@00 option<array>) (V@81@00 Int)) (!
  (and
    (forall ((i1@146@00 Int)) (!
      (implies
        (and (and (< i1@146@00 V@81@00) (<= 0 i1@146@00)) (< $Perm.No $k@147@00))
        (=
          (inv@148@00 s@$ this@79@00 p@80@00 V@81@00 (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit p@80@00) i1@146@00))
          i1@146@00))
      :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@80@00) i1@146@00))
      ))
    (forall ((r $Ref)) (!
      (implies
        (and
          (and
            (< (inv@148@00 s@$ this@79@00 p@80@00 V@81@00 r) V@81@00)
            (<= 0 (inv@148@00 s@$ this@79@00 p@80@00 V@81@00 r)))
          (< $Perm.No $k@147@00))
        (=
          (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@80@00) (inv@148@00 s@$ this@79@00 p@80@00 V@81@00 r))
          r))
      :pattern ((inv@148@00 s@$ this@79@00 p@80@00 V@81@00 r))
      :qid |int-fctOfInv|))
    (forall ((r $Ref)) (!
      (implies
        (ite
          (and
            (< (inv@148@00 s@$ this@79@00 p@80@00 V@81@00 r) V@81@00)
            (<= 0 (inv@148@00 s@$ this@79@00 p@80@00 V@81@00 r)))
          (< $Perm.No $k@147@00)
          false)
        (=
          ($FVF.lookup_int (sm@149@00 s@$ this@79@00 p@80@00 V@81@00) r)
          ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second s@$)))) r)))
      :pattern (($FVF.lookup_int (sm@149@00 s@$ this@79@00 p@80@00 V@81@00) r))
      :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second s@$)))) r))
      :qid |qp.fvfValDef7|))
    (forall ((r $Ref)) (!
      ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second s@$)))) r) r)
      :pattern (($FVF.lookup_int (sm@149@00 s@$ this@79@00 p@80@00 V@81@00) r))
      :qid |qp.fvfResTrgDef8|))
    ($Perm.isReadVar $k@147@00 $Perm.Write)
    (implies
      (and
        (not (= this@79@00 $Ref.null))
        (not (= p@80@00 (as None<option<array>>  option<array>)))
        (= (alen<Int> (opt_get1 $Snap.unit p@80@00)) V@81@00))
      (=
        (valid_graph_vertices s@$ this@79@00 p@80@00 V@81@00)
        (and
          (forall ((unknown1 Int)) (!
            (implies
              (and
                (<= 0 unknown1)
                (< unknown1 (alen<Int> (opt_get1 $Snap.unit p@80@00))))
              (<=
                0
                ($FVF.lookup_int (sm@149@00 s@$ this@79@00 p@80@00 V@81@00) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit p@80@00) unknown1))))
            :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@80@00) unknown1))
            ))
          (forall ((unknown1 Int)) (!
            (implies
              (and
                (<= 0 unknown1)
                (< unknown1 (alen<Int> (opt_get1 $Snap.unit p@80@00))))
              (<
                ($FVF.lookup_int (sm@149@00 s@$ this@79@00 p@80@00 V@81@00) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit p@80@00) unknown1))
                V@81@00))
            :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@80@00) unknown1))
            ))))))
  :pattern ((valid_graph_vertices s@$ this@79@00 p@80@00 V@81@00))
  )))
(assert (forall ((s@$ $Snap) (type1@83@00 $Ref)) (!
  (= (type%limited s@$ type1@83@00) (type s@$ type1@83@00))
  :pattern ((type s@$ type1@83@00))
  )))
(assert (forall ((s@$ $Snap) (type1@83@00 $Ref)) (!
  (type%stateless type1@83@00)
  :pattern ((type%limited s@$ type1@83@00))
  )))
(assert (forall ((s@$ $Snap) (type1@83@00 $Ref)) (!
  (let ((result@84@00 (type%limited s@$ type1@83@00))) (and
    (<= 0 result@84@00)
    (< result@84@00 3)
    (implies (= type1@83@00 $Ref.null) (= result@84@00 0))
    (implies (not (= type1@83@00 $Ref.null)) (not (= result@84@00 0)))))
  :pattern ((type%limited s@$ type1@83@00))
  )))
(assert (forall ((s@$ $Snap) (subtype1@85@00 Int) (subtype2@86@00 Int)) (!
  (=
    (subtype%limited s@$ subtype1@85@00 subtype2@86@00)
    (subtype s@$ subtype1@85@00 subtype2@86@00))
  :pattern ((subtype s@$ subtype1@85@00 subtype2@86@00))
  )))
(assert (forall ((s@$ $Snap) (subtype1@85@00 Int) (subtype2@86@00 Int)) (!
  (subtype%stateless subtype1@85@00 subtype2@86@00)
  :pattern ((subtype%limited s@$ subtype1@85@00 subtype2@86@00))
  )))
(assert (forall ((s@$ $Snap) (subtype1@85@00 Int) (subtype2@86@00 Int)) (!
  (implies
    (and
      (<= 0 subtype1@85@00)
      (< subtype1@85@00 3)
      (<= 0 subtype2@86@00)
      (<= subtype2@86@00 2))
    (=
      (subtype s@$ subtype1@85@00 subtype2@86@00)
      (and
        (implies (= subtype1@85@00 2) (= subtype2@86@00 2))
        (implies (= subtype1@85@00 1) (= subtype2@86@00 1)))))
  :pattern ((subtype s@$ subtype1@85@00 subtype2@86@00))
  )))
(assert (forall ((s@$ $Snap) (this@88@00 $Ref) (a2@89@00 option<array>) (V@90@00 Int)) (!
  (Seq_equal
    (matrixValues%limited s@$ this@88@00 a2@89@00 V@90@00)
    (matrixValues s@$ this@88@00 a2@89@00 V@90@00))
  :pattern ((matrixValues s@$ this@88@00 a2@89@00 V@90@00))
  )))
(assert (forall ((s@$ $Snap) (this@88@00 $Ref) (a2@89@00 option<array>) (V@90@00 Int)) (!
  (matrixValues%stateless this@88@00 a2@89@00 V@90@00)
  :pattern ((matrixValues%limited s@$ this@88@00 a2@89@00 V@90@00))
  )))
(assert (forall ((s@$ $Snap) (this@88@00 $Ref) (a2@89@00 option<array>) (V@90@00 Int)) (!
  (let ((result@91@00 (matrixValues%limited s@$ this@88@00 a2@89@00 V@90@00))) (and
    (forall ((i1@153@00 Int)) (!
      (implies
        (and (and (< i1@153@00 V@90@00) (<= 0 i1@153@00)) (< $Perm.No $k@154@00))
        (=
          (inv@155@00 s@$ this@88@00 a2@89@00 V@90@00 (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1@153@00))
          i1@153@00))
      :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1@153@00))
      ))
    (forall ((r $Ref)) (!
      (implies
        (and
          (and
            (< (inv@155@00 s@$ this@88@00 a2@89@00 V@90@00 r) V@90@00)
            (<= 0 (inv@155@00 s@$ this@88@00 a2@89@00 V@90@00 r)))
          (< $Perm.No $k@154@00))
        (=
          (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit a2@89@00) (inv@155@00 s@$ this@88@00 a2@89@00 V@90@00 r))
          r))
      :pattern ((inv@155@00 s@$ this@88@00 a2@89@00 V@90@00 r))
      :qid |option$array$-fctOfInv|))
    (forall ((i1@161@00 Int) (j@162@00 Int)) (!
      (implies
        (and
          (and
            (and
              (and (< j@162@00 V@90@00) (<= 0 j@162@00))
              (< i1@161@00 V@90@00))
            (<= 0 i1@161@00))
          (< $Perm.No $k@163@00))
        (and
          (=
            (inv@164@00 s@$ this@88@00 a2@89@00 V@90@00 (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@156@00 s@$ this@88@00 a2@89@00 V@90@00) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1@161@00))) j@162@00))
            i1@161@00)
          (=
            (inv@165@00 s@$ this@88@00 a2@89@00 V@90@00 (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@156@00 s@$ this@88@00 a2@89@00 V@90@00) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1@161@00))) j@162@00))
            j@162@00)))
      :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@156@00 s@$ this@88@00 a2@89@00 V@90@00) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1@161@00))) j@162@00))
      ))
    (forall ((r $Ref)) (!
      (implies
        (and
          (and
            (and
              (and
                (< (inv@165@00 s@$ this@88@00 a2@89@00 V@90@00 r) V@90@00)
                (<= 0 (inv@165@00 s@$ this@88@00 a2@89@00 V@90@00 r)))
              (< (inv@164@00 s@$ this@88@00 a2@89@00 V@90@00 r) V@90@00))
            (<= 0 (inv@164@00 s@$ this@88@00 a2@89@00 V@90@00 r)))
          (< $Perm.No $k@163@00))
        (=
          (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@156@00 s@$ this@88@00 a2@89@00 V@90@00) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit a2@89@00) (inv@164@00 s@$ this@88@00 a2@89@00 V@90@00 r)))) (inv@165@00 s@$ this@88@00 a2@89@00 V@90@00 r))
          r))
      :pattern ((inv@164@00 s@$ this@88@00 a2@89@00 V@90@00 r))
      :pattern ((inv@165@00 s@$ this@88@00 a2@89@00 V@90@00 r))
      :qid |int-fctOfInv|))
    (forall ((r $Ref)) (!
      (implies
        (ite
          (and
            (< (inv@155@00 s@$ this@88@00 a2@89@00 V@90@00 r) V@90@00)
            (<= 0 (inv@155@00 s@$ this@88@00 a2@89@00 V@90@00 r)))
          (< $Perm.No $k@154@00)
          false)
        (=
          ($FVF.lookup_option$array$ (sm@156@00 s@$ this@88@00 a2@89@00 V@90@00) r)
          ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r)))
      :pattern (($FVF.lookup_option$array$ (sm@156@00 s@$ this@88@00 a2@89@00 V@90@00) r))
      :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r))
      :qid |qp.fvfValDef9|))
    (forall ((r $Ref)) (!
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r)
      :pattern (($FVF.lookup_option$array$ (sm@156@00 s@$ this@88@00 a2@89@00 V@90@00) r))
      :qid |qp.fvfResTrgDef10|))
    (forall ((r $Ref)) (!
      ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$)))))))) r) r)
      :pattern (($FVF.lookup_int (sm@173@00 s@$ this@88@00 a2@89@00 V@90@00) r))
      :qid |qp.fvfResTrgDef15|))
    ($Perm.isReadVar $k@154@00 $Perm.Write)
    ($Perm.isReadVar $k@163@00 $Perm.Write)
    ($Perm.isReadVar $k@170@00 $Perm.Write)
    (implies
      (and
        (not (= this@88@00 $Ref.null))
        (not (= a2@89@00 (as None<option<array>>  option<array>)))
        (= (alen<Int> (opt_get1 $Snap.unit a2@89@00)) V@90@00)
        (forall ((i1 Int)) (!
          (implies
            (and (<= 0 i1) (< i1 V@90@00))
            (not
              (=
                ($FVF.lookup_option$array$ (sm@156@00 s@$ this@88@00 a2@89@00 V@90@00) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1))
                (as None<option<array>>  option<array>))))
          :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1))
          ))
        (forall ((i1 Int)) (!
          (implies
            (and (<= 0 i1) (< i1 V@90@00))
            (=
              (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@156@00 s@$ this@88@00 a2@89@00 V@90@00) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1))))
              V@90@00))
          :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@156@00 s@$ this@88@00 a2@89@00 V@90@00) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1)))))
          ))
        (forall ((i1 Int)) (!
          (forall ((i2 Int)) (!
            (implies
              (and
                (and
                  (and (and (<= 0 i1) (< i1 V@90@00)) (<= 0 i2))
                  (< i2 V@90@00))
                (=
                  ($FVF.lookup_option$array$ (sm@156@00 s@$ this@88@00 a2@89@00 V@90@00) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1))
                  ($FVF.lookup_option$array$ (sm@156@00 s@$ this@88@00 a2@89@00 V@90@00) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i2))))
              (= i1 i2))
            :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i2))
            ))
          :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1))
          )))
      (and
        (SquareIntMatrix $Snap.unit this@88@00 result@91@00 V@90@00)
        (forall ((i1 Int)) (!
          (implies
            (and (<= 0 i1) (< i1 V@90@00))
            (Seq_equal
              (Seq_index result@91@00 i1)
              (unknown_ ($Snap.combine
                $Snap.unit
                ($Snap.combine
                  $Snap.unit
                  ($Snap.combine
                    $Snap.unit
                    ($Snap.combine
                      $Snap.unit
                      ($SortWrappers.$FVF<Int>To$Snap (sm@173@00 s@$ this@88@00 a2@89@00 V@90@00)))))) ($FVF.lookup_option$array$ (sm@156@00 s@$ this@88@00 a2@89@00 V@90@00) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1)) 0 (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@156@00 s@$ this@88@00 a2@89@00 V@90@00) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1)))))))
          :pattern ((Seq_index result@91@00 i1))
          :pattern ((unknown%limited ($Snap.combine
            $Snap.unit
            ($Snap.combine
              $Snap.unit
              ($Snap.combine
                $Snap.unit
                ($Snap.combine
                  $Snap.unit
                  ($SortWrappers.$FVF<Int>To$Snap (sm@173@00 s@$ this@88@00 a2@89@00 V@90@00)))))) ($FVF.lookup_option$array$ (sm@156@00 s@$ this@88@00 a2@89@00 V@90@00) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1)) 0 (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@156@00 s@$ this@88@00 a2@89@00 V@90@00) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit a2@89@00) i1))))))
          ))))))
  :pattern ((matrixValues%limited s@$ this@88@00 a2@89@00 V@90@00))
  )))
(assert (forall ((s@$ $Snap) (this@92@00 $Ref) (G@93@00 Seq<Seq<Int>>) (Gf@94@00 Seq<Seq<Int>>) (V@95@00 Int) (s@96@00 Int) (t@97@00 Int)) (!
  (=
    (ExAugPath%limited s@$ this@92@00 G@93@00 Gf@94@00 V@95@00 s@96@00 t@97@00)
    (ExAugPath s@$ this@92@00 G@93@00 Gf@94@00 V@95@00 s@96@00 t@97@00))
  :pattern ((ExAugPath s@$ this@92@00 G@93@00 Gf@94@00 V@95@00 s@96@00 t@97@00))
  )))
(assert (forall ((s@$ $Snap) (this@92@00 $Ref) (G@93@00 Seq<Seq<Int>>) (Gf@94@00 Seq<Seq<Int>>) (V@95@00 Int) (s@96@00 Int) (t@97@00 Int)) (!
  (ExAugPath%stateless this@92@00 G@93@00 Gf@94@00 V@95@00 s@96@00 t@97@00)
  :pattern ((ExAugPath%limited s@$ this@92@00 G@93@00 Gf@94@00 V@95@00 s@96@00 t@97@00))
  )))
(assert (forall ((s@$ $Snap) (this@92@00 $Ref) (G@93@00 Seq<Seq<Int>>) (Gf@94@00 Seq<Seq<Int>>) (V@95@00 Int) (s@96@00 Int) (t@97@00 Int)) (!
  (implies
    (and
      (not (= this@92@00 $Ref.null))
      (SquareIntMatrix $Snap.unit this@92@00 G@93@00 V@95@00)
      (SquareIntMatrix $Snap.unit this@92@00 Gf@94@00 V@95@00)
      (FlowNetwork $Snap.unit this@92@00 G@93@00 V@95@00 s@96@00 t@97@00)
      (FlowNetwork $Snap.unit this@92@00 Gf@94@00 V@95@00 s@96@00 t@97@00)
      (ValidFlow ($Snap.combine
        $Snap.unit
        ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) this@92@00 G@93@00 Gf@94@00 V@95@00 s@96@00 t@97@00))
    (=
      (ExAugPath s@$ this@92@00 G@93@00 Gf@94@00 V@95@00 s@96@00 t@97@00)
      (exists ((P Seq<Int>)) (!
        (and
          (AugPath ($Snap.combine
            $Snap.unit
            ($Snap.combine
              $Snap.unit
              ($Snap.combine
                $Snap.unit
                ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))))) this@92@00 G@93@00 Gf@94@00 V@95@00 s@96@00 t@97@00 P)
          (<= (Seq_length P) V@95@00))
        :pattern ((AugPath%limited ($Snap.combine
          $Snap.unit
          ($Snap.combine
            $Snap.unit
            ($Snap.combine
              $Snap.unit
              ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))))) this@92@00 G@93@00 Gf@94@00 V@95@00 s@96@00 t@97@00 P))
        :pattern ((Seq_length P))
        ))))
  :pattern ((ExAugPath s@$ this@92@00 G@93@00 Gf@94@00 V@95@00 s@96@00 t@97@00))
  )))
(assert (forall ((s@$ $Snap) (opt1@99@00 option<any>) (alt@100@00 any)) (!
  (=
    (opt_or_else%limited s@$ opt1@99@00 alt@100@00)
    (opt_or_else s@$ opt1@99@00 alt@100@00))
  :pattern ((opt_or_else s@$ opt1@99@00 alt@100@00))
  )))
(assert (forall ((s@$ $Snap) (opt1@99@00 option<any>) (alt@100@00 any)) (!
  (opt_or_else%stateless opt1@99@00 alt@100@00)
  :pattern ((opt_or_else%limited s@$ opt1@99@00 alt@100@00))
  )))
(assert (forall ((s@$ $Snap) (opt1@99@00 option<any>) (alt@100@00 any)) (!
  (let ((result@101@00 (opt_or_else%limited s@$ opt1@99@00 alt@100@00))) (and
    (implies
      (= opt1@99@00 (as None<option<any>>  option<any>))
      (= result@101@00 alt@100@00))
    (implies
      (not (= opt1@99@00 (as None<option<any>>  option<any>)))
      (= result@101@00 (opt_get $Snap.unit opt1@99@00)))))
  :pattern ((opt_or_else%limited s@$ opt1@99@00 alt@100@00))
  )))
(assert (forall ((s@$ $Snap) (opt1@99@00 option<any>) (alt@100@00 any)) (!
  (=
    (opt_or_else s@$ opt1@99@00 alt@100@00)
    (ite
      (= opt1@99@00 (as None<option<any>>  option<any>))
      alt@100@00
      (opt_get $Snap.unit opt1@99@00)))
  :pattern ((opt_or_else s@$ opt1@99@00 alt@100@00))
  )))
(assert (forall ((s@$ $Snap) (this@102@00 $Ref) (G@103@00 option<array>) (V@104@00 Int) (s@105@00 Int) (t@106@00 Int)) (!
  (=
    (FlowNetwork1%limited s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00)
    (FlowNetwork1 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00))
  :pattern ((FlowNetwork1 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00))
  )))
(assert (forall ((s@$ $Snap) (this@102@00 $Ref) (G@103@00 option<array>) (V@104@00 Int) (s@105@00 Int) (t@106@00 Int)) (!
  (FlowNetwork1%stateless this@102@00 G@103@00 V@104@00 s@105@00 t@106@00)
  :pattern ((FlowNetwork1%limited s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00))
  )))
(assert (forall ((s@$ $Snap) (this@102@00 $Ref) (G@103@00 option<array>) (V@104@00 Int) (s@105@00 Int) (t@106@00 Int)) (!
  (and
    (forall ((i1@176@00 Int)) (!
      (implies
        (and
          (and (< i1@176@00 V@104@00) (<= 0 i1@176@00))
          (< $Perm.No $k@177@00))
        (=
          (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@176@00))
          i1@176@00))
      :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@176@00))
      ))
    (forall ((r $Ref)) (!
      (implies
        (and
          (and
            (<
              (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
              V@104@00)
            (<=
              0
              (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
          (< $Perm.No $k@177@00))
        (=
          (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@103@00) (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
          r))
      :pattern ((inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
      :qid |option$array$-fctOfInv|))
    (forall ((i1@184@00 Int) (j@185@00 Int)) (!
      (implies
        (and
          (and
            (and
              (and (< j@185@00 V@104@00) (<= 0 j@185@00))
              (< i1@184@00 V@104@00))
            (<= 0 i1@184@00))
          (< $Perm.No $k@186@00))
        (and
          (=
            (inv@187@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@179@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@184@00))) j@185@00))
            i1@184@00)
          (=
            (inv@188@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@179@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@184@00))) j@185@00))
            j@185@00)))
      :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@179@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@184@00))) j@185@00))
      ))
    (forall ((r $Ref)) (!
      (implies
        (and
          (and
            (and
              (and
                (<
                  (inv@188@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                  V@104@00)
                (<=
                  0
                  (inv@188@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
              (<
                (inv@187@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                V@104@00))
            (<=
              0
              (inv@187@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
          (< $Perm.No $k@186@00))
        (=
          (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@179@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@103@00) (inv@187@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))) (inv@188@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
          r))
      :pattern ((inv@187@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
      :pattern ((inv@188@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
      :qid |int-fctOfInv|))
    (forall ((i1@190@00 Int)) (!
      (implies
        (and
          (and (< i1@190@00 V@104@00) (<= 0 i1@190@00))
          (< $Perm.No $k@191@00))
        (=
          (inv@192@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@190@00))
          i1@190@00))
      :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@190@00))
      :qid |option$array$-invOfFct|))
    (forall ((r $Ref)) (!
      (implies
        (and
          (and
            (<
              (inv@192@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
              V@104@00)
            (<=
              0
              (inv@192@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
          (< $Perm.No $k@191@00))
        (=
          (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@103@00) (inv@192@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
          r))
      :pattern ((inv@192@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
      :qid |option$array$-fctOfInv|))
    (forall ((i1@207@00 Int) (j@208@00 Int)) (!
      (implies
        (and
          (and
            (and
              (and (< j@208@00 V@104@00) (<= 0 j@208@00))
              (< i1@207@00 V@104@00))
            (<= 0 i1@207@00))
          (< $Perm.No $k@209@00))
        (and
          (=
            (inv@212@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@210@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@207@00))) j@208@00))
            i1@207@00)
          (=
            (inv@213@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@210@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@207@00))) j@208@00))
            j@208@00)))
      :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@210@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1@207@00))) j@208@00))
      :qid |int-invOfFct|))
    (forall ((r $Ref)) (!
      (implies
        (and
          (and
            (and
              (and
                (<
                  (inv@213@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                  V@104@00)
                (<=
                  0
                  (inv@213@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
              (<
                (inv@212@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                V@104@00))
            (<=
              0
              (inv@212@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
          (< $Perm.No $k@209@00))
        (=
          (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@210@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@103@00) (inv@212@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))) (inv@213@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
          r))
      :pattern ((inv@212@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
      :pattern ((inv@213@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r))
      :qid |int-fctOfInv|))
    (forall ((r $Ref)) (!
      (implies
        (ite
          (and
            (<
              (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
              V@104@00)
            (<=
              0
              (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
          (< $Perm.No $k@177@00)
          false)
        (=
          ($FVF.lookup_option$array$ (sm@179@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r)
          ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r)))
      :pattern (($FVF.lookup_option$array$ (sm@179@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
      :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r))
      :qid |qp.fvfValDef17|))
    (forall ((r $Ref)) (!
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r)
      :pattern (($FVF.lookup_option$array$ (sm@179@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
      :qid |qp.fvfResTrgDef18|))
    (forall ((r $Ref)) (!
      (iff
        (Set_in r ($FVF.domain_option$array$ (sm@194@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00)))
        (and
          (and
            (<
              (inv@192@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
              V@104@00)
            (<=
              0
              (inv@192@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
          (< $Perm.No $k@191@00)))
      :pattern ((Set_in r ($FVF.domain_option$array$ (sm@194@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00))))
      :qid |qp.fvfDomDef24|))
    (forall ((r $Ref)) (!
      (implies
        (and
          (and
            (and
              (<
                (inv@192@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                V@104@00)
              (<=
                0
                (inv@192@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
            (< $Perm.No $k@191@00))
          (ite
            (and
              (<
                (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                V@104@00)
              (<=
                0
                (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
            (< $Perm.No $k@177@00)
            false))
        (=
          ($FVF.lookup_option$array$ (sm@194@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r)
          ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r)))
      :pattern (($FVF.lookup_option$array$ (sm@194@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
      :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r))
      :qid |qp.fvfValDef22|))
    (forall ((r $Ref)) (!
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r)
      :pattern (($FVF.lookup_option$array$ (sm@194@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
      :qid |qp.fvfResTrgDef23|))
    (forall ((r $Ref)) (!
      (implies
        (ite
          (and
            (<
              (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
              V@104@00)
            (<=
              0
              (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
          (< $Perm.No $k@177@00)
          false)
        (=
          ($FVF.lookup_option$array$ (sm@196@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r)
          ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r)))
      :pattern (($FVF.lookup_option$array$ (sm@196@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
      :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r))
      :qid |qp.fvfValDef25|))
    (forall ((r $Ref)) (!
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r)
      :pattern (($FVF.lookup_option$array$ (sm@196@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
      :qid |qp.fvfResTrgDef26|))
    (forall ((r $Ref)) (!
      (implies
        (ite
          (and
            (<
              (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
              V@104@00)
            (<=
              0
              (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
          (< $Perm.No $k@177@00)
          false)
        (=
          ($FVF.lookup_option$array$ (sm@199@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r)
          ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r)))
      :pattern (($FVF.lookup_option$array$ (sm@199@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
      :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r))
      :qid |qp.fvfValDef29|))
    (forall ((r $Ref)) (!
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r)
      :pattern (($FVF.lookup_option$array$ (sm@199@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
      :qid |qp.fvfResTrgDef30|))
    (forall ((r $Ref)) (!
      (implies
        (ite
          (and
            (<
              (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
              V@104@00)
            (<=
              0
              (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
          (< $Perm.No $k@177@00)
          false)
        (=
          ($FVF.lookup_option$array$ (sm@203@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r)
          ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r)))
      :pattern (($FVF.lookup_option$array$ (sm@203@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
      :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r))
      :qid |qp.fvfValDef33|))
    (forall ((r $Ref)) (!
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r)
      :pattern (($FVF.lookup_option$array$ (sm@203@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
      :qid |qp.fvfResTrgDef34|))
    (forall ((r $Ref)) (!
      (implies
        (ite
          (and
            (<
              (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
              V@104@00)
            (<=
              0
              (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
          (< $Perm.No $k@177@00)
          false)
        (=
          ($FVF.lookup_option$array$ (sm@205@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r)
          ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r)))
      :pattern (($FVF.lookup_option$array$ (sm@205@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
      :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r))
      :qid |qp.fvfValDef37|))
    (forall ((r $Ref)) (!
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r)
      :pattern (($FVF.lookup_option$array$ (sm@205@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
      :qid |qp.fvfResTrgDef38|))
    (forall ((r $Ref)) (!
      (implies
        (ite
          (and
            (<
              (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
              V@104@00)
            (<=
              0
              (inv@178@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
          (< $Perm.No $k@177@00)
          false)
        (=
          ($FVF.lookup_option$array$ (sm@210@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r)
          ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r)))
      :pattern (($FVF.lookup_option$array$ (sm@210@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
      :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r))
      :qid |qp.fvfValDef41|))
    (forall ((r $Ref)) (!
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second s@$))))) r) r)
      :pattern (($FVF.lookup_option$array$ (sm@210@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
      :qid |qp.fvfResTrgDef42|))
    (forall ((r $Ref)) (!
      (iff
        (Set_in r ($FVF.domain_int (sm@215@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00)))
        (and
          (and
            (and
              (and
                (<
                  (inv@213@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                  V@104@00)
                (<=
                  0
                  (inv@213@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
              (<
                (inv@212@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                V@104@00))
            (<=
              0
              (inv@212@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
          (< $Perm.No $k@209@00)))
      :pattern ((Set_in r ($FVF.domain_int (sm@215@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00))))
      :qid |qp.fvfDomDef48|))
    (forall ((r $Ref)) (!
      (implies
        (and
          (and
            (and
              (and
                (and
                  (<
                    (inv@213@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                    V@104@00)
                  (<=
                    0
                    (inv@213@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
                (<
                  (inv@212@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                  V@104@00))
              (<=
                0
                (inv@212@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
            (< $Perm.No $k@209@00))
          (ite
            (and
              (and
                (and
                  (<
                    (inv@188@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                    V@104@00)
                  (<=
                    0
                    (inv@188@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
                (<
                  (inv@187@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)
                  V@104@00))
              (<=
                0
                (inv@187@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00 r)))
            (< $Perm.No $k@186@00)
            false))
        (=
          ($FVF.lookup_int (sm@215@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r)
          ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$)))))))) r)))
      :pattern (($FVF.lookup_int (sm@215@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
      :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$)))))))) r))
      :qid |qp.fvfValDef46|))
    (forall ((r $Ref)) (!
      ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$)))))))) r) r)
      :pattern (($FVF.lookup_int (sm@215@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) r))
      :qid |qp.fvfResTrgDef47|))
    ($Perm.isReadVar $k@177@00 $Perm.Write)
    ($Perm.isReadVar $k@186@00 $Perm.Write)
    ($Perm.isReadVar $k@191@00 $Perm.Write)
    ($Perm.isReadVar $k@209@00 $Perm.Write)
    (implies
      (and
        (not (= this@102@00 $Ref.null))
        (not (= G@103@00 (as None<option<array>>  option<array>)))
        (= (alen<Int> (opt_get1 $Snap.unit G@103@00)) V@104@00)
        (forall ((i1 Int)) (!
          (implies
            (and (<= 0 i1) (< i1 V@104@00))
            (not
              (=
                ($FVF.lookup_option$array$ (sm@179@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1))
                (as None<option<array>>  option<array>))))
          :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1))
          ))
        (forall ((i1 Int)) (!
          (implies
            (and (<= 0 i1) (< i1 V@104@00))
            (=
              (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@179@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1))))
              V@104@00))
          :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (sm@179@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1)))))
          ))
        (forall ((i1 Int)) (!
          (forall ((i2 Int)) (!
            (implies
              (and
                (and
                  (and (and (<= 0 i1) (< i1 V@104@00)) (<= 0 i2))
                  (< i2 V@104@00))
                (=
                  ($FVF.lookup_option$array$ (sm@179@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1))
                  ($FVF.lookup_option$array$ (sm@179@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit G@103@00) i2))))
              (= i1 i2))
            :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@103@00) i2))
            ))
          :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@103@00) i1))
          )))
      (=
        (FlowNetwork1 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00)
        (and
          (and
            (and
              (and (and (<= 0 s@105@00) (< s@105@00 V@104@00)) (<= 0 t@106@00))
              (< t@106@00 V@104@00))
            (SquareIntMatrix1 ($Snap.combine
              $Snap.unit
              ($Snap.combine
                $Snap.unit
                ($Snap.combine
                  $Snap.unit
                  ($Snap.combine
                    ($SortWrappers.$FVF<option<array>>To$Snap (sm@194@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00))
                    ($Snap.combine
                      $Snap.unit
                      ($Snap.combine
                        $Snap.unit
                        ($Snap.combine
                          $Snap.unit
                          ($SortWrappers.$FVF<Int>To$Snap (sm@215@00 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00))))))))) this@102@00 G@103@00 V@104@00))
          (NonNegativeCapacities1 ($Snap.combine $Snap.unit $Snap.unit) this@102@00 G@103@00 V@104@00)))))
  :pattern ((FlowNetwork1 s@$ this@102@00 G@103@00 V@104@00 s@105@00 t@106@00))
  )))
; End function- and predicate-related preamble
; ------------------------------------------------------------
; ---------- hasAugmentingPath ----------
(declare-const this@0@03 $Ref)
(declare-const tid@1@03 Int)
(declare-const Gf@2@03 option<array>)
(declare-const V@3@03 Int)
(declare-const s@4@03 Int)
(declare-const t@5@03 Int)
(declare-const p@6@03 option<array>)
(declare-const exc@7@03 $Ref)
(declare-const res@8@03 Bool)
(declare-const this@9@03 $Ref)
(declare-const tid@10@03 Int)
(declare-const Gf@11@03 option<array>)
(declare-const V@12@03 Int)
(declare-const s@13@03 Int)
(declare-const t@14@03 Int)
(declare-const p@15@03 option<array>)
(declare-const exc@16@03 $Ref)
(declare-const res@17@03 Bool)
(push) ; 1
(declare-const $t@18@03 $Snap)
(assert (= $t@18@03 ($Snap.combine ($Snap.first $t@18@03) ($Snap.second $t@18@03))))
(assert (= ($Snap.first $t@18@03) $Snap.unit))
; [eval] this != null
(assert (not (= this@9@03 $Ref.null)))
(assert (=
  ($Snap.second $t@18@03)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@18@03))
    ($Snap.second ($Snap.second $t@18@03)))))
(assert (= ($Snap.first ($Snap.second $t@18@03)) $Snap.unit))
; [eval] Gf != (None(): option[array])
; [eval] (None(): option[array])
(assert (not (= Gf@11@03 (as None<option<array>>  option<array>))))
(assert (=
  ($Snap.second ($Snap.second $t@18@03))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second $t@18@03)))
    ($Snap.second ($Snap.second ($Snap.second $t@18@03))))))
(assert (= ($Snap.first ($Snap.second ($Snap.second $t@18@03))) $Snap.unit))
; [eval] alen(opt_get1(Gf)) == V
; [eval] alen(opt_get1(Gf))
; [eval] opt_get1(Gf)
(push) ; 2
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 2
; Joined path conditions
(assert (= (alen<Int> (opt_get1 $Snap.unit Gf@11@03)) V@12@03))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second $t@18@03)))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@18@03))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@03)))))))
(declare-const i1@19@03 Int)
(push) ; 2
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 3
; [then-branch: 0 | 0 <= i1@19@03 | live]
; [else-branch: 0 | !(0 <= i1@19@03) | live]
(push) ; 4
; [then-branch: 0 | 0 <= i1@19@03]
(assert (<= 0 i1@19@03))
; [eval] i1 < V
(pop) ; 4
(push) ; 4
; [else-branch: 0 | !(0 <= i1@19@03)]
(assert (not (<= 0 i1@19@03)))
(pop) ; 4
(pop) ; 3
; Joined path conditions
; Joined path conditions
(assert (and (< i1@19@03 V@12@03) (<= 0 i1@19@03)))
; [eval] aloc(opt_get1(Gf), i1)
; [eval] opt_get1(Gf)
(push) ; 3
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 3
; Joined path conditions
(push) ; 3
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 4
(assert (not (< i1@19@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs            30
;  :arith-assert-lower   5
;  :arith-assert-upper   4
;  :arith-eq-adapter     3
;  :arith-fixed-eqs      1
;  :arith-pivots         1
;  :datatype-accessor-ax 5
;  :max-generation       2
;  :max-memory           4.25
;  :memory               4.19
;  :mk-bool-var          368
;  :num-allocs           147280
;  :num-checks           1
;  :quant-instantiations 7
;  :rlimit-count         175761)
(assert (< i1@19@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03))))
(pop) ; 3
; Joined path conditions
(assert (< i1@19@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03))))
(declare-const $k@20@03 $Perm)
(assert ($Perm.isReadVar $k@20@03 $Perm.Write))
(pop) ; 2
(declare-fun inv@21@03 ($Ref) Int)
; Nested auxiliary terms: globals
(assert ($Perm.isReadVar $k@20@03 $Perm.Write))
; Nested auxiliary terms: non-globals
(assert (forall ((i1@19@03 Int)) (!
  (< i1@19@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@19@03))
  :qid |option$array$-aux|)))
(push) ; 2
(assert (not (forall ((i1@19@03 Int)) (!
  (implies
    (and (< i1@19@03 V@12@03) (<= 0 i1@19@03))
    (or (= $k@20@03 $Perm.No) (< $Perm.No $k@20@03)))
  
  ))))
(check-sat)
; unsat
(pop) ; 2
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs            32
;  :arith-assert-diseq   1
;  :arith-assert-lower   7
;  :arith-assert-upper   5
;  :arith-eq-adapter     4
;  :arith-fixed-eqs      1
;  :arith-pivots         2
;  :conflicts            1
;  :datatype-accessor-ax 6
;  :max-generation       2
;  :max-memory           4.25
;  :memory               4.20
;  :mk-bool-var          375
;  :mk-clause            2
;  :num-allocs           147775
;  :num-checks           2
;  :propagations         1
;  :quant-instantiations 7
;  :rlimit-count         176337)
; Check receiver injectivity
(push) ; 2
(assert (not (forall ((i11@19@03 Int) (i12@19@03 Int)) (!
  (implies
    (and
      (and (and (< i11@19@03 V@12@03) (<= 0 i11@19@03)) (< $Perm.No $k@20@03))
      (and (and (< i12@19@03 V@12@03) (<= 0 i12@19@03)) (< $Perm.No $k@20@03))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i11@19@03)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i12@19@03)))
    (= i11@19@03 i12@19@03))
  
  :qid |option$array$-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 2
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs            62
;  :arith-add-rows       17
;  :arith-assert-diseq   5
;  :arith-assert-lower   15
;  :arith-assert-upper   8
;  :arith-conflicts      2
;  :arith-eq-adapter     6
;  :arith-fixed-eqs      2
;  :arith-offset-eqs     1
;  :arith-pivots         10
;  :conflicts            4
;  :datatype-accessor-ax 6
;  :decisions            2
;  :del-clause           18
;  :max-generation       2
;  :max-memory           4.25
;  :memory               4.23
;  :mk-bool-var          403
;  :mk-clause            20
;  :num-allocs           148318
;  :num-checks           3
;  :propagations         21
;  :quant-instantiations 18
;  :rlimit-count         177523)
; Definitional axioms for inverse functions
(assert (forall ((i1@19@03 Int)) (!
  (implies
    (and (and (< i1@19@03 V@12@03) (<= 0 i1@19@03)) (< $Perm.No $k@20@03))
    (=
      (inv@21@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@19@03))
      i1@19@03))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@19@03))
  )))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and (< (inv@21@03 r) V@12@03) (<= 0 (inv@21@03 r)))
      (< $Perm.No $k@20@03))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) (inv@21@03 r))
      r))
  :pattern ((inv@21@03 r))
  :qid |option$array$-fctOfInv|)))
; Permissions are non-negative
(assert (forall ((i1@19@03 Int)) (!
  (<= $Perm.No $k@20@03)
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@19@03))
  :qid |option$array$-permAtLeastZero|)))
; Field permissions are at most one
(assert (forall ((i1@19@03 Int)) (!
  (<= $k@20@03 $Perm.Write)
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@19@03))
  :qid |option$array$-permAtMostOne|)))
; Permission implies non-null receiver
(assert (forall ((i1@19@03 Int)) (!
  (implies
    (and (and (< i1@19@03 V@12@03) (<= 0 i1@19@03)) (< $Perm.No $k@20@03))
    (not
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@19@03)
        $Ref.null)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@19@03))
  :qid |option$array$-permImpliesNonNull|)))
(declare-const sm@22@03 $FVF<option<array>>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@21@03 r) V@12@03) (<= 0 (inv@21@03 r)))
      (< $Perm.No $k@20@03)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@22@03  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@18@03))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@22@03  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@18@03))))) r))
  :qid |qp.fvfValDef0|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@18@03))))) r) r)
  :pattern (($FVF.lookup_option$array$ (as sm@22@03  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef1|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@21@03 r) V@12@03) (<= 0 (inv@21@03 r)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@22@03  $FVF<option<array>>) r) r))
  :pattern ((inv@21@03 r))
  )))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@03))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@03)))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@03))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@03)))))
  $Snap.unit))
; [eval] (forall i1: Int :: { aloc(opt_get1(Gf), i1) } 0 <= i1 && i1 < V ==> aloc(opt_get1(Gf), i1).option$array$ != (None(): option[array]))
(declare-const i1@23@03 Int)
(push) ; 2
; [eval] 0 <= i1 && i1 < V ==> aloc(opt_get1(Gf), i1).option$array$ != (None(): option[array])
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 3
; [then-branch: 1 | 0 <= i1@23@03 | live]
; [else-branch: 1 | !(0 <= i1@23@03) | live]
(push) ; 4
; [then-branch: 1 | 0 <= i1@23@03]
(assert (<= 0 i1@23@03))
; [eval] i1 < V
(pop) ; 4
(push) ; 4
; [else-branch: 1 | !(0 <= i1@23@03)]
(assert (not (<= 0 i1@23@03)))
(pop) ; 4
(pop) ; 3
; Joined path conditions
; Joined path conditions
(push) ; 3
; [then-branch: 2 | i1@23@03 < V@12@03 && 0 <= i1@23@03 | live]
; [else-branch: 2 | !(i1@23@03 < V@12@03 && 0 <= i1@23@03) | live]
(push) ; 4
; [then-branch: 2 | i1@23@03 < V@12@03 && 0 <= i1@23@03]
(assert (and (< i1@23@03 V@12@03) (<= 0 i1@23@03)))
; [eval] aloc(opt_get1(Gf), i1).option$array$ != (None(): option[array])
; [eval] aloc(opt_get1(Gf), i1)
; [eval] opt_get1(Gf)
(push) ; 5
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 5
; Joined path conditions
(push) ; 5
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 6
(assert (not (< i1@23@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs            69
;  :arith-add-rows       17
;  :arith-assert-diseq   5
;  :arith-assert-lower   18
;  :arith-assert-upper   10
;  :arith-conflicts      2
;  :arith-eq-adapter     7
;  :arith-fixed-eqs      3
;  :arith-offset-eqs     1
;  :arith-pivots         11
;  :conflicts            4
;  :datatype-accessor-ax 7
;  :decisions            2
;  :del-clause           18
;  :max-generation       2
;  :max-memory           4.25
;  :memory               4.24
;  :mk-bool-var          416
;  :mk-clause            20
;  :num-allocs           149620
;  :num-checks           4
;  :propagations         21
;  :quant-instantiations 18
;  :rlimit-count         179877)
(assert (< i1@23@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03))))
(pop) ; 5
; Joined path conditions
(assert (< i1@23@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@22@03  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@23@03)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@23@03)))
(push) ; 5
(assert (not (ite
  (and
    (<
      (inv@21@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@23@03))
      V@12@03)
    (<=
      0
      (inv@21@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@23@03))))
  (< $Perm.No $k@20@03)
  false)))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs            73
;  :arith-add-rows       22
;  :arith-assert-diseq   5
;  :arith-assert-lower   20
;  :arith-assert-upper   11
;  :arith-bound-prop     1
;  :arith-conflicts      3
;  :arith-eq-adapter     8
;  :arith-fixed-eqs      4
;  :arith-offset-eqs     1
;  :arith-pivots         13
;  :conflicts            5
;  :datatype-accessor-ax 7
;  :decisions            2
;  :del-clause           18
;  :max-generation       2
;  :max-memory           4.26
;  :memory               4.26
;  :mk-bool-var          433
;  :mk-clause            27
;  :num-allocs           149957
;  :num-checks           5
;  :propagations         21
;  :quant-instantiations 28
;  :rlimit-count         180545)
; [eval] (None(): option[array])
(pop) ; 4
(push) ; 4
; [else-branch: 2 | !(i1@23@03 < V@12@03 && 0 <= i1@23@03)]
(assert (not (and (< i1@23@03 V@12@03) (<= 0 i1@23@03))))
(pop) ; 4
(pop) ; 3
; Joined path conditions
(assert (implies
  (and (< i1@23@03 V@12@03) (<= 0 i1@23@03))
  (and
    (< i1@23@03 V@12@03)
    (<= 0 i1@23@03)
    (< i1@23@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@22@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@23@03)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@23@03)))))
; Joined path conditions
(pop) ; 2
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@23@03 Int)) (!
  (implies
    (and (< i1@23@03 V@12@03) (<= 0 i1@23@03))
    (and
      (< i1@23@03 V@12@03)
      (<= 0 i1@23@03)
      (< i1@23@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@22@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@23@03)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@23@03))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@23@03))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(assert (forall ((i1@23@03 Int)) (!
  (implies
    (and (< i1@23@03 V@12@03) (<= 0 i1@23@03))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@22@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@23@03))
        (as None<option<array>>  option<array>))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@23@03))
  :qid |prog.l<no position>|)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@03)))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@03))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@03)))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@03))))))
  $Snap.unit))
; [eval] (forall i1: Int :: { alen(opt_get1(aloc(opt_get1(Gf), i1).option$array$)) } 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(Gf), i1).option$array$)) == V)
(declare-const i1@24@03 Int)
(push) ; 2
; [eval] 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(Gf), i1).option$array$)) == V
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 3
; [then-branch: 3 | 0 <= i1@24@03 | live]
; [else-branch: 3 | !(0 <= i1@24@03) | live]
(push) ; 4
; [then-branch: 3 | 0 <= i1@24@03]
(assert (<= 0 i1@24@03))
; [eval] i1 < V
(pop) ; 4
(push) ; 4
; [else-branch: 3 | !(0 <= i1@24@03)]
(assert (not (<= 0 i1@24@03)))
(pop) ; 4
(pop) ; 3
; Joined path conditions
; Joined path conditions
(push) ; 3
; [then-branch: 4 | i1@24@03 < V@12@03 && 0 <= i1@24@03 | live]
; [else-branch: 4 | !(i1@24@03 < V@12@03 && 0 <= i1@24@03) | live]
(push) ; 4
; [then-branch: 4 | i1@24@03 < V@12@03 && 0 <= i1@24@03]
(assert (and (< i1@24@03 V@12@03) (<= 0 i1@24@03)))
; [eval] alen(opt_get1(aloc(opt_get1(Gf), i1).option$array$)) == V
; [eval] alen(opt_get1(aloc(opt_get1(Gf), i1).option$array$))
; [eval] opt_get1(aloc(opt_get1(Gf), i1).option$array$)
; [eval] aloc(opt_get1(Gf), i1)
; [eval] opt_get1(Gf)
(push) ; 5
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 5
; Joined path conditions
(push) ; 5
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 6
(assert (not (< i1@24@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs            80
;  :arith-add-rows       29
;  :arith-assert-diseq   5
;  :arith-assert-lower   22
;  :arith-assert-upper   13
;  :arith-bound-prop     1
;  :arith-conflicts      3
;  :arith-eq-adapter     9
;  :arith-fixed-eqs      5
;  :arith-offset-eqs     1
;  :arith-pivots         17
;  :conflicts            5
;  :datatype-accessor-ax 8
;  :decisions            2
;  :del-clause           25
;  :max-generation       2
;  :max-memory           4.26
;  :memory               4.26
;  :mk-bool-var          441
;  :mk-clause            27
;  :num-allocs           150553
;  :num-checks           6
;  :propagations         21
;  :quant-instantiations 28
;  :rlimit-count         181761)
(assert (< i1@24@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03))))
(pop) ; 5
; Joined path conditions
(assert (< i1@24@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@22@03  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@24@03)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@24@03)))
(push) ; 5
(assert (not (ite
  (and
    (<
      (inv@21@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@24@03))
      V@12@03)
    (<=
      0
      (inv@21@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@24@03))))
  (< $Perm.No $k@20@03)
  false)))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs            84
;  :arith-add-rows       34
;  :arith-assert-diseq   5
;  :arith-assert-lower   24
;  :arith-assert-upper   14
;  :arith-bound-prop     2
;  :arith-conflicts      4
;  :arith-eq-adapter     10
;  :arith-fixed-eqs      6
;  :arith-offset-eqs     1
;  :arith-pivots         19
;  :conflicts            6
;  :datatype-accessor-ax 8
;  :decisions            2
;  :del-clause           25
;  :max-generation       2
;  :max-memory           4.27
;  :memory               4.26
;  :mk-bool-var          460
;  :mk-clause            34
;  :num-allocs           150835
;  :num-checks           7
;  :propagations         21
;  :quant-instantiations 40
;  :rlimit-count         182470)
(push) ; 5
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 6
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@22@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@24@03))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs            84
;  :arith-add-rows       34
;  :arith-assert-diseq   5
;  :arith-assert-lower   24
;  :arith-assert-upper   14
;  :arith-bound-prop     2
;  :arith-conflicts      4
;  :arith-eq-adapter     10
;  :arith-fixed-eqs      6
;  :arith-offset-eqs     1
;  :arith-pivots         19
;  :conflicts            7
;  :datatype-accessor-ax 8
;  :decisions            2
;  :del-clause           25
;  :max-generation       2
;  :max-memory           4.27
;  :memory               4.26
;  :mk-bool-var          460
;  :mk-clause            34
;  :num-allocs           150924
;  :num-checks           8
;  :propagations         21
;  :quant-instantiations 40
;  :rlimit-count         182565)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@22@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@24@03))
    (as None<option<array>>  option<array>))))
(pop) ; 5
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@22@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@24@03))
    (as None<option<array>>  option<array>))))
(pop) ; 4
(push) ; 4
; [else-branch: 4 | !(i1@24@03 < V@12@03 && 0 <= i1@24@03)]
(assert (not (and (< i1@24@03 V@12@03) (<= 0 i1@24@03))))
(pop) ; 4
(pop) ; 3
; Joined path conditions
(assert (implies
  (and (< i1@24@03 V@12@03) (<= 0 i1@24@03))
  (and
    (< i1@24@03 V@12@03)
    (<= 0 i1@24@03)
    (< i1@24@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@22@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@24@03)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@24@03))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@22@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@24@03))
        (as None<option<array>>  option<array>))))))
; Joined path conditions
(pop) ; 2
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@24@03 Int)) (!
  (implies
    (and (< i1@24@03 V@12@03) (<= 0 i1@24@03))
    (and
      (< i1@24@03 V@12@03)
      (<= 0 i1@24@03)
      (< i1@24@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@22@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@24@03)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@24@03))
      (not
        (=
          ($FVF.lookup_option$array$ (as sm@22@03  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@24@03))
          (as None<option<array>>  option<array>)))))
  :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@22@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@24@03)))))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(assert (forall ((i1@24@03 Int)) (!
  (implies
    (and (< i1@24@03 V@12@03) (<= 0 i1@24@03))
    (=
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@22@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@24@03))))
      V@12@03))
  :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@22@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@24@03)))))
  :qid |prog.l<no position>|)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@03))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@03)))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@03))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@03)))))))
  $Snap.unit))
; [eval] (forall i1: Int :: { aloc(opt_get1(Gf), i1) } (forall i2: Int :: { aloc(opt_get1(Gf), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(Gf), i1).option$array$ == aloc(opt_get1(Gf), i2).option$array$ ==> i1 == i2))
(declare-const i1@25@03 Int)
(push) ; 2
; [eval] (forall i2: Int :: { aloc(opt_get1(Gf), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(Gf), i1).option$array$ == aloc(opt_get1(Gf), i2).option$array$ ==> i1 == i2)
(declare-const i2@26@03 Int)
(push) ; 3
; [eval] 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(Gf), i1).option$array$ == aloc(opt_get1(Gf), i2).option$array$ ==> i1 == i2
; [eval] 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(Gf), i1).option$array$ == aloc(opt_get1(Gf), i2).option$array$
; [eval] 0 <= i1
(push) ; 4
; [then-branch: 5 | 0 <= i1@25@03 | live]
; [else-branch: 5 | !(0 <= i1@25@03) | live]
(push) ; 5
; [then-branch: 5 | 0 <= i1@25@03]
(assert (<= 0 i1@25@03))
; [eval] i1 < V
(push) ; 6
; [then-branch: 6 | i1@25@03 < V@12@03 | live]
; [else-branch: 6 | !(i1@25@03 < V@12@03) | live]
(push) ; 7
; [then-branch: 6 | i1@25@03 < V@12@03]
(assert (< i1@25@03 V@12@03))
; [eval] 0 <= i2
(push) ; 8
; [then-branch: 7 | 0 <= i2@26@03 | live]
; [else-branch: 7 | !(0 <= i2@26@03) | live]
(push) ; 9
; [then-branch: 7 | 0 <= i2@26@03]
(assert (<= 0 i2@26@03))
; [eval] i2 < V
(push) ; 10
; [then-branch: 8 | i2@26@03 < V@12@03 | live]
; [else-branch: 8 | !(i2@26@03 < V@12@03) | live]
(push) ; 11
; [then-branch: 8 | i2@26@03 < V@12@03]
(assert (< i2@26@03 V@12@03))
; [eval] aloc(opt_get1(Gf), i1).option$array$ == aloc(opt_get1(Gf), i2).option$array$
; [eval] aloc(opt_get1(Gf), i1)
; [eval] opt_get1(Gf)
(push) ; 12
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 12
; Joined path conditions
(push) ; 12
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 13
(assert (not (< i1@25@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))))
(check-sat)
; unsat
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs            91
;  :arith-add-rows       43
;  :arith-assert-diseq   5
;  :arith-assert-lower   28
;  :arith-assert-upper   16
;  :arith-bound-prop     2
;  :arith-conflicts      4
;  :arith-eq-adapter     11
;  :arith-fixed-eqs      7
;  :arith-offset-eqs     1
;  :arith-pivots         25
;  :conflicts            7
;  :datatype-accessor-ax 9
;  :decisions            2
;  :del-clause           32
;  :max-generation       2
;  :max-memory           4.27
;  :memory               4.27
;  :mk-bool-var          470
;  :mk-clause            34
;  :num-allocs           151828
;  :num-checks           9
;  :propagations         21
;  :quant-instantiations 40
;  :rlimit-count         184050)
(assert (< i1@25@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03))))
(pop) ; 12
; Joined path conditions
(assert (< i1@25@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@22@03  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@25@03)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@25@03)))
(push) ; 12
(assert (not (ite
  (and
    (<
      (inv@21@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@25@03))
      V@12@03)
    (<=
      0
      (inv@21@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@25@03))))
  (< $Perm.No $k@20@03)
  false)))
(check-sat)
; unsat
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs            104
;  :arith-add-rows       46
;  :arith-assert-diseq   5
;  :arith-assert-lower   29
;  :arith-assert-upper   17
;  :arith-bound-prop     5
;  :arith-conflicts      4
;  :arith-eq-adapter     12
;  :arith-fixed-eqs      8
;  :arith-offset-eqs     4
;  :arith-pivots         26
;  :conflicts            8
;  :datatype-accessor-ax 9
;  :decisions            2
;  :del-clause           32
;  :max-generation       2
;  :max-memory           4.29
;  :memory               4.28
;  :mk-bool-var          490
;  :mk-clause            42
;  :num-allocs           152113
;  :num-checks           10
;  :propagations         25
;  :quant-instantiations 52
;  :rlimit-count         184721)
; [eval] aloc(opt_get1(Gf), i2)
; [eval] opt_get1(Gf)
(push) ; 12
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 12
; Joined path conditions
(push) ; 12
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 13
(assert (not (< i2@26@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))))
(check-sat)
; unsat
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs            104
;  :arith-add-rows       46
;  :arith-assert-diseq   5
;  :arith-assert-lower   29
;  :arith-assert-upper   17
;  :arith-bound-prop     5
;  :arith-conflicts      4
;  :arith-eq-adapter     12
;  :arith-fixed-eqs      8
;  :arith-offset-eqs     4
;  :arith-pivots         26
;  :conflicts            8
;  :datatype-accessor-ax 9
;  :decisions            2
;  :del-clause           32
;  :max-generation       2
;  :max-memory           4.29
;  :memory               4.28
;  :mk-bool-var          490
;  :mk-clause            42
;  :num-allocs           152143
;  :num-checks           11
;  :propagations         25
;  :quant-instantiations 52
;  :rlimit-count         184751)
(assert (< i2@26@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03))))
(pop) ; 12
; Joined path conditions
(assert (< i2@26@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@22@03  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@26@03)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@26@03)))
(push) ; 12
(assert (not (ite
  (and
    (<
      (inv@21@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@26@03))
      V@12@03)
    (<=
      0
      (inv@21@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@26@03))))
  (< $Perm.No $k@20@03)
  false)))
(check-sat)
; unsat
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs            112
;  :arith-add-rows       54
;  :arith-assert-diseq   5
;  :arith-assert-lower   30
;  :arith-assert-upper   19
;  :arith-bound-prop     7
;  :arith-conflicts      5
;  :arith-eq-adapter     13
;  :arith-fixed-eqs      9
;  :arith-offset-eqs     5
;  :arith-pivots         28
;  :conflicts            9
;  :datatype-accessor-ax 9
;  :decisions            2
;  :del-clause           32
;  :max-generation       2
;  :max-memory           4.31
;  :memory               4.30
;  :mk-bool-var          509
;  :mk-clause            49
;  :num-allocs           152481
;  :num-checks           12
;  :propagations         28
;  :quant-instantiations 63
;  :rlimit-count         185475)
(pop) ; 11
(push) ; 11
; [else-branch: 8 | !(i2@26@03 < V@12@03)]
(assert (not (< i2@26@03 V@12@03)))
(pop) ; 11
(pop) ; 10
; Joined path conditions
(assert (implies
  (< i2@26@03 V@12@03)
  (and
    (< i2@26@03 V@12@03)
    (< i1@25@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@22@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@25@03)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@25@03))
    (< i2@26@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@22@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@26@03)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@26@03)))))
; Joined path conditions
(pop) ; 9
(push) ; 9
; [else-branch: 7 | !(0 <= i2@26@03)]
(assert (not (<= 0 i2@26@03)))
(pop) ; 9
(pop) ; 8
; Joined path conditions
(assert (implies
  (<= 0 i2@26@03)
  (and
    (<= 0 i2@26@03)
    (implies
      (< i2@26@03 V@12@03)
      (and
        (< i2@26@03 V@12@03)
        (< i1@25@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@22@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@25@03)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@25@03))
        (< i2@26@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@22@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@26@03)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@26@03)))))))
; Joined path conditions
(pop) ; 7
(push) ; 7
; [else-branch: 6 | !(i1@25@03 < V@12@03)]
(assert (not (< i1@25@03 V@12@03)))
(pop) ; 7
(pop) ; 6
; Joined path conditions
(assert (implies
  (< i1@25@03 V@12@03)
  (and
    (< i1@25@03 V@12@03)
    (implies
      (<= 0 i2@26@03)
      (and
        (<= 0 i2@26@03)
        (implies
          (< i2@26@03 V@12@03)
          (and
            (< i2@26@03 V@12@03)
            (< i1@25@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@22@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@25@03)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@25@03))
            (< i2@26@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@22@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@26@03)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@26@03)))))))))
; Joined path conditions
(pop) ; 5
(push) ; 5
; [else-branch: 5 | !(0 <= i1@25@03)]
(assert (not (<= 0 i1@25@03)))
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (implies
  (<= 0 i1@25@03)
  (and
    (<= 0 i1@25@03)
    (implies
      (< i1@25@03 V@12@03)
      (and
        (< i1@25@03 V@12@03)
        (implies
          (<= 0 i2@26@03)
          (and
            (<= 0 i2@26@03)
            (implies
              (< i2@26@03 V@12@03)
              (and
                (< i2@26@03 V@12@03)
                (< i1@25@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@22@03  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@25@03)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@25@03))
                (< i2@26@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@22@03  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@26@03)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@26@03)))))))))))
; Joined path conditions
(push) ; 4
; [then-branch: 9 | Lookup(option$array$,sm@22@03,aloc((_, _), opt_get1(_, Gf@11@03), i1@25@03)) == Lookup(option$array$,sm@22@03,aloc((_, _), opt_get1(_, Gf@11@03), i2@26@03)) && i2@26@03 < V@12@03 && 0 <= i2@26@03 && i1@25@03 < V@12@03 && 0 <= i1@25@03 | live]
; [else-branch: 9 | !(Lookup(option$array$,sm@22@03,aloc((_, _), opt_get1(_, Gf@11@03), i1@25@03)) == Lookup(option$array$,sm@22@03,aloc((_, _), opt_get1(_, Gf@11@03), i2@26@03)) && i2@26@03 < V@12@03 && 0 <= i2@26@03 && i1@25@03 < V@12@03 && 0 <= i1@25@03) | live]
(push) ; 5
; [then-branch: 9 | Lookup(option$array$,sm@22@03,aloc((_, _), opt_get1(_, Gf@11@03), i1@25@03)) == Lookup(option$array$,sm@22@03,aloc((_, _), opt_get1(_, Gf@11@03), i2@26@03)) && i2@26@03 < V@12@03 && 0 <= i2@26@03 && i1@25@03 < V@12@03 && 0 <= i1@25@03]
(assert (and
  (and
    (and
      (and
        (=
          ($FVF.lookup_option$array$ (as sm@22@03  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@25@03))
          ($FVF.lookup_option$array$ (as sm@22@03  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@26@03)))
        (< i2@26@03 V@12@03))
      (<= 0 i2@26@03))
    (< i1@25@03 V@12@03))
  (<= 0 i1@25@03)))
; [eval] i1 == i2
(pop) ; 5
(push) ; 5
; [else-branch: 9 | !(Lookup(option$array$,sm@22@03,aloc((_, _), opt_get1(_, Gf@11@03), i1@25@03)) == Lookup(option$array$,sm@22@03,aloc((_, _), opt_get1(_, Gf@11@03), i2@26@03)) && i2@26@03 < V@12@03 && 0 <= i2@26@03 && i1@25@03 < V@12@03 && 0 <= i1@25@03)]
(assert (not
  (and
    (and
      (and
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@22@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@25@03))
            ($FVF.lookup_option$array$ (as sm@22@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@26@03)))
          (< i2@26@03 V@12@03))
        (<= 0 i2@26@03))
      (< i1@25@03 V@12@03))
    (<= 0 i1@25@03))))
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (implies
  (and
    (and
      (and
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@22@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@25@03))
            ($FVF.lookup_option$array$ (as sm@22@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@26@03)))
          (< i2@26@03 V@12@03))
        (<= 0 i2@26@03))
      (< i1@25@03 V@12@03))
    (<= 0 i1@25@03))
  (and
    (=
      ($FVF.lookup_option$array$ (as sm@22@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@25@03))
      ($FVF.lookup_option$array$ (as sm@22@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@26@03)))
    (< i2@26@03 V@12@03)
    (<= 0 i2@26@03)
    (< i1@25@03 V@12@03)
    (<= 0 i1@25@03))))
; Joined path conditions
(pop) ; 3
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i2@26@03 Int)) (!
  (and
    (implies
      (<= 0 i1@25@03)
      (and
        (<= 0 i1@25@03)
        (implies
          (< i1@25@03 V@12@03)
          (and
            (< i1@25@03 V@12@03)
            (implies
              (<= 0 i2@26@03)
              (and
                (<= 0 i2@26@03)
                (implies
                  (< i2@26@03 V@12@03)
                  (and
                    (< i2@26@03 V@12@03)
                    (< i1@25@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))
                    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@22@03  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@25@03)) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@25@03))
                    (< i2@26@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))
                    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@22@03  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@26@03)) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@26@03))))))))))
    (implies
      (and
        (and
          (and
            (and
              (=
                ($FVF.lookup_option$array$ (as sm@22@03  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@25@03))
                ($FVF.lookup_option$array$ (as sm@22@03  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@26@03)))
              (< i2@26@03 V@12@03))
            (<= 0 i2@26@03))
          (< i1@25@03 V@12@03))
        (<= 0 i1@25@03))
      (and
        (=
          ($FVF.lookup_option$array$ (as sm@22@03  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@25@03))
          ($FVF.lookup_option$array$ (as sm@22@03  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@26@03)))
        (< i2@26@03 V@12@03)
        (<= 0 i2@26@03)
        (< i1@25@03 V@12@03)
        (<= 0 i1@25@03))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@26@03))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 2
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@25@03 Int)) (!
  (forall ((i2@26@03 Int)) (!
    (and
      (implies
        (<= 0 i1@25@03)
        (and
          (<= 0 i1@25@03)
          (implies
            (< i1@25@03 V@12@03)
            (and
              (< i1@25@03 V@12@03)
              (implies
                (<= 0 i2@26@03)
                (and
                  (<= 0 i2@26@03)
                  (implies
                    (< i2@26@03 V@12@03)
                    (and
                      (< i2@26@03 V@12@03)
                      (< i1@25@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))
                      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@22@03  $FVF<option<array>>) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@25@03)) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@25@03))
                      (< i2@26@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))
                      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@22@03  $FVF<option<array>>) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@26@03)) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@26@03))))))))))
      (implies
        (and
          (and
            (and
              (and
                (=
                  ($FVF.lookup_option$array$ (as sm@22@03  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@25@03))
                  ($FVF.lookup_option$array$ (as sm@22@03  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@26@03)))
                (< i2@26@03 V@12@03))
              (<= 0 i2@26@03))
            (< i1@25@03 V@12@03))
          (<= 0 i1@25@03))
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@22@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@25@03))
            ($FVF.lookup_option$array$ (as sm@22@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@26@03)))
          (< i2@26@03 V@12@03)
          (<= 0 i2@26@03)
          (< i1@25@03 V@12@03)
          (<= 0 i1@25@03))))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@26@03))
    :qid |prog.l<no position>-aux|))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@25@03))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(assert (forall ((i1@25@03 Int)) (!
  (forall ((i2@26@03 Int)) (!
    (implies
      (and
        (and
          (and
            (and
              (=
                ($FVF.lookup_option$array$ (as sm@22@03  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@25@03))
                ($FVF.lookup_option$array$ (as sm@22@03  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@26@03)))
              (< i2@26@03 V@12@03))
            (<= 0 i2@26@03))
          (< i1@25@03 V@12@03))
        (<= 0 i1@25@03))
      (= i1@25@03 i2@26@03))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@26@03))
    :qid |prog.l<no position>|))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@25@03))
  :qid |prog.l<no position>|)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@03)))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@03))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@03)))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@03))))))))
  $Snap.unit))
; [eval] p != (None(): option[array])
; [eval] (None(): option[array])
(assert (not (= p@15@03 (as None<option<array>>  option<array>))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@03))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@03)))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@03))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@03)))))))))
  $Snap.unit))
; [eval] alen(opt_get1(p)) == V
; [eval] alen(opt_get1(p))
; [eval] opt_get1(p)
(push) ; 2
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 2
; Joined path conditions
(assert (= (alen<Int> (opt_get1 $Snap.unit p@15@03)) V@12@03))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@03)))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@03))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@03)))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@03))))))))))
  $Snap.unit))
; [eval] 0 <= s
(assert (<= 0 s@13@03))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@03))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@03)))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@03))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@03)))))))))))
  $Snap.unit))
; [eval] s < V
(assert (< s@13@03 V@12@03))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@03)))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@03))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@03)))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@03))))))))))))
  $Snap.unit))
; [eval] 0 <= t
(assert (<= 0 t@14@03))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@03))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@03)))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@03))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@03)))))))))))))
  $Snap.unit))
; [eval] t < V
(assert (< t@14@03 V@12@03))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@03)))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@03))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@03)))))))))))))))))
(declare-const i1@27@03 Int)
(declare-const j1@28@03 Int)
(push) ; 2
; [eval] 0 <= i1 && i1 < V && (0 <= j1 && j1 < V)
; [eval] 0 <= i1
(push) ; 3
; [then-branch: 10 | 0 <= i1@27@03 | live]
; [else-branch: 10 | !(0 <= i1@27@03) | live]
(push) ; 4
; [then-branch: 10 | 0 <= i1@27@03]
(assert (<= 0 i1@27@03))
; [eval] i1 < V
(push) ; 5
; [then-branch: 11 | i1@27@03 < V@12@03 | live]
; [else-branch: 11 | !(i1@27@03 < V@12@03) | live]
(push) ; 6
; [then-branch: 11 | i1@27@03 < V@12@03]
(assert (< i1@27@03 V@12@03))
; [eval] 0 <= j1
(push) ; 7
; [then-branch: 12 | 0 <= j1@28@03 | live]
; [else-branch: 12 | !(0 <= j1@28@03) | live]
(push) ; 8
; [then-branch: 12 | 0 <= j1@28@03]
(assert (<= 0 j1@28@03))
; [eval] j1 < V
(pop) ; 8
(push) ; 8
; [else-branch: 12 | !(0 <= j1@28@03)]
(assert (not (<= 0 j1@28@03)))
(pop) ; 8
(pop) ; 7
; Joined path conditions
; Joined path conditions
(pop) ; 6
(push) ; 6
; [else-branch: 11 | !(i1@27@03 < V@12@03)]
(assert (not (< i1@27@03 V@12@03)))
(pop) ; 6
(pop) ; 5
; Joined path conditions
; Joined path conditions
(pop) ; 4
(push) ; 4
; [else-branch: 10 | !(0 <= i1@27@03)]
(assert (not (<= 0 i1@27@03)))
(pop) ; 4
(pop) ; 3
; Joined path conditions
; Joined path conditions
(assert (and
  (and (and (< j1@28@03 V@12@03) (<= 0 j1@28@03)) (< i1@27@03 V@12@03))
  (<= 0 i1@27@03)))
; [eval] aloc(opt_get1(aloc(opt_get1(Gf), i1).option$array$), j1)
; [eval] opt_get1(aloc(opt_get1(Gf), i1).option$array$)
; [eval] aloc(opt_get1(Gf), i1)
; [eval] opt_get1(Gf)
(push) ; 3
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 3
; Joined path conditions
(push) ; 3
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 4
(assert (not (< i1@27@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs            160
;  :arith-add-rows       61
;  :arith-assert-diseq   5
;  :arith-assert-lower   39
;  :arith-assert-upper   27
;  :arith-bound-prop     7
;  :arith-conflicts      5
;  :arith-eq-adapter     16
;  :arith-fixed-eqs      12
;  :arith-offset-eqs     5
;  :arith-pivots         38
;  :conflicts            9
;  :datatype-accessor-ax 16
;  :decisions            2
;  :del-clause           71
;  :max-generation       2
;  :max-memory           4.32
;  :memory               4.31
;  :mk-bool-var          560
;  :mk-clause            73
;  :num-allocs           154289
;  :num-checks           13
;  :propagations         28
;  :quant-instantiations 68
;  :rlimit-count         189760)
(assert (< i1@27@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03))))
(pop) ; 3
; Joined path conditions
(assert (< i1@27@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@22@03  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@27@03)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@27@03)))
(push) ; 3
(assert (not (ite
  (and
    (<
      (inv@21@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@27@03))
      V@12@03)
    (<=
      0
      (inv@21@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@27@03))))
  (< $Perm.No $k@20@03)
  false)))
(check-sat)
; unsat
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs            164
;  :arith-add-rows       66
;  :arith-assert-diseq   5
;  :arith-assert-lower   41
;  :arith-assert-upper   28
;  :arith-bound-prop     8
;  :arith-conflicts      6
;  :arith-eq-adapter     17
;  :arith-fixed-eqs      13
;  :arith-offset-eqs     5
;  :arith-pivots         40
;  :conflicts            10
;  :datatype-accessor-ax 16
;  :decisions            2
;  :del-clause           71
;  :max-generation       3
;  :max-memory           4.66
;  :memory               4.50
;  :mk-bool-var          588
;  :mk-clause            80
;  :num-allocs           154663
;  :num-checks           14
;  :propagations         28
;  :quant-instantiations 83
;  :rlimit-count         190782)
(push) ; 3
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 4
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@22@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@27@03))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs            164
;  :arith-add-rows       66
;  :arith-assert-diseq   5
;  :arith-assert-lower   41
;  :arith-assert-upper   28
;  :arith-bound-prop     8
;  :arith-conflicts      6
;  :arith-eq-adapter     17
;  :arith-fixed-eqs      13
;  :arith-offset-eqs     5
;  :arith-pivots         40
;  :conflicts            11
;  :datatype-accessor-ax 16
;  :decisions            2
;  :del-clause           71
;  :max-generation       3
;  :max-memory           4.66
;  :memory               4.51
;  :mk-bool-var          588
;  :mk-clause            80
;  :num-allocs           154754
;  :num-checks           15
;  :propagations         28
;  :quant-instantiations 83
;  :rlimit-count         190877)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@22@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@27@03))
    (as None<option<array>>  option<array>))))
(pop) ; 3
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@22@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@27@03))
    (as None<option<array>>  option<array>))))
(push) ; 3
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 4
(assert (not (<
  j1@28@03
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@22@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@27@03)))))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs            170
;  :arith-add-rows       71
;  :arith-assert-diseq   5
;  :arith-assert-lower   44
;  :arith-assert-upper   29
;  :arith-bound-prop     8
;  :arith-conflicts      7
;  :arith-eq-adapter     18
;  :arith-fixed-eqs      14
;  :arith-offset-eqs     5
;  :arith-pivots         44
;  :conflicts            12
;  :datatype-accessor-ax 16
;  :decisions            2
;  :del-clause           75
;  :max-generation       3
;  :max-memory           4.66
;  :memory               4.52
;  :mk-bool-var          599
;  :mk-clause            84
;  :num-allocs           154970
;  :num-checks           16
;  :propagations         30
;  :quant-instantiations 90
;  :rlimit-count         191380)
(assert (<
  j1@28@03
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@22@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@27@03))))))
(pop) ; 3
; Joined path conditions
(assert (<
  j1@28@03
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@22@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@27@03))))))
(pop) ; 2
(declare-fun inv@29@03 ($Ref) Int)
(declare-fun inv@30@03 ($Ref) Int)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(assert (forall ((i1@27@03 Int) (j1@28@03 Int)) (!
  (and
    (< i1@27@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@22@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@27@03)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@27@03))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@22@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@27@03))
        (as None<option<array>>  option<array>)))
    (<
      j1@28@03
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@22@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@27@03))))))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@22@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@27@03))) j1@28@03))
  :qid |int-aux|)))
; Check receiver injectivity
(push) ; 2
(assert (not (forall ((i11@27@03 Int) (j11@28@03 Int) (i12@27@03 Int) (j12@28@03 Int)) (!
  (implies
    (and
      (and
        (and (and (< j11@28@03 V@12@03) (<= 0 j11@28@03)) (< i11@27@03 V@12@03))
        (<= 0 i11@27@03))
      (and
        (and (and (< j12@28@03 V@12@03) (<= 0 j12@28@03)) (< i12@27@03 V@12@03))
        (<= 0 i12@27@03))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@22@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i11@27@03))) j11@28@03)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@22@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i12@27@03))) j12@28@03)))
    (and (= i11@27@03 i12@27@03) (= j11@28@03 j12@28@03)))
  
  :qid |int-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 2
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs            215
;  :arith-add-rows       87
;  :arith-assert-diseq   5
;  :arith-assert-lower   57
;  :arith-assert-upper   34
;  :arith-bound-prop     11
;  :arith-conflicts      7
;  :arith-eq-adapter     24
;  :arith-fixed-eqs      17
;  :arith-offset-eqs     6
;  :arith-pivots         58
;  :conflicts            13
;  :datatype-accessor-ax 16
;  :decisions            2
;  :del-clause           141
;  :max-generation       3
;  :max-memory           4.66
;  :memory               4.63
;  :mk-bool-var          733
;  :mk-clause            143
;  :num-allocs           156289
;  :num-checks           17
;  :propagations         55
;  :quant-instantiations 148
;  :rlimit-count         195051
;  :time                 0.00)
; Definitional axioms for inverse functions
(assert (forall ((i1@27@03 Int) (j1@28@03 Int)) (!
  (implies
    (and
      (and (and (< j1@28@03 V@12@03) (<= 0 j1@28@03)) (< i1@27@03 V@12@03))
      (<= 0 i1@27@03))
    (and
      (=
        (inv@29@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@22@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@27@03))) j1@28@03))
        i1@27@03)
      (=
        (inv@30@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@22@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@27@03))) j1@28@03))
        j1@28@03)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@22@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@27@03))) j1@28@03))
  )))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@30@03 r) V@12@03) (<= 0 (inv@30@03 r)))
        (< (inv@29@03 r) V@12@03))
      (<= 0 (inv@29@03 r)))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@22@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) (inv@29@03 r)))) (inv@30@03 r))
      r))
  :pattern ((inv@29@03 r))
  :pattern ((inv@30@03 r))
  :qid |int-fctOfInv|)))
; Permissions are non-negative
; Field permissions are at most one
; Permission implies non-null receiver
(assert (forall ((i1@27@03 Int) (j1@28@03 Int)) (!
  (implies
    (and
      (and (and (< j1@28@03 V@12@03) (<= 0 j1@28@03)) (< i1@27@03 V@12@03))
      (<= 0 i1@27@03))
    (not
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@22@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@27@03))) j1@28@03)
        $Ref.null)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@22@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@27@03))) j1@28@03))
  :qid |int-permImpliesNonNull|)))
(declare-const sm@31@03 $FVF<Int>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@30@03 r) V@12@03) (<= 0 (inv@30@03 r)))
        (< (inv@29@03 r) V@12@03))
      (<= 0 (inv@29@03 r)))
    (=
      ($FVF.lookup_int (as sm@31@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@03))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@31@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@03))))))))))))))) r))
  :qid |qp.fvfValDef2|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@03))))))))))))))) r) r)
  :pattern (($FVF.lookup_int (as sm@31@03  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef3|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@30@03 r) V@12@03) (<= 0 (inv@30@03 r)))
        (< (inv@29@03 r) V@12@03))
      (<= 0 (inv@29@03 r)))
    ($FVF.loc_int ($FVF.lookup_int (as sm@31@03  $FVF<Int>) r) r))
  :pattern ((inv@29@03 r) (inv@30@03 r))
  )))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@03))))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@03)))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@03))))))))))))))))))
(declare-const i1@32@03 Int)
(push) ; 2
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 3
; [then-branch: 13 | 0 <= i1@32@03 | live]
; [else-branch: 13 | !(0 <= i1@32@03) | live]
(push) ; 4
; [then-branch: 13 | 0 <= i1@32@03]
(assert (<= 0 i1@32@03))
; [eval] i1 < V
(pop) ; 4
(push) ; 4
; [else-branch: 13 | !(0 <= i1@32@03)]
(assert (not (<= 0 i1@32@03)))
(pop) ; 4
(pop) ; 3
; Joined path conditions
; Joined path conditions
(assert (and (< i1@32@03 V@12@03) (<= 0 i1@32@03)))
; [eval] aloc(opt_get1(p), i1)
; [eval] opt_get1(p)
(push) ; 3
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 3
; Joined path conditions
(push) ; 3
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 4
(assert (not (< i1@32@03 (alen<Int> (opt_get1 $Snap.unit p@15@03)))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs            220
;  :arith-add-rows       87
;  :arith-assert-diseq   5
;  :arith-assert-lower   59
;  :arith-assert-upper   34
;  :arith-bound-prop     11
;  :arith-conflicts      7
;  :arith-eq-adapter     24
;  :arith-fixed-eqs      17
;  :arith-offset-eqs     6
;  :arith-pivots         58
;  :conflicts            13
;  :datatype-accessor-ax 17
;  :decisions            2
;  :del-clause           141
;  :max-generation       3
;  :max-memory           4.66
;  :memory               4.64
;  :mk-bool-var          742
;  :mk-clause            143
;  :num-allocs           157407
;  :num-checks           18
;  :propagations         55
;  :quant-instantiations 148
;  :rlimit-count         198170)
(assert (< i1@32@03 (alen<Int> (opt_get1 $Snap.unit p@15@03))))
(pop) ; 3
; Joined path conditions
(assert (< i1@32@03 (alen<Int> (opt_get1 $Snap.unit p@15@03))))
(pop) ; 2
(declare-fun inv@33@03 ($Ref) Int)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(assert (forall ((i1@32@03 Int)) (!
  (< i1@32@03 (alen<Int> (opt_get1 $Snap.unit p@15@03)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) i1@32@03))
  :qid |int-aux|)))
; Check receiver injectivity
(push) ; 2
(assert (not (forall ((i11@32@03 Int) (i12@32@03 Int)) (!
  (implies
    (and
      (and (< i11@32@03 V@12@03) (<= 0 i11@32@03))
      (and (< i12@32@03 V@12@03) (<= 0 i12@32@03))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) i11@32@03)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) i12@32@03)))
    (= i11@32@03 i12@32@03))
  
  :qid |int-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 2
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs            240
;  :arith-add-rows       100
;  :arith-assert-diseq   8
;  :arith-assert-lower   66
;  :arith-assert-upper   36
;  :arith-bound-prop     11
;  :arith-conflicts      9
;  :arith-eq-adapter     25
;  :arith-fixed-eqs      17
;  :arith-offset-eqs     7
;  :arith-pivots         64
;  :conflicts            16
;  :datatype-accessor-ax 17
;  :decisions            4
;  :del-clause           155
;  :max-generation       3
;  :max-memory           4.66
;  :memory               4.64
;  :mk-bool-var          766
;  :mk-clause            157
;  :num-allocs           157922
;  :num-checks           19
;  :propagations         70
;  :quant-instantiations 158
;  :rlimit-count         199345)
; Definitional axioms for inverse functions
(assert (forall ((i1@32@03 Int)) (!
  (implies
    (and (< i1@32@03 V@12@03) (<= 0 i1@32@03))
    (=
      (inv@33@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) i1@32@03))
      i1@32@03))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) i1@32@03))
  )))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@33@03 r) V@12@03) (<= 0 (inv@33@03 r)))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) (inv@33@03 r))
      r))
  :pattern ((inv@33@03 r))
  :qid |int-fctOfInv|)))
; Permissions are non-negative
; Field permissions are at most one
; Permission implies non-null receiver
(assert (forall ((i1@32@03 Int)) (!
  (implies
    (and (< i1@32@03 V@12@03) (<= 0 i1@32@03))
    (not
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) i1@32@03)
        $Ref.null)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) i1@32@03))
  :qid |int-permImpliesNonNull|)))
(declare-const sm@34@03 $FVF<Int>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@33@03 r) V@12@03) (<= 0 (inv@33@03 r)))
    (=
      ($FVF.lookup_int (as sm@34@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@03)))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@34@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@03)))))))))))))))) r))
  :qid |qp.fvfValDef4|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@30@03 r) V@12@03) (<= 0 (inv@30@03 r)))
        (< (inv@29@03 r) V@12@03))
      (<= 0 (inv@29@03 r)))
    (=
      ($FVF.lookup_int (as sm@34@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@03))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@34@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@03))))))))))))))) r))
  :qid |qp.fvfValDef5|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@03)))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@03))))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@34@03  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef6|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@33@03 r) V@12@03) (<= 0 (inv@33@03 r)))
    ($FVF.loc_int ($FVF.lookup_int (as sm@34@03  $FVF<Int>) r) r))
  :pattern ((inv@33@03 r))
  )))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@03)))))))))))))))
  $Snap.unit))
; [eval] valid_graph_vertices(this, p, V)
(push) ; 2
; [eval] this != null
; [eval] p != (None(): option[array])
; [eval] (None(): option[array])
; [eval] alen(opt_get1(p)) == V
; [eval] alen(opt_get1(p))
; [eval] opt_get1(p)
(push) ; 3
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 3
; Joined path conditions
(declare-const i1@35@03 Int)
(push) ; 3
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 4
; [then-branch: 14 | 0 <= i1@35@03 | live]
; [else-branch: 14 | !(0 <= i1@35@03) | live]
(push) ; 5
; [then-branch: 14 | 0 <= i1@35@03]
(assert (<= 0 i1@35@03))
; [eval] i1 < V
(pop) ; 5
(push) ; 5
; [else-branch: 14 | !(0 <= i1@35@03)]
(assert (not (<= 0 i1@35@03)))
(pop) ; 5
(pop) ; 4
; Joined path conditions
; Joined path conditions
(assert (and (< i1@35@03 V@12@03) (<= 0 i1@35@03)))
(declare-const $k@36@03 $Perm)
(assert ($Perm.isReadVar $k@36@03 $Perm.Write))
; [eval] aloc(opt_get1(p), i1)
; [eval] opt_get1(p)
(push) ; 4
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 4
; Joined path conditions
(push) ; 4
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 5
(assert (not (< i1@35@03 (alen<Int> (opt_get1 $Snap.unit p@15@03)))))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs            241
;  :arith-add-rows       100
;  :arith-assert-diseq   9
;  :arith-assert-lower   70
;  :arith-assert-upper   37
;  :arith-bound-prop     11
;  :arith-conflicts      9
;  :arith-eq-adapter     26
;  :arith-fixed-eqs      17
;  :arith-offset-eqs     7
;  :arith-pivots         64
;  :conflicts            16
;  :datatype-accessor-ax 17
;  :decisions            4
;  :del-clause           155
;  :max-generation       3
;  :max-memory           4.66
;  :memory               4.65
;  :mk-bool-var          780
;  :mk-clause            159
;  :num-allocs           159162
;  :num-checks           20
;  :propagations         71
;  :quant-instantiations 158
;  :rlimit-count         202605)
(assert (< i1@35@03 (alen<Int> (opt_get1 $Snap.unit p@15@03))))
(pop) ; 4
; Joined path conditions
(assert (< i1@35@03 (alen<Int> (opt_get1 $Snap.unit p@15@03))))
(pop) ; 3
(declare-fun inv@37@03 ($Ref) Int)
; Nested auxiliary terms: globals
(assert ($Perm.isReadVar $k@36@03 $Perm.Write))
; Nested auxiliary terms: non-globals
(assert (forall ((i1@35@03 Int)) (!
  (< i1@35@03 (alen<Int> (opt_get1 $Snap.unit p@15@03)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) i1@35@03))
  :qid |int-aux|)))
(push) ; 3
(assert (not (forall ((i1@35@03 Int)) (!
  (implies
    (and (< i1@35@03 V@12@03) (<= 0 i1@35@03))
    (or (= $k@36@03 $Perm.No) (< $Perm.No $k@36@03)))
  
  ))))
(check-sat)
; unsat
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs            241
;  :arith-add-rows       100
;  :arith-assert-diseq   10
;  :arith-assert-lower   72
;  :arith-assert-upper   38
;  :arith-bound-prop     11
;  :arith-conflicts      9
;  :arith-eq-adapter     27
;  :arith-fixed-eqs      17
;  :arith-offset-eqs     7
;  :arith-pivots         64
;  :conflicts            17
;  :datatype-accessor-ax 17
;  :decisions            4
;  :del-clause           157
;  :max-generation       3
;  :max-memory           4.66
;  :memory               4.64
;  :mk-bool-var          787
;  :mk-clause            161
;  :num-allocs           159580
;  :num-checks           21
;  :propagations         72
;  :quant-instantiations 158
;  :rlimit-count         203151)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 3
(assert (not (forall ((i11@35@03 Int) (i12@35@03 Int)) (!
  (implies
    (and
      (and
        (and
          (and (< i11@35@03 V@12@03) (<= 0 i11@35@03))
          ($FVF.loc_int ($FVF.lookup_int (as sm@34@03  $FVF<Int>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit p@15@03) i11@35@03)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit p@15@03) i11@35@03)))
        (< $Perm.No $k@36@03))
      (and
        (and
          (and (< i12@35@03 V@12@03) (<= 0 i12@35@03))
          ($FVF.loc_int ($FVF.lookup_int (as sm@34@03  $FVF<Int>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit p@15@03) i12@35@03)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit p@15@03) i12@35@03)))
        (< $Perm.No $k@36@03))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) i11@35@03)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) i12@35@03)))
    (= i11@35@03 i12@35@03))
  
  :qid |int-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs            249
;  :arith-add-rows       102
;  :arith-assert-diseq   11
;  :arith-assert-lower   76
;  :arith-assert-upper   38
;  :arith-bound-prop     11
;  :arith-conflicts      9
;  :arith-eq-adapter     28
;  :arith-fixed-eqs      17
;  :arith-offset-eqs     7
;  :arith-pivots         64
;  :conflicts            18
;  :datatype-accessor-ax 17
;  :decisions            4
;  :del-clause           168
;  :max-generation       3
;  :max-memory           4.66
;  :memory               4.65
;  :mk-bool-var          817
;  :mk-clause            172
;  :num-allocs           160032
;  :num-checks           22
;  :propagations         74
;  :quant-instantiations 172
;  :rlimit-count         204118)
; Definitional axioms for inverse functions
(assert (forall ((i1@35@03 Int)) (!
  (implies
    (and (and (< i1@35@03 V@12@03) (<= 0 i1@35@03)) (< $Perm.No $k@36@03))
    (=
      (inv@37@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) i1@35@03))
      i1@35@03))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) i1@35@03))
  :qid |int-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and (< (inv@37@03 r) V@12@03) (<= 0 (inv@37@03 r)))
      (< $Perm.No $k@36@03))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) (inv@37@03 r))
      r))
  :pattern ((inv@37@03 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@37@03 r) V@12@03) (<= 0 (inv@37@03 r)))
    ($FVF.loc_int ($FVF.lookup_int (as sm@34@03  $FVF<Int>) r) r))
  :pattern ((inv@37@03 r))
  )))
; Precomputing data for removing quantified permissions
(define-fun pTaken@38@03 ((r $Ref)) $Perm
  (ite
    (and (< (inv@37@03 r) V@12@03) (<= 0 (inv@37@03 r)))
    ($Perm.min
      (ite
        (and (< (inv@33@03 r) V@12@03) (<= 0 (inv@33@03 r)))
        $Perm.Write
        $Perm.No)
      $k@36@03)
    $Perm.No))
(define-fun pTaken@39@03 ((r $Ref)) $Perm
  (ite
    (and (< (inv@37@03 r) V@12@03) (<= 0 (inv@37@03 r)))
    ($Perm.min
      (ite
        (and
          (and
            (and (< (inv@30@03 r) V@12@03) (<= 0 (inv@30@03 r)))
            (< (inv@29@03 r) V@12@03))
          (<= 0 (inv@29@03 r)))
        $Perm.Write
        $Perm.No)
      (- $k@36@03 (pTaken@38@03 r)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Constrain original permissions $k@36@03
(assert (forall ((r $Ref)) (!
  (implies
    (not
      (=
        (ite
          (and (< (inv@33@03 r) V@12@03) (<= 0 (inv@33@03 r)))
          $Perm.Write
          $Perm.No)
        $Perm.No))
    (ite
      (and (< (inv@33@03 r) V@12@03) (<= 0 (inv@33@03 r)))
      (<
        (ite
          (and (< (inv@37@03 r) V@12@03) (<= 0 (inv@37@03 r)))
          $k@36@03
          $Perm.No)
        $Perm.Write)
      (<
        (ite
          (and (< (inv@37@03 r) V@12@03) (<= 0 (inv@37@03 r)))
          $k@36@03
          $Perm.No)
        $Perm.No)))
  :pattern ((inv@33@03 r))
  :pattern ((inv@37@03 r))
  :qid |qp.srp7|)))
; Intermediate check if already taken enough permissions
(set-option :timeout 500)
(push) ; 3
(assert (not (forall ((r $Ref)) (!
  (implies
    (and (< (inv@37@03 r) V@12@03) (<= 0 (inv@37@03 r)))
    (= (- $k@36@03 (pTaken@38@03 r)) $Perm.No))
  
  ))))
(check-sat)
; unsat
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               312
;  :arith-add-rows          117
;  :arith-assert-diseq      17
;  :arith-assert-lower      86
;  :arith-assert-upper      48
;  :arith-bound-prop        12
;  :arith-conflicts         12
;  :arith-eq-adapter        42
;  :arith-fixed-eqs         20
;  :arith-offset-eqs        8
;  :arith-pivots            75
;  :conflicts               26
;  :datatype-accessor-ax    17
;  :datatype-constructor-ax 6
;  :datatype-occurs-check   3
;  :datatype-splits         3
;  :decisions               14
;  :del-clause              232
;  :final-checks            2
;  :max-generation          3
;  :max-memory              4.73
;  :memory                  4.73
;  :minimized-lits          1
;  :mk-bool-var             906
;  :mk-clause               234
;  :num-allocs              162169
;  :num-checks              24
;  :propagations            108
;  :quant-instantiations    191
;  :rlimit-count            207690)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@40@03 $FVF<Int>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (iff
    (Set_in r ($FVF.domain_int (as sm@40@03  $FVF<Int>)))
    (and
      (and (< (inv@37@03 r) V@12@03) (<= 0 (inv@37@03 r)))
      (< $Perm.No $k@36@03)))
  :pattern ((Set_in r ($FVF.domain_int (as sm@40@03  $FVF<Int>))))
  :qid |qp.fvfDomDef11|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@37@03 r) V@12@03) (<= 0 (inv@37@03 r)))
        (< $Perm.No $k@36@03))
      (and (< (inv@33@03 r) V@12@03) (<= 0 (inv@33@03 r))))
    (=
      ($FVF.lookup_int (as sm@40@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@03)))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@40@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@03)))))))))))))))) r))
  :qid |qp.fvfValDef8|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@37@03 r) V@12@03) (<= 0 (inv@37@03 r)))
        (< $Perm.No $k@36@03))
      (and
        (and
          (and (< (inv@30@03 r) V@12@03) (<= 0 (inv@30@03 r)))
          (< (inv@29@03 r) V@12@03))
        (<= 0 (inv@29@03 r))))
    (=
      ($FVF.lookup_int (as sm@40@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@03))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@40@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@03))))))))))))))) r))
  :qid |qp.fvfValDef9|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@03)))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@03))))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@40@03  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef10|)))
(pop) ; 2
; Joined path conditions
(assert ($Perm.isReadVar $k@36@03 $Perm.Write))
(assert (forall ((i1@35@03 Int)) (!
  (implies
    (and (and (< i1@35@03 V@12@03) (<= 0 i1@35@03)) (< $Perm.No $k@36@03))
    (=
      (inv@37@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) i1@35@03))
      i1@35@03))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) i1@35@03))
  :qid |int-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and (< (inv@37@03 r) V@12@03) (<= 0 (inv@37@03 r)))
      (< $Perm.No $k@36@03))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) (inv@37@03 r))
      r))
  :pattern ((inv@37@03 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (iff
    (Set_in r ($FVF.domain_int (as sm@40@03  $FVF<Int>)))
    (and
      (and (< (inv@37@03 r) V@12@03) (<= 0 (inv@37@03 r)))
      (< $Perm.No $k@36@03)))
  :pattern ((Set_in r ($FVF.domain_int (as sm@40@03  $FVF<Int>))))
  :qid |qp.fvfDomDef11|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@37@03 r) V@12@03) (<= 0 (inv@37@03 r)))
        (< $Perm.No $k@36@03))
      (and (< (inv@33@03 r) V@12@03) (<= 0 (inv@33@03 r))))
    (=
      ($FVF.lookup_int (as sm@40@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@03)))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@40@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@03)))))))))))))))) r))
  :qid |qp.fvfValDef8|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@37@03 r) V@12@03) (<= 0 (inv@37@03 r)))
        (< $Perm.No $k@36@03))
      (and
        (and
          (and (< (inv@30@03 r) V@12@03) (<= 0 (inv@30@03 r)))
          (< (inv@29@03 r) V@12@03))
        (<= 0 (inv@29@03 r))))
    (=
      ($FVF.lookup_int (as sm@40@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@03))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@40@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@03))))))))))))))) r))
  :qid |qp.fvfValDef9|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@03)))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@03))))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@40@03  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef10|)))
(assert (and
  (forall ((i1@35@03 Int)) (!
    (< i1@35@03 (alen<Int> (opt_get1 $Snap.unit p@15@03)))
    :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) i1@35@03))
    :qid |int-aux|))
  (forall ((r $Ref)) (!
    (implies
      (and (< (inv@37@03 r) V@12@03) (<= 0 (inv@37@03 r)))
      ($FVF.loc_int ($FVF.lookup_int (as sm@34@03  $FVF<Int>) r) r))
    :pattern ((inv@37@03 r))
    ))
  (forall ((r $Ref)) (!
    (implies
      (not
        (=
          (ite
            (and (< (inv@33@03 r) V@12@03) (<= 0 (inv@33@03 r)))
            $Perm.Write
            $Perm.No)
          $Perm.No))
      (ite
        (and (< (inv@33@03 r) V@12@03) (<= 0 (inv@33@03 r)))
        (<
          (ite
            (and (< (inv@37@03 r) V@12@03) (<= 0 (inv@37@03 r)))
            $k@36@03
            $Perm.No)
          $Perm.Write)
        (<
          (ite
            (and (< (inv@37@03 r) V@12@03) (<= 0 (inv@37@03 r)))
            $k@36@03
            $Perm.No)
          $Perm.No)))
    :pattern ((inv@33@03 r))
    :pattern ((inv@37@03 r))
    :qid |qp.srp7|))))
(assert (valid_graph_vertices ($Snap.combine
  $Snap.unit
  ($Snap.combine
    $Snap.unit
    ($Snap.combine
      $Snap.unit
      ($SortWrappers.$FVF<Int>To$Snap (as sm@40@03  $FVF<Int>))))) this@9@03 p@15@03 V@12@03))
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
(push) ; 2
(declare-const $t@41@03 $Snap)
(assert (= $t@41@03 ($Snap.combine ($Snap.first $t@41@03) ($Snap.second $t@41@03))))
(assert (= ($Snap.first $t@41@03) $Snap.unit))
; [eval] exc == null
(assert (= exc@16@03 $Ref.null))
(assert (=
  ($Snap.second $t@41@03)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@41@03))
    ($Snap.second ($Snap.second $t@41@03)))))
(assert (= ($Snap.first ($Snap.second $t@41@03)) $Snap.unit))
; [eval] exc == null ==> Gf != (None(): option[array])
; [eval] exc == null
(push) ; 3
(set-option :timeout 10)
(push) ; 4
(assert (not (not (= exc@16@03 $Ref.null))))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               364
;  :arith-add-rows          119
;  :arith-assert-diseq      19
;  :arith-assert-lower      90
;  :arith-assert-upper      50
;  :arith-bound-prop        12
;  :arith-conflicts         12
;  :arith-eq-adapter        44
;  :arith-fixed-eqs         20
;  :arith-offset-eqs        8
;  :arith-pivots            75
;  :conflicts               26
;  :datatype-accessor-ax    22
;  :datatype-constructor-ax 15
;  :datatype-occurs-check   13
;  :datatype-splits         8
;  :decisions               23
;  :del-clause              257
;  :final-checks            6
;  :max-generation          3
;  :max-memory              4.77
;  :memory                  4.76
;  :minimized-lits          1
;  :mk-bool-var             958
;  :mk-clause               265
;  :num-allocs              165487
;  :num-checks              26
;  :propagations            123
;  :quant-instantiations    195
;  :rlimit-count            214030)
; [then-branch: 15 | exc@16@03 == Null | live]
; [else-branch: 15 | exc@16@03 != Null | dead]
(push) ; 4
; [then-branch: 15 | exc@16@03 == Null]
; [eval] Gf != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 4
(pop) ; 3
; Joined path conditions
(assert (implies
  (= exc@16@03 $Ref.null)
  (not (= Gf@11@03 (as None<option<array>>  option<array>)))))
(assert (=
  ($Snap.second ($Snap.second $t@41@03))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second $t@41@03)))
    ($Snap.second ($Snap.second ($Snap.second $t@41@03))))))
(assert (= ($Snap.first ($Snap.second ($Snap.second $t@41@03))) $Snap.unit))
; [eval] exc == null ==> alen(opt_get1(Gf)) == V
; [eval] exc == null
(push) ; 3
(push) ; 4
(assert (not (not (= exc@16@03 $Ref.null))))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               389
;  :arith-add-rows          119
;  :arith-assert-diseq      19
;  :arith-assert-lower      90
;  :arith-assert-upper      50
;  :arith-bound-prop        12
;  :arith-conflicts         12
;  :arith-eq-adapter        44
;  :arith-fixed-eqs         20
;  :arith-offset-eqs        8
;  :arith-pivots            75
;  :conflicts               26
;  :datatype-accessor-ax    23
;  :datatype-constructor-ax 20
;  :datatype-occurs-check   16
;  :datatype-splits         9
;  :decisions               28
;  :del-clause              257
;  :final-checks            8
;  :max-generation          3
;  :max-memory              4.77
;  :memory                  4.76
;  :minimized-lits          1
;  :mk-bool-var             961
;  :mk-clause               265
;  :num-allocs              166204
;  :num-checks              27
;  :propagations            123
;  :quant-instantiations    195
;  :rlimit-count            214740)
; [then-branch: 16 | exc@16@03 == Null | live]
; [else-branch: 16 | exc@16@03 != Null | dead]
(push) ; 4
; [then-branch: 16 | exc@16@03 == Null]
; [eval] alen(opt_get1(Gf)) == V
; [eval] alen(opt_get1(Gf))
; [eval] opt_get1(Gf)
(push) ; 5
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 5
; Joined path conditions
(pop) ; 4
(pop) ; 3
; Joined path conditions
(assert (implies
  (= exc@16@03 $Ref.null)
  (= (alen<Int> (opt_get1 $Snap.unit Gf@11@03)) V@12@03)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second $t@41@03)))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@41@03))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@41@03)))))))
; [eval] exc == null
(push) ; 3
(assert (not (not (= exc@16@03 $Ref.null))))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               416
;  :arith-add-rows          119
;  :arith-assert-diseq      19
;  :arith-assert-lower      90
;  :arith-assert-upper      50
;  :arith-bound-prop        12
;  :arith-conflicts         12
;  :arith-eq-adapter        44
;  :arith-fixed-eqs         20
;  :arith-offset-eqs        8
;  :arith-pivots            75
;  :conflicts               26
;  :datatype-accessor-ax    24
;  :datatype-constructor-ax 26
;  :datatype-occurs-check   19
;  :datatype-splits         11
;  :decisions               34
;  :del-clause              257
;  :final-checks            10
;  :max-generation          3
;  :max-memory              4.77
;  :memory                  4.76
;  :minimized-lits          1
;  :mk-bool-var             964
;  :mk-clause               265
;  :num-allocs              166922
;  :num-checks              28
;  :propagations            123
;  :quant-instantiations    195
;  :rlimit-count            215442)
; [then-branch: 17 | exc@16@03 == Null | live]
; [else-branch: 17 | exc@16@03 != Null | dead]
(push) ; 3
; [then-branch: 17 | exc@16@03 == Null]
(declare-const i1@42@03 Int)
(push) ; 4
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 5
; [then-branch: 18 | 0 <= i1@42@03 | live]
; [else-branch: 18 | !(0 <= i1@42@03) | live]
(push) ; 6
; [then-branch: 18 | 0 <= i1@42@03]
(assert (<= 0 i1@42@03))
; [eval] i1 < V
(pop) ; 6
(push) ; 6
; [else-branch: 18 | !(0 <= i1@42@03)]
(assert (not (<= 0 i1@42@03)))
(pop) ; 6
(pop) ; 5
; Joined path conditions
; Joined path conditions
(assert (and (< i1@42@03 V@12@03) (<= 0 i1@42@03)))
; [eval] aloc(opt_get1(Gf), i1)
; [eval] opt_get1(Gf)
(push) ; 5
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 5
; Joined path conditions
(push) ; 5
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 6
(assert (not (< i1@42@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               416
;  :arith-add-rows          119
;  :arith-assert-diseq      19
;  :arith-assert-lower      92
;  :arith-assert-upper      50
;  :arith-bound-prop        12
;  :arith-conflicts         12
;  :arith-eq-adapter        44
;  :arith-fixed-eqs         20
;  :arith-offset-eqs        8
;  :arith-pivots            75
;  :conflicts               26
;  :datatype-accessor-ax    24
;  :datatype-constructor-ax 26
;  :datatype-occurs-check   19
;  :datatype-splits         11
;  :decisions               34
;  :del-clause              257
;  :final-checks            10
;  :max-generation          3
;  :max-memory              4.77
;  :memory                  4.76
;  :minimized-lits          1
;  :mk-bool-var             966
;  :mk-clause               265
;  :num-allocs              167025
;  :num-checks              29
;  :propagations            123
;  :quant-instantiations    195
;  :rlimit-count            215627)
(assert (< i1@42@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03))))
(pop) ; 5
; Joined path conditions
(assert (< i1@42@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03))))
(declare-const $k@43@03 $Perm)
(assert ($Perm.isReadVar $k@43@03 $Perm.Write))
(pop) ; 4
(declare-fun inv@44@03 ($Ref) Int)
; Nested auxiliary terms: globals
(assert ($Perm.isReadVar $k@43@03 $Perm.Write))
; Nested auxiliary terms: non-globals
(assert (forall ((i1@42@03 Int)) (!
  (< i1@42@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@42@03))
  :qid |option$array$-aux|)))
(push) ; 4
(assert (not (forall ((i1@42@03 Int)) (!
  (implies
    (and (< i1@42@03 V@12@03) (<= 0 i1@42@03))
    (or (= $k@43@03 $Perm.No) (< $Perm.No $k@43@03)))
  
  ))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               416
;  :arith-add-rows          119
;  :arith-assert-diseq      20
;  :arith-assert-lower      94
;  :arith-assert-upper      51
;  :arith-bound-prop        12
;  :arith-conflicts         12
;  :arith-eq-adapter        45
;  :arith-fixed-eqs         20
;  :arith-offset-eqs        8
;  :arith-pivots            75
;  :conflicts               27
;  :datatype-accessor-ax    24
;  :datatype-constructor-ax 26
;  :datatype-occurs-check   19
;  :datatype-splits         11
;  :decisions               34
;  :del-clause              257
;  :final-checks            10
;  :max-generation          3
;  :max-memory              4.77
;  :memory                  4.76
;  :minimized-lits          1
;  :mk-bool-var             973
;  :mk-clause               267
;  :num-allocs              167490
;  :num-checks              30
;  :propagations            124
;  :quant-instantiations    195
;  :rlimit-count            216197)
; Check receiver injectivity
(push) ; 4
(assert (not (forall ((i11@42@03 Int) (i12@42@03 Int)) (!
  (implies
    (and
      (and (and (< i11@42@03 V@12@03) (<= 0 i11@42@03)) (< $Perm.No $k@43@03))
      (and (and (< i12@42@03 V@12@03) (<= 0 i12@42@03)) (< $Perm.No $k@43@03))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i11@42@03)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i12@42@03)))
    (= i11@42@03 i12@42@03))
  
  :qid |option$array$-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               422
;  :arith-add-rows          121
;  :arith-assert-diseq      21
;  :arith-assert-lower      98
;  :arith-assert-upper      51
;  :arith-bound-prop        12
;  :arith-conflicts         12
;  :arith-eq-adapter        46
;  :arith-fixed-eqs         20
;  :arith-offset-eqs        8
;  :arith-pivots            75
;  :conflicts               28
;  :datatype-accessor-ax    24
;  :datatype-constructor-ax 26
;  :datatype-occurs-check   19
;  :datatype-splits         11
;  :decisions               34
;  :del-clause              263
;  :final-checks            10
;  :max-generation          3
;  :max-memory              4.78
;  :memory                  4.76
;  :minimized-lits          1
;  :mk-bool-var             990
;  :mk-clause               273
;  :num-allocs              167851
;  :num-checks              31
;  :propagations            124
;  :quant-instantiations    206
;  :rlimit-count            216894)
; Definitional axioms for inverse functions
(assert (forall ((i1@42@03 Int)) (!
  (implies
    (and (and (< i1@42@03 V@12@03) (<= 0 i1@42@03)) (< $Perm.No $k@43@03))
    (=
      (inv@44@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@42@03))
      i1@42@03))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@42@03))
  )))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and (< (inv@44@03 r) V@12@03) (<= 0 (inv@44@03 r)))
      (< $Perm.No $k@43@03))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) (inv@44@03 r))
      r))
  :pattern ((inv@44@03 r))
  :qid |option$array$-fctOfInv|)))
; Permissions are non-negative
(assert (forall ((i1@42@03 Int)) (!
  (<= $Perm.No $k@43@03)
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@42@03))
  :qid |option$array$-permAtLeastZero|)))
; Field permissions are at most one
(assert (forall ((i1@42@03 Int)) (!
  (<= $k@43@03 $Perm.Write)
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@42@03))
  :qid |option$array$-permAtMostOne|)))
; Permission implies non-null receiver
(assert (forall ((i1@42@03 Int)) (!
  (implies
    (and (and (< i1@42@03 V@12@03) (<= 0 i1@42@03)) (< $Perm.No $k@43@03))
    (not
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@42@03)
        $Ref.null)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@42@03))
  :qid |option$array$-permImpliesNonNull|)))
(declare-const sm@45@03 $FVF<option<array>>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@44@03 r) V@12@03) (<= 0 (inv@44@03 r)))
      (< $Perm.No $k@43@03)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@45@03  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@41@03))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@45@03  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@41@03))))) r))
  :qid |qp.fvfValDef12|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@41@03))))) r) r)
  :pattern (($FVF.lookup_option$array$ (as sm@45@03  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef13|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@44@03 r) V@12@03) (<= 0 (inv@44@03 r)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@45@03  $FVF<option<array>>) r) r))
  :pattern ((inv@44@03 r))
  )))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@41@03))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@41@03)))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@41@03))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@41@03)))))
  $Snap.unit))
; [eval] exc == null ==> (forall i1: Int :: { aloc(opt_get1(Gf), i1) } 0 <= i1 && i1 < V ==> aloc(opt_get1(Gf), i1).option$array$ != (None(): option[array]))
; [eval] exc == null
(push) ; 4
(set-option :timeout 10)
(push) ; 5
(assert (not (not (= exc@16@03 $Ref.null))))
(check-sat)
; unknown
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               452
;  :arith-add-rows          121
;  :arith-assert-diseq      21
;  :arith-assert-lower      98
;  :arith-assert-upper      52
;  :arith-bound-prop        12
;  :arith-conflicts         12
;  :arith-eq-adapter        46
;  :arith-fixed-eqs         20
;  :arith-offset-eqs        8
;  :arith-pivots            75
;  :conflicts               28
;  :datatype-accessor-ax    25
;  :datatype-constructor-ax 32
;  :datatype-occurs-check   22
;  :datatype-splits         13
;  :decisions               40
;  :del-clause              263
;  :final-checks            12
;  :max-generation          3
;  :max-memory              4.79
;  :memory                  4.77
;  :minimized-lits          1
;  :mk-bool-var             1001
;  :mk-clause               273
;  :num-allocs              169554
;  :num-checks              32
;  :propagations            124
;  :quant-instantiations    206
;  :rlimit-count            219621)
; [then-branch: 19 | exc@16@03 == Null | live]
; [else-branch: 19 | exc@16@03 != Null | dead]
(push) ; 5
; [then-branch: 19 | exc@16@03 == Null]
; [eval] (forall i1: Int :: { aloc(opt_get1(Gf), i1) } 0 <= i1 && i1 < V ==> aloc(opt_get1(Gf), i1).option$array$ != (None(): option[array]))
(declare-const i1@46@03 Int)
(push) ; 6
; [eval] 0 <= i1 && i1 < V ==> aloc(opt_get1(Gf), i1).option$array$ != (None(): option[array])
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 7
; [then-branch: 20 | 0 <= i1@46@03 | live]
; [else-branch: 20 | !(0 <= i1@46@03) | live]
(push) ; 8
; [then-branch: 20 | 0 <= i1@46@03]
(assert (<= 0 i1@46@03))
; [eval] i1 < V
(pop) ; 8
(push) ; 8
; [else-branch: 20 | !(0 <= i1@46@03)]
(assert (not (<= 0 i1@46@03)))
(pop) ; 8
(pop) ; 7
; Joined path conditions
; Joined path conditions
(push) ; 7
; [then-branch: 21 | i1@46@03 < V@12@03 && 0 <= i1@46@03 | live]
; [else-branch: 21 | !(i1@46@03 < V@12@03 && 0 <= i1@46@03) | live]
(push) ; 8
; [then-branch: 21 | i1@46@03 < V@12@03 && 0 <= i1@46@03]
(assert (and (< i1@46@03 V@12@03) (<= 0 i1@46@03)))
; [eval] aloc(opt_get1(Gf), i1).option$array$ != (None(): option[array])
; [eval] aloc(opt_get1(Gf), i1)
; [eval] opt_get1(Gf)
(push) ; 9
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 9
; Joined path conditions
(push) ; 9
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 10
(assert (not (< i1@46@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               452
;  :arith-add-rows          121
;  :arith-assert-diseq      21
;  :arith-assert-lower      100
;  :arith-assert-upper      52
;  :arith-bound-prop        12
;  :arith-conflicts         12
;  :arith-eq-adapter        46
;  :arith-fixed-eqs         20
;  :arith-offset-eqs        8
;  :arith-pivots            75
;  :conflicts               28
;  :datatype-accessor-ax    25
;  :datatype-constructor-ax 32
;  :datatype-occurs-check   22
;  :datatype-splits         13
;  :decisions               40
;  :del-clause              263
;  :final-checks            12
;  :max-generation          3
;  :max-memory              4.79
;  :memory                  4.77
;  :minimized-lits          1
;  :mk-bool-var             1003
;  :mk-clause               273
;  :num-allocs              169657
;  :num-checks              33
;  :propagations            124
;  :quant-instantiations    206
;  :rlimit-count            219816)
(assert (< i1@46@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03))))
(pop) ; 9
; Joined path conditions
(assert (< i1@46@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@45@03  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@46@03)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@46@03)))
(push) ; 9
(assert (not (ite
  (and
    (<
      (inv@44@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@46@03))
      V@12@03)
    (<=
      0
      (inv@44@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@46@03))))
  (< $Perm.No $k@43@03)
  false)))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               461
;  :arith-add-rows          129
;  :arith-assert-diseq      21
;  :arith-assert-lower      102
;  :arith-assert-upper      55
;  :arith-bound-prop        14
;  :arith-conflicts         13
;  :arith-eq-adapter        48
;  :arith-fixed-eqs         22
;  :arith-offset-eqs        8
;  :arith-pivots            78
;  :conflicts               29
;  :datatype-accessor-ax    25
;  :datatype-constructor-ax 32
;  :datatype-occurs-check   22
;  :datatype-splits         13
;  :decisions               40
;  :del-clause              263
;  :final-checks            12
;  :max-generation          3
;  :max-memory              4.81
;  :memory                  4.79
;  :minimized-lits          1
;  :mk-bool-var             1051
;  :mk-clause               293
;  :num-allocs              170119
;  :num-checks              34
;  :propagations            125
;  :quant-instantiations    229
;  :rlimit-count            221185)
; [eval] (None(): option[array])
(pop) ; 8
(push) ; 8
; [else-branch: 21 | !(i1@46@03 < V@12@03 && 0 <= i1@46@03)]
(assert (not (and (< i1@46@03 V@12@03) (<= 0 i1@46@03))))
(pop) ; 8
(pop) ; 7
; Joined path conditions
(assert (implies
  (and (< i1@46@03 V@12@03) (<= 0 i1@46@03))
  (and
    (< i1@46@03 V@12@03)
    (<= 0 i1@46@03)
    (< i1@46@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@45@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@46@03)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@46@03)))))
; Joined path conditions
(pop) ; 6
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@46@03 Int)) (!
  (implies
    (and (< i1@46@03 V@12@03) (<= 0 i1@46@03))
    (and
      (< i1@46@03 V@12@03)
      (<= 0 i1@46@03)
      (< i1@46@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@45@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@46@03)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@46@03))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@46@03))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (implies
  (= exc@16@03 $Ref.null)
  (forall ((i1@46@03 Int)) (!
    (implies
      (and (< i1@46@03 V@12@03) (<= 0 i1@46@03))
      (and
        (< i1@46@03 V@12@03)
        (<= 0 i1@46@03)
        (< i1@46@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@45@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@46@03)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@46@03))))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@46@03))
    :qid |prog.l<no position>-aux|))))
(assert (implies
  (= exc@16@03 $Ref.null)
  (forall ((i1@46@03 Int)) (!
    (implies
      (and (< i1@46@03 V@12@03) (<= 0 i1@46@03))
      (not
        (=
          ($FVF.lookup_option$array$ (as sm@45@03  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@46@03))
          (as None<option<array>>  option<array>))))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@46@03))
    :qid |prog.l<no position>|))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@41@03)))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@41@03))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@41@03)))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@41@03))))))
  $Snap.unit))
; [eval] exc == null ==> (forall i1: Int :: { alen(opt_get1(aloc(opt_get1(Gf), i1).option$array$)) } 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(Gf), i1).option$array$)) == V)
; [eval] exc == null
(push) ; 4
(set-option :timeout 10)
(push) ; 5
(assert (not (not (= exc@16@03 $Ref.null))))
(check-sat)
; unknown
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               492
;  :arith-add-rows          132
;  :arith-assert-diseq      21
;  :arith-assert-lower      102
;  :arith-assert-upper      55
;  :arith-bound-prop        14
;  :arith-conflicts         13
;  :arith-eq-adapter        48
;  :arith-fixed-eqs         22
;  :arith-offset-eqs        8
;  :arith-pivots            81
;  :conflicts               29
;  :datatype-accessor-ax    26
;  :datatype-constructor-ax 38
;  :datatype-occurs-check   25
;  :datatype-splits         15
;  :decisions               46
;  :del-clause              283
;  :final-checks            14
;  :max-generation          3
;  :max-memory              4.82
;  :memory                  4.81
;  :minimized-lits          1
;  :mk-bool-var             1057
;  :mk-clause               293
;  :num-allocs              171220
;  :num-checks              35
;  :propagations            125
;  :quant-instantiations    229
;  :rlimit-count            222781)
; [then-branch: 22 | exc@16@03 == Null | live]
; [else-branch: 22 | exc@16@03 != Null | dead]
(push) ; 5
; [then-branch: 22 | exc@16@03 == Null]
; [eval] (forall i1: Int :: { alen(opt_get1(aloc(opt_get1(Gf), i1).option$array$)) } 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(Gf), i1).option$array$)) == V)
(declare-const i1@47@03 Int)
(push) ; 6
; [eval] 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(Gf), i1).option$array$)) == V
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 7
; [then-branch: 23 | 0 <= i1@47@03 | live]
; [else-branch: 23 | !(0 <= i1@47@03) | live]
(push) ; 8
; [then-branch: 23 | 0 <= i1@47@03]
(assert (<= 0 i1@47@03))
; [eval] i1 < V
(pop) ; 8
(push) ; 8
; [else-branch: 23 | !(0 <= i1@47@03)]
(assert (not (<= 0 i1@47@03)))
(pop) ; 8
(pop) ; 7
; Joined path conditions
; Joined path conditions
(push) ; 7
; [then-branch: 24 | i1@47@03 < V@12@03 && 0 <= i1@47@03 | live]
; [else-branch: 24 | !(i1@47@03 < V@12@03 && 0 <= i1@47@03) | live]
(push) ; 8
; [then-branch: 24 | i1@47@03 < V@12@03 && 0 <= i1@47@03]
(assert (and (< i1@47@03 V@12@03) (<= 0 i1@47@03)))
; [eval] alen(opt_get1(aloc(opt_get1(Gf), i1).option$array$)) == V
; [eval] alen(opt_get1(aloc(opt_get1(Gf), i1).option$array$))
; [eval] opt_get1(aloc(opt_get1(Gf), i1).option$array$)
; [eval] aloc(opt_get1(Gf), i1)
; [eval] opt_get1(Gf)
(push) ; 9
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 9
; Joined path conditions
(push) ; 9
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 10
(assert (not (< i1@47@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               492
;  :arith-add-rows          132
;  :arith-assert-diseq      21
;  :arith-assert-lower      104
;  :arith-assert-upper      55
;  :arith-bound-prop        14
;  :arith-conflicts         13
;  :arith-eq-adapter        48
;  :arith-fixed-eqs         22
;  :arith-offset-eqs        8
;  :arith-pivots            81
;  :conflicts               29
;  :datatype-accessor-ax    26
;  :datatype-constructor-ax 38
;  :datatype-occurs-check   25
;  :datatype-splits         15
;  :decisions               46
;  :del-clause              283
;  :final-checks            14
;  :max-generation          3
;  :max-memory              4.82
;  :memory                  4.81
;  :minimized-lits          1
;  :mk-bool-var             1059
;  :mk-clause               293
;  :num-allocs              171323
;  :num-checks              36
;  :propagations            125
;  :quant-instantiations    229
;  :rlimit-count            222976)
(assert (< i1@47@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03))))
(pop) ; 9
; Joined path conditions
(assert (< i1@47@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@45@03  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@47@03)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@47@03)))
(push) ; 9
(assert (not (ite
  (and
    (<
      (inv@44@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@47@03))
      V@12@03)
    (<=
      0
      (inv@44@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@47@03))))
  (< $Perm.No $k@43@03)
  false)))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               502
;  :arith-add-rows          140
;  :arith-assert-diseq      21
;  :arith-assert-lower      106
;  :arith-assert-upper      58
;  :arith-bound-prop        16
;  :arith-conflicts         14
;  :arith-eq-adapter        50
;  :arith-fixed-eqs         24
;  :arith-offset-eqs        8
;  :arith-pivots            84
;  :conflicts               30
;  :datatype-accessor-ax    26
;  :datatype-constructor-ax 38
;  :datatype-occurs-check   25
;  :datatype-splits         15
;  :decisions               46
;  :del-clause              283
;  :final-checks            14
;  :max-generation          3
;  :max-memory              4.83
;  :memory                  4.81
;  :minimized-lits          1
;  :mk-bool-var             1110
;  :mk-clause               313
;  :num-allocs              171766
;  :num-checks              37
;  :propagations            126
;  :quant-instantiations    254
;  :rlimit-count            224370)
(push) ; 9
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 10
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@45@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@47@03))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               502
;  :arith-add-rows          140
;  :arith-assert-diseq      21
;  :arith-assert-lower      106
;  :arith-assert-upper      58
;  :arith-bound-prop        16
;  :arith-conflicts         14
;  :arith-eq-adapter        50
;  :arith-fixed-eqs         24
;  :arith-offset-eqs        8
;  :arith-pivots            84
;  :conflicts               31
;  :datatype-accessor-ax    26
;  :datatype-constructor-ax 38
;  :datatype-occurs-check   25
;  :datatype-splits         15
;  :decisions               46
;  :del-clause              283
;  :final-checks            14
;  :max-generation          3
;  :max-memory              4.83
;  :memory                  4.81
;  :minimized-lits          1
;  :mk-bool-var             1110
;  :mk-clause               313
;  :num-allocs              171855
;  :num-checks              38
;  :propagations            126
;  :quant-instantiations    254
;  :rlimit-count            224465)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@45@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@47@03))
    (as None<option<array>>  option<array>))))
(pop) ; 9
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@45@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@47@03))
    (as None<option<array>>  option<array>))))
(pop) ; 8
(push) ; 8
; [else-branch: 24 | !(i1@47@03 < V@12@03 && 0 <= i1@47@03)]
(assert (not (and (< i1@47@03 V@12@03) (<= 0 i1@47@03))))
(pop) ; 8
(pop) ; 7
; Joined path conditions
(assert (implies
  (and (< i1@47@03 V@12@03) (<= 0 i1@47@03))
  (and
    (< i1@47@03 V@12@03)
    (<= 0 i1@47@03)
    (< i1@47@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@45@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@47@03)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@47@03))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@45@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@47@03))
        (as None<option<array>>  option<array>))))))
; Joined path conditions
(pop) ; 6
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@47@03 Int)) (!
  (implies
    (and (< i1@47@03 V@12@03) (<= 0 i1@47@03))
    (and
      (< i1@47@03 V@12@03)
      (<= 0 i1@47@03)
      (< i1@47@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@45@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@47@03)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@47@03))
      (not
        (=
          ($FVF.lookup_option$array$ (as sm@45@03  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@47@03))
          (as None<option<array>>  option<array>)))))
  :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@45@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@47@03)))))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (implies
  (= exc@16@03 $Ref.null)
  (forall ((i1@47@03 Int)) (!
    (implies
      (and (< i1@47@03 V@12@03) (<= 0 i1@47@03))
      (and
        (< i1@47@03 V@12@03)
        (<= 0 i1@47@03)
        (< i1@47@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@45@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@47@03)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@47@03))
        (not
          (=
            ($FVF.lookup_option$array$ (as sm@45@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@47@03))
            (as None<option<array>>  option<array>)))))
    :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@45@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@47@03)))))
    :qid |prog.l<no position>-aux|))))
(assert (implies
  (= exc@16@03 $Ref.null)
  (forall ((i1@47@03 Int)) (!
    (implies
      (and (< i1@47@03 V@12@03) (<= 0 i1@47@03))
      (=
        (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@45@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@47@03))))
        V@12@03))
    :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@45@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@47@03)))))
    :qid |prog.l<no position>|))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@41@03))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@41@03)))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@41@03))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@41@03)))))))
  $Snap.unit))
; [eval] exc == null ==> (forall i1: Int :: { aloc(opt_get1(Gf), i1) } (forall i2: Int :: { aloc(opt_get1(Gf), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(Gf), i1).option$array$ == aloc(opt_get1(Gf), i2).option$array$ ==> i1 == i2))
; [eval] exc == null
(push) ; 4
(set-option :timeout 10)
(push) ; 5
(assert (not (not (= exc@16@03 $Ref.null))))
(check-sat)
; unknown
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               534
;  :arith-add-rows          143
;  :arith-assert-diseq      21
;  :arith-assert-lower      106
;  :arith-assert-upper      58
;  :arith-bound-prop        16
;  :arith-conflicts         14
;  :arith-eq-adapter        50
;  :arith-fixed-eqs         24
;  :arith-offset-eqs        8
;  :arith-pivots            87
;  :conflicts               31
;  :datatype-accessor-ax    27
;  :datatype-constructor-ax 44
;  :datatype-occurs-check   28
;  :datatype-splits         17
;  :decisions               52
;  :del-clause              303
;  :final-checks            16
;  :max-generation          3
;  :max-memory              4.84
;  :memory                  4.82
;  :minimized-lits          1
;  :mk-bool-var             1116
;  :mk-clause               313
;  :num-allocs              172976
;  :num-checks              39
;  :propagations            126
;  :quant-instantiations    254
;  :rlimit-count            226166)
; [then-branch: 25 | exc@16@03 == Null | live]
; [else-branch: 25 | exc@16@03 != Null | dead]
(push) ; 5
; [then-branch: 25 | exc@16@03 == Null]
; [eval] (forall i1: Int :: { aloc(opt_get1(Gf), i1) } (forall i2: Int :: { aloc(opt_get1(Gf), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(Gf), i1).option$array$ == aloc(opt_get1(Gf), i2).option$array$ ==> i1 == i2))
(declare-const i1@48@03 Int)
(push) ; 6
; [eval] (forall i2: Int :: { aloc(opt_get1(Gf), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(Gf), i1).option$array$ == aloc(opt_get1(Gf), i2).option$array$ ==> i1 == i2)
(declare-const i2@49@03 Int)
(push) ; 7
; [eval] 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(Gf), i1).option$array$ == aloc(opt_get1(Gf), i2).option$array$ ==> i1 == i2
; [eval] 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(Gf), i1).option$array$ == aloc(opt_get1(Gf), i2).option$array$
; [eval] 0 <= i1
(push) ; 8
; [then-branch: 26 | 0 <= i1@48@03 | live]
; [else-branch: 26 | !(0 <= i1@48@03) | live]
(push) ; 9
; [then-branch: 26 | 0 <= i1@48@03]
(assert (<= 0 i1@48@03))
; [eval] i1 < V
(push) ; 10
; [then-branch: 27 | i1@48@03 < V@12@03 | live]
; [else-branch: 27 | !(i1@48@03 < V@12@03) | live]
(push) ; 11
; [then-branch: 27 | i1@48@03 < V@12@03]
(assert (< i1@48@03 V@12@03))
; [eval] 0 <= i2
(push) ; 12
; [then-branch: 28 | 0 <= i2@49@03 | live]
; [else-branch: 28 | !(0 <= i2@49@03) | live]
(push) ; 13
; [then-branch: 28 | 0 <= i2@49@03]
(assert (<= 0 i2@49@03))
; [eval] i2 < V
(push) ; 14
; [then-branch: 29 | i2@49@03 < V@12@03 | live]
; [else-branch: 29 | !(i2@49@03 < V@12@03) | live]
(push) ; 15
; [then-branch: 29 | i2@49@03 < V@12@03]
(assert (< i2@49@03 V@12@03))
; [eval] aloc(opt_get1(Gf), i1).option$array$ == aloc(opt_get1(Gf), i2).option$array$
; [eval] aloc(opt_get1(Gf), i1)
; [eval] opt_get1(Gf)
(push) ; 16
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 16
; Joined path conditions
(push) ; 16
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 17
(assert (not (< i1@48@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))))
(check-sat)
; unsat
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               534
;  :arith-add-rows          143
;  :arith-assert-diseq      21
;  :arith-assert-lower      110
;  :arith-assert-upper      58
;  :arith-bound-prop        16
;  :arith-conflicts         14
;  :arith-eq-adapter        50
;  :arith-fixed-eqs         24
;  :arith-offset-eqs        8
;  :arith-pivots            88
;  :conflicts               31
;  :datatype-accessor-ax    27
;  :datatype-constructor-ax 44
;  :datatype-occurs-check   28
;  :datatype-splits         17
;  :decisions               52
;  :del-clause              303
;  :final-checks            16
;  :max-generation          3
;  :max-memory              4.84
;  :memory                  4.83
;  :minimized-lits          1
;  :mk-bool-var             1120
;  :mk-clause               313
;  :num-allocs              173256
;  :num-checks              40
;  :propagations            126
;  :quant-instantiations    254
;  :rlimit-count            226510)
(assert (< i1@48@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03))))
(pop) ; 16
; Joined path conditions
(assert (< i1@48@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@45@03  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@48@03)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@48@03)))
(push) ; 16
(assert (not (ite
  (and
    (<
      (inv@44@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@48@03))
      V@12@03)
    (<=
      0
      (inv@44@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@48@03))))
  (< $Perm.No $k@43@03)
  false)))
(check-sat)
; unsat
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               544
;  :arith-add-rows          151
;  :arith-assert-diseq      21
;  :arith-assert-lower      112
;  :arith-assert-upper      61
;  :arith-bound-prop        18
;  :arith-conflicts         15
;  :arith-eq-adapter        52
;  :arith-fixed-eqs         26
;  :arith-offset-eqs        8
;  :arith-pivots            91
;  :conflicts               32
;  :datatype-accessor-ax    27
;  :datatype-constructor-ax 44
;  :datatype-occurs-check   28
;  :datatype-splits         17
;  :decisions               52
;  :del-clause              303
;  :final-checks            16
;  :max-generation          3
;  :max-memory              4.84
;  :memory                  4.82
;  :minimized-lits          1
;  :mk-bool-var             1171
;  :mk-clause               333
;  :num-allocs              173698
;  :num-checks              41
;  :propagations            127
;  :quant-instantiations    279
;  :rlimit-count            227904)
; [eval] aloc(opt_get1(Gf), i2)
; [eval] opt_get1(Gf)
(push) ; 16
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 16
; Joined path conditions
(push) ; 16
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 17
(assert (not (< i2@49@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))))
(check-sat)
; unsat
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               544
;  :arith-add-rows          151
;  :arith-assert-diseq      21
;  :arith-assert-lower      112
;  :arith-assert-upper      61
;  :arith-bound-prop        18
;  :arith-conflicts         15
;  :arith-eq-adapter        52
;  :arith-fixed-eqs         26
;  :arith-offset-eqs        8
;  :arith-pivots            91
;  :conflicts               32
;  :datatype-accessor-ax    27
;  :datatype-constructor-ax 44
;  :datatype-occurs-check   28
;  :datatype-splits         17
;  :decisions               52
;  :del-clause              303
;  :final-checks            16
;  :max-generation          3
;  :max-memory              4.84
;  :memory                  4.82
;  :minimized-lits          1
;  :mk-bool-var             1171
;  :mk-clause               333
;  :num-allocs              173724
;  :num-checks              42
;  :propagations            127
;  :quant-instantiations    279
;  :rlimit-count            227934)
(assert (< i2@49@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03))))
(pop) ; 16
; Joined path conditions
(assert (< i2@49@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@45@03  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@49@03)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@49@03)))
(push) ; 16
(assert (not (ite
  (and
    (<
      (inv@44@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@49@03))
      V@12@03)
    (<=
      0
      (inv@44@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@49@03))))
  (< $Perm.No $k@43@03)
  false)))
(check-sat)
; unsat
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               561
;  :arith-add-rows          165
;  :arith-assert-diseq      21
;  :arith-assert-lower      114
;  :arith-assert-upper      64
;  :arith-bound-prop        21
;  :arith-conflicts         16
;  :arith-eq-adapter        55
;  :arith-fixed-eqs         28
;  :arith-offset-eqs        13
;  :arith-pivots            94
;  :conflicts               33
;  :datatype-accessor-ax    27
;  :datatype-constructor-ax 44
;  :datatype-occurs-check   28
;  :datatype-splits         17
;  :decisions               52
;  :del-clause              303
;  :final-checks            16
;  :max-generation          3
;  :max-memory              4.87
;  :memory                  4.86
;  :minimized-lits          1
;  :mk-bool-var             1230
;  :mk-clause               365
;  :num-allocs              174224
;  :num-checks              43
;  :propagations            137
;  :quant-instantiations    304
;  :rlimit-count            229467)
(pop) ; 15
(push) ; 15
; [else-branch: 29 | !(i2@49@03 < V@12@03)]
(assert (not (< i2@49@03 V@12@03)))
(pop) ; 15
(pop) ; 14
; Joined path conditions
(assert (implies
  (< i2@49@03 V@12@03)
  (and
    (< i2@49@03 V@12@03)
    (< i1@48@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@45@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@48@03)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@48@03))
    (< i2@49@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@45@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@49@03)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@49@03)))))
; Joined path conditions
(pop) ; 13
(push) ; 13
; [else-branch: 28 | !(0 <= i2@49@03)]
(assert (not (<= 0 i2@49@03)))
(pop) ; 13
(pop) ; 12
; Joined path conditions
(assert (implies
  (<= 0 i2@49@03)
  (and
    (<= 0 i2@49@03)
    (implies
      (< i2@49@03 V@12@03)
      (and
        (< i2@49@03 V@12@03)
        (< i1@48@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@45@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@48@03)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@48@03))
        (< i2@49@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@45@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@49@03)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@49@03)))))))
; Joined path conditions
(pop) ; 11
(push) ; 11
; [else-branch: 27 | !(i1@48@03 < V@12@03)]
(assert (not (< i1@48@03 V@12@03)))
(pop) ; 11
(pop) ; 10
; Joined path conditions
(assert (implies
  (< i1@48@03 V@12@03)
  (and
    (< i1@48@03 V@12@03)
    (implies
      (<= 0 i2@49@03)
      (and
        (<= 0 i2@49@03)
        (implies
          (< i2@49@03 V@12@03)
          (and
            (< i2@49@03 V@12@03)
            (< i1@48@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@45@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@48@03)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@48@03))
            (< i2@49@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@45@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@49@03)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@49@03)))))))))
; Joined path conditions
(pop) ; 9
(push) ; 9
; [else-branch: 26 | !(0 <= i1@48@03)]
(assert (not (<= 0 i1@48@03)))
(pop) ; 9
(pop) ; 8
; Joined path conditions
(assert (implies
  (<= 0 i1@48@03)
  (and
    (<= 0 i1@48@03)
    (implies
      (< i1@48@03 V@12@03)
      (and
        (< i1@48@03 V@12@03)
        (implies
          (<= 0 i2@49@03)
          (and
            (<= 0 i2@49@03)
            (implies
              (< i2@49@03 V@12@03)
              (and
                (< i2@49@03 V@12@03)
                (< i1@48@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@45@03  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@48@03)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@48@03))
                (< i2@49@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@45@03  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@49@03)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@49@03)))))))))))
; Joined path conditions
(push) ; 8
; [then-branch: 30 | Lookup(option$array$,sm@45@03,aloc((_, _), opt_get1(_, Gf@11@03), i1@48@03)) == Lookup(option$array$,sm@45@03,aloc((_, _), opt_get1(_, Gf@11@03), i2@49@03)) && i2@49@03 < V@12@03 && 0 <= i2@49@03 && i1@48@03 < V@12@03 && 0 <= i1@48@03 | live]
; [else-branch: 30 | !(Lookup(option$array$,sm@45@03,aloc((_, _), opt_get1(_, Gf@11@03), i1@48@03)) == Lookup(option$array$,sm@45@03,aloc((_, _), opt_get1(_, Gf@11@03), i2@49@03)) && i2@49@03 < V@12@03 && 0 <= i2@49@03 && i1@48@03 < V@12@03 && 0 <= i1@48@03) | live]
(push) ; 9
; [then-branch: 30 | Lookup(option$array$,sm@45@03,aloc((_, _), opt_get1(_, Gf@11@03), i1@48@03)) == Lookup(option$array$,sm@45@03,aloc((_, _), opt_get1(_, Gf@11@03), i2@49@03)) && i2@49@03 < V@12@03 && 0 <= i2@49@03 && i1@48@03 < V@12@03 && 0 <= i1@48@03]
(assert (and
  (and
    (and
      (and
        (=
          ($FVF.lookup_option$array$ (as sm@45@03  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@48@03))
          ($FVF.lookup_option$array$ (as sm@45@03  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@49@03)))
        (< i2@49@03 V@12@03))
      (<= 0 i2@49@03))
    (< i1@48@03 V@12@03))
  (<= 0 i1@48@03)))
; [eval] i1 == i2
(pop) ; 9
(push) ; 9
; [else-branch: 30 | !(Lookup(option$array$,sm@45@03,aloc((_, _), opt_get1(_, Gf@11@03), i1@48@03)) == Lookup(option$array$,sm@45@03,aloc((_, _), opt_get1(_, Gf@11@03), i2@49@03)) && i2@49@03 < V@12@03 && 0 <= i2@49@03 && i1@48@03 < V@12@03 && 0 <= i1@48@03)]
(assert (not
  (and
    (and
      (and
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@45@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@48@03))
            ($FVF.lookup_option$array$ (as sm@45@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@49@03)))
          (< i2@49@03 V@12@03))
        (<= 0 i2@49@03))
      (< i1@48@03 V@12@03))
    (<= 0 i1@48@03))))
(pop) ; 9
(pop) ; 8
; Joined path conditions
(assert (implies
  (and
    (and
      (and
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@45@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@48@03))
            ($FVF.lookup_option$array$ (as sm@45@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@49@03)))
          (< i2@49@03 V@12@03))
        (<= 0 i2@49@03))
      (< i1@48@03 V@12@03))
    (<= 0 i1@48@03))
  (and
    (=
      ($FVF.lookup_option$array$ (as sm@45@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@48@03))
      ($FVF.lookup_option$array$ (as sm@45@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@49@03)))
    (< i2@49@03 V@12@03)
    (<= 0 i2@49@03)
    (< i1@48@03 V@12@03)
    (<= 0 i1@48@03))))
; Joined path conditions
(pop) ; 7
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i2@49@03 Int)) (!
  (and
    (implies
      (<= 0 i1@48@03)
      (and
        (<= 0 i1@48@03)
        (implies
          (< i1@48@03 V@12@03)
          (and
            (< i1@48@03 V@12@03)
            (implies
              (<= 0 i2@49@03)
              (and
                (<= 0 i2@49@03)
                (implies
                  (< i2@49@03 V@12@03)
                  (and
                    (< i2@49@03 V@12@03)
                    (< i1@48@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))
                    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@45@03  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@48@03)) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@48@03))
                    (< i2@49@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))
                    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@45@03  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@49@03)) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@49@03))))))))))
    (implies
      (and
        (and
          (and
            (and
              (=
                ($FVF.lookup_option$array$ (as sm@45@03  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@48@03))
                ($FVF.lookup_option$array$ (as sm@45@03  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@49@03)))
              (< i2@49@03 V@12@03))
            (<= 0 i2@49@03))
          (< i1@48@03 V@12@03))
        (<= 0 i1@48@03))
      (and
        (=
          ($FVF.lookup_option$array$ (as sm@45@03  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@48@03))
          ($FVF.lookup_option$array$ (as sm@45@03  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@49@03)))
        (< i2@49@03 V@12@03)
        (<= 0 i2@49@03)
        (< i1@48@03 V@12@03)
        (<= 0 i1@48@03))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@49@03))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 6
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@48@03 Int)) (!
  (forall ((i2@49@03 Int)) (!
    (and
      (implies
        (<= 0 i1@48@03)
        (and
          (<= 0 i1@48@03)
          (implies
            (< i1@48@03 V@12@03)
            (and
              (< i1@48@03 V@12@03)
              (implies
                (<= 0 i2@49@03)
                (and
                  (<= 0 i2@49@03)
                  (implies
                    (< i2@49@03 V@12@03)
                    (and
                      (< i2@49@03 V@12@03)
                      (< i1@48@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))
                      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@45@03  $FVF<option<array>>) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@48@03)) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@48@03))
                      (< i2@49@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))
                      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@45@03  $FVF<option<array>>) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@49@03)) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@49@03))))))))))
      (implies
        (and
          (and
            (and
              (and
                (=
                  ($FVF.lookup_option$array$ (as sm@45@03  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@48@03))
                  ($FVF.lookup_option$array$ (as sm@45@03  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@49@03)))
                (< i2@49@03 V@12@03))
              (<= 0 i2@49@03))
            (< i1@48@03 V@12@03))
          (<= 0 i1@48@03))
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@45@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@48@03))
            ($FVF.lookup_option$array$ (as sm@45@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@49@03)))
          (< i2@49@03 V@12@03)
          (<= 0 i2@49@03)
          (< i1@48@03 V@12@03)
          (<= 0 i1@48@03))))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@49@03))
    :qid |prog.l<no position>-aux|))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@48@03))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (implies
  (= exc@16@03 $Ref.null)
  (forall ((i1@48@03 Int)) (!
    (forall ((i2@49@03 Int)) (!
      (and
        (implies
          (<= 0 i1@48@03)
          (and
            (<= 0 i1@48@03)
            (implies
              (< i1@48@03 V@12@03)
              (and
                (< i1@48@03 V@12@03)
                (implies
                  (<= 0 i2@49@03)
                  (and
                    (<= 0 i2@49@03)
                    (implies
                      (< i2@49@03 V@12@03)
                      (and
                        (< i2@49@03 V@12@03)
                        (< i1@48@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))
                        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@45@03  $FVF<option<array>>) (aloc ($Snap.combine
                          $Snap.unit
                          $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@48@03)) (aloc ($Snap.combine
                          $Snap.unit
                          $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@48@03))
                        (< i2@49@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))
                        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@45@03  $FVF<option<array>>) (aloc ($Snap.combine
                          $Snap.unit
                          $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@49@03)) (aloc ($Snap.combine
                          $Snap.unit
                          $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@49@03))))))))))
        (implies
          (and
            (and
              (and
                (and
                  (=
                    ($FVF.lookup_option$array$ (as sm@45@03  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@48@03))
                    ($FVF.lookup_option$array$ (as sm@45@03  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@49@03)))
                  (< i2@49@03 V@12@03))
                (<= 0 i2@49@03))
              (< i1@48@03 V@12@03))
            (<= 0 i1@48@03))
          (and
            (=
              ($FVF.lookup_option$array$ (as sm@45@03  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@48@03))
              ($FVF.lookup_option$array$ (as sm@45@03  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@49@03)))
            (< i2@49@03 V@12@03)
            (<= 0 i2@49@03)
            (< i1@48@03 V@12@03)
            (<= 0 i1@48@03))))
      :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@49@03))
      :qid |prog.l<no position>-aux|))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@48@03))
    :qid |prog.l<no position>-aux|))))
(assert (implies
  (= exc@16@03 $Ref.null)
  (forall ((i1@48@03 Int)) (!
    (forall ((i2@49@03 Int)) (!
      (implies
        (and
          (and
            (and
              (and
                (=
                  ($FVF.lookup_option$array$ (as sm@45@03  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@48@03))
                  ($FVF.lookup_option$array$ (as sm@45@03  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@49@03)))
                (< i2@49@03 V@12@03))
              (<= 0 i2@49@03))
            (< i1@48@03 V@12@03))
          (<= 0 i1@48@03))
        (= i1@48@03 i2@49@03))
      :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@49@03))
      :qid |prog.l<no position>|))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@48@03))
    :qid |prog.l<no position>|))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@41@03)))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@41@03))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@41@03)))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@41@03))))))))
  $Snap.unit))
; [eval] exc == null ==> p != (None(): option[array])
; [eval] exc == null
(push) ; 4
(set-option :timeout 10)
(push) ; 5
(assert (not (not (= exc@16@03 $Ref.null))))
(check-sat)
; unknown
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               594
;  :arith-add-rows          171
;  :arith-assert-diseq      21
;  :arith-assert-lower      114
;  :arith-assert-upper      64
;  :arith-bound-prop        21
;  :arith-conflicts         16
;  :arith-eq-adapter        55
;  :arith-fixed-eqs         28
;  :arith-offset-eqs        13
;  :arith-pivots            100
;  :conflicts               33
;  :datatype-accessor-ax    28
;  :datatype-constructor-ax 50
;  :datatype-occurs-check   31
;  :datatype-splits         19
;  :decisions               58
;  :del-clause              379
;  :final-checks            18
;  :max-generation          3
;  :max-memory              4.88
;  :memory                  4.87
;  :minimized-lits          1
;  :mk-bool-var             1249
;  :mk-clause               389
;  :num-allocs              175905
;  :num-checks              44
;  :propagations            137
;  :quant-instantiations    304
;  :rlimit-count            232700)
; [then-branch: 31 | exc@16@03 == Null | live]
; [else-branch: 31 | exc@16@03 != Null | dead]
(push) ; 5
; [then-branch: 31 | exc@16@03 == Null]
; [eval] p != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (implies
  (= exc@16@03 $Ref.null)
  (not (= p@15@03 (as None<option<array>>  option<array>)))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@41@03))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@41@03)))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@41@03))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@41@03)))))))))
  $Snap.unit))
; [eval] exc == null ==> alen(opt_get1(p)) == V
; [eval] exc == null
(push) ; 4
(push) ; 5
(assert (not (not (= exc@16@03 $Ref.null))))
(check-sat)
; unknown
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               628
;  :arith-add-rows          171
;  :arith-assert-diseq      21
;  :arith-assert-lower      114
;  :arith-assert-upper      64
;  :arith-bound-prop        21
;  :arith-conflicts         16
;  :arith-eq-adapter        55
;  :arith-fixed-eqs         28
;  :arith-offset-eqs        13
;  :arith-pivots            100
;  :conflicts               33
;  :datatype-accessor-ax    29
;  :datatype-constructor-ax 56
;  :datatype-occurs-check   34
;  :datatype-splits         21
;  :decisions               64
;  :del-clause              379
;  :final-checks            20
;  :max-generation          3
;  :max-memory              4.88
;  :memory                  4.87
;  :minimized-lits          1
;  :mk-bool-var             1253
;  :mk-clause               389
;  :num-allocs              176657
;  :num-checks              45
;  :propagations            137
;  :quant-instantiations    304
;  :rlimit-count            233517)
; [then-branch: 32 | exc@16@03 == Null | live]
; [else-branch: 32 | exc@16@03 != Null | dead]
(push) ; 5
; [then-branch: 32 | exc@16@03 == Null]
; [eval] alen(opt_get1(p)) == V
; [eval] alen(opt_get1(p))
; [eval] opt_get1(p)
(push) ; 6
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 6
; Joined path conditions
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (implies
  (= exc@16@03 $Ref.null)
  (= (alen<Int> (opt_get1 $Snap.unit p@15@03)) V@12@03)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@41@03)))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@41@03))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@41@03)))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@41@03))))))))))
  $Snap.unit))
; [eval] exc == null ==> 0 <= s
; [eval] exc == null
(push) ; 4
(push) ; 5
(assert (not (not (= exc@16@03 $Ref.null))))
(check-sat)
; unknown
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               663
;  :arith-add-rows          171
;  :arith-assert-diseq      21
;  :arith-assert-lower      114
;  :arith-assert-upper      64
;  :arith-bound-prop        21
;  :arith-conflicts         16
;  :arith-eq-adapter        55
;  :arith-fixed-eqs         28
;  :arith-offset-eqs        13
;  :arith-pivots            100
;  :conflicts               33
;  :datatype-accessor-ax    30
;  :datatype-constructor-ax 62
;  :datatype-occurs-check   37
;  :datatype-splits         23
;  :decisions               70
;  :del-clause              379
;  :final-checks            22
;  :max-generation          3
;  :max-memory              4.88
;  :memory                  4.87
;  :minimized-lits          1
;  :mk-bool-var             1257
;  :mk-clause               389
;  :num-allocs              177419
;  :num-checks              46
;  :propagations            137
;  :quant-instantiations    304
;  :rlimit-count            234352)
; [then-branch: 33 | exc@16@03 == Null | live]
; [else-branch: 33 | exc@16@03 != Null | dead]
(push) ; 5
; [then-branch: 33 | exc@16@03 == Null]
; [eval] 0 <= s
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (implies (= exc@16@03 $Ref.null) (<= 0 s@13@03)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@41@03))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@41@03)))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@41@03))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@41@03)))))))))))
  $Snap.unit))
; [eval] exc == null ==> s < V
; [eval] exc == null
(push) ; 4
(push) ; 5
(assert (not (not (= exc@16@03 $Ref.null))))
(check-sat)
; unknown
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               699
;  :arith-add-rows          171
;  :arith-assert-diseq      21
;  :arith-assert-lower      114
;  :arith-assert-upper      64
;  :arith-bound-prop        21
;  :arith-conflicts         16
;  :arith-eq-adapter        55
;  :arith-fixed-eqs         28
;  :arith-offset-eqs        13
;  :arith-pivots            100
;  :conflicts               33
;  :datatype-accessor-ax    31
;  :datatype-constructor-ax 68
;  :datatype-occurs-check   40
;  :datatype-splits         25
;  :decisions               76
;  :del-clause              379
;  :final-checks            24
;  :max-generation          3
;  :max-memory              4.88
;  :memory                  4.87
;  :minimized-lits          1
;  :mk-bool-var             1261
;  :mk-clause               389
;  :num-allocs              178180
;  :num-checks              47
;  :propagations            137
;  :quant-instantiations    304
;  :rlimit-count            235202)
; [then-branch: 34 | exc@16@03 == Null | live]
; [else-branch: 34 | exc@16@03 != Null | dead]
(push) ; 5
; [then-branch: 34 | exc@16@03 == Null]
; [eval] s < V
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (implies (= exc@16@03 $Ref.null) (< s@13@03 V@12@03)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@41@03)))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@41@03))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@41@03)))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@41@03))))))))))))
  $Snap.unit))
; [eval] exc == null ==> 0 <= t
; [eval] exc == null
(push) ; 4
(push) ; 5
(assert (not (not (= exc@16@03 $Ref.null))))
(check-sat)
; unknown
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               736
;  :arith-add-rows          171
;  :arith-assert-diseq      21
;  :arith-assert-lower      114
;  :arith-assert-upper      64
;  :arith-bound-prop        21
;  :arith-conflicts         16
;  :arith-eq-adapter        55
;  :arith-fixed-eqs         28
;  :arith-offset-eqs        13
;  :arith-pivots            100
;  :conflicts               33
;  :datatype-accessor-ax    32
;  :datatype-constructor-ax 74
;  :datatype-occurs-check   43
;  :datatype-splits         27
;  :decisions               82
;  :del-clause              379
;  :final-checks            26
;  :max-generation          3
;  :max-memory              4.89
;  :memory                  4.87
;  :minimized-lits          1
;  :mk-bool-var             1265
;  :mk-clause               389
;  :num-allocs              178955
;  :num-checks              48
;  :propagations            137
;  :quant-instantiations    304
;  :rlimit-count            236070)
; [then-branch: 35 | exc@16@03 == Null | live]
; [else-branch: 35 | exc@16@03 != Null | dead]
(push) ; 5
; [then-branch: 35 | exc@16@03 == Null]
; [eval] 0 <= t
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (implies (= exc@16@03 $Ref.null) (<= 0 t@14@03)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@41@03))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@41@03)))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@41@03))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@41@03)))))))))))))
  $Snap.unit))
; [eval] exc == null ==> t < V
; [eval] exc == null
(push) ; 4
(push) ; 5
(assert (not (not (= exc@16@03 $Ref.null))))
(check-sat)
; unknown
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               774
;  :arith-add-rows          171
;  :arith-assert-diseq      21
;  :arith-assert-lower      114
;  :arith-assert-upper      64
;  :arith-bound-prop        21
;  :arith-conflicts         16
;  :arith-eq-adapter        55
;  :arith-fixed-eqs         28
;  :arith-offset-eqs        13
;  :arith-pivots            100
;  :conflicts               33
;  :datatype-accessor-ax    33
;  :datatype-constructor-ax 80
;  :datatype-occurs-check   46
;  :datatype-splits         29
;  :decisions               88
;  :del-clause              379
;  :final-checks            28
;  :max-generation          3
;  :max-memory              4.89
;  :memory                  4.87
;  :minimized-lits          1
;  :mk-bool-var             1269
;  :mk-clause               389
;  :num-allocs              179723
;  :num-checks              49
;  :propagations            137
;  :quant-instantiations    304
;  :rlimit-count            236946)
; [then-branch: 36 | exc@16@03 == Null | live]
; [else-branch: 36 | exc@16@03 != Null | dead]
(push) ; 5
; [then-branch: 36 | exc@16@03 == Null]
; [eval] t < V
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (implies (= exc@16@03 $Ref.null) (< t@14@03 V@12@03)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@41@03)))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@41@03))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@41@03)))))))))))))))))
; [eval] exc == null
(push) ; 4
(assert (not (not (= exc@16@03 $Ref.null))))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               814
;  :arith-add-rows          171
;  :arith-assert-diseq      21
;  :arith-assert-lower      114
;  :arith-assert-upper      64
;  :arith-bound-prop        21
;  :arith-conflicts         16
;  :arith-eq-adapter        55
;  :arith-fixed-eqs         28
;  :arith-offset-eqs        13
;  :arith-pivots            100
;  :conflicts               33
;  :datatype-accessor-ax    34
;  :datatype-constructor-ax 87
;  :datatype-occurs-check   49
;  :datatype-splits         32
;  :decisions               95
;  :del-clause              379
;  :final-checks            30
;  :max-generation          3
;  :max-memory              4.89
;  :memory                  4.87
;  :minimized-lits          1
;  :mk-bool-var             1273
;  :mk-clause               389
;  :num-allocs              180495
;  :num-checks              50
;  :propagations            137
;  :quant-instantiations    304
;  :rlimit-count            237823)
; [then-branch: 37 | exc@16@03 == Null | live]
; [else-branch: 37 | exc@16@03 != Null | dead]
(push) ; 4
; [then-branch: 37 | exc@16@03 == Null]
(declare-const i1@50@03 Int)
(declare-const j1@51@03 Int)
(push) ; 5
; [eval] 0 <= i1 && i1 < V && (0 <= j1 && j1 < V)
; [eval] 0 <= i1
(push) ; 6
; [then-branch: 38 | 0 <= i1@50@03 | live]
; [else-branch: 38 | !(0 <= i1@50@03) | live]
(push) ; 7
; [then-branch: 38 | 0 <= i1@50@03]
(assert (<= 0 i1@50@03))
; [eval] i1 < V
(push) ; 8
; [then-branch: 39 | i1@50@03 < V@12@03 | live]
; [else-branch: 39 | !(i1@50@03 < V@12@03) | live]
(push) ; 9
; [then-branch: 39 | i1@50@03 < V@12@03]
(assert (< i1@50@03 V@12@03))
; [eval] 0 <= j1
(push) ; 10
; [then-branch: 40 | 0 <= j1@51@03 | live]
; [else-branch: 40 | !(0 <= j1@51@03) | live]
(push) ; 11
; [then-branch: 40 | 0 <= j1@51@03]
(assert (<= 0 j1@51@03))
; [eval] j1 < V
(pop) ; 11
(push) ; 11
; [else-branch: 40 | !(0 <= j1@51@03)]
(assert (not (<= 0 j1@51@03)))
(pop) ; 11
(pop) ; 10
; Joined path conditions
; Joined path conditions
(pop) ; 9
(push) ; 9
; [else-branch: 39 | !(i1@50@03 < V@12@03)]
(assert (not (< i1@50@03 V@12@03)))
(pop) ; 9
(pop) ; 8
; Joined path conditions
; Joined path conditions
(pop) ; 7
(push) ; 7
; [else-branch: 38 | !(0 <= i1@50@03)]
(assert (not (<= 0 i1@50@03)))
(pop) ; 7
(pop) ; 6
; Joined path conditions
; Joined path conditions
(assert (and
  (and (and (< j1@51@03 V@12@03) (<= 0 j1@51@03)) (< i1@50@03 V@12@03))
  (<= 0 i1@50@03)))
; [eval] aloc(opt_get1(aloc(opt_get1(Gf), i1).option$array$), j1)
; [eval] opt_get1(aloc(opt_get1(Gf), i1).option$array$)
; [eval] aloc(opt_get1(Gf), i1)
; [eval] opt_get1(Gf)
(push) ; 6
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 6
; Joined path conditions
(push) ; 6
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 7
(assert (not (< i1@50@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               814
;  :arith-add-rows          171
;  :arith-assert-diseq      21
;  :arith-assert-lower      120
;  :arith-assert-upper      64
;  :arith-bound-prop        21
;  :arith-conflicts         16
;  :arith-eq-adapter        55
;  :arith-fixed-eqs         28
;  :arith-offset-eqs        13
;  :arith-pivots            101
;  :conflicts               33
;  :datatype-accessor-ax    34
;  :datatype-constructor-ax 87
;  :datatype-occurs-check   49
;  :datatype-splits         32
;  :decisions               95
;  :del-clause              379
;  :final-checks            30
;  :max-generation          3
;  :max-memory              4.89
;  :memory                  4.89
;  :minimized-lits          1
;  :mk-bool-var             1279
;  :mk-clause               389
;  :num-allocs              180773
;  :num-checks              51
;  :propagations            137
;  :quant-instantiations    304
;  :rlimit-count            238297)
(assert (< i1@50@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03))))
(pop) ; 6
; Joined path conditions
(assert (< i1@50@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@45@03  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@50@03)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@50@03)))
(push) ; 6
(assert (not (ite
  (and
    (<
      (inv@44@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@50@03))
      V@12@03)
    (<=
      0
      (inv@44@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@50@03))))
  (< $Perm.No $k@43@03)
  false)))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               824
;  :arith-add-rows          179
;  :arith-assert-diseq      21
;  :arith-assert-lower      122
;  :arith-assert-upper      67
;  :arith-bound-prop        23
;  :arith-conflicts         17
;  :arith-eq-adapter        57
;  :arith-fixed-eqs         30
;  :arith-offset-eqs        13
;  :arith-pivots            104
;  :conflicts               34
;  :datatype-accessor-ax    34
;  :datatype-constructor-ax 87
;  :datatype-occurs-check   49
;  :datatype-splits         32
;  :decisions               95
;  :del-clause              379
;  :final-checks            30
;  :max-generation          3
;  :max-memory              4.91
;  :memory                  4.90
;  :minimized-lits          1
;  :mk-bool-var             1339
;  :mk-clause               409
;  :num-allocs              181268
;  :num-checks              52
;  :propagations            138
;  :quant-instantiations    332
;  :rlimit-count            240008)
(push) ; 6
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 7
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@45@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@50@03))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               824
;  :arith-add-rows          179
;  :arith-assert-diseq      21
;  :arith-assert-lower      122
;  :arith-assert-upper      67
;  :arith-bound-prop        23
;  :arith-conflicts         17
;  :arith-eq-adapter        57
;  :arith-fixed-eqs         30
;  :arith-offset-eqs        13
;  :arith-pivots            104
;  :conflicts               35
;  :datatype-accessor-ax    34
;  :datatype-constructor-ax 87
;  :datatype-occurs-check   49
;  :datatype-splits         32
;  :decisions               95
;  :del-clause              379
;  :final-checks            30
;  :max-generation          3
;  :max-memory              4.91
;  :memory                  4.90
;  :minimized-lits          1
;  :mk-bool-var             1339
;  :mk-clause               409
;  :num-allocs              181357
;  :num-checks              53
;  :propagations            138
;  :quant-instantiations    332
;  :rlimit-count            240103)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@45@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@50@03))
    (as None<option<array>>  option<array>))))
(pop) ; 6
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@45@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@50@03))
    (as None<option<array>>  option<array>))))
(push) ; 6
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 7
(assert (not (<
  j1@51@03
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@45@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@50@03)))))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               828
;  :arith-add-rows          181
;  :arith-assert-diseq      21
;  :arith-assert-lower      124
;  :arith-assert-upper      67
;  :arith-bound-prop        25
;  :arith-conflicts         17
;  :arith-eq-adapter        58
;  :arith-fixed-eqs         30
;  :arith-offset-eqs        13
;  :arith-pivots            106
;  :conflicts               36
;  :datatype-accessor-ax    34
;  :datatype-constructor-ax 87
;  :datatype-occurs-check   49
;  :datatype-splits         32
;  :decisions               95
;  :del-clause              385
;  :final-checks            30
;  :max-generation          3
;  :max-memory              4.91
;  :memory                  4.90
;  :minimized-lits          1
;  :mk-bool-var             1350
;  :mk-clause               415
;  :num-allocs              181552
;  :num-checks              54
;  :propagations            138
;  :quant-instantiations    339
;  :rlimit-count            240518)
(assert (<
  j1@51@03
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@45@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@50@03))))))
(pop) ; 6
; Joined path conditions
(assert (<
  j1@51@03
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@45@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@50@03))))))
(pop) ; 5
(declare-fun inv@52@03 ($Ref) Int)
(declare-fun inv@53@03 ($Ref) Int)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(assert (forall ((i1@50@03 Int) (j1@51@03 Int)) (!
  (and
    (< i1@50@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@45@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@50@03)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@50@03))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@45@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@50@03))
        (as None<option<array>>  option<array>)))
    (<
      j1@51@03
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@45@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@50@03))))))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@45@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@50@03))) j1@51@03))
  :qid |int-aux|)))
; Check receiver injectivity
(push) ; 5
(assert (not (forall ((i11@50@03 Int) (j11@51@03 Int) (i12@50@03 Int) (j12@51@03 Int)) (!
  (implies
    (and
      (and
        (and (and (< j11@51@03 V@12@03) (<= 0 j11@51@03)) (< i11@50@03 V@12@03))
        (<= 0 i11@50@03))
      (and
        (and (and (< j12@51@03 V@12@03) (<= 0 j12@51@03)) (< i12@50@03 V@12@03))
        (<= 0 i12@50@03))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@45@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i11@50@03))) j11@51@03)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@45@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i12@50@03))) j12@51@03)))
    (and (= i11@50@03 i12@50@03) (= j11@51@03 j12@51@03)))
  
  :qid |int-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               870
;  :arith-add-rows          193
;  :arith-assert-diseq      21
;  :arith-assert-lower      136
;  :arith-assert-upper      71
;  :arith-bound-prop        27
;  :arith-conflicts         17
;  :arith-eq-adapter        66
;  :arith-fixed-eqs         32
;  :arith-offset-eqs        13
;  :arith-pivots            118
;  :conflicts               37
;  :datatype-accessor-ax    34
;  :datatype-constructor-ax 87
;  :datatype-occurs-check   49
;  :datatype-splits         32
;  :decisions               95
;  :del-clause              476
;  :final-checks            30
;  :max-generation          3
;  :max-memory              5.05
;  :memory                  5.04
;  :minimized-lits          1
;  :mk-bool-var             1537
;  :mk-clause               486
;  :num-allocs              183004
;  :num-checks              55
;  :propagations            164
;  :quant-instantiations    421
;  :rlimit-count            245320
;  :time                    0.00)
; Definitional axioms for inverse functions
(assert (forall ((i1@50@03 Int) (j1@51@03 Int)) (!
  (implies
    (and
      (and (and (< j1@51@03 V@12@03) (<= 0 j1@51@03)) (< i1@50@03 V@12@03))
      (<= 0 i1@50@03))
    (and
      (=
        (inv@52@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@45@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@50@03))) j1@51@03))
        i1@50@03)
      (=
        (inv@53@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@45@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@50@03))) j1@51@03))
        j1@51@03)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@45@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@50@03))) j1@51@03))
  )))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@53@03 r) V@12@03) (<= 0 (inv@53@03 r)))
        (< (inv@52@03 r) V@12@03))
      (<= 0 (inv@52@03 r)))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@45@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) (inv@52@03 r)))) (inv@53@03 r))
      r))
  :pattern ((inv@52@03 r))
  :pattern ((inv@53@03 r))
  :qid |int-fctOfInv|)))
; Permissions are non-negative
; Field permissions are at most one
; Permission implies non-null receiver
(assert (forall ((i1@50@03 Int) (j1@51@03 Int)) (!
  (implies
    (and
      (and (and (< j1@51@03 V@12@03) (<= 0 j1@51@03)) (< i1@50@03 V@12@03))
      (<= 0 i1@50@03))
    (not
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@45@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@50@03))) j1@51@03)
        $Ref.null)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@45@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@50@03))) j1@51@03))
  :qid |int-permImpliesNonNull|)))
(declare-const sm@54@03 $FVF<Int>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@53@03 r) V@12@03) (<= 0 (inv@53@03 r)))
        (< (inv@52@03 r) V@12@03))
      (<= 0 (inv@52@03 r)))
    (=
      ($FVF.lookup_int (as sm@54@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@41@03))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@54@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@41@03))))))))))))))) r))
  :qid |qp.fvfValDef14|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@41@03))))))))))))))) r) r)
  :pattern (($FVF.lookup_int (as sm@54@03  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef15|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@53@03 r) V@12@03) (<= 0 (inv@53@03 r)))
        (< (inv@52@03 r) V@12@03))
      (<= 0 (inv@52@03 r)))
    ($FVF.loc_int ($FVF.lookup_int (as sm@54@03  $FVF<Int>) r) r))
  :pattern ((inv@52@03 r) (inv@53@03 r))
  )))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@41@03))))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@41@03)))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@41@03))))))))))))))))))
; [eval] exc == null
(set-option :timeout 10)
(push) ; 5
(assert (not (not (= exc@16@03 $Ref.null))))
(check-sat)
; unknown
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               914
;  :arith-add-rows          193
;  :arith-assert-diseq      21
;  :arith-assert-lower      136
;  :arith-assert-upper      71
;  :arith-bound-prop        27
;  :arith-conflicts         17
;  :arith-eq-adapter        66
;  :arith-fixed-eqs         32
;  :arith-offset-eqs        13
;  :arith-pivots            118
;  :conflicts               37
;  :datatype-accessor-ax    35
;  :datatype-constructor-ax 95
;  :datatype-occurs-check   54
;  :datatype-splits         36
;  :decisions               103
;  :del-clause              476
;  :final-checks            32
;  :max-generation          3
;  :max-memory              5.06
;  :memory                  5.05
;  :minimized-lits          1
;  :mk-bool-var             1548
;  :mk-clause               486
;  :num-allocs              184656
;  :num-checks              56
;  :propagations            164
;  :quant-instantiations    421
;  :rlimit-count            248900)
; [then-branch: 41 | exc@16@03 == Null | live]
; [else-branch: 41 | exc@16@03 != Null | dead]
(push) ; 5
; [then-branch: 41 | exc@16@03 == Null]
(declare-const i1@55@03 Int)
(push) ; 6
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 7
; [then-branch: 42 | 0 <= i1@55@03 | live]
; [else-branch: 42 | !(0 <= i1@55@03) | live]
(push) ; 8
; [then-branch: 42 | 0 <= i1@55@03]
(assert (<= 0 i1@55@03))
; [eval] i1 < V
(pop) ; 8
(push) ; 8
; [else-branch: 42 | !(0 <= i1@55@03)]
(assert (not (<= 0 i1@55@03)))
(pop) ; 8
(pop) ; 7
; Joined path conditions
; Joined path conditions
(assert (and (< i1@55@03 V@12@03) (<= 0 i1@55@03)))
; [eval] aloc(opt_get1(p), i1)
; [eval] opt_get1(p)
(push) ; 7
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 7
; Joined path conditions
(push) ; 7
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 8
(assert (not (< i1@55@03 (alen<Int> (opt_get1 $Snap.unit p@15@03)))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               914
;  :arith-add-rows          193
;  :arith-assert-diseq      21
;  :arith-assert-lower      138
;  :arith-assert-upper      71
;  :arith-bound-prop        27
;  :arith-conflicts         17
;  :arith-eq-adapter        66
;  :arith-fixed-eqs         32
;  :arith-offset-eqs        13
;  :arith-pivots            118
;  :conflicts               37
;  :datatype-accessor-ax    35
;  :datatype-constructor-ax 95
;  :datatype-occurs-check   54
;  :datatype-splits         36
;  :decisions               103
;  :del-clause              476
;  :final-checks            32
;  :max-generation          3
;  :max-memory              5.06
;  :memory                  5.05
;  :minimized-lits          1
;  :mk-bool-var             1550
;  :mk-clause               486
;  :num-allocs              184759
;  :num-checks              57
;  :propagations            164
;  :quant-instantiations    421
;  :rlimit-count            249085)
(assert (< i1@55@03 (alen<Int> (opt_get1 $Snap.unit p@15@03))))
(pop) ; 7
; Joined path conditions
(assert (< i1@55@03 (alen<Int> (opt_get1 $Snap.unit p@15@03))))
(pop) ; 6
(declare-fun inv@56@03 ($Ref) Int)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(assert (forall ((i1@55@03 Int)) (!
  (< i1@55@03 (alen<Int> (opt_get1 $Snap.unit p@15@03)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) i1@55@03))
  :qid |int-aux|)))
; Check receiver injectivity
(push) ; 6
(assert (not (forall ((i11@55@03 Int) (i12@55@03 Int)) (!
  (implies
    (and
      (and (< i11@55@03 V@12@03) (<= 0 i11@55@03))
      (and (< i12@55@03 V@12@03) (<= 0 i12@55@03))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) i11@55@03)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) i12@55@03)))
    (= i11@55@03 i12@55@03))
  
  :qid |int-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               925
;  :arith-add-rows          195
;  :arith-assert-diseq      22
;  :arith-assert-lower      142
;  :arith-assert-upper      71
;  :arith-bound-prop        27
;  :arith-conflicts         17
;  :arith-eq-adapter        67
;  :arith-fixed-eqs         32
;  :arith-offset-eqs        13
;  :arith-pivots            118
;  :conflicts               38
;  :datatype-accessor-ax    35
;  :datatype-constructor-ax 95
;  :datatype-occurs-check   54
;  :datatype-splits         36
;  :decisions               103
;  :del-clause              482
;  :final-checks            32
;  :max-generation          3
;  :max-memory              5.06
;  :memory                  5.04
;  :minimized-lits          1
;  :mk-bool-var             1573
;  :mk-clause               492
;  :num-allocs              185291
;  :num-checks              58
;  :propagations            164
;  :quant-instantiations    438
;  :rlimit-count            250058)
; Definitional axioms for inverse functions
(assert (forall ((i1@55@03 Int)) (!
  (implies
    (and (< i1@55@03 V@12@03) (<= 0 i1@55@03))
    (=
      (inv@56@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) i1@55@03))
      i1@55@03))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) i1@55@03))
  )))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@56@03 r) V@12@03) (<= 0 (inv@56@03 r)))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) (inv@56@03 r))
      r))
  :pattern ((inv@56@03 r))
  :qid |int-fctOfInv|)))
; Permissions are non-negative
; Field permissions are at most one
; Permission implies non-null receiver
(assert (forall ((i1@55@03 Int)) (!
  (implies
    (and (< i1@55@03 V@12@03) (<= 0 i1@55@03))
    (not
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) i1@55@03)
        $Ref.null)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) i1@55@03))
  :qid |int-permImpliesNonNull|)))
(declare-const sm@57@03 $FVF<Int>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@56@03 r) V@12@03) (<= 0 (inv@56@03 r)))
    (=
      ($FVF.lookup_int (as sm@57@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@41@03)))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@57@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@41@03)))))))))))))))) r))
  :qid |qp.fvfValDef16|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@53@03 r) V@12@03) (<= 0 (inv@53@03 r)))
        (< (inv@52@03 r) V@12@03))
      (<= 0 (inv@52@03 r)))
    (=
      ($FVF.lookup_int (as sm@57@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@41@03))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@57@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@41@03))))))))))))))) r))
  :qid |qp.fvfValDef17|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@41@03)))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@41@03))))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@57@03  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef18|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@56@03 r) V@12@03) (<= 0 (inv@56@03 r)))
    ($FVF.loc_int ($FVF.lookup_int (as sm@57@03  $FVF<Int>) r) r))
  :pattern ((inv@56@03 r))
  )))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@41@03)))))))))))))))
  $Snap.unit))
; [eval] exc == null ==> valid_graph_vertices(this, p, V)
; [eval] exc == null
(push) ; 6
(set-option :timeout 10)
(push) ; 7
(assert (not (not (= exc@16@03 $Ref.null))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               964
;  :arith-add-rows          195
;  :arith-assert-diseq      22
;  :arith-assert-lower      142
;  :arith-assert-upper      71
;  :arith-bound-prop        27
;  :arith-conflicts         17
;  :arith-eq-adapter        67
;  :arith-fixed-eqs         32
;  :arith-offset-eqs        13
;  :arith-pivots            118
;  :conflicts               38
;  :datatype-accessor-ax    35
;  :datatype-constructor-ax 102
;  :datatype-occurs-check   59
;  :datatype-splits         39
;  :decisions               110
;  :del-clause              482
;  :final-checks            34
;  :max-generation          3
;  :max-memory              5.07
;  :memory                  5.05
;  :minimized-lits          1
;  :mk-bool-var             1584
;  :mk-clause               492
;  :num-allocs              187013
;  :num-checks              59
;  :propagations            164
;  :quant-instantiations    438
;  :rlimit-count            253633)
; [then-branch: 43 | exc@16@03 == Null | live]
; [else-branch: 43 | exc@16@03 != Null | dead]
(push) ; 7
; [then-branch: 43 | exc@16@03 == Null]
; [eval] valid_graph_vertices(this, p, V)
(push) ; 8
; [eval] this != null
; [eval] p != (None(): option[array])
; [eval] (None(): option[array])
; [eval] alen(opt_get1(p)) == V
; [eval] alen(opt_get1(p))
; [eval] opt_get1(p)
(push) ; 9
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 9
; Joined path conditions
(declare-const i1@58@03 Int)
(push) ; 9
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 10
; [then-branch: 44 | 0 <= i1@58@03 | live]
; [else-branch: 44 | !(0 <= i1@58@03) | live]
(push) ; 11
; [then-branch: 44 | 0 <= i1@58@03]
(assert (<= 0 i1@58@03))
; [eval] i1 < V
(pop) ; 11
(push) ; 11
; [else-branch: 44 | !(0 <= i1@58@03)]
(assert (not (<= 0 i1@58@03)))
(pop) ; 11
(pop) ; 10
; Joined path conditions
; Joined path conditions
(assert (and (< i1@58@03 V@12@03) (<= 0 i1@58@03)))
(declare-const $k@59@03 $Perm)
(assert ($Perm.isReadVar $k@59@03 $Perm.Write))
; [eval] aloc(opt_get1(p), i1)
; [eval] opt_get1(p)
(push) ; 10
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 10
; Joined path conditions
(push) ; 10
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 11
(assert (not (< i1@58@03 (alen<Int> (opt_get1 $Snap.unit p@15@03)))))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               964
;  :arith-add-rows          195
;  :arith-assert-diseq      23
;  :arith-assert-lower      146
;  :arith-assert-upper      72
;  :arith-bound-prop        27
;  :arith-conflicts         17
;  :arith-eq-adapter        68
;  :arith-fixed-eqs         32
;  :arith-offset-eqs        13
;  :arith-pivots            118
;  :conflicts               38
;  :datatype-accessor-ax    35
;  :datatype-constructor-ax 102
;  :datatype-occurs-check   59
;  :datatype-splits         39
;  :decisions               110
;  :del-clause              482
;  :final-checks            34
;  :max-generation          3
;  :max-memory              5.07
;  :memory                  5.06
;  :minimized-lits          1
;  :mk-bool-var             1590
;  :mk-clause               494
;  :num-allocs              187185
;  :num-checks              60
;  :propagations            165
;  :quant-instantiations    438
;  :rlimit-count            253970)
(assert (< i1@58@03 (alen<Int> (opt_get1 $Snap.unit p@15@03))))
(pop) ; 10
; Joined path conditions
(assert (< i1@58@03 (alen<Int> (opt_get1 $Snap.unit p@15@03))))
(pop) ; 9
(declare-fun inv@60@03 ($Ref) Int)
; Nested auxiliary terms: globals
(assert ($Perm.isReadVar $k@59@03 $Perm.Write))
; Nested auxiliary terms: non-globals
(assert (forall ((i1@58@03 Int)) (!
  (< i1@58@03 (alen<Int> (opt_get1 $Snap.unit p@15@03)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) i1@58@03))
  :qid |int-aux|)))
(push) ; 9
(assert (not (forall ((i1@58@03 Int)) (!
  (implies
    (and (< i1@58@03 V@12@03) (<= 0 i1@58@03))
    (or (= $k@59@03 $Perm.No) (< $Perm.No $k@59@03)))
  
  ))))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               964
;  :arith-add-rows          195
;  :arith-assert-diseq      24
;  :arith-assert-lower      148
;  :arith-assert-upper      73
;  :arith-bound-prop        27
;  :arith-conflicts         17
;  :arith-eq-adapter        69
;  :arith-fixed-eqs         32
;  :arith-offset-eqs        13
;  :arith-pivots            118
;  :conflicts               39
;  :datatype-accessor-ax    35
;  :datatype-constructor-ax 102
;  :datatype-occurs-check   59
;  :datatype-splits         39
;  :decisions               110
;  :del-clause              484
;  :final-checks            34
;  :max-generation          3
;  :max-memory              5.07
;  :memory                  5.05
;  :minimized-lits          1
;  :mk-bool-var             1597
;  :mk-clause               496
;  :num-allocs              187606
;  :num-checks              61
;  :propagations            166
;  :quant-instantiations    438
;  :rlimit-count            254516)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 9
(assert (not (forall ((i11@58@03 Int) (i12@58@03 Int)) (!
  (implies
    (and
      (and
        (and
          (and (< i11@58@03 V@12@03) (<= 0 i11@58@03))
          ($FVF.loc_int ($FVF.lookup_int (as sm@57@03  $FVF<Int>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit p@15@03) i11@58@03)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit p@15@03) i11@58@03)))
        (< $Perm.No $k@59@03))
      (and
        (and
          (and (< i12@58@03 V@12@03) (<= 0 i12@58@03))
          ($FVF.loc_int ($FVF.lookup_int (as sm@57@03  $FVF<Int>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit p@15@03) i12@58@03)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit p@15@03) i12@58@03)))
        (< $Perm.No $k@59@03))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) i11@58@03)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) i12@58@03)))
    (= i11@58@03 i12@58@03))
  
  :qid |int-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               978
;  :arith-add-rows          199
;  :arith-assert-diseq      25
;  :arith-assert-lower      152
;  :arith-assert-upper      73
;  :arith-bound-prop        27
;  :arith-conflicts         17
;  :arith-eq-adapter        70
;  :arith-fixed-eqs         32
;  :arith-offset-eqs        13
;  :arith-pivots            120
;  :conflicts               40
;  :datatype-accessor-ax    35
;  :datatype-constructor-ax 102
;  :datatype-occurs-check   59
;  :datatype-splits         39
;  :decisions               110
;  :del-clause              495
;  :final-checks            34
;  :max-generation          3
;  :max-memory              5.07
;  :memory                  5.05
;  :minimized-lits          1
;  :mk-bool-var             1633
;  :mk-clause               507
;  :num-allocs              188070
;  :num-checks              62
;  :propagations            168
;  :quant-instantiations    462
;  :rlimit-count            255696)
; Definitional axioms for inverse functions
(assert (forall ((i1@58@03 Int)) (!
  (implies
    (and (and (< i1@58@03 V@12@03) (<= 0 i1@58@03)) (< $Perm.No $k@59@03))
    (=
      (inv@60@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) i1@58@03))
      i1@58@03))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) i1@58@03))
  :qid |int-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and (< (inv@60@03 r) V@12@03) (<= 0 (inv@60@03 r)))
      (< $Perm.No $k@59@03))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) (inv@60@03 r))
      r))
  :pattern ((inv@60@03 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@60@03 r) V@12@03) (<= 0 (inv@60@03 r)))
    ($FVF.loc_int ($FVF.lookup_int (as sm@57@03  $FVF<Int>) r) r))
  :pattern ((inv@60@03 r))
  )))
; Precomputing data for removing quantified permissions
(define-fun pTaken@61@03 ((r $Ref)) $Perm
  (ite
    (and (< (inv@60@03 r) V@12@03) (<= 0 (inv@60@03 r)))
    ($Perm.min
      (ite
        (and (< (inv@56@03 r) V@12@03) (<= 0 (inv@56@03 r)))
        $Perm.Write
        $Perm.No)
      $k@59@03)
    $Perm.No))
(define-fun pTaken@62@03 ((r $Ref)) $Perm
  (ite
    (and (< (inv@60@03 r) V@12@03) (<= 0 (inv@60@03 r)))
    ($Perm.min
      (ite
        (and
          (and
            (and (< (inv@53@03 r) V@12@03) (<= 0 (inv@53@03 r)))
            (< (inv@52@03 r) V@12@03))
          (<= 0 (inv@52@03 r)))
        $Perm.Write
        $Perm.No)
      (- $k@59@03 (pTaken@61@03 r)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Constrain original permissions $k@59@03
(assert (forall ((r $Ref)) (!
  (implies
    (not
      (=
        (ite
          (and (< (inv@56@03 r) V@12@03) (<= 0 (inv@56@03 r)))
          $Perm.Write
          $Perm.No)
        $Perm.No))
    (ite
      (and (< (inv@56@03 r) V@12@03) (<= 0 (inv@56@03 r)))
      (<
        (ite
          (and (< (inv@60@03 r) V@12@03) (<= 0 (inv@60@03 r)))
          $k@59@03
          $Perm.No)
        $Perm.Write)
      (<
        (ite
          (and (< (inv@60@03 r) V@12@03) (<= 0 (inv@60@03 r)))
          $k@59@03
          $Perm.No)
        $Perm.No)))
  :pattern ((inv@56@03 r))
  :pattern ((inv@60@03 r))
  :qid |qp.srp19|)))
; Intermediate check if already taken enough permissions
(set-option :timeout 500)
(push) ; 9
(assert (not (forall ((r $Ref)) (!
  (implies
    (and (< (inv@60@03 r) V@12@03) (<= 0 (inv@60@03 r)))
    (= (- $k@59@03 (pTaken@61@03 r)) $Perm.No))
  
  ))))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1099
;  :arith-add-rows          228
;  :arith-assert-diseq      29
;  :arith-assert-lower      169
;  :arith-assert-upper      82
;  :arith-bound-prop        34
;  :arith-conflicts         19
;  :arith-eq-adapter        88
;  :arith-fixed-eqs         36
;  :arith-offset-eqs        21
;  :arith-pivots            135
;  :conflicts               49
;  :datatype-accessor-ax    35
;  :datatype-constructor-ax 113
;  :datatype-occurs-check   64
;  :datatype-splits         42
;  :decisions               125
;  :del-clause              604
;  :final-checks            36
;  :max-generation          5
;  :max-memory              5.11
;  :memory                  5.10
;  :minimized-lits          1
;  :mk-bool-var             1784
;  :mk-clause               614
;  :num-allocs              190461
;  :num-checks              64
;  :propagations            221
;  :quant-instantiations    500
;  :rlimit-count            260414
;  :time                    0.00)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@63@03 $FVF<Int>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (iff
    (Set_in r ($FVF.domain_int (as sm@63@03  $FVF<Int>)))
    (and
      (and (< (inv@60@03 r) V@12@03) (<= 0 (inv@60@03 r)))
      (< $Perm.No $k@59@03)))
  :pattern ((Set_in r ($FVF.domain_int (as sm@63@03  $FVF<Int>))))
  :qid |qp.fvfDomDef23|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@60@03 r) V@12@03) (<= 0 (inv@60@03 r)))
        (< $Perm.No $k@59@03))
      (and (< (inv@56@03 r) V@12@03) (<= 0 (inv@56@03 r))))
    (=
      ($FVF.lookup_int (as sm@63@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@41@03)))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@63@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@41@03)))))))))))))))) r))
  :qid |qp.fvfValDef20|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@60@03 r) V@12@03) (<= 0 (inv@60@03 r)))
        (< $Perm.No $k@59@03))
      (and
        (and
          (and (< (inv@53@03 r) V@12@03) (<= 0 (inv@53@03 r)))
          (< (inv@52@03 r) V@12@03))
        (<= 0 (inv@52@03 r))))
    (=
      ($FVF.lookup_int (as sm@63@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@41@03))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@63@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@41@03))))))))))))))) r))
  :qid |qp.fvfValDef21|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@41@03)))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@41@03))))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@63@03  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef22|)))
(pop) ; 8
; Joined path conditions
(assert ($Perm.isReadVar $k@59@03 $Perm.Write))
(assert (forall ((i1@58@03 Int)) (!
  (implies
    (and (and (< i1@58@03 V@12@03) (<= 0 i1@58@03)) (< $Perm.No $k@59@03))
    (=
      (inv@60@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) i1@58@03))
      i1@58@03))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) i1@58@03))
  :qid |int-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and (< (inv@60@03 r) V@12@03) (<= 0 (inv@60@03 r)))
      (< $Perm.No $k@59@03))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) (inv@60@03 r))
      r))
  :pattern ((inv@60@03 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (iff
    (Set_in r ($FVF.domain_int (as sm@63@03  $FVF<Int>)))
    (and
      (and (< (inv@60@03 r) V@12@03) (<= 0 (inv@60@03 r)))
      (< $Perm.No $k@59@03)))
  :pattern ((Set_in r ($FVF.domain_int (as sm@63@03  $FVF<Int>))))
  :qid |qp.fvfDomDef23|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@60@03 r) V@12@03) (<= 0 (inv@60@03 r)))
        (< $Perm.No $k@59@03))
      (and (< (inv@56@03 r) V@12@03) (<= 0 (inv@56@03 r))))
    (=
      ($FVF.lookup_int (as sm@63@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@41@03)))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@63@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@41@03)))))))))))))))) r))
  :qid |qp.fvfValDef20|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@60@03 r) V@12@03) (<= 0 (inv@60@03 r)))
        (< $Perm.No $k@59@03))
      (and
        (and
          (and (< (inv@53@03 r) V@12@03) (<= 0 (inv@53@03 r)))
          (< (inv@52@03 r) V@12@03))
        (<= 0 (inv@52@03 r))))
    (=
      ($FVF.lookup_int (as sm@63@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@41@03))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@63@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@41@03))))))))))))))) r))
  :qid |qp.fvfValDef21|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@41@03)))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@41@03))))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@63@03  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef22|)))
(assert (and
  (forall ((i1@58@03 Int)) (!
    (< i1@58@03 (alen<Int> (opt_get1 $Snap.unit p@15@03)))
    :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) i1@58@03))
    :qid |int-aux|))
  (forall ((r $Ref)) (!
    (implies
      (and (< (inv@60@03 r) V@12@03) (<= 0 (inv@60@03 r)))
      ($FVF.loc_int ($FVF.lookup_int (as sm@57@03  $FVF<Int>) r) r))
    :pattern ((inv@60@03 r))
    ))
  (forall ((r $Ref)) (!
    (implies
      (not
        (=
          (ite
            (and (< (inv@56@03 r) V@12@03) (<= 0 (inv@56@03 r)))
            $Perm.Write
            $Perm.No)
          $Perm.No))
      (ite
        (and (< (inv@56@03 r) V@12@03) (<= 0 (inv@56@03 r)))
        (<
          (ite
            (and (< (inv@60@03 r) V@12@03) (<= 0 (inv@60@03 r)))
            $k@59@03
            $Perm.No)
          $Perm.Write)
        (<
          (ite
            (and (< (inv@60@03 r) V@12@03) (<= 0 (inv@60@03 r)))
            $k@59@03
            $Perm.No)
          $Perm.No)))
    :pattern ((inv@56@03 r))
    :pattern ((inv@60@03 r))
    :qid |qp.srp19|))))
(pop) ; 7
(pop) ; 6
; Joined path conditions
(assert ($Perm.isReadVar $k@59@03 $Perm.Write))
(assert (forall ((i1@58@03 Int)) (!
  (implies
    (and (and (< i1@58@03 V@12@03) (<= 0 i1@58@03)) (< $Perm.No $k@59@03))
    (=
      (inv@60@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) i1@58@03))
      i1@58@03))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) i1@58@03))
  :qid |int-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and (< (inv@60@03 r) V@12@03) (<= 0 (inv@60@03 r)))
      (< $Perm.No $k@59@03))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) (inv@60@03 r))
      r))
  :pattern ((inv@60@03 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (iff
    (Set_in r ($FVF.domain_int (as sm@63@03  $FVF<Int>)))
    (and
      (and (< (inv@60@03 r) V@12@03) (<= 0 (inv@60@03 r)))
      (< $Perm.No $k@59@03)))
  :pattern ((Set_in r ($FVF.domain_int (as sm@63@03  $FVF<Int>))))
  :qid |qp.fvfDomDef23|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@60@03 r) V@12@03) (<= 0 (inv@60@03 r)))
        (< $Perm.No $k@59@03))
      (and (< (inv@56@03 r) V@12@03) (<= 0 (inv@56@03 r))))
    (=
      ($FVF.lookup_int (as sm@63@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@41@03)))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@63@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@41@03)))))))))))))))) r))
  :qid |qp.fvfValDef20|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@60@03 r) V@12@03) (<= 0 (inv@60@03 r)))
        (< $Perm.No $k@59@03))
      (and
        (and
          (and (< (inv@53@03 r) V@12@03) (<= 0 (inv@53@03 r)))
          (< (inv@52@03 r) V@12@03))
        (<= 0 (inv@52@03 r))))
    (=
      ($FVF.lookup_int (as sm@63@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@41@03))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@63@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@41@03))))))))))))))) r))
  :qid |qp.fvfValDef21|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@41@03)))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@41@03))))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@63@03  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef22|)))
(assert (implies
  (= exc@16@03 $Ref.null)
  (and
    (forall ((i1@58@03 Int)) (!
      (< i1@58@03 (alen<Int> (opt_get1 $Snap.unit p@15@03)))
      :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) i1@58@03))
      :qid |int-aux|))
    (forall ((r $Ref)) (!
      (implies
        (and (< (inv@60@03 r) V@12@03) (<= 0 (inv@60@03 r)))
        ($FVF.loc_int ($FVF.lookup_int (as sm@57@03  $FVF<Int>) r) r))
      :pattern ((inv@60@03 r))
      ))
    (forall ((r $Ref)) (!
      (implies
        (not
          (=
            (ite
              (and (< (inv@56@03 r) V@12@03) (<= 0 (inv@56@03 r)))
              $Perm.Write
              $Perm.No)
            $Perm.No))
        (ite
          (and (< (inv@56@03 r) V@12@03) (<= 0 (inv@56@03 r)))
          (<
            (ite
              (and (< (inv@60@03 r) V@12@03) (<= 0 (inv@60@03 r)))
              $k@59@03
              $Perm.No)
            $Perm.Write)
          (<
            (ite
              (and (< (inv@60@03 r) V@12@03) (<= 0 (inv@60@03 r)))
              $k@59@03
              $Perm.No)
            $Perm.No)))
      :pattern ((inv@56@03 r))
      :pattern ((inv@60@03 r))
      :qid |qp.srp19|)))))
(assert (implies
  (= exc@16@03 $Ref.null)
  (valid_graph_vertices ($Snap.combine
    $Snap.unit
    ($Snap.combine
      $Snap.unit
      ($Snap.combine
        $Snap.unit
        ($SortWrappers.$FVF<Int>To$Snap (as sm@63@03  $FVF<Int>))))) this@9@03 p@15@03 V@12@03)))
(pop) ; 5
(pop) ; 4
(pop) ; 3
(pop) ; 2
(push) ; 2
; [exec]
; var return: Bool
(declare-const return@64@03 Bool)
; [exec]
; var visited: option[array]
(declare-const visited@65@03 option<array>)
; [exec]
; var queue: Seq[Int]
(declare-const queue@66@03 Seq<Int>)
; [exec]
; var u: Int
(declare-const u@67@03 Int)
; [exec]
; var k: Int
(declare-const k@68@03 Int)
; [exec]
; var v: Int
(declare-const v@69@03 Int)
; [exec]
; var res1: option[array]
(declare-const res1@70@03 option<array>)
; [exec]
; var res2: void
(declare-const res2@71@03 void)
; [exec]
; var flatten: Int
(declare-const flatten@72@03 Int)
; [exec]
; var excBeforeLoop: Ref
(declare-const excBeforeLoop@73@03 $Ref)
; [exec]
; var excBeforeLoop1: Ref
(declare-const excBeforeLoop1@74@03 $Ref)
; [exec]
; var evaluationDummy: void
(declare-const evaluationDummy@75@03 void)
; [exec]
; var evaluationDummy1: Seq[Int]
(declare-const evaluationDummy1@76@03 Seq<Int>)
; [exec]
; var evaluationDummy2: Int
(declare-const evaluationDummy2@77@03 Int)
; [exec]
; exc := null
; [exec]
; exc, res1 := make_array(tid, V)
(declare-const exc@78@03 $Ref)
(declare-const res@79@03 option<array>)
(declare-const $t@80@03 $Snap)
(assert (= $t@80@03 ($Snap.combine ($Snap.first $t@80@03) ($Snap.second $t@80@03))))
(assert (= ($Snap.first $t@80@03) $Snap.unit))
; [eval] exc == null
(assert (= exc@78@03 $Ref.null))
(assert (=
  ($Snap.second $t@80@03)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@80@03))
    ($Snap.second ($Snap.second $t@80@03)))))
(assert (= ($Snap.first ($Snap.second $t@80@03)) $Snap.unit))
; [eval] exc == null ==> res != (None(): option[array])
; [eval] exc == null
(push) ; 3
(set-option :timeout 10)
(push) ; 4
(assert (not (not (= exc@78@03 $Ref.null))))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1130
;  :arith-add-rows          228
;  :arith-assert-diseq      29
;  :arith-assert-lower      169
;  :arith-assert-upper      82
;  :arith-bound-prop        34
;  :arith-conflicts         19
;  :arith-eq-adapter        88
;  :arith-fixed-eqs         36
;  :arith-offset-eqs        21
;  :arith-pivots            135
;  :conflicts               49
;  :datatype-accessor-ax    37
;  :datatype-constructor-ax 118
;  :datatype-occurs-check   67
;  :datatype-splits         43
;  :decisions               130
;  :del-clause              606
;  :final-checks            38
;  :max-generation          5
;  :max-memory              5.11
;  :memory                  5.10
;  :minimized-lits          1
;  :mk-bool-var             1790
;  :mk-clause               614
;  :num-allocs              192321
;  :num-checks              65
;  :propagations            221
;  :quant-instantiations    500
;  :rlimit-count            262420)
; [then-branch: 45 | exc@78@03 == Null | live]
; [else-branch: 45 | exc@78@03 != Null | dead]
(push) ; 4
; [then-branch: 45 | exc@78@03 == Null]
; [eval] res != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 4
(pop) ; 3
; Joined path conditions
(assert (implies
  (= exc@78@03 $Ref.null)
  (not (= res@79@03 (as None<option<array>>  option<array>)))))
(assert (=
  ($Snap.second ($Snap.second $t@80@03))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second $t@80@03)))
    ($Snap.second ($Snap.second ($Snap.second $t@80@03))))))
(assert (= ($Snap.first ($Snap.second ($Snap.second $t@80@03))) $Snap.unit))
; [eval] exc == null ==> alen(opt_get1(res)) == dim0
; [eval] exc == null
(push) ; 3
(push) ; 4
(assert (not (not (= exc@78@03 $Ref.null))))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1155
;  :arith-add-rows          228
;  :arith-assert-diseq      29
;  :arith-assert-lower      169
;  :arith-assert-upper      82
;  :arith-bound-prop        34
;  :arith-conflicts         19
;  :arith-eq-adapter        88
;  :arith-fixed-eqs         36
;  :arith-offset-eqs        21
;  :arith-pivots            135
;  :conflicts               49
;  :datatype-accessor-ax    38
;  :datatype-constructor-ax 123
;  :datatype-occurs-check   70
;  :datatype-splits         44
;  :decisions               135
;  :del-clause              606
;  :final-checks            40
;  :max-generation          5
;  :max-memory              5.12
;  :memory                  5.10
;  :minimized-lits          1
;  :mk-bool-var             1794
;  :mk-clause               614
;  :num-allocs              193056
;  :num-checks              66
;  :propagations            221
;  :quant-instantiations    500
;  :rlimit-count            263181)
; [then-branch: 46 | exc@78@03 == Null | live]
; [else-branch: 46 | exc@78@03 != Null | dead]
(push) ; 4
; [then-branch: 46 | exc@78@03 == Null]
; [eval] alen(opt_get1(res)) == dim0
; [eval] alen(opt_get1(res))
; [eval] opt_get1(res)
(push) ; 5
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(set-option :timeout 0)
(push) ; 6
(assert (not (not (= res@79@03 (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1155
;  :arith-add-rows          228
;  :arith-assert-diseq      29
;  :arith-assert-lower      169
;  :arith-assert-upper      82
;  :arith-bound-prop        34
;  :arith-conflicts         19
;  :arith-eq-adapter        88
;  :arith-fixed-eqs         36
;  :arith-offset-eqs        21
;  :arith-pivots            135
;  :conflicts               49
;  :datatype-accessor-ax    38
;  :datatype-constructor-ax 123
;  :datatype-occurs-check   70
;  :datatype-splits         44
;  :decisions               135
;  :del-clause              606
;  :final-checks            40
;  :max-generation          5
;  :max-memory              5.12
;  :memory                  5.10
;  :minimized-lits          1
;  :mk-bool-var             1794
;  :mk-clause               614
;  :num-allocs              193080
;  :num-checks              67
;  :propagations            221
;  :quant-instantiations    500
;  :rlimit-count            263202)
(assert (not (= res@79@03 (as None<option<array>>  option<array>))))
(pop) ; 5
; Joined path conditions
(assert (not (= res@79@03 (as None<option<array>>  option<array>))))
(pop) ; 4
(pop) ; 3
; Joined path conditions
(assert (implies
  (= exc@78@03 $Ref.null)
  (= (alen<Int> (opt_get1 $Snap.unit res@79@03)) V@12@03)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second $t@80@03)))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@80@03))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@03)))))))
; [eval] exc == null
(set-option :timeout 10)
(push) ; 3
(assert (not (not (= exc@78@03 $Ref.null))))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1188
;  :arith-add-rows          228
;  :arith-assert-diseq      29
;  :arith-assert-lower      171
;  :arith-assert-upper      83
;  :arith-bound-prop        34
;  :arith-conflicts         19
;  :arith-eq-adapter        89
;  :arith-fixed-eqs         37
;  :arith-offset-eqs        21
;  :arith-pivots            136
;  :conflicts               49
;  :datatype-accessor-ax    39
;  :datatype-constructor-ax 129
;  :datatype-occurs-check   73
;  :datatype-splits         46
;  :decisions               141
;  :del-clause              606
;  :final-checks            42
;  :max-generation          5
;  :max-memory              5.12
;  :memory                  5.10
;  :minimized-lits          1
;  :mk-bool-var             1806
;  :mk-clause               614
;  :num-allocs              193869
;  :num-checks              68
;  :propagations            221
;  :quant-instantiations    505
;  :rlimit-count            264074)
; [then-branch: 47 | exc@78@03 == Null | live]
; [else-branch: 47 | exc@78@03 != Null | dead]
(push) ; 3
; [then-branch: 47 | exc@78@03 == Null]
(declare-const i0@81@03 Int)
(push) ; 4
; [eval] 0 <= i0 && i0 < dim0
; [eval] 0 <= i0
(push) ; 5
; [then-branch: 48 | 0 <= i0@81@03 | live]
; [else-branch: 48 | !(0 <= i0@81@03) | live]
(push) ; 6
; [then-branch: 48 | 0 <= i0@81@03]
(assert (<= 0 i0@81@03))
; [eval] i0 < dim0
(pop) ; 6
(push) ; 6
; [else-branch: 48 | !(0 <= i0@81@03)]
(assert (not (<= 0 i0@81@03)))
(pop) ; 6
(pop) ; 5
; Joined path conditions
; Joined path conditions
(assert (and (< i0@81@03 V@12@03) (<= 0 i0@81@03)))
; [eval] aloc(opt_get1(res), i0)
; [eval] opt_get1(res)
(push) ; 5
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(set-option :timeout 0)
(push) ; 6
(assert (not (not (= res@79@03 (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1188
;  :arith-add-rows          228
;  :arith-assert-diseq      29
;  :arith-assert-lower      173
;  :arith-assert-upper      83
;  :arith-bound-prop        34
;  :arith-conflicts         19
;  :arith-eq-adapter        89
;  :arith-fixed-eqs         37
;  :arith-offset-eqs        21
;  :arith-pivots            136
;  :conflicts               49
;  :datatype-accessor-ax    39
;  :datatype-constructor-ax 129
;  :datatype-occurs-check   73
;  :datatype-splits         46
;  :decisions               141
;  :del-clause              606
;  :final-checks            42
;  :max-generation          5
;  :max-memory              5.12
;  :memory                  5.10
;  :minimized-lits          1
;  :mk-bool-var             1808
;  :mk-clause               614
;  :num-allocs              193968
;  :num-checks              69
;  :propagations            221
;  :quant-instantiations    505
;  :rlimit-count            264243)
(assert (not (= res@79@03 (as None<option<array>>  option<array>))))
(pop) ; 5
; Joined path conditions
(assert (not (= res@79@03 (as None<option<array>>  option<array>))))
(push) ; 5
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 6
(assert (not (< i0@81@03 (alen<Int> (opt_get1 $Snap.unit res@79@03)))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1188
;  :arith-add-rows          228
;  :arith-assert-diseq      29
;  :arith-assert-lower      173
;  :arith-assert-upper      83
;  :arith-bound-prop        34
;  :arith-conflicts         19
;  :arith-eq-adapter        89
;  :arith-fixed-eqs         37
;  :arith-offset-eqs        21
;  :arith-pivots            136
;  :conflicts               49
;  :datatype-accessor-ax    39
;  :datatype-constructor-ax 129
;  :datatype-occurs-check   73
;  :datatype-splits         46
;  :decisions               141
;  :del-clause              606
;  :final-checks            42
;  :max-generation          5
;  :max-memory              5.12
;  :memory                  5.10
;  :minimized-lits          1
;  :mk-bool-var             1808
;  :mk-clause               614
;  :num-allocs              193988
;  :num-checks              70
;  :propagations            221
;  :quant-instantiations    505
;  :rlimit-count            264274)
(assert (< i0@81@03 (alen<Int> (opt_get1 $Snap.unit res@79@03))))
(pop) ; 5
; Joined path conditions
(assert (< i0@81@03 (alen<Int> (opt_get1 $Snap.unit res@79@03))))
(declare-const sm@82@03 $FVF<Bool>)
; Definitional axioms for snapshot map values
; [eval] aloc(opt_get1(res), i0)
; [eval] opt_get1(res)
(push) ; 5
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 5
; Joined path conditions
(push) ; 5
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(pop) ; 5
; Joined path conditions
(pop) ; 4
(declare-fun inv@83@03 ($Ref) Int)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(assert (forall ((i0@81@03 Int)) (!
  (and
    (not (= res@79@03 (as None<option<array>>  option<array>)))
    (< i0@81@03 (alen<Int> (opt_get1 $Snap.unit res@79@03))))
  :pattern (($FVF.loc_bool ($FVF.lookup_bool ($SortWrappers.$SnapTo$FVF<Bool> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@80@03))))) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit res@79@03) i0@81@03)) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit res@79@03) i0@81@03)))
  :qid |bool-aux|)))
; Check receiver injectivity
(push) ; 4
(assert (not (forall ((i01@81@03 Int) (i02@81@03 Int)) (!
  (implies
    (and
      (and (< i01@81@03 V@12@03) (<= 0 i01@81@03))
      (and (< i02@81@03 V@12@03) (<= 0 i02@81@03))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@79@03) i01@81@03)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@79@03) i02@81@03)))
    (= i01@81@03 i02@81@03))
  
  :qid |bool-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1227
;  :arith-add-rows          244
;  :arith-assert-diseq      32
;  :arith-assert-lower      181
;  :arith-assert-upper      88
;  :arith-bound-prop        34
;  :arith-conflicts         22
;  :arith-eq-adapter        90
;  :arith-fixed-eqs         37
;  :arith-offset-eqs        23
;  :arith-pivots            142
;  :conflicts               56
;  :datatype-accessor-ax    39
;  :datatype-constructor-ax 133
;  :datatype-occurs-check   73
;  :datatype-splits         46
;  :decisions               147
;  :del-clause              621
;  :final-checks            42
;  :max-generation          5
;  :max-memory              5.12
;  :memory                  5.10
;  :minimized-lits          1
;  :mk-bool-var             1831
;  :mk-clause               629
;  :num-allocs              194561
;  :num-checks              71
;  :propagations            244
;  :quant-instantiations    513
;  :rlimit-count            265698)
; Definitional axioms for inverse functions
(assert (forall ((i0@81@03 Int)) (!
  (implies
    (and (< i0@81@03 V@12@03) (<= 0 i0@81@03))
    (=
      (inv@83@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@79@03) i0@81@03))
      i0@81@03))
  :pattern (($FVF.loc_bool ($FVF.lookup_bool ($SortWrappers.$SnapTo$FVF<Bool> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@80@03))))) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit res@79@03) i0@81@03)) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit res@79@03) i0@81@03)))
  )))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@83@03 r) V@12@03) (<= 0 (inv@83@03 r)))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@79@03) (inv@83@03 r))
      r))
  :pattern ((inv@83@03 r))
  :qid |bool-fctOfInv|)))
; Permissions are non-negative
; Field permissions are at most one
; Permission implies non-null receiver
(assert (forall ((i0@81@03 Int)) (!
  (implies
    (and (< i0@81@03 V@12@03) (<= 0 i0@81@03))
    (not
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@79@03) i0@81@03)
        $Ref.null)))
  :pattern (($FVF.loc_bool ($FVF.lookup_bool ($SortWrappers.$SnapTo$FVF<Bool> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@80@03))))) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit res@79@03) i0@81@03)) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit res@79@03) i0@81@03)))
  :qid |bool-permImpliesNonNull|)))
(declare-const sm@84@03 $FVF<Bool>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@83@03 r) V@12@03) (<= 0 (inv@83@03 r)))
    (=
      ($FVF.lookup_bool (as sm@84@03  $FVF<Bool>) r)
      ($FVF.lookup_bool ($SortWrappers.$SnapTo$FVF<Bool> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@80@03))))) r)))
  :pattern (($FVF.lookup_bool (as sm@84@03  $FVF<Bool>) r))
  :pattern (($FVF.lookup_bool ($SortWrappers.$SnapTo$FVF<Bool> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@80@03))))) r))
  :qid |qp.fvfValDef25|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_bool ($FVF.lookup_bool ($SortWrappers.$SnapTo$FVF<Bool> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@80@03))))) r) r)
  :pattern (($FVF.lookup_bool (as sm@84@03  $FVF<Bool>) r))
  :qid |qp.fvfResTrgDef26|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@83@03 r) V@12@03) (<= 0 (inv@83@03 r)))
    ($FVF.loc_bool ($FVF.lookup_bool (as sm@84@03  $FVF<Bool>) r) r))
  :pattern ((inv@83@03 r))
  )))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@03))))
  $Snap.unit))
; [eval] exc == null ==> (forall i0: Int :: { aloc(opt_get1(res), i0).bool } 0 <= i0 && i0 < dim0 ==> aloc(opt_get1(res), i0).bool == false)
; [eval] exc == null
(push) ; 4
(set-option :timeout 10)
(push) ; 5
(assert (not (not (= exc@78@03 $Ref.null))))
(check-sat)
; unknown
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1248
;  :arith-add-rows          244
;  :arith-assert-diseq      32
;  :arith-assert-lower      181
;  :arith-assert-upper      88
;  :arith-bound-prop        34
;  :arith-conflicts         22
;  :arith-eq-adapter        90
;  :arith-fixed-eqs         37
;  :arith-offset-eqs        23
;  :arith-pivots            142
;  :conflicts               56
;  :datatype-accessor-ax    39
;  :datatype-constructor-ax 138
;  :datatype-occurs-check   76
;  :datatype-splits         47
;  :decisions               152
;  :del-clause              621
;  :final-checks            44
;  :max-generation          5
;  :max-memory              5.12
;  :memory                  5.10
;  :minimized-lits          1
;  :mk-bool-var             1839
;  :mk-clause               629
;  :num-allocs              196078
;  :num-checks              72
;  :propagations            244
;  :quant-instantiations    513
;  :rlimit-count            268173)
; [then-branch: 49 | exc@78@03 == Null | live]
; [else-branch: 49 | exc@78@03 != Null | dead]
(push) ; 5
; [then-branch: 49 | exc@78@03 == Null]
; [eval] (forall i0: Int :: { aloc(opt_get1(res), i0).bool } 0 <= i0 && i0 < dim0 ==> aloc(opt_get1(res), i0).bool == false)
(declare-const i0@85@03 Int)
(push) ; 6
; [eval] 0 <= i0 && i0 < dim0 ==> aloc(opt_get1(res), i0).bool == false
; [eval] 0 <= i0 && i0 < dim0
; [eval] 0 <= i0
(push) ; 7
; [then-branch: 50 | 0 <= i0@85@03 | live]
; [else-branch: 50 | !(0 <= i0@85@03) | live]
(push) ; 8
; [then-branch: 50 | 0 <= i0@85@03]
(assert (<= 0 i0@85@03))
; [eval] i0 < dim0
(pop) ; 8
(push) ; 8
; [else-branch: 50 | !(0 <= i0@85@03)]
(assert (not (<= 0 i0@85@03)))
(pop) ; 8
(pop) ; 7
; Joined path conditions
; Joined path conditions
(push) ; 7
; [then-branch: 51 | i0@85@03 < V@12@03 && 0 <= i0@85@03 | live]
; [else-branch: 51 | !(i0@85@03 < V@12@03 && 0 <= i0@85@03) | live]
(push) ; 8
; [then-branch: 51 | i0@85@03 < V@12@03 && 0 <= i0@85@03]
(assert (and (< i0@85@03 V@12@03) (<= 0 i0@85@03)))
; [eval] aloc(opt_get1(res), i0).bool == false
; [eval] aloc(opt_get1(res), i0)
; [eval] opt_get1(res)
(push) ; 9
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(set-option :timeout 0)
(push) ; 10
(assert (not (not (= res@79@03 (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1248
;  :arith-add-rows          244
;  :arith-assert-diseq      32
;  :arith-assert-lower      183
;  :arith-assert-upper      88
;  :arith-bound-prop        34
;  :arith-conflicts         22
;  :arith-eq-adapter        90
;  :arith-fixed-eqs         37
;  :arith-offset-eqs        23
;  :arith-pivots            142
;  :conflicts               56
;  :datatype-accessor-ax    39
;  :datatype-constructor-ax 138
;  :datatype-occurs-check   76
;  :datatype-splits         47
;  :decisions               152
;  :del-clause              621
;  :final-checks            44
;  :max-generation          5
;  :max-memory              5.12
;  :memory                  5.10
;  :minimized-lits          1
;  :mk-bool-var             1841
;  :mk-clause               629
;  :num-allocs              196177
;  :num-checks              73
;  :propagations            244
;  :quant-instantiations    513
;  :rlimit-count            268352)
(assert (not (= res@79@03 (as None<option<array>>  option<array>))))
(pop) ; 9
; Joined path conditions
(assert (not (= res@79@03 (as None<option<array>>  option<array>))))
(push) ; 9
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 10
(assert (not (< i0@85@03 (alen<Int> (opt_get1 $Snap.unit res@79@03)))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1248
;  :arith-add-rows          244
;  :arith-assert-diseq      32
;  :arith-assert-lower      183
;  :arith-assert-upper      88
;  :arith-bound-prop        34
;  :arith-conflicts         22
;  :arith-eq-adapter        90
;  :arith-fixed-eqs         37
;  :arith-offset-eqs        23
;  :arith-pivots            142
;  :conflicts               56
;  :datatype-accessor-ax    39
;  :datatype-constructor-ax 138
;  :datatype-occurs-check   76
;  :datatype-splits         47
;  :decisions               152
;  :del-clause              621
;  :final-checks            44
;  :max-generation          5
;  :max-memory              5.12
;  :memory                  5.10
;  :minimized-lits          1
;  :mk-bool-var             1841
;  :mk-clause               629
;  :num-allocs              196197
;  :num-checks              74
;  :propagations            244
;  :quant-instantiations    513
;  :rlimit-count            268383)
(assert (< i0@85@03 (alen<Int> (opt_get1 $Snap.unit res@79@03))))
(pop) ; 9
; Joined path conditions
(assert (< i0@85@03 (alen<Int> (opt_get1 $Snap.unit res@79@03))))
(assert ($FVF.loc_bool ($FVF.lookup_bool (as sm@84@03  $FVF<Bool>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit res@79@03) i0@85@03)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit res@79@03) i0@85@03)))
(push) ; 9
(assert (not (and
  (<
    (inv@83@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@79@03) i0@85@03))
    V@12@03)
  (<=
    0
    (inv@83@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@79@03) i0@85@03))))))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1252
;  :arith-add-rows          249
;  :arith-assert-diseq      32
;  :arith-assert-lower      184
;  :arith-assert-upper      90
;  :arith-bound-prop        35
;  :arith-conflicts         23
;  :arith-eq-adapter        91
;  :arith-fixed-eqs         38
;  :arith-offset-eqs        23
;  :arith-pivots            144
;  :conflicts               57
;  :datatype-accessor-ax    39
;  :datatype-constructor-ax 138
;  :datatype-occurs-check   76
;  :datatype-splits         47
;  :decisions               152
;  :del-clause              621
;  :final-checks            44
;  :max-generation          5
;  :max-memory              5.12
;  :memory                  5.10
;  :minimized-lits          1
;  :mk-bool-var             1860
;  :mk-clause               643
;  :num-allocs              196456
;  :num-checks              75
;  :propagations            246
;  :quant-instantiations    523
;  :rlimit-count            269025)
(pop) ; 8
(push) ; 8
; [else-branch: 51 | !(i0@85@03 < V@12@03 && 0 <= i0@85@03)]
(assert (not (and (< i0@85@03 V@12@03) (<= 0 i0@85@03))))
(pop) ; 8
(pop) ; 7
; Joined path conditions
(assert (implies
  (and (< i0@85@03 V@12@03) (<= 0 i0@85@03))
  (and
    (< i0@85@03 V@12@03)
    (<= 0 i0@85@03)
    (not (= res@79@03 (as None<option<array>>  option<array>)))
    (< i0@85@03 (alen<Int> (opt_get1 $Snap.unit res@79@03)))
    ($FVF.loc_bool ($FVF.lookup_bool (as sm@84@03  $FVF<Bool>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@79@03) i0@85@03)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@79@03) i0@85@03)))))
; Joined path conditions
; Definitional axioms for snapshot map values
(pop) ; 6
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i0@85@03 Int)) (!
  (implies
    (and (< i0@85@03 V@12@03) (<= 0 i0@85@03))
    (and
      (< i0@85@03 V@12@03)
      (<= 0 i0@85@03)
      (not (= res@79@03 (as None<option<array>>  option<array>)))
      (< i0@85@03 (alen<Int> (opt_get1 $Snap.unit res@79@03)))
      ($FVF.loc_bool ($FVF.lookup_bool (as sm@84@03  $FVF<Bool>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit res@79@03) i0@85@03)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit res@79@03) i0@85@03))))
  :pattern (($FVF.loc_bool ($FVF.lookup_bool (as sm@84@03  $FVF<Bool>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit res@79@03) i0@85@03)) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit res@79@03) i0@85@03)))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (implies
  (= exc@78@03 $Ref.null)
  (forall ((i0@85@03 Int)) (!
    (implies
      (and (< i0@85@03 V@12@03) (<= 0 i0@85@03))
      (and
        (< i0@85@03 V@12@03)
        (<= 0 i0@85@03)
        (not (= res@79@03 (as None<option<array>>  option<array>)))
        (< i0@85@03 (alen<Int> (opt_get1 $Snap.unit res@79@03)))
        ($FVF.loc_bool ($FVF.lookup_bool (as sm@84@03  $FVF<Bool>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@79@03) i0@85@03)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@79@03) i0@85@03))))
    :pattern (($FVF.loc_bool ($FVF.lookup_bool (as sm@84@03  $FVF<Bool>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@79@03) i0@85@03)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@79@03) i0@85@03)))
    :qid |prog.l<no position>-aux|))))
(assert (implies
  (= exc@78@03 $Ref.null)
  (forall ((i0@85@03 Int)) (!
    (implies
      (and (< i0@85@03 V@12@03) (<= 0 i0@85@03))
      (=
        ($FVF.lookup_bool (as sm@84@03  $FVF<Bool>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@79@03) i0@85@03))
        false))
    :pattern (($FVF.loc_bool ($FVF.lookup_bool (as sm@84@03  $FVF<Bool>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@79@03) i0@85@03)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@79@03) i0@85@03)))
    :qid |prog.l<no position>|))))
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
; [eval] exc != null
; [then-branch: 52 | exc@78@03 != Null | dead]
; [else-branch: 52 | exc@78@03 == Null | live]
(push) ; 4
; [else-branch: 52 | exc@78@03 == Null]
(pop) ; 4
; [eval] !(exc != null)
; [eval] exc != null
(set-option :timeout 10)
(push) ; 4
(assert (not (not (= exc@78@03 $Ref.null))))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1292
;  :arith-add-rows          251
;  :arith-assert-diseq      32
;  :arith-assert-lower      184
;  :arith-assert-upper      90
;  :arith-bound-prop        35
;  :arith-conflicts         23
;  :arith-eq-adapter        91
;  :arith-fixed-eqs         38
;  :arith-offset-eqs        23
;  :arith-pivots            146
;  :conflicts               57
;  :datatype-accessor-ax    39
;  :datatype-constructor-ax 148
;  :datatype-occurs-check   82
;  :datatype-splits         49
;  :decisions               162
;  :del-clause              635
;  :final-checks            48
;  :max-generation          5
;  :max-memory              5.12
;  :memory                  5.10
;  :minimized-lits          1
;  :mk-bool-var             1864
;  :mk-clause               643
;  :num-allocs              198132
;  :num-checks              77
;  :propagations            246
;  :quant-instantiations    523
;  :rlimit-count            270856)
; [then-branch: 53 | exc@78@03 == Null | live]
; [else-branch: 53 | exc@78@03 != Null | dead]
(push) ; 4
; [then-branch: 53 | exc@78@03 == Null]
; [exec]
; visited := res1
; [exec]
; exc, res2 := initializeVisited(this, tid, visited, s, V)
; [eval] this != null
; [eval] visited != (None(): option[array])
; [eval] (None(): option[array])
(set-option :timeout 0)
(push) ; 5
(assert (not (not (= res@79@03 (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1292
;  :arith-add-rows          251
;  :arith-assert-diseq      32
;  :arith-assert-lower      184
;  :arith-assert-upper      90
;  :arith-bound-prop        35
;  :arith-conflicts         23
;  :arith-eq-adapter        91
;  :arith-fixed-eqs         38
;  :arith-offset-eqs        23
;  :arith-pivots            146
;  :conflicts               57
;  :datatype-accessor-ax    39
;  :datatype-constructor-ax 148
;  :datatype-occurs-check   82
;  :datatype-splits         49
;  :decisions               162
;  :del-clause              635
;  :final-checks            48
;  :max-generation          5
;  :max-memory              5.12
;  :memory                  5.11
;  :minimized-lits          1
;  :mk-bool-var             1864
;  :mk-clause               643
;  :num-allocs              198156
;  :num-checks              78
;  :propagations            246
;  :quant-instantiations    523
;  :rlimit-count            270872)
(assert (not (= res@79@03 (as None<option<array>>  option<array>))))
; [eval] alen(opt_get1(visited)) == V
; [eval] alen(opt_get1(visited))
; [eval] opt_get1(visited)
(push) ; 5
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 5
; Joined path conditions
(push) ; 5
(assert (not (= (alen<Int> (opt_get1 $Snap.unit res@79@03)) V@12@03)))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1292
;  :arith-add-rows          251
;  :arith-assert-diseq      32
;  :arith-assert-lower      184
;  :arith-assert-upper      90
;  :arith-bound-prop        35
;  :arith-conflicts         23
;  :arith-eq-adapter        91
;  :arith-fixed-eqs         38
;  :arith-offset-eqs        23
;  :arith-pivots            146
;  :conflicts               57
;  :datatype-accessor-ax    39
;  :datatype-constructor-ax 148
;  :datatype-occurs-check   82
;  :datatype-splits         49
;  :decisions               162
;  :del-clause              635
;  :final-checks            48
;  :max-generation          5
;  :max-memory              5.12
;  :memory                  5.11
;  :minimized-lits          1
;  :mk-bool-var             1864
;  :mk-clause               643
;  :num-allocs              198172
;  :num-checks              79
;  :propagations            246
;  :quant-instantiations    523
;  :rlimit-count            270891)
(assert (= (alen<Int> (opt_get1 $Snap.unit res@79@03)) V@12@03))
; [eval] 0 <= s
; [eval] s < V
(declare-const k@86@03 Int)
(push) ; 5
; [eval] 0 <= k && k < V
; [eval] 0 <= k
(push) ; 6
; [then-branch: 54 | 0 <= k@86@03 | live]
; [else-branch: 54 | !(0 <= k@86@03) | live]
(push) ; 7
; [then-branch: 54 | 0 <= k@86@03]
(assert (<= 0 k@86@03))
; [eval] k < V
(pop) ; 7
(push) ; 7
; [else-branch: 54 | !(0 <= k@86@03)]
(assert (not (<= 0 k@86@03)))
(pop) ; 7
(pop) ; 6
; Joined path conditions
; Joined path conditions
(assert (and (< k@86@03 V@12@03) (<= 0 k@86@03)))
; [eval] aloc(opt_get1(visited), k)
; [eval] opt_get1(visited)
(push) ; 6
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 6
; Joined path conditions
(push) ; 6
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 7
(assert (not (< k@86@03 (alen<Int> (opt_get1 $Snap.unit res@79@03)))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1292
;  :arith-add-rows          251
;  :arith-assert-diseq      32
;  :arith-assert-lower      186
;  :arith-assert-upper      90
;  :arith-bound-prop        35
;  :arith-conflicts         23
;  :arith-eq-adapter        91
;  :arith-fixed-eqs         38
;  :arith-offset-eqs        23
;  :arith-pivots            146
;  :conflicts               57
;  :datatype-accessor-ax    39
;  :datatype-constructor-ax 148
;  :datatype-occurs-check   82
;  :datatype-splits         49
;  :decisions               162
;  :del-clause              635
;  :final-checks            48
;  :max-generation          5
;  :max-memory              5.12
;  :memory                  5.11
;  :minimized-lits          1
;  :mk-bool-var             1866
;  :mk-clause               643
;  :num-allocs              198267
;  :num-checks              80
;  :propagations            246
;  :quant-instantiations    523
;  :rlimit-count            271074)
(assert (< k@86@03 (alen<Int> (opt_get1 $Snap.unit res@79@03))))
(pop) ; 6
; Joined path conditions
(assert (< k@86@03 (alen<Int> (opt_get1 $Snap.unit res@79@03))))
(pop) ; 5
(declare-fun inv@87@03 ($Ref) Int)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(assert (forall ((k@86@03 Int)) (!
  (< k@86@03 (alen<Int> (opt_get1 $Snap.unit res@79@03)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@79@03) k@86@03))
  :qid |bool-aux|)))
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 5
(assert (not (forall ((k1@86@03 Int) (k2@86@03 Int)) (!
  (implies
    (and
      (and
        (and (< k1@86@03 V@12@03) (<= 0 k1@86@03))
        ($FVF.loc_bool ($FVF.lookup_bool (as sm@84@03  $FVF<Bool>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@79@03) k1@86@03)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@79@03) k1@86@03)))
      (and
        (and (< k2@86@03 V@12@03) (<= 0 k2@86@03))
        ($FVF.loc_bool ($FVF.lookup_bool (as sm@84@03  $FVF<Bool>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@79@03) k2@86@03)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@79@03) k2@86@03)))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@79@03) k1@86@03)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@79@03) k2@86@03)))
    (= k1@86@03 k2@86@03))
  
  :qid |bool-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1305
;  :arith-add-rows          253
;  :arith-assert-diseq      33
;  :arith-assert-lower      190
;  :arith-assert-upper      90
;  :arith-bound-prop        35
;  :arith-conflicts         23
;  :arith-eq-adapter        93
;  :arith-fixed-eqs         38
;  :arith-offset-eqs        23
;  :arith-pivots            146
;  :conflicts               58
;  :datatype-accessor-ax    39
;  :datatype-constructor-ax 148
;  :datatype-occurs-check   82
;  :datatype-splits         49
;  :decisions               162
;  :del-clause              656
;  :final-checks            48
;  :max-generation          5
;  :max-memory              5.12
;  :memory                  5.10
;  :minimized-lits          1
;  :mk-bool-var             1906
;  :mk-clause               664
;  :num-allocs              198849
;  :num-checks              81
;  :propagations            248
;  :quant-instantiations    544
;  :rlimit-count            272347)
; Definitional axioms for inverse functions
(assert (forall ((k@86@03 Int)) (!
  (implies
    (and (< k@86@03 V@12@03) (<= 0 k@86@03))
    (=
      (inv@87@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@79@03) k@86@03))
      k@86@03))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@79@03) k@86@03))
  :qid |bool-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@87@03 r) V@12@03) (<= 0 (inv@87@03 r)))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@79@03) (inv@87@03 r))
      r))
  :pattern ((inv@87@03 r))
  :qid |bool-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@87@03 r) V@12@03) (<= 0 (inv@87@03 r)))
    ($FVF.loc_bool ($FVF.lookup_bool (as sm@84@03  $FVF<Bool>) r) r))
  :pattern ((inv@87@03 r))
  )))
; Precomputing data for removing quantified permissions
(define-fun pTaken@88@03 ((r $Ref)) $Perm
  (ite
    (and (< (inv@87@03 r) V@12@03) (<= 0 (inv@87@03 r)))
    ($Perm.min
      (ite
        (and (< (inv@83@03 r) V@12@03) (<= 0 (inv@83@03 r)))
        $Perm.Write
        $Perm.No)
      $Perm.Write)
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 500)
(push) ; 5
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and (< (inv@83@03 r) V@12@03) (<= 0 (inv@83@03 r)))
        $Perm.Write
        $Perm.No)
      (pTaken@88@03 r))
    $Perm.No)
  
  ))))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1400
;  :arith-add-rows          280
;  :arith-assert-diseq      37
;  :arith-assert-lower      200
;  :arith-assert-upper      95
;  :arith-bound-prop        37
;  :arith-conflicts         24
;  :arith-eq-adapter        107
;  :arith-fixed-eqs         40
;  :arith-offset-eqs        24
;  :arith-pivots            155
;  :conflicts               67
;  :datatype-accessor-ax    39
;  :datatype-constructor-ax 157
;  :datatype-occurs-check   85
;  :datatype-splits         50
;  :decisions               176
;  :del-clause              721
;  :final-checks            50
;  :max-generation          5
;  :max-memory              5.12
;  :memory                  5.10
;  :minimized-lits          2
;  :mk-bool-var             1996
;  :mk-clause               729
;  :num-allocs              200526
;  :num-checks              83
;  :propagations            287
;  :quant-instantiations    575
;  :rlimit-count            275242)
; Intermediate check if already taken enough permissions
(push) ; 5
(assert (not (forall ((r $Ref)) (!
  (implies
    (and (< (inv@87@03 r) V@12@03) (<= 0 (inv@87@03 r)))
    (= (- $Perm.Write (pTaken@88@03 r)) $Perm.No))
  
  ))))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1418
;  :arith-add-rows          287
;  :arith-assert-diseq      39
;  :arith-assert-lower      204
;  :arith-assert-upper      100
;  :arith-bound-prop        38
;  :arith-conflicts         25
;  :arith-eq-adapter        110
;  :arith-fixed-eqs         41
;  :arith-offset-eqs        24
;  :arith-pivots            159
;  :conflicts               68
;  :datatype-accessor-ax    39
;  :datatype-constructor-ax 157
;  :datatype-occurs-check   85
;  :datatype-splits         50
;  :decisions               176
;  :del-clause              743
;  :final-checks            50
;  :max-generation          5
;  :max-memory              5.13
;  :memory                  5.11
;  :minimized-lits          2
;  :mk-bool-var             2035
;  :mk-clause               751
;  :num-allocs              200902
;  :num-checks              84
;  :propagations            293
;  :quant-instantiations    590
;  :rlimit-count            276324)
; Final check if taken enough permissions
; Done removing quantified permissions
; Definitional axioms for snapshot map values
(declare-const exc@89@03 $Ref)
(declare-const res@90@03 void)
(declare-const $t@91@03 $Snap)
(assert (= $t@91@03 ($Snap.combine ($Snap.first $t@91@03) ($Snap.second $t@91@03))))
(assert (= ($Snap.first $t@91@03) $Snap.unit))
; [eval] exc == null
(assert (= exc@89@03 $Ref.null))
(assert (=
  ($Snap.second $t@91@03)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@91@03))
    ($Snap.second ($Snap.second $t@91@03)))))
(assert (= ($Snap.first ($Snap.second $t@91@03)) $Snap.unit))
; [eval] exc == null ==> visited != (None(): option[array])
; [eval] exc == null
(push) ; 5
(set-option :timeout 10)
(push) ; 6
(assert (not (not (= exc@89@03 $Ref.null))))
(check-sat)
; unknown
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1455
;  :arith-add-rows          287
;  :arith-assert-diseq      39
;  :arith-assert-lower      204
;  :arith-assert-upper      100
;  :arith-bound-prop        38
;  :arith-conflicts         25
;  :arith-eq-adapter        110
;  :arith-fixed-eqs         41
;  :arith-offset-eqs        24
;  :arith-pivots            159
;  :conflicts               68
;  :datatype-accessor-ax    41
;  :datatype-constructor-ax 163
;  :datatype-occurs-check   89
;  :datatype-splits         52
;  :decisions               182
;  :del-clause              743
;  :final-checks            52
;  :max-generation          5
;  :max-memory              5.13
;  :memory                  5.12
;  :minimized-lits          2
;  :mk-bool-var             2042
;  :mk-clause               751
;  :num-allocs              201720
;  :num-checks              85
;  :propagations            293
;  :quant-instantiations    590
;  :rlimit-count            277194)
; [then-branch: 55 | exc@89@03 == Null | live]
; [else-branch: 55 | exc@89@03 != Null | dead]
(push) ; 6
; [then-branch: 55 | exc@89@03 == Null]
; [eval] visited != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 6
(pop) ; 5
; Joined path conditions
(assert (implies
  (= exc@89@03 $Ref.null)
  (not (= res@79@03 (as None<option<array>>  option<array>)))))
(assert (=
  ($Snap.second ($Snap.second $t@91@03))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second $t@91@03)))
    ($Snap.second ($Snap.second ($Snap.second $t@91@03))))))
(assert (= ($Snap.first ($Snap.second ($Snap.second $t@91@03))) $Snap.unit))
; [eval] exc == null ==> alen(opt_get1(visited)) == V
; [eval] exc == null
(push) ; 5
(push) ; 6
(assert (not (not (= exc@89@03 $Ref.null))))
(check-sat)
; unknown
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1486
;  :arith-add-rows          287
;  :arith-assert-diseq      39
;  :arith-assert-lower      204
;  :arith-assert-upper      100
;  :arith-bound-prop        38
;  :arith-conflicts         25
;  :arith-eq-adapter        110
;  :arith-fixed-eqs         41
;  :arith-offset-eqs        24
;  :arith-pivots            159
;  :conflicts               68
;  :datatype-accessor-ax    42
;  :datatype-constructor-ax 169
;  :datatype-occurs-check   93
;  :datatype-splits         54
;  :decisions               188
;  :del-clause              743
;  :final-checks            54
;  :max-generation          5
;  :max-memory              5.13
;  :memory                  5.12
;  :minimized-lits          2
;  :mk-bool-var             2046
;  :mk-clause               751
;  :num-allocs              202475
;  :num-checks              86
;  :propagations            293
;  :quant-instantiations    590
;  :rlimit-count            277944)
; [then-branch: 56 | exc@89@03 == Null | live]
; [else-branch: 56 | exc@89@03 != Null | dead]
(push) ; 6
; [then-branch: 56 | exc@89@03 == Null]
; [eval] alen(opt_get1(visited)) == V
; [eval] alen(opt_get1(visited))
; [eval] opt_get1(visited)
(push) ; 7
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 7
; Joined path conditions
(pop) ; 6
(pop) ; 5
; Joined path conditions
(assert (implies
  (= exc@89@03 $Ref.null)
  (= (alen<Int> (opt_get1 $Snap.unit res@79@03)) V@12@03)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second $t@91@03)))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@91@03))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@91@03)))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@91@03))))
  $Snap.unit))
; [eval] exc == null ==> 0 <= s
; [eval] exc == null
(push) ; 5
(push) ; 6
(assert (not (not (= exc@89@03 $Ref.null))))
(check-sat)
; unknown
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1518
;  :arith-add-rows          287
;  :arith-assert-diseq      39
;  :arith-assert-lower      204
;  :arith-assert-upper      100
;  :arith-bound-prop        38
;  :arith-conflicts         25
;  :arith-eq-adapter        110
;  :arith-fixed-eqs         41
;  :arith-offset-eqs        24
;  :arith-pivots            159
;  :conflicts               68
;  :datatype-accessor-ax    43
;  :datatype-constructor-ax 175
;  :datatype-occurs-check   97
;  :datatype-splits         56
;  :decisions               194
;  :del-clause              743
;  :final-checks            56
;  :max-generation          5
;  :max-memory              5.13
;  :memory                  5.12
;  :minimized-lits          2
;  :mk-bool-var             2050
;  :mk-clause               751
;  :num-allocs              203236
;  :num-checks              87
;  :propagations            293
;  :quant-instantiations    590
;  :rlimit-count            278712)
; [then-branch: 57 | exc@89@03 == Null | live]
; [else-branch: 57 | exc@89@03 != Null | dead]
(push) ; 6
; [then-branch: 57 | exc@89@03 == Null]
; [eval] 0 <= s
(pop) ; 6
(pop) ; 5
; Joined path conditions
(assert (implies (= exc@89@03 $Ref.null) (<= 0 s@13@03)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@91@03))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@91@03)))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@91@03))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@91@03)))))
  $Snap.unit))
; [eval] exc == null ==> s < V
; [eval] exc == null
(push) ; 5
(push) ; 6
(assert (not (not (= exc@89@03 $Ref.null))))
(check-sat)
; unknown
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1551
;  :arith-add-rows          287
;  :arith-assert-diseq      39
;  :arith-assert-lower      204
;  :arith-assert-upper      100
;  :arith-bound-prop        38
;  :arith-conflicts         25
;  :arith-eq-adapter        110
;  :arith-fixed-eqs         41
;  :arith-offset-eqs        24
;  :arith-pivots            159
;  :conflicts               68
;  :datatype-accessor-ax    44
;  :datatype-constructor-ax 181
;  :datatype-occurs-check   101
;  :datatype-splits         58
;  :decisions               200
;  :del-clause              743
;  :final-checks            58
;  :max-generation          5
;  :max-memory              5.13
;  :memory                  5.12
;  :minimized-lits          2
;  :mk-bool-var             2054
;  :mk-clause               751
;  :num-allocs              204007
;  :num-checks              88
;  :propagations            293
;  :quant-instantiations    590
;  :rlimit-count            279495)
; [then-branch: 58 | exc@89@03 == Null | live]
; [else-branch: 58 | exc@89@03 != Null | dead]
(push) ; 6
; [then-branch: 58 | exc@89@03 == Null]
; [eval] s < V
(pop) ; 6
(pop) ; 5
; Joined path conditions
(assert (implies (= exc@89@03 $Ref.null) (< s@13@03 V@12@03)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@91@03)))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@91@03))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@91@03)))))))))
; [eval] exc == null
(push) ; 5
(assert (not (not (= exc@89@03 $Ref.null))))
(check-sat)
; unknown
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1586
;  :arith-add-rows          287
;  :arith-assert-diseq      39
;  :arith-assert-lower      204
;  :arith-assert-upper      100
;  :arith-bound-prop        38
;  :arith-conflicts         25
;  :arith-eq-adapter        110
;  :arith-fixed-eqs         41
;  :arith-offset-eqs        24
;  :arith-pivots            159
;  :conflicts               68
;  :datatype-accessor-ax    45
;  :datatype-constructor-ax 188
;  :datatype-occurs-check   105
;  :datatype-splits         61
;  :decisions               207
;  :del-clause              743
;  :final-checks            60
;  :max-generation          5
;  :max-memory              5.13
;  :memory                  5.12
;  :minimized-lits          2
;  :mk-bool-var             2058
;  :mk-clause               751
;  :num-allocs              204786
;  :num-checks              89
;  :propagations            293
;  :quant-instantiations    590
;  :rlimit-count            280279)
; [then-branch: 59 | exc@89@03 == Null | live]
; [else-branch: 59 | exc@89@03 != Null | dead]
(push) ; 5
; [then-branch: 59 | exc@89@03 == Null]
(declare-const k@92@03 Int)
(push) ; 6
; [eval] 0 <= k && k < V
; [eval] 0 <= k
(push) ; 7
; [then-branch: 60 | 0 <= k@92@03 | live]
; [else-branch: 60 | !(0 <= k@92@03) | live]
(push) ; 8
; [then-branch: 60 | 0 <= k@92@03]
(assert (<= 0 k@92@03))
; [eval] k < V
(pop) ; 8
(push) ; 8
; [else-branch: 60 | !(0 <= k@92@03)]
(assert (not (<= 0 k@92@03)))
(pop) ; 8
(pop) ; 7
; Joined path conditions
; Joined path conditions
(assert (and (< k@92@03 V@12@03) (<= 0 k@92@03)))
; [eval] aloc(opt_get1(visited), k)
; [eval] opt_get1(visited)
(push) ; 7
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 7
; Joined path conditions
(push) ; 7
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 8
(assert (not (< k@92@03 (alen<Int> (opt_get1 $Snap.unit res@79@03)))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1586
;  :arith-add-rows          287
;  :arith-assert-diseq      39
;  :arith-assert-lower      206
;  :arith-assert-upper      100
;  :arith-bound-prop        38
;  :arith-conflicts         25
;  :arith-eq-adapter        110
;  :arith-fixed-eqs         41
;  :arith-offset-eqs        24
;  :arith-pivots            159
;  :conflicts               68
;  :datatype-accessor-ax    45
;  :datatype-constructor-ax 188
;  :datatype-occurs-check   105
;  :datatype-splits         61
;  :decisions               207
;  :del-clause              743
;  :final-checks            60
;  :max-generation          5
;  :max-memory              5.13
;  :memory                  5.12
;  :minimized-lits          2
;  :mk-bool-var             2060
;  :mk-clause               751
;  :num-allocs              204889
;  :num-checks              90
;  :propagations            293
;  :quant-instantiations    590
;  :rlimit-count            280462)
(assert (< k@92@03 (alen<Int> (opt_get1 $Snap.unit res@79@03))))
(pop) ; 7
; Joined path conditions
(assert (< k@92@03 (alen<Int> (opt_get1 $Snap.unit res@79@03))))
(pop) ; 6
(declare-fun inv@93@03 ($Ref) Int)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(assert (forall ((k@92@03 Int)) (!
  (< k@92@03 (alen<Int> (opt_get1 $Snap.unit res@79@03)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@79@03) k@92@03))
  :qid |bool-aux|)))
; Check receiver injectivity
(push) ; 6
(assert (not (forall ((k1@92@03 Int) (k2@92@03 Int)) (!
  (implies
    (and
      (and (< k1@92@03 V@12@03) (<= 0 k1@92@03))
      (and (< k2@92@03 V@12@03) (<= 0 k2@92@03))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@79@03) k1@92@03)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@79@03) k2@92@03)))
    (= k1@92@03 k2@92@03))
  
  :qid |bool-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1593
;  :arith-add-rows          289
;  :arith-assert-diseq      40
;  :arith-assert-lower      210
;  :arith-assert-upper      100
;  :arith-bound-prop        38
;  :arith-conflicts         25
;  :arith-eq-adapter        111
;  :arith-fixed-eqs         41
;  :arith-offset-eqs        24
;  :arith-pivots            159
;  :conflicts               69
;  :datatype-accessor-ax    45
;  :datatype-constructor-ax 188
;  :datatype-occurs-check   105
;  :datatype-splits         61
;  :decisions               207
;  :del-clause              749
;  :final-checks            60
;  :max-generation          5
;  :max-memory              5.13
;  :memory                  5.11
;  :minimized-lits          2
;  :mk-bool-var             2078
;  :mk-clause               757
;  :num-allocs              205381
;  :num-checks              91
;  :propagations            293
;  :quant-instantiations    600
;  :rlimit-count            281286)
; Definitional axioms for inverse functions
(assert (forall ((k@92@03 Int)) (!
  (implies
    (and (< k@92@03 V@12@03) (<= 0 k@92@03))
    (=
      (inv@93@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@79@03) k@92@03))
      k@92@03))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@79@03) k@92@03))
  )))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@93@03 r) V@12@03) (<= 0 (inv@93@03 r)))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@79@03) (inv@93@03 r))
      r))
  :pattern ((inv@93@03 r))
  :qid |bool-fctOfInv|)))
; Permissions are non-negative
; Field permissions are at most one
; Permission implies non-null receiver
(assert (forall ((k@92@03 Int)) (!
  (implies
    (and (< k@92@03 V@12@03) (<= 0 k@92@03))
    (not
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@79@03) k@92@03)
        $Ref.null)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@79@03) k@92@03))
  :qid |bool-permImpliesNonNull|)))
(declare-const sm@94@03 $FVF<Bool>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@93@03 r) V@12@03) (<= 0 (inv@93@03 r)))
    (=
      ($FVF.lookup_bool (as sm@94@03  $FVF<Bool>) r)
      ($FVF.lookup_bool ($SortWrappers.$SnapTo$FVF<Bool> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@91@03))))))) r)))
  :pattern (($FVF.lookup_bool (as sm@94@03  $FVF<Bool>) r))
  :pattern (($FVF.lookup_bool ($SortWrappers.$SnapTo$FVF<Bool> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@91@03))))))) r))
  :qid |qp.fvfValDef27|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_bool ($FVF.lookup_bool ($SortWrappers.$SnapTo$FVF<Bool> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@91@03))))))) r) r)
  :pattern (($FVF.lookup_bool (as sm@94@03  $FVF<Bool>) r))
  :qid |qp.fvfResTrgDef28|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@93@03 r) V@12@03) (<= 0 (inv@93@03 r)))
    ($FVF.loc_bool ($FVF.lookup_bool (as sm@94@03  $FVF<Bool>) r) r))
  :pattern ((inv@93@03 r))
  )))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@91@03))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@91@03)))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@91@03))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@91@03)))))))
  $Snap.unit))
; [eval] exc == null ==> (forall k: Int :: { aloc(opt_get1(visited), k) } 0 <= k && k < V && k != s ==> aloc(opt_get1(visited), k).bool == false)
; [eval] exc == null
(push) ; 6
(set-option :timeout 10)
(push) ; 7
(assert (not (not (= exc@89@03 $Ref.null))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1631
;  :arith-add-rows          289
;  :arith-assert-diseq      40
;  :arith-assert-lower      210
;  :arith-assert-upper      100
;  :arith-bound-prop        38
;  :arith-conflicts         25
;  :arith-eq-adapter        111
;  :arith-fixed-eqs         41
;  :arith-offset-eqs        24
;  :arith-pivots            159
;  :conflicts               69
;  :datatype-accessor-ax    46
;  :datatype-constructor-ax 195
;  :datatype-occurs-check   109
;  :datatype-splits         64
;  :decisions               214
;  :del-clause              749
;  :final-checks            62
;  :max-generation          5
;  :max-memory              5.14
;  :memory                  5.12
;  :minimized-lits          2
;  :mk-bool-var             2089
;  :mk-clause               757
;  :num-allocs              206999
;  :num-checks              92
;  :propagations            293
;  :quant-instantiations    600
;  :rlimit-count            283940)
; [then-branch: 61 | exc@89@03 == Null | live]
; [else-branch: 61 | exc@89@03 != Null | dead]
(push) ; 7
; [then-branch: 61 | exc@89@03 == Null]
; [eval] (forall k: Int :: { aloc(opt_get1(visited), k) } 0 <= k && k < V && k != s ==> aloc(opt_get1(visited), k).bool == false)
(declare-const k@95@03 Int)
(push) ; 8
; [eval] 0 <= k && k < V && k != s ==> aloc(opt_get1(visited), k).bool == false
; [eval] 0 <= k && k < V && k != s
; [eval] 0 <= k
(push) ; 9
; [then-branch: 62 | 0 <= k@95@03 | live]
; [else-branch: 62 | !(0 <= k@95@03) | live]
(push) ; 10
; [then-branch: 62 | 0 <= k@95@03]
(assert (<= 0 k@95@03))
; [eval] k < V
(push) ; 11
; [then-branch: 63 | k@95@03 < V@12@03 | live]
; [else-branch: 63 | !(k@95@03 < V@12@03) | live]
(push) ; 12
; [then-branch: 63 | k@95@03 < V@12@03]
(assert (< k@95@03 V@12@03))
; [eval] k != s
(pop) ; 12
(push) ; 12
; [else-branch: 63 | !(k@95@03 < V@12@03)]
(assert (not (< k@95@03 V@12@03)))
(pop) ; 12
(pop) ; 11
; Joined path conditions
; Joined path conditions
(pop) ; 10
(push) ; 10
; [else-branch: 62 | !(0 <= k@95@03)]
(assert (not (<= 0 k@95@03)))
(pop) ; 10
(pop) ; 9
; Joined path conditions
; Joined path conditions
(push) ; 9
; [then-branch: 64 | k@95@03 != s@13@03 && k@95@03 < V@12@03 && 0 <= k@95@03 | live]
; [else-branch: 64 | !(k@95@03 != s@13@03 && k@95@03 < V@12@03 && 0 <= k@95@03) | live]
(push) ; 10
; [then-branch: 64 | k@95@03 != s@13@03 && k@95@03 < V@12@03 && 0 <= k@95@03]
(assert (and (and (not (= k@95@03 s@13@03)) (< k@95@03 V@12@03)) (<= 0 k@95@03)))
; [eval] aloc(opt_get1(visited), k).bool == false
; [eval] aloc(opt_get1(visited), k)
; [eval] opt_get1(visited)
(push) ; 11
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 11
; Joined path conditions
(push) ; 11
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 12
(assert (not (< k@95@03 (alen<Int> (opt_get1 $Snap.unit res@79@03)))))
(check-sat)
; unsat
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1632
;  :arith-add-rows          290
;  :arith-assert-diseq      43
;  :arith-assert-lower      213
;  :arith-assert-upper      100
;  :arith-bound-prop        38
;  :arith-conflicts         25
;  :arith-eq-adapter        112
;  :arith-fixed-eqs         41
;  :arith-offset-eqs        24
;  :arith-pivots            159
;  :conflicts               69
;  :datatype-accessor-ax    46
;  :datatype-constructor-ax 195
;  :datatype-occurs-check   109
;  :datatype-splits         64
;  :decisions               214
;  :del-clause              749
;  :final-checks            62
;  :max-generation          5
;  :max-memory              5.14
;  :memory                  5.12
;  :minimized-lits          2
;  :mk-bool-var             2096
;  :mk-clause               761
;  :num-allocs              207191
;  :num-checks              93
;  :propagations            293
;  :quant-instantiations    600
;  :rlimit-count            284261)
(assert (< k@95@03 (alen<Int> (opt_get1 $Snap.unit res@79@03))))
(pop) ; 11
; Joined path conditions
(assert (< k@95@03 (alen<Int> (opt_get1 $Snap.unit res@79@03))))
(assert ($FVF.loc_bool ($FVF.lookup_bool (as sm@94@03  $FVF<Bool>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit res@79@03) k@95@03)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit res@79@03) k@95@03)))
(push) ; 11
(assert (not (and
  (<
    (inv@93@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@79@03) k@95@03))
    V@12@03)
  (<=
    0
    (inv@93@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@79@03) k@95@03))))))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1640
;  :arith-add-rows          299
;  :arith-assert-diseq      43
;  :arith-assert-lower      215
;  :arith-assert-upper      103
;  :arith-bound-prop        40
;  :arith-conflicts         26
;  :arith-eq-adapter        114
;  :arith-fixed-eqs         43
;  :arith-offset-eqs        24
;  :arith-pivots            162
;  :conflicts               70
;  :datatype-accessor-ax    46
;  :datatype-constructor-ax 195
;  :datatype-occurs-check   109
;  :datatype-splits         64
;  :decisions               214
;  :del-clause              749
;  :final-checks            62
;  :max-generation          5
;  :max-memory              5.14
;  :memory                  5.12
;  :minimized-lits          2
;  :mk-bool-var             2124
;  :mk-clause               774
;  :num-allocs              207474
;  :num-checks              94
;  :propagations            293
;  :quant-instantiations    613
;  :rlimit-count            285069)
(pop) ; 10
(push) ; 10
; [else-branch: 64 | !(k@95@03 != s@13@03 && k@95@03 < V@12@03 && 0 <= k@95@03)]
(assert (not (and (and (not (= k@95@03 s@13@03)) (< k@95@03 V@12@03)) (<= 0 k@95@03))))
(pop) ; 10
(pop) ; 9
; Joined path conditions
(assert (implies
  (and (and (not (= k@95@03 s@13@03)) (< k@95@03 V@12@03)) (<= 0 k@95@03))
  (and
    (not (= k@95@03 s@13@03))
    (< k@95@03 V@12@03)
    (<= 0 k@95@03)
    (< k@95@03 (alen<Int> (opt_get1 $Snap.unit res@79@03)))
    ($FVF.loc_bool ($FVF.lookup_bool (as sm@94@03  $FVF<Bool>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@79@03) k@95@03)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@79@03) k@95@03)))))
; Joined path conditions
(pop) ; 8
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((k@95@03 Int)) (!
  (implies
    (and (and (not (= k@95@03 s@13@03)) (< k@95@03 V@12@03)) (<= 0 k@95@03))
    (and
      (not (= k@95@03 s@13@03))
      (< k@95@03 V@12@03)
      (<= 0 k@95@03)
      (< k@95@03 (alen<Int> (opt_get1 $Snap.unit res@79@03)))
      ($FVF.loc_bool ($FVF.lookup_bool (as sm@94@03  $FVF<Bool>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit res@79@03) k@95@03)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit res@79@03) k@95@03))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@79@03) k@95@03))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 7
(pop) ; 6
; Joined path conditions
(assert (implies
  (= exc@89@03 $Ref.null)
  (forall ((k@95@03 Int)) (!
    (implies
      (and (and (not (= k@95@03 s@13@03)) (< k@95@03 V@12@03)) (<= 0 k@95@03))
      (and
        (not (= k@95@03 s@13@03))
        (< k@95@03 V@12@03)
        (<= 0 k@95@03)
        (< k@95@03 (alen<Int> (opt_get1 $Snap.unit res@79@03)))
        ($FVF.loc_bool ($FVF.lookup_bool (as sm@94@03  $FVF<Bool>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@79@03) k@95@03)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@79@03) k@95@03))))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@79@03) k@95@03))
    :qid |prog.l<no position>-aux|))))
(assert (implies
  (= exc@89@03 $Ref.null)
  (forall ((k@95@03 Int)) (!
    (implies
      (and (and (not (= k@95@03 s@13@03)) (< k@95@03 V@12@03)) (<= 0 k@95@03))
      (=
        ($FVF.lookup_bool (as sm@94@03  $FVF<Bool>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@79@03) k@95@03))
        false))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@79@03) k@95@03))
    :qid |prog.l<no position>|))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@91@03)))))))
  $Snap.unit))
; [eval] exc == null ==> aloc(opt_get1(visited), s).bool == true
; [eval] exc == null
(push) ; 6
(set-option :timeout 10)
(push) ; 7
(assert (not (not (= exc@89@03 $Ref.null))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1671
;  :arith-add-rows          303
;  :arith-assert-diseq      43
;  :arith-assert-lower      215
;  :arith-assert-upper      103
;  :arith-bound-prop        40
;  :arith-conflicts         26
;  :arith-eq-adapter        114
;  :arith-fixed-eqs         43
;  :arith-offset-eqs        24
;  :arith-pivots            165
;  :conflicts               70
;  :datatype-accessor-ax    46
;  :datatype-constructor-ax 201
;  :datatype-occurs-check   113
;  :datatype-splits         66
;  :decisions               220
;  :del-clause              766
;  :final-checks            64
;  :max-generation          5
;  :max-memory              5.14
;  :memory                  5.12
;  :minimized-lits          2
;  :mk-bool-var             2129
;  :mk-clause               774
;  :num-allocs              208554
;  :num-checks              95
;  :propagations            293
;  :quant-instantiations    613
;  :rlimit-count            286633)
; [then-branch: 65 | exc@89@03 == Null | live]
; [else-branch: 65 | exc@89@03 != Null | dead]
(push) ; 7
; [then-branch: 65 | exc@89@03 == Null]
; [eval] aloc(opt_get1(visited), s).bool == true
; [eval] aloc(opt_get1(visited), s)
; [eval] opt_get1(visited)
(push) ; 8
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 8
; Joined path conditions
(push) ; 8
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 9
(assert (not (< s@13@03 (alen<Int> (opt_get1 $Snap.unit res@79@03)))))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1671
;  :arith-add-rows          303
;  :arith-assert-diseq      43
;  :arith-assert-lower      215
;  :arith-assert-upper      103
;  :arith-bound-prop        40
;  :arith-conflicts         26
;  :arith-eq-adapter        114
;  :arith-fixed-eqs         43
;  :arith-offset-eqs        24
;  :arith-pivots            165
;  :conflicts               70
;  :datatype-accessor-ax    46
;  :datatype-constructor-ax 201
;  :datatype-occurs-check   113
;  :datatype-splits         66
;  :decisions               220
;  :del-clause              766
;  :final-checks            64
;  :max-generation          5
;  :max-memory              5.14
;  :memory                  5.12
;  :minimized-lits          2
;  :mk-bool-var             2129
;  :mk-clause               774
;  :num-allocs              208588
;  :num-checks              96
;  :propagations            293
;  :quant-instantiations    613
;  :rlimit-count            286668)
(assert (< s@13@03 (alen<Int> (opt_get1 $Snap.unit res@79@03))))
(pop) ; 8
; Joined path conditions
(assert (< s@13@03 (alen<Int> (opt_get1 $Snap.unit res@79@03))))
(assert ($FVF.loc_bool ($FVF.lookup_bool (as sm@94@03  $FVF<Bool>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit res@79@03) s@13@03)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit res@79@03) s@13@03)))
(push) ; 8
(assert (not (and
  (<
    (inv@93@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@79@03) s@13@03))
    V@12@03)
  (<=
    0
    (inv@93@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@79@03) s@13@03))))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1685
;  :arith-add-rows          314
;  :arith-assert-diseq      43
;  :arith-assert-lower      217
;  :arith-assert-upper      106
;  :arith-bound-prop        43
;  :arith-conflicts         27
;  :arith-eq-adapter        116
;  :arith-fixed-eqs         45
;  :arith-offset-eqs        25
;  :arith-pivots            168
;  :conflicts               71
;  :datatype-accessor-ax    46
;  :datatype-constructor-ax 201
;  :datatype-occurs-check   113
;  :datatype-splits         66
;  :decisions               220
;  :del-clause              766
;  :final-checks            64
;  :max-generation          5
;  :max-memory              5.14
;  :memory                  5.12
;  :minimized-lits          2
;  :mk-bool-var             2157
;  :mk-clause               787
;  :num-allocs              208868
;  :num-checks              97
;  :propagations            296
;  :quant-instantiations    626
;  :rlimit-count            287469)
(pop) ; 7
(pop) ; 6
; Joined path conditions
(assert (implies
  (= exc@89@03 $Ref.null)
  (and
    (< s@13@03 (alen<Int> (opt_get1 $Snap.unit res@79@03)))
    ($FVF.loc_bool ($FVF.lookup_bool (as sm@94@03  $FVF<Bool>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@79@03) s@13@03)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@79@03) s@13@03)))))
(assert (implies
  (= exc@89@03 $Ref.null)
  (=
    ($FVF.lookup_bool (as sm@94@03  $FVF<Bool>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@79@03) s@13@03))
    true)))
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
; [eval] exc != null
; [then-branch: 66 | exc@89@03 != Null | dead]
; [else-branch: 66 | exc@89@03 == Null | live]
(push) ; 6
; [else-branch: 66 | exc@89@03 == Null]
(pop) ; 6
; [eval] !(exc != null)
; [eval] exc != null
(set-option :timeout 10)
(push) ; 6
(assert (not (not (= exc@89@03 $Ref.null))))
(check-sat)
; unknown
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1799
;  :arith-add-rows          337
;  :arith-assert-diseq      43
;  :arith-assert-lower      223
;  :arith-assert-upper      112
;  :arith-bound-prop        50
;  :arith-conflicts         28
;  :arith-eq-adapter        121
;  :arith-fixed-eqs         50
;  :arith-offset-eqs        26
;  :arith-pivots            177
;  :conflicts               73
;  :datatype-accessor-ax    48
;  :datatype-constructor-ax 218
;  :datatype-occurs-check   127
;  :datatype-splits         74
;  :decisions               247
;  :del-clause              847
;  :final-checks            70
;  :max-generation          5
;  :max-memory              5.16
;  :memory                  5.15
;  :minimized-lits          2
;  :mk-bool-var             2284
;  :mk-clause               886
;  :num-allocs              211062
;  :num-checks              99
;  :propagations            324
;  :quant-instantiations    662
;  :rlimit-count            290641)
; [then-branch: 67 | exc@89@03 == Null | live]
; [else-branch: 67 | exc@89@03 != Null | dead]
(push) ; 6
; [then-branch: 67 | exc@89@03 == Null]
; [exec]
; evaluationDummy := res2
; [exec]
; queue := Seq(s)
; [eval] Seq(s)
(assert (= (Seq_length (Seq_singleton s@13@03)) 1))
(declare-const queue@96@03 Seq<Int>)
(assert (Seq_equal queue@96@03 (Seq_singleton s@13@03)))
; [exec]
; label loop
; [exec]
; excBeforeLoop := exc
(declare-const u@97@03 Int)
(declare-const evaluationDummy1@98@03 Seq<Int>)
(declare-const k@99@03 Int)
(declare-const excBeforeLoop1@100@03 $Ref)
(declare-const v@101@03 Int)
(declare-const queue@102@03 Seq<Int>)
(declare-const flatten@103@03 Int)
(declare-const evaluationDummy2@104@03 Int)
(push) ; 7
; Loop head block: Check well-definedness of invariant
(declare-const $t@105@03 $Snap)
(assert (= $t@105@03 ($Snap.combine ($Snap.first $t@105@03) ($Snap.second $t@105@03))))
(assert (= ($Snap.first $t@105@03) $Snap.unit))
; [eval] exc == excBeforeLoop
(assert (=
  ($Snap.second $t@105@03)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@105@03))
    ($Snap.second ($Snap.second $t@105@03)))))
(assert (= ($Snap.first ($Snap.second $t@105@03)) $Snap.unit))
; [eval] Gf != (None(): option[array])
; [eval] (None(): option[array])
(assert (=
  ($Snap.second ($Snap.second $t@105@03))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second $t@105@03)))
    ($Snap.second ($Snap.second ($Snap.second $t@105@03))))))
(assert (= ($Snap.first ($Snap.second ($Snap.second $t@105@03))) $Snap.unit))
; [eval] alen(opt_get1(Gf)) == V
; [eval] alen(opt_get1(Gf))
; [eval] opt_get1(Gf)
(push) ; 8
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 8
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second ($Snap.second $t@105@03)))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@105@03))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03)))))))
(declare-const i1@106@03 Int)
(push) ; 8
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 9
; [then-branch: 68 | 0 <= i1@106@03 | live]
; [else-branch: 68 | !(0 <= i1@106@03) | live]
(push) ; 10
; [then-branch: 68 | 0 <= i1@106@03]
(assert (<= 0 i1@106@03))
; [eval] i1 < V
(pop) ; 10
(push) ; 10
; [else-branch: 68 | !(0 <= i1@106@03)]
(assert (not (<= 0 i1@106@03)))
(pop) ; 10
(pop) ; 9
; Joined path conditions
; Joined path conditions
(assert (and (< i1@106@03 V@12@03) (<= 0 i1@106@03)))
; [eval] aloc(opt_get1(Gf), i1)
; [eval] opt_get1(Gf)
(push) ; 9
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 9
; Joined path conditions
(push) ; 9
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 10
(assert (not (< i1@106@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1828
;  :arith-add-rows          338
;  :arith-assert-diseq      44
;  :arith-assert-lower      229
;  :arith-assert-upper      114
;  :arith-bound-prop        50
;  :arith-conflicts         28
;  :arith-eq-adapter        124
;  :arith-fixed-eqs         51
;  :arith-offset-eqs        26
;  :arith-pivots            178
;  :conflicts               73
;  :datatype-accessor-ax    52
;  :datatype-constructor-ax 218
;  :datatype-occurs-check   127
;  :datatype-splits         74
;  :decisions               247
;  :del-clause              847
;  :final-checks            70
;  :max-generation          5
;  :max-memory              5.21
;  :memory                  5.20
;  :minimized-lits          2
;  :mk-bool-var             2314
;  :mk-clause               901
;  :num-allocs              211636
;  :num-checks              100
;  :propagations            330
;  :quant-instantiations    666
;  :rlimit-count            291701)
(assert (< i1@106@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03))))
(pop) ; 9
; Joined path conditions
(assert (< i1@106@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03))))
(declare-const $k@107@03 $Perm)
(assert ($Perm.isReadVar $k@107@03 $Perm.Write))
(pop) ; 8
(declare-fun inv@108@03 ($Ref) Int)
; Nested auxiliary terms: globals
(assert ($Perm.isReadVar $k@107@03 $Perm.Write))
; Nested auxiliary terms: non-globals
(assert (forall ((i1@106@03 Int)) (!
  (< i1@106@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@106@03))
  :qid |option$array$-aux|)))
(push) ; 8
(assert (not (forall ((i1@106@03 Int)) (!
  (implies
    (and (< i1@106@03 V@12@03) (<= 0 i1@106@03))
    (or (= $k@107@03 $Perm.No) (< $Perm.No $k@107@03)))
  
  ))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1828
;  :arith-add-rows          338
;  :arith-assert-diseq      45
;  :arith-assert-lower      231
;  :arith-assert-upper      115
;  :arith-bound-prop        50
;  :arith-conflicts         28
;  :arith-eq-adapter        125
;  :arith-fixed-eqs         51
;  :arith-offset-eqs        26
;  :arith-pivots            178
;  :conflicts               74
;  :datatype-accessor-ax    52
;  :datatype-constructor-ax 218
;  :datatype-occurs-check   127
;  :datatype-splits         74
;  :decisions               247
;  :del-clause              847
;  :final-checks            70
;  :max-generation          5
;  :max-memory              5.21
;  :memory                  5.20
;  :minimized-lits          2
;  :mk-bool-var             2321
;  :mk-clause               903
;  :num-allocs              212104
;  :num-checks              101
;  :propagations            331
;  :quant-instantiations    666
;  :rlimit-count            292271)
; Check receiver injectivity
(push) ; 8
(assert (not (forall ((i11@106@03 Int) (i12@106@03 Int)) (!
  (implies
    (and
      (and (and (< i11@106@03 V@12@03) (<= 0 i11@106@03)) (< $Perm.No $k@107@03))
      (and (and (< i12@106@03 V@12@03) (<= 0 i12@106@03)) (< $Perm.No $k@107@03))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i11@106@03)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i12@106@03)))
    (= i11@106@03 i12@106@03))
  
  :qid |option$array$-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1835
;  :arith-add-rows          340
;  :arith-assert-diseq      46
;  :arith-assert-lower      235
;  :arith-assert-upper      115
;  :arith-bound-prop        50
;  :arith-conflicts         28
;  :arith-eq-adapter        126
;  :arith-fixed-eqs         51
;  :arith-offset-eqs        26
;  :arith-pivots            178
;  :conflicts               75
;  :datatype-accessor-ax    52
;  :datatype-constructor-ax 218
;  :datatype-occurs-check   127
;  :datatype-splits         74
;  :decisions               247
;  :del-clause              853
;  :final-checks            70
;  :max-generation          5
;  :max-memory              5.21
;  :memory                  5.19
;  :minimized-lits          2
;  :mk-bool-var             2338
;  :mk-clause               909
;  :num-allocs              212471
;  :num-checks              102
;  :propagations            331
;  :quant-instantiations    677
;  :rlimit-count            292976)
; Definitional axioms for inverse functions
(assert (forall ((i1@106@03 Int)) (!
  (implies
    (and (and (< i1@106@03 V@12@03) (<= 0 i1@106@03)) (< $Perm.No $k@107@03))
    (=
      (inv@108@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@106@03))
      i1@106@03))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@106@03))
  )))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and (< (inv@108@03 r) V@12@03) (<= 0 (inv@108@03 r)))
      (< $Perm.No $k@107@03))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) (inv@108@03 r))
      r))
  :pattern ((inv@108@03 r))
  :qid |option$array$-fctOfInv|)))
; Permissions are non-negative
(assert (forall ((i1@106@03 Int)) (!
  (<= $Perm.No $k@107@03)
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@106@03))
  :qid |option$array$-permAtLeastZero|)))
; Field permissions are at most one
(assert (forall ((i1@106@03 Int)) (!
  (<= $k@107@03 $Perm.Write)
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@106@03))
  :qid |option$array$-permAtMostOne|)))
; Permission implies non-null receiver
(assert (forall ((i1@106@03 Int)) (!
  (implies
    (and (and (< i1@106@03 V@12@03) (<= 0 i1@106@03)) (< $Perm.No $k@107@03))
    (not
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@106@03)
        $Ref.null)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@106@03))
  :qid |option$array$-permImpliesNonNull|)))
(declare-const sm@109@03 $FVF<option<array>>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@108@03 r) V@12@03) (<= 0 (inv@108@03 r)))
      (< $Perm.No $k@107@03)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@109@03  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@105@03))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@109@03  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@105@03))))) r))
  :qid |qp.fvfValDef29|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@105@03))))) r) r)
  :pattern (($FVF.lookup_option$array$ (as sm@109@03  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef30|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@108@03 r) V@12@03) (<= 0 (inv@108@03 r)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@109@03  $FVF<option<array>>) r) r))
  :pattern ((inv@108@03 r))
  )))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03)))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03)))))
  $Snap.unit))
; [eval] (forall i1: Int :: { aloc(opt_get1(Gf), i1) } 0 <= i1 && i1 < V ==> aloc(opt_get1(Gf), i1).option$array$ != (None(): option[array]))
(declare-const i1@110@03 Int)
(push) ; 8
; [eval] 0 <= i1 && i1 < V ==> aloc(opt_get1(Gf), i1).option$array$ != (None(): option[array])
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 9
; [then-branch: 69 | 0 <= i1@110@03 | live]
; [else-branch: 69 | !(0 <= i1@110@03) | live]
(push) ; 10
; [then-branch: 69 | 0 <= i1@110@03]
(assert (<= 0 i1@110@03))
; [eval] i1 < V
(pop) ; 10
(push) ; 10
; [else-branch: 69 | !(0 <= i1@110@03)]
(assert (not (<= 0 i1@110@03)))
(pop) ; 10
(pop) ; 9
; Joined path conditions
; Joined path conditions
(push) ; 9
; [then-branch: 70 | i1@110@03 < V@12@03 && 0 <= i1@110@03 | live]
; [else-branch: 70 | !(i1@110@03 < V@12@03 && 0 <= i1@110@03) | live]
(push) ; 10
; [then-branch: 70 | i1@110@03 < V@12@03 && 0 <= i1@110@03]
(assert (and (< i1@110@03 V@12@03) (<= 0 i1@110@03)))
; [eval] aloc(opt_get1(Gf), i1).option$array$ != (None(): option[array])
; [eval] aloc(opt_get1(Gf), i1)
; [eval] opt_get1(Gf)
(push) ; 11
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 11
; Joined path conditions
(push) ; 11
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 12
(assert (not (< i1@110@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))))
(check-sat)
; unsat
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1841
;  :arith-add-rows          340
;  :arith-assert-diseq      46
;  :arith-assert-lower      237
;  :arith-assert-upper      116
;  :arith-bound-prop        50
;  :arith-conflicts         28
;  :arith-eq-adapter        126
;  :arith-fixed-eqs         51
;  :arith-offset-eqs        26
;  :arith-pivots            178
;  :conflicts               75
;  :datatype-accessor-ax    53
;  :datatype-constructor-ax 218
;  :datatype-occurs-check   127
;  :datatype-splits         74
;  :decisions               247
;  :del-clause              853
;  :final-checks            70
;  :max-generation          5
;  :max-memory              5.21
;  :memory                  5.20
;  :minimized-lits          2
;  :mk-bool-var             2349
;  :mk-clause               909
;  :num-allocs              213658
;  :num-checks              103
;  :propagations            331
;  :quant-instantiations    677
;  :rlimit-count            295313)
(assert (< i1@110@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03))))
(pop) ; 11
; Joined path conditions
(assert (< i1@110@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@109@03  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@110@03)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@110@03)))
(push) ; 11
(assert (not (ite
  (and
    (<
      (inv@108@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@110@03))
      V@12@03)
    (<=
      0
      (inv@108@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@110@03))))
  (< $Perm.No $k@107@03)
  false)))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1855
;  :arith-add-rows          348
;  :arith-assert-diseq      46
;  :arith-assert-lower      239
;  :arith-assert-upper      119
;  :arith-bound-prop        52
;  :arith-conflicts         29
;  :arith-eq-adapter        128
;  :arith-fixed-eqs         53
;  :arith-offset-eqs        26
;  :arith-pivots            181
;  :conflicts               76
;  :datatype-accessor-ax    53
;  :datatype-constructor-ax 218
;  :datatype-occurs-check   127
;  :datatype-splits         74
;  :decisions               247
;  :del-clause              853
;  :final-checks            70
;  :max-generation          5
;  :max-memory              5.23
;  :memory                  5.22
;  :minimized-lits          2
;  :mk-bool-var             2399
;  :mk-clause               929
;  :num-allocs              214116
;  :num-checks              104
;  :propagations            332
;  :quant-instantiations    700
;  :rlimit-count            296695)
; [eval] (None(): option[array])
(pop) ; 10
(push) ; 10
; [else-branch: 70 | !(i1@110@03 < V@12@03 && 0 <= i1@110@03)]
(assert (not (and (< i1@110@03 V@12@03) (<= 0 i1@110@03))))
(pop) ; 10
(pop) ; 9
; Joined path conditions
(assert (implies
  (and (< i1@110@03 V@12@03) (<= 0 i1@110@03))
  (and
    (< i1@110@03 V@12@03)
    (<= 0 i1@110@03)
    (< i1@110@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@109@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@110@03)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@110@03)))))
; Joined path conditions
(pop) ; 8
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@110@03 Int)) (!
  (implies
    (and (< i1@110@03 V@12@03) (<= 0 i1@110@03))
    (and
      (< i1@110@03 V@12@03)
      (<= 0 i1@110@03)
      (< i1@110@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@109@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@110@03)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@110@03))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@110@03))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(assert (forall ((i1@110@03 Int)) (!
  (implies
    (and (< i1@110@03 V@12@03) (<= 0 i1@110@03))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@109@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@110@03))
        (as None<option<array>>  option<array>))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@110@03))
  :qid |prog.l<no position>|)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03)))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03)))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03))))))
  $Snap.unit))
; [eval] (forall i1: Int :: { alen(opt_get1(aloc(opt_get1(Gf), i1).option$array$)) } 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(Gf), i1).option$array$)) == V)
(declare-const i1@111@03 Int)
(push) ; 8
; [eval] 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(Gf), i1).option$array$)) == V
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 9
; [then-branch: 71 | 0 <= i1@111@03 | live]
; [else-branch: 71 | !(0 <= i1@111@03) | live]
(push) ; 10
; [then-branch: 71 | 0 <= i1@111@03]
(assert (<= 0 i1@111@03))
; [eval] i1 < V
(pop) ; 10
(push) ; 10
; [else-branch: 71 | !(0 <= i1@111@03)]
(assert (not (<= 0 i1@111@03)))
(pop) ; 10
(pop) ; 9
; Joined path conditions
; Joined path conditions
(push) ; 9
; [then-branch: 72 | i1@111@03 < V@12@03 && 0 <= i1@111@03 | live]
; [else-branch: 72 | !(i1@111@03 < V@12@03 && 0 <= i1@111@03) | live]
(push) ; 10
; [then-branch: 72 | i1@111@03 < V@12@03 && 0 <= i1@111@03]
(assert (and (< i1@111@03 V@12@03) (<= 0 i1@111@03)))
; [eval] alen(opt_get1(aloc(opt_get1(Gf), i1).option$array$)) == V
; [eval] alen(opt_get1(aloc(opt_get1(Gf), i1).option$array$))
; [eval] opt_get1(aloc(opt_get1(Gf), i1).option$array$)
; [eval] aloc(opt_get1(Gf), i1)
; [eval] opt_get1(Gf)
(push) ; 11
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 11
; Joined path conditions
(push) ; 11
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 12
(assert (not (< i1@111@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))))
(check-sat)
; unsat
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1861
;  :arith-add-rows          351
;  :arith-assert-diseq      46
;  :arith-assert-lower      241
;  :arith-assert-upper      119
;  :arith-bound-prop        52
;  :arith-conflicts         29
;  :arith-eq-adapter        128
;  :arith-fixed-eqs         53
;  :arith-offset-eqs        26
;  :arith-pivots            184
;  :conflicts               76
;  :datatype-accessor-ax    54
;  :datatype-constructor-ax 218
;  :datatype-occurs-check   127
;  :datatype-splits         74
;  :decisions               247
;  :del-clause              873
;  :final-checks            70
;  :max-generation          5
;  :max-memory              5.23
;  :memory                  5.22
;  :minimized-lits          2
;  :mk-bool-var             2405
;  :mk-clause               929
;  :num-allocs              214647
;  :num-checks              105
;  :propagations            332
;  :quant-instantiations    700
;  :rlimit-count            297857)
(assert (< i1@111@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03))))
(pop) ; 11
; Joined path conditions
(assert (< i1@111@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@109@03  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@111@03)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@111@03)))
(push) ; 11
(assert (not (ite
  (and
    (<
      (inv@108@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@111@03))
      V@12@03)
    (<=
      0
      (inv@108@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@111@03))))
  (< $Perm.No $k@107@03)
  false)))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1875
;  :arith-add-rows          359
;  :arith-assert-diseq      46
;  :arith-assert-lower      243
;  :arith-assert-upper      122
;  :arith-bound-prop        54
;  :arith-conflicts         30
;  :arith-eq-adapter        130
;  :arith-fixed-eqs         55
;  :arith-offset-eqs        26
;  :arith-pivots            187
;  :conflicts               77
;  :datatype-accessor-ax    54
;  :datatype-constructor-ax 218
;  :datatype-occurs-check   127
;  :datatype-splits         74
;  :decisions               247
;  :del-clause              873
;  :final-checks            70
;  :max-generation          5
;  :max-memory              5.24
;  :memory                  5.23
;  :minimized-lits          2
;  :mk-bool-var             2457
;  :mk-clause               949
;  :num-allocs              215090
;  :num-checks              106
;  :propagations            333
;  :quant-instantiations    725
;  :rlimit-count            299266)
(push) ; 11
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 12
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@109@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@111@03))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1875
;  :arith-add-rows          359
;  :arith-assert-diseq      46
;  :arith-assert-lower      243
;  :arith-assert-upper      122
;  :arith-bound-prop        54
;  :arith-conflicts         30
;  :arith-eq-adapter        130
;  :arith-fixed-eqs         55
;  :arith-offset-eqs        26
;  :arith-pivots            187
;  :conflicts               78
;  :datatype-accessor-ax    54
;  :datatype-constructor-ax 218
;  :datatype-occurs-check   127
;  :datatype-splits         74
;  :decisions               247
;  :del-clause              873
;  :final-checks            70
;  :max-generation          5
;  :max-memory              5.24
;  :memory                  5.23
;  :minimized-lits          2
;  :mk-bool-var             2457
;  :mk-clause               949
;  :num-allocs              215179
;  :num-checks              107
;  :propagations            333
;  :quant-instantiations    725
;  :rlimit-count            299361)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@109@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@111@03))
    (as None<option<array>>  option<array>))))
(pop) ; 11
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@109@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@111@03))
    (as None<option<array>>  option<array>))))
(pop) ; 10
(push) ; 10
; [else-branch: 72 | !(i1@111@03 < V@12@03 && 0 <= i1@111@03)]
(assert (not (and (< i1@111@03 V@12@03) (<= 0 i1@111@03))))
(pop) ; 10
(pop) ; 9
; Joined path conditions
(assert (implies
  (and (< i1@111@03 V@12@03) (<= 0 i1@111@03))
  (and
    (< i1@111@03 V@12@03)
    (<= 0 i1@111@03)
    (< i1@111@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@109@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@111@03)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@111@03))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@109@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@111@03))
        (as None<option<array>>  option<array>))))))
; Joined path conditions
(pop) ; 8
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@111@03 Int)) (!
  (implies
    (and (< i1@111@03 V@12@03) (<= 0 i1@111@03))
    (and
      (< i1@111@03 V@12@03)
      (<= 0 i1@111@03)
      (< i1@111@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@109@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@111@03)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@111@03))
      (not
        (=
          ($FVF.lookup_option$array$ (as sm@109@03  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@111@03))
          (as None<option<array>>  option<array>)))))
  :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@109@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@111@03)))))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(assert (forall ((i1@111@03 Int)) (!
  (implies
    (and (< i1@111@03 V@12@03) (<= 0 i1@111@03))
    (=
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@109@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@111@03))))
      V@12@03))
  :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@109@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@111@03)))))
  :qid |prog.l<no position>|)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03)))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03)))))))
  $Snap.unit))
; [eval] (forall i1: Int :: { aloc(opt_get1(Gf), i1) } (forall i2: Int :: { aloc(opt_get1(Gf), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(Gf), i1).option$array$ == aloc(opt_get1(Gf), i2).option$array$ ==> i1 == i2))
(declare-const i1@112@03 Int)
(push) ; 8
; [eval] (forall i2: Int :: { aloc(opt_get1(Gf), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(Gf), i1).option$array$ == aloc(opt_get1(Gf), i2).option$array$ ==> i1 == i2)
(declare-const i2@113@03 Int)
(push) ; 9
; [eval] 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(Gf), i1).option$array$ == aloc(opt_get1(Gf), i2).option$array$ ==> i1 == i2
; [eval] 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(Gf), i1).option$array$ == aloc(opt_get1(Gf), i2).option$array$
; [eval] 0 <= i1
(push) ; 10
; [then-branch: 73 | 0 <= i1@112@03 | live]
; [else-branch: 73 | !(0 <= i1@112@03) | live]
(push) ; 11
; [then-branch: 73 | 0 <= i1@112@03]
(assert (<= 0 i1@112@03))
; [eval] i1 < V
(push) ; 12
; [then-branch: 74 | i1@112@03 < V@12@03 | live]
; [else-branch: 74 | !(i1@112@03 < V@12@03) | live]
(push) ; 13
; [then-branch: 74 | i1@112@03 < V@12@03]
(assert (< i1@112@03 V@12@03))
; [eval] 0 <= i2
(push) ; 14
; [then-branch: 75 | 0 <= i2@113@03 | live]
; [else-branch: 75 | !(0 <= i2@113@03) | live]
(push) ; 15
; [then-branch: 75 | 0 <= i2@113@03]
(assert (<= 0 i2@113@03))
; [eval] i2 < V
(push) ; 16
; [then-branch: 76 | i2@113@03 < V@12@03 | live]
; [else-branch: 76 | !(i2@113@03 < V@12@03) | live]
(push) ; 17
; [then-branch: 76 | i2@113@03 < V@12@03]
(assert (< i2@113@03 V@12@03))
; [eval] aloc(opt_get1(Gf), i1).option$array$ == aloc(opt_get1(Gf), i2).option$array$
; [eval] aloc(opt_get1(Gf), i1)
; [eval] opt_get1(Gf)
(push) ; 18
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 18
; Joined path conditions
(push) ; 18
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 19
(assert (not (< i1@112@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))))
(check-sat)
; unsat
(pop) ; 19
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1881
;  :arith-add-rows          362
;  :arith-assert-diseq      46
;  :arith-assert-lower      247
;  :arith-assert-upper      122
;  :arith-bound-prop        54
;  :arith-conflicts         30
;  :arith-eq-adapter        130
;  :arith-fixed-eqs         55
;  :arith-offset-eqs        26
;  :arith-pivots            190
;  :conflicts               78
;  :datatype-accessor-ax    55
;  :datatype-constructor-ax 218
;  :datatype-occurs-check   127
;  :datatype-splits         74
;  :decisions               247
;  :del-clause              893
;  :final-checks            70
;  :max-generation          5
;  :max-memory              5.24
;  :memory                  5.24
;  :minimized-lits          2
;  :mk-bool-var             2465
;  :mk-clause               949
;  :num-allocs              215951
;  :num-checks              108
;  :propagations            333
;  :quant-instantiations    725
;  :rlimit-count            300760)
(assert (< i1@112@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03))))
(pop) ; 18
; Joined path conditions
(assert (< i1@112@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@109@03  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@112@03)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@112@03)))
(push) ; 18
(assert (not (ite
  (and
    (<
      (inv@108@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@112@03))
      V@12@03)
    (<=
      0
      (inv@108@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@112@03))))
  (< $Perm.No $k@107@03)
  false)))
(check-sat)
; unsat
(pop) ; 18
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1895
;  :arith-add-rows          370
;  :arith-assert-diseq      46
;  :arith-assert-lower      249
;  :arith-assert-upper      125
;  :arith-bound-prop        56
;  :arith-conflicts         31
;  :arith-eq-adapter        132
;  :arith-fixed-eqs         57
;  :arith-offset-eqs        26
;  :arith-pivots            193
;  :conflicts               79
;  :datatype-accessor-ax    55
;  :datatype-constructor-ax 218
;  :datatype-occurs-check   127
;  :datatype-splits         74
;  :decisions               247
;  :del-clause              893
;  :final-checks            70
;  :max-generation          5
;  :max-memory              5.25
;  :memory                  5.24
;  :minimized-lits          2
;  :mk-bool-var             2517
;  :mk-clause               969
;  :num-allocs              216395
;  :num-checks              109
;  :propagations            334
;  :quant-instantiations    750
;  :rlimit-count            302169)
; [eval] aloc(opt_get1(Gf), i2)
; [eval] opt_get1(Gf)
(push) ; 18
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 18
; Joined path conditions
(push) ; 18
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 19
(assert (not (< i2@113@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))))
(check-sat)
; unsat
(pop) ; 19
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1895
;  :arith-add-rows          370
;  :arith-assert-diseq      46
;  :arith-assert-lower      249
;  :arith-assert-upper      125
;  :arith-bound-prop        56
;  :arith-conflicts         31
;  :arith-eq-adapter        132
;  :arith-fixed-eqs         57
;  :arith-offset-eqs        26
;  :arith-pivots            193
;  :conflicts               79
;  :datatype-accessor-ax    55
;  :datatype-constructor-ax 218
;  :datatype-occurs-check   127
;  :datatype-splits         74
;  :decisions               247
;  :del-clause              893
;  :final-checks            70
;  :max-generation          5
;  :max-memory              5.25
;  :memory                  5.24
;  :minimized-lits          2
;  :mk-bool-var             2517
;  :mk-clause               969
;  :num-allocs              216421
;  :num-checks              110
;  :propagations            334
;  :quant-instantiations    750
;  :rlimit-count            302199)
(assert (< i2@113@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03))))
(pop) ; 18
; Joined path conditions
(assert (< i2@113@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@109@03  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@113@03)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@113@03)))
(push) ; 18
(assert (not (ite
  (and
    (<
      (inv@108@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@113@03))
      V@12@03)
    (<=
      0
      (inv@108@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@113@03))))
  (< $Perm.No $k@107@03)
  false)))
(check-sat)
; unsat
(pop) ; 18
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1908
;  :arith-add-rows          380
;  :arith-assert-diseq      46
;  :arith-assert-lower      251
;  :arith-assert-upper      128
;  :arith-bound-prop        58
;  :arith-conflicts         32
;  :arith-eq-adapter        135
;  :arith-fixed-eqs         59
;  :arith-offset-eqs        26
;  :arith-pivots            196
;  :conflicts               80
;  :datatype-accessor-ax    55
;  :datatype-constructor-ax 218
;  :datatype-occurs-check   127
;  :datatype-splits         74
;  :decisions               247
;  :del-clause              893
;  :final-checks            70
;  :max-generation          5
;  :max-memory              5.30
;  :memory                  5.29
;  :minimized-lits          2
;  :mk-bool-var             2577
;  :mk-clause               1001
;  :num-allocs              216950
;  :num-checks              111
;  :propagations            341
;  :quant-instantiations    775
;  :rlimit-count            303722)
(pop) ; 17
(push) ; 17
; [else-branch: 76 | !(i2@113@03 < V@12@03)]
(assert (not (< i2@113@03 V@12@03)))
(pop) ; 17
(pop) ; 16
; Joined path conditions
(assert (implies
  (< i2@113@03 V@12@03)
  (and
    (< i2@113@03 V@12@03)
    (< i1@112@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@109@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@112@03)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@112@03))
    (< i2@113@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@109@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@113@03)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@113@03)))))
; Joined path conditions
(pop) ; 15
(push) ; 15
; [else-branch: 75 | !(0 <= i2@113@03)]
(assert (not (<= 0 i2@113@03)))
(pop) ; 15
(pop) ; 14
; Joined path conditions
(assert (implies
  (<= 0 i2@113@03)
  (and
    (<= 0 i2@113@03)
    (implies
      (< i2@113@03 V@12@03)
      (and
        (< i2@113@03 V@12@03)
        (< i1@112@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@109@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@112@03)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@112@03))
        (< i2@113@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@109@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@113@03)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@113@03)))))))
; Joined path conditions
(pop) ; 13
(push) ; 13
; [else-branch: 74 | !(i1@112@03 < V@12@03)]
(assert (not (< i1@112@03 V@12@03)))
(pop) ; 13
(pop) ; 12
; Joined path conditions
(assert (implies
  (< i1@112@03 V@12@03)
  (and
    (< i1@112@03 V@12@03)
    (implies
      (<= 0 i2@113@03)
      (and
        (<= 0 i2@113@03)
        (implies
          (< i2@113@03 V@12@03)
          (and
            (< i2@113@03 V@12@03)
            (< i1@112@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@109@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@112@03)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@112@03))
            (< i2@113@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@109@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@113@03)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@113@03)))))))))
; Joined path conditions
(pop) ; 11
(push) ; 11
; [else-branch: 73 | !(0 <= i1@112@03)]
(assert (not (<= 0 i1@112@03)))
(pop) ; 11
(pop) ; 10
; Joined path conditions
(assert (implies
  (<= 0 i1@112@03)
  (and
    (<= 0 i1@112@03)
    (implies
      (< i1@112@03 V@12@03)
      (and
        (< i1@112@03 V@12@03)
        (implies
          (<= 0 i2@113@03)
          (and
            (<= 0 i2@113@03)
            (implies
              (< i2@113@03 V@12@03)
              (and
                (< i2@113@03 V@12@03)
                (< i1@112@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@109@03  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@112@03)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@112@03))
                (< i2@113@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@109@03  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@113@03)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@113@03)))))))))))
; Joined path conditions
(push) ; 10
; [then-branch: 77 | Lookup(option$array$,sm@109@03,aloc((_, _), opt_get1(_, Gf@11@03), i1@112@03)) == Lookup(option$array$,sm@109@03,aloc((_, _), opt_get1(_, Gf@11@03), i2@113@03)) && i2@113@03 < V@12@03 && 0 <= i2@113@03 && i1@112@03 < V@12@03 && 0 <= i1@112@03 | live]
; [else-branch: 77 | !(Lookup(option$array$,sm@109@03,aloc((_, _), opt_get1(_, Gf@11@03), i1@112@03)) == Lookup(option$array$,sm@109@03,aloc((_, _), opt_get1(_, Gf@11@03), i2@113@03)) && i2@113@03 < V@12@03 && 0 <= i2@113@03 && i1@112@03 < V@12@03 && 0 <= i1@112@03) | live]
(push) ; 11
; [then-branch: 77 | Lookup(option$array$,sm@109@03,aloc((_, _), opt_get1(_, Gf@11@03), i1@112@03)) == Lookup(option$array$,sm@109@03,aloc((_, _), opt_get1(_, Gf@11@03), i2@113@03)) && i2@113@03 < V@12@03 && 0 <= i2@113@03 && i1@112@03 < V@12@03 && 0 <= i1@112@03]
(assert (and
  (and
    (and
      (and
        (=
          ($FVF.lookup_option$array$ (as sm@109@03  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@112@03))
          ($FVF.lookup_option$array$ (as sm@109@03  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@113@03)))
        (< i2@113@03 V@12@03))
      (<= 0 i2@113@03))
    (< i1@112@03 V@12@03))
  (<= 0 i1@112@03)))
; [eval] i1 == i2
(pop) ; 11
(push) ; 11
; [else-branch: 77 | !(Lookup(option$array$,sm@109@03,aloc((_, _), opt_get1(_, Gf@11@03), i1@112@03)) == Lookup(option$array$,sm@109@03,aloc((_, _), opt_get1(_, Gf@11@03), i2@113@03)) && i2@113@03 < V@12@03 && 0 <= i2@113@03 && i1@112@03 < V@12@03 && 0 <= i1@112@03)]
(assert (not
  (and
    (and
      (and
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@109@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@112@03))
            ($FVF.lookup_option$array$ (as sm@109@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@113@03)))
          (< i2@113@03 V@12@03))
        (<= 0 i2@113@03))
      (< i1@112@03 V@12@03))
    (<= 0 i1@112@03))))
(pop) ; 11
(pop) ; 10
; Joined path conditions
(assert (implies
  (and
    (and
      (and
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@109@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@112@03))
            ($FVF.lookup_option$array$ (as sm@109@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@113@03)))
          (< i2@113@03 V@12@03))
        (<= 0 i2@113@03))
      (< i1@112@03 V@12@03))
    (<= 0 i1@112@03))
  (and
    (=
      ($FVF.lookup_option$array$ (as sm@109@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@112@03))
      ($FVF.lookup_option$array$ (as sm@109@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@113@03)))
    (< i2@113@03 V@12@03)
    (<= 0 i2@113@03)
    (< i1@112@03 V@12@03)
    (<= 0 i1@112@03))))
; Joined path conditions
(pop) ; 9
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i2@113@03 Int)) (!
  (and
    (implies
      (<= 0 i1@112@03)
      (and
        (<= 0 i1@112@03)
        (implies
          (< i1@112@03 V@12@03)
          (and
            (< i1@112@03 V@12@03)
            (implies
              (<= 0 i2@113@03)
              (and
                (<= 0 i2@113@03)
                (implies
                  (< i2@113@03 V@12@03)
                  (and
                    (< i2@113@03 V@12@03)
                    (< i1@112@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))
                    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@109@03  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@112@03)) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@112@03))
                    (< i2@113@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))
                    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@109@03  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@113@03)) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@113@03))))))))))
    (implies
      (and
        (and
          (and
            (and
              (=
                ($FVF.lookup_option$array$ (as sm@109@03  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@112@03))
                ($FVF.lookup_option$array$ (as sm@109@03  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@113@03)))
              (< i2@113@03 V@12@03))
            (<= 0 i2@113@03))
          (< i1@112@03 V@12@03))
        (<= 0 i1@112@03))
      (and
        (=
          ($FVF.lookup_option$array$ (as sm@109@03  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@112@03))
          ($FVF.lookup_option$array$ (as sm@109@03  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@113@03)))
        (< i2@113@03 V@12@03)
        (<= 0 i2@113@03)
        (< i1@112@03 V@12@03)
        (<= 0 i1@112@03))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@113@03))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 8
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@112@03 Int)) (!
  (forall ((i2@113@03 Int)) (!
    (and
      (implies
        (<= 0 i1@112@03)
        (and
          (<= 0 i1@112@03)
          (implies
            (< i1@112@03 V@12@03)
            (and
              (< i1@112@03 V@12@03)
              (implies
                (<= 0 i2@113@03)
                (and
                  (<= 0 i2@113@03)
                  (implies
                    (< i2@113@03 V@12@03)
                    (and
                      (< i2@113@03 V@12@03)
                      (< i1@112@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))
                      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@109@03  $FVF<option<array>>) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@112@03)) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@112@03))
                      (< i2@113@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))
                      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@109@03  $FVF<option<array>>) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@113@03)) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@113@03))))))))))
      (implies
        (and
          (and
            (and
              (and
                (=
                  ($FVF.lookup_option$array$ (as sm@109@03  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@112@03))
                  ($FVF.lookup_option$array$ (as sm@109@03  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@113@03)))
                (< i2@113@03 V@12@03))
              (<= 0 i2@113@03))
            (< i1@112@03 V@12@03))
          (<= 0 i1@112@03))
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@109@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@112@03))
            ($FVF.lookup_option$array$ (as sm@109@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@113@03)))
          (< i2@113@03 V@12@03)
          (<= 0 i2@113@03)
          (< i1@112@03 V@12@03)
          (<= 0 i1@112@03))))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@113@03))
    :qid |prog.l<no position>-aux|))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@112@03))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(assert (forall ((i1@112@03 Int)) (!
  (forall ((i2@113@03 Int)) (!
    (implies
      (and
        (and
          (and
            (and
              (=
                ($FVF.lookup_option$array$ (as sm@109@03  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@112@03))
                ($FVF.lookup_option$array$ (as sm@109@03  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@113@03)))
              (< i2@113@03 V@12@03))
            (<= 0 i2@113@03))
          (< i1@112@03 V@12@03))
        (<= 0 i1@112@03))
      (= i1@112@03 i2@113@03))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@113@03))
    :qid |prog.l<no position>|))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@112@03))
  :qid |prog.l<no position>|)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03)))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03)))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03))))))))
  $Snap.unit))
; [eval] p != (None(): option[array])
; [eval] (None(): option[array])
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03)))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03)))))))))
  $Snap.unit))
; [eval] alen(opt_get1(p)) == V
; [eval] alen(opt_get1(p))
; [eval] opt_get1(p)
(push) ; 8
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 8
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03)))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03)))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03))))))))))
  $Snap.unit))
; [eval] 0 <= s
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03)))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03)))))))))))
  $Snap.unit))
; [eval] s < V
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03)))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03)))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03))))))))))))
  $Snap.unit))
; [eval] 0 <= t
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03)))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03)))))))))))))
  $Snap.unit))
; [eval] t < V
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03)))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03)))))))))))))))))
(declare-const i1@114@03 Int)
(declare-const j1@115@03 Int)
(push) ; 8
; [eval] 0 <= i1 && i1 < V && (0 <= j1 && j1 < V)
; [eval] 0 <= i1
(push) ; 9
; [then-branch: 78 | 0 <= i1@114@03 | live]
; [else-branch: 78 | !(0 <= i1@114@03) | live]
(push) ; 10
; [then-branch: 78 | 0 <= i1@114@03]
(assert (<= 0 i1@114@03))
; [eval] i1 < V
(push) ; 11
; [then-branch: 79 | i1@114@03 < V@12@03 | live]
; [else-branch: 79 | !(i1@114@03 < V@12@03) | live]
(push) ; 12
; [then-branch: 79 | i1@114@03 < V@12@03]
(assert (< i1@114@03 V@12@03))
; [eval] 0 <= j1
(push) ; 13
; [then-branch: 80 | 0 <= j1@115@03 | live]
; [else-branch: 80 | !(0 <= j1@115@03) | live]
(push) ; 14
; [then-branch: 80 | 0 <= j1@115@03]
(assert (<= 0 j1@115@03))
; [eval] j1 < V
(pop) ; 14
(push) ; 14
; [else-branch: 80 | !(0 <= j1@115@03)]
(assert (not (<= 0 j1@115@03)))
(pop) ; 14
(pop) ; 13
; Joined path conditions
; Joined path conditions
(pop) ; 12
(push) ; 12
; [else-branch: 79 | !(i1@114@03 < V@12@03)]
(assert (not (< i1@114@03 V@12@03)))
(pop) ; 12
(pop) ; 11
; Joined path conditions
; Joined path conditions
(pop) ; 10
(push) ; 10
; [else-branch: 78 | !(0 <= i1@114@03)]
(assert (not (<= 0 i1@114@03)))
(pop) ; 10
(pop) ; 9
; Joined path conditions
; Joined path conditions
(assert (and
  (and (and (< j1@115@03 V@12@03) (<= 0 j1@115@03)) (< i1@114@03 V@12@03))
  (<= 0 i1@114@03)))
; [eval] aloc(opt_get1(aloc(opt_get1(Gf), i1).option$array$), j1)
; [eval] opt_get1(aloc(opt_get1(Gf), i1).option$array$)
; [eval] aloc(opt_get1(Gf), i1)
; [eval] opt_get1(Gf)
(push) ; 9
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 9
; Joined path conditions
(push) ; 9
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 10
(assert (not (< i1@114@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1949
;  :arith-add-rows          386
;  :arith-assert-diseq      46
;  :arith-assert-lower      257
;  :arith-assert-upper      128
;  :arith-bound-prop        58
;  :arith-conflicts         32
;  :arith-eq-adapter        135
;  :arith-fixed-eqs         59
;  :arith-offset-eqs        26
;  :arith-pivots            203
;  :conflicts               80
;  :datatype-accessor-ax    62
;  :datatype-constructor-ax 218
;  :datatype-occurs-check   127
;  :datatype-splits         74
;  :decisions               247
;  :del-clause              969
;  :final-checks            70
;  :max-generation          5
;  :max-memory              5.30
;  :memory                  5.29
;  :minimized-lits          2
;  :mk-bool-var             2611
;  :mk-clause               1025
;  :num-allocs              218487
;  :num-checks              112
;  :propagations            341
;  :quant-instantiations    775
;  :rlimit-count            307553)
(assert (< i1@114@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03))))
(pop) ; 9
; Joined path conditions
(assert (< i1@114@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@109@03  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@114@03)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@114@03)))
(push) ; 9
(assert (not (ite
  (and
    (<
      (inv@108@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@114@03))
      V@12@03)
    (<=
      0
      (inv@108@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@114@03))))
  (< $Perm.No $k@107@03)
  false)))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1971
;  :arith-add-rows          397
;  :arith-assert-diseq      46
;  :arith-assert-lower      259
;  :arith-assert-upper      131
;  :arith-bound-prop        61
;  :arith-conflicts         33
;  :arith-eq-adapter        137
;  :arith-fixed-eqs         61
;  :arith-offset-eqs        31
;  :arith-pivots            206
;  :conflicts               81
;  :datatype-accessor-ax    62
;  :datatype-constructor-ax 218
;  :datatype-occurs-check   127
;  :datatype-splits         74
;  :decisions               247
;  :del-clause              969
;  :final-checks            70
;  :max-generation          5
;  :max-memory              5.32
;  :memory                  5.31
;  :minimized-lits          2
;  :mk-bool-var             2672
;  :mk-clause               1045
;  :num-allocs              218989
;  :num-checks              113
;  :propagations            345
;  :quant-instantiations    803
;  :rlimit-count            309301)
(push) ; 9
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 10
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@109@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@114@03))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1971
;  :arith-add-rows          397
;  :arith-assert-diseq      46
;  :arith-assert-lower      259
;  :arith-assert-upper      131
;  :arith-bound-prop        61
;  :arith-conflicts         33
;  :arith-eq-adapter        137
;  :arith-fixed-eqs         61
;  :arith-offset-eqs        31
;  :arith-pivots            206
;  :conflicts               82
;  :datatype-accessor-ax    62
;  :datatype-constructor-ax 218
;  :datatype-occurs-check   127
;  :datatype-splits         74
;  :decisions               247
;  :del-clause              969
;  :final-checks            70
;  :max-generation          5
;  :max-memory              5.32
;  :memory                  5.31
;  :minimized-lits          2
;  :mk-bool-var             2672
;  :mk-clause               1045
;  :num-allocs              219079
;  :num-checks              114
;  :propagations            345
;  :quant-instantiations    803
;  :rlimit-count            309396)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@109@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@114@03))
    (as None<option<array>>  option<array>))))
(pop) ; 9
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@109@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@114@03))
    (as None<option<array>>  option<array>))))
(push) ; 9
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 10
(assert (not (<
  j1@115@03
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@109@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@114@03)))))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1977
;  :arith-add-rows          402
;  :arith-assert-diseq      46
;  :arith-assert-lower      262
;  :arith-assert-upper      132
;  :arith-bound-prop        61
;  :arith-conflicts         34
;  :arith-eq-adapter        138
;  :arith-fixed-eqs         62
;  :arith-offset-eqs        31
;  :arith-pivots            210
;  :conflicts               83
;  :datatype-accessor-ax    62
;  :datatype-constructor-ax 218
;  :datatype-occurs-check   127
;  :datatype-splits         74
;  :decisions               247
;  :del-clause              973
;  :final-checks            70
;  :max-generation          5
;  :max-memory              5.32
;  :memory                  5.31
;  :minimized-lits          2
;  :mk-bool-var             2683
;  :mk-clause               1049
;  :num-allocs              219272
;  :num-checks              115
;  :propagations            347
;  :quant-instantiations    810
;  :rlimit-count            309899)
(assert (<
  j1@115@03
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@109@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@114@03))))))
(pop) ; 9
; Joined path conditions
(assert (<
  j1@115@03
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@109@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@114@03))))))
(pop) ; 8
(declare-fun inv@116@03 ($Ref) Int)
(declare-fun inv@117@03 ($Ref) Int)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(assert (forall ((i1@114@03 Int) (j1@115@03 Int)) (!
  (and
    (< i1@114@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@109@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@114@03)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@114@03))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@109@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@114@03))
        (as None<option<array>>  option<array>)))
    (<
      j1@115@03
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@109@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@114@03))))))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@109@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@114@03))) j1@115@03))
  :qid |int-aux|)))
; Check receiver injectivity
(push) ; 8
(assert (not (forall ((i11@114@03 Int) (j11@115@03 Int) (i12@114@03 Int) (j12@115@03 Int)) (!
  (implies
    (and
      (and
        (and
          (and (< j11@115@03 V@12@03) (<= 0 j11@115@03))
          (< i11@114@03 V@12@03))
        (<= 0 i11@114@03))
      (and
        (and
          (and (< j12@115@03 V@12@03) (<= 0 j12@115@03))
          (< i12@114@03 V@12@03))
        (<= 0 i12@114@03))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@109@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i11@114@03))) j11@115@03)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@109@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i12@114@03))) j12@115@03)))
    (and (= i11@114@03 i12@114@03) (= j11@115@03 j12@115@03)))
  
  :qid |int-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               2029
;  :arith-add-rows          413
;  :arith-assert-diseq      46
;  :arith-assert-lower      274
;  :arith-assert-upper      136
;  :arith-bound-prop        63
;  :arith-conflicts         34
;  :arith-eq-adapter        146
;  :arith-fixed-eqs         64
;  :arith-offset-eqs        31
;  :arith-pivots            219
;  :conflicts               84
;  :datatype-accessor-ax    62
;  :datatype-constructor-ax 218
;  :datatype-occurs-check   127
;  :datatype-splits         74
;  :decisions               247
;  :del-clause              1064
;  :final-checks            70
;  :max-generation          5
;  :max-memory              5.47
;  :memory                  5.46
;  :minimized-lits          2
;  :mk-bool-var             2873
;  :mk-clause               1120
;  :num-allocs              220730
;  :num-checks              116
;  :propagations            373
;  :quant-instantiations    892
;  :rlimit-count            314728
;  :time                    0.00)
; Definitional axioms for inverse functions
(assert (forall ((i1@114@03 Int) (j1@115@03 Int)) (!
  (implies
    (and
      (and (and (< j1@115@03 V@12@03) (<= 0 j1@115@03)) (< i1@114@03 V@12@03))
      (<= 0 i1@114@03))
    (and
      (=
        (inv@116@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@109@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@114@03))) j1@115@03))
        i1@114@03)
      (=
        (inv@117@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@109@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@114@03))) j1@115@03))
        j1@115@03)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@109@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@114@03))) j1@115@03))
  )))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@117@03 r) V@12@03) (<= 0 (inv@117@03 r)))
        (< (inv@116@03 r) V@12@03))
      (<= 0 (inv@116@03 r)))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@109@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) (inv@116@03 r)))) (inv@117@03 r))
      r))
  :pattern ((inv@116@03 r))
  :pattern ((inv@117@03 r))
  :qid |int-fctOfInv|)))
; Permissions are non-negative
; Field permissions are at most one
; Permission implies non-null receiver
(assert (forall ((i1@114@03 Int) (j1@115@03 Int)) (!
  (implies
    (and
      (and (and (< j1@115@03 V@12@03) (<= 0 j1@115@03)) (< i1@114@03 V@12@03))
      (<= 0 i1@114@03))
    (not
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@109@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@114@03))) j1@115@03)
        $Ref.null)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@109@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@114@03))) j1@115@03))
  :qid |int-permImpliesNonNull|)))
(declare-const sm@118@03 $FVF<Int>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@117@03 r) V@12@03) (<= 0 (inv@117@03 r)))
        (< (inv@116@03 r) V@12@03))
      (<= 0 (inv@116@03 r)))
    (=
      ($FVF.lookup_int (as sm@118@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@118@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03))))))))))))))) r))
  :qid |qp.fvfValDef31|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03))))))))))))))) r) r)
  :pattern (($FVF.lookup_int (as sm@118@03  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef32|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@117@03 r) V@12@03) (<= 0 (inv@117@03 r)))
        (< (inv@116@03 r) V@12@03))
      (<= 0 (inv@116@03 r)))
    ($FVF.loc_int ($FVF.lookup_int (as sm@118@03  $FVF<Int>) r) r))
  :pattern ((inv@116@03 r) (inv@117@03 r))
  )))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03))))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03)))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03))))))))))))))))))
(declare-const i1@119@03 Int)
(push) ; 8
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 9
; [then-branch: 81 | 0 <= i1@119@03 | live]
; [else-branch: 81 | !(0 <= i1@119@03) | live]
(push) ; 10
; [then-branch: 81 | 0 <= i1@119@03]
(assert (<= 0 i1@119@03))
; [eval] i1 < V
(pop) ; 10
(push) ; 10
; [else-branch: 81 | !(0 <= i1@119@03)]
(assert (not (<= 0 i1@119@03)))
(pop) ; 10
(pop) ; 9
; Joined path conditions
; Joined path conditions
(assert (and (< i1@119@03 V@12@03) (<= 0 i1@119@03)))
; [eval] aloc(opt_get1(p), i1)
; [eval] opt_get1(p)
(push) ; 9
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 9
; Joined path conditions
(push) ; 9
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 10
(assert (not (< i1@119@03 (alen<Int> (opt_get1 $Snap.unit p@15@03)))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               2034
;  :arith-add-rows          413
;  :arith-assert-diseq      46
;  :arith-assert-lower      276
;  :arith-assert-upper      136
;  :arith-bound-prop        63
;  :arith-conflicts         34
;  :arith-eq-adapter        146
;  :arith-fixed-eqs         64
;  :arith-offset-eqs        31
;  :arith-pivots            219
;  :conflicts               84
;  :datatype-accessor-ax    63
;  :datatype-constructor-ax 218
;  :datatype-occurs-check   127
;  :datatype-splits         74
;  :decisions               247
;  :del-clause              1064
;  :final-checks            70
;  :max-generation          5
;  :max-memory              5.47
;  :memory                  5.46
;  :minimized-lits          2
;  :mk-bool-var             2882
;  :mk-clause               1120
;  :num-allocs              221840
;  :num-checks              117
;  :propagations            373
;  :quant-instantiations    892
;  :rlimit-count            317847)
(assert (< i1@119@03 (alen<Int> (opt_get1 $Snap.unit p@15@03))))
(pop) ; 9
; Joined path conditions
(assert (< i1@119@03 (alen<Int> (opt_get1 $Snap.unit p@15@03))))
(pop) ; 8
(declare-fun inv@120@03 ($Ref) Int)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(assert (forall ((i1@119@03 Int)) (!
  (< i1@119@03 (alen<Int> (opt_get1 $Snap.unit p@15@03)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) i1@119@03))
  :qid |int-aux|)))
; Check receiver injectivity
(push) ; 8
(assert (not (forall ((i11@119@03 Int) (i12@119@03 Int)) (!
  (implies
    (and
      (and (< i11@119@03 V@12@03) (<= 0 i11@119@03))
      (and (< i12@119@03 V@12@03) (<= 0 i12@119@03))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) i11@119@03)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) i12@119@03)))
    (= i11@119@03 i12@119@03))
  
  :qid |int-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               2046
;  :arith-add-rows          415
;  :arith-assert-diseq      47
;  :arith-assert-lower      280
;  :arith-assert-upper      136
;  :arith-bound-prop        63
;  :arith-conflicts         34
;  :arith-eq-adapter        147
;  :arith-fixed-eqs         64
;  :arith-offset-eqs        31
;  :arith-pivots            219
;  :conflicts               85
;  :datatype-accessor-ax    63
;  :datatype-constructor-ax 218
;  :datatype-occurs-check   127
;  :datatype-splits         74
;  :decisions               247
;  :del-clause              1070
;  :final-checks            70
;  :max-generation          5
;  :max-memory              5.50
;  :memory                  5.47
;  :minimized-lits          2
;  :mk-bool-var             2905
;  :mk-clause               1126
;  :num-allocs              222368
;  :num-checks              118
;  :propagations            373
;  :quant-instantiations    909
;  :rlimit-count            318824)
; Definitional axioms for inverse functions
(assert (forall ((i1@119@03 Int)) (!
  (implies
    (and (< i1@119@03 V@12@03) (<= 0 i1@119@03))
    (=
      (inv@120@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) i1@119@03))
      i1@119@03))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) i1@119@03))
  )))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@120@03 r) V@12@03) (<= 0 (inv@120@03 r)))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) (inv@120@03 r))
      r))
  :pattern ((inv@120@03 r))
  :qid |int-fctOfInv|)))
; Permissions are non-negative
; Field permissions are at most one
; Permission implies non-null receiver
(assert (forall ((i1@119@03 Int)) (!
  (implies
    (and (< i1@119@03 V@12@03) (<= 0 i1@119@03))
    (not
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) i1@119@03)
        $Ref.null)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) i1@119@03))
  :qid |int-permImpliesNonNull|)))
(declare-const sm@121@03 $FVF<Int>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@120@03 r) V@12@03) (<= 0 (inv@120@03 r)))
    (=
      ($FVF.lookup_int (as sm@121@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03)))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@121@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03)))))))))))))))) r))
  :qid |qp.fvfValDef33|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@117@03 r) V@12@03) (<= 0 (inv@117@03 r)))
        (< (inv@116@03 r) V@12@03))
      (<= 0 (inv@116@03 r)))
    (=
      ($FVF.lookup_int (as sm@121@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@121@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03))))))))))))))) r))
  :qid |qp.fvfValDef34|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03)))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03))))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@121@03  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef35|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@120@03 r) V@12@03) (<= 0 (inv@120@03 r)))
    ($FVF.loc_int ($FVF.lookup_int (as sm@121@03  $FVF<Int>) r) r))
  :pattern ((inv@120@03 r))
  )))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03)))))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03))))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03)))))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03))))))))))))))))
  $Snap.unit))
; [eval] valid_graph_vertices(this, p, V)
(push) ; 8
; [eval] this != null
; [eval] p != (None(): option[array])
; [eval] (None(): option[array])
; [eval] alen(opt_get1(p)) == V
; [eval] alen(opt_get1(p))
; [eval] opt_get1(p)
(push) ; 9
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 9
; Joined path conditions
(declare-const i1@122@03 Int)
(push) ; 9
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 10
; [then-branch: 82 | 0 <= i1@122@03 | live]
; [else-branch: 82 | !(0 <= i1@122@03) | live]
(push) ; 11
; [then-branch: 82 | 0 <= i1@122@03]
(assert (<= 0 i1@122@03))
; [eval] i1 < V
(pop) ; 11
(push) ; 11
; [else-branch: 82 | !(0 <= i1@122@03)]
(assert (not (<= 0 i1@122@03)))
(pop) ; 11
(pop) ; 10
; Joined path conditions
; Joined path conditions
(assert (and (< i1@122@03 V@12@03) (<= 0 i1@122@03)))
(declare-const $k@123@03 $Perm)
(assert ($Perm.isReadVar $k@123@03 $Perm.Write))
; [eval] aloc(opt_get1(p), i1)
; [eval] opt_get1(p)
(push) ; 10
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 10
; Joined path conditions
(push) ; 10
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 11
(assert (not (< i1@122@03 (alen<Int> (opt_get1 $Snap.unit p@15@03)))))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               2052
;  :arith-add-rows          415
;  :arith-assert-diseq      48
;  :arith-assert-lower      284
;  :arith-assert-upper      137
;  :arith-bound-prop        63
;  :arith-conflicts         34
;  :arith-eq-adapter        148
;  :arith-fixed-eqs         64
;  :arith-offset-eqs        31
;  :arith-pivots            219
;  :conflicts               85
;  :datatype-accessor-ax    64
;  :datatype-constructor-ax 218
;  :datatype-occurs-check   127
;  :datatype-splits         74
;  :decisions               247
;  :del-clause              1070
;  :final-checks            70
;  :max-generation          5
;  :max-memory              5.50
;  :memory                  5.47
;  :minimized-lits          2
;  :mk-bool-var             2920
;  :mk-clause               1128
;  :num-allocs              223748
;  :num-checks              119
;  :propagations            374
;  :quant-instantiations    909
;  :rlimit-count            322486)
(assert (< i1@122@03 (alen<Int> (opt_get1 $Snap.unit p@15@03))))
(pop) ; 10
; Joined path conditions
(assert (< i1@122@03 (alen<Int> (opt_get1 $Snap.unit p@15@03))))
(pop) ; 9
(declare-fun inv@124@03 ($Ref) Int)
; Nested auxiliary terms: globals
(assert ($Perm.isReadVar $k@123@03 $Perm.Write))
; Nested auxiliary terms: non-globals
(assert (forall ((i1@122@03 Int)) (!
  (< i1@122@03 (alen<Int> (opt_get1 $Snap.unit p@15@03)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) i1@122@03))
  :qid |int-aux|)))
(push) ; 9
(assert (not (forall ((i1@122@03 Int)) (!
  (implies
    (and (< i1@122@03 V@12@03) (<= 0 i1@122@03))
    (or (= $k@123@03 $Perm.No) (< $Perm.No $k@123@03)))
  
  ))))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               2052
;  :arith-add-rows          415
;  :arith-assert-diseq      49
;  :arith-assert-lower      286
;  :arith-assert-upper      138
;  :arith-bound-prop        63
;  :arith-conflicts         34
;  :arith-eq-adapter        149
;  :arith-fixed-eqs         64
;  :arith-offset-eqs        31
;  :arith-pivots            219
;  :conflicts               86
;  :datatype-accessor-ax    64
;  :datatype-constructor-ax 218
;  :datatype-occurs-check   127
;  :datatype-splits         74
;  :decisions               247
;  :del-clause              1072
;  :final-checks            70
;  :max-generation          5
;  :max-memory              5.50
;  :memory                  5.48
;  :minimized-lits          2
;  :mk-bool-var             2927
;  :mk-clause               1130
;  :num-allocs              224172
;  :num-checks              120
;  :propagations            375
;  :quant-instantiations    909
;  :rlimit-count            323032)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 9
(assert (not (forall ((i11@122@03 Int) (i12@122@03 Int)) (!
  (implies
    (and
      (and
        (and
          (and (< i11@122@03 V@12@03) (<= 0 i11@122@03))
          ($FVF.loc_int ($FVF.lookup_int (as sm@121@03  $FVF<Int>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit p@15@03) i11@122@03)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit p@15@03) i11@122@03)))
        (< $Perm.No $k@123@03))
      (and
        (and
          (and (< i12@122@03 V@12@03) (<= 0 i12@122@03))
          ($FVF.loc_int ($FVF.lookup_int (as sm@121@03  $FVF<Int>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit p@15@03) i12@122@03)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit p@15@03) i12@122@03)))
        (< $Perm.No $k@123@03))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) i11@122@03)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) i12@122@03)))
    (= i11@122@03 i12@122@03))
  
  :qid |int-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               2067
;  :arith-add-rows          417
;  :arith-assert-diseq      50
;  :arith-assert-lower      290
;  :arith-assert-upper      138
;  :arith-bound-prop        63
;  :arith-conflicts         34
;  :arith-eq-adapter        150
;  :arith-fixed-eqs         64
;  :arith-offset-eqs        31
;  :arith-pivots            219
;  :conflicts               87
;  :datatype-accessor-ax    64
;  :datatype-constructor-ax 218
;  :datatype-occurs-check   127
;  :datatype-splits         74
;  :decisions               247
;  :del-clause              1083
;  :final-checks            70
;  :max-generation          5
;  :max-memory              5.50
;  :memory                  5.48
;  :minimized-lits          2
;  :mk-bool-var             2963
;  :mk-clause               1141
;  :num-allocs              224642
;  :num-checks              121
;  :propagations            377
;  :quant-instantiations    933
;  :rlimit-count            324197)
; Definitional axioms for inverse functions
(assert (forall ((i1@122@03 Int)) (!
  (implies
    (and (and (< i1@122@03 V@12@03) (<= 0 i1@122@03)) (< $Perm.No $k@123@03))
    (=
      (inv@124@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) i1@122@03))
      i1@122@03))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) i1@122@03))
  :qid |int-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and (< (inv@124@03 r) V@12@03) (<= 0 (inv@124@03 r)))
      (< $Perm.No $k@123@03))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) (inv@124@03 r))
      r))
  :pattern ((inv@124@03 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@124@03 r) V@12@03) (<= 0 (inv@124@03 r)))
    ($FVF.loc_int ($FVF.lookup_int (as sm@121@03  $FVF<Int>) r) r))
  :pattern ((inv@124@03 r))
  )))
; Precomputing data for removing quantified permissions
(define-fun pTaken@125@03 ((r $Ref)) $Perm
  (ite
    (and (< (inv@124@03 r) V@12@03) (<= 0 (inv@124@03 r)))
    ($Perm.min
      (ite
        (and (< (inv@120@03 r) V@12@03) (<= 0 (inv@120@03 r)))
        $Perm.Write
        $Perm.No)
      $k@123@03)
    $Perm.No))
(define-fun pTaken@126@03 ((r $Ref)) $Perm
  (ite
    (and (< (inv@124@03 r) V@12@03) (<= 0 (inv@124@03 r)))
    ($Perm.min
      (ite
        (and
          (and
            (and (< (inv@117@03 r) V@12@03) (<= 0 (inv@117@03 r)))
            (< (inv@116@03 r) V@12@03))
          (<= 0 (inv@116@03 r)))
        $Perm.Write
        $Perm.No)
      (- $k@123@03 (pTaken@125@03 r)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Constrain original permissions $k@123@03
(assert (forall ((r $Ref)) (!
  (implies
    (not
      (=
        (ite
          (and (< (inv@120@03 r) V@12@03) (<= 0 (inv@120@03 r)))
          $Perm.Write
          $Perm.No)
        $Perm.No))
    (ite
      (and (< (inv@120@03 r) V@12@03) (<= 0 (inv@120@03 r)))
      (<
        (ite
          (and (< (inv@124@03 r) V@12@03) (<= 0 (inv@124@03 r)))
          $k@123@03
          $Perm.No)
        $Perm.Write)
      (<
        (ite
          (and (< (inv@124@03 r) V@12@03) (<= 0 (inv@124@03 r)))
          $k@123@03
          $Perm.No)
        $Perm.No)))
  :pattern ((inv@120@03 r))
  :pattern ((inv@124@03 r))
  :qid |qp.srp36|)))
; Intermediate check if already taken enough permissions
(set-option :timeout 500)
(push) ; 9
(assert (not (forall ((r $Ref)) (!
  (implies
    (and (< (inv@124@03 r) V@12@03) (<= 0 (inv@124@03 r)))
    (= (- $k@123@03 (pTaken@125@03 r)) $Perm.No))
  
  ))))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               2185
;  :arith-add-rows          440
;  :arith-assert-diseq      56
;  :arith-assert-lower      302
;  :arith-assert-upper      150
;  :arith-bound-prop        66
;  :arith-conflicts         37
;  :arith-eq-adapter        170
;  :arith-fixed-eqs         69
;  :arith-offset-eqs        32
;  :arith-pivots            234
;  :conflicts               99
;  :datatype-accessor-ax    65
;  :datatype-constructor-ax 234
;  :datatype-occurs-check   139
;  :datatype-splits         82
;  :decisions               274
;  :del-clause              1226
;  :final-checks            73
;  :max-generation          5
;  :max-memory              5.52
;  :memory                  5.51
;  :minimized-lits          3
;  :mk-bool-var             3134
;  :mk-clause               1282
;  :num-allocs              227271
;  :num-checks              123
;  :propagations            415
;  :quant-instantiations    970
;  :rlimit-count            329144
;  :time                    0.00)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@127@03 $FVF<Int>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (iff
    (Set_in r ($FVF.domain_int (as sm@127@03  $FVF<Int>)))
    (and
      (and (< (inv@124@03 r) V@12@03) (<= 0 (inv@124@03 r)))
      (< $Perm.No $k@123@03)))
  :pattern ((Set_in r ($FVF.domain_int (as sm@127@03  $FVF<Int>))))
  :qid |qp.fvfDomDef40|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@124@03 r) V@12@03) (<= 0 (inv@124@03 r)))
        (< $Perm.No $k@123@03))
      (and (< (inv@120@03 r) V@12@03) (<= 0 (inv@120@03 r))))
    (=
      ($FVF.lookup_int (as sm@127@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03)))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@127@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03)))))))))))))))) r))
  :qid |qp.fvfValDef37|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@124@03 r) V@12@03) (<= 0 (inv@124@03 r)))
        (< $Perm.No $k@123@03))
      (and
        (and
          (and (< (inv@117@03 r) V@12@03) (<= 0 (inv@117@03 r)))
          (< (inv@116@03 r) V@12@03))
        (<= 0 (inv@116@03 r))))
    (=
      ($FVF.lookup_int (as sm@127@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@127@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03))))))))))))))) r))
  :qid |qp.fvfValDef38|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03)))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03))))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@127@03  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef39|)))
(pop) ; 8
; Joined path conditions
(assert ($Perm.isReadVar $k@123@03 $Perm.Write))
(assert (forall ((i1@122@03 Int)) (!
  (implies
    (and (and (< i1@122@03 V@12@03) (<= 0 i1@122@03)) (< $Perm.No $k@123@03))
    (=
      (inv@124@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) i1@122@03))
      i1@122@03))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) i1@122@03))
  :qid |int-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and (< (inv@124@03 r) V@12@03) (<= 0 (inv@124@03 r)))
      (< $Perm.No $k@123@03))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) (inv@124@03 r))
      r))
  :pattern ((inv@124@03 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (iff
    (Set_in r ($FVF.domain_int (as sm@127@03  $FVF<Int>)))
    (and
      (and (< (inv@124@03 r) V@12@03) (<= 0 (inv@124@03 r)))
      (< $Perm.No $k@123@03)))
  :pattern ((Set_in r ($FVF.domain_int (as sm@127@03  $FVF<Int>))))
  :qid |qp.fvfDomDef40|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@124@03 r) V@12@03) (<= 0 (inv@124@03 r)))
        (< $Perm.No $k@123@03))
      (and (< (inv@120@03 r) V@12@03) (<= 0 (inv@120@03 r))))
    (=
      ($FVF.lookup_int (as sm@127@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03)))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@127@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03)))))))))))))))) r))
  :qid |qp.fvfValDef37|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@124@03 r) V@12@03) (<= 0 (inv@124@03 r)))
        (< $Perm.No $k@123@03))
      (and
        (and
          (and (< (inv@117@03 r) V@12@03) (<= 0 (inv@117@03 r)))
          (< (inv@116@03 r) V@12@03))
        (<= 0 (inv@116@03 r))))
    (=
      ($FVF.lookup_int (as sm@127@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@127@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03))))))))))))))) r))
  :qid |qp.fvfValDef38|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03)))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03))))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@127@03  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef39|)))
(assert (and
  (forall ((i1@122@03 Int)) (!
    (< i1@122@03 (alen<Int> (opt_get1 $Snap.unit p@15@03)))
    :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) i1@122@03))
    :qid |int-aux|))
  (forall ((r $Ref)) (!
    (implies
      (and (< (inv@124@03 r) V@12@03) (<= 0 (inv@124@03 r)))
      ($FVF.loc_int ($FVF.lookup_int (as sm@121@03  $FVF<Int>) r) r))
    :pattern ((inv@124@03 r))
    ))
  (forall ((r $Ref)) (!
    (implies
      (not
        (=
          (ite
            (and (< (inv@120@03 r) V@12@03) (<= 0 (inv@120@03 r)))
            $Perm.Write
            $Perm.No)
          $Perm.No))
      (ite
        (and (< (inv@120@03 r) V@12@03) (<= 0 (inv@120@03 r)))
        (<
          (ite
            (and (< (inv@124@03 r) V@12@03) (<= 0 (inv@124@03 r)))
            $k@123@03
            $Perm.No)
          $Perm.Write)
        (<
          (ite
            (and (< (inv@124@03 r) V@12@03) (<= 0 (inv@124@03 r)))
            $k@123@03
            $Perm.No)
          $Perm.No)))
    :pattern ((inv@120@03 r))
    :pattern ((inv@124@03 r))
    :qid |qp.srp36|))))
(assert (valid_graph_vertices ($Snap.combine
  $Snap.unit
  ($Snap.combine
    $Snap.unit
    ($Snap.combine
      $Snap.unit
      ($SortWrappers.$FVF<Int>To$Snap (as sm@127@03  $FVF<Int>))))) this@9@03 p@15@03 V@12@03))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03))))))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03)))))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03))))))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03)))))))))))))))))
  $Snap.unit))
; [eval] 0 <= s
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03)))))))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03))))))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03)))))))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03))))))))))))))))))
  $Snap.unit))
; [eval] s < V
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03))))))))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03)))))))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03))))))))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03)))))))))))))))))))
  $Snap.unit))
; [eval] valid_graph_vertices1(this, queue, V)
(push) ; 8
; [eval] this != null
(pop) ; 8
; Joined path conditions
(assert (valid_graph_vertices1 $Snap.unit this@9@03 queue@102@03 V@12@03))
(declare-const i1@128@03 Int)
(push) ; 8
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 9
; [then-branch: 83 | 0 <= i1@128@03 | live]
; [else-branch: 83 | !(0 <= i1@128@03) | live]
(push) ; 10
; [then-branch: 83 | 0 <= i1@128@03]
(assert (<= 0 i1@128@03))
; [eval] i1 < V
(pop) ; 10
(push) ; 10
; [else-branch: 83 | !(0 <= i1@128@03)]
(assert (not (<= 0 i1@128@03)))
(pop) ; 10
(pop) ; 9
; Joined path conditions
; Joined path conditions
(assert (and (< i1@128@03 V@12@03) (<= 0 i1@128@03)))
; [eval] aloc(opt_get1(visited), i1)
; [eval] opt_get1(visited)
(push) ; 9
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 9
; Joined path conditions
(push) ; 9
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 10
(assert (not (< i1@128@03 (alen<Int> (opt_get1 $Snap.unit res@79@03)))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               2212
;  :arith-add-rows          442
;  :arith-assert-diseq      57
;  :arith-assert-lower      306
;  :arith-assert-upper      151
;  :arith-bound-prop        66
;  :arith-conflicts         37
;  :arith-eq-adapter        171
;  :arith-fixed-eqs         69
;  :arith-offset-eqs        32
;  :arith-pivots            234
;  :conflicts               99
;  :datatype-accessor-ax    71
;  :datatype-constructor-ax 234
;  :datatype-occurs-check   139
;  :datatype-splits         82
;  :decisions               274
;  :del-clause              1226
;  :final-checks            73
;  :max-generation          5
;  :max-memory              5.55
;  :memory                  5.55
;  :minimized-lits          3
;  :mk-bool-var             3207
;  :mk-clause               1334
;  :num-allocs              229727
;  :num-checks              124
;  :propagations            432
;  :quant-instantiations    978
;  :rlimit-count            335687)
(assert (< i1@128@03 (alen<Int> (opt_get1 $Snap.unit res@79@03))))
(pop) ; 9
; Joined path conditions
(assert (< i1@128@03 (alen<Int> (opt_get1 $Snap.unit res@79@03))))
(pop) ; 8
(declare-fun inv@129@03 ($Ref) Int)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(assert (forall ((i1@128@03 Int)) (!
  (< i1@128@03 (alen<Int> (opt_get1 $Snap.unit res@79@03)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@79@03) i1@128@03))
  :qid |bool-aux|)))
; Check receiver injectivity
(push) ; 8
(assert (not (forall ((i11@128@03 Int) (i12@128@03 Int)) (!
  (implies
    (and
      (and (< i11@128@03 V@12@03) (<= 0 i11@128@03))
      (and (< i12@128@03 V@12@03) (<= 0 i12@128@03))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@79@03) i11@128@03)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@79@03) i12@128@03)))
    (= i11@128@03 i12@128@03))
  
  :qid |bool-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               2222
;  :arith-add-rows          446
;  :arith-assert-diseq      58
;  :arith-assert-lower      310
;  :arith-assert-upper      151
;  :arith-bound-prop        66
;  :arith-conflicts         37
;  :arith-eq-adapter        172
;  :arith-fixed-eqs         69
;  :arith-offset-eqs        32
;  :arith-pivots            236
;  :conflicts               100
;  :datatype-accessor-ax    71
;  :datatype-constructor-ax 234
;  :datatype-occurs-check   139
;  :datatype-splits         82
;  :decisions               274
;  :del-clause              1232
;  :final-checks            73
;  :max-generation          5
;  :max-memory              5.56
;  :memory                  5.55
;  :minimized-lits          3
;  :mk-bool-var             3228
;  :mk-clause               1340
;  :num-allocs              230253
;  :num-checks              125
;  :propagations            432
;  :quant-instantiations    994
;  :rlimit-count            336645)
; Definitional axioms for inverse functions
(assert (forall ((i1@128@03 Int)) (!
  (implies
    (and (< i1@128@03 V@12@03) (<= 0 i1@128@03))
    (=
      (inv@129@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@79@03) i1@128@03))
      i1@128@03))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@79@03) i1@128@03))
  )))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@129@03 r) V@12@03) (<= 0 (inv@129@03 r)))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@79@03) (inv@129@03 r))
      r))
  :pattern ((inv@129@03 r))
  :qid |bool-fctOfInv|)))
; Permissions are non-negative
; Field permissions are at most one
; Permission implies non-null receiver
(assert (forall ((i1@128@03 Int)) (!
  (implies
    (and (< i1@128@03 V@12@03) (<= 0 i1@128@03))
    (not
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@79@03) i1@128@03)
        $Ref.null)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@79@03) i1@128@03))
  :qid |bool-permImpliesNonNull|)))
(declare-const sm@130@03 $FVF<Bool>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@129@03 r) V@12@03) (<= 0 (inv@129@03 r)))
    (=
      ($FVF.lookup_bool (as sm@130@03  $FVF<Bool>) r)
      ($FVF.lookup_bool ($SortWrappers.$SnapTo$FVF<Bool> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03)))))))))))))))))))) r)))
  :pattern (($FVF.lookup_bool (as sm@130@03  $FVF<Bool>) r))
  :pattern (($FVF.lookup_bool ($SortWrappers.$SnapTo$FVF<Bool> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03)))))))))))))))))))) r))
  :qid |qp.fvfValDef41|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_bool ($FVF.lookup_bool ($SortWrappers.$SnapTo$FVF<Bool> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03)))))))))))))))))))) r) r)
  :pattern (($FVF.lookup_bool (as sm@130@03  $FVF<Bool>) r))
  :qid |qp.fvfResTrgDef42|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@129@03 r) V@12@03) (<= 0 (inv@129@03 r)))
    ($FVF.loc_bool ($FVF.lookup_bool (as sm@130@03  $FVF<Bool>) r) r))
  :pattern ((inv@129@03 r))
  )))
; Loop head block: Check well-definedness of edge conditions
(push) ; 8
; [eval] !(|queue| == 0)
; [eval] |queue| == 0
; [eval] |queue|
(pop) ; 8
(push) ; 8
; [eval] !!(|queue| == 0)
; [eval] !(|queue| == 0)
; [eval] |queue| == 0
; [eval] |queue|
(pop) ; 8
(pop) ; 7
(push) ; 7
; Loop head block: Establish invariant
; [eval] exc == excBeforeLoop
; [eval] Gf != (None(): option[array])
; [eval] (None(): option[array])
; [eval] alen(opt_get1(Gf)) == V
; [eval] alen(opt_get1(Gf))
; [eval] opt_get1(Gf)
(push) ; 8
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 8
; Joined path conditions
(declare-const i1@131@03 Int)
(push) ; 8
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 9
; [then-branch: 84 | 0 <= i1@131@03 | live]
; [else-branch: 84 | !(0 <= i1@131@03) | live]
(push) ; 10
; [then-branch: 84 | 0 <= i1@131@03]
(assert (<= 0 i1@131@03))
; [eval] i1 < V
(pop) ; 10
(push) ; 10
; [else-branch: 84 | !(0 <= i1@131@03)]
(assert (not (<= 0 i1@131@03)))
(pop) ; 10
(pop) ; 9
; Joined path conditions
; Joined path conditions
(assert (and (< i1@131@03 V@12@03) (<= 0 i1@131@03)))
(declare-const $k@132@03 $Perm)
(assert ($Perm.isReadVar $k@132@03 $Perm.Write))
; [eval] aloc(opt_get1(Gf), i1)
; [eval] opt_get1(Gf)
(push) ; 9
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 9
; Joined path conditions
(push) ; 9
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 10
(assert (not (< i1@131@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               2226
;  :arith-add-rows          449
;  :arith-assert-diseq      59
;  :arith-assert-lower      315
;  :arith-assert-upper      153
;  :arith-bound-prop        66
;  :arith-conflicts         37
;  :arith-eq-adapter        174
;  :arith-fixed-eqs         70
;  :arith-offset-eqs        32
;  :arith-pivots            238
;  :conflicts               100
;  :datatype-accessor-ax    71
;  :datatype-constructor-ax 234
;  :datatype-occurs-check   139
;  :datatype-splits         82
;  :decisions               274
;  :del-clause              1287
;  :final-checks            73
;  :max-generation          5
;  :max-memory              5.56
;  :memory                  5.53
;  :minimized-lits          3
;  :mk-bool-var             3248
;  :mk-clause               1343
;  :num-allocs              231315
;  :num-checks              126
;  :propagations            433
;  :quant-instantiations    996
;  :rlimit-count            339245)
(assert (< i1@131@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03))))
(pop) ; 9
; Joined path conditions
(assert (< i1@131@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03))))
(pop) ; 8
(declare-fun inv@133@03 ($Ref) Int)
; Nested auxiliary terms: globals
(assert ($Perm.isReadVar $k@132@03 $Perm.Write))
; Nested auxiliary terms: non-globals
(assert (forall ((i1@131@03 Int)) (!
  (< i1@131@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@131@03))
  :qid |option$array$-aux|)))
(push) ; 8
(assert (not (forall ((i1@131@03 Int)) (!
  (implies
    (and (< i1@131@03 V@12@03) (<= 0 i1@131@03))
    (or (= $k@132@03 $Perm.No) (< $Perm.No $k@132@03)))
  
  ))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               2226
;  :arith-add-rows          449
;  :arith-assert-diseq      60
;  :arith-assert-lower      317
;  :arith-assert-upper      154
;  :arith-bound-prop        66
;  :arith-conflicts         37
;  :arith-eq-adapter        175
;  :arith-fixed-eqs         70
;  :arith-offset-eqs        32
;  :arith-pivots            238
;  :conflicts               101
;  :datatype-accessor-ax    71
;  :datatype-constructor-ax 234
;  :datatype-occurs-check   139
;  :datatype-splits         82
;  :decisions               274
;  :del-clause              1289
;  :final-checks            73
;  :max-generation          5
;  :max-memory              5.56
;  :memory                  5.53
;  :minimized-lits          3
;  :mk-bool-var             3255
;  :mk-clause               1345
;  :num-allocs              231749
;  :num-checks              127
;  :propagations            434
;  :quant-instantiations    996
;  :rlimit-count            339790)
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 8
(assert (not (forall ((i11@131@03 Int) (i12@131@03 Int)) (!
  (implies
    (and
      (and
        (and
          (and (< i11@131@03 V@12@03) (<= 0 i11@131@03))
          ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@22@03  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i11@131@03)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i11@131@03)))
        (< $Perm.No $k@132@03))
      (and
        (and
          (and (< i12@131@03 V@12@03) (<= 0 i12@131@03))
          ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@22@03  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i12@131@03)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i12@131@03)))
        (< $Perm.No $k@132@03))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i11@131@03)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i12@131@03)))
    (= i11@131@03 i12@131@03))
  
  :qid |option$array$-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               2236
;  :arith-add-rows          453
;  :arith-assert-diseq      61
;  :arith-assert-lower      321
;  :arith-assert-upper      154
;  :arith-bound-prop        66
;  :arith-conflicts         37
;  :arith-eq-adapter        176
;  :arith-fixed-eqs         70
;  :arith-offset-eqs        32
;  :arith-pivots            240
;  :conflicts               102
;  :datatype-accessor-ax    71
;  :datatype-constructor-ax 234
;  :datatype-occurs-check   139
;  :datatype-splits         82
;  :decisions               274
;  :del-clause              1296
;  :final-checks            73
;  :max-generation          5
;  :max-memory              5.56
;  :memory                  5.53
;  :minimized-lits          3
;  :mk-bool-var             3279
;  :mk-clause               1352
;  :num-allocs              232150
;  :num-checks              128
;  :propagations            434
;  :quant-instantiations    1009
;  :rlimit-count            340668)
; Definitional axioms for inverse functions
(assert (forall ((i1@131@03 Int)) (!
  (implies
    (and (and (< i1@131@03 V@12@03) (<= 0 i1@131@03)) (< $Perm.No $k@132@03))
    (=
      (inv@133@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@131@03))
      i1@131@03))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@131@03))
  :qid |option$array$-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and (< (inv@133@03 r) V@12@03) (<= 0 (inv@133@03 r)))
      (< $Perm.No $k@132@03))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) (inv@133@03 r))
      r))
  :pattern ((inv@133@03 r))
  :qid |option$array$-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@133@03 r) V@12@03) (<= 0 (inv@133@03 r)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@22@03  $FVF<option<array>>) r) r))
  :pattern ((inv@133@03 r))
  )))
; Precomputing data for removing quantified permissions
(define-fun pTaken@134@03 ((r $Ref)) $Perm
  (ite
    (and (< (inv@133@03 r) V@12@03) (<= 0 (inv@133@03 r)))
    ($Perm.min
      (ite
        (and (< (inv@21@03 r) V@12@03) (<= 0 (inv@21@03 r)))
        $k@20@03
        $Perm.No)
      $k@132@03)
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Constrain original permissions $k@132@03
(assert (forall ((r $Ref)) (!
  (implies
    (not
      (=
        (ite
          (and (< (inv@21@03 r) V@12@03) (<= 0 (inv@21@03 r)))
          $k@20@03
          $Perm.No)
        $Perm.No))
    (ite
      (and (< (inv@21@03 r) V@12@03) (<= 0 (inv@21@03 r)))
      (<
        (ite
          (and (< (inv@133@03 r) V@12@03) (<= 0 (inv@133@03 r)))
          $k@132@03
          $Perm.No)
        $k@20@03)
      (<
        (ite
          (and (< (inv@133@03 r) V@12@03) (<= 0 (inv@133@03 r)))
          $k@132@03
          $Perm.No)
        $Perm.No)))
  :pattern ((inv@21@03 r))
  :pattern ((inv@133@03 r))
  :qid |qp.srp43|)))
; Intermediate check if already taken enough permissions
(set-option :timeout 500)
(push) ; 8
(assert (not (forall ((r $Ref)) (!
  (implies
    (and (< (inv@133@03 r) V@12@03) (<= 0 (inv@133@03 r)))
    (= (- $k@132@03 (pTaken@134@03 r)) $Perm.No))
  
  ))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               2328
;  :arith-add-rows          503
;  :arith-assert-diseq      69
;  :arith-assert-lower      337
;  :arith-assert-upper      164
;  :arith-bound-prop        72
;  :arith-conflicts         40
;  :arith-eq-adapter        196
;  :arith-fixed-eqs         75
;  :arith-offset-eqs        36
;  :arith-pivots            259
;  :conflicts               113
;  :datatype-accessor-ax    72
;  :datatype-constructor-ax 246
;  :datatype-occurs-check   146
;  :datatype-splits         86
;  :decisions               296
;  :del-clause              1412
;  :final-checks            76
;  :max-generation          5
;  :max-memory              5.56
;  :memory                  5.53
;  :minimized-lits          4
;  :mk-bool-var             3436
;  :mk-clause               1466
;  :num-allocs              234560
;  :num-checks              130
;  :propagations            473
;  :quant-instantiations    1032
;  :rlimit-count            345282
;  :time                    0.00)
; Final check if taken enough permissions
; Done removing quantified permissions
; Definitional axioms for snapshot map values
; [eval] (forall i1: Int :: { aloc(opt_get1(Gf), i1) } 0 <= i1 && i1 < V ==> aloc(opt_get1(Gf), i1).option$array$ != (None(): option[array]))
(declare-const i1@135@03 Int)
(push) ; 8
; [eval] 0 <= i1 && i1 < V ==> aloc(opt_get1(Gf), i1).option$array$ != (None(): option[array])
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 9
; [then-branch: 85 | 0 <= i1@135@03 | live]
; [else-branch: 85 | !(0 <= i1@135@03) | live]
(push) ; 10
; [then-branch: 85 | 0 <= i1@135@03]
(assert (<= 0 i1@135@03))
; [eval] i1 < V
(pop) ; 10
(push) ; 10
; [else-branch: 85 | !(0 <= i1@135@03)]
(assert (not (<= 0 i1@135@03)))
(pop) ; 10
(pop) ; 9
; Joined path conditions
; Joined path conditions
(push) ; 9
; [then-branch: 86 | i1@135@03 < V@12@03 && 0 <= i1@135@03 | live]
; [else-branch: 86 | !(i1@135@03 < V@12@03 && 0 <= i1@135@03) | live]
(push) ; 10
; [then-branch: 86 | i1@135@03 < V@12@03 && 0 <= i1@135@03]
(assert (and (< i1@135@03 V@12@03) (<= 0 i1@135@03)))
; [eval] aloc(opt_get1(Gf), i1).option$array$ != (None(): option[array])
; [eval] aloc(opt_get1(Gf), i1)
; [eval] opt_get1(Gf)
(push) ; 11
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 11
; Joined path conditions
(push) ; 11
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 12
(assert (not (< i1@135@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))))
(check-sat)
; unsat
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               2328
;  :arith-add-rows          503
;  :arith-assert-diseq      69
;  :arith-assert-lower      339
;  :arith-assert-upper      164
;  :arith-bound-prop        72
;  :arith-conflicts         40
;  :arith-eq-adapter        196
;  :arith-fixed-eqs         75
;  :arith-offset-eqs        36
;  :arith-pivots            259
;  :conflicts               113
;  :datatype-accessor-ax    72
;  :datatype-constructor-ax 246
;  :datatype-occurs-check   146
;  :datatype-splits         86
;  :decisions               296
;  :del-clause              1412
;  :final-checks            76
;  :max-generation          5
;  :max-memory              5.56
;  :memory                  5.53
;  :minimized-lits          4
;  :mk-bool-var             3438
;  :mk-clause               1466
;  :num-allocs              234669
;  :num-checks              131
;  :propagations            473
;  :quant-instantiations    1032
;  :rlimit-count            345470)
(assert (< i1@135@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03))))
(pop) ; 11
; Joined path conditions
(assert (< i1@135@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@22@03  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@135@03)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@135@03)))
(push) ; 11
(assert (not (ite
  (and
    (<
      (inv@21@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@135@03))
      V@12@03)
    (<=
      0
      (inv@21@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@135@03))))
  (< $Perm.No $k@20@03)
  false)))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               2340
;  :arith-add-rows          515
;  :arith-assert-diseq      69
;  :arith-assert-lower      342
;  :arith-assert-upper      168
;  :arith-bound-prop        75
;  :arith-conflicts         41
;  :arith-eq-adapter        199
;  :arith-fixed-eqs         78
;  :arith-offset-eqs        36
;  :arith-pivots            263
;  :conflicts               114
;  :datatype-accessor-ax    72
;  :datatype-constructor-ax 246
;  :datatype-occurs-check   146
;  :datatype-splits         86
;  :decisions               296
;  :del-clause              1412
;  :final-checks            76
;  :max-generation          5
;  :max-memory              5.56
;  :memory                  5.54
;  :minimized-lits          4
;  :mk-bool-var             3486
;  :mk-clause               1490
;  :num-allocs              235111
;  :num-checks              132
;  :propagations            473
;  :quant-instantiations    1050
;  :rlimit-count            346788)
; [eval] (None(): option[array])
(pop) ; 10
(push) ; 10
; [else-branch: 86 | !(i1@135@03 < V@12@03 && 0 <= i1@135@03)]
(assert (not (and (< i1@135@03 V@12@03) (<= 0 i1@135@03))))
(pop) ; 10
(pop) ; 9
; Joined path conditions
(assert (implies
  (and (< i1@135@03 V@12@03) (<= 0 i1@135@03))
  (and
    (< i1@135@03 V@12@03)
    (<= 0 i1@135@03)
    (< i1@135@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@22@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@135@03)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@135@03)))))
; Joined path conditions
(pop) ; 8
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@135@03 Int)) (!
  (implies
    (and (< i1@135@03 V@12@03) (<= 0 i1@135@03))
    (and
      (< i1@135@03 V@12@03)
      (<= 0 i1@135@03)
      (< i1@135@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@22@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@135@03)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@135@03))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@135@03))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(push) ; 8
(assert (not (forall ((i1@135@03 Int)) (!
  (implies
    (and (< i1@135@03 V@12@03) (<= 0 i1@135@03))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@22@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@135@03))
        (as None<option<array>>  option<array>))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@135@03))
  :qid |prog.l<no position>|))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               2346
;  :arith-add-rows          522
;  :arith-assert-diseq      69
;  :arith-assert-lower      344
;  :arith-assert-upper      168
;  :arith-bound-prop        76
;  :arith-conflicts         41
;  :arith-eq-adapter        200
;  :arith-fixed-eqs         78
;  :arith-offset-eqs        37
;  :arith-pivots            269
;  :conflicts               115
;  :datatype-accessor-ax    72
;  :datatype-constructor-ax 246
;  :datatype-occurs-check   146
;  :datatype-splits         86
;  :decisions               296
;  :del-clause              1465
;  :final-checks            76
;  :max-generation          5
;  :max-memory              5.56
;  :memory                  5.54
;  :minimized-lits          4
;  :mk-bool-var             3526
;  :mk-clause               1519
;  :num-allocs              235749
;  :num-checks              133
;  :propagations            473
;  :quant-instantiations    1070
;  :rlimit-count            348283)
(assert (forall ((i1@135@03 Int)) (!
  (implies
    (and (< i1@135@03 V@12@03) (<= 0 i1@135@03))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@22@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@135@03))
        (as None<option<array>>  option<array>))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@135@03))
  :qid |prog.l<no position>|)))
; [eval] (forall i1: Int :: { alen(opt_get1(aloc(opt_get1(Gf), i1).option$array$)) } 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(Gf), i1).option$array$)) == V)
(declare-const i1@136@03 Int)
(push) ; 8
; [eval] 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(Gf), i1).option$array$)) == V
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 9
; [then-branch: 87 | 0 <= i1@136@03 | live]
; [else-branch: 87 | !(0 <= i1@136@03) | live]
(push) ; 10
; [then-branch: 87 | 0 <= i1@136@03]
(assert (<= 0 i1@136@03))
; [eval] i1 < V
(pop) ; 10
(push) ; 10
; [else-branch: 87 | !(0 <= i1@136@03)]
(assert (not (<= 0 i1@136@03)))
(pop) ; 10
(pop) ; 9
; Joined path conditions
; Joined path conditions
(push) ; 9
; [then-branch: 88 | i1@136@03 < V@12@03 && 0 <= i1@136@03 | live]
; [else-branch: 88 | !(i1@136@03 < V@12@03 && 0 <= i1@136@03) | live]
(push) ; 10
; [then-branch: 88 | i1@136@03 < V@12@03 && 0 <= i1@136@03]
(assert (and (< i1@136@03 V@12@03) (<= 0 i1@136@03)))
; [eval] alen(opt_get1(aloc(opt_get1(Gf), i1).option$array$)) == V
; [eval] alen(opt_get1(aloc(opt_get1(Gf), i1).option$array$))
; [eval] opt_get1(aloc(opt_get1(Gf), i1).option$array$)
; [eval] aloc(opt_get1(Gf), i1)
; [eval] opt_get1(Gf)
(push) ; 11
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 11
; Joined path conditions
(push) ; 11
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 12
(assert (not (< i1@136@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))))
(check-sat)
; unsat
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               2346
;  :arith-add-rows          522
;  :arith-assert-diseq      69
;  :arith-assert-lower      346
;  :arith-assert-upper      168
;  :arith-bound-prop        76
;  :arith-conflicts         41
;  :arith-eq-adapter        200
;  :arith-fixed-eqs         78
;  :arith-offset-eqs        37
;  :arith-pivots            269
;  :conflicts               115
;  :datatype-accessor-ax    72
;  :datatype-constructor-ax 246
;  :datatype-occurs-check   146
;  :datatype-splits         86
;  :decisions               296
;  :del-clause              1465
;  :final-checks            76
;  :max-generation          5
;  :max-memory              5.56
;  :memory                  5.54
;  :minimized-lits          4
;  :mk-bool-var             3529
;  :mk-clause               1519
;  :num-allocs              236053
;  :num-checks              134
;  :propagations            473
;  :quant-instantiations    1070
;  :rlimit-count            348782)
(assert (< i1@136@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03))))
(pop) ; 11
; Joined path conditions
(assert (< i1@136@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@22@03  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@136@03)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@136@03)))
(push) ; 11
(assert (not (ite
  (and
    (<
      (inv@21@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@136@03))
      V@12@03)
    (<=
      0
      (inv@21@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@136@03))))
  (< $Perm.No $k@20@03)
  false)))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               2359
;  :arith-add-rows          534
;  :arith-assert-diseq      69
;  :arith-assert-lower      349
;  :arith-assert-upper      172
;  :arith-bound-prop        79
;  :arith-conflicts         42
;  :arith-eq-adapter        203
;  :arith-fixed-eqs         81
;  :arith-offset-eqs        37
;  :arith-pivots            273
;  :conflicts               116
;  :datatype-accessor-ax    72
;  :datatype-constructor-ax 246
;  :datatype-occurs-check   146
;  :datatype-splits         86
;  :decisions               296
;  :del-clause              1465
;  :final-checks            76
;  :max-generation          5
;  :max-memory              5.59
;  :memory                  5.58
;  :minimized-lits          4
;  :mk-bool-var             3578
;  :mk-clause               1543
;  :num-allocs              236497
;  :num-checks              135
;  :propagations            473
;  :quant-instantiations    1089
;  :rlimit-count            350132)
(push) ; 11
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 12
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@22@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@136@03))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               2359
;  :arith-add-rows          534
;  :arith-assert-diseq      69
;  :arith-assert-lower      349
;  :arith-assert-upper      172
;  :arith-bound-prop        79
;  :arith-conflicts         42
;  :arith-eq-adapter        203
;  :arith-fixed-eqs         81
;  :arith-offset-eqs        37
;  :arith-pivots            273
;  :conflicts               117
;  :datatype-accessor-ax    72
;  :datatype-constructor-ax 246
;  :datatype-occurs-check   146
;  :datatype-splits         86
;  :decisions               296
;  :del-clause              1465
;  :final-checks            76
;  :max-generation          5
;  :max-memory              5.59
;  :memory                  5.58
;  :minimized-lits          4
;  :mk-bool-var             3578
;  :mk-clause               1543
;  :num-allocs              236586
;  :num-checks              136
;  :propagations            473
;  :quant-instantiations    1089
;  :rlimit-count            350227)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@22@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@136@03))
    (as None<option<array>>  option<array>))))
(pop) ; 11
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@22@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@136@03))
    (as None<option<array>>  option<array>))))
(pop) ; 10
(push) ; 10
; [else-branch: 88 | !(i1@136@03 < V@12@03 && 0 <= i1@136@03)]
(assert (not (and (< i1@136@03 V@12@03) (<= 0 i1@136@03))))
(pop) ; 10
(pop) ; 9
; Joined path conditions
(assert (implies
  (and (< i1@136@03 V@12@03) (<= 0 i1@136@03))
  (and
    (< i1@136@03 V@12@03)
    (<= 0 i1@136@03)
    (< i1@136@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@22@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@136@03)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@136@03))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@22@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@136@03))
        (as None<option<array>>  option<array>))))))
; Joined path conditions
(pop) ; 8
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@136@03 Int)) (!
  (implies
    (and (< i1@136@03 V@12@03) (<= 0 i1@136@03))
    (and
      (< i1@136@03 V@12@03)
      (<= 0 i1@136@03)
      (< i1@136@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@22@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@136@03)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@136@03))
      (not
        (=
          ($FVF.lookup_option$array$ (as sm@22@03  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@136@03))
          (as None<option<array>>  option<array>)))))
  :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@22@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@136@03)))))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(push) ; 8
(assert (not (forall ((i1@136@03 Int)) (!
  (implies
    (and (< i1@136@03 V@12@03) (<= 0 i1@136@03))
    (=
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@22@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@136@03))))
      V@12@03))
  :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@22@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@136@03)))))
  :qid |prog.l<no position>|))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               2359
;  :arith-add-rows          539
;  :arith-assert-diseq      69
;  :arith-assert-lower      351
;  :arith-assert-upper      172
;  :arith-bound-prop        79
;  :arith-conflicts         42
;  :arith-eq-adapter        204
;  :arith-fixed-eqs         81
;  :arith-offset-eqs        37
;  :arith-pivots            277
;  :conflicts               118
;  :datatype-accessor-ax    72
;  :datatype-constructor-ax 246
;  :datatype-occurs-check   146
;  :datatype-splits         86
;  :decisions               296
;  :del-clause              1499
;  :final-checks            76
;  :max-generation          5
;  :max-memory              5.59
;  :memory                  5.57
;  :minimized-lits          4
;  :mk-bool-var             3600
;  :mk-clause               1553
;  :num-allocs              237108
;  :num-checks              137
;  :propagations            473
;  :quant-instantiations    1104
;  :rlimit-count            351404)
(assert (forall ((i1@136@03 Int)) (!
  (implies
    (and (< i1@136@03 V@12@03) (<= 0 i1@136@03))
    (=
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@22@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@136@03))))
      V@12@03))
  :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@22@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@136@03)))))
  :qid |prog.l<no position>|)))
; [eval] (forall i1: Int :: { aloc(opt_get1(Gf), i1) } (forall i2: Int :: { aloc(opt_get1(Gf), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(Gf), i1).option$array$ == aloc(opt_get1(Gf), i2).option$array$ ==> i1 == i2))
(declare-const i1@137@03 Int)
(push) ; 8
; [eval] (forall i2: Int :: { aloc(opt_get1(Gf), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(Gf), i1).option$array$ == aloc(opt_get1(Gf), i2).option$array$ ==> i1 == i2)
(declare-const i2@138@03 Int)
(push) ; 9
; [eval] 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(Gf), i1).option$array$ == aloc(opt_get1(Gf), i2).option$array$ ==> i1 == i2
; [eval] 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(Gf), i1).option$array$ == aloc(opt_get1(Gf), i2).option$array$
; [eval] 0 <= i1
(push) ; 10
; [then-branch: 89 | 0 <= i1@137@03 | live]
; [else-branch: 89 | !(0 <= i1@137@03) | live]
(push) ; 11
; [then-branch: 89 | 0 <= i1@137@03]
(assert (<= 0 i1@137@03))
; [eval] i1 < V
(push) ; 12
; [then-branch: 90 | i1@137@03 < V@12@03 | live]
; [else-branch: 90 | !(i1@137@03 < V@12@03) | live]
(push) ; 13
; [then-branch: 90 | i1@137@03 < V@12@03]
(assert (< i1@137@03 V@12@03))
; [eval] 0 <= i2
(push) ; 14
; [then-branch: 91 | 0 <= i2@138@03 | live]
; [else-branch: 91 | !(0 <= i2@138@03) | live]
(push) ; 15
; [then-branch: 91 | 0 <= i2@138@03]
(assert (<= 0 i2@138@03))
; [eval] i2 < V
(push) ; 16
; [then-branch: 92 | i2@138@03 < V@12@03 | live]
; [else-branch: 92 | !(i2@138@03 < V@12@03) | live]
(push) ; 17
; [then-branch: 92 | i2@138@03 < V@12@03]
(assert (< i2@138@03 V@12@03))
; [eval] aloc(opt_get1(Gf), i1).option$array$ == aloc(opt_get1(Gf), i2).option$array$
; [eval] aloc(opt_get1(Gf), i1)
; [eval] opt_get1(Gf)
(push) ; 18
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 18
; Joined path conditions
(push) ; 18
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 19
(assert (not (< i1@137@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))))
(check-sat)
; unsat
(pop) ; 19
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               2359
;  :arith-add-rows          539
;  :arith-assert-diseq      69
;  :arith-assert-lower      354
;  :arith-assert-upper      173
;  :arith-bound-prop        79
;  :arith-conflicts         42
;  :arith-eq-adapter        204
;  :arith-fixed-eqs         81
;  :arith-offset-eqs        37
;  :arith-pivots            277
;  :conflicts               118
;  :datatype-accessor-ax    72
;  :datatype-constructor-ax 246
;  :datatype-occurs-check   146
;  :datatype-splits         86
;  :decisions               296
;  :del-clause              1499
;  :final-checks            76
;  :max-generation          5
;  :max-memory              5.59
;  :memory                  5.58
;  :minimized-lits          4
;  :mk-bool-var             3605
;  :mk-clause               1553
;  :num-allocs              237603
;  :num-checks              138
;  :propagations            473
;  :quant-instantiations    1104
;  :rlimit-count            352038)
(assert (< i1@137@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03))))
(pop) ; 18
; Joined path conditions
(assert (< i1@137@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@22@03  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@137@03)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@137@03)))
(push) ; 18
(assert (not (ite
  (and
    (<
      (inv@21@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@137@03))
      V@12@03)
    (<=
      0
      (inv@21@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@137@03))))
  (< $Perm.No $k@20@03)
  false)))
(check-sat)
; unsat
(pop) ; 18
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               2372
;  :arith-add-rows          551
;  :arith-assert-diseq      69
;  :arith-assert-lower      357
;  :arith-assert-upper      177
;  :arith-bound-prop        82
;  :arith-conflicts         43
;  :arith-eq-adapter        207
;  :arith-fixed-eqs         84
;  :arith-offset-eqs        37
;  :arith-pivots            281
;  :conflicts               119
;  :datatype-accessor-ax    72
;  :datatype-constructor-ax 246
;  :datatype-occurs-check   146
;  :datatype-splits         86
;  :decisions               296
;  :del-clause              1499
;  :final-checks            76
;  :max-generation          5
;  :max-memory              5.59
;  :memory                  5.58
;  :minimized-lits          4
;  :mk-bool-var             3654
;  :mk-clause               1577
;  :num-allocs              238039
;  :num-checks              139
;  :propagations            473
;  :quant-instantiations    1123
;  :rlimit-count            353388)
; [eval] aloc(opt_get1(Gf), i2)
; [eval] opt_get1(Gf)
(push) ; 18
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 18
; Joined path conditions
(push) ; 18
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 19
(assert (not (< i2@138@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))))
(check-sat)
; unsat
(pop) ; 19
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               2372
;  :arith-add-rows          551
;  :arith-assert-diseq      69
;  :arith-assert-lower      357
;  :arith-assert-upper      177
;  :arith-bound-prop        82
;  :arith-conflicts         43
;  :arith-eq-adapter        207
;  :arith-fixed-eqs         84
;  :arith-offset-eqs        37
;  :arith-pivots            281
;  :conflicts               119
;  :datatype-accessor-ax    72
;  :datatype-constructor-ax 246
;  :datatype-occurs-check   146
;  :datatype-splits         86
;  :decisions               296
;  :del-clause              1499
;  :final-checks            76
;  :max-generation          5
;  :max-memory              5.59
;  :memory                  5.58
;  :minimized-lits          4
;  :mk-bool-var             3654
;  :mk-clause               1577
;  :num-allocs              238065
;  :num-checks              140
;  :propagations            473
;  :quant-instantiations    1123
;  :rlimit-count            353418)
(assert (< i2@138@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03))))
(pop) ; 18
; Joined path conditions
(assert (< i2@138@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@22@03  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@138@03)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@138@03)))
(push) ; 18
(assert (not (ite
  (and
    (<
      (inv@21@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@138@03))
      V@12@03)
    (<=
      0
      (inv@21@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@138@03))))
  (< $Perm.No $k@20@03)
  false)))
(check-sat)
; unsat
(pop) ; 18
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               2386
;  :arith-add-rows          565
;  :arith-assert-diseq      69
;  :arith-assert-lower      360
;  :arith-assert-upper      181
;  :arith-bound-prop        85
;  :arith-conflicts         44
;  :arith-eq-adapter        211
;  :arith-fixed-eqs         87
;  :arith-offset-eqs        37
;  :arith-pivots            285
;  :conflicts               120
;  :datatype-accessor-ax    72
;  :datatype-constructor-ax 246
;  :datatype-occurs-check   146
;  :datatype-splits         86
;  :decisions               296
;  :del-clause              1499
;  :final-checks            76
;  :max-generation          5
;  :max-memory              5.59
;  :memory                  5.59
;  :minimized-lits          4
;  :mk-bool-var             3721
;  :mk-clause               1607
;  :num-allocs              238556
;  :num-checks              141
;  :propagations            473
;  :quant-instantiations    1145
;  :rlimit-count            355003)
(pop) ; 17
(push) ; 17
; [else-branch: 92 | !(i2@138@03 < V@12@03)]
(assert (not (< i2@138@03 V@12@03)))
(pop) ; 17
(pop) ; 16
; Joined path conditions
(assert (implies
  (< i2@138@03 V@12@03)
  (and
    (< i2@138@03 V@12@03)
    (< i1@137@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@22@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@137@03)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@137@03))
    (< i2@138@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@22@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@138@03)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@138@03)))))
; Joined path conditions
(pop) ; 15
(push) ; 15
; [else-branch: 91 | !(0 <= i2@138@03)]
(assert (not (<= 0 i2@138@03)))
(pop) ; 15
(pop) ; 14
; Joined path conditions
(assert (implies
  (<= 0 i2@138@03)
  (and
    (<= 0 i2@138@03)
    (implies
      (< i2@138@03 V@12@03)
      (and
        (< i2@138@03 V@12@03)
        (< i1@137@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@22@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@137@03)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@137@03))
        (< i2@138@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@22@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@138@03)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@138@03)))))))
; Joined path conditions
(pop) ; 13
(push) ; 13
; [else-branch: 90 | !(i1@137@03 < V@12@03)]
(assert (not (< i1@137@03 V@12@03)))
(pop) ; 13
(pop) ; 12
; Joined path conditions
(assert (implies
  (< i1@137@03 V@12@03)
  (and
    (< i1@137@03 V@12@03)
    (implies
      (<= 0 i2@138@03)
      (and
        (<= 0 i2@138@03)
        (implies
          (< i2@138@03 V@12@03)
          (and
            (< i2@138@03 V@12@03)
            (< i1@137@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@22@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@137@03)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@137@03))
            (< i2@138@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@22@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@138@03)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@138@03)))))))))
; Joined path conditions
(pop) ; 11
(push) ; 11
; [else-branch: 89 | !(0 <= i1@137@03)]
(assert (not (<= 0 i1@137@03)))
(pop) ; 11
(pop) ; 10
; Joined path conditions
(assert (implies
  (<= 0 i1@137@03)
  (and
    (<= 0 i1@137@03)
    (implies
      (< i1@137@03 V@12@03)
      (and
        (< i1@137@03 V@12@03)
        (implies
          (<= 0 i2@138@03)
          (and
            (<= 0 i2@138@03)
            (implies
              (< i2@138@03 V@12@03)
              (and
                (< i2@138@03 V@12@03)
                (< i1@137@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@22@03  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@137@03)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@137@03))
                (< i2@138@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@22@03  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@138@03)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@138@03)))))))))))
; Joined path conditions
(push) ; 10
; [then-branch: 93 | Lookup(option$array$,sm@22@03,aloc((_, _), opt_get1(_, Gf@11@03), i1@137@03)) == Lookup(option$array$,sm@22@03,aloc((_, _), opt_get1(_, Gf@11@03), i2@138@03)) && i2@138@03 < V@12@03 && 0 <= i2@138@03 && i1@137@03 < V@12@03 && 0 <= i1@137@03 | live]
; [else-branch: 93 | !(Lookup(option$array$,sm@22@03,aloc((_, _), opt_get1(_, Gf@11@03), i1@137@03)) == Lookup(option$array$,sm@22@03,aloc((_, _), opt_get1(_, Gf@11@03), i2@138@03)) && i2@138@03 < V@12@03 && 0 <= i2@138@03 && i1@137@03 < V@12@03 && 0 <= i1@137@03) | live]
(push) ; 11
; [then-branch: 93 | Lookup(option$array$,sm@22@03,aloc((_, _), opt_get1(_, Gf@11@03), i1@137@03)) == Lookup(option$array$,sm@22@03,aloc((_, _), opt_get1(_, Gf@11@03), i2@138@03)) && i2@138@03 < V@12@03 && 0 <= i2@138@03 && i1@137@03 < V@12@03 && 0 <= i1@137@03]
(assert (and
  (and
    (and
      (and
        (=
          ($FVF.lookup_option$array$ (as sm@22@03  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@137@03))
          ($FVF.lookup_option$array$ (as sm@22@03  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@138@03)))
        (< i2@138@03 V@12@03))
      (<= 0 i2@138@03))
    (< i1@137@03 V@12@03))
  (<= 0 i1@137@03)))
; [eval] i1 == i2
(pop) ; 11
(push) ; 11
; [else-branch: 93 | !(Lookup(option$array$,sm@22@03,aloc((_, _), opt_get1(_, Gf@11@03), i1@137@03)) == Lookup(option$array$,sm@22@03,aloc((_, _), opt_get1(_, Gf@11@03), i2@138@03)) && i2@138@03 < V@12@03 && 0 <= i2@138@03 && i1@137@03 < V@12@03 && 0 <= i1@137@03)]
(assert (not
  (and
    (and
      (and
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@22@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@137@03))
            ($FVF.lookup_option$array$ (as sm@22@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@138@03)))
          (< i2@138@03 V@12@03))
        (<= 0 i2@138@03))
      (< i1@137@03 V@12@03))
    (<= 0 i1@137@03))))
(pop) ; 11
(pop) ; 10
; Joined path conditions
(assert (implies
  (and
    (and
      (and
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@22@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@137@03))
            ($FVF.lookup_option$array$ (as sm@22@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@138@03)))
          (< i2@138@03 V@12@03))
        (<= 0 i2@138@03))
      (< i1@137@03 V@12@03))
    (<= 0 i1@137@03))
  (and
    (=
      ($FVF.lookup_option$array$ (as sm@22@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@137@03))
      ($FVF.lookup_option$array$ (as sm@22@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@138@03)))
    (< i2@138@03 V@12@03)
    (<= 0 i2@138@03)
    (< i1@137@03 V@12@03)
    (<= 0 i1@137@03))))
; Joined path conditions
(pop) ; 9
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i2@138@03 Int)) (!
  (and
    (implies
      (<= 0 i1@137@03)
      (and
        (<= 0 i1@137@03)
        (implies
          (< i1@137@03 V@12@03)
          (and
            (< i1@137@03 V@12@03)
            (implies
              (<= 0 i2@138@03)
              (and
                (<= 0 i2@138@03)
                (implies
                  (< i2@138@03 V@12@03)
                  (and
                    (< i2@138@03 V@12@03)
                    (< i1@137@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))
                    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@22@03  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@137@03)) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@137@03))
                    (< i2@138@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))
                    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@22@03  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@138@03)) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@138@03))))))))))
    (implies
      (and
        (and
          (and
            (and
              (=
                ($FVF.lookup_option$array$ (as sm@22@03  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@137@03))
                ($FVF.lookup_option$array$ (as sm@22@03  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@138@03)))
              (< i2@138@03 V@12@03))
            (<= 0 i2@138@03))
          (< i1@137@03 V@12@03))
        (<= 0 i1@137@03))
      (and
        (=
          ($FVF.lookup_option$array$ (as sm@22@03  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@137@03))
          ($FVF.lookup_option$array$ (as sm@22@03  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@138@03)))
        (< i2@138@03 V@12@03)
        (<= 0 i2@138@03)
        (< i1@137@03 V@12@03)
        (<= 0 i1@137@03))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@138@03))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 8
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@137@03 Int)) (!
  (forall ((i2@138@03 Int)) (!
    (and
      (implies
        (<= 0 i1@137@03)
        (and
          (<= 0 i1@137@03)
          (implies
            (< i1@137@03 V@12@03)
            (and
              (< i1@137@03 V@12@03)
              (implies
                (<= 0 i2@138@03)
                (and
                  (<= 0 i2@138@03)
                  (implies
                    (< i2@138@03 V@12@03)
                    (and
                      (< i2@138@03 V@12@03)
                      (< i1@137@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))
                      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@22@03  $FVF<option<array>>) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@137@03)) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@137@03))
                      (< i2@138@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))
                      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@22@03  $FVF<option<array>>) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@138@03)) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@138@03))))))))))
      (implies
        (and
          (and
            (and
              (and
                (=
                  ($FVF.lookup_option$array$ (as sm@22@03  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@137@03))
                  ($FVF.lookup_option$array$ (as sm@22@03  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@138@03)))
                (< i2@138@03 V@12@03))
              (<= 0 i2@138@03))
            (< i1@137@03 V@12@03))
          (<= 0 i1@137@03))
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@22@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@137@03))
            ($FVF.lookup_option$array$ (as sm@22@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@138@03)))
          (< i2@138@03 V@12@03)
          (<= 0 i2@138@03)
          (< i1@137@03 V@12@03)
          (<= 0 i1@137@03))))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@138@03))
    :qid |prog.l<no position>-aux|))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@137@03))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(push) ; 8
(assert (not (forall ((i1@137@03 Int)) (!
  (forall ((i2@138@03 Int)) (!
    (implies
      (and
        (and
          (and
            (and
              (=
                ($FVF.lookup_option$array$ (as sm@22@03  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@137@03))
                ($FVF.lookup_option$array$ (as sm@22@03  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@138@03)))
              (< i2@138@03 V@12@03))
            (<= 0 i2@138@03))
          (< i1@137@03 V@12@03))
        (<= 0 i1@137@03))
      (= i1@137@03 i2@138@03))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@138@03))
    :qid |prog.l<no position>|))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@137@03))
  :qid |prog.l<no position>|))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               2407
;  :arith-add-rows          581
;  :arith-assert-diseq      71
;  :arith-assert-lower      366
;  :arith-assert-upper      183
;  :arith-bound-prop        87
;  :arith-conflicts         44
;  :arith-eq-adapter        218
;  :arith-fixed-eqs         89
;  :arith-offset-eqs        37
;  :arith-pivots            297
;  :conflicts               121
;  :datatype-accessor-ax    72
;  :datatype-constructor-ax 246
;  :datatype-occurs-check   146
;  :datatype-splits         86
;  :decisions               296
;  :del-clause              1645
;  :final-checks            76
;  :max-generation          5
;  :max-memory              5.60
;  :memory                  5.59
;  :minimized-lits          4
;  :mk-bool-var             3857
;  :mk-clause               1699
;  :num-allocs              240152
;  :num-checks              142
;  :propagations            479
;  :quant-instantiations    1195
;  :rlimit-count            359852)
(assert (forall ((i1@137@03 Int)) (!
  (forall ((i2@138@03 Int)) (!
    (implies
      (and
        (and
          (and
            (and
              (=
                ($FVF.lookup_option$array$ (as sm@22@03  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@137@03))
                ($FVF.lookup_option$array$ (as sm@22@03  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@138@03)))
              (< i2@138@03 V@12@03))
            (<= 0 i2@138@03))
          (< i1@137@03 V@12@03))
        (<= 0 i1@137@03))
      (= i1@137@03 i2@138@03))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@138@03))
    :qid |prog.l<no position>|))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@137@03))
  :qid |prog.l<no position>|)))
; [eval] p != (None(): option[array])
; [eval] (None(): option[array])
; [eval] alen(opt_get1(p)) == V
; [eval] alen(opt_get1(p))
; [eval] opt_get1(p)
(push) ; 8
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 8
; Joined path conditions
; [eval] 0 <= s
; [eval] s < V
; [eval] 0 <= t
; [eval] t < V
(declare-const i1@139@03 Int)
(declare-const j1@140@03 Int)
(push) ; 8
; [eval] 0 <= i1 && i1 < V && (0 <= j1 && j1 < V)
; [eval] 0 <= i1
(push) ; 9
; [then-branch: 94 | 0 <= i1@139@03 | live]
; [else-branch: 94 | !(0 <= i1@139@03) | live]
(push) ; 10
; [then-branch: 94 | 0 <= i1@139@03]
(assert (<= 0 i1@139@03))
; [eval] i1 < V
(push) ; 11
; [then-branch: 95 | i1@139@03 < V@12@03 | live]
; [else-branch: 95 | !(i1@139@03 < V@12@03) | live]
(push) ; 12
; [then-branch: 95 | i1@139@03 < V@12@03]
(assert (< i1@139@03 V@12@03))
; [eval] 0 <= j1
(push) ; 13
; [then-branch: 96 | 0 <= j1@140@03 | live]
; [else-branch: 96 | !(0 <= j1@140@03) | live]
(push) ; 14
; [then-branch: 96 | 0 <= j1@140@03]
(assert (<= 0 j1@140@03))
; [eval] j1 < V
(pop) ; 14
(push) ; 14
; [else-branch: 96 | !(0 <= j1@140@03)]
(assert (not (<= 0 j1@140@03)))
(pop) ; 14
(pop) ; 13
; Joined path conditions
; Joined path conditions
(pop) ; 12
(push) ; 12
; [else-branch: 95 | !(i1@139@03 < V@12@03)]
(assert (not (< i1@139@03 V@12@03)))
(pop) ; 12
(pop) ; 11
; Joined path conditions
; Joined path conditions
(pop) ; 10
(push) ; 10
; [else-branch: 94 | !(0 <= i1@139@03)]
(assert (not (<= 0 i1@139@03)))
(pop) ; 10
(pop) ; 9
; Joined path conditions
; Joined path conditions
(assert (and
  (and (and (< j1@140@03 V@12@03) (<= 0 j1@140@03)) (< i1@139@03 V@12@03))
  (<= 0 i1@139@03)))
; [eval] aloc(opt_get1(aloc(opt_get1(Gf), i1).option$array$), j1)
; [eval] opt_get1(aloc(opt_get1(Gf), i1).option$array$)
; [eval] aloc(opt_get1(Gf), i1)
; [eval] opt_get1(Gf)
(push) ; 9
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 9
; Joined path conditions
(push) ; 9
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 10
(assert (not (< i1@139@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               2407
;  :arith-add-rows          581
;  :arith-assert-diseq      71
;  :arith-assert-lower      372
;  :arith-assert-upper      183
;  :arith-bound-prop        87
;  :arith-conflicts         44
;  :arith-eq-adapter        218
;  :arith-fixed-eqs         89
;  :arith-offset-eqs        37
;  :arith-pivots            298
;  :conflicts               121
;  :datatype-accessor-ax    72
;  :datatype-constructor-ax 246
;  :datatype-occurs-check   146
;  :datatype-splits         86
;  :decisions               296
;  :del-clause              1645
;  :final-checks            76
;  :max-generation          5
;  :max-memory              5.60
;  :memory                  5.59
;  :minimized-lits          4
;  :mk-bool-var             3864
;  :mk-clause               1699
;  :num-allocs              240756
;  :num-checks              143
;  :propagations            479
;  :quant-instantiations    1195
;  :rlimit-count            360857)
(assert (< i1@139@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03))))
(pop) ; 9
; Joined path conditions
(assert (< i1@139@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@22@03  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@139@03)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@139@03)))
(push) ; 9
(assert (not (ite
  (and
    (<
      (inv@21@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@139@03))
      V@12@03)
    (<=
      0
      (inv@21@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@139@03))))
  (< $Perm.No $k@20@03)
  false)))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               2430
;  :arith-add-rows          596
;  :arith-assert-diseq      71
;  :arith-assert-lower      375
;  :arith-assert-upper      187
;  :arith-bound-prop        91
;  :arith-conflicts         45
;  :arith-eq-adapter        221
;  :arith-fixed-eqs         92
;  :arith-offset-eqs        44
;  :arith-pivots            302
;  :conflicts               122
;  :datatype-accessor-ax    72
;  :datatype-constructor-ax 246
;  :datatype-occurs-check   146
;  :datatype-splits         86
;  :decisions               296
;  :del-clause              1645
;  :final-checks            76
;  :max-generation          5
;  :max-memory              5.60
;  :memory                  5.59
;  :minimized-lits          4
;  :mk-bool-var             3915
;  :mk-clause               1723
;  :num-allocs              241271
;  :num-checks              144
;  :propagations            482
;  :quant-instantiations    1217
;  :rlimit-count            362546)
(push) ; 9
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 10
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@22@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@139@03))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               2430
;  :arith-add-rows          596
;  :arith-assert-diseq      71
;  :arith-assert-lower      375
;  :arith-assert-upper      187
;  :arith-bound-prop        91
;  :arith-conflicts         45
;  :arith-eq-adapter        221
;  :arith-fixed-eqs         92
;  :arith-offset-eqs        44
;  :arith-pivots            302
;  :conflicts               123
;  :datatype-accessor-ax    72
;  :datatype-constructor-ax 246
;  :datatype-occurs-check   146
;  :datatype-splits         86
;  :decisions               296
;  :del-clause              1645
;  :final-checks            76
;  :max-generation          5
;  :max-memory              5.60
;  :memory                  5.59
;  :minimized-lits          4
;  :mk-bool-var             3915
;  :mk-clause               1723
;  :num-allocs              241360
;  :num-checks              145
;  :propagations            482
;  :quant-instantiations    1217
;  :rlimit-count            362641)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@22@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@139@03))
    (as None<option<array>>  option<array>))))
(pop) ; 9
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@22@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@139@03))
    (as None<option<array>>  option<array>))))
(push) ; 9
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 10
(assert (not (<
  j1@140@03
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@22@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@139@03)))))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               2436
;  :arith-add-rows          601
;  :arith-assert-diseq      71
;  :arith-assert-lower      378
;  :arith-assert-upper      188
;  :arith-bound-prop        91
;  :arith-conflicts         46
;  :arith-eq-adapter        222
;  :arith-fixed-eqs         93
;  :arith-offset-eqs        44
;  :arith-pivots            306
;  :conflicts               124
;  :datatype-accessor-ax    72
;  :datatype-constructor-ax 246
;  :datatype-occurs-check   146
;  :datatype-splits         86
;  :decisions               296
;  :del-clause              1649
;  :final-checks            76
;  :max-generation          5
;  :max-memory              5.60
;  :memory                  5.59
;  :minimized-lits          4
;  :mk-bool-var             3926
;  :mk-clause               1727
;  :num-allocs              241562
;  :num-checks              146
;  :propagations            484
;  :quant-instantiations    1226
;  :rlimit-count            363198)
(assert (<
  j1@140@03
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@22@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@139@03))))))
(pop) ; 9
; Joined path conditions
(assert (<
  j1@140@03
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@22@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@139@03))))))
(pop) ; 8
(declare-fun inv@141@03 ($Ref) Int)
(declare-fun inv@142@03 ($Ref) Int)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(assert (forall ((i1@139@03 Int) (j1@140@03 Int)) (!
  (and
    (< i1@139@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@22@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@139@03)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@139@03))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@22@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@139@03))
        (as None<option<array>>  option<array>)))
    (<
      j1@140@03
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@22@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@139@03))))))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@22@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@139@03))) j1@140@03))
  :qid |int-aux|)))
(declare-const sm@143@03 $FVF<Int>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@33@03 r) V@12@03) (<= 0 (inv@33@03 r)))
    (=
      ($FVF.lookup_int (as sm@143@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@03)))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@143@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@03)))))))))))))))) r))
  :qid |qp.fvfValDef44|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@30@03 r) V@12@03) (<= 0 (inv@30@03 r)))
        (< (inv@29@03 r) V@12@03))
      (<= 0 (inv@29@03 r)))
    (=
      ($FVF.lookup_int (as sm@143@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@03))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@143@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@03))))))))))))))) r))
  :qid |qp.fvfValDef45|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@03)))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@03))))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@143@03  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef46|)))
; Check receiver injectivity
(push) ; 8
(assert (not (forall ((i11@139@03 Int) (j11@140@03 Int) (i12@139@03 Int) (j12@140@03 Int)) (!
  (implies
    (and
      (and
        (and
          (and
            (and (< j11@140@03 V@12@03) (<= 0 j11@140@03))
            (< i11@139@03 V@12@03))
          (<= 0 i11@139@03))
        ($FVF.loc_int ($FVF.lookup_int (as sm@143@03  $FVF<Int>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@22@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i11@139@03))) j11@140@03)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@22@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i11@139@03))) j11@140@03)))
      (and
        (and
          (and
            (and (< j12@140@03 V@12@03) (<= 0 j12@140@03))
            (< i12@139@03 V@12@03))
          (<= 0 i12@139@03))
        ($FVF.loc_int ($FVF.lookup_int (as sm@143@03  $FVF<Int>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@22@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i12@139@03))) j12@140@03)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@22@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i12@139@03))) j12@140@03)))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@22@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i11@139@03))) j11@140@03)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@22@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i12@139@03))) j12@140@03)))
    (and (= i11@139@03 i12@139@03) (= j11@140@03 j12@140@03)))
  
  :qid |int-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               2480
;  :arith-add-rows          610
;  :arith-assert-diseq      71
;  :arith-assert-lower      386
;  :arith-assert-upper      190
;  :arith-bound-prop        91
;  :arith-conflicts         46
;  :arith-eq-adapter        232
;  :arith-fixed-eqs         93
;  :arith-offset-eqs        44
;  :arith-pivots            314
;  :conflicts               125
;  :datatype-accessor-ax    72
;  :datatype-constructor-ax 246
;  :datatype-occurs-check   146
;  :datatype-splits         86
;  :decisions               296
;  :del-clause              1751
;  :final-checks            76
;  :max-generation          5
;  :max-memory              5.62
;  :memory                  5.61
;  :minimized-lits          4
;  :mk-bool-var             4076
;  :mk-clause               1805
;  :num-allocs              243408
;  :num-checks              147
;  :propagations            500
;  :quant-instantiations    1290
;  :rlimit-count            368788
;  :time                    0.00)
; Definitional axioms for inverse functions
(assert (forall ((i1@139@03 Int) (j1@140@03 Int)) (!
  (implies
    (and
      (and (and (< j1@140@03 V@12@03) (<= 0 j1@140@03)) (< i1@139@03 V@12@03))
      (<= 0 i1@139@03))
    (and
      (=
        (inv@141@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@22@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@139@03))) j1@140@03))
        i1@139@03)
      (=
        (inv@142@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@22@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@139@03))) j1@140@03))
        j1@140@03)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@22@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@139@03))) j1@140@03))
  :qid |int-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@142@03 r) V@12@03) (<= 0 (inv@142@03 r)))
        (< (inv@141@03 r) V@12@03))
      (<= 0 (inv@141@03 r)))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@22@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) (inv@141@03 r)))) (inv@142@03 r))
      r))
  :pattern ((inv@141@03 r))
  :pattern ((inv@142@03 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@142@03 r) V@12@03) (<= 0 (inv@142@03 r)))
        (< (inv@141@03 r) V@12@03))
      (<= 0 (inv@141@03 r)))
    ($FVF.loc_int ($FVF.lookup_int (as sm@143@03  $FVF<Int>) r) r))
  :pattern ((inv@141@03 r) (inv@142@03 r))
  )))
; Precomputing data for removing quantified permissions
(define-fun pTaken@144@03 ((r $Ref)) $Perm
  (ite
    (and
      (and
        (and (< (inv@142@03 r) V@12@03) (<= 0 (inv@142@03 r)))
        (< (inv@141@03 r) V@12@03))
      (<= 0 (inv@141@03 r)))
    ($Perm.min
      (ite
        (and (< (inv@33@03 r) V@12@03) (<= 0 (inv@33@03 r)))
        $Perm.Write
        $Perm.No)
      $Perm.Write)
    $Perm.No))
(define-fun pTaken@145@03 ((r $Ref)) $Perm
  (ite
    (and
      (and
        (and (< (inv@142@03 r) V@12@03) (<= 0 (inv@142@03 r)))
        (< (inv@141@03 r) V@12@03))
      (<= 0 (inv@141@03 r)))
    ($Perm.min
      (ite
        (and
          (and
            (and (< (inv@30@03 r) V@12@03) (<= 0 (inv@30@03 r)))
            (< (inv@29@03 r) V@12@03))
          (<= 0 (inv@29@03 r)))
        $Perm.Write
        $Perm.No)
      (- $Perm.Write (pTaken@144@03 r)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 500)
(push) ; 8
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and (< (inv@33@03 r) V@12@03) (<= 0 (inv@33@03 r)))
        $Perm.Write
        $Perm.No)
      (pTaken@144@03 r))
    $Perm.No)
  
  ))))
(check-sat)
; unknown
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               2703
;  :arith-add-rows          663
;  :arith-assert-diseq      81
;  :arith-assert-lower      434
;  :arith-assert-upper      217
;  :arith-bound-prop        105
;  :arith-conflicts         49
;  :arith-eq-adapter        266
;  :arith-fixed-eqs         106
;  :arith-offset-eqs        58
;  :arith-pivots            346
;  :conflicts               131
;  :datatype-accessor-ax    74
;  :datatype-constructor-ax 262
;  :datatype-occurs-check   160
;  :datatype-splits         94
;  :decisions               332
;  :del-clause              1954
;  :final-checks            82
;  :max-generation          5
;  :max-memory              5.70
;  :memory                  5.66
;  :minimized-lits          5
;  :mk-bool-var             4427
;  :mk-clause               2008
;  :num-allocs              247722
;  :num-checks              149
;  :propagations            608
;  :quant-instantiations    1392
;  :rlimit-count            376795
;  :time                    0.00)
; Intermediate check if already taken enough permissions
(push) ; 8
(assert (not (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@142@03 r) V@12@03) (<= 0 (inv@142@03 r)))
        (< (inv@141@03 r) V@12@03))
      (<= 0 (inv@141@03 r)))
    (= (- $Perm.Write (pTaken@144@03 r)) $Perm.No))
  
  ))))
(check-sat)
; unknown
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               2887
;  :arith-add-rows          710
;  :arith-assert-diseq      86
;  :arith-assert-lower      459
;  :arith-assert-upper      236
;  :arith-bound-prop        121
;  :arith-conflicts         51
;  :arith-eq-adapter        279
;  :arith-fixed-eqs         116
;  :arith-offset-eqs        72
;  :arith-pivots            376
;  :conflicts               134
;  :datatype-accessor-ax    75
;  :datatype-constructor-ax 270
;  :datatype-occurs-check   167
;  :datatype-splits         98
;  :decisions               350
;  :del-clause              2090
;  :final-checks            85
;  :max-generation          5
;  :max-memory              5.74
;  :memory                  5.70
;  :minimized-lits          5
;  :mk-bool-var             4631
;  :mk-clause               2144
;  :num-allocs              250077
;  :num-checks              150
;  :propagations            658
;  :quant-instantiations    1457
;  :rlimit-count            382518
;  :time                    0.00)
; Chunk depleted?
(push) ; 8
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and
          (and
            (and (< (inv@30@03 r) V@12@03) (<= 0 (inv@30@03 r)))
            (< (inv@29@03 r) V@12@03))
          (<= 0 (inv@29@03 r)))
        $Perm.Write
        $Perm.No)
      (pTaken@145@03 r))
    $Perm.No)
  
  ))))
(check-sat)
; unknown
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               3212
;  :arith-add-rows          878
;  :arith-assert-diseq      100
;  :arith-assert-lower      579
;  :arith-assert-upper      284
;  :arith-bound-prop        144
;  :arith-conflicts         55
;  :arith-eq-adapter        339
;  :arith-fixed-eqs         152
;  :arith-offset-eqs        91
;  :arith-pivots            448
;  :conflicts               144
;  :datatype-accessor-ax    76
;  :datatype-constructor-ax 278
;  :datatype-occurs-check   174
;  :datatype-splits         102
;  :decisions               390
;  :del-clause              2387
;  :final-checks            88
;  :max-generation          5
;  :max-memory              5.78
;  :memory                  5.73
;  :minimized-lits          6
;  :mk-bool-var             5107
;  :mk-clause               2441
;  :num-allocs              253688
;  :num-checks              151
;  :propagations            827
;  :quant-instantiations    1599
;  :rlimit-count            393012
;  :time                    0.00)
; Intermediate check if already taken enough permissions
(push) ; 8
(assert (not (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@142@03 r) V@12@03) (<= 0 (inv@142@03 r)))
        (< (inv@141@03 r) V@12@03))
      (<= 0 (inv@141@03 r)))
    (= (- (- $Perm.Write (pTaken@144@03 r)) (pTaken@145@03 r)) $Perm.No))
  
  ))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               3418
;  :arith-add-rows          978
;  :arith-assert-diseq      117
;  :arith-assert-lower      622
;  :arith-assert-upper      329
;  :arith-bound-prop        163
;  :arith-conflicts         61
;  :arith-eq-adapter        387
;  :arith-fixed-eqs         170
;  :arith-offset-eqs        112
;  :arith-pivots            489
;  :conflicts               159
;  :datatype-accessor-ax    76
;  :datatype-constructor-ax 282
;  :datatype-occurs-check   174
;  :datatype-splits         102
;  :decisions               404
;  :del-clause              2619
;  :final-checks            88
;  :max-generation          5
;  :max-memory              5.78
;  :memory                  5.72
;  :minimized-lits          9
;  :mk-bool-var             5425
;  :mk-clause               2673
;  :num-allocs              255278
;  :num-checks              152
;  :propagations            901
;  :quant-instantiations    1663
;  :rlimit-count            399199
;  :time                    0.00)
; Final check if taken enough permissions
; Done removing quantified permissions
; Definitional axioms for snapshot map values
(declare-const i1@146@03 Int)
(push) ; 8
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 9
; [then-branch: 97 | 0 <= i1@146@03 | live]
; [else-branch: 97 | !(0 <= i1@146@03) | live]
(push) ; 10
; [then-branch: 97 | 0 <= i1@146@03]
(assert (<= 0 i1@146@03))
; [eval] i1 < V
(pop) ; 10
(push) ; 10
; [else-branch: 97 | !(0 <= i1@146@03)]
(assert (not (<= 0 i1@146@03)))
(pop) ; 10
(pop) ; 9
; Joined path conditions
; Joined path conditions
(assert (and (< i1@146@03 V@12@03) (<= 0 i1@146@03)))
; [eval] aloc(opt_get1(p), i1)
; [eval] opt_get1(p)
(push) ; 9
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 9
; Joined path conditions
(push) ; 9
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 10
(assert (not (< i1@146@03 (alen<Int> (opt_get1 $Snap.unit p@15@03)))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               3418
;  :arith-add-rows          978
;  :arith-assert-diseq      117
;  :arith-assert-lower      624
;  :arith-assert-upper      329
;  :arith-bound-prop        163
;  :arith-conflicts         61
;  :arith-eq-adapter        387
;  :arith-fixed-eqs         170
;  :arith-offset-eqs        112
;  :arith-pivots            489
;  :conflicts               159
;  :datatype-accessor-ax    76
;  :datatype-constructor-ax 282
;  :datatype-occurs-check   174
;  :datatype-splits         102
;  :decisions               404
;  :del-clause              2619
;  :final-checks            88
;  :max-generation          5
;  :max-memory              5.78
;  :memory                  5.72
;  :minimized-lits          9
;  :mk-bool-var             5427
;  :mk-clause               2673
;  :num-allocs              255387
;  :num-checks              153
;  :propagations            901
;  :quant-instantiations    1663
;  :rlimit-count            399379)
(assert (< i1@146@03 (alen<Int> (opt_get1 $Snap.unit p@15@03))))
(pop) ; 9
; Joined path conditions
(assert (< i1@146@03 (alen<Int> (opt_get1 $Snap.unit p@15@03))))
(pop) ; 8
(declare-fun inv@147@03 ($Ref) Int)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(assert (forall ((i1@146@03 Int)) (!
  (< i1@146@03 (alen<Int> (opt_get1 $Snap.unit p@15@03)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) i1@146@03))
  :qid |int-aux|)))
(declare-const sm@148@03 $FVF<Int>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (ite
          (and
            (and
              (and (< (inv@30@03 r) V@12@03) (<= 0 (inv@30@03 r)))
              (< (inv@29@03 r) V@12@03))
            (<= 0 (inv@29@03 r)))
          $Perm.Write
          $Perm.No)
        (pTaken@145@03 r)))
    (=
      ($FVF.lookup_int (as sm@148@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@03))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@148@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@03))))))))))))))) r))
  :qid |qp.fvfValDef47|)))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (ite
          (and (< (inv@33@03 r) V@12@03) (<= 0 (inv@33@03 r)))
          $Perm.Write
          $Perm.No)
        (pTaken@144@03 r)))
    (=
      ($FVF.lookup_int (as sm@148@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@03)))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@148@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@03)))))))))))))))) r))
  :qid |qp.fvfValDef48|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@03))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@03)))))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@148@03  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef49|)))
; Check receiver injectivity
(push) ; 8
(assert (not (forall ((i11@146@03 Int) (i12@146@03 Int)) (!
  (implies
    (and
      (and
        (and (< i11@146@03 V@12@03) (<= 0 i11@146@03))
        ($FVF.loc_int ($FVF.lookup_int (as sm@148@03  $FVF<Int>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit p@15@03) i11@146@03)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit p@15@03) i11@146@03)))
      (and
        (and (< i12@146@03 V@12@03) (<= 0 i12@146@03))
        ($FVF.loc_int ($FVF.lookup_int (as sm@148@03  $FVF<Int>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit p@15@03) i12@146@03)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit p@15@03) i12@146@03)))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) i11@146@03)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) i12@146@03)))
    (= i11@146@03 i12@146@03))
  
  :qid |int-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               3431
;  :arith-add-rows          980
;  :arith-assert-diseq      118
;  :arith-assert-lower      628
;  :arith-assert-upper      329
;  :arith-bound-prop        163
;  :arith-conflicts         61
;  :arith-eq-adapter        388
;  :arith-fixed-eqs         170
;  :arith-offset-eqs        112
;  :arith-pivots            489
;  :conflicts               160
;  :datatype-accessor-ax    76
;  :datatype-constructor-ax 282
;  :datatype-occurs-check   174
;  :datatype-splits         102
;  :decisions               404
;  :del-clause              2655
;  :final-checks            88
;  :max-generation          5
;  :max-memory              5.78
;  :memory                  5.72
;  :minimized-lits          9
;  :mk-bool-var             5488
;  :mk-clause               2709
;  :num-allocs              256694
;  :num-checks              154
;  :propagations            903
;  :quant-instantiations    1683
;  :rlimit-count            403565)
; Definitional axioms for inverse functions
(assert (forall ((i1@146@03 Int)) (!
  (implies
    (and (< i1@146@03 V@12@03) (<= 0 i1@146@03))
    (=
      (inv@147@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) i1@146@03))
      i1@146@03))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) i1@146@03))
  :qid |int-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@147@03 r) V@12@03) (<= 0 (inv@147@03 r)))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) (inv@147@03 r))
      r))
  :pattern ((inv@147@03 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@147@03 r) V@12@03) (<= 0 (inv@147@03 r)))
    ($FVF.loc_int ($FVF.lookup_int (as sm@148@03  $FVF<Int>) r) r))
  :pattern ((inv@147@03 r))
  )))
; Precomputing data for removing quantified permissions
(define-fun pTaken@149@03 ((r $Ref)) $Perm
  (ite
    (and (< (inv@147@03 r) V@12@03) (<= 0 (inv@147@03 r)))
    ($Perm.min
      (-
        (ite
          (and
            (and
              (and (< (inv@30@03 r) V@12@03) (<= 0 (inv@30@03 r)))
              (< (inv@29@03 r) V@12@03))
            (<= 0 (inv@29@03 r)))
          $Perm.Write
          $Perm.No)
        (pTaken@145@03 r))
      $Perm.Write)
    $Perm.No))
(define-fun pTaken@150@03 ((r $Ref)) $Perm
  (ite
    (and (< (inv@147@03 r) V@12@03) (<= 0 (inv@147@03 r)))
    ($Perm.min
      (-
        (ite
          (and (< (inv@33@03 r) V@12@03) (<= 0 (inv@33@03 r)))
          $Perm.Write
          $Perm.No)
        (pTaken@144@03 r))
      (- $Perm.Write (pTaken@149@03 r)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 500)
(push) ; 8
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (-
        (ite
          (and
            (and
              (and (< (inv@30@03 r) V@12@03) (<= 0 (inv@30@03 r)))
              (< (inv@29@03 r) V@12@03))
            (<= 0 (inv@29@03 r)))
          $Perm.Write
          $Perm.No)
        (pTaken@145@03 r))
      (pTaken@149@03 r))
    $Perm.No)
  
  ))))
(check-sat)
; unsat
(pop) ; 8
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               4174
;  :arith-add-rows          1276
;  :arith-assert-diseq      149
;  :arith-assert-lower      850
;  :arith-assert-upper      473
;  :arith-bound-prop        208
;  :arith-conflicts         71
;  :arith-eq-adapter        548
;  :arith-fixed-eqs         287
;  :arith-offset-eqs        127
;  :arith-pivots            633
;  :conflicts               189
;  :datatype-accessor-ax    77
;  :datatype-constructor-ax 294
;  :datatype-occurs-check   181
;  :datatype-splits         106
;  :decisions               456
;  :del-clause              3596
;  :final-checks            91
;  :max-generation          5
;  :max-memory              6.43
;  :memory                  6.13
;  :minimized-lits          15
;  :mk-bool-var             7074
;  :mk-clause               3650
;  :num-allocs              265004
;  :num-checks              156
;  :propagations            1289
;  :quant-instantiations    2056
;  :rlimit-count            422099
;  :time                    0.01)
; Intermediate check if already taken enough permissions
(push) ; 8
(assert (not (forall ((r $Ref)) (!
  (implies
    (and (< (inv@147@03 r) V@12@03) (<= 0 (inv@147@03 r)))
    (= (- $Perm.Write (pTaken@149@03 r)) $Perm.No))
  
  ))))
(check-sat)
; unknown
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               4465
;  :arith-add-rows          1355
;  :arith-assert-diseq      169
;  :arith-assert-lower      927
;  :arith-assert-upper      529
;  :arith-bound-prop        230
;  :arith-conflicts         78
;  :arith-eq-adapter        600
;  :arith-fixed-eqs         312
;  :arith-offset-eqs        154
;  :arith-pivots            675
;  :conflicts               198
;  :datatype-accessor-ax    78
;  :datatype-constructor-ax 302
;  :datatype-occurs-check   188
;  :datatype-splits         110
;  :decisions               482
;  :del-clause              3831
;  :final-checks            94
;  :max-generation          5
;  :max-memory              6.43
;  :memory                  6.14
;  :minimized-lits          15
;  :mk-bool-var             7421
;  :mk-clause               3885
;  :num-allocs              267840
;  :num-checks              157
;  :propagations            1412
;  :quant-instantiations    2142
;  :rlimit-count            430037
;  :time                    0.00)
; Chunk depleted?
(push) ; 8
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (-
        (ite
          (and (< (inv@33@03 r) V@12@03) (<= 0 (inv@33@03 r)))
          $Perm.Write
          $Perm.No)
        (pTaken@144@03 r))
      (pTaken@150@03 r))
    $Perm.No)
  
  ))))
(check-sat)
; unsat
(pop) ; 8
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               5103
;  :arith-add-rows          1734
;  :arith-assert-diseq      193
;  :arith-assert-lower      1109
;  :arith-assert-upper      659
;  :arith-bound-prop        284
;  :arith-conflicts         88
;  :arith-eq-adapter        740
;  :arith-fixed-eqs         415
;  :arith-offset-eqs        191
;  :arith-pivots            805
;  :conflicts               225
;  :datatype-accessor-ax    78
;  :datatype-constructor-ax 306
;  :datatype-occurs-check   188
;  :datatype-splits         110
;  :decisions               514
;  :del-clause              4656
;  :final-checks            94
;  :max-generation          5
;  :max-memory              6.43
;  :memory                  6.24
;  :minimized-lits          22
;  :mk-bool-var             8930
;  :mk-clause               4710
;  :num-allocs              274226
;  :num-checks              158
;  :propagations            1749
;  :quant-instantiations    2461
;  :rlimit-count            447273
;  :time                    0.01)
; Intermediate check if already taken enough permissions
(push) ; 8
(assert (not (forall ((r $Ref)) (!
  (implies
    (and (< (inv@147@03 r) V@12@03) (<= 0 (inv@147@03 r)))
    (= (- (- $Perm.Write (pTaken@149@03 r)) (pTaken@150@03 r)) $Perm.No))
  
  ))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               5516
;  :arith-add-rows          1973
;  :arith-assert-diseq      219
;  :arith-assert-lower      1211
;  :arith-assert-upper      726
;  :arith-bound-prop        317
;  :arith-conflicts         98
;  :arith-eq-adapter        839
;  :arith-fixed-eqs         453
;  :arith-offset-eqs        242
;  :arith-pivots            873
;  :conflicts               249
;  :datatype-accessor-ax    78
;  :datatype-constructor-ax 310
;  :datatype-occurs-check   188
;  :datatype-splits         110
;  :decisions               539
;  :del-clause              5148
;  :final-checks            94
;  :max-generation          5
;  :max-memory              6.43
;  :memory                  6.25
;  :minimized-lits          28
;  :mk-bool-var             9659
;  :mk-clause               5202
;  :num-allocs              277385
;  :num-checks              159
;  :propagations            1961
;  :quant-instantiations    2586
;  :rlimit-count            457814
;  :time                    0.00)
; Final check if taken enough permissions
; Done removing quantified permissions
; Definitional axioms for snapshot map values
; [eval] valid_graph_vertices(this, p, V)
(push) ; 8
; [eval] this != null
; [eval] p != (None(): option[array])
; [eval] (None(): option[array])
; [eval] alen(opt_get1(p)) == V
; [eval] alen(opt_get1(p))
; [eval] opt_get1(p)
(push) ; 9
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 9
; Joined path conditions
(declare-const i1@151@03 Int)
(push) ; 9
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 10
; [then-branch: 98 | 0 <= i1@151@03 | live]
; [else-branch: 98 | !(0 <= i1@151@03) | live]
(push) ; 11
; [then-branch: 98 | 0 <= i1@151@03]
(assert (<= 0 i1@151@03))
; [eval] i1 < V
(pop) ; 11
(push) ; 11
; [else-branch: 98 | !(0 <= i1@151@03)]
(assert (not (<= 0 i1@151@03)))
(pop) ; 11
(pop) ; 10
; Joined path conditions
; Joined path conditions
(assert (and (< i1@151@03 V@12@03) (<= 0 i1@151@03)))
(declare-const $k@152@03 $Perm)
(assert ($Perm.isReadVar $k@152@03 $Perm.Write))
; [eval] aloc(opt_get1(p), i1)
; [eval] opt_get1(p)
(push) ; 10
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 10
; Joined path conditions
(push) ; 10
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 11
(assert (not (< i1@151@03 (alen<Int> (opt_get1 $Snap.unit p@15@03)))))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               5516
;  :arith-add-rows          1973
;  :arith-assert-diseq      220
;  :arith-assert-lower      1215
;  :arith-assert-upper      727
;  :arith-bound-prop        317
;  :arith-conflicts         98
;  :arith-eq-adapter        840
;  :arith-fixed-eqs         453
;  :arith-offset-eqs        242
;  :arith-pivots            873
;  :conflicts               249
;  :datatype-accessor-ax    78
;  :datatype-constructor-ax 310
;  :datatype-occurs-check   188
;  :datatype-splits         110
;  :decisions               539
;  :del-clause              5148
;  :final-checks            94
;  :max-generation          5
;  :max-memory              6.43
;  :memory                  6.25
;  :minimized-lits          28
;  :mk-bool-var             9665
;  :mk-clause               5204
;  :num-allocs              277561
;  :num-checks              160
;  :propagations            1962
;  :quant-instantiations    2586
;  :rlimit-count            458145)
(assert (< i1@151@03 (alen<Int> (opt_get1 $Snap.unit p@15@03))))
(pop) ; 10
; Joined path conditions
(assert (< i1@151@03 (alen<Int> (opt_get1 $Snap.unit p@15@03))))
(pop) ; 9
(declare-fun inv@153@03 ($Ref) Int)
; Nested auxiliary terms: globals
(assert ($Perm.isReadVar $k@152@03 $Perm.Write))
; Nested auxiliary terms: non-globals
(assert (forall ((i1@151@03 Int)) (!
  (< i1@151@03 (alen<Int> (opt_get1 $Snap.unit p@15@03)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) i1@151@03))
  :qid |int-aux|)))
(push) ; 9
(assert (not (forall ((i1@151@03 Int)) (!
  (implies
    (and (< i1@151@03 V@12@03) (<= 0 i1@151@03))
    (or (= $k@152@03 $Perm.No) (< $Perm.No $k@152@03)))
  
  ))))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               5516
;  :arith-add-rows          1973
;  :arith-assert-diseq      221
;  :arith-assert-lower      1217
;  :arith-assert-upper      728
;  :arith-bound-prop        317
;  :arith-conflicts         98
;  :arith-eq-adapter        841
;  :arith-fixed-eqs         453
;  :arith-offset-eqs        242
;  :arith-pivots            873
;  :conflicts               250
;  :datatype-accessor-ax    78
;  :datatype-constructor-ax 310
;  :datatype-occurs-check   188
;  :datatype-splits         110
;  :decisions               539
;  :del-clause              5150
;  :final-checks            94
;  :max-generation          5
;  :max-memory              6.43
;  :memory                  6.25
;  :minimized-lits          28
;  :mk-bool-var             9672
;  :mk-clause               5206
;  :num-allocs              277983
;  :num-checks              161
;  :propagations            1963
;  :quant-instantiations    2586
;  :rlimit-count            458690)
(declare-const sm@154@03 $FVF<Int>)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@30@03 r) V@12@03) (<= 0 (inv@30@03 r)))
        (< (inv@29@03 r) V@12@03))
      (<= 0 (inv@29@03 r)))
    (=
      ($FVF.lookup_int (as sm@154@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@03))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@154@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@03))))))))))))))) r))
  :qid |qp.fvfValDef50|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@33@03 r) V@12@03) (<= 0 (inv@33@03 r)))
    (=
      ($FVF.lookup_int (as sm@154@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@03)))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@154@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@03)))))))))))))))) r))
  :qid |qp.fvfValDef51|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@03))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@03)))))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@154@03  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef52|)))
; Check receiver injectivity
(push) ; 9
(assert (not (forall ((i11@151@03 Int) (i12@151@03 Int)) (!
  (implies
    (and
      (and
        (and
          (and (< i11@151@03 V@12@03) (<= 0 i11@151@03))
          ($FVF.loc_int ($FVF.lookup_int (as sm@154@03  $FVF<Int>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit p@15@03) i11@151@03)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit p@15@03) i11@151@03)))
        (< $Perm.No $k@152@03))
      (and
        (and
          (and (< i12@151@03 V@12@03) (<= 0 i12@151@03))
          ($FVF.loc_int ($FVF.lookup_int (as sm@154@03  $FVF<Int>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit p@15@03) i12@151@03)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit p@15@03) i12@151@03)))
        (< $Perm.No $k@152@03))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) i11@151@03)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) i12@151@03)))
    (= i11@151@03 i12@151@03))
  
  :qid |int-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               5531
;  :arith-add-rows          1975
;  :arith-assert-diseq      222
;  :arith-assert-lower      1221
;  :arith-assert-upper      728
;  :arith-bound-prop        317
;  :arith-conflicts         98
;  :arith-eq-adapter        842
;  :arith-fixed-eqs         453
;  :arith-offset-eqs        242
;  :arith-pivots            873
;  :conflicts               251
;  :datatype-accessor-ax    78
;  :datatype-constructor-ax 310
;  :datatype-occurs-check   188
;  :datatype-splits         110
;  :decisions               539
;  :del-clause              5161
;  :final-checks            94
;  :max-generation          5
;  :max-memory              6.43
;  :memory                  6.25
;  :minimized-lits          28
;  :mk-bool-var             9711
;  :mk-clause               5217
;  :num-allocs              278948
;  :num-checks              162
;  :propagations            1965
;  :quant-instantiations    2610
;  :rlimit-count            461538)
; Definitional axioms for inverse functions
(assert (forall ((i1@151@03 Int)) (!
  (implies
    (and (and (< i1@151@03 V@12@03) (<= 0 i1@151@03)) (< $Perm.No $k@152@03))
    (=
      (inv@153@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) i1@151@03))
      i1@151@03))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) i1@151@03))
  :qid |int-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and (< (inv@153@03 r) V@12@03) (<= 0 (inv@153@03 r)))
      (< $Perm.No $k@152@03))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) (inv@153@03 r))
      r))
  :pattern ((inv@153@03 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@153@03 r) V@12@03) (<= 0 (inv@153@03 r)))
    ($FVF.loc_int ($FVF.lookup_int (as sm@154@03  $FVF<Int>) r) r))
  :pattern ((inv@153@03 r))
  )))
; Precomputing data for removing quantified permissions
(define-fun pTaken@155@03 ((r $Ref)) $Perm
  (ite
    (and (< (inv@153@03 r) V@12@03) (<= 0 (inv@153@03 r)))
    ($Perm.min
      (ite
        (and
          (and
            (and (< (inv@30@03 r) V@12@03) (<= 0 (inv@30@03 r)))
            (< (inv@29@03 r) V@12@03))
          (<= 0 (inv@29@03 r)))
        $Perm.Write
        $Perm.No)
      $k@152@03)
    $Perm.No))
(define-fun pTaken@156@03 ((r $Ref)) $Perm
  (ite
    (and (< (inv@153@03 r) V@12@03) (<= 0 (inv@153@03 r)))
    ($Perm.min
      (ite
        (and (< (inv@33@03 r) V@12@03) (<= 0 (inv@33@03 r)))
        $Perm.Write
        $Perm.No)
      (- $k@152@03 (pTaken@155@03 r)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Constrain original permissions $k@152@03
(assert (forall ((r $Ref)) (!
  (implies
    (not
      (=
        (ite
          (and
            (and
              (and (< (inv@30@03 r) V@12@03) (<= 0 (inv@30@03 r)))
              (< (inv@29@03 r) V@12@03))
            (<= 0 (inv@29@03 r)))
          $Perm.Write
          $Perm.No)
        $Perm.No))
    (ite
      (and
        (and
          (and (< (inv@30@03 r) V@12@03) (<= 0 (inv@30@03 r)))
          (< (inv@29@03 r) V@12@03))
        (<= 0 (inv@29@03 r)))
      (<
        (ite
          (and (< (inv@153@03 r) V@12@03) (<= 0 (inv@153@03 r)))
          $k@152@03
          $Perm.No)
        $Perm.Write)
      (<
        (ite
          (and (< (inv@153@03 r) V@12@03) (<= 0 (inv@153@03 r)))
          $k@152@03
          $Perm.No)
        $Perm.No)))
  :pattern ((inv@30@03 r))
  :pattern ((inv@29@03 r))
  :pattern ((inv@153@03 r))
  :qid |qp.srp53|)))
; Intermediate check if already taken enough permissions
(set-option :timeout 500)
(push) ; 9
(assert (not (forall ((r $Ref)) (!
  (implies
    (and (< (inv@153@03 r) V@12@03) (<= 0 (inv@153@03 r)))
    (= (- $k@152@03 (pTaken@155@03 r)) $Perm.No))
  
  ))))
(check-sat)
; unknown
(pop) ; 9
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               5799
;  :arith-add-rows          2032
;  :arith-assert-diseq      231
;  :arith-assert-lower      1265
;  :arith-assert-upper      756
;  :arith-bound-prop        331
;  :arith-conflicts         102
;  :arith-eq-adapter        874
;  :arith-fixed-eqs         470
;  :arith-offset-eqs        254
;  :arith-pivots            905
;  :conflicts               259
;  :datatype-accessor-ax    80
;  :datatype-constructor-ax 326
;  :datatype-occurs-check   202
;  :datatype-splits         118
;  :decisions               578
;  :del-clause              5384
;  :final-checks            101
;  :interface-eqs           1
;  :max-generation          6
;  :max-memory              6.43
;  :memory                  6.27
;  :minimized-lits          28
;  :mk-bool-var             10014
;  :mk-clause               5438
;  :num-allocs              283282
;  :num-checks              164
;  :propagations            2064
;  :quant-instantiations    2698
;  :rlimit-count            470605
;  :time                    0.00)
; Constrain original permissions $k@152@03
(assert (forall ((r $Ref)) (!
  (implies
    (not
      (=
        (ite
          (and (< (inv@33@03 r) V@12@03) (<= 0 (inv@33@03 r)))
          $Perm.Write
          $Perm.No)
        $Perm.No))
    (ite
      (and (< (inv@33@03 r) V@12@03) (<= 0 (inv@33@03 r)))
      (<
        (ite
          (and (< (inv@153@03 r) V@12@03) (<= 0 (inv@153@03 r)))
          $k@152@03
          $Perm.No)
        $Perm.Write)
      (<
        (ite
          (and (< (inv@153@03 r) V@12@03) (<= 0 (inv@153@03 r)))
          $k@152@03
          $Perm.No)
        $Perm.No)))
  :pattern ((inv@33@03 r))
  :pattern ((inv@153@03 r))
  :qid |qp.srp54|)))
; Intermediate check if already taken enough permissions
(push) ; 9
(assert (not (forall ((r $Ref)) (!
  (implies
    (and (< (inv@153@03 r) V@12@03) (<= 0 (inv@153@03 r)))
    (= (- (- $k@152@03 (pTaken@155@03 r)) (pTaken@156@03 r)) $Perm.No))
  
  ))))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               5968
;  :arith-add-rows          2121
;  :arith-assert-diseq      246
;  :arith-assert-lower      1299
;  :arith-assert-upper      787
;  :arith-bound-prop        344
;  :arith-conflicts         108
;  :arith-eq-adapter        919
;  :arith-fixed-eqs         481
;  :arith-offset-eqs        260
;  :arith-pivots            928
;  :conflicts               276
;  :datatype-accessor-ax    80
;  :datatype-constructor-ax 330
;  :datatype-occurs-check   202
;  :datatype-splits         118
;  :decisions               594
;  :del-clause              5628
;  :final-checks            101
;  :interface-eqs           1
;  :max-generation          6
;  :max-memory              6.57
;  :memory                  6.41
;  :minimized-lits          34
;  :mk-bool-var             10311
;  :mk-clause               5682
;  :num-allocs              284926
;  :num-checks              165
;  :propagations            2148
;  :quant-instantiations    2745
;  :rlimit-count            475726
;  :time                    0.00)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@157@03 $FVF<Int>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (iff
    (Set_in r ($FVF.domain_int (as sm@157@03  $FVF<Int>)))
    (and
      (and (< (inv@153@03 r) V@12@03) (<= 0 (inv@153@03 r)))
      (< $Perm.No $k@152@03)))
  :pattern ((Set_in r ($FVF.domain_int (as sm@157@03  $FVF<Int>))))
  :qid |qp.fvfDomDef58|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@153@03 r) V@12@03) (<= 0 (inv@153@03 r)))
        (< $Perm.No $k@152@03))
      (and
        (and
          (and (< (inv@30@03 r) V@12@03) (<= 0 (inv@30@03 r)))
          (< (inv@29@03 r) V@12@03))
        (<= 0 (inv@29@03 r))))
    (=
      ($FVF.lookup_int (as sm@157@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@03))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@157@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@03))))))))))))))) r))
  :qid |qp.fvfValDef55|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@153@03 r) V@12@03) (<= 0 (inv@153@03 r)))
        (< $Perm.No $k@152@03))
      (and (< (inv@33@03 r) V@12@03) (<= 0 (inv@33@03 r))))
    (=
      ($FVF.lookup_int (as sm@157@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@03)))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@157@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@03)))))))))))))))) r))
  :qid |qp.fvfValDef56|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@03))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@03)))))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@157@03  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef57|)))
(pop) ; 8
; Joined path conditions
(assert ($Perm.isReadVar $k@152@03 $Perm.Write))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@30@03 r) V@12@03) (<= 0 (inv@30@03 r)))
        (< (inv@29@03 r) V@12@03))
      (<= 0 (inv@29@03 r)))
    (=
      ($FVF.lookup_int (as sm@154@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@03))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@154@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@03))))))))))))))) r))
  :qid |qp.fvfValDef50|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@33@03 r) V@12@03) (<= 0 (inv@33@03 r)))
    (=
      ($FVF.lookup_int (as sm@154@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@03)))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@154@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@03)))))))))))))))) r))
  :qid |qp.fvfValDef51|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@03))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@03)))))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@154@03  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef52|)))
(assert (forall ((i1@151@03 Int)) (!
  (implies
    (and (and (< i1@151@03 V@12@03) (<= 0 i1@151@03)) (< $Perm.No $k@152@03))
    (=
      (inv@153@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) i1@151@03))
      i1@151@03))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) i1@151@03))
  :qid |int-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and (< (inv@153@03 r) V@12@03) (<= 0 (inv@153@03 r)))
      (< $Perm.No $k@152@03))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) (inv@153@03 r))
      r))
  :pattern ((inv@153@03 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (iff
    (Set_in r ($FVF.domain_int (as sm@157@03  $FVF<Int>)))
    (and
      (and (< (inv@153@03 r) V@12@03) (<= 0 (inv@153@03 r)))
      (< $Perm.No $k@152@03)))
  :pattern ((Set_in r ($FVF.domain_int (as sm@157@03  $FVF<Int>))))
  :qid |qp.fvfDomDef58|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@153@03 r) V@12@03) (<= 0 (inv@153@03 r)))
        (< $Perm.No $k@152@03))
      (and
        (and
          (and (< (inv@30@03 r) V@12@03) (<= 0 (inv@30@03 r)))
          (< (inv@29@03 r) V@12@03))
        (<= 0 (inv@29@03 r))))
    (=
      ($FVF.lookup_int (as sm@157@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@03))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@157@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@03))))))))))))))) r))
  :qid |qp.fvfValDef55|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@153@03 r) V@12@03) (<= 0 (inv@153@03 r)))
        (< $Perm.No $k@152@03))
      (and (< (inv@33@03 r) V@12@03) (<= 0 (inv@33@03 r))))
    (=
      ($FVF.lookup_int (as sm@157@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@03)))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@157@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@03)))))))))))))))) r))
  :qid |qp.fvfValDef56|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@03))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@18@03)))))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@157@03  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef57|)))
(assert (and
  (forall ((i1@151@03 Int)) (!
    (< i1@151@03 (alen<Int> (opt_get1 $Snap.unit p@15@03)))
    :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) i1@151@03))
    :qid |int-aux|))
  (forall ((r $Ref)) (!
    (implies
      (and (< (inv@153@03 r) V@12@03) (<= 0 (inv@153@03 r)))
      ($FVF.loc_int ($FVF.lookup_int (as sm@154@03  $FVF<Int>) r) r))
    :pattern ((inv@153@03 r))
    ))
  (forall ((r $Ref)) (!
    (implies
      (not
        (=
          (ite
            (and
              (and
                (and (< (inv@30@03 r) V@12@03) (<= 0 (inv@30@03 r)))
                (< (inv@29@03 r) V@12@03))
              (<= 0 (inv@29@03 r)))
            $Perm.Write
            $Perm.No)
          $Perm.No))
      (ite
        (and
          (and
            (and (< (inv@30@03 r) V@12@03) (<= 0 (inv@30@03 r)))
            (< (inv@29@03 r) V@12@03))
          (<= 0 (inv@29@03 r)))
        (<
          (ite
            (and (< (inv@153@03 r) V@12@03) (<= 0 (inv@153@03 r)))
            $k@152@03
            $Perm.No)
          $Perm.Write)
        (<
          (ite
            (and (< (inv@153@03 r) V@12@03) (<= 0 (inv@153@03 r)))
            $k@152@03
            $Perm.No)
          $Perm.No)))
    :pattern ((inv@30@03 r))
    :pattern ((inv@29@03 r))
    :pattern ((inv@153@03 r))
    :qid |qp.srp53|))
  (forall ((r $Ref)) (!
    (implies
      (not
        (=
          (ite
            (and (< (inv@33@03 r) V@12@03) (<= 0 (inv@33@03 r)))
            $Perm.Write
            $Perm.No)
          $Perm.No))
      (ite
        (and (< (inv@33@03 r) V@12@03) (<= 0 (inv@33@03 r)))
        (<
          (ite
            (and (< (inv@153@03 r) V@12@03) (<= 0 (inv@153@03 r)))
            $k@152@03
            $Perm.No)
          $Perm.Write)
        (<
          (ite
            (and (< (inv@153@03 r) V@12@03) (<= 0 (inv@153@03 r)))
            $k@152@03
            $Perm.No)
          $Perm.No)))
    :pattern ((inv@33@03 r))
    :pattern ((inv@153@03 r))
    :qid |qp.srp54|))))
(set-option :timeout 0)
(push) ; 8
(assert (not (valid_graph_vertices ($Snap.combine
  $Snap.unit
  ($Snap.combine
    $Snap.unit
    ($Snap.combine
      $Snap.unit
      ($SortWrappers.$FVF<Int>To$Snap (as sm@157@03  $FVF<Int>))))) this@9@03 p@15@03 V@12@03)))
(check-sat)
; unsat
(pop) ; 8
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               6409
;  :arith-add-rows          2304
;  :arith-assert-diseq      247
;  :arith-assert-lower      1376
;  :arith-assert-upper      842
;  :arith-bound-prop        387
;  :arith-conflicts         113
;  :arith-eq-adapter        987
;  :arith-fixed-eqs         535
;  :arith-offset-eqs        285
;  :arith-pivots            1024
;  :conflicts               291
;  :datatype-accessor-ax    84
;  :datatype-constructor-ax 335
;  :datatype-occurs-check   202
;  :datatype-splits         118
;  :decisions               624
;  :del-clause              6671
;  :final-checks            101
;  :interface-eqs           1
;  :max-generation          6
;  :max-memory              6.57
;  :memory                  6.51
;  :minimized-lits          36
;  :mk-bool-var             11767
;  :mk-clause               6727
;  :num-allocs              292821
;  :num-checks              166
;  :propagations            2355
;  :quant-instantiations    3105
;  :rlimit-count            496079
;  :time                    0.01)
(assert (valid_graph_vertices ($Snap.combine
  $Snap.unit
  ($Snap.combine
    $Snap.unit
    ($Snap.combine
      $Snap.unit
      ($SortWrappers.$FVF<Int>To$Snap (as sm@157@03  $FVF<Int>))))) this@9@03 p@15@03 V@12@03))
; [eval] 0 <= s
; [eval] s < V
; [eval] valid_graph_vertices1(this, queue, V)
(push) ; 8
; [eval] this != null
(pop) ; 8
; Joined path conditions
(push) ; 8
(assert (not (valid_graph_vertices1 $Snap.unit this@9@03 queue@96@03 V@12@03)))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               6886
;  :arith-add-rows          2496
;  :arith-assert-diseq      259
;  :arith-assert-lower      1483
;  :arith-assert-upper      970
;  :arith-bound-prop        401
;  :arith-conflicts         122
;  :arith-eq-adapter        1086
;  :arith-fixed-eqs         583
;  :arith-offset-eqs        325
;  :arith-pivots            1089
;  :conflicts               313
;  :datatype-accessor-ax    92
;  :datatype-constructor-ax 349
;  :datatype-occurs-check   217
;  :datatype-splits         128
;  :decisions               770
;  :del-clause              7846
;  :final-checks            112
;  :interface-eqs           7
;  :max-generation          7
;  :max-memory              6.57
;  :memory                  6.53
;  :minimized-lits          38
;  :mk-bool-var             13259
;  :mk-clause               7936
;  :num-allocs              298147
;  :num-checks              167
;  :propagations            2619
;  :quant-instantiations    3437
;  :rlimit-count            510786
;  :time                    0.01)
(assert (valid_graph_vertices1 $Snap.unit this@9@03 queue@96@03 V@12@03))
(declare-const i1@158@03 Int)
(push) ; 8
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 9
; [then-branch: 99 | 0 <= i1@158@03 | live]
; [else-branch: 99 | !(0 <= i1@158@03) | live]
(push) ; 10
; [then-branch: 99 | 0 <= i1@158@03]
(assert (<= 0 i1@158@03))
; [eval] i1 < V
(pop) ; 10
(push) ; 10
; [else-branch: 99 | !(0 <= i1@158@03)]
(assert (not (<= 0 i1@158@03)))
(pop) ; 10
(pop) ; 9
; Joined path conditions
; Joined path conditions
(assert (and (< i1@158@03 V@12@03) (<= 0 i1@158@03)))
; [eval] aloc(opt_get1(visited), i1)
; [eval] opt_get1(visited)
(push) ; 9
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 9
; Joined path conditions
(push) ; 9
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 10
(assert (not (< i1@158@03 (alen<Int> (opt_get1 $Snap.unit res@79@03)))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               6887
;  :arith-add-rows          2496
;  :arith-assert-diseq      259
;  :arith-assert-lower      1485
;  :arith-assert-upper      970
;  :arith-bound-prop        401
;  :arith-conflicts         122
;  :arith-eq-adapter        1086
;  :arith-fixed-eqs         583
;  :arith-offset-eqs        325
;  :arith-pivots            1089
;  :conflicts               313
;  :datatype-accessor-ax    92
;  :datatype-constructor-ax 349
;  :datatype-occurs-check   217
;  :datatype-splits         128
;  :decisions               770
;  :del-clause              7846
;  :final-checks            112
;  :interface-eqs           7
;  :max-generation          7
;  :max-memory              6.57
;  :memory                  6.53
;  :minimized-lits          38
;  :mk-bool-var             13280
;  :mk-clause               7961
;  :num-allocs              298386
;  :num-checks              168
;  :propagations            2625
;  :quant-instantiations    3440
;  :rlimit-count            511156)
(assert (< i1@158@03 (alen<Int> (opt_get1 $Snap.unit res@79@03))))
(pop) ; 9
; Joined path conditions
(assert (< i1@158@03 (alen<Int> (opt_get1 $Snap.unit res@79@03))))
(pop) ; 8
(declare-fun inv@159@03 ($Ref) Int)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(assert (forall ((i1@158@03 Int)) (!
  (< i1@158@03 (alen<Int> (opt_get1 $Snap.unit res@79@03)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@79@03) i1@158@03))
  :qid |bool-aux|)))
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 8
(assert (not (forall ((i11@158@03 Int) (i12@158@03 Int)) (!
  (implies
    (and
      (and
        (and (< i11@158@03 V@12@03) (<= 0 i11@158@03))
        ($FVF.loc_bool ($FVF.lookup_bool (as sm@94@03  $FVF<Bool>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@79@03) i11@158@03)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@79@03) i11@158@03)))
      (and
        (and (< i12@158@03 V@12@03) (<= 0 i12@158@03))
        ($FVF.loc_bool ($FVF.lookup_bool (as sm@94@03  $FVF<Bool>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@79@03) i12@158@03)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@79@03) i12@158@03)))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@79@03) i11@158@03)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@79@03) i12@158@03)))
    (= i11@158@03 i12@158@03))
  
  :qid |bool-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               6898
;  :arith-add-rows          2498
;  :arith-assert-diseq      260
;  :arith-assert-lower      1489
;  :arith-assert-upper      970
;  :arith-bound-prop        401
;  :arith-conflicts         122
;  :arith-eq-adapter        1087
;  :arith-fixed-eqs         583
;  :arith-offset-eqs        325
;  :arith-pivots            1089
;  :conflicts               314
;  :datatype-accessor-ax    92
;  :datatype-constructor-ax 349
;  :datatype-occurs-check   217
;  :datatype-splits         128
;  :decisions               770
;  :del-clause              7857
;  :final-checks            112
;  :interface-eqs           7
;  :max-generation          7
;  :max-memory              6.57
;  :memory                  6.53
;  :minimized-lits          38
;  :mk-bool-var             13309
;  :mk-clause               7972
;  :num-allocs              298933
;  :num-checks              169
;  :propagations            2625
;  :quant-instantiations    3458
;  :rlimit-count            512249)
; Definitional axioms for inverse functions
(assert (forall ((i1@158@03 Int)) (!
  (implies
    (and (< i1@158@03 V@12@03) (<= 0 i1@158@03))
    (=
      (inv@159@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@79@03) i1@158@03))
      i1@158@03))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@79@03) i1@158@03))
  :qid |bool-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@159@03 r) V@12@03) (<= 0 (inv@159@03 r)))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@79@03) (inv@159@03 r))
      r))
  :pattern ((inv@159@03 r))
  :qid |bool-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@159@03 r) V@12@03) (<= 0 (inv@159@03 r)))
    ($FVF.loc_bool ($FVF.lookup_bool (as sm@94@03  $FVF<Bool>) r) r))
  :pattern ((inv@159@03 r))
  )))
; Precomputing data for removing quantified permissions
(define-fun pTaken@160@03 ((r $Ref)) $Perm
  (ite
    (and (< (inv@159@03 r) V@12@03) (<= 0 (inv@159@03 r)))
    ($Perm.min
      (ite
        (and (< (inv@93@03 r) V@12@03) (<= 0 (inv@93@03 r)))
        $Perm.Write
        $Perm.No)
      $Perm.Write)
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 500)
(push) ; 8
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and (< (inv@93@03 r) V@12@03) (<= 0 (inv@93@03 r)))
        $Perm.Write
        $Perm.No)
      (pTaken@160@03 r))
    $Perm.No)
  
  ))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               7315
;  :arith-add-rows          2719
;  :arith-assert-diseq      270
;  :arith-assert-lower      1566
;  :arith-assert-upper      1032
;  :arith-bound-prop        431
;  :arith-conflicts         130
;  :arith-eq-adapter        1157
;  :arith-fixed-eqs         625
;  :arith-offset-eqs        347
;  :arith-pivots            1166
;  :conflicts               336
;  :datatype-accessor-ax    93
;  :datatype-constructor-ax 361
;  :datatype-occurs-check   226
;  :datatype-splits         132
;  :decisions               831
;  :del-clause              8680
;  :final-checks            119
;  :interface-eqs           11
;  :max-generation          7
;  :max-memory              6.58
;  :memory                  6.53
;  :minimized-lits          40
;  :mk-bool-var             14374
;  :mk-clause               8812
;  :num-allocs              304777
;  :num-checks              171
;  :propagations            2789
;  :quant-instantiations    3776
;  :rlimit-count            527494
;  :time                    0.00)
; Intermediate check if already taken enough permissions
(push) ; 8
(assert (not (forall ((r $Ref)) (!
  (implies
    (and (< (inv@159@03 r) V@12@03) (<= 0 (inv@159@03 r)))
    (= (- $Perm.Write (pTaken@160@03 r)) $Perm.No))
  
  ))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               7335
;  :arith-add-rows          2729
;  :arith-assert-diseq      272
;  :arith-assert-lower      1571
;  :arith-assert-upper      1038
;  :arith-bound-prop        432
;  :arith-conflicts         131
;  :arith-eq-adapter        1162
;  :arith-fixed-eqs         627
;  :arith-offset-eqs        347
;  :arith-pivots            1170
;  :conflicts               337
;  :datatype-accessor-ax    93
;  :datatype-constructor-ax 361
;  :datatype-occurs-check   226
;  :datatype-splits         132
;  :decisions               831
;  :del-clause              8711
;  :final-checks            119
;  :interface-eqs           11
;  :max-generation          7
;  :max-memory              6.58
;  :memory                  6.53
;  :minimized-lits          40
;  :mk-bool-var             14424
;  :mk-clause               8843
;  :num-allocs              305199
;  :num-checks              172
;  :propagations            2794
;  :quant-instantiations    3793
;  :rlimit-count            528668)
; Final check if taken enough permissions
; Done removing quantified permissions
; Definitional axioms for snapshot map values
; Loop head block: Execute statements of loop head block (in invariant state)
(push) ; 8
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@129@03 r) V@12@03) (<= 0 (inv@129@03 r)))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@79@03) (inv@129@03 r))
      r))
  :pattern ((inv@129@03 r))
  :qid |bool-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@129@03 r) V@12@03) (<= 0 (inv@129@03 r)))
    (=
      ($FVF.lookup_bool (as sm@130@03  $FVF<Bool>) r)
      ($FVF.lookup_bool ($SortWrappers.$SnapTo$FVF<Bool> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03)))))))))))))))))))) r)))
  :pattern (($FVF.lookup_bool (as sm@130@03  $FVF<Bool>) r))
  :pattern (($FVF.lookup_bool ($SortWrappers.$SnapTo$FVF<Bool> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03)))))))))))))))))))) r))
  :qid |qp.fvfValDef41|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_bool ($FVF.lookup_bool ($SortWrappers.$SnapTo$FVF<Bool> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03)))))))))))))))))))) r) r)
  :pattern (($FVF.lookup_bool (as sm@130@03  $FVF<Bool>) r))
  :qid |qp.fvfResTrgDef42|)))
(assert (forall ((i1@128@03 Int)) (!
  (implies
    (and (< i1@128@03 V@12@03) (<= 0 i1@128@03))
    (=
      (inv@129@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@79@03) i1@128@03))
      i1@128@03))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@79@03) i1@128@03))
  )))
(assert (forall ((i1@128@03 Int)) (!
  (implies
    (and (< i1@128@03 V@12@03) (<= 0 i1@128@03))
    (not
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@79@03) i1@128@03)
        $Ref.null)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@79@03) i1@128@03))
  :qid |bool-permImpliesNonNull|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@129@03 r) V@12@03) (<= 0 (inv@129@03 r)))
    ($FVF.loc_bool ($FVF.lookup_bool (as sm@130@03  $FVF<Bool>) r) r))
  :pattern ((inv@129@03 r))
  )))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@120@03 r) V@12@03) (<= 0 (inv@120@03 r)))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) (inv@120@03 r))
      r))
  :pattern ((inv@120@03 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@120@03 r) V@12@03) (<= 0 (inv@120@03 r)))
    (=
      ($FVF.lookup_int (as sm@121@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03)))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@121@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03)))))))))))))))) r))
  :qid |qp.fvfValDef33|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@117@03 r) V@12@03) (<= 0 (inv@117@03 r)))
        (< (inv@116@03 r) V@12@03))
      (<= 0 (inv@116@03 r)))
    (=
      ($FVF.lookup_int (as sm@121@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@121@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03))))))))))))))) r))
  :qid |qp.fvfValDef34|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03)))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03))))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@121@03  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef35|)))
(assert ($Perm.isReadVar $k@123@03 $Perm.Write))
(assert (forall ((i1@122@03 Int)) (!
  (implies
    (and (and (< i1@122@03 V@12@03) (<= 0 i1@122@03)) (< $Perm.No $k@123@03))
    (=
      (inv@124@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) i1@122@03))
      i1@122@03))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) i1@122@03))
  :qid |int-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and (< (inv@124@03 r) V@12@03) (<= 0 (inv@124@03 r)))
      (< $Perm.No $k@123@03))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) (inv@124@03 r))
      r))
  :pattern ((inv@124@03 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (iff
    (Set_in r ($FVF.domain_int (as sm@127@03  $FVF<Int>)))
    (and
      (and (< (inv@124@03 r) V@12@03) (<= 0 (inv@124@03 r)))
      (< $Perm.No $k@123@03)))
  :pattern ((Set_in r ($FVF.domain_int (as sm@127@03  $FVF<Int>))))
  :qid |qp.fvfDomDef40|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@124@03 r) V@12@03) (<= 0 (inv@124@03 r)))
        (< $Perm.No $k@123@03))
      (and (< (inv@120@03 r) V@12@03) (<= 0 (inv@120@03 r))))
    (=
      ($FVF.lookup_int (as sm@127@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03)))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@127@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03)))))))))))))))) r))
  :qid |qp.fvfValDef37|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@124@03 r) V@12@03) (<= 0 (inv@124@03 r)))
        (< $Perm.No $k@123@03))
      (and
        (and
          (and (< (inv@117@03 r) V@12@03) (<= 0 (inv@117@03 r)))
          (< (inv@116@03 r) V@12@03))
        (<= 0 (inv@116@03 r))))
    (=
      ($FVF.lookup_int (as sm@127@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@127@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03))))))))))))))) r))
  :qid |qp.fvfValDef38|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03)))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03))))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@127@03  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef39|)))
(assert (forall ((i1@119@03 Int)) (!
  (implies
    (and (< i1@119@03 V@12@03) (<= 0 i1@119@03))
    (=
      (inv@120@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) i1@119@03))
      i1@119@03))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) i1@119@03))
  )))
(assert (forall ((i1@119@03 Int)) (!
  (implies
    (and (< i1@119@03 V@12@03) (<= 0 i1@119@03))
    (not
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) i1@119@03)
        $Ref.null)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) i1@119@03))
  :qid |int-permImpliesNonNull|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@120@03 r) V@12@03) (<= 0 (inv@120@03 r)))
    ($FVF.loc_int ($FVF.lookup_int (as sm@121@03  $FVF<Int>) r) r))
  :pattern ((inv@120@03 r))
  )))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03)))))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03))))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03)))))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03))))))))))))))))
  $Snap.unit))
(assert (forall ((i1@122@03 Int)) (!
  (< i1@122@03 (alen<Int> (opt_get1 $Snap.unit p@15@03)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) i1@122@03))
  :qid |int-aux|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@124@03 r) V@12@03) (<= 0 (inv@124@03 r)))
    ($FVF.loc_int ($FVF.lookup_int (as sm@121@03  $FVF<Int>) r) r))
  :pattern ((inv@124@03 r))
  )))
(assert (forall ((r $Ref)) (!
  (implies
    (not
      (=
        (ite
          (and (< (inv@120@03 r) V@12@03) (<= 0 (inv@120@03 r)))
          $Perm.Write
          $Perm.No)
        $Perm.No))
    (ite
      (and (< (inv@120@03 r) V@12@03) (<= 0 (inv@120@03 r)))
      (<
        (ite
          (and (< (inv@124@03 r) V@12@03) (<= 0 (inv@124@03 r)))
          $k@123@03
          $Perm.No)
        $Perm.Write)
      (<
        (ite
          (and (< (inv@124@03 r) V@12@03) (<= 0 (inv@124@03 r)))
          $k@123@03
          $Perm.No)
        $Perm.No)))
  :pattern ((inv@120@03 r))
  :pattern ((inv@124@03 r))
  :qid |qp.srp36|)))
(assert (valid_graph_vertices ($Snap.combine
  $Snap.unit
  ($Snap.combine
    $Snap.unit
    ($Snap.combine
      $Snap.unit
      ($SortWrappers.$FVF<Int>To$Snap (as sm@127@03  $FVF<Int>))))) this@9@03 p@15@03 V@12@03))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03))))))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03)))))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03))))))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03)))))))))))))))))
  $Snap.unit))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03)))))))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03))))))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03)))))))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03))))))))))))))))))
  $Snap.unit))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03))))))))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03)))))))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03))))))))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03)))))))))))))))))))
  $Snap.unit))
(assert (valid_graph_vertices1 $Snap.unit this@9@03 queue@102@03 V@12@03))
(assert (forall ((i1@128@03 Int)) (!
  (< i1@128@03 (alen<Int> (opt_get1 $Snap.unit res@79@03)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@79@03) i1@128@03))
  :qid |bool-aux|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@117@03 r) V@12@03) (<= 0 (inv@117@03 r)))
        (< (inv@116@03 r) V@12@03))
      (<= 0 (inv@116@03 r)))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@109@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) (inv@116@03 r)))) (inv@117@03 r))
      r))
  :pattern ((inv@116@03 r))
  :pattern ((inv@117@03 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@117@03 r) V@12@03) (<= 0 (inv@117@03 r)))
        (< (inv@116@03 r) V@12@03))
      (<= 0 (inv@116@03 r)))
    (=
      ($FVF.lookup_int (as sm@118@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@118@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03))))))))))))))) r))
  :qid |qp.fvfValDef31|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03))))))))))))))) r) r)
  :pattern (($FVF.lookup_int (as sm@118@03  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef32|)))
(assert (forall ((i1@114@03 Int) (j1@115@03 Int)) (!
  (implies
    (and
      (and (and (< j1@115@03 V@12@03) (<= 0 j1@115@03)) (< i1@114@03 V@12@03))
      (<= 0 i1@114@03))
    (and
      (=
        (inv@116@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@109@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@114@03))) j1@115@03))
        i1@114@03)
      (=
        (inv@117@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@109@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@114@03))) j1@115@03))
        j1@115@03)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@109@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@114@03))) j1@115@03))
  )))
(assert (forall ((i1@114@03 Int) (j1@115@03 Int)) (!
  (implies
    (and
      (and (and (< j1@115@03 V@12@03) (<= 0 j1@115@03)) (< i1@114@03 V@12@03))
      (<= 0 i1@114@03))
    (not
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@109@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@114@03))) j1@115@03)
        $Ref.null)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@109@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@114@03))) j1@115@03))
  :qid |int-permImpliesNonNull|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@117@03 r) V@12@03) (<= 0 (inv@117@03 r)))
        (< (inv@116@03 r) V@12@03))
      (<= 0 (inv@116@03 r)))
    ($FVF.loc_int ($FVF.lookup_int (as sm@118@03  $FVF<Int>) r) r))
  :pattern ((inv@116@03 r) (inv@117@03 r))
  )))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03))))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03)))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03))))))))))))))))))
(assert (forall ((i1@119@03 Int)) (!
  (< i1@119@03 (alen<Int> (opt_get1 $Snap.unit p@15@03)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) i1@119@03))
  :qid |int-aux|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and (< (inv@108@03 r) V@12@03) (<= 0 (inv@108@03 r)))
      (< $Perm.No $k@107@03))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) (inv@108@03 r))
      r))
  :pattern ((inv@108@03 r))
  :qid |option$array$-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@108@03 r) V@12@03) (<= 0 (inv@108@03 r)))
      (< $Perm.No $k@107@03)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@109@03  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@105@03))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@109@03  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@105@03))))) r))
  :qid |qp.fvfValDef29|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@105@03))))) r) r)
  :pattern (($FVF.lookup_option$array$ (as sm@109@03  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef30|)))
(assert (forall ((i1@106@03 Int)) (!
  (implies
    (and (and (< i1@106@03 V@12@03) (<= 0 i1@106@03)) (< $Perm.No $k@107@03))
    (=
      (inv@108@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@106@03))
      i1@106@03))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@106@03))
  )))
(assert (forall ((i1@106@03 Int)) (!
  (<= $Perm.No $k@107@03)
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@106@03))
  :qid |option$array$-permAtLeastZero|)))
(assert (forall ((i1@106@03 Int)) (!
  (<= $k@107@03 $Perm.Write)
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@106@03))
  :qid |option$array$-permAtMostOne|)))
(assert (forall ((i1@106@03 Int)) (!
  (implies
    (and (and (< i1@106@03 V@12@03) (<= 0 i1@106@03)) (< $Perm.No $k@107@03))
    (not
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@106@03)
        $Ref.null)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@106@03))
  :qid |option$array$-permImpliesNonNull|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@108@03 r) V@12@03) (<= 0 (inv@108@03 r)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@109@03  $FVF<option<array>>) r) r))
  :pattern ((inv@108@03 r))
  )))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03)))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03)))))
  $Snap.unit))
(assert (forall ((i1@110@03 Int)) (!
  (implies
    (and (< i1@110@03 V@12@03) (<= 0 i1@110@03))
    (and
      (< i1@110@03 V@12@03)
      (<= 0 i1@110@03)
      (< i1@110@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@109@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@110@03)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@110@03))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@110@03))
  :qid |prog.l<no position>-aux|)))
(assert (forall ((i1@110@03 Int)) (!
  (implies
    (and (< i1@110@03 V@12@03) (<= 0 i1@110@03))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@109@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@110@03))
        (as None<option<array>>  option<array>))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@110@03))
  :qid |prog.l<no position>|)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03)))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03)))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03))))))
  $Snap.unit))
(assert (forall ((i1@111@03 Int)) (!
  (implies
    (and (< i1@111@03 V@12@03) (<= 0 i1@111@03))
    (and
      (< i1@111@03 V@12@03)
      (<= 0 i1@111@03)
      (< i1@111@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@109@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@111@03)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@111@03))
      (not
        (=
          ($FVF.lookup_option$array$ (as sm@109@03  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@111@03))
          (as None<option<array>>  option<array>)))))
  :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@109@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@111@03)))))
  :qid |prog.l<no position>-aux|)))
(assert (forall ((i1@111@03 Int)) (!
  (implies
    (and (< i1@111@03 V@12@03) (<= 0 i1@111@03))
    (=
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@109@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@111@03))))
      V@12@03))
  :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@109@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@111@03)))))
  :qid |prog.l<no position>|)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03)))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03)))))))
  $Snap.unit))
(assert (forall ((i1@112@03 Int)) (!
  (forall ((i2@113@03 Int)) (!
    (and
      (implies
        (<= 0 i1@112@03)
        (and
          (<= 0 i1@112@03)
          (implies
            (< i1@112@03 V@12@03)
            (and
              (< i1@112@03 V@12@03)
              (implies
                (<= 0 i2@113@03)
                (and
                  (<= 0 i2@113@03)
                  (implies
                    (< i2@113@03 V@12@03)
                    (and
                      (< i2@113@03 V@12@03)
                      (< i1@112@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))
                      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@109@03  $FVF<option<array>>) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@112@03)) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@112@03))
                      (< i2@113@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))
                      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@109@03  $FVF<option<array>>) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@113@03)) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@113@03))))))))))
      (implies
        (and
          (and
            (and
              (and
                (=
                  ($FVF.lookup_option$array$ (as sm@109@03  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@112@03))
                  ($FVF.lookup_option$array$ (as sm@109@03  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@113@03)))
                (< i2@113@03 V@12@03))
              (<= 0 i2@113@03))
            (< i1@112@03 V@12@03))
          (<= 0 i1@112@03))
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@109@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@112@03))
            ($FVF.lookup_option$array$ (as sm@109@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@113@03)))
          (< i2@113@03 V@12@03)
          (<= 0 i2@113@03)
          (< i1@112@03 V@12@03)
          (<= 0 i1@112@03))))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@113@03))
    :qid |prog.l<no position>-aux|))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@112@03))
  :qid |prog.l<no position>-aux|)))
(assert (forall ((i1@112@03 Int)) (!
  (forall ((i2@113@03 Int)) (!
    (implies
      (and
        (and
          (and
            (and
              (=
                ($FVF.lookup_option$array$ (as sm@109@03  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@112@03))
                ($FVF.lookup_option$array$ (as sm@109@03  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@113@03)))
              (< i2@113@03 V@12@03))
            (<= 0 i2@113@03))
          (< i1@112@03 V@12@03))
        (<= 0 i1@112@03))
      (= i1@112@03 i2@113@03))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@113@03))
    :qid |prog.l<no position>|))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@112@03))
  :qid |prog.l<no position>|)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03)))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03)))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03))))))))
  $Snap.unit))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03)))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03)))))))))
  $Snap.unit))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03)))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03)))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03))))))))))
  $Snap.unit))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03)))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03)))))))))))
  $Snap.unit))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03)))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03)))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03))))))))))))
  $Snap.unit))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03)))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03)))))))))))))
  $Snap.unit))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03)))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03)))))))))))))))))
(assert (forall ((i1@114@03 Int) (j1@115@03 Int)) (!
  (and
    (< i1@114@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@109@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@114@03)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@114@03))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@109@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@114@03))
        (as None<option<array>>  option<array>)))
    (<
      j1@115@03
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@109@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@114@03))))))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@109@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@114@03))) j1@115@03))
  :qid |int-aux|)))
(assert ($Perm.isReadVar $k@107@03 $Perm.Write))
(assert (= $t@105@03 ($Snap.combine ($Snap.first $t@105@03) ($Snap.second $t@105@03))))
(assert (= ($Snap.first $t@105@03) $Snap.unit))
(assert (=
  ($Snap.second $t@105@03)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@105@03))
    ($Snap.second ($Snap.second $t@105@03)))))
(assert (= ($Snap.first ($Snap.second $t@105@03)) $Snap.unit))
(assert (=
  ($Snap.second ($Snap.second $t@105@03))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second $t@105@03)))
    ($Snap.second ($Snap.second ($Snap.second $t@105@03))))))
(assert (= ($Snap.first ($Snap.second ($Snap.second $t@105@03))) $Snap.unit))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second $t@105@03)))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@105@03))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03)))))))
(assert (forall ((i1@106@03 Int)) (!
  (< i1@106@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@106@03))
  :qid |option$array$-aux|)))
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
(set-option :timeout 10)
(check-sat)
; unknown
; Loop head block: Follow loop-internal edges
; [eval] !(|queue| == 0)
; [eval] |queue| == 0
; [eval] |queue|
(push) ; 9
(assert (not (= (Seq_length queue@102@03) 0)))
(check-sat)
; unknown
(pop) ; 9
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               13419
;  :arith-add-rows          5089
;  :arith-assert-diseq      486
;  :arith-assert-lower      3221
;  :arith-assert-upper      2192
;  :arith-bound-prop        837
;  :arith-conflicts         161
;  :arith-eq-adapter        2047
;  :arith-fixed-eqs         1329
;  :arith-offset-eqs        985
;  :arith-pivots            1986
;  :conflicts               388
;  :datatype-accessor-ax    117
;  :datatype-constructor-ax 377
;  :datatype-occurs-check   234
;  :datatype-splits         139
;  :decisions               1864
;  :del-clause              21482
;  :final-checks            122
;  :interface-eqs           13
;  :max-generation          9
;  :max-memory              8.79
;  :memory                  8.43
;  :minimized-lits          61
;  :mk-bool-var             27706
;  :mk-clause               22360
;  :num-allocs              357315
;  :num-checks              175
;  :propagations            6535
;  :quant-instantiations    7730
;  :rlimit-count            722448
;  :time                    0.01)
(push) ; 9
(assert (not (not (= (Seq_length queue@102@03) 0))))
(check-sat)
; unknown
(pop) ; 9
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               14589
;  :arith-add-rows          6326
;  :arith-assert-diseq      505
;  :arith-assert-lower      3545
;  :arith-assert-upper      2422
;  :arith-bound-prop        889
;  :arith-conflicts         173
;  :arith-eq-adapter        2234
;  :arith-fixed-eqs         1508
;  :arith-offset-eqs        1146
;  :arith-pivots            2066
;  :conflicts               400
;  :datatype-accessor-ax    117
;  :datatype-constructor-ax 381
;  :datatype-occurs-check   234
;  :datatype-splits         139
;  :decisions               2094
;  :del-clause              24212
;  :final-checks            122
;  :interface-eqs           13
;  :max-generation          9
;  :max-memory              8.79
;  :memory                  8.55
;  :minimized-lits          61
;  :mk-bool-var             30153
;  :mk-clause               25090
;  :num-allocs              363712
;  :num-checks              176
;  :propagations            7261
;  :quant-instantiations    8462
;  :rlimit-count            768432
;  :time                    0.01)
; [then-branch: 100 | |queue@102@03| != 0 | live]
; [else-branch: 100 | |queue@102@03| == 0 | live]
(push) ; 9
; [then-branch: 100 | |queue@102@03| != 0]
(assert (not (= (Seq_length queue@102@03) 0)))
; [exec]
; u := queue[0]
; [eval] queue[0]
(set-option :timeout 0)
(push) ; 10
(assert (not (< 0 (Seq_length queue@102@03))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               14589
;  :arith-add-rows          6326
;  :arith-assert-diseq      506
;  :arith-assert-lower      3547
;  :arith-assert-upper      2422
;  :arith-bound-prop        889
;  :arith-conflicts         173
;  :arith-eq-adapter        2235
;  :arith-fixed-eqs         1508
;  :arith-offset-eqs        1146
;  :arith-pivots            2066
;  :conflicts               401
;  :datatype-accessor-ax    117
;  :datatype-constructor-ax 381
;  :datatype-occurs-check   234
;  :datatype-splits         139
;  :decisions               2094
;  :del-clause              24212
;  :final-checks            122
;  :interface-eqs           13
;  :max-generation          9
;  :max-memory              8.79
;  :memory                  8.55
;  :minimized-lits          61
;  :mk-bool-var             30156
;  :mk-clause               25094
;  :num-allocs              363854
;  :num-checks              177
;  :propagations            7262
;  :quant-instantiations    8463
;  :rlimit-count            768571)
(declare-const u@161@03 Int)
(assert (= u@161@03 (Seq_index queue@102@03 0)))
; [exec]
; evaluationDummy1 := queue[..0] ++ queue[0 + 1..]
; [eval] queue[..0] ++ queue[0 + 1..]
; [eval] queue[..0]
; [eval] queue[0 + 1..]
; [eval] 0 + 1
(declare-const evaluationDummy1@162@03 Seq<Int>)
(assert (Seq_equal
  evaluationDummy1@162@03
  (Seq_append (Seq_take queue@102@03 0) (Seq_drop queue@102@03 1))))
; [exec]
; k := 0
; [exec]
; label loop1
; [exec]
; excBeforeLoop1 := exc
; [exec]
; v := 0
(declare-const k@163@03 Int)
(declare-const queue@164@03 Seq<Int>)
(declare-const flatten@165@03 Int)
(declare-const v@166@03 Int)
(declare-const evaluationDummy2@167@03 Int)
(push) ; 10
; Loop head block: Check well-definedness of invariant
(declare-const $t@168@03 $Snap)
(assert (= $t@168@03 ($Snap.combine ($Snap.first $t@168@03) ($Snap.second $t@168@03))))
(assert (= ($Snap.first $t@168@03) $Snap.unit))
; [eval] exc == excBeforeLoop1
(assert (=
  ($Snap.second $t@168@03)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@168@03))
    ($Snap.second ($Snap.second $t@168@03)))))
(assert (= ($Snap.first ($Snap.second $t@168@03)) $Snap.unit))
; [eval] Gf != (None(): option[array])
; [eval] (None(): option[array])
(assert (=
  ($Snap.second ($Snap.second $t@168@03))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second $t@168@03)))
    ($Snap.second ($Snap.second ($Snap.second $t@168@03))))))
(assert (= ($Snap.first ($Snap.second ($Snap.second $t@168@03))) $Snap.unit))
; [eval] alen(opt_get1(Gf)) == V
; [eval] alen(opt_get1(Gf))
; [eval] opt_get1(Gf)
(push) ; 11
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 11
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second ($Snap.second $t@168@03)))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@168@03))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03)))))))
(declare-const i1@169@03 Int)
(push) ; 11
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 12
; [then-branch: 101 | 0 <= i1@169@03 | live]
; [else-branch: 101 | !(0 <= i1@169@03) | live]
(push) ; 13
; [then-branch: 101 | 0 <= i1@169@03]
(assert (<= 0 i1@169@03))
; [eval] i1 < V
(pop) ; 13
(push) ; 13
; [else-branch: 101 | !(0 <= i1@169@03)]
(assert (not (<= 0 i1@169@03)))
(pop) ; 13
(pop) ; 12
; Joined path conditions
; Joined path conditions
(assert (and (< i1@169@03 V@12@03) (<= 0 i1@169@03)))
; [eval] aloc(opt_get1(Gf), i1)
; [eval] opt_get1(Gf)
(push) ; 12
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 12
; Joined path conditions
(push) ; 12
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 13
(assert (not (< i1@169@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))))
(check-sat)
; unsat
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               14629
;  :arith-add-rows          6332
;  :arith-assert-diseq      507
;  :arith-assert-lower      3557
;  :arith-assert-upper      2425
;  :arith-bound-prop        890
;  :arith-conflicts         173
;  :arith-eq-adapter        2240
;  :arith-fixed-eqs         1510
;  :arith-offset-eqs        1146
;  :arith-pivots            2069
;  :conflicts               401
;  :datatype-accessor-ax    121
;  :datatype-constructor-ax 381
;  :datatype-occurs-check   234
;  :datatype-splits         139
;  :decisions               2094
;  :del-clause              24212
;  :final-checks            122
;  :interface-eqs           13
;  :max-generation          9
;  :max-memory              8.79
;  :memory                  8.57
;  :minimized-lits          61
;  :mk-bool-var             30202
;  :mk-clause               25124
;  :num-allocs              364536
;  :num-checks              178
;  :propagations            7271
;  :quant-instantiations    8473
;  :rlimit-count            770079)
(assert (< i1@169@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03))))
(pop) ; 12
; Joined path conditions
(assert (< i1@169@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03))))
(declare-const $k@170@03 $Perm)
(assert ($Perm.isReadVar $k@170@03 $Perm.Write))
(pop) ; 11
(declare-fun inv@171@03 ($Ref) Int)
; Nested auxiliary terms: globals
(assert ($Perm.isReadVar $k@170@03 $Perm.Write))
; Nested auxiliary terms: non-globals
(assert (forall ((i1@169@03 Int)) (!
  (< i1@169@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@169@03))
  :qid |option$array$-aux|)))
(push) ; 11
(assert (not (forall ((i1@169@03 Int)) (!
  (implies
    (and (< i1@169@03 V@12@03) (<= 0 i1@169@03))
    (or (= $k@170@03 $Perm.No) (< $Perm.No $k@170@03)))
  
  ))))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               14629
;  :arith-add-rows          6333
;  :arith-assert-diseq      508
;  :arith-assert-lower      3559
;  :arith-assert-upper      2426
;  :arith-bound-prop        890
;  :arith-conflicts         173
;  :arith-eq-adapter        2241
;  :arith-fixed-eqs         1510
;  :arith-offset-eqs        1146
;  :arith-pivots            2069
;  :conflicts               402
;  :datatype-accessor-ax    121
;  :datatype-constructor-ax 381
;  :datatype-occurs-check   234
;  :datatype-splits         139
;  :decisions               2094
;  :del-clause              24212
;  :final-checks            122
;  :interface-eqs           13
;  :max-generation          9
;  :max-memory              8.79
;  :memory                  8.58
;  :minimized-lits          61
;  :mk-bool-var             30209
;  :mk-clause               25126
;  :num-allocs              365000
;  :num-checks              179
;  :propagations            7272
;  :quant-instantiations    8473
;  :rlimit-count            770650)
; Check receiver injectivity
(push) ; 11
(assert (not (forall ((i11@169@03 Int) (i12@169@03 Int)) (!
  (implies
    (and
      (and (and (< i11@169@03 V@12@03) (<= 0 i11@169@03)) (< $Perm.No $k@170@03))
      (and (and (< i12@169@03 V@12@03) (<= 0 i12@169@03)) (< $Perm.No $k@170@03))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i11@169@03)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i12@169@03)))
    (= i11@169@03 i12@169@03))
  
  :qid |option$array$-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               14641
;  :arith-add-rows          6337
;  :arith-assert-diseq      509
;  :arith-assert-lower      3563
;  :arith-assert-upper      2426
;  :arith-bound-prop        890
;  :arith-conflicts         173
;  :arith-eq-adapter        2242
;  :arith-fixed-eqs         1510
;  :arith-offset-eqs        1146
;  :arith-pivots            2069
;  :conflicts               403
;  :datatype-accessor-ax    121
;  :datatype-constructor-ax 381
;  :datatype-occurs-check   234
;  :datatype-splits         139
;  :decisions               2094
;  :del-clause              24218
;  :final-checks            122
;  :interface-eqs           13
;  :max-generation          9
;  :max-memory              8.79
;  :memory                  8.56
;  :minimized-lits          61
;  :mk-bool-var             30231
;  :mk-clause               25132
;  :num-allocs              365392
;  :num-checks              180
;  :propagations            7272
;  :quant-instantiations    8492
;  :rlimit-count            771500)
; Definitional axioms for inverse functions
(assert (forall ((i1@169@03 Int)) (!
  (implies
    (and (and (< i1@169@03 V@12@03) (<= 0 i1@169@03)) (< $Perm.No $k@170@03))
    (=
      (inv@171@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@169@03))
      i1@169@03))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@169@03))
  )))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and (< (inv@171@03 r) V@12@03) (<= 0 (inv@171@03 r)))
      (< $Perm.No $k@170@03))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) (inv@171@03 r))
      r))
  :pattern ((inv@171@03 r))
  :qid |option$array$-fctOfInv|)))
; Permissions are non-negative
(assert (forall ((i1@169@03 Int)) (!
  (<= $Perm.No $k@170@03)
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@169@03))
  :qid |option$array$-permAtLeastZero|)))
; Field permissions are at most one
(assert (forall ((i1@169@03 Int)) (!
  (<= $k@170@03 $Perm.Write)
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@169@03))
  :qid |option$array$-permAtMostOne|)))
; Permission implies non-null receiver
(assert (forall ((i1@169@03 Int)) (!
  (implies
    (and (and (< i1@169@03 V@12@03) (<= 0 i1@169@03)) (< $Perm.No $k@170@03))
    (not
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@169@03)
        $Ref.null)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@169@03))
  :qid |option$array$-permImpliesNonNull|)))
(declare-const sm@172@03 $FVF<option<array>>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@171@03 r) V@12@03) (<= 0 (inv@171@03 r)))
      (< $Perm.No $k@170@03)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@168@03))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@168@03))))) r))
  :qid |qp.fvfValDef59|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@168@03))))) r) r)
  :pattern (($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef60|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@171@03 r) V@12@03) (<= 0 (inv@171@03 r)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) r) r))
  :pattern ((inv@171@03 r))
  )))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03)))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03)))))
  $Snap.unit))
; [eval] (forall i1: Int :: { aloc(opt_get1(Gf), i1) } 0 <= i1 && i1 < V ==> aloc(opt_get1(Gf), i1).option$array$ != (None(): option[array]))
(declare-const i1@173@03 Int)
(push) ; 11
; [eval] 0 <= i1 && i1 < V ==> aloc(opt_get1(Gf), i1).option$array$ != (None(): option[array])
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 12
; [then-branch: 102 | 0 <= i1@173@03 | live]
; [else-branch: 102 | !(0 <= i1@173@03) | live]
(push) ; 13
; [then-branch: 102 | 0 <= i1@173@03]
(assert (<= 0 i1@173@03))
; [eval] i1 < V
(pop) ; 13
(push) ; 13
; [else-branch: 102 | !(0 <= i1@173@03)]
(assert (not (<= 0 i1@173@03)))
(pop) ; 13
(pop) ; 12
; Joined path conditions
; Joined path conditions
(push) ; 12
; [then-branch: 103 | i1@173@03 < V@12@03 && 0 <= i1@173@03 | live]
; [else-branch: 103 | !(i1@173@03 < V@12@03 && 0 <= i1@173@03) | live]
(push) ; 13
; [then-branch: 103 | i1@173@03 < V@12@03 && 0 <= i1@173@03]
(assert (and (< i1@173@03 V@12@03) (<= 0 i1@173@03)))
; [eval] aloc(opt_get1(Gf), i1).option$array$ != (None(): option[array])
; [eval] aloc(opt_get1(Gf), i1)
; [eval] opt_get1(Gf)
(push) ; 14
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 14
; Joined path conditions
(push) ; 14
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 15
(assert (not (< i1@173@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))))
(check-sat)
; unsat
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               14647
;  :arith-add-rows          6338
;  :arith-assert-diseq      509
;  :arith-assert-lower      3565
;  :arith-assert-upper      2427
;  :arith-bound-prop        890
;  :arith-conflicts         173
;  :arith-eq-adapter        2242
;  :arith-fixed-eqs         1510
;  :arith-offset-eqs        1146
;  :arith-pivots            2069
;  :conflicts               403
;  :datatype-accessor-ax    122
;  :datatype-constructor-ax 381
;  :datatype-occurs-check   234
;  :datatype-splits         139
;  :decisions               2094
;  :del-clause              24218
;  :final-checks            122
;  :interface-eqs           13
;  :max-generation          9
;  :max-memory              8.79
;  :memory                  8.56
;  :minimized-lits          61
;  :mk-bool-var             30242
;  :mk-clause               25132
;  :num-allocs              366582
;  :num-checks              181
;  :propagations            7272
;  :quant-instantiations    8492
;  :rlimit-count            773838)
(assert (< i1@173@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03))))
(pop) ; 14
; Joined path conditions
(assert (< i1@173@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@173@03)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@173@03)))
(push) ; 14
(assert (not (ite
  (and
    (<
      (inv@171@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@173@03))
      V@12@03)
    (<=
      0
      (inv@171@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@173@03))))
  (< $Perm.No $k@170@03)
  false)))
(check-sat)
; unsat
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               14673
;  :arith-add-rows          6356
;  :arith-assert-diseq      509
;  :arith-assert-lower      3569
;  :arith-assert-upper      2432
;  :arith-bound-prop        894
;  :arith-conflicts         174
;  :arith-eq-adapter        2246
;  :arith-fixed-eqs         1514
;  :arith-offset-eqs        1146
;  :arith-pivots            2074
;  :conflicts               404
;  :datatype-accessor-ax    122
;  :datatype-constructor-ax 381
;  :datatype-occurs-check   234
;  :datatype-splits         139
;  :decisions               2094
;  :del-clause              24218
;  :final-checks            122
;  :interface-eqs           13
;  :max-generation          9
;  :max-memory              8.79
;  :memory                  8.57
;  :minimized-lits          61
;  :mk-bool-var             30350
;  :mk-clause               25190
;  :num-allocs              367329
;  :num-checks              182
;  :propagations            7274
;  :quant-instantiations    8539
;  :rlimit-count            776625)
; [eval] (None(): option[array])
(pop) ; 13
(push) ; 13
; [else-branch: 103 | !(i1@173@03 < V@12@03 && 0 <= i1@173@03)]
(assert (not (and (< i1@173@03 V@12@03) (<= 0 i1@173@03))))
(pop) ; 13
(pop) ; 12
; Joined path conditions
(assert (implies
  (and (< i1@173@03 V@12@03) (<= 0 i1@173@03))
  (and
    (< i1@173@03 V@12@03)
    (<= 0 i1@173@03)
    (< i1@173@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@173@03)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@173@03)))))
; Joined path conditions
(pop) ; 11
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@173@03 Int)) (!
  (implies
    (and (< i1@173@03 V@12@03) (<= 0 i1@173@03))
    (and
      (< i1@173@03 V@12@03)
      (<= 0 i1@173@03)
      (< i1@173@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@173@03)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@173@03))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@173@03))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(assert (forall ((i1@173@03 Int)) (!
  (implies
    (and (< i1@173@03 V@12@03) (<= 0 i1@173@03))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@173@03))
        (as None<option<array>>  option<array>))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@173@03))
  :qid |prog.l<no position>|)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03)))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03)))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03))))))
  $Snap.unit))
; [eval] (forall i1: Int :: { alen(opt_get1(aloc(opt_get1(Gf), i1).option$array$)) } 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(Gf), i1).option$array$)) == V)
(declare-const i1@174@03 Int)
(push) ; 11
; [eval] 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(Gf), i1).option$array$)) == V
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 12
; [then-branch: 104 | 0 <= i1@174@03 | live]
; [else-branch: 104 | !(0 <= i1@174@03) | live]
(push) ; 13
; [then-branch: 104 | 0 <= i1@174@03]
(assert (<= 0 i1@174@03))
; [eval] i1 < V
(pop) ; 13
(push) ; 13
; [else-branch: 104 | !(0 <= i1@174@03)]
(assert (not (<= 0 i1@174@03)))
(pop) ; 13
(pop) ; 12
; Joined path conditions
; Joined path conditions
(push) ; 12
; [then-branch: 105 | i1@174@03 < V@12@03 && 0 <= i1@174@03 | live]
; [else-branch: 105 | !(i1@174@03 < V@12@03 && 0 <= i1@174@03) | live]
(push) ; 13
; [then-branch: 105 | i1@174@03 < V@12@03 && 0 <= i1@174@03]
(assert (and (< i1@174@03 V@12@03) (<= 0 i1@174@03)))
; [eval] alen(opt_get1(aloc(opt_get1(Gf), i1).option$array$)) == V
; [eval] alen(opt_get1(aloc(opt_get1(Gf), i1).option$array$))
; [eval] opt_get1(aloc(opt_get1(Gf), i1).option$array$)
; [eval] aloc(opt_get1(Gf), i1)
; [eval] opt_get1(Gf)
(push) ; 14
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 14
; Joined path conditions
(push) ; 14
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 15
(assert (not (< i1@174@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))))
(check-sat)
; unsat
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               14679
;  :arith-add-rows          6362
;  :arith-assert-diseq      509
;  :arith-assert-lower      3571
;  :arith-assert-upper      2432
;  :arith-bound-prop        894
;  :arith-conflicts         174
;  :arith-eq-adapter        2246
;  :arith-fixed-eqs         1514
;  :arith-offset-eqs        1146
;  :arith-pivots            2079
;  :conflicts               404
;  :datatype-accessor-ax    123
;  :datatype-constructor-ax 381
;  :datatype-occurs-check   234
;  :datatype-splits         139
;  :decisions               2094
;  :del-clause              24276
;  :final-checks            122
;  :interface-eqs           13
;  :max-generation          9
;  :max-memory              8.79
;  :memory                  8.56
;  :minimized-lits          61
;  :mk-bool-var             30356
;  :mk-clause               25190
;  :num-allocs              367862
;  :num-checks              183
;  :propagations            7274
;  :quant-instantiations    8539
;  :rlimit-count            777855)
(assert (< i1@174@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03))))
(pop) ; 14
; Joined path conditions
(assert (< i1@174@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@174@03)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@174@03)))
(push) ; 14
(assert (not (ite
  (and
    (<
      (inv@171@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@174@03))
      V@12@03)
    (<=
      0
      (inv@171@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@174@03))))
  (< $Perm.No $k@170@03)
  false)))
(check-sat)
; unsat
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               14705
;  :arith-add-rows          6380
;  :arith-assert-diseq      509
;  :arith-assert-lower      3575
;  :arith-assert-upper      2437
;  :arith-bound-prop        898
;  :arith-conflicts         175
;  :arith-eq-adapter        2250
;  :arith-fixed-eqs         1518
;  :arith-offset-eqs        1146
;  :arith-pivots            2084
;  :conflicts               405
;  :datatype-accessor-ax    123
;  :datatype-constructor-ax 381
;  :datatype-occurs-check   234
;  :datatype-splits         139
;  :decisions               2094
;  :del-clause              24276
;  :final-checks            122
;  :interface-eqs           13
;  :max-generation          9
;  :max-memory              8.79
;  :memory                  8.57
;  :minimized-lits          61
;  :mk-bool-var             30466
;  :mk-clause               25248
;  :num-allocs              368597
;  :num-checks              184
;  :propagations            7276
;  :quant-instantiations    8588
;  :rlimit-count            780651)
(push) ; 14
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 15
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@174@03))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               14705
;  :arith-add-rows          6380
;  :arith-assert-diseq      509
;  :arith-assert-lower      3575
;  :arith-assert-upper      2437
;  :arith-bound-prop        898
;  :arith-conflicts         175
;  :arith-eq-adapter        2250
;  :arith-fixed-eqs         1518
;  :arith-offset-eqs        1146
;  :arith-pivots            2084
;  :conflicts               406
;  :datatype-accessor-ax    123
;  :datatype-constructor-ax 381
;  :datatype-occurs-check   234
;  :datatype-splits         139
;  :decisions               2094
;  :del-clause              24276
;  :final-checks            122
;  :interface-eqs           13
;  :max-generation          9
;  :max-memory              8.79
;  :memory                  8.57
;  :minimized-lits          61
;  :mk-bool-var             30466
;  :mk-clause               25248
;  :num-allocs              368686
;  :num-checks              185
;  :propagations            7276
;  :quant-instantiations    8588
;  :rlimit-count            780746)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@174@03))
    (as None<option<array>>  option<array>))))
(pop) ; 14
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@174@03))
    (as None<option<array>>  option<array>))))
(pop) ; 13
(push) ; 13
; [else-branch: 105 | !(i1@174@03 < V@12@03 && 0 <= i1@174@03)]
(assert (not (and (< i1@174@03 V@12@03) (<= 0 i1@174@03))))
(pop) ; 13
(pop) ; 12
; Joined path conditions
(assert (implies
  (and (< i1@174@03 V@12@03) (<= 0 i1@174@03))
  (and
    (< i1@174@03 V@12@03)
    (<= 0 i1@174@03)
    (< i1@174@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@174@03)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@174@03))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@174@03))
        (as None<option<array>>  option<array>))))))
; Joined path conditions
(pop) ; 11
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@174@03 Int)) (!
  (implies
    (and (< i1@174@03 V@12@03) (<= 0 i1@174@03))
    (and
      (< i1@174@03 V@12@03)
      (<= 0 i1@174@03)
      (< i1@174@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@174@03)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@174@03))
      (not
        (=
          ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@174@03))
          (as None<option<array>>  option<array>)))))
  :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@174@03)))))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(assert (forall ((i1@174@03 Int)) (!
  (implies
    (and (< i1@174@03 V@12@03) (<= 0 i1@174@03))
    (=
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@174@03))))
      V@12@03))
  :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@174@03)))))
  :qid |prog.l<no position>|)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03)))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03)))))))
  $Snap.unit))
; [eval] (forall i1: Int :: { aloc(opt_get1(Gf), i1) } (forall i2: Int :: { aloc(opt_get1(Gf), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(Gf), i1).option$array$ == aloc(opt_get1(Gf), i2).option$array$ ==> i1 == i2))
(declare-const i1@175@03 Int)
(push) ; 11
; [eval] (forall i2: Int :: { aloc(opt_get1(Gf), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(Gf), i1).option$array$ == aloc(opt_get1(Gf), i2).option$array$ ==> i1 == i2)
(declare-const i2@176@03 Int)
(push) ; 12
; [eval] 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(Gf), i1).option$array$ == aloc(opt_get1(Gf), i2).option$array$ ==> i1 == i2
; [eval] 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(Gf), i1).option$array$ == aloc(opt_get1(Gf), i2).option$array$
; [eval] 0 <= i1
(push) ; 13
; [then-branch: 106 | 0 <= i1@175@03 | live]
; [else-branch: 106 | !(0 <= i1@175@03) | live]
(push) ; 14
; [then-branch: 106 | 0 <= i1@175@03]
(assert (<= 0 i1@175@03))
; [eval] i1 < V
(push) ; 15
; [then-branch: 107 | i1@175@03 < V@12@03 | live]
; [else-branch: 107 | !(i1@175@03 < V@12@03) | live]
(push) ; 16
; [then-branch: 107 | i1@175@03 < V@12@03]
(assert (< i1@175@03 V@12@03))
; [eval] 0 <= i2
(push) ; 17
; [then-branch: 108 | 0 <= i2@176@03 | live]
; [else-branch: 108 | !(0 <= i2@176@03) | live]
(push) ; 18
; [then-branch: 108 | 0 <= i2@176@03]
(assert (<= 0 i2@176@03))
; [eval] i2 < V
(push) ; 19
; [then-branch: 109 | i2@176@03 < V@12@03 | live]
; [else-branch: 109 | !(i2@176@03 < V@12@03) | live]
(push) ; 20
; [then-branch: 109 | i2@176@03 < V@12@03]
(assert (< i2@176@03 V@12@03))
; [eval] aloc(opt_get1(Gf), i1).option$array$ == aloc(opt_get1(Gf), i2).option$array$
; [eval] aloc(opt_get1(Gf), i1)
; [eval] opt_get1(Gf)
(push) ; 21
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 21
; Joined path conditions
(push) ; 21
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 22
(assert (not (< i1@175@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))))
(check-sat)
; unsat
(pop) ; 22
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               14711
;  :arith-add-rows          6387
;  :arith-assert-diseq      509
;  :arith-assert-lower      3579
;  :arith-assert-upper      2437
;  :arith-bound-prop        898
;  :arith-conflicts         175
;  :arith-eq-adapter        2250
;  :arith-fixed-eqs         1518
;  :arith-offset-eqs        1146
;  :arith-pivots            2089
;  :conflicts               406
;  :datatype-accessor-ax    124
;  :datatype-constructor-ax 381
;  :datatype-occurs-check   234
;  :datatype-splits         139
;  :decisions               2094
;  :del-clause              24334
;  :final-checks            122
;  :interface-eqs           13
;  :max-generation          9
;  :max-memory              8.79
;  :memory                  8.56
;  :minimized-lits          61
;  :mk-bool-var             30474
;  :mk-clause               25248
;  :num-allocs              369420
;  :num-checks              186
;  :propagations            7276
;  :quant-instantiations    8588
;  :rlimit-count            782215)
(assert (< i1@175@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03))))
(pop) ; 21
; Joined path conditions
(assert (< i1@175@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@175@03)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@175@03)))
(push) ; 21
(assert (not (ite
  (and
    (<
      (inv@171@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@175@03))
      V@12@03)
    (<=
      0
      (inv@171@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@175@03))))
  (< $Perm.No $k@170@03)
  false)))
(check-sat)
; unsat
(pop) ; 21
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               14737
;  :arith-add-rows          6405
;  :arith-assert-diseq      509
;  :arith-assert-lower      3583
;  :arith-assert-upper      2442
;  :arith-bound-prop        902
;  :arith-conflicts         176
;  :arith-eq-adapter        2254
;  :arith-fixed-eqs         1522
;  :arith-offset-eqs        1146
;  :arith-pivots            2094
;  :conflicts               407
;  :datatype-accessor-ax    124
;  :datatype-constructor-ax 381
;  :datatype-occurs-check   234
;  :datatype-splits         139
;  :decisions               2094
;  :del-clause              24334
;  :final-checks            122
;  :interface-eqs           13
;  :max-generation          9
;  :max-memory              8.79
;  :memory                  8.57
;  :minimized-lits          61
;  :mk-bool-var             30584
;  :mk-clause               25306
;  :num-allocs              370151
;  :num-checks              187
;  :propagations            7278
;  :quant-instantiations    8637
;  :rlimit-count            785011)
; [eval] aloc(opt_get1(Gf), i2)
; [eval] opt_get1(Gf)
(push) ; 21
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 21
; Joined path conditions
(push) ; 21
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 22
(assert (not (< i2@176@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))))
(check-sat)
; unsat
(pop) ; 22
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               14737
;  :arith-add-rows          6405
;  :arith-assert-diseq      509
;  :arith-assert-lower      3583
;  :arith-assert-upper      2442
;  :arith-bound-prop        902
;  :arith-conflicts         176
;  :arith-eq-adapter        2254
;  :arith-fixed-eqs         1522
;  :arith-offset-eqs        1146
;  :arith-pivots            2094
;  :conflicts               407
;  :datatype-accessor-ax    124
;  :datatype-constructor-ax 381
;  :datatype-occurs-check   234
;  :datatype-splits         139
;  :decisions               2094
;  :del-clause              24334
;  :final-checks            122
;  :interface-eqs           13
;  :max-generation          9
;  :max-memory              8.79
;  :memory                  8.57
;  :minimized-lits          61
;  :mk-bool-var             30584
;  :mk-clause               25306
;  :num-allocs              370177
;  :num-checks              188
;  :propagations            7278
;  :quant-instantiations    8637
;  :rlimit-count            785041)
(assert (< i2@176@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03))))
(pop) ; 21
; Joined path conditions
(assert (< i2@176@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@176@03)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@176@03)))
(push) ; 21
(assert (not (ite
  (and
    (<
      (inv@171@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@176@03))
      V@12@03)
    (<=
      0
      (inv@171@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@176@03))))
  (< $Perm.No $k@170@03)
  false)))
(check-sat)
; unsat
(pop) ; 21
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               14761
;  :arith-add-rows          6425
;  :arith-assert-diseq      509
;  :arith-assert-lower      3587
;  :arith-assert-upper      2447
;  :arith-bound-prop        906
;  :arith-conflicts         177
;  :arith-eq-adapter        2259
;  :arith-fixed-eqs         1526
;  :arith-offset-eqs        1146
;  :arith-pivots            2099
;  :conflicts               408
;  :datatype-accessor-ax    124
;  :datatype-constructor-ax 381
;  :datatype-occurs-check   234
;  :datatype-splits         139
;  :decisions               2094
;  :del-clause              24334
;  :final-checks            122
;  :interface-eqs           13
;  :max-generation          9
;  :max-memory              8.79
;  :memory                  8.57
;  :minimized-lits          61
;  :mk-bool-var             30697
;  :mk-clause               25378
;  :num-allocs              370923
;  :num-checks              189
;  :propagations            7292
;  :quant-instantiations    8689
;  :rlimit-count            788171)
(pop) ; 20
(push) ; 20
; [else-branch: 109 | !(i2@176@03 < V@12@03)]
(assert (not (< i2@176@03 V@12@03)))
(pop) ; 20
(pop) ; 19
; Joined path conditions
(assert (implies
  (< i2@176@03 V@12@03)
  (and
    (< i2@176@03 V@12@03)
    (< i1@175@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@175@03)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@175@03))
    (< i2@176@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@176@03)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@176@03)))))
; Joined path conditions
(pop) ; 18
(push) ; 18
; [else-branch: 108 | !(0 <= i2@176@03)]
(assert (not (<= 0 i2@176@03)))
(pop) ; 18
(pop) ; 17
; Joined path conditions
(assert (implies
  (<= 0 i2@176@03)
  (and
    (<= 0 i2@176@03)
    (implies
      (< i2@176@03 V@12@03)
      (and
        (< i2@176@03 V@12@03)
        (< i1@175@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@175@03)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@175@03))
        (< i2@176@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@176@03)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@176@03)))))))
; Joined path conditions
(pop) ; 16
(push) ; 16
; [else-branch: 107 | !(i1@175@03 < V@12@03)]
(assert (not (< i1@175@03 V@12@03)))
(pop) ; 16
(pop) ; 15
; Joined path conditions
(assert (implies
  (< i1@175@03 V@12@03)
  (and
    (< i1@175@03 V@12@03)
    (implies
      (<= 0 i2@176@03)
      (and
        (<= 0 i2@176@03)
        (implies
          (< i2@176@03 V@12@03)
          (and
            (< i2@176@03 V@12@03)
            (< i1@175@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@175@03)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@175@03))
            (< i2@176@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@176@03)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@176@03)))))))))
; Joined path conditions
(pop) ; 14
(push) ; 14
; [else-branch: 106 | !(0 <= i1@175@03)]
(assert (not (<= 0 i1@175@03)))
(pop) ; 14
(pop) ; 13
; Joined path conditions
(assert (implies
  (<= 0 i1@175@03)
  (and
    (<= 0 i1@175@03)
    (implies
      (< i1@175@03 V@12@03)
      (and
        (< i1@175@03 V@12@03)
        (implies
          (<= 0 i2@176@03)
          (and
            (<= 0 i2@176@03)
            (implies
              (< i2@176@03 V@12@03)
              (and
                (< i2@176@03 V@12@03)
                (< i1@175@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@175@03)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@175@03))
                (< i2@176@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@176@03)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@176@03)))))))))))
; Joined path conditions
(push) ; 13
; [then-branch: 110 | Lookup(option$array$,sm@172@03,aloc((_, _), opt_get1(_, Gf@11@03), i1@175@03)) == Lookup(option$array$,sm@172@03,aloc((_, _), opt_get1(_, Gf@11@03), i2@176@03)) && i2@176@03 < V@12@03 && 0 <= i2@176@03 && i1@175@03 < V@12@03 && 0 <= i1@175@03 | live]
; [else-branch: 110 | !(Lookup(option$array$,sm@172@03,aloc((_, _), opt_get1(_, Gf@11@03), i1@175@03)) == Lookup(option$array$,sm@172@03,aloc((_, _), opt_get1(_, Gf@11@03), i2@176@03)) && i2@176@03 < V@12@03 && 0 <= i2@176@03 && i1@175@03 < V@12@03 && 0 <= i1@175@03) | live]
(push) ; 14
; [then-branch: 110 | Lookup(option$array$,sm@172@03,aloc((_, _), opt_get1(_, Gf@11@03), i1@175@03)) == Lookup(option$array$,sm@172@03,aloc((_, _), opt_get1(_, Gf@11@03), i2@176@03)) && i2@176@03 < V@12@03 && 0 <= i2@176@03 && i1@175@03 < V@12@03 && 0 <= i1@175@03]
(assert (and
  (and
    (and
      (and
        (=
          ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@175@03))
          ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@176@03)))
        (< i2@176@03 V@12@03))
      (<= 0 i2@176@03))
    (< i1@175@03 V@12@03))
  (<= 0 i1@175@03)))
; [eval] i1 == i2
(pop) ; 14
(push) ; 14
; [else-branch: 110 | !(Lookup(option$array$,sm@172@03,aloc((_, _), opt_get1(_, Gf@11@03), i1@175@03)) == Lookup(option$array$,sm@172@03,aloc((_, _), opt_get1(_, Gf@11@03), i2@176@03)) && i2@176@03 < V@12@03 && 0 <= i2@176@03 && i1@175@03 < V@12@03 && 0 <= i1@175@03)]
(assert (not
  (and
    (and
      (and
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@175@03))
            ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@176@03)))
          (< i2@176@03 V@12@03))
        (<= 0 i2@176@03))
      (< i1@175@03 V@12@03))
    (<= 0 i1@175@03))))
(pop) ; 14
(pop) ; 13
; Joined path conditions
(assert (implies
  (and
    (and
      (and
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@175@03))
            ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@176@03)))
          (< i2@176@03 V@12@03))
        (<= 0 i2@176@03))
      (< i1@175@03 V@12@03))
    (<= 0 i1@175@03))
  (and
    (=
      ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@175@03))
      ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@176@03)))
    (< i2@176@03 V@12@03)
    (<= 0 i2@176@03)
    (< i1@175@03 V@12@03)
    (<= 0 i1@175@03))))
; Joined path conditions
(pop) ; 12
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i2@176@03 Int)) (!
  (and
    (implies
      (<= 0 i1@175@03)
      (and
        (<= 0 i1@175@03)
        (implies
          (< i1@175@03 V@12@03)
          (and
            (< i1@175@03 V@12@03)
            (implies
              (<= 0 i2@176@03)
              (and
                (<= 0 i2@176@03)
                (implies
                  (< i2@176@03 V@12@03)
                  (and
                    (< i2@176@03 V@12@03)
                    (< i1@175@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))
                    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@175@03)) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@175@03))
                    (< i2@176@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))
                    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@176@03)) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@176@03))))))))))
    (implies
      (and
        (and
          (and
            (and
              (=
                ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@175@03))
                ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@176@03)))
              (< i2@176@03 V@12@03))
            (<= 0 i2@176@03))
          (< i1@175@03 V@12@03))
        (<= 0 i1@175@03))
      (and
        (=
          ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@175@03))
          ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@176@03)))
        (< i2@176@03 V@12@03)
        (<= 0 i2@176@03)
        (< i1@175@03 V@12@03)
        (<= 0 i1@175@03))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@176@03))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 11
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@175@03 Int)) (!
  (forall ((i2@176@03 Int)) (!
    (and
      (implies
        (<= 0 i1@175@03)
        (and
          (<= 0 i1@175@03)
          (implies
            (< i1@175@03 V@12@03)
            (and
              (< i1@175@03 V@12@03)
              (implies
                (<= 0 i2@176@03)
                (and
                  (<= 0 i2@176@03)
                  (implies
                    (< i2@176@03 V@12@03)
                    (and
                      (< i2@176@03 V@12@03)
                      (< i1@175@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))
                      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@175@03)) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@175@03))
                      (< i2@176@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))
                      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@176@03)) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@176@03))))))))))
      (implies
        (and
          (and
            (and
              (and
                (=
                  ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@175@03))
                  ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@176@03)))
                (< i2@176@03 V@12@03))
              (<= 0 i2@176@03))
            (< i1@175@03 V@12@03))
          (<= 0 i1@175@03))
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@175@03))
            ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@176@03)))
          (< i2@176@03 V@12@03)
          (<= 0 i2@176@03)
          (< i1@175@03 V@12@03)
          (<= 0 i1@175@03))))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@176@03))
    :qid |prog.l<no position>-aux|))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@175@03))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(assert (forall ((i1@175@03 Int)) (!
  (forall ((i2@176@03 Int)) (!
    (implies
      (and
        (and
          (and
            (and
              (=
                ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@175@03))
                ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@176@03)))
              (< i2@176@03 V@12@03))
            (<= 0 i2@176@03))
          (< i1@175@03 V@12@03))
        (<= 0 i1@175@03))
      (= i1@175@03 i2@176@03))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@176@03))
    :qid |prog.l<no position>|))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@175@03))
  :qid |prog.l<no position>|)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03)))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03)))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03))))))))
  $Snap.unit))
; [eval] p != (None(): option[array])
; [eval] (None(): option[array])
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03)))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03)))))))))
  $Snap.unit))
; [eval] alen(opt_get1(p)) == V
; [eval] alen(opt_get1(p))
; [eval] opt_get1(p)
(push) ; 11
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 11
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03)))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03)))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03))))))))))
  $Snap.unit))
; [eval] 0 <= s
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03)))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03)))))))))))
  $Snap.unit))
; [eval] s < V
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03)))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03)))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03))))))))))))
  $Snap.unit))
; [eval] 0 <= t
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03)))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03)))))))))))))
  $Snap.unit))
; [eval] t < V
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03)))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03)))))))))))))))))
(declare-const i1@177@03 Int)
(declare-const j1@178@03 Int)
(push) ; 11
; [eval] 0 <= i1 && i1 < V && (0 <= j1 && j1 < V)
; [eval] 0 <= i1
(push) ; 12
; [then-branch: 111 | 0 <= i1@177@03 | live]
; [else-branch: 111 | !(0 <= i1@177@03) | live]
(push) ; 13
; [then-branch: 111 | 0 <= i1@177@03]
(assert (<= 0 i1@177@03))
; [eval] i1 < V
(push) ; 14
; [then-branch: 112 | i1@177@03 < V@12@03 | live]
; [else-branch: 112 | !(i1@177@03 < V@12@03) | live]
(push) ; 15
; [then-branch: 112 | i1@177@03 < V@12@03]
(assert (< i1@177@03 V@12@03))
; [eval] 0 <= j1
(push) ; 16
; [then-branch: 113 | 0 <= j1@178@03 | live]
; [else-branch: 113 | !(0 <= j1@178@03) | live]
(push) ; 17
; [then-branch: 113 | 0 <= j1@178@03]
(assert (<= 0 j1@178@03))
; [eval] j1 < V
(pop) ; 17
(push) ; 17
; [else-branch: 113 | !(0 <= j1@178@03)]
(assert (not (<= 0 j1@178@03)))
(pop) ; 17
(pop) ; 16
; Joined path conditions
; Joined path conditions
(pop) ; 15
(push) ; 15
; [else-branch: 112 | !(i1@177@03 < V@12@03)]
(assert (not (< i1@177@03 V@12@03)))
(pop) ; 15
(pop) ; 14
; Joined path conditions
; Joined path conditions
(pop) ; 13
(push) ; 13
; [else-branch: 111 | !(0 <= i1@177@03)]
(assert (not (<= 0 i1@177@03)))
(pop) ; 13
(pop) ; 12
; Joined path conditions
; Joined path conditions
(assert (and
  (and (and (< j1@178@03 V@12@03) (<= 0 j1@178@03)) (< i1@177@03 V@12@03))
  (<= 0 i1@177@03)))
; [eval] aloc(opt_get1(aloc(opt_get1(Gf), i1).option$array$), j1)
; [eval] opt_get1(aloc(opt_get1(Gf), i1).option$array$)
; [eval] aloc(opt_get1(Gf), i1)
; [eval] opt_get1(Gf)
(push) ; 12
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 12
; Joined path conditions
(push) ; 12
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 13
(assert (not (< i1@177@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))))
(check-sat)
; unsat
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               14802
;  :arith-add-rows          6440
;  :arith-assert-diseq      509
;  :arith-assert-lower      3593
;  :arith-assert-upper      2447
;  :arith-bound-prop        906
;  :arith-conflicts         177
;  :arith-eq-adapter        2259
;  :arith-fixed-eqs         1526
;  :arith-offset-eqs        1146
;  :arith-pivots            2109
;  :conflicts               408
;  :datatype-accessor-ax    131
;  :datatype-constructor-ax 381
;  :datatype-occurs-check   234
;  :datatype-splits         139
;  :decisions               2094
;  :del-clause              24488
;  :final-checks            122
;  :interface-eqs           13
;  :max-generation          9
;  :max-memory              8.79
;  :memory                  8.58
;  :minimized-lits          61
;  :mk-bool-var             30731
;  :mk-clause               25402
;  :num-allocs              372463
;  :num-checks              190
;  :propagations            7292
;  :quant-instantiations    8689
;  :rlimit-count            792137)
(assert (< i1@177@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03))))
(pop) ; 12
; Joined path conditions
(assert (< i1@177@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@177@03)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@177@03)))
(push) ; 12
(assert (not (ite
  (and
    (<
      (inv@171@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@177@03))
      V@12@03)
    (<=
      0
      (inv@171@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@177@03))))
  (< $Perm.No $k@170@03)
  false)))
(check-sat)
; unsat
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               14828
;  :arith-add-rows          6458
;  :arith-assert-diseq      509
;  :arith-assert-lower      3597
;  :arith-assert-upper      2452
;  :arith-bound-prop        910
;  :arith-conflicts         178
;  :arith-eq-adapter        2263
;  :arith-fixed-eqs         1530
;  :arith-offset-eqs        1146
;  :arith-pivots            2114
;  :conflicts               409
;  :datatype-accessor-ax    131
;  :datatype-constructor-ax 381
;  :datatype-occurs-check   234
;  :datatype-splits         139
;  :decisions               2094
;  :del-clause              24488
;  :final-checks            122
;  :interface-eqs           13
;  :max-generation          9
;  :max-memory              8.79
;  :memory                  8.59
;  :minimized-lits          61
;  :mk-bool-var             30850
;  :mk-clause               25460
;  :num-allocs              373265
;  :num-checks              191
;  :propagations            7294
;  :quant-instantiations    8741
;  :rlimit-count            795250)
(push) ; 12
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 13
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@177@03))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               14828
;  :arith-add-rows          6458
;  :arith-assert-diseq      509
;  :arith-assert-lower      3597
;  :arith-assert-upper      2452
;  :arith-bound-prop        910
;  :arith-conflicts         178
;  :arith-eq-adapter        2263
;  :arith-fixed-eqs         1530
;  :arith-offset-eqs        1146
;  :arith-pivots            2114
;  :conflicts               410
;  :datatype-accessor-ax    131
;  :datatype-constructor-ax 381
;  :datatype-occurs-check   234
;  :datatype-splits         139
;  :decisions               2094
;  :del-clause              24488
;  :final-checks            122
;  :interface-eqs           13
;  :max-generation          9
;  :max-memory              8.79
;  :memory                  8.59
;  :minimized-lits          61
;  :mk-bool-var             30850
;  :mk-clause               25460
;  :num-allocs              373355
;  :num-checks              192
;  :propagations            7294
;  :quant-instantiations    8741
;  :rlimit-count            795345)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@177@03))
    (as None<option<array>>  option<array>))))
(pop) ; 12
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@177@03))
    (as None<option<array>>  option<array>))))
(push) ; 12
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 13
(assert (not (<
  j1@178@03
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@177@03)))))))
(check-sat)
; unsat
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               14834
;  :arith-add-rows          6464
;  :arith-assert-diseq      509
;  :arith-assert-lower      3599
;  :arith-assert-upper      2454
;  :arith-bound-prop        910
;  :arith-conflicts         179
;  :arith-eq-adapter        2264
;  :arith-fixed-eqs         1531
;  :arith-offset-eqs        1146
;  :arith-pivots            2118
;  :conflicts               411
;  :datatype-accessor-ax    131
;  :datatype-constructor-ax 381
;  :datatype-occurs-check   234
;  :datatype-splits         139
;  :decisions               2094
;  :del-clause              24492
;  :final-checks            122
;  :interface-eqs           13
;  :max-generation          9
;  :max-memory              8.79
;  :memory                  8.60
;  :minimized-lits          61
;  :mk-bool-var             30861
;  :mk-clause               25464
;  :num-allocs              373548
;  :num-checks              193
;  :propagations            7296
;  :quant-instantiations    8748
;  :rlimit-count            795862)
(assert (<
  j1@178@03
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@177@03))))))
(pop) ; 12
; Joined path conditions
(assert (<
  j1@178@03
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@177@03))))))
(pop) ; 11
(declare-fun inv@179@03 ($Ref) Int)
(declare-fun inv@180@03 ($Ref) Int)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(assert (forall ((i1@177@03 Int) (j1@178@03 Int)) (!
  (and
    (< i1@177@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@177@03)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@177@03))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@177@03))
        (as None<option<array>>  option<array>)))
    (<
      j1@178@03
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@177@03))))))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@177@03))) j1@178@03))
  :qid |int-aux|)))
; Check receiver injectivity
(push) ; 11
(assert (not (forall ((i11@177@03 Int) (j11@178@03 Int) (i12@177@03 Int) (j12@178@03 Int)) (!
  (implies
    (and
      (and
        (and
          (and (< j11@178@03 V@12@03) (<= 0 j11@178@03))
          (< i11@177@03 V@12@03))
        (<= 0 i11@177@03))
      (and
        (and
          (and (< j12@178@03 V@12@03) (<= 0 j12@178@03))
          (< i12@177@03 V@12@03))
        (<= 0 i12@177@03))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i11@177@03))) j11@178@03)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i12@177@03))) j12@178@03)))
    (and (= i11@177@03 i12@177@03) (= j11@178@03 j12@178@03)))
  
  :qid |int-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               14898
;  :arith-add-rows          6492
;  :arith-assert-diseq      509
;  :arith-assert-lower      3612
;  :arith-assert-upper      2457
;  :arith-bound-prop        912
;  :arith-conflicts         179
;  :arith-eq-adapter        2276
;  :arith-fixed-eqs         1533
;  :arith-offset-eqs        1146
;  :arith-pivots            2131
;  :conflicts               412
;  :datatype-accessor-ax    131
;  :datatype-constructor-ax 381
;  :datatype-occurs-check   234
;  :datatype-splits         139
;  :decisions               2094
;  :del-clause              24669
;  :final-checks            122
;  :interface-eqs           13
;  :max-generation          9
;  :max-memory              8.79
;  :memory                  8.59
;  :minimized-lits          61
;  :mk-bool-var             31143
;  :mk-clause               25583
;  :num-allocs              375405
;  :num-checks              194
;  :propagations            7322
;  :quant-instantiations    8874
;  :rlimit-count            803149
;  :time                    0.00)
; Definitional axioms for inverse functions
(assert (forall ((i1@177@03 Int) (j1@178@03 Int)) (!
  (implies
    (and
      (and (and (< j1@178@03 V@12@03) (<= 0 j1@178@03)) (< i1@177@03 V@12@03))
      (<= 0 i1@177@03))
    (and
      (=
        (inv@179@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@177@03))) j1@178@03))
        i1@177@03)
      (=
        (inv@180@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@177@03))) j1@178@03))
        j1@178@03)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@177@03))) j1@178@03))
  )))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@180@03 r) V@12@03) (<= 0 (inv@180@03 r)))
        (< (inv@179@03 r) V@12@03))
      (<= 0 (inv@179@03 r)))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) (inv@179@03 r)))) (inv@180@03 r))
      r))
  :pattern ((inv@179@03 r))
  :pattern ((inv@180@03 r))
  :qid |int-fctOfInv|)))
; Permissions are non-negative
; Field permissions are at most one
; Permission implies non-null receiver
(assert (forall ((i1@177@03 Int) (j1@178@03 Int)) (!
  (implies
    (and
      (and (and (< j1@178@03 V@12@03) (<= 0 j1@178@03)) (< i1@177@03 V@12@03))
      (<= 0 i1@177@03))
    (not
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@177@03))) j1@178@03)
        $Ref.null)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@177@03))) j1@178@03))
  :qid |int-permImpliesNonNull|)))
(declare-const sm@181@03 $FVF<Int>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@180@03 r) V@12@03) (<= 0 (inv@180@03 r)))
        (< (inv@179@03 r) V@12@03))
      (<= 0 (inv@179@03 r)))
    (=
      ($FVF.lookup_int (as sm@181@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@181@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03))))))))))))))) r))
  :qid |qp.fvfValDef61|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03))))))))))))))) r) r)
  :pattern (($FVF.lookup_int (as sm@181@03  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef62|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@180@03 r) V@12@03) (<= 0 (inv@180@03 r)))
        (< (inv@179@03 r) V@12@03))
      (<= 0 (inv@179@03 r)))
    ($FVF.loc_int ($FVF.lookup_int (as sm@181@03  $FVF<Int>) r) r))
  :pattern ((inv@179@03 r) (inv@180@03 r))
  )))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03))))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03)))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03))))))))))))))))))
(declare-const i1@182@03 Int)
(push) ; 11
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 12
; [then-branch: 114 | 0 <= i1@182@03 | live]
; [else-branch: 114 | !(0 <= i1@182@03) | live]
(push) ; 13
; [then-branch: 114 | 0 <= i1@182@03]
(assert (<= 0 i1@182@03))
; [eval] i1 < V
(pop) ; 13
(push) ; 13
; [else-branch: 114 | !(0 <= i1@182@03)]
(assert (not (<= 0 i1@182@03)))
(pop) ; 13
(pop) ; 12
; Joined path conditions
; Joined path conditions
(assert (and (< i1@182@03 V@12@03) (<= 0 i1@182@03)))
; [eval] aloc(opt_get1(p), i1)
; [eval] opt_get1(p)
(push) ; 12
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 12
; Joined path conditions
(push) ; 12
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 13
(assert (not (< i1@182@03 (alen<Int> (opt_get1 $Snap.unit p@15@03)))))
(check-sat)
; unsat
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               14903
;  :arith-add-rows          6493
;  :arith-assert-diseq      509
;  :arith-assert-lower      3614
;  :arith-assert-upper      2457
;  :arith-bound-prop        912
;  :arith-conflicts         179
;  :arith-eq-adapter        2276
;  :arith-fixed-eqs         1533
;  :arith-offset-eqs        1146
;  :arith-pivots            2131
;  :conflicts               412
;  :datatype-accessor-ax    132
;  :datatype-constructor-ax 381
;  :datatype-occurs-check   234
;  :datatype-splits         139
;  :decisions               2094
;  :del-clause              24669
;  :final-checks            122
;  :interface-eqs           13
;  :max-generation          9
;  :max-memory              8.79
;  :memory                  8.59
;  :minimized-lits          61
;  :mk-bool-var             31152
;  :mk-clause               25583
;  :num-allocs              376504
;  :num-checks              195
;  :propagations            7322
;  :quant-instantiations    8874
;  :rlimit-count            806269)
(assert (< i1@182@03 (alen<Int> (opt_get1 $Snap.unit p@15@03))))
(pop) ; 12
; Joined path conditions
(assert (< i1@182@03 (alen<Int> (opt_get1 $Snap.unit p@15@03))))
(pop) ; 11
(declare-fun inv@183@03 ($Ref) Int)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(assert (forall ((i1@182@03 Int)) (!
  (< i1@182@03 (alen<Int> (opt_get1 $Snap.unit p@15@03)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) i1@182@03))
  :qid |int-aux|)))
; Check receiver injectivity
(push) ; 11
(assert (not (forall ((i11@182@03 Int) (i12@182@03 Int)) (!
  (implies
    (and
      (and (< i11@182@03 V@12@03) (<= 0 i11@182@03))
      (and (< i12@182@03 V@12@03) (<= 0 i12@182@03))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) i11@182@03)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) i12@182@03)))
    (= i11@182@03 i12@182@03))
  
  :qid |int-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               14926
;  :arith-add-rows          6497
;  :arith-assert-diseq      510
;  :arith-assert-lower      3618
;  :arith-assert-upper      2457
;  :arith-bound-prop        912
;  :arith-conflicts         179
;  :arith-eq-adapter        2277
;  :arith-fixed-eqs         1533
;  :arith-offset-eqs        1146
;  :arith-pivots            2131
;  :conflicts               413
;  :datatype-accessor-ax    132
;  :datatype-constructor-ax 381
;  :datatype-occurs-check   234
;  :datatype-splits         139
;  :decisions               2094
;  :del-clause              24675
;  :final-checks            122
;  :interface-eqs           13
;  :max-generation          9
;  :max-memory              8.79
;  :memory                  8.59
;  :minimized-lits          61
;  :mk-bool-var             31186
;  :mk-clause               25589
;  :num-allocs              377106
;  :num-checks              196
;  :propagations            7322
;  :quant-instantiations    8911
;  :rlimit-count            807613)
; Definitional axioms for inverse functions
(assert (forall ((i1@182@03 Int)) (!
  (implies
    (and (< i1@182@03 V@12@03) (<= 0 i1@182@03))
    (=
      (inv@183@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) i1@182@03))
      i1@182@03))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) i1@182@03))
  )))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@183@03 r) V@12@03) (<= 0 (inv@183@03 r)))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) (inv@183@03 r))
      r))
  :pattern ((inv@183@03 r))
  :qid |int-fctOfInv|)))
; Permissions are non-negative
; Field permissions are at most one
; Permission implies non-null receiver
(assert (forall ((i1@182@03 Int)) (!
  (implies
    (and (< i1@182@03 V@12@03) (<= 0 i1@182@03))
    (not
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) i1@182@03)
        $Ref.null)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) i1@182@03))
  :qid |int-permImpliesNonNull|)))
(declare-const sm@184@03 $FVF<Int>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@183@03 r) V@12@03) (<= 0 (inv@183@03 r)))
    (=
      ($FVF.lookup_int (as sm@184@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03)))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@184@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03)))))))))))))))) r))
  :qid |qp.fvfValDef63|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@180@03 r) V@12@03) (<= 0 (inv@180@03 r)))
        (< (inv@179@03 r) V@12@03))
      (<= 0 (inv@179@03 r)))
    (=
      ($FVF.lookup_int (as sm@184@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@184@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03))))))))))))))) r))
  :qid |qp.fvfValDef64|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03)))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03))))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@184@03  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef65|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@183@03 r) V@12@03) (<= 0 (inv@183@03 r)))
    ($FVF.loc_int ($FVF.lookup_int (as sm@184@03  $FVF<Int>) r) r))
  :pattern ((inv@183@03 r))
  )))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03)))))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03))))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03)))))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03))))))))))))))))
  $Snap.unit))
; [eval] valid_graph_vertices(this, p, V)
(push) ; 11
; [eval] this != null
; [eval] p != (None(): option[array])
; [eval] (None(): option[array])
; [eval] alen(opt_get1(p)) == V
; [eval] alen(opt_get1(p))
; [eval] opt_get1(p)
(push) ; 12
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 12
; Joined path conditions
(declare-const i1@185@03 Int)
(push) ; 12
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 13
; [then-branch: 115 | 0 <= i1@185@03 | live]
; [else-branch: 115 | !(0 <= i1@185@03) | live]
(push) ; 14
; [then-branch: 115 | 0 <= i1@185@03]
(assert (<= 0 i1@185@03))
; [eval] i1 < V
(pop) ; 14
(push) ; 14
; [else-branch: 115 | !(0 <= i1@185@03)]
(assert (not (<= 0 i1@185@03)))
(pop) ; 14
(pop) ; 13
; Joined path conditions
; Joined path conditions
(assert (and (< i1@185@03 V@12@03) (<= 0 i1@185@03)))
(declare-const $k@186@03 $Perm)
(assert ($Perm.isReadVar $k@186@03 $Perm.Write))
; [eval] aloc(opt_get1(p), i1)
; [eval] opt_get1(p)
(push) ; 13
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 13
; Joined path conditions
(push) ; 13
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 14
(assert (not (< i1@185@03 (alen<Int> (opt_get1 $Snap.unit p@15@03)))))
(check-sat)
; unsat
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               14932
;  :arith-add-rows          6498
;  :arith-assert-diseq      511
;  :arith-assert-lower      3622
;  :arith-assert-upper      2458
;  :arith-bound-prop        912
;  :arith-conflicts         179
;  :arith-eq-adapter        2278
;  :arith-fixed-eqs         1533
;  :arith-offset-eqs        1146
;  :arith-pivots            2131
;  :conflicts               413
;  :datatype-accessor-ax    133
;  :datatype-constructor-ax 381
;  :datatype-occurs-check   234
;  :datatype-splits         139
;  :decisions               2094
;  :del-clause              24675
;  :final-checks            122
;  :interface-eqs           13
;  :max-generation          9
;  :max-memory              8.79
;  :memory                  8.60
;  :minimized-lits          61
;  :mk-bool-var             31201
;  :mk-clause               25591
;  :num-allocs              378475
;  :num-checks              197
;  :propagations            7323
;  :quant-instantiations    8911
;  :rlimit-count            811275)
(assert (< i1@185@03 (alen<Int> (opt_get1 $Snap.unit p@15@03))))
(pop) ; 13
; Joined path conditions
(assert (< i1@185@03 (alen<Int> (opt_get1 $Snap.unit p@15@03))))
(pop) ; 12
(declare-fun inv@187@03 ($Ref) Int)
; Nested auxiliary terms: globals
(assert ($Perm.isReadVar $k@186@03 $Perm.Write))
; Nested auxiliary terms: non-globals
(assert (forall ((i1@185@03 Int)) (!
  (< i1@185@03 (alen<Int> (opt_get1 $Snap.unit p@15@03)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) i1@185@03))
  :qid |int-aux|)))
(push) ; 12
(assert (not (forall ((i1@185@03 Int)) (!
  (implies
    (and (< i1@185@03 V@12@03) (<= 0 i1@185@03))
    (or (= $k@186@03 $Perm.No) (< $Perm.No $k@186@03)))
  
  ))))
(check-sat)
; unsat
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               14932
;  :arith-add-rows          6499
;  :arith-assert-diseq      512
;  :arith-assert-lower      3624
;  :arith-assert-upper      2459
;  :arith-bound-prop        912
;  :arith-conflicts         179
;  :arith-eq-adapter        2279
;  :arith-fixed-eqs         1533
;  :arith-offset-eqs        1146
;  :arith-pivots            2131
;  :conflicts               414
;  :datatype-accessor-ax    133
;  :datatype-constructor-ax 381
;  :datatype-occurs-check   234
;  :datatype-splits         139
;  :decisions               2094
;  :del-clause              24677
;  :final-checks            122
;  :interface-eqs           13
;  :max-generation          9
;  :max-memory              8.79
;  :memory                  8.60
;  :minimized-lits          61
;  :mk-bool-var             31208
;  :mk-clause               25593
;  :num-allocs              378898
;  :num-checks              198
;  :propagations            7324
;  :quant-instantiations    8911
;  :rlimit-count            811821)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 12
(assert (not (forall ((i11@185@03 Int) (i12@185@03 Int)) (!
  (implies
    (and
      (and
        (and
          (and (< i11@185@03 V@12@03) (<= 0 i11@185@03))
          ($FVF.loc_int ($FVF.lookup_int (as sm@184@03  $FVF<Int>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit p@15@03) i11@185@03)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit p@15@03) i11@185@03)))
        (< $Perm.No $k@186@03))
      (and
        (and
          (and (< i12@185@03 V@12@03) (<= 0 i12@185@03))
          ($FVF.loc_int ($FVF.lookup_int (as sm@184@03  $FVF<Int>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit p@15@03) i12@185@03)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit p@15@03) i12@185@03)))
        (< $Perm.No $k@186@03))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) i11@185@03)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) i12@185@03)))
    (= i11@185@03 i12@185@03))
  
  :qid |int-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               14959
;  :arith-add-rows          6506
;  :arith-assert-diseq      513
;  :arith-assert-lower      3628
;  :arith-assert-upper      2459
;  :arith-bound-prop        912
;  :arith-conflicts         179
;  :arith-eq-adapter        2280
;  :arith-fixed-eqs         1533
;  :arith-offset-eqs        1146
;  :arith-pivots            2131
;  :conflicts               415
;  :datatype-accessor-ax    133
;  :datatype-constructor-ax 381
;  :datatype-occurs-check   234
;  :datatype-splits         139
;  :decisions               2094
;  :del-clause              24688
;  :final-checks            122
;  :interface-eqs           13
;  :max-generation          9
;  :max-memory              8.79
;  :memory                  8.60
;  :minimized-lits          61
;  :mk-bool-var             31256
;  :mk-clause               25604
;  :num-allocs              379435
;  :num-checks              199
;  :propagations            7326
;  :quant-instantiations    8955
;  :rlimit-count            813362)
; Definitional axioms for inverse functions
(assert (forall ((i1@185@03 Int)) (!
  (implies
    (and (and (< i1@185@03 V@12@03) (<= 0 i1@185@03)) (< $Perm.No $k@186@03))
    (=
      (inv@187@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) i1@185@03))
      i1@185@03))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) i1@185@03))
  :qid |int-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and (< (inv@187@03 r) V@12@03) (<= 0 (inv@187@03 r)))
      (< $Perm.No $k@186@03))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) (inv@187@03 r))
      r))
  :pattern ((inv@187@03 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@187@03 r) V@12@03) (<= 0 (inv@187@03 r)))
    ($FVF.loc_int ($FVF.lookup_int (as sm@184@03  $FVF<Int>) r) r))
  :pattern ((inv@187@03 r))
  )))
; Precomputing data for removing quantified permissions
(define-fun pTaken@188@03 ((r $Ref)) $Perm
  (ite
    (and (< (inv@187@03 r) V@12@03) (<= 0 (inv@187@03 r)))
    ($Perm.min
      (ite
        (and (< (inv@183@03 r) V@12@03) (<= 0 (inv@183@03 r)))
        $Perm.Write
        $Perm.No)
      $k@186@03)
    $Perm.No))
(define-fun pTaken@189@03 ((r $Ref)) $Perm
  (ite
    (and (< (inv@187@03 r) V@12@03) (<= 0 (inv@187@03 r)))
    ($Perm.min
      (ite
        (and
          (and
            (and (< (inv@180@03 r) V@12@03) (<= 0 (inv@180@03 r)))
            (< (inv@179@03 r) V@12@03))
          (<= 0 (inv@179@03 r)))
        $Perm.Write
        $Perm.No)
      (- $k@186@03 (pTaken@188@03 r)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Constrain original permissions $k@186@03
(assert (forall ((r $Ref)) (!
  (implies
    (not
      (=
        (ite
          (and (< (inv@183@03 r) V@12@03) (<= 0 (inv@183@03 r)))
          $Perm.Write
          $Perm.No)
        $Perm.No))
    (ite
      (and (< (inv@183@03 r) V@12@03) (<= 0 (inv@183@03 r)))
      (<
        (ite
          (and (< (inv@187@03 r) V@12@03) (<= 0 (inv@187@03 r)))
          $k@186@03
          $Perm.No)
        $Perm.Write)
      (<
        (ite
          (and (< (inv@187@03 r) V@12@03) (<= 0 (inv@187@03 r)))
          $k@186@03
          $Perm.No)
        $Perm.No)))
  :pattern ((inv@183@03 r))
  :pattern ((inv@187@03 r))
  :qid |qp.srp66|)))
; Intermediate check if already taken enough permissions
(set-option :timeout 500)
(push) ; 12
(assert (not (forall ((r $Ref)) (!
  (implies
    (and (< (inv@187@03 r) V@12@03) (<= 0 (inv@187@03 r)))
    (= (- $k@186@03 (pTaken@188@03 r)) $Perm.No))
  
  ))))
(check-sat)
; unsat
(pop) ; 12
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               16301
;  :arith-add-rows          7310
;  :arith-assert-diseq      567
;  :arith-assert-lower      3920
;  :arith-assert-upper      2655
;  :arith-bound-prop        974
;  :arith-conflicts         188
;  :arith-eq-adapter        2513
;  :arith-fixed-eqs         1694
;  :arith-offset-eqs        1236
;  :arith-pivots            2217
;  :conflicts               442
;  :datatype-accessor-ax    133
;  :datatype-constructor-ax 389
;  :datatype-occurs-check   234
;  :datatype-splits         139
;  :decisions               2379
;  :del-clause              28719
;  :final-checks            122
;  :interface-eqs           13
;  :max-generation          9
;  :max-memory              8.87
;  :memory                  8.80
;  :minimized-lits          61
;  :mk-bool-var             34889
;  :mk-clause               29699
;  :num-allocs              388910
;  :num-checks              201
;  :propagations            8300
;  :quant-instantiations    9900
;  :rlimit-count            860221
;  :time                    0.01)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@190@03 $FVF<Int>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (iff
    (Set_in r ($FVF.domain_int (as sm@190@03  $FVF<Int>)))
    (and
      (and (< (inv@187@03 r) V@12@03) (<= 0 (inv@187@03 r)))
      (< $Perm.No $k@186@03)))
  :pattern ((Set_in r ($FVF.domain_int (as sm@190@03  $FVF<Int>))))
  :qid |qp.fvfDomDef70|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@187@03 r) V@12@03) (<= 0 (inv@187@03 r)))
        (< $Perm.No $k@186@03))
      (and (< (inv@183@03 r) V@12@03) (<= 0 (inv@183@03 r))))
    (=
      ($FVF.lookup_int (as sm@190@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03)))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@190@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03)))))))))))))))) r))
  :qid |qp.fvfValDef67|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@187@03 r) V@12@03) (<= 0 (inv@187@03 r)))
        (< $Perm.No $k@186@03))
      (and
        (and
          (and (< (inv@180@03 r) V@12@03) (<= 0 (inv@180@03 r)))
          (< (inv@179@03 r) V@12@03))
        (<= 0 (inv@179@03 r))))
    (=
      ($FVF.lookup_int (as sm@190@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@190@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03))))))))))))))) r))
  :qid |qp.fvfValDef68|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03)))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03))))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@190@03  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef69|)))
(pop) ; 11
; Joined path conditions
(assert ($Perm.isReadVar $k@186@03 $Perm.Write))
(assert (forall ((i1@185@03 Int)) (!
  (implies
    (and (and (< i1@185@03 V@12@03) (<= 0 i1@185@03)) (< $Perm.No $k@186@03))
    (=
      (inv@187@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) i1@185@03))
      i1@185@03))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) i1@185@03))
  :qid |int-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and (< (inv@187@03 r) V@12@03) (<= 0 (inv@187@03 r)))
      (< $Perm.No $k@186@03))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) (inv@187@03 r))
      r))
  :pattern ((inv@187@03 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (iff
    (Set_in r ($FVF.domain_int (as sm@190@03  $FVF<Int>)))
    (and
      (and (< (inv@187@03 r) V@12@03) (<= 0 (inv@187@03 r)))
      (< $Perm.No $k@186@03)))
  :pattern ((Set_in r ($FVF.domain_int (as sm@190@03  $FVF<Int>))))
  :qid |qp.fvfDomDef70|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@187@03 r) V@12@03) (<= 0 (inv@187@03 r)))
        (< $Perm.No $k@186@03))
      (and (< (inv@183@03 r) V@12@03) (<= 0 (inv@183@03 r))))
    (=
      ($FVF.lookup_int (as sm@190@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03)))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@190@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03)))))))))))))))) r))
  :qid |qp.fvfValDef67|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@187@03 r) V@12@03) (<= 0 (inv@187@03 r)))
        (< $Perm.No $k@186@03))
      (and
        (and
          (and (< (inv@180@03 r) V@12@03) (<= 0 (inv@180@03 r)))
          (< (inv@179@03 r) V@12@03))
        (<= 0 (inv@179@03 r))))
    (=
      ($FVF.lookup_int (as sm@190@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@190@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03))))))))))))))) r))
  :qid |qp.fvfValDef68|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03)))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03))))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@190@03  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef69|)))
(assert (and
  (forall ((i1@185@03 Int)) (!
    (< i1@185@03 (alen<Int> (opt_get1 $Snap.unit p@15@03)))
    :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) i1@185@03))
    :qid |int-aux|))
  (forall ((r $Ref)) (!
    (implies
      (and (< (inv@187@03 r) V@12@03) (<= 0 (inv@187@03 r)))
      ($FVF.loc_int ($FVF.lookup_int (as sm@184@03  $FVF<Int>) r) r))
    :pattern ((inv@187@03 r))
    ))
  (forall ((r $Ref)) (!
    (implies
      (not
        (=
          (ite
            (and (< (inv@183@03 r) V@12@03) (<= 0 (inv@183@03 r)))
            $Perm.Write
            $Perm.No)
          $Perm.No))
      (ite
        (and (< (inv@183@03 r) V@12@03) (<= 0 (inv@183@03 r)))
        (<
          (ite
            (and (< (inv@187@03 r) V@12@03) (<= 0 (inv@187@03 r)))
            $k@186@03
            $Perm.No)
          $Perm.Write)
        (<
          (ite
            (and (< (inv@187@03 r) V@12@03) (<= 0 (inv@187@03 r)))
            $k@186@03
            $Perm.No)
          $Perm.No)))
    :pattern ((inv@183@03 r))
    :pattern ((inv@187@03 r))
    :qid |qp.srp66|))))
(assert (valid_graph_vertices ($Snap.combine
  $Snap.unit
  ($Snap.combine
    $Snap.unit
    ($Snap.combine
      $Snap.unit
      ($SortWrappers.$FVF<Int>To$Snap (as sm@190@03  $FVF<Int>))))) this@9@03 p@15@03 V@12@03))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03))))))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03)))))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03))))))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03)))))))))))))))))
  $Snap.unit))
; [eval] alen(opt_get1(visited)) == V
; [eval] alen(opt_get1(visited))
; [eval] opt_get1(visited)
(push) ; 11
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 11
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03)))))))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03))))))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03)))))))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03))))))))))))))))))
  $Snap.unit))
; [eval] 0 <= u
(assert (<= 0 u@161@03))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03))))))))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03)))))))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03))))))))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03)))))))))))))))))))
  $Snap.unit))
; [eval] u < V
(assert (< u@161@03 V@12@03))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03)))))))))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03))))))))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03)))))))))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03))))))))))))))))))))
  $Snap.unit))
; [eval] 0 <= v
(assert (<= 0 v@166@03))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03))))))))))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03)))))))))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03))))))))))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03)))))))))))))))))))))
  $Snap.unit))
; [eval] v <= V
(assert (<= v@166@03 V@12@03))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03)))))))))))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03))))))))))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03)))))))))))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03))))))))))))))))))))))
  $Snap.unit))
; [eval] 0 <= k
(assert (<= 0 k@163@03))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03))))))))))))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03)))))))))))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03))))))))))))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03)))))))))))))))))))))))
  $Snap.unit))
; [eval] k < V
(assert (< k@163@03 V@12@03))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03)))))))))))))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03))))))))))))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03)))))))))))))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03))))))))))))))))))))))))
  $Snap.unit))
; [eval] valid_graph_vertices1(this, queue, V)
(push) ; 11
; [eval] this != null
(pop) ; 11
; Joined path conditions
(assert (valid_graph_vertices1 $Snap.unit this@9@03 queue@164@03 V@12@03))
(declare-const i1@191@03 Int)
(push) ; 11
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 12
; [then-branch: 116 | 0 <= i1@191@03 | live]
; [else-branch: 116 | !(0 <= i1@191@03) | live]
(push) ; 13
; [then-branch: 116 | 0 <= i1@191@03]
(assert (<= 0 i1@191@03))
; [eval] i1 < V
(pop) ; 13
(push) ; 13
; [else-branch: 116 | !(0 <= i1@191@03)]
(assert (not (<= 0 i1@191@03)))
(pop) ; 13
(pop) ; 12
; Joined path conditions
; Joined path conditions
(assert (and (< i1@191@03 V@12@03) (<= 0 i1@191@03)))
; [eval] aloc(opt_get1(visited), i1)
; [eval] opt_get1(visited)
(push) ; 12
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 12
; Joined path conditions
(push) ; 12
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 13
(assert (not (< i1@191@03 (alen<Int> (opt_get1 $Snap.unit res@79@03)))))
(check-sat)
; unsat
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               16362
;  :arith-add-rows          7321
;  :arith-assert-diseq      568
;  :arith-assert-lower      3931
;  :arith-assert-upper      2657
;  :arith-bound-prop        974
;  :arith-conflicts         188
;  :arith-eq-adapter        2515
;  :arith-fixed-eqs         1695
;  :arith-offset-eqs        1236
;  :arith-pivots            2222
;  :conflicts               442
;  :datatype-accessor-ax    144
;  :datatype-constructor-ax 389
;  :datatype-occurs-check   234
;  :datatype-splits         139
;  :decisions               2379
;  :del-clause              28785
;  :final-checks            122
;  :interface-eqs           13
;  :max-generation          9
;  :max-memory              8.87
;  :memory                  8.83
;  :minimized-lits          61
;  :mk-bool-var             35001
;  :mk-clause               29771
;  :num-allocs              391726
;  :num-checks              202
;  :propagations            8317
;  :quant-instantiations    9912
;  :rlimit-count            868239)
(assert (< i1@191@03 (alen<Int> (opt_get1 $Snap.unit res@79@03))))
(pop) ; 12
; Joined path conditions
(assert (< i1@191@03 (alen<Int> (opt_get1 $Snap.unit res@79@03))))
(pop) ; 11
(declare-fun inv@192@03 ($Ref) Int)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(assert (forall ((i1@191@03 Int)) (!
  (< i1@191@03 (alen<Int> (opt_get1 $Snap.unit res@79@03)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@79@03) i1@191@03))
  :qid |bool-aux|)))
; Check receiver injectivity
(push) ; 11
(assert (not (forall ((i11@191@03 Int) (i12@191@03 Int)) (!
  (implies
    (and
      (and (< i11@191@03 V@12@03) (<= 0 i11@191@03))
      (and (< i12@191@03 V@12@03) (<= 0 i12@191@03))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@79@03) i11@191@03)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@79@03) i12@191@03)))
    (= i11@191@03 i12@191@03))
  
  :qid |bool-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               16376
;  :arith-add-rows          7325
;  :arith-assert-diseq      569
;  :arith-assert-lower      3935
;  :arith-assert-upper      2657
;  :arith-bound-prop        974
;  :arith-conflicts         188
;  :arith-eq-adapter        2516
;  :arith-fixed-eqs         1695
;  :arith-offset-eqs        1236
;  :arith-pivots            2222
;  :conflicts               443
;  :datatype-accessor-ax    144
;  :datatype-constructor-ax 389
;  :datatype-occurs-check   234
;  :datatype-splits         139
;  :decisions               2379
;  :del-clause              28791
;  :final-checks            122
;  :interface-eqs           13
;  :max-generation          9
;  :max-memory              8.87
;  :memory                  8.83
;  :minimized-lits          61
;  :mk-bool-var             35026
;  :mk-clause               29777
;  :num-allocs              392265
;  :num-checks              203
;  :propagations            8317
;  :quant-instantiations    9936
;  :rlimit-count            869319)
; Definitional axioms for inverse functions
(assert (forall ((i1@191@03 Int)) (!
  (implies
    (and (< i1@191@03 V@12@03) (<= 0 i1@191@03))
    (=
      (inv@192@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@79@03) i1@191@03))
      i1@191@03))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@79@03) i1@191@03))
  )))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@192@03 r) V@12@03) (<= 0 (inv@192@03 r)))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@79@03) (inv@192@03 r))
      r))
  :pattern ((inv@192@03 r))
  :qid |bool-fctOfInv|)))
; Permissions are non-negative
; Field permissions are at most one
; Permission implies non-null receiver
(assert (forall ((i1@191@03 Int)) (!
  (implies
    (and (< i1@191@03 V@12@03) (<= 0 i1@191@03))
    (not
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@79@03) i1@191@03)
        $Ref.null)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@79@03) i1@191@03))
  :qid |bool-permImpliesNonNull|)))
(declare-const sm@193@03 $FVF<Bool>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@192@03 r) V@12@03) (<= 0 (inv@192@03 r)))
    (=
      ($FVF.lookup_bool (as sm@193@03  $FVF<Bool>) r)
      ($FVF.lookup_bool ($SortWrappers.$SnapTo$FVF<Bool> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03))))))))))))))))))))))))) r)))
  :pattern (($FVF.lookup_bool (as sm@193@03  $FVF<Bool>) r))
  :pattern (($FVF.lookup_bool ($SortWrappers.$SnapTo$FVF<Bool> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03))))))))))))))))))))))))) r))
  :qid |qp.fvfValDef71|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_bool ($FVF.lookup_bool ($SortWrappers.$SnapTo$FVF<Bool> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03))))))))))))))))))))))))) r) r)
  :pattern (($FVF.lookup_bool (as sm@193@03  $FVF<Bool>) r))
  :qid |qp.fvfResTrgDef72|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@192@03 r) V@12@03) (<= 0 (inv@192@03 r)))
    ($FVF.loc_bool ($FVF.lookup_bool (as sm@193@03  $FVF<Bool>) r) r))
  :pattern ((inv@192@03 r))
  )))
; Loop head block: Check well-definedness of edge conditions
(push) ; 11
; [eval] v < V
(pop) ; 11
(push) ; 11
; [eval] !(v < V)
; [eval] v < V
(pop) ; 11
(pop) ; 10
(push) ; 10
; Loop head block: Establish invariant
; [eval] exc == excBeforeLoop1
; [eval] Gf != (None(): option[array])
; [eval] (None(): option[array])
; [eval] alen(opt_get1(Gf)) == V
; [eval] alen(opt_get1(Gf))
; [eval] opt_get1(Gf)
(push) ; 11
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 11
; Joined path conditions
(declare-const i1@194@03 Int)
(push) ; 11
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 12
; [then-branch: 117 | 0 <= i1@194@03 | live]
; [else-branch: 117 | !(0 <= i1@194@03) | live]
(push) ; 13
; [then-branch: 117 | 0 <= i1@194@03]
(assert (<= 0 i1@194@03))
; [eval] i1 < V
(pop) ; 13
(push) ; 13
; [else-branch: 117 | !(0 <= i1@194@03)]
(assert (not (<= 0 i1@194@03)))
(pop) ; 13
(pop) ; 12
; Joined path conditions
; Joined path conditions
(assert (and (< i1@194@03 V@12@03) (<= 0 i1@194@03)))
(declare-const $k@195@03 $Perm)
(assert ($Perm.isReadVar $k@195@03 $Perm.Write))
; [eval] aloc(opt_get1(Gf), i1)
; [eval] opt_get1(Gf)
(push) ; 12
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 12
; Joined path conditions
(push) ; 12
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 13
(assert (not (< i1@194@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))))
(check-sat)
; unsat
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               16384
;  :arith-add-rows          7330
;  :arith-assert-diseq      570
;  :arith-assert-lower      3940
;  :arith-assert-upper      2659
;  :arith-bound-prop        976
;  :arith-conflicts         188
;  :arith-eq-adapter        2518
;  :arith-fixed-eqs         1696
;  :arith-offset-eqs        1236
;  :arith-pivots            2225
;  :conflicts               443
;  :datatype-accessor-ax    144
;  :datatype-constructor-ax 389
;  :datatype-occurs-check   234
;  :datatype-splits         139
;  :decisions               2379
;  :del-clause              28920
;  :final-checks            122
;  :interface-eqs           13
;  :max-generation          9
;  :max-memory              8.87
;  :memory                  8.81
;  :minimized-lits          61
;  :mk-bool-var             35092
;  :mk-clause               29834
;  :num-allocs              393407
;  :num-checks              204
;  :propagations            8319
;  :quant-instantiations    9947
;  :rlimit-count            872542)
(assert (< i1@194@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03))))
(pop) ; 12
; Joined path conditions
(assert (< i1@194@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03))))
(pop) ; 11
(declare-fun inv@196@03 ($Ref) Int)
; Nested auxiliary terms: globals
(assert ($Perm.isReadVar $k@195@03 $Perm.Write))
; Nested auxiliary terms: non-globals
(assert (forall ((i1@194@03 Int)) (!
  (< i1@194@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@194@03))
  :qid |option$array$-aux|)))
(push) ; 11
(assert (not (forall ((i1@194@03 Int)) (!
  (implies
    (and (< i1@194@03 V@12@03) (<= 0 i1@194@03))
    (or (= $k@195@03 $Perm.No) (< $Perm.No $k@195@03)))
  
  ))))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               16384
;  :arith-add-rows          7331
;  :arith-assert-diseq      571
;  :arith-assert-lower      3942
;  :arith-assert-upper      2660
;  :arith-bound-prop        976
;  :arith-conflicts         188
;  :arith-eq-adapter        2519
;  :arith-fixed-eqs         1696
;  :arith-offset-eqs        1236
;  :arith-pivots            2225
;  :conflicts               444
;  :datatype-accessor-ax    144
;  :datatype-constructor-ax 389
;  :datatype-occurs-check   234
;  :datatype-splits         139
;  :decisions               2379
;  :del-clause              28922
;  :final-checks            122
;  :interface-eqs           13
;  :max-generation          9
;  :max-memory              8.87
;  :memory                  8.81
;  :minimized-lits          61
;  :mk-bool-var             35099
;  :mk-clause               29836
;  :num-allocs              393840
;  :num-checks              205
;  :propagations            8320
;  :quant-instantiations    9947
;  :rlimit-count            873088)
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 11
(assert (not (forall ((i11@194@03 Int) (i12@194@03 Int)) (!
  (implies
    (and
      (and
        (and
          (and (< i11@194@03 V@12@03) (<= 0 i11@194@03))
          ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@109@03  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i11@194@03)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i11@194@03)))
        (< $Perm.No $k@195@03))
      (and
        (and
          (and (< i12@194@03 V@12@03) (<= 0 i12@194@03))
          ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@109@03  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i12@194@03)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i12@194@03)))
        (< $Perm.No $k@195@03))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i11@194@03)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i12@194@03)))
    (= i11@194@03 i12@194@03))
  
  :qid |option$array$-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               16397
;  :arith-add-rows          7336
;  :arith-assert-diseq      572
;  :arith-assert-lower      3946
;  :arith-assert-upper      2660
;  :arith-bound-prop        976
;  :arith-conflicts         188
;  :arith-eq-adapter        2520
;  :arith-fixed-eqs         1696
;  :arith-offset-eqs        1236
;  :arith-pivots            2225
;  :conflicts               445
;  :datatype-accessor-ax    144
;  :datatype-constructor-ax 389
;  :datatype-occurs-check   234
;  :datatype-splits         139
;  :decisions               2379
;  :del-clause              28929
;  :final-checks            122
;  :interface-eqs           13
;  :max-generation          9
;  :max-memory              8.93
;  :memory                  8.88
;  :minimized-lits          61
;  :mk-bool-var             35126
;  :mk-clause               29843
;  :num-allocs              394262
;  :num-checks              206
;  :propagations            8320
;  :quant-instantiations    9968
;  :rlimit-count            874086)
; Definitional axioms for inverse functions
(assert (forall ((i1@194@03 Int)) (!
  (implies
    (and (and (< i1@194@03 V@12@03) (<= 0 i1@194@03)) (< $Perm.No $k@195@03))
    (=
      (inv@196@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@194@03))
      i1@194@03))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@194@03))
  :qid |option$array$-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and (< (inv@196@03 r) V@12@03) (<= 0 (inv@196@03 r)))
      (< $Perm.No $k@195@03))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) (inv@196@03 r))
      r))
  :pattern ((inv@196@03 r))
  :qid |option$array$-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@196@03 r) V@12@03) (<= 0 (inv@196@03 r)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@109@03  $FVF<option<array>>) r) r))
  :pattern ((inv@196@03 r))
  )))
; Precomputing data for removing quantified permissions
(define-fun pTaken@197@03 ((r $Ref)) $Perm
  (ite
    (and (< (inv@196@03 r) V@12@03) (<= 0 (inv@196@03 r)))
    ($Perm.min
      (ite
        (and (< (inv@108@03 r) V@12@03) (<= 0 (inv@108@03 r)))
        $k@107@03
        $Perm.No)
      $k@195@03)
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Constrain original permissions $k@195@03
(assert (forall ((r $Ref)) (!
  (implies
    (not
      (=
        (ite
          (and (< (inv@108@03 r) V@12@03) (<= 0 (inv@108@03 r)))
          $k@107@03
          $Perm.No)
        $Perm.No))
    (ite
      (and (< (inv@108@03 r) V@12@03) (<= 0 (inv@108@03 r)))
      (<
        (ite
          (and (< (inv@196@03 r) V@12@03) (<= 0 (inv@196@03 r)))
          $k@195@03
          $Perm.No)
        $k@107@03)
      (<
        (ite
          (and (< (inv@196@03 r) V@12@03) (<= 0 (inv@196@03 r)))
          $k@195@03
          $Perm.No)
        $Perm.No)))
  :pattern ((inv@108@03 r))
  :pattern ((inv@196@03 r))
  :qid |qp.srp73|)))
; Intermediate check if already taken enough permissions
(set-option :timeout 500)
(push) ; 11
(assert (not (forall ((r $Ref)) (!
  (implies
    (and (< (inv@196@03 r) V@12@03) (<= 0 (inv@196@03 r)))
    (= (- $k@195@03 (pTaken@197@03 r)) $Perm.No))
  
  ))))
(check-sat)
; unsat
(pop) ; 11
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               17462
;  :arith-add-rows          7804
;  :arith-assert-diseq      632
;  :arith-assert-lower      4233
;  :arith-assert-upper      2841
;  :arith-bound-prop        1013
;  :arith-conflicts         196
;  :arith-eq-adapter        2740
;  :arith-fixed-eqs         1841
;  :arith-offset-eqs        1291
;  :arith-pivots            2274
;  :conflicts               469
;  :datatype-accessor-ax    144
;  :datatype-constructor-ax 397
;  :datatype-occurs-check   234
;  :datatype-splits         139
;  :decisions               2561
;  :del-clause              30996
;  :final-checks            122
;  :interface-eqs           13
;  :max-generation          9
;  :max-memory              8.94
;  :memory                  8.90
;  :minimized-lits          62
;  :mk-bool-var             37204
;  :mk-clause               31964
;  :num-allocs              400987
;  :num-checks              208
;  :propagations            8942
;  :quant-instantiations    10568
;  :rlimit-count            903949
;  :time                    0.01)
; Final check if taken enough permissions
; Done removing quantified permissions
; Definitional axioms for snapshot map values
; [eval] (forall i1: Int :: { aloc(opt_get1(Gf), i1) } 0 <= i1 && i1 < V ==> aloc(opt_get1(Gf), i1).option$array$ != (None(): option[array]))
(declare-const i1@198@03 Int)
(push) ; 11
; [eval] 0 <= i1 && i1 < V ==> aloc(opt_get1(Gf), i1).option$array$ != (None(): option[array])
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 12
; [then-branch: 118 | 0 <= i1@198@03 | live]
; [else-branch: 118 | !(0 <= i1@198@03) | live]
(push) ; 13
; [then-branch: 118 | 0 <= i1@198@03]
(assert (<= 0 i1@198@03))
; [eval] i1 < V
(pop) ; 13
(push) ; 13
; [else-branch: 118 | !(0 <= i1@198@03)]
(assert (not (<= 0 i1@198@03)))
(pop) ; 13
(pop) ; 12
; Joined path conditions
; Joined path conditions
(push) ; 12
; [then-branch: 119 | i1@198@03 < V@12@03 && 0 <= i1@198@03 | live]
; [else-branch: 119 | !(i1@198@03 < V@12@03 && 0 <= i1@198@03) | live]
(push) ; 13
; [then-branch: 119 | i1@198@03 < V@12@03 && 0 <= i1@198@03]
(assert (and (< i1@198@03 V@12@03) (<= 0 i1@198@03)))
; [eval] aloc(opt_get1(Gf), i1).option$array$ != (None(): option[array])
; [eval] aloc(opt_get1(Gf), i1)
; [eval] opt_get1(Gf)
(push) ; 14
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 14
; Joined path conditions
(push) ; 14
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 15
(assert (not (< i1@198@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))))
(check-sat)
; unsat
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               17462
;  :arith-add-rows          7805
;  :arith-assert-diseq      632
;  :arith-assert-lower      4235
;  :arith-assert-upper      2841
;  :arith-bound-prop        1013
;  :arith-conflicts         196
;  :arith-eq-adapter        2740
;  :arith-fixed-eqs         1841
;  :arith-offset-eqs        1291
;  :arith-pivots            2274
;  :conflicts               469
;  :datatype-accessor-ax    144
;  :datatype-constructor-ax 397
;  :datatype-occurs-check   234
;  :datatype-splits         139
;  :decisions               2561
;  :del-clause              30996
;  :final-checks            122
;  :interface-eqs           13
;  :max-generation          9
;  :max-memory              8.94
;  :memory                  8.91
;  :minimized-lits          62
;  :mk-bool-var             37206
;  :mk-clause               31964
;  :num-allocs              401097
;  :num-checks              209
;  :propagations            8942
;  :quant-instantiations    10568
;  :rlimit-count            904138)
(assert (< i1@198@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03))))
(pop) ; 14
; Joined path conditions
(assert (< i1@198@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@109@03  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@198@03)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@198@03)))
(push) ; 14
(assert (not (ite
  (and
    (<
      (inv@108@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@198@03))
      V@12@03)
    (<=
      0
      (inv@108@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@198@03))))
  (< $Perm.No $k@107@03)
  false)))
(check-sat)
; unsat
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               17486
;  :arith-add-rows          7828
;  :arith-assert-diseq      632
;  :arith-assert-lower      4240
;  :arith-assert-upper      2847
;  :arith-bound-prop        1018
;  :arith-conflicts         197
;  :arith-eq-adapter        2745
;  :arith-fixed-eqs         1846
;  :arith-offset-eqs        1291
;  :arith-pivots            2280
;  :conflicts               470
;  :datatype-accessor-ax    144
;  :datatype-constructor-ax 397
;  :datatype-occurs-check   234
;  :datatype-splits         139
;  :decisions               2561
;  :del-clause              30996
;  :final-checks            122
;  :interface-eqs           13
;  :max-generation          9
;  :max-memory              8.94
;  :memory                  8.91
;  :minimized-lits          62
;  :mk-bool-var             37303
;  :mk-clause               32018
;  :num-allocs              401809
;  :num-checks              210
;  :propagations            8943
;  :quant-instantiations    10608
;  :rlimit-count            906700)
; [eval] (None(): option[array])
(pop) ; 13
(push) ; 13
; [else-branch: 119 | !(i1@198@03 < V@12@03 && 0 <= i1@198@03)]
(assert (not (and (< i1@198@03 V@12@03) (<= 0 i1@198@03))))
(pop) ; 13
(pop) ; 12
; Joined path conditions
(assert (implies
  (and (< i1@198@03 V@12@03) (<= 0 i1@198@03))
  (and
    (< i1@198@03 V@12@03)
    (<= 0 i1@198@03)
    (< i1@198@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@109@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@198@03)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@198@03)))))
; Joined path conditions
(pop) ; 11
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@198@03 Int)) (!
  (implies
    (and (< i1@198@03 V@12@03) (<= 0 i1@198@03))
    (and
      (< i1@198@03 V@12@03)
      (<= 0 i1@198@03)
      (< i1@198@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@109@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@198@03)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@198@03))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@198@03))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(push) ; 11
(assert (not (forall ((i1@198@03 Int)) (!
  (implies
    (and (< i1@198@03 V@12@03) (<= 0 i1@198@03))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@109@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@198@03))
        (as None<option<array>>  option<array>))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@198@03))
  :qid |prog.l<no position>|))))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               17493
;  :arith-add-rows          7843
;  :arith-assert-diseq      632
;  :arith-assert-lower      4243
;  :arith-assert-upper      2848
;  :arith-bound-prop        1019
;  :arith-conflicts         197
;  :arith-eq-adapter        2746
;  :arith-fixed-eqs         1847
;  :arith-offset-eqs        1291
;  :arith-pivots            2288
;  :conflicts               471
;  :datatype-accessor-ax    144
;  :datatype-constructor-ax 397
;  :datatype-occurs-check   234
;  :datatype-splits         139
;  :decisions               2561
;  :del-clause              31099
;  :final-checks            122
;  :interface-eqs           13
;  :max-generation          9
;  :max-memory              8.94
;  :memory                  8.90
;  :minimized-lits          62
;  :mk-bool-var             37365
;  :mk-clause               32067
;  :num-allocs              402623
;  :num-checks              211
;  :propagations            8945
;  :quant-instantiations    10643
;  :rlimit-count            909092)
(assert (forall ((i1@198@03 Int)) (!
  (implies
    (and (< i1@198@03 V@12@03) (<= 0 i1@198@03))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@109@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@198@03))
        (as None<option<array>>  option<array>))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@198@03))
  :qid |prog.l<no position>|)))
; [eval] (forall i1: Int :: { alen(opt_get1(aloc(opt_get1(Gf), i1).option$array$)) } 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(Gf), i1).option$array$)) == V)
(declare-const i1@199@03 Int)
(push) ; 11
; [eval] 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(Gf), i1).option$array$)) == V
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 12
; [then-branch: 120 | 0 <= i1@199@03 | live]
; [else-branch: 120 | !(0 <= i1@199@03) | live]
(push) ; 13
; [then-branch: 120 | 0 <= i1@199@03]
(assert (<= 0 i1@199@03))
; [eval] i1 < V
(pop) ; 13
(push) ; 13
; [else-branch: 120 | !(0 <= i1@199@03)]
(assert (not (<= 0 i1@199@03)))
(pop) ; 13
(pop) ; 12
; Joined path conditions
; Joined path conditions
(push) ; 12
; [then-branch: 121 | i1@199@03 < V@12@03 && 0 <= i1@199@03 | live]
; [else-branch: 121 | !(i1@199@03 < V@12@03 && 0 <= i1@199@03) | live]
(push) ; 13
; [then-branch: 121 | i1@199@03 < V@12@03 && 0 <= i1@199@03]
(assert (and (< i1@199@03 V@12@03) (<= 0 i1@199@03)))
; [eval] alen(opt_get1(aloc(opt_get1(Gf), i1).option$array$)) == V
; [eval] alen(opt_get1(aloc(opt_get1(Gf), i1).option$array$))
; [eval] opt_get1(aloc(opt_get1(Gf), i1).option$array$)
; [eval] aloc(opt_get1(Gf), i1)
; [eval] opt_get1(Gf)
(push) ; 14
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 14
; Joined path conditions
(push) ; 14
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 15
(assert (not (< i1@199@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))))
(check-sat)
; unsat
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               17493
;  :arith-add-rows          7844
;  :arith-assert-diseq      632
;  :arith-assert-lower      4245
;  :arith-assert-upper      2848
;  :arith-bound-prop        1019
;  :arith-conflicts         197
;  :arith-eq-adapter        2746
;  :arith-fixed-eqs         1847
;  :arith-offset-eqs        1291
;  :arith-pivots            2288
;  :conflicts               471
;  :datatype-accessor-ax    144
;  :datatype-constructor-ax 397
;  :datatype-occurs-check   234
;  :datatype-splits         139
;  :decisions               2561
;  :del-clause              31099
;  :final-checks            122
;  :interface-eqs           13
;  :max-generation          9
;  :max-memory              8.94
;  :memory                  8.91
;  :minimized-lits          62
;  :mk-bool-var             37368
;  :mk-clause               32067
;  :num-allocs              402916
;  :num-checks              212
;  :propagations            8945
;  :quant-instantiations    10643
;  :rlimit-count            909590)
(assert (< i1@199@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03))))
(pop) ; 14
; Joined path conditions
(assert (< i1@199@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@109@03  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@199@03)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@199@03)))
(push) ; 14
(assert (not (ite
  (and
    (<
      (inv@108@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@199@03))
      V@12@03)
    (<=
      0
      (inv@108@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@199@03))))
  (< $Perm.No $k@107@03)
  false)))
(check-sat)
; unsat
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               17517
;  :arith-add-rows          7867
;  :arith-assert-diseq      632
;  :arith-assert-lower      4250
;  :arith-assert-upper      2854
;  :arith-bound-prop        1024
;  :arith-conflicts         198
;  :arith-eq-adapter        2751
;  :arith-fixed-eqs         1852
;  :arith-offset-eqs        1291
;  :arith-pivots            2294
;  :conflicts               472
;  :datatype-accessor-ax    144
;  :datatype-constructor-ax 397
;  :datatype-occurs-check   234
;  :datatype-splits         139
;  :decisions               2561
;  :del-clause              31099
;  :final-checks            122
;  :interface-eqs           13
;  :max-generation          9
;  :max-memory              8.94
;  :memory                  8.91
;  :minimized-lits          62
;  :mk-bool-var             37465
;  :mk-clause               32121
;  :num-allocs              403635
;  :num-checks              213
;  :propagations            8946
;  :quant-instantiations    10684
;  :rlimit-count            912244)
(push) ; 14
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 15
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@109@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@199@03))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               17517
;  :arith-add-rows          7867
;  :arith-assert-diseq      632
;  :arith-assert-lower      4250
;  :arith-assert-upper      2854
;  :arith-bound-prop        1024
;  :arith-conflicts         198
;  :arith-eq-adapter        2751
;  :arith-fixed-eqs         1852
;  :arith-offset-eqs        1291
;  :arith-pivots            2294
;  :conflicts               473
;  :datatype-accessor-ax    144
;  :datatype-constructor-ax 397
;  :datatype-occurs-check   234
;  :datatype-splits         139
;  :decisions               2561
;  :del-clause              31099
;  :final-checks            122
;  :interface-eqs           13
;  :max-generation          9
;  :max-memory              8.94
;  :memory                  8.91
;  :minimized-lits          62
;  :mk-bool-var             37465
;  :mk-clause               32121
;  :num-allocs              403725
;  :num-checks              214
;  :propagations            8946
;  :quant-instantiations    10684
;  :rlimit-count            912339)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@109@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@199@03))
    (as None<option<array>>  option<array>))))
(pop) ; 14
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@109@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@199@03))
    (as None<option<array>>  option<array>))))
(pop) ; 13
(push) ; 13
; [else-branch: 121 | !(i1@199@03 < V@12@03 && 0 <= i1@199@03)]
(assert (not (and (< i1@199@03 V@12@03) (<= 0 i1@199@03))))
(pop) ; 13
(pop) ; 12
; Joined path conditions
(assert (implies
  (and (< i1@199@03 V@12@03) (<= 0 i1@199@03))
  (and
    (< i1@199@03 V@12@03)
    (<= 0 i1@199@03)
    (< i1@199@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@109@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@199@03)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@199@03))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@109@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@199@03))
        (as None<option<array>>  option<array>))))))
; Joined path conditions
(pop) ; 11
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@199@03 Int)) (!
  (implies
    (and (< i1@199@03 V@12@03) (<= 0 i1@199@03))
    (and
      (< i1@199@03 V@12@03)
      (<= 0 i1@199@03)
      (< i1@199@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@109@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@199@03)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@199@03))
      (not
        (=
          ($FVF.lookup_option$array$ (as sm@109@03  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@199@03))
          (as None<option<array>>  option<array>)))))
  :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@109@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@199@03)))))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(push) ; 11
(assert (not (forall ((i1@199@03 Int)) (!
  (implies
    (and (< i1@199@03 V@12@03) (<= 0 i1@199@03))
    (=
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@109@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@199@03))))
      V@12@03))
  :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@109@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@199@03)))))
  :qid |prog.l<no position>|))))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               17517
;  :arith-add-rows          7876
;  :arith-assert-diseq      632
;  :arith-assert-lower      4252
;  :arith-assert-upper      2854
;  :arith-bound-prop        1024
;  :arith-conflicts         198
;  :arith-eq-adapter        2752
;  :arith-fixed-eqs         1852
;  :arith-offset-eqs        1291
;  :arith-pivots            2300
;  :conflicts               474
;  :datatype-accessor-ax    144
;  :datatype-constructor-ax 397
;  :datatype-occurs-check   234
;  :datatype-splits         139
;  :decisions               2561
;  :del-clause              31163
;  :final-checks            122
;  :interface-eqs           13
;  :max-generation          9
;  :max-memory              8.94
;  :memory                  8.90
;  :minimized-lits          62
;  :mk-bool-var             37490
;  :mk-clause               32131
;  :num-allocs              404240
;  :num-checks              215
;  :propagations            8946
;  :quant-instantiations    10703
;  :rlimit-count            913655)
(assert (forall ((i1@199@03 Int)) (!
  (implies
    (and (< i1@199@03 V@12@03) (<= 0 i1@199@03))
    (=
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@109@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@199@03))))
      V@12@03))
  :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@109@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@199@03)))))
  :qid |prog.l<no position>|)))
; [eval] (forall i1: Int :: { aloc(opt_get1(Gf), i1) } (forall i2: Int :: { aloc(opt_get1(Gf), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(Gf), i1).option$array$ == aloc(opt_get1(Gf), i2).option$array$ ==> i1 == i2))
(declare-const i1@200@03 Int)
(push) ; 11
; [eval] (forall i2: Int :: { aloc(opt_get1(Gf), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(Gf), i1).option$array$ == aloc(opt_get1(Gf), i2).option$array$ ==> i1 == i2)
(declare-const i2@201@03 Int)
(push) ; 12
; [eval] 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(Gf), i1).option$array$ == aloc(opt_get1(Gf), i2).option$array$ ==> i1 == i2
; [eval] 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(Gf), i1).option$array$ == aloc(opt_get1(Gf), i2).option$array$
; [eval] 0 <= i1
(push) ; 13
; [then-branch: 122 | 0 <= i1@200@03 | live]
; [else-branch: 122 | !(0 <= i1@200@03) | live]
(push) ; 14
; [then-branch: 122 | 0 <= i1@200@03]
(assert (<= 0 i1@200@03))
; [eval] i1 < V
(push) ; 15
; [then-branch: 123 | i1@200@03 < V@12@03 | live]
; [else-branch: 123 | !(i1@200@03 < V@12@03) | live]
(push) ; 16
; [then-branch: 123 | i1@200@03 < V@12@03]
(assert (< i1@200@03 V@12@03))
; [eval] 0 <= i2
(push) ; 17
; [then-branch: 124 | 0 <= i2@201@03 | live]
; [else-branch: 124 | !(0 <= i2@201@03) | live]
(push) ; 18
; [then-branch: 124 | 0 <= i2@201@03]
(assert (<= 0 i2@201@03))
; [eval] i2 < V
(push) ; 19
; [then-branch: 125 | i2@201@03 < V@12@03 | live]
; [else-branch: 125 | !(i2@201@03 < V@12@03) | live]
(push) ; 20
; [then-branch: 125 | i2@201@03 < V@12@03]
(assert (< i2@201@03 V@12@03))
; [eval] aloc(opt_get1(Gf), i1).option$array$ == aloc(opt_get1(Gf), i2).option$array$
; [eval] aloc(opt_get1(Gf), i1)
; [eval] opt_get1(Gf)
(push) ; 21
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 21
; Joined path conditions
(push) ; 21
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 22
(assert (not (< i1@200@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))))
(check-sat)
; unsat
(pop) ; 22
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               17517
;  :arith-add-rows          7878
;  :arith-assert-diseq      632
;  :arith-assert-lower      4256
;  :arith-assert-upper      2854
;  :arith-bound-prop        1024
;  :arith-conflicts         198
;  :arith-eq-adapter        2752
;  :arith-fixed-eqs         1852
;  :arith-offset-eqs        1291
;  :arith-pivots            2300
;  :conflicts               474
;  :datatype-accessor-ax    144
;  :datatype-constructor-ax 397
;  :datatype-occurs-check   234
;  :datatype-splits         139
;  :decisions               2561
;  :del-clause              31163
;  :final-checks            122
;  :interface-eqs           13
;  :max-generation          9
;  :max-memory              8.94
;  :memory                  8.90
;  :minimized-lits          62
;  :mk-bool-var             37495
;  :mk-clause               32131
;  :num-allocs              404709
;  :num-checks              216
;  :propagations            8946
;  :quant-instantiations    10703
;  :rlimit-count            914298)
(assert (< i1@200@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03))))
(pop) ; 21
; Joined path conditions
(assert (< i1@200@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@109@03  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@200@03)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@200@03)))
(push) ; 21
(assert (not (ite
  (and
    (<
      (inv@108@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@200@03))
      V@12@03)
    (<=
      0
      (inv@108@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@200@03))))
  (< $Perm.No $k@107@03)
  false)))
(check-sat)
; unsat
(pop) ; 21
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               17542
;  :arith-add-rows          7901
;  :arith-assert-diseq      632
;  :arith-assert-lower      4261
;  :arith-assert-upper      2860
;  :arith-bound-prop        1029
;  :arith-conflicts         199
;  :arith-eq-adapter        2757
;  :arith-fixed-eqs         1857
;  :arith-offset-eqs        1291
;  :arith-pivots            2306
;  :conflicts               475
;  :datatype-accessor-ax    144
;  :datatype-constructor-ax 397
;  :datatype-occurs-check   234
;  :datatype-splits         139
;  :decisions               2561
;  :del-clause              31163
;  :final-checks            122
;  :interface-eqs           13
;  :max-generation          9
;  :max-memory              8.94
;  :memory                  8.90
;  :minimized-lits          62
;  :mk-bool-var             37593
;  :mk-clause               32185
;  :num-allocs              405427
;  :num-checks              217
;  :propagations            8947
;  :quant-instantiations    10744
;  :rlimit-count            916960)
; [eval] aloc(opt_get1(Gf), i2)
; [eval] opt_get1(Gf)
(push) ; 21
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 21
; Joined path conditions
(push) ; 21
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 22
(assert (not (< i2@201@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))))
(check-sat)
; unsat
(pop) ; 22
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               17542
;  :arith-add-rows          7901
;  :arith-assert-diseq      632
;  :arith-assert-lower      4261
;  :arith-assert-upper      2860
;  :arith-bound-prop        1029
;  :arith-conflicts         199
;  :arith-eq-adapter        2757
;  :arith-fixed-eqs         1857
;  :arith-offset-eqs        1291
;  :arith-pivots            2306
;  :conflicts               475
;  :datatype-accessor-ax    144
;  :datatype-constructor-ax 397
;  :datatype-occurs-check   234
;  :datatype-splits         139
;  :decisions               2561
;  :del-clause              31163
;  :final-checks            122
;  :interface-eqs           13
;  :max-generation          9
;  :max-memory              8.94
;  :memory                  8.90
;  :minimized-lits          62
;  :mk-bool-var             37593
;  :mk-clause               32185
;  :num-allocs              405453
;  :num-checks              218
;  :propagations            8947
;  :quant-instantiations    10744
;  :rlimit-count            916990)
(assert (< i2@201@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03))))
(pop) ; 21
; Joined path conditions
(assert (< i2@201@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@109@03  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@201@03)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@201@03)))
(push) ; 21
(assert (not (ite
  (and
    (<
      (inv@108@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@201@03))
      V@12@03)
    (<=
      0
      (inv@108@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@201@03))))
  (< $Perm.No $k@107@03)
  false)))
(check-sat)
; unsat
(pop) ; 21
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               17566
;  :arith-add-rows          7926
;  :arith-assert-diseq      632
;  :arith-assert-lower      4266
;  :arith-assert-upper      2866
;  :arith-bound-prop        1034
;  :arith-conflicts         200
;  :arith-eq-adapter        2763
;  :arith-fixed-eqs         1862
;  :arith-offset-eqs        1291
;  :arith-pivots            2312
;  :conflicts               476
;  :datatype-accessor-ax    144
;  :datatype-constructor-ax 397
;  :datatype-occurs-check   234
;  :datatype-splits         139
;  :decisions               2561
;  :del-clause              31163
;  :final-checks            122
;  :interface-eqs           13
;  :max-generation          9
;  :max-memory              8.94
;  :memory                  8.91
;  :minimized-lits          62
;  :mk-bool-var             37713
;  :mk-clause               32255
;  :num-allocs              406232
;  :num-checks              219
;  :propagations            8954
;  :quant-instantiations    10793
;  :rlimit-count            920192)
(pop) ; 20
(push) ; 20
; [else-branch: 125 | !(i2@201@03 < V@12@03)]
(assert (not (< i2@201@03 V@12@03)))
(pop) ; 20
(pop) ; 19
; Joined path conditions
(assert (implies
  (< i2@201@03 V@12@03)
  (and
    (< i2@201@03 V@12@03)
    (< i1@200@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@109@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@200@03)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@200@03))
    (< i2@201@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@109@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@201@03)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@201@03)))))
; Joined path conditions
(pop) ; 18
(push) ; 18
; [else-branch: 124 | !(0 <= i2@201@03)]
(assert (not (<= 0 i2@201@03)))
(pop) ; 18
(pop) ; 17
; Joined path conditions
(assert (implies
  (<= 0 i2@201@03)
  (and
    (<= 0 i2@201@03)
    (implies
      (< i2@201@03 V@12@03)
      (and
        (< i2@201@03 V@12@03)
        (< i1@200@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@109@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@200@03)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@200@03))
        (< i2@201@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@109@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@201@03)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@201@03)))))))
; Joined path conditions
(pop) ; 16
(push) ; 16
; [else-branch: 123 | !(i1@200@03 < V@12@03)]
(assert (not (< i1@200@03 V@12@03)))
(pop) ; 16
(pop) ; 15
; Joined path conditions
(assert (implies
  (< i1@200@03 V@12@03)
  (and
    (< i1@200@03 V@12@03)
    (implies
      (<= 0 i2@201@03)
      (and
        (<= 0 i2@201@03)
        (implies
          (< i2@201@03 V@12@03)
          (and
            (< i2@201@03 V@12@03)
            (< i1@200@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@109@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@200@03)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@200@03))
            (< i2@201@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@109@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@201@03)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@201@03)))))))))
; Joined path conditions
(pop) ; 14
(push) ; 14
; [else-branch: 122 | !(0 <= i1@200@03)]
(assert (not (<= 0 i1@200@03)))
(pop) ; 14
(pop) ; 13
; Joined path conditions
(assert (implies
  (<= 0 i1@200@03)
  (and
    (<= 0 i1@200@03)
    (implies
      (< i1@200@03 V@12@03)
      (and
        (< i1@200@03 V@12@03)
        (implies
          (<= 0 i2@201@03)
          (and
            (<= 0 i2@201@03)
            (implies
              (< i2@201@03 V@12@03)
              (and
                (< i2@201@03 V@12@03)
                (< i1@200@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@109@03  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@200@03)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@200@03))
                (< i2@201@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@109@03  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@201@03)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@201@03)))))))))))
; Joined path conditions
(push) ; 13
; [then-branch: 126 | Lookup(option$array$,sm@109@03,aloc((_, _), opt_get1(_, Gf@11@03), i1@200@03)) == Lookup(option$array$,sm@109@03,aloc((_, _), opt_get1(_, Gf@11@03), i2@201@03)) && i2@201@03 < V@12@03 && 0 <= i2@201@03 && i1@200@03 < V@12@03 && 0 <= i1@200@03 | live]
; [else-branch: 126 | !(Lookup(option$array$,sm@109@03,aloc((_, _), opt_get1(_, Gf@11@03), i1@200@03)) == Lookup(option$array$,sm@109@03,aloc((_, _), opt_get1(_, Gf@11@03), i2@201@03)) && i2@201@03 < V@12@03 && 0 <= i2@201@03 && i1@200@03 < V@12@03 && 0 <= i1@200@03) | live]
(push) ; 14
; [then-branch: 126 | Lookup(option$array$,sm@109@03,aloc((_, _), opt_get1(_, Gf@11@03), i1@200@03)) == Lookup(option$array$,sm@109@03,aloc((_, _), opt_get1(_, Gf@11@03), i2@201@03)) && i2@201@03 < V@12@03 && 0 <= i2@201@03 && i1@200@03 < V@12@03 && 0 <= i1@200@03]
(assert (and
  (and
    (and
      (and
        (=
          ($FVF.lookup_option$array$ (as sm@109@03  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@200@03))
          ($FVF.lookup_option$array$ (as sm@109@03  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@201@03)))
        (< i2@201@03 V@12@03))
      (<= 0 i2@201@03))
    (< i1@200@03 V@12@03))
  (<= 0 i1@200@03)))
; [eval] i1 == i2
(pop) ; 14
(push) ; 14
; [else-branch: 126 | !(Lookup(option$array$,sm@109@03,aloc((_, _), opt_get1(_, Gf@11@03), i1@200@03)) == Lookup(option$array$,sm@109@03,aloc((_, _), opt_get1(_, Gf@11@03), i2@201@03)) && i2@201@03 < V@12@03 && 0 <= i2@201@03 && i1@200@03 < V@12@03 && 0 <= i1@200@03)]
(assert (not
  (and
    (and
      (and
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@109@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@200@03))
            ($FVF.lookup_option$array$ (as sm@109@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@201@03)))
          (< i2@201@03 V@12@03))
        (<= 0 i2@201@03))
      (< i1@200@03 V@12@03))
    (<= 0 i1@200@03))))
(pop) ; 14
(pop) ; 13
; Joined path conditions
(assert (implies
  (and
    (and
      (and
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@109@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@200@03))
            ($FVF.lookup_option$array$ (as sm@109@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@201@03)))
          (< i2@201@03 V@12@03))
        (<= 0 i2@201@03))
      (< i1@200@03 V@12@03))
    (<= 0 i1@200@03))
  (and
    (=
      ($FVF.lookup_option$array$ (as sm@109@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@200@03))
      ($FVF.lookup_option$array$ (as sm@109@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@201@03)))
    (< i2@201@03 V@12@03)
    (<= 0 i2@201@03)
    (< i1@200@03 V@12@03)
    (<= 0 i1@200@03))))
; Joined path conditions
(pop) ; 12
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i2@201@03 Int)) (!
  (and
    (implies
      (<= 0 i1@200@03)
      (and
        (<= 0 i1@200@03)
        (implies
          (< i1@200@03 V@12@03)
          (and
            (< i1@200@03 V@12@03)
            (implies
              (<= 0 i2@201@03)
              (and
                (<= 0 i2@201@03)
                (implies
                  (< i2@201@03 V@12@03)
                  (and
                    (< i2@201@03 V@12@03)
                    (< i1@200@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))
                    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@109@03  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@200@03)) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@200@03))
                    (< i2@201@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))
                    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@109@03  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@201@03)) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@201@03))))))))))
    (implies
      (and
        (and
          (and
            (and
              (=
                ($FVF.lookup_option$array$ (as sm@109@03  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@200@03))
                ($FVF.lookup_option$array$ (as sm@109@03  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@201@03)))
              (< i2@201@03 V@12@03))
            (<= 0 i2@201@03))
          (< i1@200@03 V@12@03))
        (<= 0 i1@200@03))
      (and
        (=
          ($FVF.lookup_option$array$ (as sm@109@03  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@200@03))
          ($FVF.lookup_option$array$ (as sm@109@03  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@201@03)))
        (< i2@201@03 V@12@03)
        (<= 0 i2@201@03)
        (< i1@200@03 V@12@03)
        (<= 0 i1@200@03))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@201@03))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 11
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@200@03 Int)) (!
  (forall ((i2@201@03 Int)) (!
    (and
      (implies
        (<= 0 i1@200@03)
        (and
          (<= 0 i1@200@03)
          (implies
            (< i1@200@03 V@12@03)
            (and
              (< i1@200@03 V@12@03)
              (implies
                (<= 0 i2@201@03)
                (and
                  (<= 0 i2@201@03)
                  (implies
                    (< i2@201@03 V@12@03)
                    (and
                      (< i2@201@03 V@12@03)
                      (< i1@200@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))
                      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@109@03  $FVF<option<array>>) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@200@03)) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@200@03))
                      (< i2@201@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))
                      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@109@03  $FVF<option<array>>) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@201@03)) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@201@03))))))))))
      (implies
        (and
          (and
            (and
              (and
                (=
                  ($FVF.lookup_option$array$ (as sm@109@03  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@200@03))
                  ($FVF.lookup_option$array$ (as sm@109@03  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@201@03)))
                (< i2@201@03 V@12@03))
              (<= 0 i2@201@03))
            (< i1@200@03 V@12@03))
          (<= 0 i1@200@03))
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@109@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@200@03))
            ($FVF.lookup_option$array$ (as sm@109@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@201@03)))
          (< i2@201@03 V@12@03)
          (<= 0 i2@201@03)
          (< i1@200@03 V@12@03)
          (<= 0 i1@200@03))))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@201@03))
    :qid |prog.l<no position>-aux|))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@200@03))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(push) ; 11
(assert (not (forall ((i1@200@03 Int)) (!
  (forall ((i2@201@03 Int)) (!
    (implies
      (and
        (and
          (and
            (and
              (=
                ($FVF.lookup_option$array$ (as sm@109@03  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@200@03))
                ($FVF.lookup_option$array$ (as sm@109@03  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@201@03)))
              (< i2@201@03 V@12@03))
            (<= 0 i2@201@03))
          (< i1@200@03 V@12@03))
        (<= 0 i1@200@03))
      (= i1@200@03 i2@201@03))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@201@03))
    :qid |prog.l<no position>|))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@200@03))
  :qid |prog.l<no position>|))))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               17600
;  :arith-add-rows          7960
;  :arith-assert-diseq      634
;  :arith-assert-lower      4272
;  :arith-assert-upper      2868
;  :arith-bound-prop        1036
;  :arith-conflicts         200
;  :arith-eq-adapter        2774
;  :arith-fixed-eqs         1864
;  :arith-offset-eqs        1291
;  :arith-pivots            2328
;  :conflicts               477
;  :datatype-accessor-ax    144
;  :datatype-constructor-ax 397
;  :datatype-occurs-check   234
;  :datatype-splits         139
;  :decisions               2561
;  :del-clause              31423
;  :final-checks            122
;  :interface-eqs           13
;  :max-generation          9
;  :max-memory              8.94
;  :memory                  8.90
;  :minimized-lits          62
;  :mk-bool-var             37940
;  :mk-clause               32391
;  :num-allocs              408224
;  :num-checks              220
;  :propagations            8962
;  :quant-instantiations    10886
;  :rlimit-count            927570
;  :time                    0.00)
(assert (forall ((i1@200@03 Int)) (!
  (forall ((i2@201@03 Int)) (!
    (implies
      (and
        (and
          (and
            (and
              (=
                ($FVF.lookup_option$array$ (as sm@109@03  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@200@03))
                ($FVF.lookup_option$array$ (as sm@109@03  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@201@03)))
              (< i2@201@03 V@12@03))
            (<= 0 i2@201@03))
          (< i1@200@03 V@12@03))
        (<= 0 i1@200@03))
      (= i1@200@03 i2@201@03))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@201@03))
    :qid |prog.l<no position>|))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@200@03))
  :qid |prog.l<no position>|)))
; [eval] p != (None(): option[array])
; [eval] (None(): option[array])
; [eval] alen(opt_get1(p)) == V
; [eval] alen(opt_get1(p))
; [eval] opt_get1(p)
(push) ; 11
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 11
; Joined path conditions
; [eval] 0 <= s
; [eval] s < V
; [eval] 0 <= t
; [eval] t < V
(declare-const i1@202@03 Int)
(declare-const j1@203@03 Int)
(push) ; 11
; [eval] 0 <= i1 && i1 < V && (0 <= j1 && j1 < V)
; [eval] 0 <= i1
(push) ; 12
; [then-branch: 127 | 0 <= i1@202@03 | live]
; [else-branch: 127 | !(0 <= i1@202@03) | live]
(push) ; 13
; [then-branch: 127 | 0 <= i1@202@03]
(assert (<= 0 i1@202@03))
; [eval] i1 < V
(push) ; 14
; [then-branch: 128 | i1@202@03 < V@12@03 | live]
; [else-branch: 128 | !(i1@202@03 < V@12@03) | live]
(push) ; 15
; [then-branch: 128 | i1@202@03 < V@12@03]
(assert (< i1@202@03 V@12@03))
; [eval] 0 <= j1
(push) ; 16
; [then-branch: 129 | 0 <= j1@203@03 | live]
; [else-branch: 129 | !(0 <= j1@203@03) | live]
(push) ; 17
; [then-branch: 129 | 0 <= j1@203@03]
(assert (<= 0 j1@203@03))
; [eval] j1 < V
(pop) ; 17
(push) ; 17
; [else-branch: 129 | !(0 <= j1@203@03)]
(assert (not (<= 0 j1@203@03)))
(pop) ; 17
(pop) ; 16
; Joined path conditions
; Joined path conditions
(pop) ; 15
(push) ; 15
; [else-branch: 128 | !(i1@202@03 < V@12@03)]
(assert (not (< i1@202@03 V@12@03)))
(pop) ; 15
(pop) ; 14
; Joined path conditions
; Joined path conditions
(pop) ; 13
(push) ; 13
; [else-branch: 127 | !(0 <= i1@202@03)]
(assert (not (<= 0 i1@202@03)))
(pop) ; 13
(pop) ; 12
; Joined path conditions
; Joined path conditions
(assert (and
  (and (and (< j1@203@03 V@12@03) (<= 0 j1@203@03)) (< i1@202@03 V@12@03))
  (<= 0 i1@202@03)))
; [eval] aloc(opt_get1(aloc(opt_get1(Gf), i1).option$array$), j1)
; [eval] opt_get1(aloc(opt_get1(Gf), i1).option$array$)
; [eval] aloc(opt_get1(Gf), i1)
; [eval] opt_get1(Gf)
(push) ; 12
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 12
; Joined path conditions
(push) ; 12
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 13
(assert (not (< i1@202@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))))
(check-sat)
; unsat
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               17600
;  :arith-add-rows          7963
;  :arith-assert-diseq      634
;  :arith-assert-lower      4278
;  :arith-assert-upper      2868
;  :arith-bound-prop        1036
;  :arith-conflicts         200
;  :arith-eq-adapter        2774
;  :arith-fixed-eqs         1864
;  :arith-offset-eqs        1291
;  :arith-pivots            2328
;  :conflicts               477
;  :datatype-accessor-ax    144
;  :datatype-constructor-ax 397
;  :datatype-occurs-check   234
;  :datatype-splits         139
;  :decisions               2561
;  :del-clause              31423
;  :final-checks            122
;  :interface-eqs           13
;  :max-generation          9
;  :max-memory              8.94
;  :memory                  8.90
;  :minimized-lits          62
;  :mk-bool-var             37947
;  :mk-clause               32391
;  :num-allocs              408825
;  :num-checks              221
;  :propagations            8962
;  :quant-instantiations    10886
;  :rlimit-count            928574)
(assert (< i1@202@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03))))
(pop) ; 12
; Joined path conditions
(assert (< i1@202@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@109@03  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@202@03)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@202@03)))
(push) ; 12
(assert (not (ite
  (and
    (<
      (inv@108@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@202@03))
      V@12@03)
    (<=
      0
      (inv@108@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@202@03))))
  (< $Perm.No $k@107@03)
  false)))
(check-sat)
; unsat
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               17624
;  :arith-add-rows          7986
;  :arith-assert-diseq      634
;  :arith-assert-lower      4283
;  :arith-assert-upper      2874
;  :arith-bound-prop        1041
;  :arith-conflicts         201
;  :arith-eq-adapter        2779
;  :arith-fixed-eqs         1869
;  :arith-offset-eqs        1291
;  :arith-pivots            2334
;  :conflicts               478
;  :datatype-accessor-ax    144
;  :datatype-constructor-ax 397
;  :datatype-occurs-check   234
;  :datatype-splits         139
;  :decisions               2561
;  :del-clause              31423
;  :final-checks            122
;  :interface-eqs           13
;  :max-generation          9
;  :max-memory              8.94
;  :memory                  8.91
;  :minimized-lits          62
;  :mk-bool-var             38046
;  :mk-clause               32445
;  :num-allocs              409617
;  :num-checks              222
;  :propagations            8963
;  :quant-instantiations    10930
;  :rlimit-count            931538)
(push) ; 12
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 13
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@109@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@202@03))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               17624
;  :arith-add-rows          7986
;  :arith-assert-diseq      634
;  :arith-assert-lower      4283
;  :arith-assert-upper      2874
;  :arith-bound-prop        1041
;  :arith-conflicts         201
;  :arith-eq-adapter        2779
;  :arith-fixed-eqs         1869
;  :arith-offset-eqs        1291
;  :arith-pivots            2334
;  :conflicts               479
;  :datatype-accessor-ax    144
;  :datatype-constructor-ax 397
;  :datatype-occurs-check   234
;  :datatype-splits         139
;  :decisions               2561
;  :del-clause              31423
;  :final-checks            122
;  :interface-eqs           13
;  :max-generation          9
;  :max-memory              8.94
;  :memory                  8.91
;  :minimized-lits          62
;  :mk-bool-var             38046
;  :mk-clause               32445
;  :num-allocs              409706
;  :num-checks              223
;  :propagations            8963
;  :quant-instantiations    10930
;  :rlimit-count            931633)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@109@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@202@03))
    (as None<option<array>>  option<array>))))
(pop) ; 12
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@109@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@202@03))
    (as None<option<array>>  option<array>))))
(push) ; 12
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 13
(assert (not (<
  j1@203@03
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@109@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@202@03)))))))
(check-sat)
; unsat
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               17630
;  :arith-add-rows          7992
;  :arith-assert-diseq      634
;  :arith-assert-lower      4285
;  :arith-assert-upper      2876
;  :arith-bound-prop        1041
;  :arith-conflicts         202
;  :arith-eq-adapter        2780
;  :arith-fixed-eqs         1870
;  :arith-offset-eqs        1291
;  :arith-pivots            2338
;  :conflicts               480
;  :datatype-accessor-ax    144
;  :datatype-constructor-ax 397
;  :datatype-occurs-check   234
;  :datatype-splits         139
;  :decisions               2561
;  :del-clause              31427
;  :final-checks            122
;  :interface-eqs           13
;  :max-generation          9
;  :max-memory              8.94
;  :memory                  8.91
;  :minimized-lits          62
;  :mk-bool-var             38057
;  :mk-clause               32449
;  :num-allocs              409901
;  :num-checks              224
;  :propagations            8965
;  :quant-instantiations    10939
;  :rlimit-count            932204)
(assert (<
  j1@203@03
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@109@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@202@03))))))
(pop) ; 12
; Joined path conditions
(assert (<
  j1@203@03
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@109@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@202@03))))))
(pop) ; 11
(declare-fun inv@204@03 ($Ref) Int)
(declare-fun inv@205@03 ($Ref) Int)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(assert (forall ((i1@202@03 Int) (j1@203@03 Int)) (!
  (and
    (< i1@202@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@109@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@202@03)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@202@03))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@109@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@202@03))
        (as None<option<array>>  option<array>)))
    (<
      j1@203@03
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@109@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@202@03))))))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@109@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@202@03))) j1@203@03))
  :qid |int-aux|)))
(declare-const sm@206@03 $FVF<Int>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@117@03 r) V@12@03) (<= 0 (inv@117@03 r)))
        (< (inv@116@03 r) V@12@03))
      (<= 0 (inv@116@03 r)))
    (=
      ($FVF.lookup_int (as sm@206@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@206@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03))))))))))))))) r))
  :qid |qp.fvfValDef74|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@120@03 r) V@12@03) (<= 0 (inv@120@03 r)))
    (=
      ($FVF.lookup_int (as sm@206@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03)))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@206@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03)))))))))))))))) r))
  :qid |qp.fvfValDef75|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03)))))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@206@03  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef76|)))
; Check receiver injectivity
(push) ; 11
(assert (not (forall ((i11@202@03 Int) (j11@203@03 Int) (i12@202@03 Int) (j12@203@03 Int)) (!
  (implies
    (and
      (and
        (and
          (and
            (and (< j11@203@03 V@12@03) (<= 0 j11@203@03))
            (< i11@202@03 V@12@03))
          (<= 0 i11@202@03))
        ($FVF.loc_int ($FVF.lookup_int (as sm@206@03  $FVF<Int>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@109@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i11@202@03))) j11@203@03)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@109@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i11@202@03))) j11@203@03)))
      (and
        (and
          (and
            (and (< j12@203@03 V@12@03) (<= 0 j12@203@03))
            (< i12@202@03 V@12@03))
          (<= 0 i12@202@03))
        ($FVF.loc_int ($FVF.lookup_int (as sm@206@03  $FVF<Int>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@109@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i12@202@03))) j12@203@03)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@109@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i12@202@03))) j12@203@03)))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@109@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i11@202@03))) j11@203@03)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@109@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i12@202@03))) j12@203@03)))
    (and (= i11@202@03 i12@202@03) (= j11@203@03 j12@203@03)))
  
  :qid |int-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               17678
;  :arith-add-rows          8021
;  :arith-assert-diseq      634
;  :arith-assert-lower      4294
;  :arith-assert-upper      2877
;  :arith-bound-prop        1041
;  :arith-conflicts         202
;  :arith-eq-adapter        2790
;  :arith-fixed-eqs         1870
;  :arith-offset-eqs        1291
;  :arith-pivots            2348
;  :conflicts               481
;  :datatype-accessor-ax    144
;  :datatype-constructor-ax 397
;  :datatype-occurs-check   234
;  :datatype-splits         139
;  :decisions               2561
;  :del-clause              31578
;  :final-checks            122
;  :interface-eqs           13
;  :max-generation          9
;  :max-memory              8.94
;  :memory                  8.90
;  :minimized-lits          62
;  :mk-bool-var             38231
;  :mk-clause               32546
;  :num-allocs              411850
;  :num-checks              225
;  :propagations            8981
;  :quant-instantiations    11021
;  :rlimit-count            938734
;  :time                    0.00)
; Definitional axioms for inverse functions
(assert (forall ((i1@202@03 Int) (j1@203@03 Int)) (!
  (implies
    (and
      (and (and (< j1@203@03 V@12@03) (<= 0 j1@203@03)) (< i1@202@03 V@12@03))
      (<= 0 i1@202@03))
    (and
      (=
        (inv@204@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@109@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@202@03))) j1@203@03))
        i1@202@03)
      (=
        (inv@205@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@109@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@202@03))) j1@203@03))
        j1@203@03)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@109@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@202@03))) j1@203@03))
  :qid |int-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@205@03 r) V@12@03) (<= 0 (inv@205@03 r)))
        (< (inv@204@03 r) V@12@03))
      (<= 0 (inv@204@03 r)))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@109@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) (inv@204@03 r)))) (inv@205@03 r))
      r))
  :pattern ((inv@204@03 r))
  :pattern ((inv@205@03 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@205@03 r) V@12@03) (<= 0 (inv@205@03 r)))
        (< (inv@204@03 r) V@12@03))
      (<= 0 (inv@204@03 r)))
    ($FVF.loc_int ($FVF.lookup_int (as sm@206@03  $FVF<Int>) r) r))
  :pattern ((inv@204@03 r) (inv@205@03 r))
  )))
; Precomputing data for removing quantified permissions
(define-fun pTaken@207@03 ((r $Ref)) $Perm
  (ite
    (and
      (and
        (and (< (inv@205@03 r) V@12@03) (<= 0 (inv@205@03 r)))
        (< (inv@204@03 r) V@12@03))
      (<= 0 (inv@204@03 r)))
    ($Perm.min
      (ite
        (and
          (and
            (and (< (inv@117@03 r) V@12@03) (<= 0 (inv@117@03 r)))
            (< (inv@116@03 r) V@12@03))
          (<= 0 (inv@116@03 r)))
        $Perm.Write
        $Perm.No)
      $Perm.Write)
    $Perm.No))
(define-fun pTaken@208@03 ((r $Ref)) $Perm
  (ite
    (and
      (and
        (and (< (inv@205@03 r) V@12@03) (<= 0 (inv@205@03 r)))
        (< (inv@204@03 r) V@12@03))
      (<= 0 (inv@204@03 r)))
    ($Perm.min
      (ite
        (and (< (inv@120@03 r) V@12@03) (<= 0 (inv@120@03 r)))
        $Perm.Write
        $Perm.No)
      (- $Perm.Write (pTaken@207@03 r)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 500)
(push) ; 11
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and
          (and
            (and (< (inv@117@03 r) V@12@03) (<= 0 (inv@117@03 r)))
            (< (inv@116@03 r) V@12@03))
          (<= 0 (inv@116@03 r)))
        $Perm.Write
        $Perm.No)
      (pTaken@207@03 r))
    $Perm.No)
  
  ))))
(check-sat)
; unsat
(pop) ; 11
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               19248
;  :arith-add-rows          8748
;  :arith-assert-diseq      683
;  :arith-assert-lower      4724
;  :arith-assert-upper      3149
;  :arith-bound-prop        1134
;  :arith-conflicts         210
;  :arith-eq-adapter        3099
;  :arith-fixed-eqs         2094
;  :arith-offset-eqs        1348
;  :arith-pivots            2534
;  :conflicts               510
;  :datatype-accessor-ax    144
;  :datatype-constructor-ax 405
;  :datatype-occurs-check   234
;  :datatype-splits         139
;  :decisions               2721
;  :del-clause              33837
;  :final-checks            122
;  :interface-eqs           13
;  :max-generation          9
;  :max-memory              9.21
;  :memory                  9.04
;  :minimized-lits          62
;  :mk-bool-var             41338
;  :mk-clause               34948
;  :num-allocs              425267
;  :num-checks              227
;  :propagations            9876
;  :quant-instantiations    11999
;  :rlimit-count            989499
;  :time                    0.01)
; Intermediate check if already taken enough permissions
(push) ; 11
(assert (not (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@205@03 r) V@12@03) (<= 0 (inv@205@03 r)))
        (< (inv@204@03 r) V@12@03))
      (<= 0 (inv@204@03 r)))
    (= (- $Perm.Write (pTaken@207@03 r)) $Perm.No))
  
  ))))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               19658
;  :arith-add-rows          8830
;  :arith-assert-diseq      691
;  :arith-assert-lower      4817
;  :arith-assert-upper      3209
;  :arith-bound-prop        1143
;  :arith-conflicts         212
;  :arith-eq-adapter        3174
;  :arith-fixed-eqs         2147
;  :arith-offset-eqs        1354
;  :arith-pivots            2560
;  :conflicts               527
;  :datatype-accessor-ax    144
;  :datatype-constructor-ax 409
;  :datatype-occurs-check   234
;  :datatype-splits         139
;  :decisions               2737
;  :del-clause              34238
;  :final-checks            122
;  :interface-eqs           13
;  :max-generation          9
;  :max-memory              9.21
;  :memory                  9.07
;  :minimized-lits          62
;  :mk-bool-var             41886
;  :mk-clause               35349
;  :num-allocs              427710
;  :num-checks              228
;  :propagations            10062
;  :quant-instantiations    12227
;  :rlimit-count            1001019
;  :time                    0.00)
; Final check if taken enough permissions
; Done removing quantified permissions
; Definitional axioms for snapshot map values
(declare-const i1@209@03 Int)
(push) ; 11
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 12
; [then-branch: 130 | 0 <= i1@209@03 | live]
; [else-branch: 130 | !(0 <= i1@209@03) | live]
(push) ; 13
; [then-branch: 130 | 0 <= i1@209@03]
(assert (<= 0 i1@209@03))
; [eval] i1 < V
(pop) ; 13
(push) ; 13
; [else-branch: 130 | !(0 <= i1@209@03)]
(assert (not (<= 0 i1@209@03)))
(pop) ; 13
(pop) ; 12
; Joined path conditions
; Joined path conditions
(assert (and (< i1@209@03 V@12@03) (<= 0 i1@209@03)))
; [eval] aloc(opt_get1(p), i1)
; [eval] opt_get1(p)
(push) ; 12
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 12
; Joined path conditions
(push) ; 12
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 13
(assert (not (< i1@209@03 (alen<Int> (opt_get1 $Snap.unit p@15@03)))))
(check-sat)
; unsat
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               19658
;  :arith-add-rows          8831
;  :arith-assert-diseq      691
;  :arith-assert-lower      4819
;  :arith-assert-upper      3209
;  :arith-bound-prop        1143
;  :arith-conflicts         212
;  :arith-eq-adapter        3174
;  :arith-fixed-eqs         2147
;  :arith-offset-eqs        1354
;  :arith-pivots            2560
;  :conflicts               527
;  :datatype-accessor-ax    144
;  :datatype-constructor-ax 409
;  :datatype-occurs-check   234
;  :datatype-splits         139
;  :decisions               2737
;  :del-clause              34238
;  :final-checks            122
;  :interface-eqs           13
;  :max-generation          9
;  :max-memory              9.21
;  :memory                  9.07
;  :minimized-lits          62
;  :mk-bool-var             41888
;  :mk-clause               35349
;  :num-allocs              427821
;  :num-checks              229
;  :propagations            10062
;  :quant-instantiations    12227
;  :rlimit-count            1001200)
(assert (< i1@209@03 (alen<Int> (opt_get1 $Snap.unit p@15@03))))
(pop) ; 12
; Joined path conditions
(assert (< i1@209@03 (alen<Int> (opt_get1 $Snap.unit p@15@03))))
(pop) ; 11
(declare-fun inv@210@03 ($Ref) Int)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(assert (forall ((i1@209@03 Int)) (!
  (< i1@209@03 (alen<Int> (opt_get1 $Snap.unit p@15@03)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) i1@209@03))
  :qid |int-aux|)))
(declare-const sm@211@03 $FVF<Int>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@120@03 r) V@12@03) (<= 0 (inv@120@03 r)))
    (=
      ($FVF.lookup_int (as sm@211@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03)))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@211@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03)))))))))))))))) r))
  :qid |qp.fvfValDef77|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03)))))))))))))))) r) r)
  :pattern (($FVF.lookup_int (as sm@211@03  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef78|)))
; Check receiver injectivity
(push) ; 11
(assert (not (forall ((i11@209@03 Int) (i12@209@03 Int)) (!
  (implies
    (and
      (and
        (and (< i11@209@03 V@12@03) (<= 0 i11@209@03))
        ($FVF.loc_int ($FVF.lookup_int (as sm@211@03  $FVF<Int>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit p@15@03) i11@209@03)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit p@15@03) i11@209@03)))
      (and
        (and (< i12@209@03 V@12@03) (<= 0 i12@209@03))
        ($FVF.loc_int ($FVF.lookup_int (as sm@211@03  $FVF<Int>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit p@15@03) i12@209@03)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit p@15@03) i12@209@03)))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) i11@209@03)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) i12@209@03)))
    (= i11@209@03 i12@209@03))
  
  :qid |int-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               19684
;  :arith-add-rows          8836
;  :arith-assert-diseq      692
;  :arith-assert-lower      4823
;  :arith-assert-upper      3209
;  :arith-bound-prop        1143
;  :arith-conflicts         212
;  :arith-eq-adapter        3175
;  :arith-fixed-eqs         2147
;  :arith-offset-eqs        1354
;  :arith-pivots            2560
;  :conflicts               528
;  :datatype-accessor-ax    144
;  :datatype-constructor-ax 409
;  :datatype-occurs-check   234
;  :datatype-splits         139
;  :decisions               2737
;  :del-clause              34245
;  :final-checks            122
;  :interface-eqs           13
;  :max-generation          9
;  :max-memory              9.21
;  :memory                  9.07
;  :minimized-lits          62
;  :mk-bool-var             41931
;  :mk-clause               35356
;  :num-allocs              428726
;  :num-checks              230
;  :propagations            10062
;  :quant-instantiations    12266
;  :rlimit-count            1003656)
; Definitional axioms for inverse functions
(assert (forall ((i1@209@03 Int)) (!
  (implies
    (and (< i1@209@03 V@12@03) (<= 0 i1@209@03))
    (=
      (inv@210@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) i1@209@03))
      i1@209@03))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) i1@209@03))
  :qid |int-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@210@03 r) V@12@03) (<= 0 (inv@210@03 r)))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) (inv@210@03 r))
      r))
  :pattern ((inv@210@03 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@210@03 r) V@12@03) (<= 0 (inv@210@03 r)))
    ($FVF.loc_int ($FVF.lookup_int (as sm@211@03  $FVF<Int>) r) r))
  :pattern ((inv@210@03 r))
  )))
; Precomputing data for removing quantified permissions
(define-fun pTaken@212@03 ((r $Ref)) $Perm
  (ite
    (and (< (inv@210@03 r) V@12@03) (<= 0 (inv@210@03 r)))
    ($Perm.min
      (ite
        (and (< (inv@120@03 r) V@12@03) (<= 0 (inv@120@03 r)))
        $Perm.Write
        $Perm.No)
      $Perm.Write)
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 500)
(push) ; 11
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and (< (inv@120@03 r) V@12@03) (<= 0 (inv@120@03 r)))
        $Perm.Write
        $Perm.No)
      (pTaken@212@03 r))
    $Perm.No)
  
  ))))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               21401
;  :arith-add-rows          9393
;  :arith-assert-diseq      746
;  :arith-assert-lower      5348
;  :arith-assert-upper      3488
;  :arith-bound-prop        1178
;  :arith-conflicts         220
;  :arith-eq-adapter        3485
;  :arith-fixed-eqs         2393
;  :arith-offset-eqs        1422
;  :arith-pivots            2661
;  :conflicts               556
;  :datatype-accessor-ax    144
;  :datatype-constructor-ax 417
;  :datatype-occurs-check   234
;  :datatype-splits         139
;  :decisions               2926
;  :del-clause              36884
;  :final-checks            122
;  :interface-eqs           13
;  :max-generation          9
;  :max-memory              9.30
;  :memory                  9.18
;  :minimized-lits          63
;  :mk-bool-var             44588
;  :mk-clause               38045
;  :num-allocs              437722
;  :num-checks              232
;  :propagations            11286
;  :quant-instantiations    13245
;  :rlimit-count            1050326
;  :time                    0.00)
; Intermediate check if already taken enough permissions
(push) ; 11
(assert (not (forall ((r $Ref)) (!
  (implies
    (and (< (inv@210@03 r) V@12@03) (<= 0 (inv@210@03 r)))
    (= (- $Perm.Write (pTaken@212@03 r)) $Perm.No))
  
  ))))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               21438
;  :arith-add-rows          9417
;  :arith-assert-diseq      748
;  :arith-assert-lower      5357
;  :arith-assert-upper      3498
;  :arith-bound-prop        1179
;  :arith-conflicts         221
;  :arith-eq-adapter        3493
;  :arith-fixed-eqs         2399
;  :arith-offset-eqs        1422
;  :arith-pivots            2665
;  :conflicts               557
;  :datatype-accessor-ax    144
;  :datatype-constructor-ax 417
;  :datatype-occurs-check   234
;  :datatype-splits         139
;  :decisions               2926
;  :del-clause              36991
;  :final-checks            122
;  :interface-eqs           13
;  :max-generation          9
;  :max-memory              9.30
;  :memory                  9.17
;  :minimized-lits          63
;  :mk-bool-var             44727
;  :mk-clause               38152
;  :num-allocs              438444
;  :num-checks              233
;  :propagations            11291
;  :quant-instantiations    13296
;  :rlimit-count            1052815
;  :time                    0.00)
; Final check if taken enough permissions
; Done removing quantified permissions
; Definitional axioms for snapshot map values
; [eval] valid_graph_vertices(this, p, V)
(push) ; 11
; [eval] this != null
; [eval] p != (None(): option[array])
; [eval] (None(): option[array])
; [eval] alen(opt_get1(p)) == V
; [eval] alen(opt_get1(p))
; [eval] opt_get1(p)
(push) ; 12
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 12
; Joined path conditions
(declare-const i1@213@03 Int)
(push) ; 12
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 13
; [then-branch: 131 | 0 <= i1@213@03 | live]
; [else-branch: 131 | !(0 <= i1@213@03) | live]
(push) ; 14
; [then-branch: 131 | 0 <= i1@213@03]
(assert (<= 0 i1@213@03))
; [eval] i1 < V
(pop) ; 14
(push) ; 14
; [else-branch: 131 | !(0 <= i1@213@03)]
(assert (not (<= 0 i1@213@03)))
(pop) ; 14
(pop) ; 13
; Joined path conditions
; Joined path conditions
(assert (and (< i1@213@03 V@12@03) (<= 0 i1@213@03)))
(declare-const $k@214@03 $Perm)
(assert ($Perm.isReadVar $k@214@03 $Perm.Write))
; [eval] aloc(opt_get1(p), i1)
; [eval] opt_get1(p)
(push) ; 13
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 13
; Joined path conditions
(push) ; 13
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 14
(assert (not (< i1@213@03 (alen<Int> (opt_get1 $Snap.unit p@15@03)))))
(check-sat)
; unsat
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               21438
;  :arith-add-rows          9418
;  :arith-assert-diseq      749
;  :arith-assert-lower      5361
;  :arith-assert-upper      3499
;  :arith-bound-prop        1179
;  :arith-conflicts         221
;  :arith-eq-adapter        3494
;  :arith-fixed-eqs         2399
;  :arith-offset-eqs        1422
;  :arith-pivots            2665
;  :conflicts               557
;  :datatype-accessor-ax    144
;  :datatype-constructor-ax 417
;  :datatype-occurs-check   234
;  :datatype-splits         139
;  :decisions               2926
;  :del-clause              36991
;  :final-checks            122
;  :interface-eqs           13
;  :max-generation          9
;  :max-memory              9.30
;  :memory                  9.17
;  :minimized-lits          63
;  :mk-bool-var             44733
;  :mk-clause               38154
;  :num-allocs              438620
;  :num-checks              234
;  :propagations            11292
;  :quant-instantiations    13296
;  :rlimit-count            1053148)
(assert (< i1@213@03 (alen<Int> (opt_get1 $Snap.unit p@15@03))))
(pop) ; 13
; Joined path conditions
(assert (< i1@213@03 (alen<Int> (opt_get1 $Snap.unit p@15@03))))
(pop) ; 12
(declare-fun inv@215@03 ($Ref) Int)
; Nested auxiliary terms: globals
(assert ($Perm.isReadVar $k@214@03 $Perm.Write))
; Nested auxiliary terms: non-globals
(assert (forall ((i1@213@03 Int)) (!
  (< i1@213@03 (alen<Int> (opt_get1 $Snap.unit p@15@03)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) i1@213@03))
  :qid |int-aux|)))
(push) ; 12
(assert (not (forall ((i1@213@03 Int)) (!
  (implies
    (and (< i1@213@03 V@12@03) (<= 0 i1@213@03))
    (or (= $k@214@03 $Perm.No) (< $Perm.No $k@214@03)))
  
  ))))
(check-sat)
; unsat
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               21438
;  :arith-add-rows          9419
;  :arith-assert-diseq      750
;  :arith-assert-lower      5363
;  :arith-assert-upper      3500
;  :arith-bound-prop        1179
;  :arith-conflicts         221
;  :arith-eq-adapter        3495
;  :arith-fixed-eqs         2399
;  :arith-offset-eqs        1422
;  :arith-pivots            2665
;  :conflicts               558
;  :datatype-accessor-ax    144
;  :datatype-constructor-ax 417
;  :datatype-occurs-check   234
;  :datatype-splits         139
;  :decisions               2926
;  :del-clause              36993
;  :final-checks            122
;  :interface-eqs           13
;  :max-generation          9
;  :max-memory              9.30
;  :memory                  9.17
;  :minimized-lits          63
;  :mk-bool-var             44740
;  :mk-clause               38156
;  :num-allocs              439045
;  :num-checks              235
;  :propagations            11293
;  :quant-instantiations    13296
;  :rlimit-count            1053695)
(declare-const sm@216@03 $FVF<Int>)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@120@03 r) V@12@03) (<= 0 (inv@120@03 r)))
    (=
      ($FVF.lookup_int (as sm@216@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03)))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@216@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03)))))))))))))))) r))
  :qid |qp.fvfValDef79|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@117@03 r) V@12@03) (<= 0 (inv@117@03 r)))
        (< (inv@116@03 r) V@12@03))
      (<= 0 (inv@116@03 r)))
    (=
      ($FVF.lookup_int (as sm@216@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@216@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03))))))))))))))) r))
  :qid |qp.fvfValDef80|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03)))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03))))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@216@03  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef81|)))
; Check receiver injectivity
(push) ; 12
(assert (not (forall ((i11@213@03 Int) (i12@213@03 Int)) (!
  (implies
    (and
      (and
        (and
          (and (< i11@213@03 V@12@03) (<= 0 i11@213@03))
          ($FVF.loc_int ($FVF.lookup_int (as sm@216@03  $FVF<Int>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit p@15@03) i11@213@03)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit p@15@03) i11@213@03)))
        (< $Perm.No $k@214@03))
      (and
        (and
          (and (< i12@213@03 V@12@03) (<= 0 i12@213@03))
          ($FVF.loc_int ($FVF.lookup_int (as sm@216@03  $FVF<Int>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit p@15@03) i12@213@03)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit p@15@03) i12@213@03)))
        (< $Perm.No $k@214@03))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) i11@213@03)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) i12@213@03)))
    (= i11@213@03 i12@213@03))
  
  :qid |int-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               21466
;  :arith-add-rows          9426
;  :arith-assert-diseq      751
;  :arith-assert-lower      5367
;  :arith-assert-upper      3500
;  :arith-bound-prop        1179
;  :arith-conflicts         221
;  :arith-eq-adapter        3496
;  :arith-fixed-eqs         2399
;  :arith-offset-eqs        1422
;  :arith-pivots            2665
;  :conflicts               559
;  :datatype-accessor-ax    144
;  :datatype-constructor-ax 417
;  :datatype-occurs-check   234
;  :datatype-splits         139
;  :decisions               2926
;  :del-clause              37004
;  :final-checks            122
;  :interface-eqs           13
;  :max-generation          9
;  :max-memory              9.30
;  :memory                  9.17
;  :minimized-lits          63
;  :mk-bool-var             44792
;  :mk-clause               38167
;  :num-allocs              440082
;  :num-checks              236
;  :propagations            11295
;  :quant-instantiations    13340
;  :rlimit-count            1056931)
; Definitional axioms for inverse functions
(assert (forall ((i1@213@03 Int)) (!
  (implies
    (and (and (< i1@213@03 V@12@03) (<= 0 i1@213@03)) (< $Perm.No $k@214@03))
    (=
      (inv@215@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) i1@213@03))
      i1@213@03))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) i1@213@03))
  :qid |int-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and (< (inv@215@03 r) V@12@03) (<= 0 (inv@215@03 r)))
      (< $Perm.No $k@214@03))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) (inv@215@03 r))
      r))
  :pattern ((inv@215@03 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@215@03 r) V@12@03) (<= 0 (inv@215@03 r)))
    ($FVF.loc_int ($FVF.lookup_int (as sm@216@03  $FVF<Int>) r) r))
  :pattern ((inv@215@03 r))
  )))
; Precomputing data for removing quantified permissions
(define-fun pTaken@217@03 ((r $Ref)) $Perm
  (ite
    (and (< (inv@215@03 r) V@12@03) (<= 0 (inv@215@03 r)))
    ($Perm.min
      (ite
        (and (< (inv@120@03 r) V@12@03) (<= 0 (inv@120@03 r)))
        $Perm.Write
        $Perm.No)
      $k@214@03)
    $Perm.No))
(define-fun pTaken@218@03 ((r $Ref)) $Perm
  (ite
    (and (< (inv@215@03 r) V@12@03) (<= 0 (inv@215@03 r)))
    ($Perm.min
      (ite
        (and
          (and
            (and (< (inv@117@03 r) V@12@03) (<= 0 (inv@117@03 r)))
            (< (inv@116@03 r) V@12@03))
          (<= 0 (inv@116@03 r)))
        $Perm.Write
        $Perm.No)
      (- $k@214@03 (pTaken@217@03 r)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Constrain original permissions $k@214@03
(assert (forall ((r $Ref)) (!
  (implies
    (not
      (=
        (ite
          (and (< (inv@120@03 r) V@12@03) (<= 0 (inv@120@03 r)))
          $Perm.Write
          $Perm.No)
        $Perm.No))
    (ite
      (and (< (inv@120@03 r) V@12@03) (<= 0 (inv@120@03 r)))
      (<
        (ite
          (and (< (inv@215@03 r) V@12@03) (<= 0 (inv@215@03 r)))
          $k@214@03
          $Perm.No)
        $Perm.Write)
      (<
        (ite
          (and (< (inv@215@03 r) V@12@03) (<= 0 (inv@215@03 r)))
          $k@214@03
          $Perm.No)
        $Perm.No)))
  :pattern ((inv@120@03 r))
  :pattern ((inv@215@03 r))
  :qid |qp.srp82|)))
; Intermediate check if already taken enough permissions
(set-option :timeout 500)
(push) ; 12
(assert (not (forall ((r $Ref)) (!
  (implies
    (and (< (inv@215@03 r) V@12@03) (<= 0 (inv@215@03 r)))
    (= (- $k@214@03 (pTaken@217@03 r)) $Perm.No))
  
  ))))
(check-sat)
; unsat
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               23263
;  :arith-add-rows          9860
;  :arith-assert-diseq      793
;  :arith-assert-lower      5846
;  :arith-assert-upper      3774
;  :arith-bound-prop        1227
;  :arith-conflicts         226
;  :arith-eq-adapter        3790
;  :arith-fixed-eqs         2653
;  :arith-offset-eqs        1530
;  :arith-pivots            2753
;  :conflicts               582
;  :datatype-accessor-ax    144
;  :datatype-constructor-ax 425
;  :datatype-occurs-check   234
;  :datatype-splits         139
;  :decisions               3061
;  :del-clause              39239
;  :final-checks            122
;  :interface-eqs           13
;  :max-generation          9
;  :max-memory              9.34
;  :memory                  9.16
;  :minimized-lits          63
;  :mk-bool-var             47234
;  :mk-clause               40444
;  :num-allocs              449936
;  :num-checks              238
;  :propagations            12574
;  :quant-instantiations    14367
;  :rlimit-count            1104319
;  :time                    0.00)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@219@03 $FVF<Int>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (iff
    (Set_in r ($FVF.domain_int (as sm@219@03  $FVF<Int>)))
    (and
      (and (< (inv@215@03 r) V@12@03) (<= 0 (inv@215@03 r)))
      (< $Perm.No $k@214@03)))
  :pattern ((Set_in r ($FVF.domain_int (as sm@219@03  $FVF<Int>))))
  :qid |qp.fvfDomDef86|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@215@03 r) V@12@03) (<= 0 (inv@215@03 r)))
        (< $Perm.No $k@214@03))
      (and (< (inv@120@03 r) V@12@03) (<= 0 (inv@120@03 r))))
    (=
      ($FVF.lookup_int (as sm@219@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03)))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@219@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03)))))))))))))))) r))
  :qid |qp.fvfValDef83|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@215@03 r) V@12@03) (<= 0 (inv@215@03 r)))
        (< $Perm.No $k@214@03))
      (and
        (and
          (and (< (inv@117@03 r) V@12@03) (<= 0 (inv@117@03 r)))
          (< (inv@116@03 r) V@12@03))
        (<= 0 (inv@116@03 r))))
    (=
      ($FVF.lookup_int (as sm@219@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@219@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03))))))))))))))) r))
  :qid |qp.fvfValDef84|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03)))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03))))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@219@03  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef85|)))
(pop) ; 11
; Joined path conditions
(assert ($Perm.isReadVar $k@214@03 $Perm.Write))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@120@03 r) V@12@03) (<= 0 (inv@120@03 r)))
    (=
      ($FVF.lookup_int (as sm@216@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03)))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@216@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03)))))))))))))))) r))
  :qid |qp.fvfValDef79|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@117@03 r) V@12@03) (<= 0 (inv@117@03 r)))
        (< (inv@116@03 r) V@12@03))
      (<= 0 (inv@116@03 r)))
    (=
      ($FVF.lookup_int (as sm@216@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@216@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03))))))))))))))) r))
  :qid |qp.fvfValDef80|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03)))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03))))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@216@03  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef81|)))
(assert (forall ((i1@213@03 Int)) (!
  (implies
    (and (and (< i1@213@03 V@12@03) (<= 0 i1@213@03)) (< $Perm.No $k@214@03))
    (=
      (inv@215@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) i1@213@03))
      i1@213@03))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) i1@213@03))
  :qid |int-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and (< (inv@215@03 r) V@12@03) (<= 0 (inv@215@03 r)))
      (< $Perm.No $k@214@03))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) (inv@215@03 r))
      r))
  :pattern ((inv@215@03 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (iff
    (Set_in r ($FVF.domain_int (as sm@219@03  $FVF<Int>)))
    (and
      (and (< (inv@215@03 r) V@12@03) (<= 0 (inv@215@03 r)))
      (< $Perm.No $k@214@03)))
  :pattern ((Set_in r ($FVF.domain_int (as sm@219@03  $FVF<Int>))))
  :qid |qp.fvfDomDef86|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@215@03 r) V@12@03) (<= 0 (inv@215@03 r)))
        (< $Perm.No $k@214@03))
      (and (< (inv@120@03 r) V@12@03) (<= 0 (inv@120@03 r))))
    (=
      ($FVF.lookup_int (as sm@219@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03)))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@219@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03)))))))))))))))) r))
  :qid |qp.fvfValDef83|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@215@03 r) V@12@03) (<= 0 (inv@215@03 r)))
        (< $Perm.No $k@214@03))
      (and
        (and
          (and (< (inv@117@03 r) V@12@03) (<= 0 (inv@117@03 r)))
          (< (inv@116@03 r) V@12@03))
        (<= 0 (inv@116@03 r))))
    (=
      ($FVF.lookup_int (as sm@219@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@219@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03))))))))))))))) r))
  :qid |qp.fvfValDef84|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03)))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03))))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@219@03  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef85|)))
(assert (and
  (forall ((i1@213@03 Int)) (!
    (< i1@213@03 (alen<Int> (opt_get1 $Snap.unit p@15@03)))
    :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) i1@213@03))
    :qid |int-aux|))
  (forall ((r $Ref)) (!
    (implies
      (and (< (inv@215@03 r) V@12@03) (<= 0 (inv@215@03 r)))
      ($FVF.loc_int ($FVF.lookup_int (as sm@216@03  $FVF<Int>) r) r))
    :pattern ((inv@215@03 r))
    ))
  (forall ((r $Ref)) (!
    (implies
      (not
        (=
          (ite
            (and (< (inv@120@03 r) V@12@03) (<= 0 (inv@120@03 r)))
            $Perm.Write
            $Perm.No)
          $Perm.No))
      (ite
        (and (< (inv@120@03 r) V@12@03) (<= 0 (inv@120@03 r)))
        (<
          (ite
            (and (< (inv@215@03 r) V@12@03) (<= 0 (inv@215@03 r)))
            $k@214@03
            $Perm.No)
          $Perm.Write)
        (<
          (ite
            (and (< (inv@215@03 r) V@12@03) (<= 0 (inv@215@03 r)))
            $k@214@03
            $Perm.No)
          $Perm.No)))
    :pattern ((inv@120@03 r))
    :pattern ((inv@215@03 r))
    :qid |qp.srp82|))))
(set-option :timeout 0)
(push) ; 11
(assert (not (valid_graph_vertices ($Snap.combine
  $Snap.unit
  ($Snap.combine
    $Snap.unit
    ($Snap.combine
      $Snap.unit
      ($SortWrappers.$FVF<Int>To$Snap (as sm@219@03  $FVF<Int>))))) this@9@03 p@15@03 V@12@03)))
(check-sat)
; unsat
(pop) ; 11
; 0.06s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               28271
;  :arith-add-rows          13122
;  :arith-assert-diseq      905
;  :arith-assert-lower      7461
;  :arith-assert-upper      4789
;  :arith-bound-prop        1407
;  :arith-conflicts         239
;  :arith-eq-adapter        4576
;  :arith-fixed-eqs         3613
;  :arith-offset-eqs        1897
;  :arith-pivots            3225
;  :conflicts               616
;  :datatype-accessor-ax    147
;  :datatype-constructor-ax 429
;  :datatype-occurs-check   234
;  :datatype-splits         139
;  :decisions               3506
;  :del-clause              50380
;  :final-checks            122
;  :interface-eqs           13
;  :max-generation          9
;  :max-memory              10.17
;  :memory                  10.04
;  :minimized-lits          65
;  :mk-bool-var             61041
;  :mk-clause               51543
;  :num-allocs              498432
;  :num-checks              239
;  :propagations            16180
;  :quant-instantiations    17686
;  :rlimit-count            1223581
;  :time                    0.06)
(assert (valid_graph_vertices ($Snap.combine
  $Snap.unit
  ($Snap.combine
    $Snap.unit
    ($Snap.combine
      $Snap.unit
      ($SortWrappers.$FVF<Int>To$Snap (as sm@219@03  $FVF<Int>))))) this@9@03 p@15@03 V@12@03))
; [eval] alen(opt_get1(visited)) == V
; [eval] alen(opt_get1(visited))
; [eval] opt_get1(visited)
(push) ; 11
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 11
; Joined path conditions
; [eval] 0 <= u
(push) ; 11
(assert (not (<= 0 u@161@03)))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               28283
;  :arith-add-rows          13127
;  :arith-assert-diseq      905
;  :arith-assert-lower      7462
;  :arith-assert-upper      4791
;  :arith-bound-prop        1407
;  :arith-conflicts         240
;  :arith-eq-adapter        4577
;  :arith-fixed-eqs         3614
;  :arith-offset-eqs        1897
;  :arith-pivots            3227
;  :conflicts               617
;  :datatype-accessor-ax    150
;  :datatype-constructor-ax 429
;  :datatype-occurs-check   234
;  :datatype-splits         139
;  :decisions               3506
;  :del-clause              50381
;  :final-checks            122
;  :interface-eqs           13
;  :max-generation          9
;  :max-memory              10.17
;  :memory                  10.04
;  :minimized-lits          65
;  :mk-bool-var             61099
;  :mk-clause               51594
;  :num-allocs              498808
;  :num-checks              240
;  :propagations            16191
;  :quant-instantiations    17695
;  :rlimit-count            1224226)
(assert (<= 0 u@161@03))
; [eval] u < V
(push) ; 11
(assert (not (< u@161@03 V@12@03)))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               28285
;  :arith-add-rows          13133
;  :arith-assert-diseq      905
;  :arith-assert-lower      7464
;  :arith-assert-upper      4793
;  :arith-bound-prop        1407
;  :arith-conflicts         241
;  :arith-eq-adapter        4578
;  :arith-fixed-eqs         3615
;  :arith-offset-eqs        1897
;  :arith-pivots            3230
;  :conflicts               618
;  :datatype-accessor-ax    150
;  :datatype-constructor-ax 429
;  :datatype-occurs-check   234
;  :datatype-splits         139
;  :decisions               3506
;  :del-clause              50381
;  :final-checks            122
;  :interface-eqs           13
;  :max-generation          9
;  :max-memory              10.17
;  :memory                  10.04
;  :minimized-lits          65
;  :mk-bool-var             61104
;  :mk-clause               51594
;  :num-allocs              498971
;  :num-checks              241
;  :propagations            16191
;  :quant-instantiations    17695
;  :rlimit-count            1224447)
(assert (< u@161@03 V@12@03))
; [eval] 0 <= v
; [eval] v <= V
(push) ; 11
(assert (not (<= 0 V@12@03)))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               28285
;  :arith-add-rows          13341
;  :arith-assert-diseq      905
;  :arith-assert-lower      7465
;  :arith-assert-upper      4794
;  :arith-bound-prop        1407
;  :arith-conflicts         242
;  :arith-eq-adapter        4578
;  :arith-fixed-eqs         3615
;  :arith-offset-eqs        1897
;  :arith-pivots            3231
;  :conflicts               619
;  :datatype-accessor-ax    150
;  :datatype-constructor-ax 429
;  :datatype-occurs-check   234
;  :datatype-splits         139
;  :decisions               3506
;  :del-clause              50381
;  :final-checks            122
;  :interface-eqs           13
;  :max-generation          9
;  :max-memory              10.17
;  :memory                  10.04
;  :minimized-lits          65
;  :mk-bool-var             61106
;  :mk-clause               51594
;  :num-allocs              499116
;  :num-checks              242
;  :propagations            16191
;  :quant-instantiations    17695
;  :rlimit-count            1227664)
(assert (<= 0 V@12@03))
; [eval] 0 <= k
; [eval] k < V
(push) ; 11
(assert (not (< 0 V@12@03)))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               28285
;  :arith-add-rows          13352
;  :arith-assert-diseq      905
;  :arith-assert-lower      7466
;  :arith-assert-upper      4795
;  :arith-bound-prop        1407
;  :arith-conflicts         243
;  :arith-eq-adapter        4578
;  :arith-fixed-eqs         3616
;  :arith-offset-eqs        1897
;  :arith-pivots            3232
;  :conflicts               620
;  :datatype-accessor-ax    150
;  :datatype-constructor-ax 429
;  :datatype-occurs-check   234
;  :datatype-splits         139
;  :decisions               3506
;  :del-clause              50381
;  :final-checks            122
;  :interface-eqs           13
;  :max-generation          9
;  :max-memory              10.17
;  :memory                  10.04
;  :minimized-lits          65
;  :mk-bool-var             61108
;  :mk-clause               51594
;  :num-allocs              499254
;  :num-checks              243
;  :propagations            16191
;  :quant-instantiations    17695
;  :rlimit-count            1228124)
(assert (< 0 V@12@03))
; [eval] valid_graph_vertices1(this, queue, V)
(push) ; 11
; [eval] this != null
(pop) ; 11
; Joined path conditions
(declare-const i1@220@03 Int)
(push) ; 11
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 12
; [then-branch: 132 | 0 <= i1@220@03 | live]
; [else-branch: 132 | !(0 <= i1@220@03) | live]
(push) ; 13
; [then-branch: 132 | 0 <= i1@220@03]
(assert (<= 0 i1@220@03))
; [eval] i1 < V
(pop) ; 13
(push) ; 13
; [else-branch: 132 | !(0 <= i1@220@03)]
(assert (not (<= 0 i1@220@03)))
(pop) ; 13
(pop) ; 12
; Joined path conditions
; Joined path conditions
(assert (and (< i1@220@03 V@12@03) (<= 0 i1@220@03)))
; [eval] aloc(opt_get1(visited), i1)
; [eval] opt_get1(visited)
(push) ; 12
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 12
; Joined path conditions
(push) ; 12
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 13
(assert (not (< i1@220@03 (alen<Int> (opt_get1 $Snap.unit res@79@03)))))
(check-sat)
; unsat
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               28285
;  :arith-add-rows          13352
;  :arith-assert-diseq      905
;  :arith-assert-lower      7469
;  :arith-assert-upper      4795
;  :arith-bound-prop        1407
;  :arith-conflicts         243
;  :arith-eq-adapter        4578
;  :arith-fixed-eqs         3616
;  :arith-offset-eqs        1897
;  :arith-pivots            3232
;  :conflicts               620
;  :datatype-accessor-ax    150
;  :datatype-constructor-ax 429
;  :datatype-occurs-check   234
;  :datatype-splits         139
;  :decisions               3506
;  :del-clause              50381
;  :final-checks            122
;  :interface-eqs           13
;  :max-generation          9
;  :max-memory              10.17
;  :memory                  10.04
;  :minimized-lits          65
;  :mk-bool-var             61111
;  :mk-clause               51594
;  :num-allocs              499423
;  :num-checks              244
;  :propagations            16191
;  :quant-instantiations    17695
;  :rlimit-count            1228364)
(assert (< i1@220@03 (alen<Int> (opt_get1 $Snap.unit res@79@03))))
(pop) ; 12
; Joined path conditions
(assert (< i1@220@03 (alen<Int> (opt_get1 $Snap.unit res@79@03))))
(pop) ; 11
(declare-fun inv@221@03 ($Ref) Int)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(assert (forall ((i1@220@03 Int)) (!
  (< i1@220@03 (alen<Int> (opt_get1 $Snap.unit res@79@03)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@79@03) i1@220@03))
  :qid |bool-aux|)))
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 11
(assert (not (forall ((i11@220@03 Int) (i12@220@03 Int)) (!
  (implies
    (and
      (and
        (and (< i11@220@03 V@12@03) (<= 0 i11@220@03))
        ($FVF.loc_bool ($FVF.lookup_bool (as sm@130@03  $FVF<Bool>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@79@03) i11@220@03)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@79@03) i11@220@03)))
      (and
        (and (< i12@220@03 V@12@03) (<= 0 i12@220@03))
        ($FVF.loc_bool ($FVF.lookup_bool (as sm@130@03  $FVF<Bool>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@79@03) i12@220@03)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@79@03) i12@220@03)))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@79@03) i11@220@03)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@79@03) i12@220@03)))
    (= i11@220@03 i12@220@03))
  
  :qid |bool-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               28301
;  :arith-add-rows          13354
;  :arith-assert-diseq      906
;  :arith-assert-lower      7473
;  :arith-assert-upper      4795
;  :arith-bound-prop        1407
;  :arith-conflicts         243
;  :arith-eq-adapter        4579
;  :arith-fixed-eqs         3616
;  :arith-offset-eqs        1897
;  :arith-pivots            3232
;  :conflicts               621
;  :datatype-accessor-ax    150
;  :datatype-constructor-ax 429
;  :datatype-occurs-check   234
;  :datatype-splits         139
;  :decisions               3506
;  :del-clause              50392
;  :final-checks            122
;  :interface-eqs           13
;  :max-generation          9
;  :max-memory              10.17
;  :memory                  10.02
;  :minimized-lits          65
;  :mk-bool-var             61145
;  :mk-clause               51605
;  :num-allocs              499995
;  :num-checks              245
;  :propagations            16191
;  :quant-instantiations    17721
;  :rlimit-count            1229611)
; Definitional axioms for inverse functions
(assert (forall ((i1@220@03 Int)) (!
  (implies
    (and (< i1@220@03 V@12@03) (<= 0 i1@220@03))
    (=
      (inv@221@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@79@03) i1@220@03))
      i1@220@03))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@79@03) i1@220@03))
  :qid |bool-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@221@03 r) V@12@03) (<= 0 (inv@221@03 r)))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@79@03) (inv@221@03 r))
      r))
  :pattern ((inv@221@03 r))
  :qid |bool-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@221@03 r) V@12@03) (<= 0 (inv@221@03 r)))
    ($FVF.loc_bool ($FVF.lookup_bool (as sm@130@03  $FVF<Bool>) r) r))
  :pattern ((inv@221@03 r))
  )))
; Precomputing data for removing quantified permissions
(define-fun pTaken@222@03 ((r $Ref)) $Perm
  (ite
    (and (< (inv@221@03 r) V@12@03) (<= 0 (inv@221@03 r)))
    ($Perm.min
      (ite
        (and (< (inv@129@03 r) V@12@03) (<= 0 (inv@129@03 r)))
        $Perm.Write
        $Perm.No)
      $Perm.Write)
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 500)
(push) ; 11
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and (< (inv@129@03 r) V@12@03) (<= 0 (inv@129@03 r)))
        $Perm.Write
        $Perm.No)
      (pTaken@222@03 r))
    $Perm.No)
  
  ))))
(check-sat)
; unsat
(pop) ; 11
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               29925
;  :arith-add-rows          13745
;  :arith-assert-diseq      959
;  :arith-assert-lower      7932
;  :arith-assert-upper      5045
;  :arith-bound-prop        1444
;  :arith-conflicts         250
;  :arith-eq-adapter        4852
;  :arith-fixed-eqs         3850
;  :arith-offset-eqs        2014
;  :arith-pivots            3315
;  :conflicts               646
;  :datatype-accessor-ax    150
;  :datatype-constructor-ax 437
;  :datatype-occurs-check   234
;  :datatype-splits         139
;  :decisions               3647
;  :del-clause              53014
;  :final-checks            122
;  :interface-eqs           13
;  :max-generation          9
;  :max-memory              10.17
;  :memory                  9.92
;  :minimized-lits          65
;  :mk-bool-var             63716
;  :mk-clause               54259
;  :num-allocs              508363
;  :num-checks              247
;  :propagations            17353
;  :quant-instantiations    18658
;  :rlimit-count            1269576
;  :time                    0.01)
; Intermediate check if already taken enough permissions
(push) ; 11
(assert (not (forall ((r $Ref)) (!
  (implies
    (and (< (inv@221@03 r) V@12@03) (<= 0 (inv@221@03 r)))
    (= (- $Perm.Write (pTaken@222@03 r)) $Perm.No))
  
  ))))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               29951
;  :arith-add-rows          13756
;  :arith-assert-diseq      961
;  :arith-assert-lower      7939
;  :arith-assert-upper      5053
;  :arith-bound-prop        1445
;  :arith-conflicts         251
;  :arith-eq-adapter        4859
;  :arith-fixed-eqs         3854
;  :arith-offset-eqs        2014
;  :arith-pivots            3319
;  :conflicts               647
;  :datatype-accessor-ax    150
;  :datatype-constructor-ax 437
;  :datatype-occurs-check   234
;  :datatype-splits         139
;  :decisions               3647
;  :del-clause              53049
;  :final-checks            122
;  :interface-eqs           13
;  :max-generation          9
;  :max-memory              10.17
;  :memory                  9.91
;  :minimized-lits          65
;  :mk-bool-var             63780
;  :mk-clause               54294
;  :num-allocs              508836
;  :num-checks              248
;  :propagations            17358
;  :quant-instantiations    18681
;  :rlimit-count            1270939)
; Final check if taken enough permissions
; Done removing quantified permissions
; Definitional axioms for snapshot map values
; Loop head block: Execute statements of loop head block (in invariant state)
(push) ; 11
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@192@03 r) V@12@03) (<= 0 (inv@192@03 r)))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@79@03) (inv@192@03 r))
      r))
  :pattern ((inv@192@03 r))
  :qid |bool-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@192@03 r) V@12@03) (<= 0 (inv@192@03 r)))
    (=
      ($FVF.lookup_bool (as sm@193@03  $FVF<Bool>) r)
      ($FVF.lookup_bool ($SortWrappers.$SnapTo$FVF<Bool> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03))))))))))))))))))))))))) r)))
  :pattern (($FVF.lookup_bool (as sm@193@03  $FVF<Bool>) r))
  :pattern (($FVF.lookup_bool ($SortWrappers.$SnapTo$FVF<Bool> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03))))))))))))))))))))))))) r))
  :qid |qp.fvfValDef71|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_bool ($FVF.lookup_bool ($SortWrappers.$SnapTo$FVF<Bool> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03))))))))))))))))))))))))) r) r)
  :pattern (($FVF.lookup_bool (as sm@193@03  $FVF<Bool>) r))
  :qid |qp.fvfResTrgDef72|)))
(assert (forall ((i1@191@03 Int)) (!
  (implies
    (and (< i1@191@03 V@12@03) (<= 0 i1@191@03))
    (=
      (inv@192@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@79@03) i1@191@03))
      i1@191@03))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@79@03) i1@191@03))
  )))
(assert (forall ((i1@191@03 Int)) (!
  (implies
    (and (< i1@191@03 V@12@03) (<= 0 i1@191@03))
    (not
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@79@03) i1@191@03)
        $Ref.null)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@79@03) i1@191@03))
  :qid |bool-permImpliesNonNull|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@192@03 r) V@12@03) (<= 0 (inv@192@03 r)))
    ($FVF.loc_bool ($FVF.lookup_bool (as sm@193@03  $FVF<Bool>) r) r))
  :pattern ((inv@192@03 r))
  )))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@183@03 r) V@12@03) (<= 0 (inv@183@03 r)))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) (inv@183@03 r))
      r))
  :pattern ((inv@183@03 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@183@03 r) V@12@03) (<= 0 (inv@183@03 r)))
    (=
      ($FVF.lookup_int (as sm@184@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03)))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@184@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03)))))))))))))))) r))
  :qid |qp.fvfValDef63|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@180@03 r) V@12@03) (<= 0 (inv@180@03 r)))
        (< (inv@179@03 r) V@12@03))
      (<= 0 (inv@179@03 r)))
    (=
      ($FVF.lookup_int (as sm@184@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@184@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03))))))))))))))) r))
  :qid |qp.fvfValDef64|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03)))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03))))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@184@03  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef65|)))
(assert ($Perm.isReadVar $k@186@03 $Perm.Write))
(assert (forall ((i1@185@03 Int)) (!
  (implies
    (and (and (< i1@185@03 V@12@03) (<= 0 i1@185@03)) (< $Perm.No $k@186@03))
    (=
      (inv@187@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) i1@185@03))
      i1@185@03))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) i1@185@03))
  :qid |int-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and (< (inv@187@03 r) V@12@03) (<= 0 (inv@187@03 r)))
      (< $Perm.No $k@186@03))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) (inv@187@03 r))
      r))
  :pattern ((inv@187@03 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (iff
    (Set_in r ($FVF.domain_int (as sm@190@03  $FVF<Int>)))
    (and
      (and (< (inv@187@03 r) V@12@03) (<= 0 (inv@187@03 r)))
      (< $Perm.No $k@186@03)))
  :pattern ((Set_in r ($FVF.domain_int (as sm@190@03  $FVF<Int>))))
  :qid |qp.fvfDomDef70|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@187@03 r) V@12@03) (<= 0 (inv@187@03 r)))
        (< $Perm.No $k@186@03))
      (and (< (inv@183@03 r) V@12@03) (<= 0 (inv@183@03 r))))
    (=
      ($FVF.lookup_int (as sm@190@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03)))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@190@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03)))))))))))))))) r))
  :qid |qp.fvfValDef67|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@187@03 r) V@12@03) (<= 0 (inv@187@03 r)))
        (< $Perm.No $k@186@03))
      (and
        (and
          (and (< (inv@180@03 r) V@12@03) (<= 0 (inv@180@03 r)))
          (< (inv@179@03 r) V@12@03))
        (<= 0 (inv@179@03 r))))
    (=
      ($FVF.lookup_int (as sm@190@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@190@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03))))))))))))))) r))
  :qid |qp.fvfValDef68|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03)))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03))))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@190@03  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef69|)))
(assert (forall ((i1@182@03 Int)) (!
  (implies
    (and (< i1@182@03 V@12@03) (<= 0 i1@182@03))
    (=
      (inv@183@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) i1@182@03))
      i1@182@03))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) i1@182@03))
  )))
(assert (forall ((i1@182@03 Int)) (!
  (implies
    (and (< i1@182@03 V@12@03) (<= 0 i1@182@03))
    (not
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) i1@182@03)
        $Ref.null)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) i1@182@03))
  :qid |int-permImpliesNonNull|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@183@03 r) V@12@03) (<= 0 (inv@183@03 r)))
    ($FVF.loc_int ($FVF.lookup_int (as sm@184@03  $FVF<Int>) r) r))
  :pattern ((inv@183@03 r))
  )))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03)))))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03))))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03)))))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03))))))))))))))))
  $Snap.unit))
(assert (forall ((i1@185@03 Int)) (!
  (< i1@185@03 (alen<Int> (opt_get1 $Snap.unit p@15@03)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) i1@185@03))
  :qid |int-aux|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@187@03 r) V@12@03) (<= 0 (inv@187@03 r)))
    ($FVF.loc_int ($FVF.lookup_int (as sm@184@03  $FVF<Int>) r) r))
  :pattern ((inv@187@03 r))
  )))
(assert (forall ((r $Ref)) (!
  (implies
    (not
      (=
        (ite
          (and (< (inv@183@03 r) V@12@03) (<= 0 (inv@183@03 r)))
          $Perm.Write
          $Perm.No)
        $Perm.No))
    (ite
      (and (< (inv@183@03 r) V@12@03) (<= 0 (inv@183@03 r)))
      (<
        (ite
          (and (< (inv@187@03 r) V@12@03) (<= 0 (inv@187@03 r)))
          $k@186@03
          $Perm.No)
        $Perm.Write)
      (<
        (ite
          (and (< (inv@187@03 r) V@12@03) (<= 0 (inv@187@03 r)))
          $k@186@03
          $Perm.No)
        $Perm.No)))
  :pattern ((inv@183@03 r))
  :pattern ((inv@187@03 r))
  :qid |qp.srp66|)))
(assert (valid_graph_vertices ($Snap.combine
  $Snap.unit
  ($Snap.combine
    $Snap.unit
    ($Snap.combine
      $Snap.unit
      ($SortWrappers.$FVF<Int>To$Snap (as sm@190@03  $FVF<Int>))))) this@9@03 p@15@03 V@12@03))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03))))))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03)))))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03))))))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03)))))))))))))))))
  $Snap.unit))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03)))))))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03))))))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03)))))))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03))))))))))))))))))
  $Snap.unit))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03))))))))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03)))))))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03))))))))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03)))))))))))))))))))
  $Snap.unit))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03)))))))))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03))))))))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03)))))))))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03))))))))))))))))))))
  $Snap.unit))
(assert (<= 0 v@166@03))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03))))))))))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03)))))))))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03))))))))))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03)))))))))))))))))))))
  $Snap.unit))
(assert (<= v@166@03 V@12@03))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03)))))))))))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03))))))))))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03)))))))))))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03))))))))))))))))))))))
  $Snap.unit))
(assert (<= 0 k@163@03))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03))))))))))))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03)))))))))))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03))))))))))))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03)))))))))))))))))))))))
  $Snap.unit))
(assert (< k@163@03 V@12@03))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03)))))))))))))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03))))))))))))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03)))))))))))))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03))))))))))))))))))))))))
  $Snap.unit))
(assert (valid_graph_vertices1 $Snap.unit this@9@03 queue@164@03 V@12@03))
(assert (forall ((i1@191@03 Int)) (!
  (< i1@191@03 (alen<Int> (opt_get1 $Snap.unit res@79@03)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@79@03) i1@191@03))
  :qid |bool-aux|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@180@03 r) V@12@03) (<= 0 (inv@180@03 r)))
        (< (inv@179@03 r) V@12@03))
      (<= 0 (inv@179@03 r)))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) (inv@179@03 r)))) (inv@180@03 r))
      r))
  :pattern ((inv@179@03 r))
  :pattern ((inv@180@03 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@180@03 r) V@12@03) (<= 0 (inv@180@03 r)))
        (< (inv@179@03 r) V@12@03))
      (<= 0 (inv@179@03 r)))
    (=
      ($FVF.lookup_int (as sm@181@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@181@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03))))))))))))))) r))
  :qid |qp.fvfValDef61|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03))))))))))))))) r) r)
  :pattern (($FVF.lookup_int (as sm@181@03  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef62|)))
(assert (forall ((i1@177@03 Int) (j1@178@03 Int)) (!
  (implies
    (and
      (and (and (< j1@178@03 V@12@03) (<= 0 j1@178@03)) (< i1@177@03 V@12@03))
      (<= 0 i1@177@03))
    (and
      (=
        (inv@179@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@177@03))) j1@178@03))
        i1@177@03)
      (=
        (inv@180@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@177@03))) j1@178@03))
        j1@178@03)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@177@03))) j1@178@03))
  )))
(assert (forall ((i1@177@03 Int) (j1@178@03 Int)) (!
  (implies
    (and
      (and (and (< j1@178@03 V@12@03) (<= 0 j1@178@03)) (< i1@177@03 V@12@03))
      (<= 0 i1@177@03))
    (not
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@177@03))) j1@178@03)
        $Ref.null)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@177@03))) j1@178@03))
  :qid |int-permImpliesNonNull|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@180@03 r) V@12@03) (<= 0 (inv@180@03 r)))
        (< (inv@179@03 r) V@12@03))
      (<= 0 (inv@179@03 r)))
    ($FVF.loc_int ($FVF.lookup_int (as sm@181@03  $FVF<Int>) r) r))
  :pattern ((inv@179@03 r) (inv@180@03 r))
  )))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03))))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03)))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03))))))))))))))))))
(assert (forall ((i1@182@03 Int)) (!
  (< i1@182@03 (alen<Int> (opt_get1 $Snap.unit p@15@03)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) i1@182@03))
  :qid |int-aux|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and (< (inv@171@03 r) V@12@03) (<= 0 (inv@171@03 r)))
      (< $Perm.No $k@170@03))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) (inv@171@03 r))
      r))
  :pattern ((inv@171@03 r))
  :qid |option$array$-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@171@03 r) V@12@03) (<= 0 (inv@171@03 r)))
      (< $Perm.No $k@170@03)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@168@03))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@168@03))))) r))
  :qid |qp.fvfValDef59|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@168@03))))) r) r)
  :pattern (($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef60|)))
(assert (forall ((i1@169@03 Int)) (!
  (implies
    (and (and (< i1@169@03 V@12@03) (<= 0 i1@169@03)) (< $Perm.No $k@170@03))
    (=
      (inv@171@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@169@03))
      i1@169@03))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@169@03))
  )))
(assert (forall ((i1@169@03 Int)) (!
  (<= $Perm.No $k@170@03)
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@169@03))
  :qid |option$array$-permAtLeastZero|)))
(assert (forall ((i1@169@03 Int)) (!
  (<= $k@170@03 $Perm.Write)
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@169@03))
  :qid |option$array$-permAtMostOne|)))
(assert (forall ((i1@169@03 Int)) (!
  (implies
    (and (and (< i1@169@03 V@12@03) (<= 0 i1@169@03)) (< $Perm.No $k@170@03))
    (not
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@169@03)
        $Ref.null)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@169@03))
  :qid |option$array$-permImpliesNonNull|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@171@03 r) V@12@03) (<= 0 (inv@171@03 r)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) r) r))
  :pattern ((inv@171@03 r))
  )))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03)))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03)))))
  $Snap.unit))
(assert (forall ((i1@173@03 Int)) (!
  (implies
    (and (< i1@173@03 V@12@03) (<= 0 i1@173@03))
    (and
      (< i1@173@03 V@12@03)
      (<= 0 i1@173@03)
      (< i1@173@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@173@03)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@173@03))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@173@03))
  :qid |prog.l<no position>-aux|)))
(assert (forall ((i1@173@03 Int)) (!
  (implies
    (and (< i1@173@03 V@12@03) (<= 0 i1@173@03))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@173@03))
        (as None<option<array>>  option<array>))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@173@03))
  :qid |prog.l<no position>|)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03)))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03)))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03))))))
  $Snap.unit))
(assert (forall ((i1@174@03 Int)) (!
  (implies
    (and (< i1@174@03 V@12@03) (<= 0 i1@174@03))
    (and
      (< i1@174@03 V@12@03)
      (<= 0 i1@174@03)
      (< i1@174@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@174@03)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@174@03))
      (not
        (=
          ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@174@03))
          (as None<option<array>>  option<array>)))))
  :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@174@03)))))
  :qid |prog.l<no position>-aux|)))
(assert (forall ((i1@174@03 Int)) (!
  (implies
    (and (< i1@174@03 V@12@03) (<= 0 i1@174@03))
    (=
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@174@03))))
      V@12@03))
  :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@174@03)))))
  :qid |prog.l<no position>|)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03)))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03)))))))
  $Snap.unit))
(assert (forall ((i1@175@03 Int)) (!
  (forall ((i2@176@03 Int)) (!
    (and
      (implies
        (<= 0 i1@175@03)
        (and
          (<= 0 i1@175@03)
          (implies
            (< i1@175@03 V@12@03)
            (and
              (< i1@175@03 V@12@03)
              (implies
                (<= 0 i2@176@03)
                (and
                  (<= 0 i2@176@03)
                  (implies
                    (< i2@176@03 V@12@03)
                    (and
                      (< i2@176@03 V@12@03)
                      (< i1@175@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))
                      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@175@03)) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@175@03))
                      (< i2@176@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))
                      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@176@03)) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@176@03))))))))))
      (implies
        (and
          (and
            (and
              (and
                (=
                  ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@175@03))
                  ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@176@03)))
                (< i2@176@03 V@12@03))
              (<= 0 i2@176@03))
            (< i1@175@03 V@12@03))
          (<= 0 i1@175@03))
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@175@03))
            ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@176@03)))
          (< i2@176@03 V@12@03)
          (<= 0 i2@176@03)
          (< i1@175@03 V@12@03)
          (<= 0 i1@175@03))))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@176@03))
    :qid |prog.l<no position>-aux|))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@175@03))
  :qid |prog.l<no position>-aux|)))
(assert (forall ((i1@175@03 Int)) (!
  (forall ((i2@176@03 Int)) (!
    (implies
      (and
        (and
          (and
            (and
              (=
                ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@175@03))
                ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@176@03)))
              (< i2@176@03 V@12@03))
            (<= 0 i2@176@03))
          (< i1@175@03 V@12@03))
        (<= 0 i1@175@03))
      (= i1@175@03 i2@176@03))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@176@03))
    :qid |prog.l<no position>|))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@175@03))
  :qid |prog.l<no position>|)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03)))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03)))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03))))))))
  $Snap.unit))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03)))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03)))))))))
  $Snap.unit))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03)))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03)))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03))))))))))
  $Snap.unit))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03)))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03)))))))))))
  $Snap.unit))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03)))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03)))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03))))))))))))
  $Snap.unit))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03)))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03)))))))))))))
  $Snap.unit))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03)))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03)))))))))))))))))
(assert (forall ((i1@177@03 Int) (j1@178@03 Int)) (!
  (and
    (< i1@177@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@177@03)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@177@03))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@177@03))
        (as None<option<array>>  option<array>)))
    (<
      j1@178@03
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@177@03))))))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@177@03))) j1@178@03))
  :qid |int-aux|)))
(assert ($Perm.isReadVar $k@170@03 $Perm.Write))
(assert (= $t@168@03 ($Snap.combine ($Snap.first $t@168@03) ($Snap.second $t@168@03))))
(assert (= ($Snap.first $t@168@03) $Snap.unit))
(assert (=
  ($Snap.second $t@168@03)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@168@03))
    ($Snap.second ($Snap.second $t@168@03)))))
(assert (= ($Snap.first ($Snap.second $t@168@03)) $Snap.unit))
(assert (=
  ($Snap.second ($Snap.second $t@168@03))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second $t@168@03)))
    ($Snap.second ($Snap.second ($Snap.second $t@168@03))))))
(assert (= ($Snap.first ($Snap.second ($Snap.second $t@168@03))) $Snap.unit))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second $t@168@03)))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@168@03))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03)))))))
(assert (forall ((i1@169@03 Int)) (!
  (< i1@169@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@169@03))
  :qid |option$array$-aux|)))
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
(set-option :timeout 10)
(check-sat)
; unknown
; Loop head block: Follow loop-internal edges
; [eval] v < V
(push) ; 12
(assert (not (not (< v@166@03 V@12@03))))
(check-sat)
; unknown
(pop) ; 12
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               35606
;  :arith-add-rows          14768
;  :arith-assert-diseq      1103
;  :arith-assert-lower      9572
;  :arith-assert-upper      5913
;  :arith-bound-prop        1559
;  :arith-conflicts         260
;  :arith-eq-adapter        5650
;  :arith-fixed-eqs         4660
;  :arith-offset-eqs        2239
;  :arith-pivots            3684
;  :conflicts               659
;  :datatype-accessor-ax    177
;  :datatype-constructor-ax 449
;  :datatype-occurs-check   234
;  :datatype-splits         139
;  :decisions               4415
;  :del-clause              69034
;  :final-checks            122
;  :interface-eqs           13
;  :max-generation          9
;  :max-memory              10.87
;  :memory                  10.73
;  :minimized-lits          67
;  :mk-bool-var             77656
;  :mk-clause               70470
;  :num-allocs              552563
;  :num-checks              251
;  :propagations            22195
;  :quant-instantiations    22948
;  :rlimit-count            1457782
;  :time                    0.01)
(push) ; 12
(assert (not (< v@166@03 V@12@03)))
(check-sat)
; unknown
(pop) ; 12
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               36505
;  :arith-add-rows          14878
;  :arith-assert-diseq      1123
;  :arith-assert-lower      9807
;  :arith-assert-upper      6036
;  :arith-bound-prop        1571
;  :arith-conflicts         261
;  :arith-eq-adapter        5782
;  :arith-fixed-eqs         4775
;  :arith-offset-eqs        2277
;  :arith-pivots            3709
;  :conflicts               660
;  :datatype-accessor-ax    177
;  :datatype-constructor-ax 453
;  :datatype-occurs-check   234
;  :datatype-splits         139
;  :decisions               4509
;  :del-clause              70909
;  :final-checks            122
;  :interface-eqs           13
;  :max-generation          9
;  :max-memory              10.87
;  :memory                  10.73
;  :minimized-lits          67
;  :mk-bool-var             79375
;  :mk-clause               72345
;  :num-allocs              557229
;  :num-checks              252
;  :propagations            22868
;  :quant-instantiations    23548
;  :rlimit-count            1484841
;  :time                    0.01)
; [then-branch: 133 | v@166@03 < V@12@03 | live]
; [else-branch: 133 | !(v@166@03 < V@12@03) | live]
(push) ; 12
; [then-branch: 133 | v@166@03 < V@12@03]
(assert (< v@166@03 V@12@03))
; [exec]
; k := v
; [eval] !aloc(opt_get1(visited), v).bool && 0 < aloc(opt_get1(aloc(opt_get1(Gf), u).option$array$), k).int
; [eval] !aloc(opt_get1(visited), v).bool
; [eval] aloc(opt_get1(visited), v)
; [eval] opt_get1(visited)
(push) ; 13
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 13
; Joined path conditions
(push) ; 13
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 14
(assert (not (< v@166@03 (alen<Int> (opt_get1 $Snap.unit res@79@03)))))
(check-sat)
; unsat
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               36505
;  :arith-add-rows          14878
;  :arith-assert-diseq      1123
;  :arith-assert-lower      9808
;  :arith-assert-upper      6036
;  :arith-bound-prop        1571
;  :arith-conflicts         261
;  :arith-eq-adapter        5782
;  :arith-fixed-eqs         4775
;  :arith-offset-eqs        2277
;  :arith-pivots            3709
;  :conflicts               660
;  :datatype-accessor-ax    177
;  :datatype-constructor-ax 453
;  :datatype-occurs-check   234
;  :datatype-splits         139
;  :decisions               4509
;  :del-clause              70909
;  :final-checks            122
;  :interface-eqs           13
;  :max-generation          9
;  :max-memory              10.87
;  :memory                  10.73
;  :minimized-lits          67
;  :mk-bool-var             79376
;  :mk-clause               72345
;  :num-allocs              557326
;  :num-checks              253
;  :propagations            22868
;  :quant-instantiations    23548
;  :rlimit-count            1484951)
(assert (< v@166@03 (alen<Int> (opt_get1 $Snap.unit res@79@03))))
(pop) ; 13
; Joined path conditions
(assert (< v@166@03 (alen<Int> (opt_get1 $Snap.unit res@79@03))))
(assert ($FVF.loc_bool ($FVF.lookup_bool (as sm@193@03  $FVF<Bool>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit res@79@03) v@166@03)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit res@79@03) v@166@03)))
(push) ; 13
(assert (not (and
  (<
    (inv@192@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@79@03) v@166@03))
    V@12@03)
  (<=
    0
    (inv@192@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@79@03) v@166@03))))))
(check-sat)
; unsat
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               36553
;  :arith-add-rows          14907
;  :arith-assert-diseq      1123
;  :arith-assert-lower      9814
;  :arith-assert-upper      6043
;  :arith-bound-prop        1578
;  :arith-conflicts         262
;  :arith-eq-adapter        5789
;  :arith-fixed-eqs         4781
;  :arith-offset-eqs        2290
;  :arith-pivots            3716
;  :conflicts               661
;  :datatype-accessor-ax    177
;  :datatype-constructor-ax 453
;  :datatype-occurs-check   234
;  :datatype-splits         139
;  :decisions               4509
;  :del-clause              70909
;  :final-checks            122
;  :interface-eqs           13
;  :max-generation          9
;  :max-memory              10.87
;  :memory                  10.74
;  :minimized-lits          67
;  :mk-bool-var             79481
;  :mk-clause               72423
;  :num-allocs              557831
;  :num-checks              254
;  :propagations            22871
;  :quant-instantiations    23581
;  :rlimit-count            1486512)
(push) ; 13
; [then-branch: 134 | !(Lookup(bool,sm@193@03,aloc((_, _), opt_get1(_, res@79@03), v@166@03))) | live]
; [else-branch: 134 | Lookup(bool,sm@193@03,aloc((_, _), opt_get1(_, res@79@03), v@166@03)) | live]
(push) ; 14
; [then-branch: 134 | !(Lookup(bool,sm@193@03,aloc((_, _), opt_get1(_, res@79@03), v@166@03)))]
(assert (not
  ($FVF.lookup_bool (as sm@193@03  $FVF<Bool>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit res@79@03) v@166@03))))
; [eval] 0 < aloc(opt_get1(aloc(opt_get1(Gf), u).option$array$), k).int
; [eval] aloc(opt_get1(aloc(opt_get1(Gf), u).option$array$), k)
; [eval] opt_get1(aloc(opt_get1(Gf), u).option$array$)
; [eval] aloc(opt_get1(Gf), u)
; [eval] opt_get1(Gf)
(push) ; 15
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 15
; Joined path conditions
(push) ; 15
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 16
(assert (not (< u@161@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))))
(check-sat)
; unsat
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               36554
;  :arith-add-rows          14907
;  :arith-assert-diseq      1123
;  :arith-assert-lower      9814
;  :arith-assert-upper      6043
;  :arith-bound-prop        1578
;  :arith-conflicts         262
;  :arith-eq-adapter        5789
;  :arith-fixed-eqs         4781
;  :arith-offset-eqs        2290
;  :arith-pivots            3716
;  :conflicts               661
;  :datatype-accessor-ax    177
;  :datatype-constructor-ax 453
;  :datatype-occurs-check   234
;  :datatype-splits         139
;  :decisions               4509
;  :del-clause              70909
;  :final-checks            122
;  :interface-eqs           13
;  :max-generation          9
;  :max-memory              10.87
;  :memory                  10.74
;  :minimized-lits          67
;  :mk-bool-var             79481
;  :mk-clause               72423
;  :num-allocs              557916
;  :num-checks              255
;  :propagations            22871
;  :quant-instantiations    23581
;  :rlimit-count            1486643)
(assert (< u@161@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03))))
(pop) ; 15
; Joined path conditions
(assert (< u@161@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) u@161@03)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) u@161@03)))
(push) ; 15
(assert (not (ite
  (and
    (<
      (inv@171@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) u@161@03))
      V@12@03)
    (<=
      0
      (inv@171@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) u@161@03))))
  (< $Perm.No $k@170@03)
  false)))
(check-sat)
; unsat
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               36589
;  :arith-add-rows          14926
;  :arith-assert-diseq      1123
;  :arith-assert-lower      9819
;  :arith-assert-upper      6049
;  :arith-bound-prop        1583
;  :arith-conflicts         263
;  :arith-eq-adapter        5794
;  :arith-fixed-eqs         4786
;  :arith-offset-eqs        2290
;  :arith-pivots            3722
;  :conflicts               662
;  :datatype-accessor-ax    177
;  :datatype-constructor-ax 453
;  :datatype-occurs-check   234
;  :datatype-splits         139
;  :decisions               4509
;  :del-clause              70909
;  :final-checks            122
;  :interface-eqs           13
;  :max-generation          9
;  :max-memory              10.87
;  :memory                  10.72
;  :minimized-lits          67
;  :mk-bool-var             79619
;  :mk-clause               72500
;  :num-allocs              558860
;  :num-checks              256
;  :propagations            22874
;  :quant-instantiations    23644
;  :rlimit-count            1490403)
(push) ; 15
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 16
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) u@161@03))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               36590
;  :arith-add-rows          14926
;  :arith-assert-diseq      1123
;  :arith-assert-lower      9819
;  :arith-assert-upper      6049
;  :arith-bound-prop        1583
;  :arith-conflicts         263
;  :arith-eq-adapter        5794
;  :arith-fixed-eqs         4786
;  :arith-offset-eqs        2290
;  :arith-pivots            3722
;  :conflicts               663
;  :datatype-accessor-ax    177
;  :datatype-constructor-ax 453
;  :datatype-occurs-check   234
;  :datatype-splits         139
;  :decisions               4509
;  :del-clause              70909
;  :final-checks            122
;  :interface-eqs           13
;  :max-generation          9
;  :max-memory              10.87
;  :memory                  10.72
;  :minimized-lits          67
;  :mk-bool-var             79620
;  :mk-clause               72500
;  :num-allocs              558956
;  :num-checks              257
;  :propagations            22874
;  :quant-instantiations    23644
;  :rlimit-count            1490500)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) u@161@03))
    (as None<option<array>>  option<array>))))
(pop) ; 15
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) u@161@03))
    (as None<option<array>>  option<array>))))
(push) ; 15
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 16
(assert (not (<
  v@166@03
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) u@161@03)))))))
(check-sat)
; unsat
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               36600
;  :arith-add-rows          14974
;  :arith-assert-diseq      1123
;  :arith-assert-lower      9822
;  :arith-assert-upper      6050
;  :arith-bound-prop        1584
;  :arith-conflicts         264
;  :arith-eq-adapter        5795
;  :arith-fixed-eqs         4787
;  :arith-offset-eqs        2290
;  :arith-pivots            3726
;  :conflicts               664
;  :datatype-accessor-ax    177
;  :datatype-constructor-ax 453
;  :datatype-occurs-check   234
;  :datatype-splits         139
;  :decisions               4509
;  :del-clause              70911
;  :final-checks            122
;  :interface-eqs           13
;  :max-generation          9
;  :max-memory              10.87
;  :memory                  10.72
;  :minimized-lits          67
;  :mk-bool-var             79632
;  :mk-clause               72502
;  :num-allocs              559166
;  :num-checks              258
;  :propagations            22876
;  :quant-instantiations    23651
;  :rlimit-count            1491759)
(assert (<
  v@166@03
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) u@161@03))))))
(pop) ; 15
; Joined path conditions
(assert (<
  v@166@03
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) u@161@03))))))
(declare-const sm@223@03 $FVF<Int>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@183@03 r) V@12@03) (<= 0 (inv@183@03 r)))
    (=
      ($FVF.lookup_int (as sm@223@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03)))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@223@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03)))))))))))))))) r))
  :qid |qp.fvfValDef87|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@180@03 r) V@12@03) (<= 0 (inv@180@03 r)))
        (< (inv@179@03 r) V@12@03))
      (<= 0 (inv@179@03 r)))
    (=
      ($FVF.lookup_int (as sm@223@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@223@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03))))))))))))))) r))
  :qid |qp.fvfValDef88|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03)))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03))))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@223@03  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef89|)))
(declare-const pm@224@03 $FPM)
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_int (as pm@224@03  $FPM) r)
    (+
      (ite
        (and (< (inv@183@03 r) V@12@03) (<= 0 (inv@183@03 r)))
        $Perm.Write
        $Perm.No)
      (ite
        (and
          (and
            (and (< (inv@180@03 r) V@12@03) (<= 0 (inv@180@03 r)))
            (< (inv@179@03 r) V@12@03))
          (<= 0 (inv@179@03 r)))
        $Perm.Write
        $Perm.No)))
  :pattern (($FVF.perm_int (as pm@224@03  $FPM) r))
  :qid |qp.resPrmSumDef90|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int (as sm@223@03  $FVF<Int>) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03)))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03))))))))))))))) r) r))
  :pattern (($FVF.perm_int (as pm@224@03  $FPM) r))
  :qid |qp.resTrgDef91|)))
(assert ($FVF.loc_int ($FVF.lookup_int (as sm@223@03  $FVF<Int>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) u@161@03))) v@166@03)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) u@161@03))) v@166@03)))
(push) ; 15
(assert (not (<
  $Perm.No
  ($FVF.perm_int (as pm@224@03  $FPM) (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) u@161@03))) v@166@03)))))
(check-sat)
; unsat
(pop) ; 15
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               37392
;  :arith-add-rows          15165
;  :arith-assert-diseq      1146
;  :arith-assert-lower      10016
;  :arith-assert-upper      6158
;  :arith-bound-prop        1607
;  :arith-conflicts         271
;  :arith-eq-adapter        5919
;  :arith-fixed-eqs         4874
;  :arith-offset-eqs        2318
;  :arith-pivots            3758
;  :conflicts               679
;  :datatype-accessor-ax    177
;  :datatype-constructor-ax 457
;  :datatype-occurs-check   234
;  :datatype-splits         139
;  :decisions               4567
;  :del-clause              71987
;  :final-checks            122
;  :interface-eqs           13
;  :max-generation          9
;  :max-memory              11.05
;  :memory                  10.90
;  :minimized-lits          67
;  :mk-bool-var             80905
;  :mk-clause               73688
;  :num-allocs              564310
;  :num-checks              259
;  :propagations            23370
;  :quant-instantiations    24126
;  :rlimit-count            1517341
;  :time                    0.01)
(pop) ; 14
(push) ; 14
; [else-branch: 134 | Lookup(bool,sm@193@03,aloc((_, _), opt_get1(_, res@79@03), v@166@03))]
(assert ($FVF.lookup_bool (as sm@193@03  $FVF<Bool>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit res@79@03) v@166@03)))
(pop) ; 14
(pop) ; 13
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@183@03 r) V@12@03) (<= 0 (inv@183@03 r)))
    (=
      ($FVF.lookup_int (as sm@223@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03)))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@223@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03)))))))))))))))) r))
  :qid |qp.fvfValDef87|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@180@03 r) V@12@03) (<= 0 (inv@180@03 r)))
        (< (inv@179@03 r) V@12@03))
      (<= 0 (inv@179@03 r)))
    (=
      ($FVF.lookup_int (as sm@223@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@223@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03))))))))))))))) r))
  :qid |qp.fvfValDef88|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03)))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03))))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@223@03  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef89|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_int (as pm@224@03  $FPM) r)
    (+
      (ite
        (and (< (inv@183@03 r) V@12@03) (<= 0 (inv@183@03 r)))
        $Perm.Write
        $Perm.No)
      (ite
        (and
          (and
            (and (< (inv@180@03 r) V@12@03) (<= 0 (inv@180@03 r)))
            (< (inv@179@03 r) V@12@03))
          (<= 0 (inv@179@03 r)))
        $Perm.Write
        $Perm.No)))
  :pattern (($FVF.perm_int (as pm@224@03  $FPM) r))
  :qid |qp.resPrmSumDef90|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int (as sm@223@03  $FVF<Int>) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03)))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03))))))))))))))) r) r))
  :pattern (($FVF.perm_int (as pm@224@03  $FPM) r))
  :qid |qp.resTrgDef91|)))
(assert (implies
  (not
    ($FVF.lookup_bool (as sm@193@03  $FVF<Bool>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@79@03) v@166@03)))
  (and
    (not
      ($FVF.lookup_bool (as sm@193@03  $FVF<Bool>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit res@79@03) v@166@03)))
    (< u@161@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) u@161@03)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) u@161@03))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) u@161@03))
        (as None<option<array>>  option<array>)))
    (<
      v@166@03
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) u@161@03)))))
    ($FVF.loc_int ($FVF.lookup_int (as sm@223@03  $FVF<Int>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) u@161@03))) v@166@03)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) u@161@03))) v@166@03)))))
; Joined path conditions
(set-option :timeout 10)
(push) ; 13
(assert (not (not
  (and
    (<
      0
      ($FVF.lookup_int (as sm@223@03  $FVF<Int>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) u@161@03))) v@166@03)))
    (not
      ($FVF.lookup_bool (as sm@193@03  $FVF<Bool>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit res@79@03) v@166@03)))))))
(check-sat)
; unknown
(pop) ; 13
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               38296
;  :arith-add-rows          15320
;  :arith-assert-diseq      1169
;  :arith-assert-lower      10225
;  :arith-assert-upper      6272
;  :arith-bound-prop        1638
;  :arith-conflicts         273
;  :arith-eq-adapter        6052
;  :arith-fixed-eqs         4981
;  :arith-offset-eqs        2352
;  :arith-pivots            3813
;  :conflicts               683
;  :datatype-accessor-ax    177
;  :datatype-constructor-ax 461
;  :datatype-occurs-check   234
;  :datatype-splits         139
;  :decisions               4648
;  :del-clause              73849
;  :final-checks            122
;  :interface-eqs           13
;  :max-generation          9
;  :max-memory              11.05
;  :memory                  10.89
;  :minimized-lits          67
;  :mk-bool-var             82610
;  :mk-clause               75370
;  :num-allocs              570784
;  :num-checks              260
;  :propagations            23942
;  :quant-instantiations    24781
;  :rlimit-count            1550438
;  :time                    0.01)
(push) ; 13
(assert (not (and
  (<
    0
    ($FVF.lookup_int (as sm@223@03  $FVF<Int>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) u@161@03))) v@166@03)))
  (not
    ($FVF.lookup_bool (as sm@193@03  $FVF<Bool>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@79@03) v@166@03))))))
(check-sat)
; unknown
(pop) ; 13
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               39279
;  :arith-add-rows          15448
;  :arith-assert-diseq      1195
;  :arith-assert-lower      10477
;  :arith-assert-upper      6404
;  :arith-bound-prop        1659
;  :arith-conflicts         275
;  :arith-eq-adapter        6191
;  :arith-fixed-eqs         5103
;  :arith-offset-eqs        2397
;  :arith-pivots            3843
;  :conflicts               685
;  :datatype-accessor-ax    177
;  :datatype-constructor-ax 465
;  :datatype-occurs-check   234
;  :datatype-splits         139
;  :decisions               4786
;  :del-clause              76033
;  :final-checks            122
;  :interface-eqs           13
;  :max-generation          9
;  :max-memory              11.05
;  :memory                  10.60
;  :minimized-lits          67
;  :mk-bool-var             84544
;  :mk-clause               77554
;  :num-allocs              576029
;  :num-checks              261
;  :propagations            24701
;  :quant-instantiations    25434
;  :rlimit-count            1579950
;  :time                    0.01)
; [then-branch: 135 | 0 < Lookup(int,sm@223@03,aloc((_, _), opt_get1(_, Lookup(option$array$,sm@172@03,aloc((_, _), opt_get1(_, Gf@11@03), u@161@03))), v@166@03)) && !(Lookup(bool,sm@193@03,aloc((_, _), opt_get1(_, res@79@03), v@166@03))) | live]
; [else-branch: 135 | !(0 < Lookup(int,sm@223@03,aloc((_, _), opt_get1(_, Lookup(option$array$,sm@172@03,aloc((_, _), opt_get1(_, Gf@11@03), u@161@03))), v@166@03)) && !(Lookup(bool,sm@193@03,aloc((_, _), opt_get1(_, res@79@03), v@166@03)))) | live]
(push) ; 13
; [then-branch: 135 | 0 < Lookup(int,sm@223@03,aloc((_, _), opt_get1(_, Lookup(option$array$,sm@172@03,aloc((_, _), opt_get1(_, Gf@11@03), u@161@03))), v@166@03)) && !(Lookup(bool,sm@193@03,aloc((_, _), opt_get1(_, res@79@03), v@166@03)))]
(assert (and
  (<
    0
    ($FVF.lookup_int (as sm@223@03  $FVF<Int>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) u@161@03))) v@166@03)))
  (not
    ($FVF.lookup_bool (as sm@193@03  $FVF<Bool>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@79@03) v@166@03)))))
; [exec]
; queue := queue ++ Seq(k)
; [eval] queue ++ Seq(k)
; [eval] Seq(k)
(assert (= (Seq_length (Seq_singleton v@166@03)) 1))
(declare-const queue@225@03 Seq<Int>)
(assert (Seq_equal queue@225@03 (Seq_append queue@164@03 (Seq_singleton v@166@03))))
; [exec]
; aloc(opt_get1(p), v).int := u
; [eval] aloc(opt_get1(p), v)
; [eval] opt_get1(p)
(push) ; 14
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 14
; Joined path conditions
(push) ; 14
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 15
(assert (not (< v@166@03 (alen<Int> (opt_get1 $Snap.unit p@15@03)))))
(check-sat)
; unsat
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               39375
;  :arith-add-rows          15468
;  :arith-assert-diseq      1195
;  :arith-assert-lower      10494
;  :arith-assert-upper      6419
;  :arith-bound-prop        1666
;  :arith-conflicts         275
;  :arith-eq-adapter        6207
;  :arith-fixed-eqs         5115
;  :arith-offset-eqs        2397
;  :arith-pivots            3855
;  :conflicts               685
;  :datatype-accessor-ax    177
;  :datatype-constructor-ax 465
;  :datatype-occurs-check   234
;  :datatype-splits         139
;  :decisions               4786
;  :del-clause              76033
;  :final-checks            122
;  :interface-eqs           13
;  :max-generation          9
;  :max-memory              11.05
;  :memory                  10.64
;  :minimized-lits          67
;  :mk-bool-var             84890
;  :mk-clause               77771
;  :num-allocs              577572
;  :num-checks              262
;  :propagations            24726
;  :quant-instantiations    25548
;  :rlimit-count            1585728)
(assert (< v@166@03 (alen<Int> (opt_get1 $Snap.unit p@15@03))))
(pop) ; 14
; Joined path conditions
(assert (< v@166@03 (alen<Int> (opt_get1 $Snap.unit p@15@03))))
(declare-const sm@226@03 $FVF<Int>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@183@03 r) V@12@03) (<= 0 (inv@183@03 r)))
    (=
      ($FVF.lookup_int (as sm@226@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03)))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@226@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03)))))))))))))))) r))
  :qid |qp.fvfValDef92|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@180@03 r) V@12@03) (<= 0 (inv@180@03 r)))
        (< (inv@179@03 r) V@12@03))
      (<= 0 (inv@179@03 r)))
    (=
      ($FVF.lookup_int (as sm@226@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@226@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03))))))))))))))) r))
  :qid |qp.fvfValDef93|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03)))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03))))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@226@03  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef94|)))
(assert ($FVF.loc_int ($FVF.lookup_int (as sm@226@03  $FVF<Int>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit p@15@03) v@166@03)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit p@15@03) v@166@03)))
; Precomputing data for removing quantified permissions
(define-fun pTaken@227@03 ((r $Ref)) $Perm
  (ite
    (=
      r
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) v@166@03))
    ($Perm.min
      (ite
        (and (< (inv@183@03 r) V@12@03) (<= 0 (inv@183@03 r)))
        $Perm.Write
        $Perm.No)
      $Perm.Write)
    $Perm.No))
(define-fun pTaken@228@03 ((r $Ref)) $Perm
  (ite
    (=
      r
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) v@166@03))
    ($Perm.min
      (ite
        (and
          (and
            (and (< (inv@180@03 r) V@12@03) (<= 0 (inv@180@03 r)))
            (< (inv@179@03 r) V@12@03))
          (<= 0 (inv@179@03 r)))
        $Perm.Write
        $Perm.No)
      (- $Perm.Write (pTaken@227@03 r)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 500)
(push) ; 14
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and (< (inv@183@03 r) V@12@03) (<= 0 (inv@183@03 r)))
        $Perm.Write
        $Perm.No)
      (pTaken@227@03 r))
    $Perm.No)
  
  ))))
(check-sat)
; unknown
(pop) ; 14
; 0.50s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               89848
;  :arith-add-rows          25290
;  :arith-assert-diseq      1564
;  :arith-assert-lower      22683
;  :arith-assert-upper      16897
;  :arith-bound-prop        2572
;  :arith-conflicts         295
;  :arith-eq-adapter        14353
;  :arith-fixed-eqs         15798
;  :arith-offset-eqs        5717
;  :arith-pivots            6106
;  :conflicts               731
;  :datatype-accessor-ax    184
;  :datatype-constructor-ax 485
;  :datatype-occurs-check   234
;  :datatype-splits         139
;  :decisions               9297
;  :del-clause              180236
;  :final-checks            122
;  :interface-eqs           13
;  :max-generation          10
;  :max-memory              19.91
;  :memory                  18.66
;  :minimized-lits          73
;  :mk-bool-var             202299
;  :mk-clause               182418
;  :num-allocs              961552
;  :num-checks              264
;  :propagations            48308
;  :quant-instantiations    76057
;  :rlimit-count            2399248
;  :time                    0.50)
; Intermediate check if already taken enough permissions
(push) ; 14
(assert (not (forall ((r $Ref)) (!
  (implies
    (=
      r
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) v@166@03))
    (= (- $Perm.Write (pTaken@227@03 r)) $Perm.No))
  
  ))))
(check-sat)
; unsat
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               89915
;  :arith-add-rows          25407
;  :arith-assert-diseq      1569
;  :arith-assert-lower      22690
;  :arith-assert-upper      16908
;  :arith-bound-prop        2577
;  :arith-conflicts         297
;  :arith-eq-adapter        14360
;  :arith-fixed-eqs         15802
;  :arith-offset-eqs        5717
;  :arith-pivots            6110
;  :conflicts               749
;  :datatype-accessor-ax    184
;  :datatype-constructor-ax 485
;  :datatype-occurs-check   234
;  :datatype-splits         139
;  :decisions               9338
;  :del-clause              180775
;  :final-checks            122
;  :interface-eqs           13
;  :max-generation          10
;  :max-memory              19.91
;  :memory                  18.76
;  :minimized-lits          73
;  :mk-bool-var             202680
;  :mk-clause               182957
;  :num-allocs              963001
;  :num-checks              265
;  :propagations            48422
;  :quant-instantiations    76115
;  :rlimit-count            2408975
;  :time                    0.00)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@229@03 $FVF<Int>)
; Definitional axioms for singleton-FVF's value
(assert (=
  ($FVF.lookup_int (as sm@229@03  $FVF<Int>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit p@15@03) v@166@03))
  u@161@03))
(assert ($FVF.loc_int ($FVF.lookup_int (as sm@229@03  $FVF<Int>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit p@15@03) v@166@03)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit p@15@03) v@166@03)))
; [exec]
; aloc(opt_get1(visited), v).bool := true
; [eval] aloc(opt_get1(visited), v)
; [eval] opt_get1(visited)
(push) ; 14
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 14
; Joined path conditions
(push) ; 14
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(pop) ; 14
; Joined path conditions
; Definitional axioms for snapshot map values
; Precomputing data for removing quantified permissions
(define-fun pTaken@230@03 ((r $Ref)) $Perm
  (ite
    (=
      r
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@79@03) v@166@03))
    ($Perm.min
      (ite
        (and (< (inv@192@03 r) V@12@03) (<= 0 (inv@192@03 r)))
        $Perm.Write
        $Perm.No)
      $Perm.Write)
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 500)
(push) ; 14
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and (< (inv@192@03 r) V@12@03) (<= 0 (inv@192@03 r)))
        $Perm.Write
        $Perm.No)
      (pTaken@230@03 r))
    $Perm.No)
  
  ))))
(check-sat)
; unknown
(pop) ; 14
; 0.50s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               145047
;  :arith-add-rows          33751
;  :arith-assert-diseq      2143
;  :arith-assert-lower      37031
;  :arith-assert-upper      29145
;  :arith-bound-prop        3278
;  :arith-conflicts         323
;  :arith-eq-adapter        22328
;  :arith-fixed-eqs         26884
;  :arith-offset-eqs        9097
;  :arith-pivots            7601
;  :conflicts               806
;  :datatype-accessor-ax    188
;  :datatype-constructor-ax 497
;  :datatype-occurs-check   234
;  :datatype-splits         139
;  :decisions               14494
;  :del-clause              275510
;  :final-checks            122
;  :interface-eqs           13
;  :max-generation          10
;  :max-memory              20.43
;  :memory                  19.63
;  :minimized-lits          82
;  :mk-bool-var             313178
;  :mk-clause               277536
;  :num-allocs              1308186
;  :num-checks              267
;  :propagations            74567
;  :quant-instantiations    128407
;  :rlimit-count            3172211
;  :time                    0.50)
; Intermediate check if already taken enough permissions
(push) ; 14
(assert (not (forall ((r $Ref)) (!
  (implies
    (=
      r
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@79@03) v@166@03))
    (= (- $Perm.Write (pTaken@230@03 r)) $Perm.No))
  
  ))))
(check-sat)
; unsat
(pop) ; 14
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               145880
;  :arith-add-rows          33958
;  :arith-assert-diseq      2161
;  :arith-assert-lower      37179
;  :arith-assert-upper      29240
;  :arith-bound-prop        3284
;  :arith-conflicts         325
;  :arith-eq-adapter        22403
;  :arith-fixed-eqs         26966
;  :arith-offset-eqs        9140
;  :arith-pivots            7614
;  :conflicts               824
;  :datatype-accessor-ax    189
;  :datatype-constructor-ax 501
;  :datatype-occurs-check   234
;  :datatype-splits         139
;  :decisions               14624
;  :del-clause              277666
;  :final-checks            122
;  :interface-eqs           13
;  :max-generation          10
;  :max-memory              20.43
;  :memory                  19.59
;  :minimized-lits          82
;  :mk-bool-var             314858
;  :mk-clause               279692
;  :num-allocs              1312431
;  :num-checks              268
;  :propagations            75131
;  :quant-instantiations    128948
;  :rlimit-count            3200806
;  :time                    0.01)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@231@03 $FVF<Bool>)
; Definitional axioms for singleton-FVF's value
(assert (=
  ($FVF.lookup_bool (as sm@231@03  $FVF<Bool>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit res@79@03) v@166@03))
  true))
(assert ($FVF.loc_bool ($FVF.lookup_bool (as sm@231@03  $FVF<Bool>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit res@79@03) v@166@03)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit res@79@03) v@166@03)))
; [exec]
; flatten := v
; [exec]
; v := v + 1
; [eval] v + 1
(declare-const v@232@03 Int)
(assert (= v@232@03 (+ v@166@03 1)))
; [exec]
; evaluationDummy2 := flatten
; Loop head block: Re-establish invariant
; [eval] exc == excBeforeLoop1
; [eval] Gf != (None(): option[array])
; [eval] (None(): option[array])
; [eval] alen(opt_get1(Gf)) == V
; [eval] alen(opt_get1(Gf))
; [eval] opt_get1(Gf)
(push) ; 14
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 14
; Joined path conditions
(declare-const i1@233@03 Int)
(push) ; 14
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 15
; [then-branch: 136 | 0 <= i1@233@03 | live]
; [else-branch: 136 | !(0 <= i1@233@03) | live]
(push) ; 16
; [then-branch: 136 | 0 <= i1@233@03]
(assert (<= 0 i1@233@03))
; [eval] i1 < V
(pop) ; 16
(push) ; 16
; [else-branch: 136 | !(0 <= i1@233@03)]
(assert (not (<= 0 i1@233@03)))
(pop) ; 16
(pop) ; 15
; Joined path conditions
; Joined path conditions
(assert (and (< i1@233@03 V@12@03) (<= 0 i1@233@03)))
(declare-const $k@234@03 $Perm)
(assert ($Perm.isReadVar $k@234@03 $Perm.Write))
; [eval] aloc(opt_get1(Gf), i1)
; [eval] opt_get1(Gf)
(push) ; 15
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 15
; Joined path conditions
(push) ; 15
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 16
(assert (not (< i1@233@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))))
(check-sat)
; unsat
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               145881
;  :arith-add-rows          33959
;  :arith-assert-diseq      2162
;  :arith-assert-lower      37184
;  :arith-assert-upper      29242
;  :arith-bound-prop        3284
;  :arith-conflicts         325
;  :arith-eq-adapter        22405
;  :arith-fixed-eqs         26966
;  :arith-offset-eqs        9140
;  :arith-pivots            7615
;  :conflicts               824
;  :datatype-accessor-ax    189
;  :datatype-constructor-ax 501
;  :datatype-occurs-check   234
;  :datatype-splits         139
;  :decisions               14624
;  :del-clause              277666
;  :final-checks            122
;  :interface-eqs           13
;  :max-generation          10
;  :max-memory              20.43
;  :memory                  19.59
;  :minimized-lits          82
;  :mk-bool-var             314869
;  :mk-clause               279697
;  :num-allocs              1312713
;  :num-checks              269
;  :propagations            75134
;  :quant-instantiations    128948
;  :rlimit-count            3201324)
(assert (< i1@233@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03))))
(pop) ; 15
; Joined path conditions
(assert (< i1@233@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03))))
(pop) ; 14
(declare-fun inv@235@03 ($Ref) Int)
; Nested auxiliary terms: globals
(assert ($Perm.isReadVar $k@234@03 $Perm.Write))
; Nested auxiliary terms: non-globals
(assert (forall ((i1@233@03 Int)) (!
  (< i1@233@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@233@03))
  :qid |option$array$-aux|)))
(push) ; 14
(assert (not (forall ((i1@233@03 Int)) (!
  (implies
    (and (< i1@233@03 V@12@03) (<= 0 i1@233@03))
    (or (= $k@234@03 $Perm.No) (< $Perm.No $k@234@03)))
  
  ))))
(check-sat)
; unsat
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               145881
;  :arith-add-rows          33959
;  :arith-assert-diseq      2163
;  :arith-assert-lower      37186
;  :arith-assert-upper      29243
;  :arith-bound-prop        3284
;  :arith-conflicts         325
;  :arith-eq-adapter        22406
;  :arith-fixed-eqs         26966
;  :arith-offset-eqs        9140
;  :arith-pivots            7615
;  :conflicts               825
;  :datatype-accessor-ax    189
;  :datatype-constructor-ax 501
;  :datatype-occurs-check   234
;  :datatype-splits         139
;  :decisions               14624
;  :del-clause              277668
;  :final-checks            122
;  :interface-eqs           13
;  :max-generation          10
;  :max-memory              20.43
;  :memory                  19.59
;  :minimized-lits          82
;  :mk-bool-var             314876
;  :mk-clause               279699
;  :num-allocs              1313148
;  :num-checks              270
;  :propagations            75135
;  :quant-instantiations    128949
;  :rlimit-count            3201885)
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 14
(assert (not (forall ((i11@233@03 Int) (i12@233@03 Int)) (!
  (implies
    (and
      (and
        (and
          (and (< i11@233@03 V@12@03) (<= 0 i11@233@03))
          ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i11@233@03)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i11@233@03)))
        (< $Perm.No $k@234@03))
      (and
        (and
          (and (< i12@233@03 V@12@03) (<= 0 i12@233@03))
          ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i12@233@03)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i12@233@03)))
        (< $Perm.No $k@234@03))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i11@233@03)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i12@233@03)))
    (= i11@233@03 i12@233@03))
  
  :qid |option$array$-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               145898
;  :arith-add-rows          33961
;  :arith-assert-diseq      2164
;  :arith-assert-lower      37190
;  :arith-assert-upper      29243
;  :arith-bound-prop        3284
;  :arith-conflicts         325
;  :arith-eq-adapter        22407
;  :arith-fixed-eqs         26966
;  :arith-offset-eqs        9140
;  :arith-pivots            7615
;  :conflicts               826
;  :datatype-accessor-ax    189
;  :datatype-constructor-ax 501
;  :datatype-occurs-check   234
;  :datatype-splits         139
;  :decisions               14624
;  :del-clause              277675
;  :final-checks            122
;  :interface-eqs           13
;  :max-generation          10
;  :max-memory              20.43
;  :memory                  19.50
;  :minimized-lits          82
;  :mk-bool-var             314907
;  :mk-clause               279706
;  :num-allocs              1313593
;  :num-checks              271
;  :propagations            75135
;  :quant-instantiations    128978
;  :rlimit-count            3203024)
; Definitional axioms for inverse functions
(assert (forall ((i1@233@03 Int)) (!
  (implies
    (and (and (< i1@233@03 V@12@03) (<= 0 i1@233@03)) (< $Perm.No $k@234@03))
    (=
      (inv@235@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@233@03))
      i1@233@03))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@233@03))
  :qid |option$array$-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and (< (inv@235@03 r) V@12@03) (<= 0 (inv@235@03 r)))
      (< $Perm.No $k@234@03))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) (inv@235@03 r))
      r))
  :pattern ((inv@235@03 r))
  :qid |option$array$-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@235@03 r) V@12@03) (<= 0 (inv@235@03 r)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) r) r))
  :pattern ((inv@235@03 r))
  )))
; Precomputing data for removing quantified permissions
(define-fun pTaken@236@03 ((r $Ref)) $Perm
  (ite
    (and (< (inv@235@03 r) V@12@03) (<= 0 (inv@235@03 r)))
    ($Perm.min
      (ite
        (and (< (inv@171@03 r) V@12@03) (<= 0 (inv@171@03 r)))
        $k@170@03
        $Perm.No)
      $k@234@03)
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Constrain original permissions $k@234@03
(assert (forall ((r $Ref)) (!
  (implies
    (not
      (=
        (ite
          (and (< (inv@171@03 r) V@12@03) (<= 0 (inv@171@03 r)))
          $k@170@03
          $Perm.No)
        $Perm.No))
    (ite
      (and (< (inv@171@03 r) V@12@03) (<= 0 (inv@171@03 r)))
      (<
        (ite
          (and (< (inv@235@03 r) V@12@03) (<= 0 (inv@235@03 r)))
          $k@234@03
          $Perm.No)
        $k@170@03)
      (<
        (ite
          (and (< (inv@235@03 r) V@12@03) (<= 0 (inv@235@03 r)))
          $k@234@03
          $Perm.No)
        $Perm.No)))
  :pattern ((inv@171@03 r))
  :pattern ((inv@235@03 r))
  :qid |qp.srp95|)))
; Intermediate check if already taken enough permissions
(set-option :timeout 500)
(push) ; 14
(assert (not (forall ((r $Ref)) (!
  (implies
    (and (< (inv@235@03 r) V@12@03) (<= 0 (inv@235@03 r)))
    (= (- $k@234@03 (pTaken@236@03 r)) $Perm.No))
  
  ))))
(check-sat)
; unsat
(pop) ; 14
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               147878
;  :arith-add-rows          34269
;  :arith-assert-diseq      2211
;  :arith-assert-lower      37570
;  :arith-assert-upper      29480
;  :arith-bound-prop        3348
;  :arith-conflicts         330
;  :arith-eq-adapter        22635
;  :arith-fixed-eqs         27177
;  :arith-offset-eqs        9254
;  :arith-pivots            7743
;  :conflicts               851
;  :datatype-accessor-ax    191
;  :datatype-constructor-ax 509
;  :datatype-occurs-check   234
;  :datatype-splits         139
;  :decisions               14914
;  :del-clause              282862
;  :final-checks            122
;  :interface-eqs           13
;  :max-generation          10
;  :max-memory              20.43
;  :memory                  19.47
;  :minimized-lits          82
;  :mk-bool-var             319372
;  :mk-clause               284895
;  :num-allocs              1326826
;  :num-checks              273
;  :propagations            76474
;  :quant-instantiations    130426
;  :rlimit-count            3270275
;  :time                    0.01)
; Final check if taken enough permissions
; Done removing quantified permissions
; Definitional axioms for snapshot map values
; [eval] (forall i1: Int :: { aloc(opt_get1(Gf), i1) } 0 <= i1 && i1 < V ==> aloc(opt_get1(Gf), i1).option$array$ != (None(): option[array]))
(declare-const i1@237@03 Int)
(push) ; 14
; [eval] 0 <= i1 && i1 < V ==> aloc(opt_get1(Gf), i1).option$array$ != (None(): option[array])
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 15
; [then-branch: 137 | 0 <= i1@237@03 | live]
; [else-branch: 137 | !(0 <= i1@237@03) | live]
(push) ; 16
; [then-branch: 137 | 0 <= i1@237@03]
(assert (<= 0 i1@237@03))
; [eval] i1 < V
(pop) ; 16
(push) ; 16
; [else-branch: 137 | !(0 <= i1@237@03)]
(assert (not (<= 0 i1@237@03)))
(pop) ; 16
(pop) ; 15
; Joined path conditions
; Joined path conditions
(push) ; 15
; [then-branch: 138 | i1@237@03 < V@12@03 && 0 <= i1@237@03 | live]
; [else-branch: 138 | !(i1@237@03 < V@12@03 && 0 <= i1@237@03) | live]
(push) ; 16
; [then-branch: 138 | i1@237@03 < V@12@03 && 0 <= i1@237@03]
(assert (and (< i1@237@03 V@12@03) (<= 0 i1@237@03)))
; [eval] aloc(opt_get1(Gf), i1).option$array$ != (None(): option[array])
; [eval] aloc(opt_get1(Gf), i1)
; [eval] opt_get1(Gf)
(push) ; 17
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 17
; Joined path conditions
(push) ; 17
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 18
(assert (not (< i1@237@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))))
(check-sat)
; unsat
(pop) ; 18
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               147878
;  :arith-add-rows          34269
;  :arith-assert-diseq      2211
;  :arith-assert-lower      37572
;  :arith-assert-upper      29480
;  :arith-bound-prop        3348
;  :arith-conflicts         330
;  :arith-eq-adapter        22635
;  :arith-fixed-eqs         27177
;  :arith-offset-eqs        9254
;  :arith-pivots            7743
;  :conflicts               851
;  :datatype-accessor-ax    191
;  :datatype-constructor-ax 509
;  :datatype-occurs-check   234
;  :datatype-splits         139
;  :decisions               14914
;  :del-clause              282862
;  :final-checks            122
;  :interface-eqs           13
;  :max-generation          10
;  :max-memory              20.43
;  :memory                  19.47
;  :minimized-lits          82
;  :mk-bool-var             319374
;  :mk-clause               284895
;  :num-allocs              1326935
;  :num-checks              274
;  :propagations            76474
;  :quant-instantiations    130426
;  :rlimit-count            3270463)
(assert (< i1@237@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03))))
(pop) ; 17
; Joined path conditions
(assert (< i1@237@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@237@03)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@237@03)))
(push) ; 17
(assert (not (ite
  (and
    (<
      (inv@171@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@237@03))
      V@12@03)
    (<=
      0
      (inv@171@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@237@03))))
  (< $Perm.No $k@170@03)
  false)))
(check-sat)
; unsat
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               147914
;  :arith-add-rows          34295
;  :arith-assert-diseq      2211
;  :arith-assert-lower      37579
;  :arith-assert-upper      29488
;  :arith-bound-prop        3355
;  :arith-conflicts         331
;  :arith-eq-adapter        22643
;  :arith-fixed-eqs         27184
;  :arith-offset-eqs        9254
;  :arith-pivots            7751
;  :conflicts               852
;  :datatype-accessor-ax    191
;  :datatype-constructor-ax 509
;  :datatype-occurs-check   234
;  :datatype-splits         139
;  :decisions               14914
;  :del-clause              282862
;  :final-checks            122
;  :interface-eqs           13
;  :max-generation          10
;  :max-memory              20.43
;  :memory                  19.48
;  :minimized-lits          82
;  :mk-bool-var             319548
;  :mk-clause               285005
;  :num-allocs              1327988
;  :num-checks              275
;  :propagations            76488
;  :quant-instantiations    130501
;  :rlimit-count            3275155)
; [eval] (None(): option[array])
(pop) ; 16
(push) ; 16
; [else-branch: 138 | !(i1@237@03 < V@12@03 && 0 <= i1@237@03)]
(assert (not (and (< i1@237@03 V@12@03) (<= 0 i1@237@03))))
(pop) ; 16
(pop) ; 15
; Joined path conditions
(assert (implies
  (and (< i1@237@03 V@12@03) (<= 0 i1@237@03))
  (and
    (< i1@237@03 V@12@03)
    (<= 0 i1@237@03)
    (< i1@237@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@237@03)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@237@03)))))
; Joined path conditions
(pop) ; 14
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@237@03 Int)) (!
  (implies
    (and (< i1@237@03 V@12@03) (<= 0 i1@237@03))
    (and
      (< i1@237@03 V@12@03)
      (<= 0 i1@237@03)
      (< i1@237@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@237@03)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@237@03))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@237@03))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(push) ; 14
(assert (not (forall ((i1@237@03 Int)) (!
  (implies
    (and (< i1@237@03 V@12@03) (<= 0 i1@237@03))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@237@03))
        (as None<option<array>>  option<array>))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@237@03))
  :qid |prog.l<no position>|))))
(check-sat)
; unsat
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               147923
;  :arith-add-rows          34307
;  :arith-assert-diseq      2211
;  :arith-assert-lower      37582
;  :arith-assert-upper      29489
;  :arith-bound-prop        3356
;  :arith-conflicts         331
;  :arith-eq-adapter        22645
;  :arith-fixed-eqs         27185
;  :arith-offset-eqs        9254
;  :arith-pivots            7761
;  :conflicts               853
;  :datatype-accessor-ax    191
;  :datatype-constructor-ax 509
;  :datatype-occurs-check   234
;  :datatype-splits         139
;  :decisions               14914
;  :del-clause              283090
;  :final-checks            122
;  :interface-eqs           13
;  :max-generation          10
;  :max-memory              20.43
;  :memory                  19.45
;  :minimized-lits          82
;  :mk-bool-var             319658
;  :mk-clause               285123
;  :num-allocs              1329058
;  :num-checks              276
;  :propagations            76490
;  :quant-instantiations    130560
;  :rlimit-count            3278847)
(assert (forall ((i1@237@03 Int)) (!
  (implies
    (and (< i1@237@03 V@12@03) (<= 0 i1@237@03))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@237@03))
        (as None<option<array>>  option<array>))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@237@03))
  :qid |prog.l<no position>|)))
; [eval] (forall i1: Int :: { alen(opt_get1(aloc(opt_get1(Gf), i1).option$array$)) } 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(Gf), i1).option$array$)) == V)
(declare-const i1@238@03 Int)
(push) ; 14
; [eval] 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(Gf), i1).option$array$)) == V
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 15
; [then-branch: 139 | 0 <= i1@238@03 | live]
; [else-branch: 139 | !(0 <= i1@238@03) | live]
(push) ; 16
; [then-branch: 139 | 0 <= i1@238@03]
(assert (<= 0 i1@238@03))
; [eval] i1 < V
(pop) ; 16
(push) ; 16
; [else-branch: 139 | !(0 <= i1@238@03)]
(assert (not (<= 0 i1@238@03)))
(pop) ; 16
(pop) ; 15
; Joined path conditions
; Joined path conditions
(push) ; 15
; [then-branch: 140 | i1@238@03 < V@12@03 && 0 <= i1@238@03 | live]
; [else-branch: 140 | !(i1@238@03 < V@12@03 && 0 <= i1@238@03) | live]
(push) ; 16
; [then-branch: 140 | i1@238@03 < V@12@03 && 0 <= i1@238@03]
(assert (and (< i1@238@03 V@12@03) (<= 0 i1@238@03)))
; [eval] alen(opt_get1(aloc(opt_get1(Gf), i1).option$array$)) == V
; [eval] alen(opt_get1(aloc(opt_get1(Gf), i1).option$array$))
; [eval] opt_get1(aloc(opt_get1(Gf), i1).option$array$)
; [eval] aloc(opt_get1(Gf), i1)
; [eval] opt_get1(Gf)
(push) ; 17
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 17
; Joined path conditions
(push) ; 17
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 18
(assert (not (< i1@238@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))))
(check-sat)
; unsat
(pop) ; 18
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               147923
;  :arith-add-rows          34307
;  :arith-assert-diseq      2211
;  :arith-assert-lower      37584
;  :arith-assert-upper      29489
;  :arith-bound-prop        3356
;  :arith-conflicts         331
;  :arith-eq-adapter        22645
;  :arith-fixed-eqs         27185
;  :arith-offset-eqs        9254
;  :arith-pivots            7761
;  :conflicts               853
;  :datatype-accessor-ax    191
;  :datatype-constructor-ax 509
;  :datatype-occurs-check   234
;  :datatype-splits         139
;  :decisions               14914
;  :del-clause              283090
;  :final-checks            122
;  :interface-eqs           13
;  :max-generation          10
;  :max-memory              20.43
;  :memory                  19.45
;  :minimized-lits          82
;  :mk-bool-var             319661
;  :mk-clause               285123
;  :num-allocs              1329361
;  :num-checks              277
;  :propagations            76490
;  :quant-instantiations    130560
;  :rlimit-count            3279345)
(assert (< i1@238@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03))))
(pop) ; 17
; Joined path conditions
(assert (< i1@238@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@238@03)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@238@03)))
(push) ; 17
(assert (not (ite
  (and
    (<
      (inv@171@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@238@03))
      V@12@03)
    (<=
      0
      (inv@171@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@238@03))))
  (< $Perm.No $k@170@03)
  false)))
(check-sat)
; unsat
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               147959
;  :arith-add-rows          34333
;  :arith-assert-diseq      2211
;  :arith-assert-lower      37591
;  :arith-assert-upper      29497
;  :arith-bound-prop        3363
;  :arith-conflicts         332
;  :arith-eq-adapter        22653
;  :arith-fixed-eqs         27192
;  :arith-offset-eqs        9254
;  :arith-pivots            7769
;  :conflicts               854
;  :datatype-accessor-ax    191
;  :datatype-constructor-ax 509
;  :datatype-occurs-check   234
;  :datatype-splits         139
;  :decisions               14914
;  :del-clause              283090
;  :final-checks            122
;  :interface-eqs           13
;  :max-generation          10
;  :max-memory              20.43
;  :memory                  19.45
;  :minimized-lits          82
;  :mk-bool-var             319835
;  :mk-clause               285233
;  :num-allocs              1330421
;  :num-checks              278
;  :propagations            76504
;  :quant-instantiations    130636
;  :rlimit-count            3284067)
(push) ; 17
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 18
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@238@03))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 18
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               147959
;  :arith-add-rows          34333
;  :arith-assert-diseq      2211
;  :arith-assert-lower      37591
;  :arith-assert-upper      29497
;  :arith-bound-prop        3363
;  :arith-conflicts         332
;  :arith-eq-adapter        22653
;  :arith-fixed-eqs         27192
;  :arith-offset-eqs        9254
;  :arith-pivots            7769
;  :conflicts               855
;  :datatype-accessor-ax    191
;  :datatype-constructor-ax 509
;  :datatype-occurs-check   234
;  :datatype-splits         139
;  :decisions               14914
;  :del-clause              283090
;  :final-checks            122
;  :interface-eqs           13
;  :max-generation          10
;  :max-memory              20.43
;  :memory                  19.45
;  :minimized-lits          82
;  :mk-bool-var             319835
;  :mk-clause               285233
;  :num-allocs              1330511
;  :num-checks              279
;  :propagations            76504
;  :quant-instantiations    130636
;  :rlimit-count            3284162)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@238@03))
    (as None<option<array>>  option<array>))))
(pop) ; 17
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@238@03))
    (as None<option<array>>  option<array>))))
(pop) ; 16
(push) ; 16
; [else-branch: 140 | !(i1@238@03 < V@12@03 && 0 <= i1@238@03)]
(assert (not (and (< i1@238@03 V@12@03) (<= 0 i1@238@03))))
(pop) ; 16
(pop) ; 15
; Joined path conditions
(assert (implies
  (and (< i1@238@03 V@12@03) (<= 0 i1@238@03))
  (and
    (< i1@238@03 V@12@03)
    (<= 0 i1@238@03)
    (< i1@238@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@238@03)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@238@03))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@238@03))
        (as None<option<array>>  option<array>))))))
; Joined path conditions
(pop) ; 14
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@238@03 Int)) (!
  (implies
    (and (< i1@238@03 V@12@03) (<= 0 i1@238@03))
    (and
      (< i1@238@03 V@12@03)
      (<= 0 i1@238@03)
      (< i1@238@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@238@03)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@238@03))
      (not
        (=
          ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@238@03))
          (as None<option<array>>  option<array>)))))
  :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@238@03)))))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(push) ; 14
(assert (not (forall ((i1@238@03 Int)) (!
  (implies
    (and (< i1@238@03 V@12@03) (<= 0 i1@238@03))
    (=
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@238@03))))
      V@12@03))
  :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@238@03)))))
  :qid |prog.l<no position>|))))
(check-sat)
; unsat
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               147959
;  :arith-add-rows          34342
;  :arith-assert-diseq      2211
;  :arith-assert-lower      37593
;  :arith-assert-upper      29497
;  :arith-bound-prop        3363
;  :arith-conflicts         332
;  :arith-eq-adapter        22654
;  :arith-fixed-eqs         27192
;  :arith-offset-eqs        9254
;  :arith-pivots            7777
;  :conflicts               856
;  :datatype-accessor-ax    191
;  :datatype-constructor-ax 509
;  :datatype-occurs-check   234
;  :datatype-splits         139
;  :decisions               14914
;  :del-clause              283210
;  :final-checks            122
;  :interface-eqs           13
;  :max-generation          10
;  :max-memory              20.43
;  :memory                  19.43
;  :minimized-lits          82
;  :mk-bool-var             319862
;  :mk-clause               285243
;  :num-allocs              1331060
;  :num-checks              280
;  :propagations            76504
;  :quant-instantiations    130660
;  :rlimit-count            3285587)
(assert (forall ((i1@238@03 Int)) (!
  (implies
    (and (< i1@238@03 V@12@03) (<= 0 i1@238@03))
    (=
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@238@03))))
      V@12@03))
  :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@238@03)))))
  :qid |prog.l<no position>|)))
; [eval] (forall i1: Int :: { aloc(opt_get1(Gf), i1) } (forall i2: Int :: { aloc(opt_get1(Gf), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(Gf), i1).option$array$ == aloc(opt_get1(Gf), i2).option$array$ ==> i1 == i2))
(declare-const i1@239@03 Int)
(push) ; 14
; [eval] (forall i2: Int :: { aloc(opt_get1(Gf), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(Gf), i1).option$array$ == aloc(opt_get1(Gf), i2).option$array$ ==> i1 == i2)
(declare-const i2@240@03 Int)
(push) ; 15
; [eval] 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(Gf), i1).option$array$ == aloc(opt_get1(Gf), i2).option$array$ ==> i1 == i2
; [eval] 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(Gf), i1).option$array$ == aloc(opt_get1(Gf), i2).option$array$
; [eval] 0 <= i1
(push) ; 16
; [then-branch: 141 | 0 <= i1@239@03 | live]
; [else-branch: 141 | !(0 <= i1@239@03) | live]
(push) ; 17
; [then-branch: 141 | 0 <= i1@239@03]
(assert (<= 0 i1@239@03))
; [eval] i1 < V
(push) ; 18
; [then-branch: 142 | i1@239@03 < V@12@03 | live]
; [else-branch: 142 | !(i1@239@03 < V@12@03) | live]
(push) ; 19
; [then-branch: 142 | i1@239@03 < V@12@03]
(assert (< i1@239@03 V@12@03))
; [eval] 0 <= i2
(push) ; 20
; [then-branch: 143 | 0 <= i2@240@03 | live]
; [else-branch: 143 | !(0 <= i2@240@03) | live]
(push) ; 21
; [then-branch: 143 | 0 <= i2@240@03]
(assert (<= 0 i2@240@03))
; [eval] i2 < V
(push) ; 22
; [then-branch: 144 | i2@240@03 < V@12@03 | live]
; [else-branch: 144 | !(i2@240@03 < V@12@03) | live]
(push) ; 23
; [then-branch: 144 | i2@240@03 < V@12@03]
(assert (< i2@240@03 V@12@03))
; [eval] aloc(opt_get1(Gf), i1).option$array$ == aloc(opt_get1(Gf), i2).option$array$
; [eval] aloc(opt_get1(Gf), i1)
; [eval] opt_get1(Gf)
(push) ; 24
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 24
; Joined path conditions
(push) ; 24
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 25
(assert (not (< i1@239@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))))
(check-sat)
; unsat
(pop) ; 25
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               147959
;  :arith-add-rows          34342
;  :arith-assert-diseq      2211
;  :arith-assert-lower      37597
;  :arith-assert-upper      29497
;  :arith-bound-prop        3363
;  :arith-conflicts         332
;  :arith-eq-adapter        22654
;  :arith-fixed-eqs         27192
;  :arith-offset-eqs        9254
;  :arith-pivots            7777
;  :conflicts               856
;  :datatype-accessor-ax    191
;  :datatype-constructor-ax 509
;  :datatype-occurs-check   234
;  :datatype-splits         139
;  :decisions               14914
;  :del-clause              283210
;  :final-checks            122
;  :interface-eqs           13
;  :max-generation          10
;  :max-memory              20.43
;  :memory                  19.43
;  :minimized-lits          82
;  :mk-bool-var             319867
;  :mk-clause               285243
;  :num-allocs              1331540
;  :num-checks              281
;  :propagations            76504
;  :quant-instantiations    130660
;  :rlimit-count            3286230)
(assert (< i1@239@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03))))
(pop) ; 24
; Joined path conditions
(assert (< i1@239@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@239@03)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@239@03)))
(push) ; 24
(assert (not (ite
  (and
    (<
      (inv@171@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@239@03))
      V@12@03)
    (<=
      0
      (inv@171@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@239@03))))
  (< $Perm.No $k@170@03)
  false)))
(check-sat)
; unsat
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               147995
;  :arith-add-rows          34368
;  :arith-assert-diseq      2211
;  :arith-assert-lower      37604
;  :arith-assert-upper      29505
;  :arith-bound-prop        3370
;  :arith-conflicts         333
;  :arith-eq-adapter        22662
;  :arith-fixed-eqs         27199
;  :arith-offset-eqs        9254
;  :arith-pivots            7785
;  :conflicts               857
;  :datatype-accessor-ax    191
;  :datatype-constructor-ax 509
;  :datatype-occurs-check   234
;  :datatype-splits         139
;  :decisions               14914
;  :del-clause              283210
;  :final-checks            122
;  :interface-eqs           13
;  :max-generation          10
;  :max-memory              20.43
;  :memory                  19.44
;  :minimized-lits          82
;  :mk-bool-var             320041
;  :mk-clause               285353
;  :num-allocs              1332604
;  :num-checks              282
;  :propagations            76518
;  :quant-instantiations    130736
;  :rlimit-count            3290952)
; [eval] aloc(opt_get1(Gf), i2)
; [eval] opt_get1(Gf)
(push) ; 24
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 24
; Joined path conditions
(push) ; 24
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 25
(assert (not (< i2@240@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))))
(check-sat)
; unsat
(pop) ; 25
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               147995
;  :arith-add-rows          34368
;  :arith-assert-diseq      2211
;  :arith-assert-lower      37604
;  :arith-assert-upper      29505
;  :arith-bound-prop        3370
;  :arith-conflicts         333
;  :arith-eq-adapter        22662
;  :arith-fixed-eqs         27199
;  :arith-offset-eqs        9254
;  :arith-pivots            7785
;  :conflicts               857
;  :datatype-accessor-ax    191
;  :datatype-constructor-ax 509
;  :datatype-occurs-check   234
;  :datatype-splits         139
;  :decisions               14914
;  :del-clause              283210
;  :final-checks            122
;  :interface-eqs           13
;  :max-generation          10
;  :max-memory              20.43
;  :memory                  19.44
;  :minimized-lits          82
;  :mk-bool-var             320041
;  :mk-clause               285353
;  :num-allocs              1332630
;  :num-checks              283
;  :propagations            76518
;  :quant-instantiations    130736
;  :rlimit-count            3290982)
(assert (< i2@240@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03))))
(pop) ; 24
; Joined path conditions
(assert (< i2@240@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@240@03)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@240@03)))
(push) ; 24
(assert (not (ite
  (and
    (<
      (inv@171@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@240@03))
      V@12@03)
    (<=
      0
      (inv@171@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@240@03))))
  (< $Perm.No $k@170@03)
  false)))
(check-sat)
; unsat
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               148035
;  :arith-add-rows          34396
;  :arith-assert-diseq      2211
;  :arith-assert-lower      37611
;  :arith-assert-upper      29513
;  :arith-bound-prop        3377
;  :arith-conflicts         334
;  :arith-eq-adapter        22671
;  :arith-fixed-eqs         27206
;  :arith-offset-eqs        9254
;  :arith-pivots            7793
;  :conflicts               858
;  :datatype-accessor-ax    191
;  :datatype-constructor-ax 509
;  :datatype-occurs-check   234
;  :datatype-splits         139
;  :decisions               14914
;  :del-clause              283210
;  :final-checks            122
;  :interface-eqs           13
;  :max-generation          10
;  :max-memory              20.43
;  :memory                  19.45
;  :minimized-lits          82
;  :mk-bool-var             320265
;  :mk-clause               285505
;  :num-allocs              1333820
;  :num-checks              284
;  :propagations            76544
;  :quant-instantiations    130832
;  :rlimit-count            3296804)
(pop) ; 23
(push) ; 23
; [else-branch: 144 | !(i2@240@03 < V@12@03)]
(assert (not (< i2@240@03 V@12@03)))
(pop) ; 23
(pop) ; 22
; Joined path conditions
(assert (implies
  (< i2@240@03 V@12@03)
  (and
    (< i2@240@03 V@12@03)
    (< i1@239@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@239@03)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@239@03))
    (< i2@240@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@240@03)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@240@03)))))
; Joined path conditions
(pop) ; 21
(push) ; 21
; [else-branch: 143 | !(0 <= i2@240@03)]
(assert (not (<= 0 i2@240@03)))
(pop) ; 21
(pop) ; 20
; Joined path conditions
(assert (implies
  (<= 0 i2@240@03)
  (and
    (<= 0 i2@240@03)
    (implies
      (< i2@240@03 V@12@03)
      (and
        (< i2@240@03 V@12@03)
        (< i1@239@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@239@03)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@239@03))
        (< i2@240@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@240@03)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@240@03)))))))
; Joined path conditions
(pop) ; 19
(push) ; 19
; [else-branch: 142 | !(i1@239@03 < V@12@03)]
(assert (not (< i1@239@03 V@12@03)))
(pop) ; 19
(pop) ; 18
; Joined path conditions
(assert (implies
  (< i1@239@03 V@12@03)
  (and
    (< i1@239@03 V@12@03)
    (implies
      (<= 0 i2@240@03)
      (and
        (<= 0 i2@240@03)
        (implies
          (< i2@240@03 V@12@03)
          (and
            (< i2@240@03 V@12@03)
            (< i1@239@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@239@03)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@239@03))
            (< i2@240@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@240@03)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@240@03)))))))))
; Joined path conditions
(pop) ; 17
(push) ; 17
; [else-branch: 141 | !(0 <= i1@239@03)]
(assert (not (<= 0 i1@239@03)))
(pop) ; 17
(pop) ; 16
; Joined path conditions
(assert (implies
  (<= 0 i1@239@03)
  (and
    (<= 0 i1@239@03)
    (implies
      (< i1@239@03 V@12@03)
      (and
        (< i1@239@03 V@12@03)
        (implies
          (<= 0 i2@240@03)
          (and
            (<= 0 i2@240@03)
            (implies
              (< i2@240@03 V@12@03)
              (and
                (< i2@240@03 V@12@03)
                (< i1@239@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@239@03)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@239@03))
                (< i2@240@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@240@03)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@240@03)))))))))))
; Joined path conditions
(push) ; 16
; [then-branch: 145 | Lookup(option$array$,sm@172@03,aloc((_, _), opt_get1(_, Gf@11@03), i1@239@03)) == Lookup(option$array$,sm@172@03,aloc((_, _), opt_get1(_, Gf@11@03), i2@240@03)) && i2@240@03 < V@12@03 && 0 <= i2@240@03 && i1@239@03 < V@12@03 && 0 <= i1@239@03 | live]
; [else-branch: 145 | !(Lookup(option$array$,sm@172@03,aloc((_, _), opt_get1(_, Gf@11@03), i1@239@03)) == Lookup(option$array$,sm@172@03,aloc((_, _), opt_get1(_, Gf@11@03), i2@240@03)) && i2@240@03 < V@12@03 && 0 <= i2@240@03 && i1@239@03 < V@12@03 && 0 <= i1@239@03) | live]
(push) ; 17
; [then-branch: 145 | Lookup(option$array$,sm@172@03,aloc((_, _), opt_get1(_, Gf@11@03), i1@239@03)) == Lookup(option$array$,sm@172@03,aloc((_, _), opt_get1(_, Gf@11@03), i2@240@03)) && i2@240@03 < V@12@03 && 0 <= i2@240@03 && i1@239@03 < V@12@03 && 0 <= i1@239@03]
(assert (and
  (and
    (and
      (and
        (=
          ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@239@03))
          ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@240@03)))
        (< i2@240@03 V@12@03))
      (<= 0 i2@240@03))
    (< i1@239@03 V@12@03))
  (<= 0 i1@239@03)))
; [eval] i1 == i2
(pop) ; 17
(push) ; 17
; [else-branch: 145 | !(Lookup(option$array$,sm@172@03,aloc((_, _), opt_get1(_, Gf@11@03), i1@239@03)) == Lookup(option$array$,sm@172@03,aloc((_, _), opt_get1(_, Gf@11@03), i2@240@03)) && i2@240@03 < V@12@03 && 0 <= i2@240@03 && i1@239@03 < V@12@03 && 0 <= i1@239@03)]
(assert (not
  (and
    (and
      (and
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@239@03))
            ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@240@03)))
          (< i2@240@03 V@12@03))
        (<= 0 i2@240@03))
      (< i1@239@03 V@12@03))
    (<= 0 i1@239@03))))
(pop) ; 17
(pop) ; 16
; Joined path conditions
(assert (implies
  (and
    (and
      (and
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@239@03))
            ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@240@03)))
          (< i2@240@03 V@12@03))
        (<= 0 i2@240@03))
      (< i1@239@03 V@12@03))
    (<= 0 i1@239@03))
  (and
    (=
      ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@239@03))
      ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@240@03)))
    (< i2@240@03 V@12@03)
    (<= 0 i2@240@03)
    (< i1@239@03 V@12@03)
    (<= 0 i1@239@03))))
; Joined path conditions
(pop) ; 15
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i2@240@03 Int)) (!
  (and
    (implies
      (<= 0 i1@239@03)
      (and
        (<= 0 i1@239@03)
        (implies
          (< i1@239@03 V@12@03)
          (and
            (< i1@239@03 V@12@03)
            (implies
              (<= 0 i2@240@03)
              (and
                (<= 0 i2@240@03)
                (implies
                  (< i2@240@03 V@12@03)
                  (and
                    (< i2@240@03 V@12@03)
                    (< i1@239@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))
                    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@239@03)) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@239@03))
                    (< i2@240@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))
                    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@240@03)) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@240@03))))))))))
    (implies
      (and
        (and
          (and
            (and
              (=
                ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@239@03))
                ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@240@03)))
              (< i2@240@03 V@12@03))
            (<= 0 i2@240@03))
          (< i1@239@03 V@12@03))
        (<= 0 i1@239@03))
      (and
        (=
          ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@239@03))
          ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@240@03)))
        (< i2@240@03 V@12@03)
        (<= 0 i2@240@03)
        (< i1@239@03 V@12@03)
        (<= 0 i1@239@03))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@240@03))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 14
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@239@03 Int)) (!
  (forall ((i2@240@03 Int)) (!
    (and
      (implies
        (<= 0 i1@239@03)
        (and
          (<= 0 i1@239@03)
          (implies
            (< i1@239@03 V@12@03)
            (and
              (< i1@239@03 V@12@03)
              (implies
                (<= 0 i2@240@03)
                (and
                  (<= 0 i2@240@03)
                  (implies
                    (< i2@240@03 V@12@03)
                    (and
                      (< i2@240@03 V@12@03)
                      (< i1@239@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))
                      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@239@03)) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@239@03))
                      (< i2@240@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))
                      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@240@03)) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@240@03))))))))))
      (implies
        (and
          (and
            (and
              (and
                (=
                  ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@239@03))
                  ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@240@03)))
                (< i2@240@03 V@12@03))
              (<= 0 i2@240@03))
            (< i1@239@03 V@12@03))
          (<= 0 i1@239@03))
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@239@03))
            ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@240@03)))
          (< i2@240@03 V@12@03)
          (<= 0 i2@240@03)
          (< i1@239@03 V@12@03)
          (<= 0 i1@239@03))))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@240@03))
    :qid |prog.l<no position>-aux|))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@239@03))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(push) ; 14
(assert (not (forall ((i1@239@03 Int)) (!
  (forall ((i2@240@03 Int)) (!
    (implies
      (and
        (and
          (and
            (and
              (=
                ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@239@03))
                ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@240@03)))
              (< i2@240@03 V@12@03))
            (<= 0 i2@240@03))
          (< i1@239@03 V@12@03))
        (<= 0 i1@239@03))
      (= i1@239@03 i2@240@03))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@240@03))
    :qid |prog.l<no position>|))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@239@03))
  :qid |prog.l<no position>|))))
(check-sat)
; unsat
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               148081
;  :arith-add-rows          34422
;  :arith-assert-diseq      2213
;  :arith-assert-lower      37617
;  :arith-assert-upper      29515
;  :arith-bound-prop        3379
;  :arith-conflicts         334
;  :arith-eq-adapter        22688
;  :arith-fixed-eqs         27208
;  :arith-offset-eqs        9254
;  :arith-pivots            7813
;  :conflicts               859
;  :datatype-accessor-ax    191
;  :datatype-constructor-ax 509
;  :datatype-occurs-check   234
;  :datatype-splits         139
;  :decisions               14914
;  :del-clause              283764
;  :final-checks            122
;  :interface-eqs           13
;  :max-generation          10
;  :max-memory              20.43
;  :memory                  19.43
;  :minimized-lits          82
;  :mk-bool-var             320682
;  :mk-clause               285797
;  :num-allocs              1336593
;  :num-checks              285
;  :propagations            76590
;  :quant-instantiations    131013
;  :rlimit-count            3309160
;  :time                    0.00)
(assert (forall ((i1@239@03 Int)) (!
  (forall ((i2@240@03 Int)) (!
    (implies
      (and
        (and
          (and
            (and
              (=
                ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@239@03))
                ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@240@03)))
              (< i2@240@03 V@12@03))
            (<= 0 i2@240@03))
          (< i1@239@03 V@12@03))
        (<= 0 i1@239@03))
      (= i1@239@03 i2@240@03))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@240@03))
    :qid |prog.l<no position>|))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@239@03))
  :qid |prog.l<no position>|)))
; [eval] p != (None(): option[array])
; [eval] (None(): option[array])
; [eval] alen(opt_get1(p)) == V
; [eval] alen(opt_get1(p))
; [eval] opt_get1(p)
(push) ; 14
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 14
; Joined path conditions
; [eval] 0 <= s
; [eval] s < V
; [eval] 0 <= t
; [eval] t < V
(declare-const i1@241@03 Int)
(declare-const j1@242@03 Int)
(push) ; 14
; [eval] 0 <= i1 && i1 < V && (0 <= j1 && j1 < V)
; [eval] 0 <= i1
(push) ; 15
; [then-branch: 146 | 0 <= i1@241@03 | live]
; [else-branch: 146 | !(0 <= i1@241@03) | live]
(push) ; 16
; [then-branch: 146 | 0 <= i1@241@03]
(assert (<= 0 i1@241@03))
; [eval] i1 < V
(push) ; 17
; [then-branch: 147 | i1@241@03 < V@12@03 | live]
; [else-branch: 147 | !(i1@241@03 < V@12@03) | live]
(push) ; 18
; [then-branch: 147 | i1@241@03 < V@12@03]
(assert (< i1@241@03 V@12@03))
; [eval] 0 <= j1
(push) ; 19
; [then-branch: 148 | 0 <= j1@242@03 | live]
; [else-branch: 148 | !(0 <= j1@242@03) | live]
(push) ; 20
; [then-branch: 148 | 0 <= j1@242@03]
(assert (<= 0 j1@242@03))
; [eval] j1 < V
(pop) ; 20
(push) ; 20
; [else-branch: 148 | !(0 <= j1@242@03)]
(assert (not (<= 0 j1@242@03)))
(pop) ; 20
(pop) ; 19
; Joined path conditions
; Joined path conditions
(pop) ; 18
(push) ; 18
; [else-branch: 147 | !(i1@241@03 < V@12@03)]
(assert (not (< i1@241@03 V@12@03)))
(pop) ; 18
(pop) ; 17
; Joined path conditions
; Joined path conditions
(pop) ; 16
(push) ; 16
; [else-branch: 146 | !(0 <= i1@241@03)]
(assert (not (<= 0 i1@241@03)))
(pop) ; 16
(pop) ; 15
; Joined path conditions
; Joined path conditions
(assert (and
  (and (and (< j1@242@03 V@12@03) (<= 0 j1@242@03)) (< i1@241@03 V@12@03))
  (<= 0 i1@241@03)))
; [eval] aloc(opt_get1(aloc(opt_get1(Gf), i1).option$array$), j1)
; [eval] opt_get1(aloc(opt_get1(Gf), i1).option$array$)
; [eval] aloc(opt_get1(Gf), i1)
; [eval] opt_get1(Gf)
(push) ; 15
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 15
; Joined path conditions
(push) ; 15
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 16
(assert (not (< i1@241@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))))
(check-sat)
; unsat
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               148081
;  :arith-add-rows          34422
;  :arith-assert-diseq      2213
;  :arith-assert-lower      37623
;  :arith-assert-upper      29515
;  :arith-bound-prop        3379
;  :arith-conflicts         334
;  :arith-eq-adapter        22688
;  :arith-fixed-eqs         27208
;  :arith-offset-eqs        9254
;  :arith-pivots            7813
;  :conflicts               859
;  :datatype-accessor-ax    191
;  :datatype-constructor-ax 509
;  :datatype-occurs-check   234
;  :datatype-splits         139
;  :decisions               14914
;  :del-clause              283764
;  :final-checks            122
;  :interface-eqs           13
;  :max-generation          10
;  :max-memory              20.43
;  :memory                  19.43
;  :minimized-lits          82
;  :mk-bool-var             320690
;  :mk-clause               285797
;  :num-allocs              1337230
;  :num-checks              286
;  :propagations            76590
;  :quant-instantiations    131014
;  :rlimit-count            3310253)
(assert (< i1@241@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03))))
(pop) ; 15
; Joined path conditions
(assert (< i1@241@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@241@03)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@241@03)))
(push) ; 15
(assert (not (ite
  (and
    (<
      (inv@171@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@241@03))
      V@12@03)
    (<=
      0
      (inv@171@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@241@03))))
  (< $Perm.No $k@170@03)
  false)))
(check-sat)
; unsat
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               148116
;  :arith-add-rows          34448
;  :arith-assert-diseq      2213
;  :arith-assert-lower      37630
;  :arith-assert-upper      29523
;  :arith-bound-prop        3386
;  :arith-conflicts         335
;  :arith-eq-adapter        22696
;  :arith-fixed-eqs         27215
;  :arith-offset-eqs        9254
;  :arith-pivots            7821
;  :conflicts               860
;  :datatype-accessor-ax    191
;  :datatype-constructor-ax 509
;  :datatype-occurs-check   234
;  :datatype-splits         139
;  :decisions               14914
;  :del-clause              283764
;  :final-checks            122
;  :interface-eqs           13
;  :max-generation          10
;  :max-memory              20.43
;  :memory                  19.45
;  :minimized-lits          82
;  :mk-bool-var             320865
;  :mk-clause               285909
;  :num-allocs              1338384
;  :num-checks              287
;  :propagations            76604
;  :quant-instantiations    131097
;  :rlimit-count            3315483)
(push) ; 15
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 16
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@241@03))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               148116
;  :arith-add-rows          34448
;  :arith-assert-diseq      2213
;  :arith-assert-lower      37630
;  :arith-assert-upper      29523
;  :arith-bound-prop        3386
;  :arith-conflicts         335
;  :arith-eq-adapter        22696
;  :arith-fixed-eqs         27215
;  :arith-offset-eqs        9254
;  :arith-pivots            7821
;  :conflicts               861
;  :datatype-accessor-ax    191
;  :datatype-constructor-ax 509
;  :datatype-occurs-check   234
;  :datatype-splits         139
;  :decisions               14914
;  :del-clause              283764
;  :final-checks            122
;  :interface-eqs           13
;  :max-generation          10
;  :max-memory              20.43
;  :memory                  19.45
;  :minimized-lits          82
;  :mk-bool-var             320865
;  :mk-clause               285909
;  :num-allocs              1338474
;  :num-checks              288
;  :propagations            76604
;  :quant-instantiations    131097
;  :rlimit-count            3315578)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@241@03))
    (as None<option<array>>  option<array>))))
(pop) ; 15
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@241@03))
    (as None<option<array>>  option<array>))))
(push) ; 15
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 16
(assert (not (<
  j1@242@03
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@241@03)))))))
(check-sat)
; unsat
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               148122
;  :arith-add-rows          34453
;  :arith-assert-diseq      2213
;  :arith-assert-lower      37632
;  :arith-assert-upper      29525
;  :arith-bound-prop        3386
;  :arith-conflicts         336
;  :arith-eq-adapter        22697
;  :arith-fixed-eqs         27216
;  :arith-offset-eqs        9254
;  :arith-pivots            7825
;  :conflicts               862
;  :datatype-accessor-ax    191
;  :datatype-constructor-ax 509
;  :datatype-occurs-check   234
;  :datatype-splits         139
;  :decisions               14914
;  :del-clause              283768
;  :final-checks            122
;  :interface-eqs           13
;  :max-generation          10
;  :max-memory              20.43
;  :memory                  19.45
;  :minimized-lits          82
;  :mk-bool-var             320876
;  :mk-clause               285913
;  :num-allocs              1338674
;  :num-checks              289
;  :propagations            76606
;  :quant-instantiations    131106
;  :rlimit-count            3316120)
(assert (<
  j1@242@03
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@241@03))))))
(pop) ; 15
; Joined path conditions
(assert (<
  j1@242@03
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@241@03))))))
(pop) ; 14
(declare-fun inv@243@03 ($Ref) Int)
(declare-fun inv@244@03 ($Ref) Int)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(assert (forall ((i1@241@03 Int) (j1@242@03 Int)) (!
  (and
    (< i1@241@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@241@03)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@241@03))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@241@03))
        (as None<option<array>>  option<array>)))
    (<
      j1@242@03
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@241@03))))))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@241@03))) j1@242@03))
  :qid |int-aux|)))
(declare-const sm@245@03 $FVF<Int>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (=
      r
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) v@166@03))
    (=
      ($FVF.lookup_int (as sm@245@03  $FVF<Int>) r)
      ($FVF.lookup_int (as sm@229@03  $FVF<Int>) r)))
  :pattern (($FVF.lookup_int (as sm@245@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int (as sm@229@03  $FVF<Int>) r))
  :qid |qp.fvfValDef96|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@180@03 r) V@12@03) (<= 0 (inv@180@03 r)))
        (< (inv@179@03 r) V@12@03))
      (<= 0 (inv@179@03 r)))
    (=
      ($FVF.lookup_int (as sm@245@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@245@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03))))))))))))))) r))
  :qid |qp.fvfValDef97|)))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (ite
          (and (< (inv@183@03 r) V@12@03) (<= 0 (inv@183@03 r)))
          $Perm.Write
          $Perm.No)
        (pTaken@227@03 r)))
    (=
      ($FVF.lookup_int (as sm@245@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03)))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@245@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03)))))))))))))))) r))
  :qid |qp.fvfValDef98|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int (as sm@229@03  $FVF<Int>) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03)))))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@245@03  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef99|)))
; Check receiver injectivity
(push) ; 14
(assert (not (forall ((i11@241@03 Int) (j11@242@03 Int) (i12@241@03 Int) (j12@242@03 Int)) (!
  (implies
    (and
      (and
        (and
          (and
            (and (< j11@242@03 V@12@03) (<= 0 j11@242@03))
            (< i11@241@03 V@12@03))
          (<= 0 i11@241@03))
        ($FVF.loc_int ($FVF.lookup_int (as sm@245@03  $FVF<Int>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i11@241@03))) j11@242@03)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i11@241@03))) j11@242@03)))
      (and
        (and
          (and
            (and (< j12@242@03 V@12@03) (<= 0 j12@242@03))
            (< i12@241@03 V@12@03))
          (<= 0 i12@241@03))
        ($FVF.loc_int ($FVF.lookup_int (as sm@245@03  $FVF<Int>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i12@241@03))) j12@242@03)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i12@241@03))) j12@242@03)))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i11@241@03))) j11@242@03)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i12@241@03))) j12@242@03)))
    (and (= i11@241@03 i12@241@03) (= j11@242@03 j12@242@03)))
  
  :qid |int-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               148178
;  :arith-add-rows          34465
;  :arith-assert-diseq      2214
;  :arith-assert-lower      37642
;  :arith-assert-upper      29525
;  :arith-bound-prop        3386
;  :arith-conflicts         336
;  :arith-eq-adapter        22709
;  :arith-fixed-eqs         27216
;  :arith-offset-eqs        9254
;  :arith-pivots            7835
;  :conflicts               863
;  :datatype-accessor-ax    191
;  :datatype-constructor-ax 509
;  :datatype-occurs-check   234
;  :datatype-splits         139
;  :decisions               14914
;  :del-clause              284049
;  :final-checks            122
;  :interface-eqs           13
;  :max-generation          10
;  :max-memory              20.43
;  :memory                  19.43
;  :minimized-lits          82
;  :mk-bool-var             321145
;  :mk-clause               286105
;  :num-allocs              1341246
;  :num-checks              290
;  :propagations            76628
;  :quant-instantiations    131228
;  :rlimit-count            3325133
;  :time                    0.00)
; Definitional axioms for inverse functions
(assert (forall ((i1@241@03 Int) (j1@242@03 Int)) (!
  (implies
    (and
      (and (and (< j1@242@03 V@12@03) (<= 0 j1@242@03)) (< i1@241@03 V@12@03))
      (<= 0 i1@241@03))
    (and
      (=
        (inv@243@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@241@03))) j1@242@03))
        i1@241@03)
      (=
        (inv@244@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@241@03))) j1@242@03))
        j1@242@03)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@241@03))) j1@242@03))
  :qid |int-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@244@03 r) V@12@03) (<= 0 (inv@244@03 r)))
        (< (inv@243@03 r) V@12@03))
      (<= 0 (inv@243@03 r)))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) (inv@243@03 r)))) (inv@244@03 r))
      r))
  :pattern ((inv@243@03 r))
  :pattern ((inv@244@03 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@244@03 r) V@12@03) (<= 0 (inv@244@03 r)))
        (< (inv@243@03 r) V@12@03))
      (<= 0 (inv@243@03 r)))
    ($FVF.loc_int ($FVF.lookup_int (as sm@245@03  $FVF<Int>) r) r))
  :pattern ((inv@243@03 r) (inv@244@03 r))
  )))
; Precomputing data for removing quantified permissions
(define-fun pTaken@246@03 ((r $Ref)) $Perm
  (ite
    (and
      (and
        (and (< (inv@244@03 r) V@12@03) (<= 0 (inv@244@03 r)))
        (< (inv@243@03 r) V@12@03))
      (<= 0 (inv@243@03 r)))
    ($Perm.min
      (ite
        (=
          r
          (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) v@166@03))
        $Perm.Write
        $Perm.No)
      $Perm.Write)
    $Perm.No))
(define-fun pTaken@247@03 ((r $Ref)) $Perm
  (ite
    (and
      (and
        (and (< (inv@244@03 r) V@12@03) (<= 0 (inv@244@03 r)))
        (< (inv@243@03 r) V@12@03))
      (<= 0 (inv@243@03 r)))
    ($Perm.min
      (ite
        (and
          (and
            (and (< (inv@180@03 r) V@12@03) (<= 0 (inv@180@03 r)))
            (< (inv@179@03 r) V@12@03))
          (<= 0 (inv@179@03 r)))
        $Perm.Write
        $Perm.No)
      (- $Perm.Write (pTaken@246@03 r)))
    $Perm.No))
(define-fun pTaken@248@03 ((r $Ref)) $Perm
  (ite
    (and
      (and
        (and (< (inv@244@03 r) V@12@03) (<= 0 (inv@244@03 r)))
        (< (inv@243@03 r) V@12@03))
      (<= 0 (inv@243@03 r)))
    ($Perm.min
      (-
        (ite
          (and (< (inv@183@03 r) V@12@03) (<= 0 (inv@183@03 r)))
          $Perm.Write
          $Perm.No)
        (pTaken@227@03 r))
      (- (- $Perm.Write (pTaken@246@03 r)) (pTaken@247@03 r)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 500)
(push) ; 14
(assert (not (=
  (-
    (ite
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) v@166@03)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) v@166@03))
      $Perm.Write
      $Perm.No)
    (pTaken@246@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) v@166@03)))
  $Perm.No)))
(check-sat)
; unknown
(pop) ; 14
; 0.50s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               193771
;  :arith-add-rows          41847
;  :arith-assert-diseq      2778
;  :arith-assert-lower      49487
;  :arith-assert-upper      39526
;  :arith-bound-prop        4031
;  :arith-conflicts         355
;  :arith-eq-adapter        29471
;  :arith-fixed-eqs         36236
;  :arith-offset-eqs        11847
;  :arith-pivots            9176
;  :conflicts               902
;  :datatype-accessor-ax    195
;  :datatype-constructor-ax 520
;  :datatype-occurs-check   234
;  :datatype-splits         139
;  :decisions               19356
;  :del-clause              367686
;  :final-checks            122
;  :interface-eqs           13
;  :max-generation          10
;  :max-memory              20.55
;  :memory                  19.81
;  :minimized-lits          87
;  :mk-bool-var             417558
;  :mk-clause               369745
;  :num-allocs              1639343
;  :num-checks              292
;  :propagations            98433
;  :quant-instantiations    175757
;  :rlimit-count            3962785
;  :time                    0.50)
; Intermediate check if already taken enough permissions
(push) ; 14
(assert (not (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@244@03 r) V@12@03) (<= 0 (inv@244@03 r)))
        (< (inv@243@03 r) V@12@03))
      (<= 0 (inv@243@03 r)))
    (= (- $Perm.Write (pTaken@246@03 r)) $Perm.No))
  
  ))))
(check-sat)
; unknown
(pop) ; 14
; 0.50s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               228820
;  :arith-add-rows          48317
;  :arith-assert-diseq      3226
;  :arith-assert-lower      58671
;  :arith-assert-upper      47137
;  :arith-bound-prop        4627
;  :arith-conflicts         372
;  :arith-eq-adapter        35017
;  :arith-fixed-eqs         42995
;  :arith-offset-eqs        13575
;  :arith-pivots            10447
;  :conflicts               938
;  :datatype-accessor-ax    198
;  :datatype-constructor-ax 527
;  :datatype-occurs-check   234
;  :datatype-splits         139
;  :decisions               22791
;  :del-clause              437203
;  :final-checks            122
;  :interface-eqs           13
;  :max-generation          10
;  :max-memory              20.55
;  :memory                  19.29
;  :minimized-lits          91
;  :mk-bool-var             497369
;  :mk-clause               439262
;  :num-allocs              1886718
;  :num-checks              293
;  :propagations            115093
;  :quant-instantiations    212310
;  :rlimit-count            4486430
;  :time                    0.51)
; Chunk depleted?
(push) ; 14
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and
          (and
            (and (< (inv@180@03 r) V@12@03) (<= 0 (inv@180@03 r)))
            (< (inv@179@03 r) V@12@03))
          (<= 0 (inv@179@03 r)))
        $Perm.Write
        $Perm.No)
      (pTaken@247@03 r))
    $Perm.No)
  
  ))))
(check-sat)
; unknown
(pop) ; 14
; 0.50s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               273674
;  :arith-add-rows          57172
;  :arith-assert-diseq      3590
;  :arith-assert-lower      68383
;  :arith-assert-upper      55594
;  :arith-bound-prop        5263
;  :arith-conflicts         388
;  :arith-eq-adapter        42379
;  :arith-fixed-eqs         50370
;  :arith-offset-eqs        16584
;  :arith-pivots            12411
;  :conflicts               973
;  :datatype-accessor-ax    212
;  :datatype-constructor-ax 562
;  :datatype-occurs-check   234
;  :datatype-splits         139
;  :decisions               25807
;  :del-clause              517671
;  :final-checks            122
;  :interface-eqs           13
;  :max-generation          10
;  :max-memory              21.20
;  :memory                  20.27
;  :minimized-lits          95
;  :mk-bool-var             589860
;  :mk-clause               519730
;  :num-allocs              2168597
;  :num-checks              294
;  :propagations            136616
;  :quant-instantiations    252236
;  :rlimit-count            5142025
;  :time                    0.50)
; Intermediate check if already taken enough permissions
(push) ; 14
(assert (not (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@244@03 r) V@12@03) (<= 0 (inv@244@03 r)))
        (< (inv@243@03 r) V@12@03))
      (<= 0 (inv@243@03 r)))
    (= (- (- $Perm.Write (pTaken@246@03 r)) (pTaken@247@03 r)) $Perm.No))
  
  ))))
(check-sat)
; unsat
(pop) ; 14
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               273988
;  :arith-add-rows          57299
;  :arith-assert-diseq      3619
;  :arith-assert-lower      68445
;  :arith-assert-upper      55660
;  :arith-bound-prop        5289
;  :arith-conflicts         394
;  :arith-eq-adapter        42463
;  :arith-fixed-eqs         50397
;  :arith-offset-eqs        16624
;  :arith-pivots            12458
;  :conflicts               994
;  :datatype-accessor-ax    212
;  :datatype-constructor-ax 562
;  :datatype-occurs-check   234
;  :datatype-splits         139
;  :decisions               25915
;  :del-clause              519421
;  :final-checks            122
;  :interface-eqs           13
;  :max-generation          10
;  :max-memory              21.20
;  :memory                  20.21
;  :minimized-lits          96
;  :mk-bool-var             591249
;  :mk-clause               521480
;  :num-allocs              2173639
;  :num-checks              295
;  :propagations            136964
;  :quant-instantiations    252506
;  :rlimit-count            5167125
;  :time                    0.01)
; Final check if taken enough permissions
; Done removing quantified permissions
; Definitional axioms for snapshot map values
(declare-const i1@249@03 Int)
(push) ; 14
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 15
; [then-branch: 149 | 0 <= i1@249@03 | live]
; [else-branch: 149 | !(0 <= i1@249@03) | live]
(push) ; 16
; [then-branch: 149 | 0 <= i1@249@03]
(assert (<= 0 i1@249@03))
; [eval] i1 < V
(pop) ; 16
(push) ; 16
; [else-branch: 149 | !(0 <= i1@249@03)]
(assert (not (<= 0 i1@249@03)))
(pop) ; 16
(pop) ; 15
; Joined path conditions
; Joined path conditions
(assert (and (< i1@249@03 V@12@03) (<= 0 i1@249@03)))
; [eval] aloc(opt_get1(p), i1)
; [eval] opt_get1(p)
(push) ; 15
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 15
; Joined path conditions
(push) ; 15
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 16
(assert (not (< i1@249@03 (alen<Int> (opt_get1 $Snap.unit p@15@03)))))
(check-sat)
; unsat
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               273988
;  :arith-add-rows          57299
;  :arith-assert-diseq      3619
;  :arith-assert-lower      68447
;  :arith-assert-upper      55660
;  :arith-bound-prop        5289
;  :arith-conflicts         394
;  :arith-eq-adapter        42463
;  :arith-fixed-eqs         50397
;  :arith-offset-eqs        16624
;  :arith-pivots            12458
;  :conflicts               994
;  :datatype-accessor-ax    212
;  :datatype-constructor-ax 562
;  :datatype-occurs-check   234
;  :datatype-splits         139
;  :decisions               25915
;  :del-clause              519421
;  :final-checks            122
;  :interface-eqs           13
;  :max-generation          10
;  :max-memory              21.20
;  :memory                  20.21
;  :minimized-lits          96
;  :mk-bool-var             591251
;  :mk-clause               521480
;  :num-allocs              2173749
;  :num-checks              296
;  :propagations            136964
;  :quant-instantiations    252506
;  :rlimit-count            5167305)
(assert (< i1@249@03 (alen<Int> (opt_get1 $Snap.unit p@15@03))))
(pop) ; 15
; Joined path conditions
(assert (< i1@249@03 (alen<Int> (opt_get1 $Snap.unit p@15@03))))
(pop) ; 14
(declare-fun inv@250@03 ($Ref) Int)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(assert (forall ((i1@249@03 Int)) (!
  (< i1@249@03 (alen<Int> (opt_get1 $Snap.unit p@15@03)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) i1@249@03))
  :qid |int-aux|)))
(declare-const sm@251@03 $FVF<Int>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (ite
          (and (< (inv@183@03 r) V@12@03) (<= 0 (inv@183@03 r)))
          $Perm.Write
          $Perm.No)
        (pTaken@227@03 r)))
    (=
      ($FVF.lookup_int (as sm@251@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03)))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@251@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03)))))))))))))))) r))
  :qid |qp.fvfValDef100|)))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (ite
          (and
            (and
              (and (< (inv@180@03 r) V@12@03) (<= 0 (inv@180@03 r)))
              (< (inv@179@03 r) V@12@03))
            (<= 0 (inv@179@03 r)))
          $Perm.Write
          $Perm.No)
        (pTaken@247@03 r)))
    (=
      ($FVF.lookup_int (as sm@251@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@251@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03))))))))))))))) r))
  :qid |qp.fvfValDef101|)))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (ite
          (=
            r
            (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) v@166@03))
          $Perm.Write
          $Perm.No)
        (pTaken@246@03 r)))
    (=
      ($FVF.lookup_int (as sm@251@03  $FVF<Int>) r)
      ($FVF.lookup_int (as sm@229@03  $FVF<Int>) r)))
  :pattern (($FVF.lookup_int (as sm@251@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int (as sm@229@03  $FVF<Int>) r))
  :qid |qp.fvfValDef102|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03)))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int (as sm@229@03  $FVF<Int>) r) r))
  :pattern (($FVF.lookup_int (as sm@251@03  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef103|)))
; Check receiver injectivity
(push) ; 14
(assert (not (forall ((i11@249@03 Int) (i12@249@03 Int)) (!
  (implies
    (and
      (and
        (and (< i11@249@03 V@12@03) (<= 0 i11@249@03))
        ($FVF.loc_int ($FVF.lookup_int (as sm@251@03  $FVF<Int>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit p@15@03) i11@249@03)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit p@15@03) i11@249@03)))
      (and
        (and (< i12@249@03 V@12@03) (<= 0 i12@249@03))
        ($FVF.loc_int ($FVF.lookup_int (as sm@251@03  $FVF<Int>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit p@15@03) i12@249@03)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit p@15@03) i12@249@03)))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) i11@249@03)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) i12@249@03)))
    (= i11@249@03 i12@249@03))
  
  :qid |int-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               274035
;  :arith-add-rows          57305
;  :arith-assert-diseq      3620
;  :arith-assert-lower      68453
;  :arith-assert-upper      55662
;  :arith-bound-prop        5289
;  :arith-conflicts         394
;  :arith-eq-adapter        42466
;  :arith-fixed-eqs         50399
;  :arith-offset-eqs        16626
;  :arith-pivots            12460
;  :conflicts               995
;  :datatype-accessor-ax    212
;  :datatype-constructor-ax 562
;  :datatype-occurs-check   234
;  :datatype-splits         139
;  :decisions               25915
;  :del-clause              519465
;  :final-checks            122
;  :interface-eqs           13
;  :max-generation          10
;  :max-memory              21.20
;  :memory                  20.12
;  :minimized-lits          96
;  :mk-bool-var             591405
;  :mk-clause               521565
;  :num-allocs              2175616
;  :num-checks              297
;  :propagations            136967
;  :quant-instantiations    252574
;  :rlimit-count            5173424
;  :time                    0.00)
; Definitional axioms for inverse functions
(assert (forall ((i1@249@03 Int)) (!
  (implies
    (and (< i1@249@03 V@12@03) (<= 0 i1@249@03))
    (=
      (inv@250@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) i1@249@03))
      i1@249@03))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) i1@249@03))
  :qid |int-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@250@03 r) V@12@03) (<= 0 (inv@250@03 r)))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) (inv@250@03 r))
      r))
  :pattern ((inv@250@03 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@250@03 r) V@12@03) (<= 0 (inv@250@03 r)))
    ($FVF.loc_int ($FVF.lookup_int (as sm@251@03  $FVF<Int>) r) r))
  :pattern ((inv@250@03 r))
  )))
; Precomputing data for removing quantified permissions
(define-fun pTaken@252@03 ((r $Ref)) $Perm
  (ite
    (and (< (inv@250@03 r) V@12@03) (<= 0 (inv@250@03 r)))
    ($Perm.min
      (-
        (ite
          (and (< (inv@183@03 r) V@12@03) (<= 0 (inv@183@03 r)))
          $Perm.Write
          $Perm.No)
        (pTaken@227@03 r))
      $Perm.Write)
    $Perm.No))
(define-fun pTaken@253@03 ((r $Ref)) $Perm
  (ite
    (and (< (inv@250@03 r) V@12@03) (<= 0 (inv@250@03 r)))
    ($Perm.min
      (-
        (ite
          (and
            (and
              (and (< (inv@180@03 r) V@12@03) (<= 0 (inv@180@03 r)))
              (< (inv@179@03 r) V@12@03))
            (<= 0 (inv@179@03 r)))
          $Perm.Write
          $Perm.No)
        (pTaken@247@03 r))
      (- $Perm.Write (pTaken@252@03 r)))
    $Perm.No))
(define-fun pTaken@254@03 ((r $Ref)) $Perm
  (ite
    (and (< (inv@250@03 r) V@12@03) (<= 0 (inv@250@03 r)))
    ($Perm.min
      (-
        (ite
          (=
            r
            (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) v@166@03))
          $Perm.Write
          $Perm.No)
        (pTaken@246@03 r))
      (- (- $Perm.Write (pTaken@252@03 r)) (pTaken@253@03 r)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 500)
(push) ; 14
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (-
        (ite
          (and (< (inv@183@03 r) V@12@03) (<= 0 (inv@183@03 r)))
          $Perm.Write
          $Perm.No)
        (pTaken@227@03 r))
      (pTaken@252@03 r))
    $Perm.No)
  
  ))))
(check-sat)
; unsat
(pop) ; 14
; 0.02s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               276270
;  :arith-add-rows          57972
;  :arith-assert-diseq      3684
;  :arith-assert-lower      68882
;  :arith-assert-upper      55952
;  :arith-bound-prop        5333
;  :arith-conflicts         401
;  :arith-eq-adapter        42778
;  :arith-fixed-eqs         50640
;  :arith-offset-eqs        16749
;  :arith-pivots            12570
;  :conflicts               1029
;  :datatype-accessor-ax    214
;  :datatype-constructor-ax 570
;  :datatype-occurs-check   234
;  :datatype-splits         139
;  :decisions               26218
;  :del-clause              524851
;  :final-checks            122
;  :interface-eqs           13
;  :max-generation          10
;  :max-memory              21.20
;  :memory                  20.09
;  :minimized-lits          100
;  :mk-bool-var             596683
;  :mk-clause               526949
;  :num-allocs              2191070
;  :num-checks              299
;  :propagations            138306
;  :quant-instantiations    254007
;  :rlimit-count            5235922
;  :time                    0.02)
; Intermediate check if already taken enough permissions
(push) ; 14
(assert (not (forall ((r $Ref)) (!
  (implies
    (and (< (inv@250@03 r) V@12@03) (<= 0 (inv@250@03 r)))
    (= (- $Perm.Write (pTaken@252@03 r)) $Perm.No))
  
  ))))
(check-sat)
; unknown
(pop) ; 14
; 0.51s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               313744
;  :arith-add-rows          67592
;  :arith-assert-diseq      4051
;  :arith-assert-lower      77475
;  :arith-assert-upper      63261
;  :arith-bound-prop        6117
;  :arith-conflicts         421
;  :arith-eq-adapter        48655
;  :arith-fixed-eqs         57328
;  :arith-offset-eqs        18680
;  :arith-pivots            14083
;  :conflicts               1074
;  :datatype-accessor-ax    217
;  :datatype-constructor-ax 577
;  :datatype-occurs-check   234
;  :datatype-splits         139
;  :decisions               29158
;  :del-clause              592425
;  :final-checks            122
;  :interface-eqs           13
;  :max-generation          10
;  :max-memory              21.36
;  :memory                  20.02
;  :minimized-lits          104
;  :mk-bool-var             675065
;  :mk-clause               594523
;  :num-allocs              2434051
;  :num-checks              300
;  :propagations            153972
;  :quant-instantiations    287991
;  :rlimit-count            5806530
;  :time                    0.51)
; Chunk depleted?
(push) ; 14
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (-
        (ite
          (and
            (and
              (and (< (inv@180@03 r) V@12@03) (<= 0 (inv@180@03 r)))
              (< (inv@179@03 r) V@12@03))
            (<= 0 (inv@179@03 r)))
          $Perm.Write
          $Perm.No)
        (pTaken@247@03 r))
      (pTaken@253@03 r))
    $Perm.No)
  
  ))))
(check-sat)
; unsat
(pop) ; 14
; 0.06s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               316433
;  :arith-add-rows          69021
;  :arith-assert-diseq      4112
;  :arith-assert-lower      77990
;  :arith-assert-upper      63631
;  :arith-bound-prop        6264
;  :arith-conflicts         430
;  :arith-eq-adapter        49036
;  :arith-fixed-eqs         57688
;  :arith-offset-eqs        18975
;  :arith-pivots            14333
;  :conflicts               1105
;  :datatype-accessor-ax    219
;  :datatype-constructor-ax 585
;  :datatype-occurs-check   234
;  :datatype-splits         139
;  :decisions               29332
;  :del-clause              597242
;  :final-checks            122
;  :interface-eqs           13
;  :max-generation          10
;  :max-memory              21.36
;  :memory                  20.18
;  :minimized-lits          106
;  :mk-bool-var             681223
;  :mk-clause               599340
;  :num-allocs              2457606
;  :num-checks              301
;  :propagations            155294
;  :quant-instantiations    289347
;  :rlimit-count            5890520
;  :time                    0.06)
; Intermediate check if already taken enough permissions
(push) ; 14
(assert (not (forall ((r $Ref)) (!
  (implies
    (and (< (inv@250@03 r) V@12@03) (<= 0 (inv@250@03 r)))
    (= (- (- $Perm.Write (pTaken@252@03 r)) (pTaken@253@03 r)) $Perm.No))
  
  ))))
(check-sat)
; unknown
(pop) ; 14
; 0.50s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               355182
;  :arith-add-rows          78710
;  :arith-assert-diseq      4682
;  :arith-assert-lower      86882
;  :arith-assert-upper      71353
;  :arith-bound-prop        7044
;  :arith-conflicts         454
;  :arith-eq-adapter        55246
;  :arith-fixed-eqs         64450
;  :arith-offset-eqs        20889
;  :arith-pivots            15975
;  :conflicts               1160
;  :datatype-accessor-ax    222
;  :datatype-constructor-ax 592
;  :datatype-occurs-check   234
;  :datatype-splits         139
;  :decisions               32322
;  :del-clause              664242
;  :final-checks            122
;  :interface-eqs           13
;  :max-generation          10
;  :max-memory              21.59
;  :memory                  20.84
;  :minimized-lits          112
;  :mk-bool-var             759637
;  :mk-clause               666340
;  :num-allocs              2704478
;  :num-checks              302
;  :propagations            171735
;  :quant-instantiations    322918
;  :rlimit-count            6511956
;  :time                    0.50)
; Chunk depleted?
(push) ; 14
(assert (not (=
  (-
    (-
      (ite
        (=
          (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) v@166@03)
          (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) v@166@03))
        $Perm.Write
        $Perm.No)
      (pTaken@246@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) v@166@03)))
    (pTaken@254@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) v@166@03)))
  $Perm.No)))
(check-sat)
; unsat
(pop) ; 14
; 0.02s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               356475
;  :arith-add-rows          79705
;  :arith-assert-diseq      4723
;  :arith-assert-lower      87158
;  :arith-assert-upper      71563
;  :arith-bound-prop        7098
;  :arith-conflicts         467
;  :arith-eq-adapter        55432
;  :arith-fixed-eqs         64610
;  :arith-offset-eqs        21038
;  :arith-pivots            16079
;  :conflicts               1191
;  :datatype-accessor-ax    223
;  :datatype-constructor-ax 596
;  :datatype-occurs-check   234
;  :datatype-splits         139
;  :decisions               32480
;  :del-clause              666952
;  :final-checks            122
;  :interface-eqs           13
;  :max-generation          10
;  :max-memory              21.59
;  :memory                  20.79
;  :minimized-lits          115
;  :mk-bool-var             762430
;  :mk-clause               669050
;  :num-allocs              2713750
;  :num-checks              303
;  :propagations            172523
;  :quant-instantiations    323600
;  :rlimit-count            6559921
;  :time                    0.02)
; Intermediate check if already taken enough permissions
(push) ; 14
(assert (not (forall ((r $Ref)) (!
  (implies
    (and (< (inv@250@03 r) V@12@03) (<= 0 (inv@250@03 r)))
    (=
      (-
        (- (- $Perm.Write (pTaken@252@03 r)) (pTaken@253@03 r))
        (pTaken@254@03 r))
      $Perm.No))
  
  ))))
(check-sat)
; unsat
(pop) ; 14
; 0.06s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               360738
;  :arith-add-rows          81319
;  :arith-assert-diseq      4876
;  :arith-assert-lower      88113
;  :arith-assert-upper      72253
;  :arith-bound-prop        7279
;  :arith-conflicts         484
;  :arith-eq-adapter        56156
;  :arith-fixed-eqs         65199
;  :arith-offset-eqs        21376
;  :arith-pivots            16446
;  :conflicts               1234
;  :datatype-accessor-ax    224
;  :datatype-constructor-ax 600
;  :datatype-occurs-check   234
;  :datatype-splits         139
;  :decisions               32719
;  :del-clause              673915
;  :final-checks            122
;  :interface-eqs           13
;  :max-generation          10
;  :max-memory              21.59
;  :memory                  20.72
;  :minimized-lits          132
;  :mk-bool-var             769831
;  :mk-clause               676013
;  :num-allocs              2740630
;  :num-checks              304
;  :propagations            174901
;  :quant-instantiations    325860
;  :rlimit-count            6664090
;  :time                    0.06)
; Final check if taken enough permissions
; Done removing quantified permissions
; Definitional axioms for snapshot map values
; [eval] valid_graph_vertices(this, p, V)
(push) ; 14
; [eval] this != null
; [eval] p != (None(): option[array])
; [eval] (None(): option[array])
; [eval] alen(opt_get1(p)) == V
; [eval] alen(opt_get1(p))
; [eval] opt_get1(p)
(push) ; 15
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 15
; Joined path conditions
(declare-const i1@255@03 Int)
(push) ; 15
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 16
; [then-branch: 150 | 0 <= i1@255@03 | live]
; [else-branch: 150 | !(0 <= i1@255@03) | live]
(push) ; 17
; [then-branch: 150 | 0 <= i1@255@03]
(assert (<= 0 i1@255@03))
; [eval] i1 < V
(pop) ; 17
(push) ; 17
; [else-branch: 150 | !(0 <= i1@255@03)]
(assert (not (<= 0 i1@255@03)))
(pop) ; 17
(pop) ; 16
; Joined path conditions
; Joined path conditions
(assert (and (< i1@255@03 V@12@03) (<= 0 i1@255@03)))
(declare-const $k@256@03 $Perm)
(assert ($Perm.isReadVar $k@256@03 $Perm.Write))
; [eval] aloc(opt_get1(p), i1)
; [eval] opt_get1(p)
(push) ; 16
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 16
; Joined path conditions
(push) ; 16
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 17
(assert (not (< i1@255@03 (alen<Int> (opt_get1 $Snap.unit p@15@03)))))
(check-sat)
; unsat
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               360738
;  :arith-add-rows          81319
;  :arith-assert-diseq      4877
;  :arith-assert-lower      88117
;  :arith-assert-upper      72254
;  :arith-bound-prop        7279
;  :arith-conflicts         484
;  :arith-eq-adapter        56157
;  :arith-fixed-eqs         65199
;  :arith-offset-eqs        21376
;  :arith-pivots            16446
;  :conflicts               1234
;  :datatype-accessor-ax    224
;  :datatype-constructor-ax 600
;  :datatype-occurs-check   234
;  :datatype-splits         139
;  :decisions               32719
;  :del-clause              673915
;  :final-checks            122
;  :interface-eqs           13
;  :max-generation          10
;  :max-memory              21.59
;  :memory                  20.72
;  :minimized-lits          132
;  :mk-bool-var             769837
;  :mk-clause               676015
;  :num-allocs              2740807
;  :num-checks              305
;  :propagations            174902
;  :quant-instantiations    325860
;  :rlimit-count            6664422)
(assert (< i1@255@03 (alen<Int> (opt_get1 $Snap.unit p@15@03))))
(pop) ; 16
; Joined path conditions
(assert (< i1@255@03 (alen<Int> (opt_get1 $Snap.unit p@15@03))))
(pop) ; 15
(declare-fun inv@257@03 ($Ref) Int)
; Nested auxiliary terms: globals
(assert ($Perm.isReadVar $k@256@03 $Perm.Write))
; Nested auxiliary terms: non-globals
(assert (forall ((i1@255@03 Int)) (!
  (< i1@255@03 (alen<Int> (opt_get1 $Snap.unit p@15@03)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) i1@255@03))
  :qid |int-aux|)))
(push) ; 15
(assert (not (forall ((i1@255@03 Int)) (!
  (implies
    (and (< i1@255@03 V@12@03) (<= 0 i1@255@03))
    (or (= $k@256@03 $Perm.No) (< $Perm.No $k@256@03)))
  
  ))))
(check-sat)
; unsat
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               360738
;  :arith-add-rows          81319
;  :arith-assert-diseq      4878
;  :arith-assert-lower      88119
;  :arith-assert-upper      72255
;  :arith-bound-prop        7279
;  :arith-conflicts         484
;  :arith-eq-adapter        56158
;  :arith-fixed-eqs         65199
;  :arith-offset-eqs        21376
;  :arith-pivots            16446
;  :conflicts               1235
;  :datatype-accessor-ax    224
;  :datatype-constructor-ax 600
;  :datatype-occurs-check   234
;  :datatype-splits         139
;  :decisions               32719
;  :del-clause              673917
;  :final-checks            122
;  :interface-eqs           13
;  :max-generation          10
;  :max-memory              21.59
;  :memory                  20.72
;  :minimized-lits          132
;  :mk-bool-var             769844
;  :mk-clause               676017
;  :num-allocs              2741230
;  :num-checks              306
;  :propagations            174903
;  :quant-instantiations    325861
;  :rlimit-count            6664977)
(declare-const sm@258@03 $FVF<Int>)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (ite
          (and (< (inv@183@03 r) V@12@03) (<= 0 (inv@183@03 r)))
          $Perm.Write
          $Perm.No)
        (pTaken@227@03 r)))
    (=
      ($FVF.lookup_int (as sm@258@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03)))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@258@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03)))))))))))))))) r))
  :qid |qp.fvfValDef104|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@180@03 r) V@12@03) (<= 0 (inv@180@03 r)))
        (< (inv@179@03 r) V@12@03))
      (<= 0 (inv@179@03 r)))
    (=
      ($FVF.lookup_int (as sm@258@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@258@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03))))))))))))))) r))
  :qid |qp.fvfValDef105|)))
(assert (forall ((r $Ref)) (!
  (implies
    (=
      r
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) v@166@03))
    (=
      ($FVF.lookup_int (as sm@258@03  $FVF<Int>) r)
      ($FVF.lookup_int (as sm@229@03  $FVF<Int>) r)))
  :pattern (($FVF.lookup_int (as sm@258@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int (as sm@229@03  $FVF<Int>) r))
  :qid |qp.fvfValDef106|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03)))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int (as sm@229@03  $FVF<Int>) r) r))
  :pattern (($FVF.lookup_int (as sm@258@03  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef107|)))
; Check receiver injectivity
(push) ; 15
(assert (not (forall ((i11@255@03 Int) (i12@255@03 Int)) (!
  (implies
    (and
      (and
        (and
          (and (< i11@255@03 V@12@03) (<= 0 i11@255@03))
          ($FVF.loc_int ($FVF.lookup_int (as sm@258@03  $FVF<Int>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit p@15@03) i11@255@03)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit p@15@03) i11@255@03)))
        (< $Perm.No $k@256@03))
      (and
        (and
          (and (< i12@255@03 V@12@03) (<= 0 i12@255@03))
          ($FVF.loc_int ($FVF.lookup_int (as sm@258@03  $FVF<Int>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit p@15@03) i12@255@03)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit p@15@03) i12@255@03)))
        (< $Perm.No $k@256@03))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) i11@255@03)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) i12@255@03)))
    (= i11@255@03 i12@255@03))
  
  :qid |int-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               360785
;  :arith-add-rows          81321
;  :arith-assert-diseq      4879
;  :arith-assert-lower      88123
;  :arith-assert-upper      72255
;  :arith-bound-prop        7279
;  :arith-conflicts         484
;  :arith-eq-adapter        56159
;  :arith-fixed-eqs         65199
;  :arith-offset-eqs        21376
;  :arith-pivots            16446
;  :conflicts               1236
;  :datatype-accessor-ax    224
;  :datatype-constructor-ax 600
;  :datatype-occurs-check   234
;  :datatype-splits         139
;  :decisions               32719
;  :del-clause              673939
;  :final-checks            122
;  :interface-eqs           13
;  :max-generation          10
;  :max-memory              21.59
;  :memory                  20.72
;  :minimized-lits          132
;  :mk-bool-var             769927
;  :mk-clause               676043
;  :num-allocs              2742594
;  :num-checks              307
;  :propagations            174906
;  :quant-instantiations    325932
;  :rlimit-count            6669454
;  :time                    0.00)
; Definitional axioms for inverse functions
(assert (forall ((i1@255@03 Int)) (!
  (implies
    (and (and (< i1@255@03 V@12@03) (<= 0 i1@255@03)) (< $Perm.No $k@256@03))
    (=
      (inv@257@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) i1@255@03))
      i1@255@03))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) i1@255@03))
  :qid |int-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and (< (inv@257@03 r) V@12@03) (<= 0 (inv@257@03 r)))
      (< $Perm.No $k@256@03))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) (inv@257@03 r))
      r))
  :pattern ((inv@257@03 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@257@03 r) V@12@03) (<= 0 (inv@257@03 r)))
    ($FVF.loc_int ($FVF.lookup_int (as sm@258@03  $FVF<Int>) r) r))
  :pattern ((inv@257@03 r))
  )))
; Precomputing data for removing quantified permissions
(define-fun pTaken@259@03 ((r $Ref)) $Perm
  (ite
    (and (< (inv@257@03 r) V@12@03) (<= 0 (inv@257@03 r)))
    ($Perm.min
      (-
        (ite
          (and (< (inv@183@03 r) V@12@03) (<= 0 (inv@183@03 r)))
          $Perm.Write
          $Perm.No)
        (pTaken@227@03 r))
      $k@256@03)
    $Perm.No))
(define-fun pTaken@260@03 ((r $Ref)) $Perm
  (ite
    (and (< (inv@257@03 r) V@12@03) (<= 0 (inv@257@03 r)))
    ($Perm.min
      (ite
        (and
          (and
            (and (< (inv@180@03 r) V@12@03) (<= 0 (inv@180@03 r)))
            (< (inv@179@03 r) V@12@03))
          (<= 0 (inv@179@03 r)))
        $Perm.Write
        $Perm.No)
      (- $k@256@03 (pTaken@259@03 r)))
    $Perm.No))
(define-fun pTaken@261@03 ((r $Ref)) $Perm
  (ite
    (and (< (inv@257@03 r) V@12@03) (<= 0 (inv@257@03 r)))
    ($Perm.min
      (ite
        (=
          r
          (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) v@166@03))
        $Perm.Write
        $Perm.No)
      (- (- $k@256@03 (pTaken@259@03 r)) (pTaken@260@03 r)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Constrain original permissions $k@256@03
(assert (forall ((r $Ref)) (!
  (implies
    (not
      (=
        (-
          (ite
            (and (< (inv@183@03 r) V@12@03) (<= 0 (inv@183@03 r)))
            $Perm.Write
            $Perm.No)
          (pTaken@227@03 r))
        $Perm.No))
    (<
      (ite
        (and (< (inv@257@03 r) V@12@03) (<= 0 (inv@257@03 r)))
        $k@256@03
        $Perm.No)
      (-
        (ite
          (and (< (inv@183@03 r) V@12@03) (<= 0 (inv@183@03 r)))
          $Perm.Write
          $Perm.No)
        (pTaken@227@03 r))))
  :pattern ((inv@183@03 r))
  :pattern ((inv@257@03 r))
  :qid |qp.srp108|)))
; Intermediate check if already taken enough permissions
(set-option :timeout 500)
(push) ; 15
(assert (not (forall ((r $Ref)) (!
  (implies
    (and (< (inv@257@03 r) V@12@03) (<= 0 (inv@257@03 r)))
    (= (- $k@256@03 (pTaken@259@03 r)) $Perm.No))
  
  ))))
(check-sat)
; unknown
(pop) ; 15
; 0.50s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               396705
;  :arith-add-rows          89054
;  :arith-assert-diseq      5327
;  :arith-assert-lower      96815
;  :arith-assert-upper      79438
;  :arith-bound-prop        8030
;  :arith-conflicts         505
;  :arith-eq-adapter        62592
;  :arith-fixed-eqs         71705
;  :arith-offset-eqs        23036
;  :arith-pivots            18042
;  :conflicts               1274
;  :datatype-accessor-ax    229
;  :datatype-constructor-ax 615
;  :datatype-occurs-check   234
;  :datatype-splits         139
;  :decisions               35807
;  :del-clause              749667
;  :final-checks            122
;  :interface-eqs           13
;  :max-generation          10
;  :max-memory              24.23
;  :memory                  22.31
;  :minimized-lits          139
;  :mk-bool-var             855205
;  :mk-clause               751805
;  :num-allocs              3004672
;  :num-checks              309
;  :propagations            190615
;  :quant-instantiations    361857
;  :rlimit-count            7231401
;  :time                    0.50)
; Constrain original permissions $k@256@03
(assert (forall ((r $Ref)) (!
  (implies
    (not
      (=
        (ite
          (and
            (and
              (and (< (inv@180@03 r) V@12@03) (<= 0 (inv@180@03 r)))
              (< (inv@179@03 r) V@12@03))
            (<= 0 (inv@179@03 r)))
          $Perm.Write
          $Perm.No)
        $Perm.No))
    (ite
      (and
        (and
          (and (< (inv@180@03 r) V@12@03) (<= 0 (inv@180@03 r)))
          (< (inv@179@03 r) V@12@03))
        (<= 0 (inv@179@03 r)))
      (<
        (ite
          (and (< (inv@257@03 r) V@12@03) (<= 0 (inv@257@03 r)))
          $k@256@03
          $Perm.No)
        $Perm.Write)
      (<
        (ite
          (and (< (inv@257@03 r) V@12@03) (<= 0 (inv@257@03 r)))
          $k@256@03
          $Perm.No)
        $Perm.No)))
  :pattern ((inv@180@03 r))
  :pattern ((inv@179@03 r))
  :pattern ((inv@257@03 r))
  :qid |qp.srp109|)))
; Intermediate check if already taken enough permissions
(push) ; 15
(assert (not (forall ((r $Ref)) (!
  (implies
    (and (< (inv@257@03 r) V@12@03) (<= 0 (inv@257@03 r)))
    (= (- (- $k@256@03 (pTaken@259@03 r)) (pTaken@260@03 r)) $Perm.No))
  
  ))))
(check-sat)
; unknown
(pop) ; 15
; 0.50s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               428332
;  :arith-add-rows          95978
;  :arith-assert-diseq      5727
;  :arith-assert-lower      104596
;  :arith-assert-upper      85706
;  :arith-bound-prop        8713
;  :arith-conflicts         524
;  :arith-eq-adapter        68496
;  :arith-fixed-eqs         77281
;  :arith-offset-eqs        24453
;  :arith-pivots            19502
;  :conflicts               1312
;  :datatype-accessor-ax    235
;  :datatype-constructor-ax 634
;  :datatype-occurs-check   234
;  :datatype-splits         139
;  :decisions               38583
;  :del-clause              823009
;  :final-checks            122
;  :interface-eqs           13
;  :max-generation          10
;  :max-memory              24.23
;  :memory                  23.10
;  :minimized-lits          143
;  :mk-bool-var             935822
;  :mk-clause               825160
;  :num-allocs              3254085
;  :num-checks              310
;  :propagations            204593
;  :quant-instantiations    395118
;  :rlimit-count            7787410
;  :time                    0.50)
; Constrain original permissions $k@256@03
(assert (implies
  (not
    (=
      (ite
        (=
          (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) v@166@03)
          (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) v@166@03))
        $Perm.Write
        $Perm.No)
      $Perm.No))
  (ite
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) v@166@03)
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) v@166@03))
    (<
      (ite
        (and
          (<
            (inv@257@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) v@166@03))
            V@12@03)
          (<=
            0
            (inv@257@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) v@166@03))))
        $k@256@03
        $Perm.No)
      $Perm.Write)
    (<
      (ite
        (and
          (<
            (inv@257@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) v@166@03))
            V@12@03)
          (<=
            0
            (inv@257@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) v@166@03))))
        $k@256@03
        $Perm.No)
      $Perm.No))))
; Intermediate check if already taken enough permissions
(push) ; 15
(assert (not (forall ((r $Ref)) (!
  (implies
    (and (< (inv@257@03 r) V@12@03) (<= 0 (inv@257@03 r)))
    (=
      (- (- (- $k@256@03 (pTaken@259@03 r)) (pTaken@260@03 r)) (pTaken@261@03 r))
      $Perm.No))
  
  ))))
(check-sat)
; unsat
(pop) ; 15
; 0.03s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               430558
;  :arith-add-rows          96782
;  :arith-assert-diseq      5815
;  :arith-assert-lower      105042
;  :arith-assert-upper      86008
;  :arith-bound-prop        8828
;  :arith-conflicts         533
;  :arith-eq-adapter        68844
;  :arith-fixed-eqs         77514
;  :arith-offset-eqs        24705
;  :arith-pivots            19677
;  :conflicts               1343
;  :datatype-accessor-ax    236
;  :datatype-constructor-ax 638
;  :datatype-occurs-check   234
;  :datatype-splits         139
;  :decisions               38838
;  :del-clause              827945
;  :final-checks            122
;  :interface-eqs           13
;  :max-generation          10
;  :max-memory              24.23
;  :memory                  23.04
;  :minimized-lits          143
;  :mk-bool-var             940767
;  :mk-clause               830101
;  :num-allocs              3268582
;  :num-checks              311
;  :propagations            205952
;  :quant-instantiations    396233
;  :rlimit-count            7847926
;  :time                    0.03)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@262@03 $FVF<Int>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (iff
    (Set_in r ($FVF.domain_int (as sm@262@03  $FVF<Int>)))
    (and
      (and (< (inv@257@03 r) V@12@03) (<= 0 (inv@257@03 r)))
      (< $Perm.No $k@256@03)))
  :pattern ((Set_in r ($FVF.domain_int (as sm@262@03  $FVF<Int>))))
  :qid |qp.fvfDomDef115|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@257@03 r) V@12@03) (<= 0 (inv@257@03 r)))
        (< $Perm.No $k@256@03))
      (<
        $Perm.No
        (-
          (ite
            (and (< (inv@183@03 r) V@12@03) (<= 0 (inv@183@03 r)))
            $Perm.Write
            $Perm.No)
          (pTaken@227@03 r))))
    (=
      ($FVF.lookup_int (as sm@262@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03)))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@262@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03)))))))))))))))) r))
  :qid |qp.fvfValDef111|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@257@03 r) V@12@03) (<= 0 (inv@257@03 r)))
        (< $Perm.No $k@256@03))
      (and
        (and
          (and (< (inv@180@03 r) V@12@03) (<= 0 (inv@180@03 r)))
          (< (inv@179@03 r) V@12@03))
        (<= 0 (inv@179@03 r))))
    (=
      ($FVF.lookup_int (as sm@262@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@262@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03))))))))))))))) r))
  :qid |qp.fvfValDef112|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@257@03 r) V@12@03) (<= 0 (inv@257@03 r)))
        (< $Perm.No $k@256@03))
      (=
        r
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) v@166@03)))
    (=
      ($FVF.lookup_int (as sm@262@03  $FVF<Int>) r)
      ($FVF.lookup_int (as sm@229@03  $FVF<Int>) r)))
  :pattern (($FVF.lookup_int (as sm@262@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int (as sm@229@03  $FVF<Int>) r))
  :qid |qp.fvfValDef113|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03)))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int (as sm@229@03  $FVF<Int>) r) r))
  :pattern (($FVF.lookup_int (as sm@262@03  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef114|)))
(pop) ; 14
; Joined path conditions
(assert ($Perm.isReadVar $k@256@03 $Perm.Write))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (ite
          (and (< (inv@183@03 r) V@12@03) (<= 0 (inv@183@03 r)))
          $Perm.Write
          $Perm.No)
        (pTaken@227@03 r)))
    (=
      ($FVF.lookup_int (as sm@258@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03)))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@258@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03)))))))))))))))) r))
  :qid |qp.fvfValDef104|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@180@03 r) V@12@03) (<= 0 (inv@180@03 r)))
        (< (inv@179@03 r) V@12@03))
      (<= 0 (inv@179@03 r)))
    (=
      ($FVF.lookup_int (as sm@258@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@258@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03))))))))))))))) r))
  :qid |qp.fvfValDef105|)))
(assert (forall ((r $Ref)) (!
  (implies
    (=
      r
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) v@166@03))
    (=
      ($FVF.lookup_int (as sm@258@03  $FVF<Int>) r)
      ($FVF.lookup_int (as sm@229@03  $FVF<Int>) r)))
  :pattern (($FVF.lookup_int (as sm@258@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int (as sm@229@03  $FVF<Int>) r))
  :qid |qp.fvfValDef106|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03)))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int (as sm@229@03  $FVF<Int>) r) r))
  :pattern (($FVF.lookup_int (as sm@258@03  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef107|)))
(assert (forall ((i1@255@03 Int)) (!
  (implies
    (and (and (< i1@255@03 V@12@03) (<= 0 i1@255@03)) (< $Perm.No $k@256@03))
    (=
      (inv@257@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) i1@255@03))
      i1@255@03))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) i1@255@03))
  :qid |int-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and (< (inv@257@03 r) V@12@03) (<= 0 (inv@257@03 r)))
      (< $Perm.No $k@256@03))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) (inv@257@03 r))
      r))
  :pattern ((inv@257@03 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (iff
    (Set_in r ($FVF.domain_int (as sm@262@03  $FVF<Int>)))
    (and
      (and (< (inv@257@03 r) V@12@03) (<= 0 (inv@257@03 r)))
      (< $Perm.No $k@256@03)))
  :pattern ((Set_in r ($FVF.domain_int (as sm@262@03  $FVF<Int>))))
  :qid |qp.fvfDomDef115|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@257@03 r) V@12@03) (<= 0 (inv@257@03 r)))
        (< $Perm.No $k@256@03))
      (<
        $Perm.No
        (-
          (ite
            (and (< (inv@183@03 r) V@12@03) (<= 0 (inv@183@03 r)))
            $Perm.Write
            $Perm.No)
          (pTaken@227@03 r))))
    (=
      ($FVF.lookup_int (as sm@262@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03)))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@262@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03)))))))))))))))) r))
  :qid |qp.fvfValDef111|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@257@03 r) V@12@03) (<= 0 (inv@257@03 r)))
        (< $Perm.No $k@256@03))
      (and
        (and
          (and (< (inv@180@03 r) V@12@03) (<= 0 (inv@180@03 r)))
          (< (inv@179@03 r) V@12@03))
        (<= 0 (inv@179@03 r))))
    (=
      ($FVF.lookup_int (as sm@262@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@262@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03))))))))))))))) r))
  :qid |qp.fvfValDef112|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@257@03 r) V@12@03) (<= 0 (inv@257@03 r)))
        (< $Perm.No $k@256@03))
      (=
        r
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) v@166@03)))
    (=
      ($FVF.lookup_int (as sm@262@03  $FVF<Int>) r)
      ($FVF.lookup_int (as sm@229@03  $FVF<Int>) r)))
  :pattern (($FVF.lookup_int (as sm@262@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int (as sm@229@03  $FVF<Int>) r))
  :qid |qp.fvfValDef113|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03)))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int (as sm@229@03  $FVF<Int>) r) r))
  :pattern (($FVF.lookup_int (as sm@262@03  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef114|)))
(assert (and
  (forall ((i1@255@03 Int)) (!
    (< i1@255@03 (alen<Int> (opt_get1 $Snap.unit p@15@03)))
    :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) i1@255@03))
    :qid |int-aux|))
  (forall ((r $Ref)) (!
    (implies
      (and (< (inv@257@03 r) V@12@03) (<= 0 (inv@257@03 r)))
      ($FVF.loc_int ($FVF.lookup_int (as sm@258@03  $FVF<Int>) r) r))
    :pattern ((inv@257@03 r))
    ))
  (forall ((r $Ref)) (!
    (implies
      (not
        (=
          (-
            (ite
              (and (< (inv@183@03 r) V@12@03) (<= 0 (inv@183@03 r)))
              $Perm.Write
              $Perm.No)
            (pTaken@227@03 r))
          $Perm.No))
      (<
        (ite
          (and (< (inv@257@03 r) V@12@03) (<= 0 (inv@257@03 r)))
          $k@256@03
          $Perm.No)
        (-
          (ite
            (and (< (inv@183@03 r) V@12@03) (<= 0 (inv@183@03 r)))
            $Perm.Write
            $Perm.No)
          (pTaken@227@03 r))))
    :pattern ((inv@183@03 r))
    :pattern ((inv@257@03 r))
    :qid |qp.srp108|))
  (forall ((r $Ref)) (!
    (implies
      (not
        (=
          (ite
            (and
              (and
                (and (< (inv@180@03 r) V@12@03) (<= 0 (inv@180@03 r)))
                (< (inv@179@03 r) V@12@03))
              (<= 0 (inv@179@03 r)))
            $Perm.Write
            $Perm.No)
          $Perm.No))
      (ite
        (and
          (and
            (and (< (inv@180@03 r) V@12@03) (<= 0 (inv@180@03 r)))
            (< (inv@179@03 r) V@12@03))
          (<= 0 (inv@179@03 r)))
        (<
          (ite
            (and (< (inv@257@03 r) V@12@03) (<= 0 (inv@257@03 r)))
            $k@256@03
            $Perm.No)
          $Perm.Write)
        (<
          (ite
            (and (< (inv@257@03 r) V@12@03) (<= 0 (inv@257@03 r)))
            $k@256@03
            $Perm.No)
          $Perm.No)))
    :pattern ((inv@180@03 r))
    :pattern ((inv@179@03 r))
    :pattern ((inv@257@03 r))
    :qid |qp.srp109|))
  (implies
    (not
      (=
        (ite
          (=
            (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) v@166@03)
            (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) v@166@03))
          $Perm.Write
          $Perm.No)
        $Perm.No))
    (ite
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) v@166@03)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) v@166@03))
      (<
        (ite
          (and
            (<
              (inv@257@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) v@166@03))
              V@12@03)
            (<=
              0
              (inv@257@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) v@166@03))))
          $k@256@03
          $Perm.No)
        $Perm.Write)
      (<
        (ite
          (and
            (<
              (inv@257@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) v@166@03))
              V@12@03)
            (<=
              0
              (inv@257@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) v@166@03))))
          $k@256@03
          $Perm.No)
        $Perm.No)))))
(set-option :timeout 0)
(push) ; 14
(assert (not (valid_graph_vertices ($Snap.combine
  $Snap.unit
  ($Snap.combine
    $Snap.unit
    ($Snap.combine
      $Snap.unit
      ($SortWrappers.$FVF<Int>To$Snap (as sm@262@03  $FVF<Int>))))) this@9@03 p@15@03 V@12@03)))
(check-sat)
; unsat
(pop) ; 14
; 3.86s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               690164
;  :arith-add-rows          173734
;  :arith-assert-diseq      12247
;  :arith-assert-lower      174058
;  :arith-assert-upper      144269
;  :arith-bound-prop        10903
;  :arith-conflicts         623
;  :arith-eq-adapter        104073
;  :arith-fixed-eqs         131804
;  :arith-offset-eqs        39472
;  :arith-pivots            25789
;  :conflicts               1527
;  :datatype-accessor-ax    248
;  :datatype-constructor-ax 660
;  :datatype-occurs-check   234
;  :datatype-splits         139
;  :decisions               56942
;  :del-clause              1205469
;  :final-checks            122
;  :interface-eqs           13
;  :max-generation          10
;  :max-memory              32.54
;  :memory                  31.15
;  :minimized-lits          178
;  :mk-bool-var             1379815
;  :mk-clause               1207613
;  :num-allocs              4641069
;  :num-checks              312
;  :propagations            337394
;  :quant-instantiations    585817
;  :restarts                1
;  :rlimit-count            10837758
;  :time                    3.86)
(assert (valid_graph_vertices ($Snap.combine
  $Snap.unit
  ($Snap.combine
    $Snap.unit
    ($Snap.combine
      $Snap.unit
      ($SortWrappers.$FVF<Int>To$Snap (as sm@262@03  $FVF<Int>))))) this@9@03 p@15@03 V@12@03))
; [eval] alen(opt_get1(visited)) == V
; [eval] alen(opt_get1(visited))
; [eval] opt_get1(visited)
(push) ; 14
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 14
; Joined path conditions
; [eval] 0 <= u
; [eval] u < V
; [eval] 0 <= v
(push) ; 14
(assert (not (<= 0 v@232@03)))
(check-sat)
; unsat
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               690187
;  :arith-add-rows          173808
;  :arith-assert-diseq      12247
;  :arith-assert-lower      174061
;  :arith-assert-upper      144271
;  :arith-bound-prop        10903
;  :arith-conflicts         624
;  :arith-eq-adapter        104074
;  :arith-fixed-eqs         131805
;  :arith-offset-eqs        39472
;  :arith-pivots            25791
;  :conflicts               1528
;  :datatype-accessor-ax    251
;  :datatype-constructor-ax 660
;  :datatype-occurs-check   234
;  :datatype-splits         139
;  :decisions               56942
;  :del-clause              1205469
;  :final-checks            122
;  :interface-eqs           13
;  :max-generation          10
;  :max-memory              32.54
;  :memory                  31.16
;  :minimized-lits          178
;  :mk-bool-var             1379950
;  :mk-clause               1207719
;  :num-allocs              4641628
;  :num-checks              313
;  :propagations            337405
;  :quant-instantiations    585845
;  :restarts                1
;  :rlimit-count            10840129
;  :time                    0.00)
(assert (<= 0 v@232@03))
; [eval] v <= V
(push) ; 14
(assert (not (<= v@232@03 V@12@03)))
(check-sat)
; unsat
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               690187
;  :arith-add-rows          173945
;  :arith-assert-diseq      12247
;  :arith-assert-lower      174062
;  :arith-assert-upper      144272
;  :arith-bound-prop        10903
;  :arith-conflicts         625
;  :arith-eq-adapter        104074
;  :arith-fixed-eqs         131805
;  :arith-offset-eqs        39472
;  :arith-pivots            25793
;  :conflicts               1529
;  :datatype-accessor-ax    251
;  :datatype-constructor-ax 660
;  :datatype-occurs-check   234
;  :datatype-splits         139
;  :decisions               56942
;  :del-clause              1205469
;  :final-checks            122
;  :interface-eqs           13
;  :max-generation          10
;  :max-memory              32.54
;  :memory                  31.16
;  :minimized-lits          178
;  :mk-bool-var             1379952
;  :mk-clause               1207719
;  :num-allocs              4641788
;  :num-checks              314
;  :propagations            337405
;  :quant-instantiations    585845
;  :restarts                1
;  :rlimit-count            10842804)
(assert (<= v@232@03 V@12@03))
; [eval] 0 <= k
; [eval] k < V
; [eval] valid_graph_vertices1(this, queue, V)
(push) ; 14
; [eval] this != null
(pop) ; 14
; Joined path conditions
(push) ; 14
(assert (not (valid_graph_vertices1 $Snap.unit this@9@03 queue@225@03 V@12@03)))
(check-sat)
; unsat
(pop) ; 14
; 9.19s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1530031
;  :arith-add-rows          401664
;  :arith-assert-diseq      59136
;  :arith-assert-lower      423700
;  :arith-assert-upper      350694
;  :arith-bound-prop        15815
;  :arith-conflicts         911
;  :arith-eq-adapter        204156
;  :arith-fixed-eqs         275249
;  :arith-offset-eqs        91490
;  :arith-pivots            42312
;  :conflicts               2099
;  :datatype-accessor-ax    620
;  :datatype-constructor-ax 1499
;  :datatype-occurs-check   1309
;  :datatype-splits         1167
;  :decisions               125574
;  :del-clause              1933948
;  :final-checks            177
;  :interface-eqs           41
;  :max-generation          15
;  :max-memory              50.39
;  :memory                  46.84
;  :minimized-lits          277
;  :mk-bool-var             2259253
;  :mk-clause               1936198
;  :num-allocs              7572634
;  :num-checks              315
;  :propagations            847827
;  :quant-instantiations    995912
;  :restarts                4
;  :rlimit-count            24658231
;  :time                    9.18)
(assert (valid_graph_vertices1 $Snap.unit this@9@03 queue@225@03 V@12@03))
(declare-const i1@263@03 Int)
(push) ; 14
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 15
; [then-branch: 151 | 0 <= i1@263@03 | live]
; [else-branch: 151 | !(0 <= i1@263@03) | live]
(push) ; 16
; [then-branch: 151 | 0 <= i1@263@03]
(assert (<= 0 i1@263@03))
; [eval] i1 < V
(pop) ; 16
(push) ; 16
; [else-branch: 151 | !(0 <= i1@263@03)]
(assert (not (<= 0 i1@263@03)))
(pop) ; 16
(pop) ; 15
; Joined path conditions
; Joined path conditions
(assert (and (< i1@263@03 V@12@03) (<= 0 i1@263@03)))
; [eval] aloc(opt_get1(visited), i1)
; [eval] opt_get1(visited)
(push) ; 15
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 15
; Joined path conditions
(push) ; 15
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 16
(assert (not (< i1@263@03 (alen<Int> (opt_get1 $Snap.unit res@79@03)))))
(check-sat)
; unsat
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1530032
;  :arith-add-rows          401668
;  :arith-assert-diseq      59136
;  :arith-assert-lower      423702
;  :arith-assert-upper      350694
;  :arith-bound-prop        15815
;  :arith-conflicts         911
;  :arith-eq-adapter        204156
;  :arith-fixed-eqs         275249
;  :arith-offset-eqs        91490
;  :arith-pivots            42312
;  :conflicts               2099
;  :datatype-accessor-ax    620
;  :datatype-constructor-ax 1499
;  :datatype-occurs-check   1309
;  :datatype-splits         1167
;  :decisions               125574
;  :del-clause              1933948
;  :final-checks            177
;  :interface-eqs           41
;  :max-generation          15
;  :max-memory              50.39
;  :memory                  46.85
;  :minimized-lits          277
;  :mk-bool-var             2259274
;  :mk-clause               1936223
;  :num-allocs              7572875
;  :num-checks              316
;  :propagations            847833
;  :quant-instantiations    995915
;  :restarts                4
;  :rlimit-count            24658599)
(assert (< i1@263@03 (alen<Int> (opt_get1 $Snap.unit res@79@03))))
(pop) ; 15
; Joined path conditions
(assert (< i1@263@03 (alen<Int> (opt_get1 $Snap.unit res@79@03))))
(pop) ; 14
(declare-fun inv@264@03 ($Ref) Int)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(assert (forall ((i1@263@03 Int)) (!
  (< i1@263@03 (alen<Int> (opt_get1 $Snap.unit res@79@03)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@79@03) i1@263@03))
  :qid |bool-aux|)))
(declare-const sm@265@03 $FVF<Bool>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (ite
          (and (< (inv@192@03 r) V@12@03) (<= 0 (inv@192@03 r)))
          $Perm.Write
          $Perm.No)
        (pTaken@230@03 r)))
    (=
      ($FVF.lookup_bool (as sm@265@03  $FVF<Bool>) r)
      ($FVF.lookup_bool ($SortWrappers.$SnapTo$FVF<Bool> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03))))))))))))))))))))))))) r)))
  :pattern (($FVF.lookup_bool (as sm@265@03  $FVF<Bool>) r))
  :pattern (($FVF.lookup_bool ($SortWrappers.$SnapTo$FVF<Bool> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03))))))))))))))))))))))))) r))
  :qid |qp.fvfValDef116|)))
(assert (forall ((r $Ref)) (!
  (implies
    (=
      r
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@79@03) v@166@03))
    (=
      ($FVF.lookup_bool (as sm@265@03  $FVF<Bool>) r)
      ($FVF.lookup_bool (as sm@231@03  $FVF<Bool>) r)))
  :pattern (($FVF.lookup_bool (as sm@265@03  $FVF<Bool>) r))
  :pattern (($FVF.lookup_bool (as sm@231@03  $FVF<Bool>) r))
  :qid |qp.fvfValDef117|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_bool ($FVF.lookup_bool ($SortWrappers.$SnapTo$FVF<Bool> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03))))))))))))))))))))))))) r) r)
    ($FVF.loc_bool ($FVF.lookup_bool (as sm@231@03  $FVF<Bool>) r) r))
  :pattern (($FVF.lookup_bool (as sm@265@03  $FVF<Bool>) r))
  :qid |qp.fvfResTrgDef118|)))
; Check receiver injectivity
(push) ; 14
(assert (not (forall ((i11@263@03 Int) (i12@263@03 Int)) (!
  (implies
    (and
      (and
        (and (< i11@263@03 V@12@03) (<= 0 i11@263@03))
        ($FVF.loc_bool ($FVF.lookup_bool (as sm@265@03  $FVF<Bool>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@79@03) i11@263@03)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@79@03) i11@263@03)))
      (and
        (and (< i12@263@03 V@12@03) (<= 0 i12@263@03))
        ($FVF.loc_bool ($FVF.lookup_bool (as sm@265@03  $FVF<Bool>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@79@03) i12@263@03)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@79@03) i12@263@03)))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@79@03) i11@263@03)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@79@03) i12@263@03)))
    (= i11@263@03 i12@263@03))
  
  :qid |bool-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 14
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1530065
;  :arith-add-rows          401676
;  :arith-assert-diseq      59137
;  :arith-assert-lower      423708
;  :arith-assert-upper      350695
;  :arith-bound-prop        15815
;  :arith-conflicts         911
;  :arith-eq-adapter        204158
;  :arith-fixed-eqs         275250
;  :arith-offset-eqs        91491
;  :arith-pivots            42313
;  :conflicts               2100
;  :datatype-accessor-ax    620
;  :datatype-constructor-ax 1499
;  :datatype-occurs-check   1309
;  :datatype-splits         1167
;  :decisions               125574
;  :del-clause              1933976
;  :final-checks            177
;  :interface-eqs           41
;  :max-generation          15
;  :max-memory              50.39
;  :memory                  46.93
;  :minimized-lits          277
;  :mk-bool-var             2259352
;  :mk-clause               1936270
;  :num-allocs              7574023
;  :num-checks              317
;  :propagations            847840
;  :quant-instantiations    995954
;  :restarts                4
;  :rlimit-count            24662107
;  :time                    0.01)
; Definitional axioms for inverse functions
(assert (forall ((i1@263@03 Int)) (!
  (implies
    (and (< i1@263@03 V@12@03) (<= 0 i1@263@03))
    (=
      (inv@264@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@79@03) i1@263@03))
      i1@263@03))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@79@03) i1@263@03))
  :qid |bool-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@264@03 r) V@12@03) (<= 0 (inv@264@03 r)))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@79@03) (inv@264@03 r))
      r))
  :pattern ((inv@264@03 r))
  :qid |bool-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@264@03 r) V@12@03) (<= 0 (inv@264@03 r)))
    ($FVF.loc_bool ($FVF.lookup_bool (as sm@265@03  $FVF<Bool>) r) r))
  :pattern ((inv@264@03 r))
  )))
; Precomputing data for removing quantified permissions
(define-fun pTaken@266@03 ((r $Ref)) $Perm
  (ite
    (and (< (inv@264@03 r) V@12@03) (<= 0 (inv@264@03 r)))
    ($Perm.min
      (-
        (ite
          (and (< (inv@192@03 r) V@12@03) (<= 0 (inv@192@03 r)))
          $Perm.Write
          $Perm.No)
        (pTaken@230@03 r))
      $Perm.Write)
    $Perm.No))
(define-fun pTaken@267@03 ((r $Ref)) $Perm
  (ite
    (and (< (inv@264@03 r) V@12@03) (<= 0 (inv@264@03 r)))
    ($Perm.min
      (ite
        (=
          r
          (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@79@03) v@166@03))
        $Perm.Write
        $Perm.No)
      (- $Perm.Write (pTaken@266@03 r)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 500)
(push) ; 14
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (-
        (ite
          (and (< (inv@192@03 r) V@12@03) (<= 0 (inv@192@03 r)))
          $Perm.Write
          $Perm.No)
        (pTaken@230@03 r))
      (pTaken@266@03 r))
    $Perm.No)
  
  ))))
(check-sat)
; unsat
(pop) ; 14
; 0.09s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1532683
;  :arith-add-rows          403257
;  :arith-assert-diseq      59196
;  :arith-assert-lower      424146
;  :arith-assert-upper      350972
;  :arith-bound-prop        15878
;  :arith-conflicts         917
;  :arith-eq-adapter        204446
;  :arith-fixed-eqs         275499
;  :arith-offset-eqs        91724
;  :arith-pivots            42400
;  :conflicts               2128
;  :datatype-accessor-ax    623
;  :datatype-constructor-ax 1511
;  :datatype-occurs-check   1309
;  :datatype-splits         1167
;  :decisions               125979
;  :del-clause              1941010
;  :final-checks            177
;  :interface-eqs           41
;  :max-generation          15
;  :max-memory              50.39
;  :memory                  46.32
;  :minimized-lits          283
;  :mk-bool-var             2265057
;  :mk-clause               1943253
;  :num-allocs              7586917
;  :num-checks              319
;  :propagations            849626
;  :quant-instantiations    997621
;  :restarts                4
;  :rlimit-count            24750607
;  :time                    0.10)
; Intermediate check if already taken enough permissions
(push) ; 14
(assert (not (forall ((r $Ref)) (!
  (implies
    (and (< (inv@264@03 r) V@12@03) (<= 0 (inv@264@03 r)))
    (= (- $Perm.Write (pTaken@266@03 r)) $Perm.No))
  
  ))))
(check-sat)
; unknown
(pop) ; 14
; 0.50s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1546720
;  :arith-add-rows          412748
;  :arith-assert-diseq      59409
;  :arith-assert-lower      427334
;  :arith-assert-upper      353446
;  :arith-bound-prop        16246
;  :arith-conflicts         924
;  :arith-eq-adapter        206941
;  :arith-fixed-eqs         277596
;  :arith-offset-eqs        92556
;  :arith-pivots            43561
;  :conflicts               2150
;  :datatype-accessor-ax    628
;  :datatype-constructor-ax 1525
;  :datatype-occurs-check   1309
;  :datatype-splits         1167
;  :decisions               127296
;  :del-clause              1975910
;  :final-checks            177
;  :interface-eqs           41
;  :max-generation          15
;  :max-memory              50.39
;  :memory                  46.28
;  :minimized-lits          286
;  :mk-bool-var             2302397
;  :mk-clause               1978153
;  :num-allocs              7698816
;  :num-checks              320
;  :propagations            855704
;  :quant-instantiations    1012341
;  :restarts                4
;  :rlimit-count            25075640
;  :time                    0.50)
; Chunk depleted?
(push) ; 14
(assert (not (=
  (-
    (ite
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@79@03) v@166@03)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@79@03) v@166@03))
      $Perm.Write
      $Perm.No)
    (pTaken@267@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@79@03) v@166@03)))
  $Perm.No)))
(check-sat)
; unsat
(pop) ; 14
; 0.05s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1548779
;  :arith-add-rows          414477
;  :arith-assert-diseq      59456
;  :arith-assert-lower      427709
;  :arith-assert-upper      353670
;  :arith-bound-prop        16304
;  :arith-conflicts         927
;  :arith-eq-adapter        207142
;  :arith-fixed-eqs         277819
;  :arith-offset-eqs        92791
;  :arith-pivots            43615
;  :conflicts               2170
;  :datatype-accessor-ax    630
;  :datatype-constructor-ax 1533
;  :datatype-occurs-check   1309
;  :datatype-splits         1167
;  :decisions               127578
;  :del-clause              1981084
;  :final-checks            177
;  :interface-eqs           41
;  :max-generation          15
;  :max-memory              50.39
;  :memory                  46.25
;  :minimized-lits          289
;  :mk-bool-var             2306561
;  :mk-clause               1983327
;  :num-allocs              7707766
;  :num-checks              321
;  :propagations            857047
;  :quant-instantiations    1013610
;  :restarts                4
;  :rlimit-count            25151429
;  :time                    0.05)
; Intermediate check if already taken enough permissions
(push) ; 14
(assert (not (forall ((r $Ref)) (!
  (implies
    (and (< (inv@264@03 r) V@12@03) (<= 0 (inv@264@03 r)))
    (= (- (- $Perm.Write (pTaken@266@03 r)) (pTaken@267@03 r)) $Perm.No))
  
  ))))
(check-sat)
; unsat
(pop) ; 14
; 0.04s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1551020
;  :arith-add-rows          415543
;  :arith-assert-diseq      59518
;  :arith-assert-lower      428107
;  :arith-assert-upper      353916
;  :arith-bound-prop        16372
;  :arith-conflicts         933
;  :arith-eq-adapter        207389
;  :arith-fixed-eqs         278054
;  :arith-offset-eqs        93064
;  :arith-pivots            43690
;  :conflicts               2194
;  :datatype-accessor-ax    632
;  :datatype-constructor-ax 1541
;  :datatype-occurs-check   1309
;  :datatype-splits         1167
;  :decisions               127866
;  :del-clause              1986363
;  :final-checks            177
;  :interface-eqs           41
;  :max-generation          15
;  :max-memory              50.39
;  :memory                  46.21
;  :minimized-lits          295
;  :mk-bool-var             2310885
;  :mk-clause               1988606
;  :num-allocs              7717390
;  :num-checks              322
;  :propagations            858425
;  :quant-instantiations    1014920
;  :restarts                4
;  :rlimit-count            25207978
;  :time                    0.04)
; Final check if taken enough permissions
; Done removing quantified permissions
; Definitional axioms for snapshot map values
(pop) ; 13
(push) ; 13
; [else-branch: 135 | !(0 < Lookup(int,sm@223@03,aloc((_, _), opt_get1(_, Lookup(option$array$,sm@172@03,aloc((_, _), opt_get1(_, Gf@11@03), u@161@03))), v@166@03)) && !(Lookup(bool,sm@193@03,aloc((_, _), opt_get1(_, res@79@03), v@166@03))))]
(assert (not
  (and
    (<
      0
      ($FVF.lookup_int (as sm@223@03  $FVF<Int>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) u@161@03))) v@166@03)))
    (not
      ($FVF.lookup_bool (as sm@193@03  $FVF<Bool>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit res@79@03) v@166@03))))))
(pop) ; 13
; [eval] !(!aloc(opt_get1(visited), v).bool && 0 < aloc(opt_get1(aloc(opt_get1(Gf), u).option$array$), k).int)
; [eval] !aloc(opt_get1(visited), v).bool && 0 < aloc(opt_get1(aloc(opt_get1(Gf), u).option$array$), k).int
; [eval] !aloc(opt_get1(visited), v).bool
; [eval] aloc(opt_get1(visited), v)
; [eval] opt_get1(visited)
(push) ; 13
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 13
; Joined path conditions
(push) ; 13
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(pop) ; 13
; Joined path conditions
(set-option :timeout 0)
(push) ; 13
(assert (not (and
  (<
    (inv@192@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@79@03) v@166@03))
    V@12@03)
  (<=
    0
    (inv@192@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@79@03) v@166@03))))))
(check-sat)
; unsat
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1551020
;  :arith-add-rows          416472
;  :arith-assert-diseq      59518
;  :arith-assert-lower      428107
;  :arith-assert-upper      353917
;  :arith-bound-prop        16372
;  :arith-conflicts         934
;  :arith-eq-adapter        207389
;  :arith-fixed-eqs         278054
;  :arith-offset-eqs        93064
;  :arith-pivots            43807
;  :conflicts               2195
;  :datatype-accessor-ax    632
;  :datatype-constructor-ax 1541
;  :datatype-occurs-check   1309
;  :datatype-splits         1167
;  :decisions               127866
;  :del-clause              1987085
;  :final-checks            177
;  :interface-eqs           41
;  :max-generation          15
;  :max-memory              50.39
;  :memory                  45.80
;  :minimized-lits          295
;  :mk-bool-var             2310885
;  :mk-clause               1988606
;  :num-allocs              7717566
;  :num-checks              323
;  :propagations            858425
;  :quant-instantiations    1014920
;  :restarts                4
;  :rlimit-count            25231122)
(push) ; 13
; [then-branch: 152 | !(Lookup(bool,sm@193@03,aloc((_, _), opt_get1(_, res@79@03), v@166@03))) | live]
; [else-branch: 152 | Lookup(bool,sm@193@03,aloc((_, _), opt_get1(_, res@79@03), v@166@03)) | live]
(push) ; 14
; [then-branch: 152 | !(Lookup(bool,sm@193@03,aloc((_, _), opt_get1(_, res@79@03), v@166@03)))]
(assert (not
  ($FVF.lookup_bool (as sm@193@03  $FVF<Bool>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit res@79@03) v@166@03))))
; [eval] 0 < aloc(opt_get1(aloc(opt_get1(Gf), u).option$array$), k).int
; [eval] aloc(opt_get1(aloc(opt_get1(Gf), u).option$array$), k)
; [eval] opt_get1(aloc(opt_get1(Gf), u).option$array$)
; [eval] aloc(opt_get1(Gf), u)
; [eval] opt_get1(Gf)
(push) ; 15
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 15
; Joined path conditions
(push) ; 15
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 16
(assert (not (< u@161@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))))
(check-sat)
; unsat
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1551109
;  :arith-add-rows          416504
;  :arith-assert-diseq      59518
;  :arith-assert-lower      428119
;  :arith-assert-upper      353930
;  :arith-bound-prop        16379
;  :arith-conflicts         934
;  :arith-eq-adapter        207401
;  :arith-fixed-eqs         278065
;  :arith-offset-eqs        93064
;  :arith-pivots            43818
;  :conflicts               2195
;  :datatype-accessor-ax    632
;  :datatype-constructor-ax 1541
;  :datatype-occurs-check   1309
;  :datatype-splits         1167
;  :decisions               127866
;  :del-clause              1987085
;  :final-checks            177
;  :interface-eqs           41
;  :max-generation          15
;  :max-memory              50.39
;  :memory                  45.82
;  :minimized-lits          295
;  :mk-bool-var             2311202
;  :mk-clause               1988802
;  :num-allocs              7718939
;  :num-checks              324
;  :propagations            858445
;  :quant-instantiations    1015030
;  :restarts                4
;  :rlimit-count            25236987)
(assert (< u@161@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03))))
(pop) ; 15
; Joined path conditions
(assert (< u@161@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) u@161@03)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) u@161@03)))
(push) ; 15
(assert (not (ite
  (and
    (<
      (inv@171@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) u@161@03))
      V@12@03)
    (<=
      0
      (inv@171@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) u@161@03))))
  (< $Perm.No $k@170@03)
  false)))
(check-sat)
; unsat
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1551109
;  :arith-add-rows          416521
;  :arith-assert-diseq      59518
;  :arith-assert-lower      428119
;  :arith-assert-upper      353931
;  :arith-bound-prop        16379
;  :arith-conflicts         935
;  :arith-eq-adapter        207401
;  :arith-fixed-eqs         278065
;  :arith-offset-eqs        93064
;  :arith-pivots            43819
;  :conflicts               2196
;  :datatype-accessor-ax    632
;  :datatype-constructor-ax 1541
;  :datatype-occurs-check   1309
;  :datatype-splits         1167
;  :decisions               127866
;  :del-clause              1987085
;  :final-checks            177
;  :interface-eqs           41
;  :max-generation          15
;  :max-memory              50.39
;  :memory                  45.79
;  :minimized-lits          295
;  :mk-bool-var             2311202
;  :mk-clause               1988802
;  :num-allocs              7719108
;  :num-checks              325
;  :propagations            858445
;  :quant-instantiations    1015030
;  :restarts                4
;  :rlimit-count            25237771)
(push) ; 15
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 16
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) u@161@03))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1551109
;  :arith-add-rows          416521
;  :arith-assert-diseq      59518
;  :arith-assert-lower      428119
;  :arith-assert-upper      353931
;  :arith-bound-prop        16379
;  :arith-conflicts         935
;  :arith-eq-adapter        207401
;  :arith-fixed-eqs         278065
;  :arith-offset-eqs        93064
;  :arith-pivots            43819
;  :conflicts               2197
;  :datatype-accessor-ax    632
;  :datatype-constructor-ax 1541
;  :datatype-occurs-check   1309
;  :datatype-splits         1167
;  :decisions               127866
;  :del-clause              1987085
;  :final-checks            177
;  :interface-eqs           41
;  :max-generation          15
;  :max-memory              50.39
;  :memory                  45.79
;  :minimized-lits          295
;  :mk-bool-var             2311202
;  :mk-clause               1988802
;  :num-allocs              7719198
;  :num-checks              326
;  :propagations            858445
;  :quant-instantiations    1015030
;  :restarts                4
;  :rlimit-count            25237862)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) u@161@03))
    (as None<option<array>>  option<array>))))
(pop) ; 15
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) u@161@03))
    (as None<option<array>>  option<array>))))
(push) ; 15
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 16
(assert (not (<
  v@166@03
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) u@161@03)))))))
(check-sat)
; unsat
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1551109
;  :arith-add-rows          416521
;  :arith-assert-diseq      59518
;  :arith-assert-lower      428119
;  :arith-assert-upper      353931
;  :arith-bound-prop        16379
;  :arith-conflicts         935
;  :arith-eq-adapter        207401
;  :arith-fixed-eqs         278065
;  :arith-offset-eqs        93064
;  :arith-pivots            43819
;  :conflicts               2198
;  :datatype-accessor-ax    632
;  :datatype-constructor-ax 1541
;  :datatype-occurs-check   1309
;  :datatype-splits         1167
;  :decisions               127866
;  :del-clause              1987085
;  :final-checks            177
;  :interface-eqs           41
;  :max-generation          15
;  :max-memory              50.39
;  :memory                  45.79
;  :minimized-lits          295
;  :mk-bool-var             2311202
;  :mk-clause               1988802
;  :num-allocs              7719346
;  :num-checks              327
;  :propagations            858445
;  :quant-instantiations    1015030
;  :restarts                4
;  :rlimit-count            25238089)
(assert (<
  v@166@03
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) u@161@03))))))
(pop) ; 15
; Joined path conditions
(assert (<
  v@166@03
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) u@161@03))))))
(declare-const sm@268@03 $FVF<Int>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@183@03 r) V@12@03) (<= 0 (inv@183@03 r)))
    (=
      ($FVF.lookup_int (as sm@268@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03)))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@268@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03)))))))))))))))) r))
  :qid |qp.fvfValDef119|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@180@03 r) V@12@03) (<= 0 (inv@180@03 r)))
        (< (inv@179@03 r) V@12@03))
      (<= 0 (inv@179@03 r)))
    (=
      ($FVF.lookup_int (as sm@268@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@268@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03))))))))))))))) r))
  :qid |qp.fvfValDef120|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03)))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03))))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@268@03  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef121|)))
(declare-const pm@269@03 $FPM)
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_int (as pm@269@03  $FPM) r)
    (+
      (ite
        (and (< (inv@183@03 r) V@12@03) (<= 0 (inv@183@03 r)))
        $Perm.Write
        $Perm.No)
      (ite
        (and
          (and
            (and (< (inv@180@03 r) V@12@03) (<= 0 (inv@180@03 r)))
            (< (inv@179@03 r) V@12@03))
          (<= 0 (inv@179@03 r)))
        $Perm.Write
        $Perm.No)))
  :pattern (($FVF.perm_int (as pm@269@03  $FPM) r))
  :qid |qp.resPrmSumDef122|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int (as sm@268@03  $FVF<Int>) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03)))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03))))))))))))))) r) r))
  :pattern (($FVF.perm_int (as pm@269@03  $FPM) r))
  :qid |qp.resTrgDef123|)))
(assert ($FVF.loc_int ($FVF.lookup_int (as sm@268@03  $FVF<Int>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) u@161@03))) v@166@03)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) u@161@03))) v@166@03)))
(push) ; 15
(assert (not (<
  $Perm.No
  ($FVF.perm_int (as pm@269@03  $FPM) (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) u@161@03))) v@166@03)))))
(check-sat)
; unsat
(pop) ; 15
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1552021
;  :arith-add-rows          416682
;  :arith-assert-diseq      59541
;  :arith-assert-lower      428297
;  :arith-assert-upper      354035
;  :arith-bound-prop        16442
;  :arith-conflicts         940
;  :arith-eq-adapter        207519
;  :arith-fixed-eqs         278166
;  :arith-offset-eqs        93223
;  :arith-pivots            43844
;  :conflicts               2212
;  :datatype-accessor-ax    632
;  :datatype-constructor-ax 1545
;  :datatype-occurs-check   1309
;  :datatype-splits         1167
;  :decisions               127915
;  :del-clause              1988157
;  :final-checks            177
;  :interface-eqs           41
;  :max-generation          15
;  :max-memory              50.39
;  :memory                  45.80
;  :minimized-lits          295
;  :mk-bool-var             2312275
;  :mk-clause               1989876
;  :num-allocs              7723750
;  :num-checks              328
;  :propagations            858910
;  :quant-instantiations    1015457
;  :restarts                4
;  :rlimit-count            25259481
;  :time                    0.01)
(pop) ; 14
(push) ; 14
; [else-branch: 152 | Lookup(bool,sm@193@03,aloc((_, _), opt_get1(_, res@79@03), v@166@03))]
(assert ($FVF.lookup_bool (as sm@193@03  $FVF<Bool>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit res@79@03) v@166@03)))
(pop) ; 14
(pop) ; 13
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@183@03 r) V@12@03) (<= 0 (inv@183@03 r)))
    (=
      ($FVF.lookup_int (as sm@268@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03)))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@268@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03)))))))))))))))) r))
  :qid |qp.fvfValDef119|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@180@03 r) V@12@03) (<= 0 (inv@180@03 r)))
        (< (inv@179@03 r) V@12@03))
      (<= 0 (inv@179@03 r)))
    (=
      ($FVF.lookup_int (as sm@268@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@268@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03))))))))))))))) r))
  :qid |qp.fvfValDef120|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03)))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03))))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@268@03  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef121|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_int (as pm@269@03  $FPM) r)
    (+
      (ite
        (and (< (inv@183@03 r) V@12@03) (<= 0 (inv@183@03 r)))
        $Perm.Write
        $Perm.No)
      (ite
        (and
          (and
            (and (< (inv@180@03 r) V@12@03) (<= 0 (inv@180@03 r)))
            (< (inv@179@03 r) V@12@03))
          (<= 0 (inv@179@03 r)))
        $Perm.Write
        $Perm.No)))
  :pattern (($FVF.perm_int (as pm@269@03  $FPM) r))
  :qid |qp.resPrmSumDef122|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int (as sm@268@03  $FVF<Int>) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03)))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03))))))))))))))) r) r))
  :pattern (($FVF.perm_int (as pm@269@03  $FPM) r))
  :qid |qp.resTrgDef123|)))
(assert (implies
  (not
    ($FVF.lookup_bool (as sm@193@03  $FVF<Bool>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@79@03) v@166@03)))
  (and
    (not
      ($FVF.lookup_bool (as sm@193@03  $FVF<Bool>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit res@79@03) v@166@03)))
    (< u@161@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) u@161@03)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) u@161@03))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) u@161@03))
        (as None<option<array>>  option<array>)))
    (<
      v@166@03
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) u@161@03)))))
    ($FVF.loc_int ($FVF.lookup_int (as sm@268@03  $FVF<Int>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) u@161@03))) v@166@03)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) u@161@03))) v@166@03)))))
; Joined path conditions
(set-option :timeout 10)
(push) ; 13
(assert (not (and
  (<
    0
    ($FVF.lookup_int (as sm@268@03  $FVF<Int>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) u@161@03))) v@166@03)))
  (not
    ($FVF.lookup_bool (as sm@193@03  $FVF<Bool>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@79@03) v@166@03))))))
(check-sat)
; unknown
(pop) ; 13
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1552775
;  :arith-add-rows          416805
;  :arith-assert-diseq      59558
;  :arith-assert-lower      428437
;  :arith-assert-upper      354115
;  :arith-bound-prop        16491
;  :arith-conflicts         941
;  :arith-eq-adapter        207622
;  :arith-fixed-eqs         278261
;  :arith-offset-eqs        93335
;  :arith-pivots            43866
;  :conflicts               2213
;  :datatype-accessor-ax    632
;  :datatype-constructor-ax 1549
;  :datatype-occurs-check   1309
;  :datatype-splits         1167
;  :decisions               127951
;  :del-clause              1989387
;  :final-checks            177
;  :interface-eqs           41
;  :max-generation          15
;  :max-memory              50.39
;  :memory                  45.78
;  :minimized-lits          295
;  :mk-bool-var             2313328
;  :mk-clause               1990915
;  :num-allocs              7727964
;  :num-checks              329
;  :propagations            859277
;  :quant-instantiations    1015891
;  :restarts                4
;  :rlimit-count            25280577
;  :time                    0.01)
(push) ; 13
(assert (not (not
  (and
    (<
      0
      ($FVF.lookup_int (as sm@268@03  $FVF<Int>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) u@161@03))) v@166@03)))
    (not
      ($FVF.lookup_bool (as sm@193@03  $FVF<Bool>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit res@79@03) v@166@03)))))))
(check-sat)
; unknown
(pop) ; 13
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1553531
;  :arith-add-rows          416904
;  :arith-assert-diseq      59575
;  :arith-assert-lower      428578
;  :arith-assert-upper      354196
;  :arith-bound-prop        16549
;  :arith-conflicts         942
;  :arith-eq-adapter        207725
;  :arith-fixed-eqs         278354
;  :arith-offset-eqs        93446
;  :arith-pivots            43894
;  :conflicts               2214
;  :datatype-accessor-ax    632
;  :datatype-constructor-ax 1553
;  :datatype-occurs-check   1309
;  :datatype-splits         1167
;  :decisions               127976
;  :del-clause              1990210
;  :final-checks            177
;  :interface-eqs           41
;  :max-generation          15
;  :max-memory              50.39
;  :memory                  45.78
;  :minimized-lits          295
;  :mk-bool-var             2314344
;  :mk-clause               1991738
;  :num-allocs              7731577
;  :num-checks              330
;  :propagations            859628
;  :quant-instantiations    1016331
;  :restarts                4
;  :rlimit-count            25298965
;  :time                    0.01)
; [then-branch: 153 | !(0 < Lookup(int,sm@268@03,aloc((_, _), opt_get1(_, Lookup(option$array$,sm@172@03,aloc((_, _), opt_get1(_, Gf@11@03), u@161@03))), v@166@03)) && !(Lookup(bool,sm@193@03,aloc((_, _), opt_get1(_, res@79@03), v@166@03)))) | live]
; [else-branch: 153 | 0 < Lookup(int,sm@268@03,aloc((_, _), opt_get1(_, Lookup(option$array$,sm@172@03,aloc((_, _), opt_get1(_, Gf@11@03), u@161@03))), v@166@03)) && !(Lookup(bool,sm@193@03,aloc((_, _), opt_get1(_, res@79@03), v@166@03))) | live]
(push) ; 13
; [then-branch: 153 | !(0 < Lookup(int,sm@268@03,aloc((_, _), opt_get1(_, Lookup(option$array$,sm@172@03,aloc((_, _), opt_get1(_, Gf@11@03), u@161@03))), v@166@03)) && !(Lookup(bool,sm@193@03,aloc((_, _), opt_get1(_, res@79@03), v@166@03))))]
(assert (not
  (and
    (<
      0
      ($FVF.lookup_int (as sm@268@03  $FVF<Int>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) u@161@03))) v@166@03)))
    (not
      ($FVF.lookup_bool (as sm@193@03  $FVF<Bool>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit res@79@03) v@166@03))))))
; [exec]
; flatten := v
; [exec]
; v := v + 1
; [eval] v + 1
(declare-const v@270@03 Int)
(assert (= v@270@03 (+ v@166@03 1)))
; [exec]
; evaluationDummy2 := flatten
; Loop head block: Re-establish invariant
; [eval] exc == excBeforeLoop1
; [eval] Gf != (None(): option[array])
; [eval] (None(): option[array])
; [eval] alen(opt_get1(Gf)) == V
; [eval] alen(opt_get1(Gf))
; [eval] opt_get1(Gf)
(push) ; 14
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 14
; Joined path conditions
(declare-const i1@271@03 Int)
(push) ; 14
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 15
; [then-branch: 154 | 0 <= i1@271@03 | live]
; [else-branch: 154 | !(0 <= i1@271@03) | live]
(push) ; 16
; [then-branch: 154 | 0 <= i1@271@03]
(assert (<= 0 i1@271@03))
; [eval] i1 < V
(pop) ; 16
(push) ; 16
; [else-branch: 154 | !(0 <= i1@271@03)]
(assert (not (<= 0 i1@271@03)))
(pop) ; 16
(pop) ; 15
; Joined path conditions
; Joined path conditions
(assert (and (< i1@271@03 V@12@03) (<= 0 i1@271@03)))
(declare-const $k@272@03 $Perm)
(assert ($Perm.isReadVar $k@272@03 $Perm.Write))
; [eval] aloc(opt_get1(Gf), i1)
; [eval] opt_get1(Gf)
(push) ; 15
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 15
; Joined path conditions
(push) ; 15
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 16
(assert (not (< i1@271@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))))
(check-sat)
; unsat
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1553532
;  :arith-add-rows          416906
;  :arith-assert-diseq      59576
;  :arith-assert-lower      428583
;  :arith-assert-upper      354198
;  :arith-bound-prop        16549
;  :arith-conflicts         942
;  :arith-eq-adapter        207727
;  :arith-fixed-eqs         278354
;  :arith-offset-eqs        93446
;  :arith-pivots            43895
;  :conflicts               2214
;  :datatype-accessor-ax    632
;  :datatype-constructor-ax 1553
;  :datatype-occurs-check   1309
;  :datatype-splits         1167
;  :decisions               127976
;  :del-clause              1990210
;  :final-checks            177
;  :interface-eqs           41
;  :max-generation          15
;  :max-memory              50.39
;  :memory                  45.78
;  :minimized-lits          295
;  :mk-bool-var             2314354
;  :mk-clause               1991744
;  :num-allocs              7731866
;  :num-checks              331
;  :propagations            859631
;  :quant-instantiations    1016331
;  :restarts                4
;  :rlimit-count            25299558)
(assert (< i1@271@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03))))
(pop) ; 15
; Joined path conditions
(assert (< i1@271@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03))))
(pop) ; 14
(declare-fun inv@273@03 ($Ref) Int)
; Nested auxiliary terms: globals
(assert ($Perm.isReadVar $k@272@03 $Perm.Write))
; Nested auxiliary terms: non-globals
(assert (forall ((i1@271@03 Int)) (!
  (< i1@271@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@271@03))
  :qid |option$array$-aux|)))
(push) ; 14
(assert (not (forall ((i1@271@03 Int)) (!
  (implies
    (and (< i1@271@03 V@12@03) (<= 0 i1@271@03))
    (or (= $k@272@03 $Perm.No) (< $Perm.No $k@272@03)))
  
  ))))
(check-sat)
; unsat
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1553532
;  :arith-add-rows          416907
;  :arith-assert-diseq      59577
;  :arith-assert-lower      428585
;  :arith-assert-upper      354199
;  :arith-bound-prop        16549
;  :arith-conflicts         942
;  :arith-eq-adapter        207728
;  :arith-fixed-eqs         278354
;  :arith-offset-eqs        93446
;  :arith-pivots            43895
;  :conflicts               2215
;  :datatype-accessor-ax    632
;  :datatype-constructor-ax 1553
;  :datatype-occurs-check   1309
;  :datatype-splits         1167
;  :decisions               127976
;  :del-clause              1990212
;  :final-checks            177
;  :interface-eqs           41
;  :max-generation          15
;  :max-memory              50.39
;  :memory                  45.78
;  :minimized-lits          295
;  :mk-bool-var             2314361
;  :mk-clause               1991746
;  :num-allocs              7732297
;  :num-checks              332
;  :propagations            859632
;  :quant-instantiations    1016331
;  :restarts                4
;  :rlimit-count            25300105)
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 14
(assert (not (forall ((i11@271@03 Int) (i12@271@03 Int)) (!
  (implies
    (and
      (and
        (and
          (and (< i11@271@03 V@12@03) (<= 0 i11@271@03))
          ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i11@271@03)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i11@271@03)))
        (< $Perm.No $k@272@03))
      (and
        (and
          (and (< i12@271@03 V@12@03) (<= 0 i12@271@03))
          ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i12@271@03)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i12@271@03)))
        (< $Perm.No $k@272@03))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i11@271@03)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i12@271@03)))
    (= i11@271@03 i12@271@03))
  
  :qid |option$array$-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1553550
;  :arith-add-rows          416912
;  :arith-assert-diseq      59578
;  :arith-assert-lower      428589
;  :arith-assert-upper      354199
;  :arith-bound-prop        16549
;  :arith-conflicts         942
;  :arith-eq-adapter        207729
;  :arith-fixed-eqs         278354
;  :arith-offset-eqs        93446
;  :arith-pivots            43895
;  :conflicts               2216
;  :datatype-accessor-ax    632
;  :datatype-constructor-ax 1553
;  :datatype-occurs-check   1309
;  :datatype-splits         1167
;  :decisions               127976
;  :del-clause              1990219
;  :final-checks            177
;  :interface-eqs           41
;  :max-generation          15
;  :max-memory              50.39
;  :memory                  45.78
;  :minimized-lits          295
;  :mk-bool-var             2314393
;  :mk-clause               1991753
;  :num-allocs              7732742
;  :num-checks              333
;  :propagations            859632
;  :quant-instantiations    1016360
;  :restarts                4
;  :rlimit-count            25301244
;  :time                    0.00)
; Definitional axioms for inverse functions
(assert (forall ((i1@271@03 Int)) (!
  (implies
    (and (and (< i1@271@03 V@12@03) (<= 0 i1@271@03)) (< $Perm.No $k@272@03))
    (=
      (inv@273@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@271@03))
      i1@271@03))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@271@03))
  :qid |option$array$-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and (< (inv@273@03 r) V@12@03) (<= 0 (inv@273@03 r)))
      (< $Perm.No $k@272@03))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) (inv@273@03 r))
      r))
  :pattern ((inv@273@03 r))
  :qid |option$array$-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@273@03 r) V@12@03) (<= 0 (inv@273@03 r)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) r) r))
  :pattern ((inv@273@03 r))
  )))
; Precomputing data for removing quantified permissions
(define-fun pTaken@274@03 ((r $Ref)) $Perm
  (ite
    (and (< (inv@273@03 r) V@12@03) (<= 0 (inv@273@03 r)))
    ($Perm.min
      (ite
        (and (< (inv@171@03 r) V@12@03) (<= 0 (inv@171@03 r)))
        $k@170@03
        $Perm.No)
      $k@272@03)
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Constrain original permissions $k@272@03
(assert (forall ((r $Ref)) (!
  (implies
    (not
      (=
        (ite
          (and (< (inv@171@03 r) V@12@03) (<= 0 (inv@171@03 r)))
          $k@170@03
          $Perm.No)
        $Perm.No))
    (ite
      (and (< (inv@171@03 r) V@12@03) (<= 0 (inv@171@03 r)))
      (<
        (ite
          (and (< (inv@273@03 r) V@12@03) (<= 0 (inv@273@03 r)))
          $k@272@03
          $Perm.No)
        $k@170@03)
      (<
        (ite
          (and (< (inv@273@03 r) V@12@03) (<= 0 (inv@273@03 r)))
          $k@272@03
          $Perm.No)
        $Perm.No)))
  :pattern ((inv@171@03 r))
  :pattern ((inv@273@03 r))
  :qid |qp.srp124|)))
; Intermediate check if already taken enough permissions
(set-option :timeout 500)
(push) ; 14
(assert (not (forall ((r $Ref)) (!
  (implies
    (and (< (inv@273@03 r) V@12@03) (<= 0 (inv@273@03 r)))
    (= (- $k@272@03 (pTaken@274@03 r)) $Perm.No))
  
  ))))
(check-sat)
; unsat
(pop) ; 14
; 0.02s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1555068
;  :arith-add-rows          417163
;  :arith-assert-diseq      59625
;  :arith-assert-lower      428883
;  :arith-assert-upper      354363
;  :arith-bound-prop        16614
;  :arith-conflicts         947
;  :arith-eq-adapter        207960
;  :arith-fixed-eqs         278542
;  :arith-offset-eqs        93688
;  :arith-pivots            43940
;  :conflicts               2239
;  :datatype-accessor-ax    632
;  :datatype-constructor-ax 1561
;  :datatype-occurs-check   1309
;  :datatype-splits         1167
;  :decisions               128044
;  :del-clause              1992012
;  :final-checks            177
;  :interface-eqs           41
;  :max-generation          15
;  :max-memory              50.39
;  :memory                  45.79
;  :minimized-lits          297
;  :mk-bool-var             2316472
;  :mk-clause               1993614
;  :num-allocs              7740553
;  :num-checks              335
;  :propagations            860458
;  :quant-instantiations    1017177
;  :restarts                4
;  :rlimit-count            25337329
;  :time                    0.02)
; Final check if taken enough permissions
; Done removing quantified permissions
; Definitional axioms for snapshot map values
; [eval] (forall i1: Int :: { aloc(opt_get1(Gf), i1) } 0 <= i1 && i1 < V ==> aloc(opt_get1(Gf), i1).option$array$ != (None(): option[array]))
(declare-const i1@275@03 Int)
(push) ; 14
; [eval] 0 <= i1 && i1 < V ==> aloc(opt_get1(Gf), i1).option$array$ != (None(): option[array])
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 15
; [then-branch: 155 | 0 <= i1@275@03 | live]
; [else-branch: 155 | !(0 <= i1@275@03) | live]
(push) ; 16
; [then-branch: 155 | 0 <= i1@275@03]
(assert (<= 0 i1@275@03))
; [eval] i1 < V
(pop) ; 16
(push) ; 16
; [else-branch: 155 | !(0 <= i1@275@03)]
(assert (not (<= 0 i1@275@03)))
(pop) ; 16
(pop) ; 15
; Joined path conditions
; Joined path conditions
(push) ; 15
; [then-branch: 156 | i1@275@03 < V@12@03 && 0 <= i1@275@03 | live]
; [else-branch: 156 | !(i1@275@03 < V@12@03 && 0 <= i1@275@03) | live]
(push) ; 16
; [then-branch: 156 | i1@275@03 < V@12@03 && 0 <= i1@275@03]
(assert (and (< i1@275@03 V@12@03) (<= 0 i1@275@03)))
; [eval] aloc(opt_get1(Gf), i1).option$array$ != (None(): option[array])
; [eval] aloc(opt_get1(Gf), i1)
; [eval] opt_get1(Gf)
(push) ; 17
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 17
; Joined path conditions
(push) ; 17
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 18
(assert (not (< i1@275@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))))
(check-sat)
; unsat
(pop) ; 18
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1555068
;  :arith-add-rows          417164
;  :arith-assert-diseq      59625
;  :arith-assert-lower      428885
;  :arith-assert-upper      354363
;  :arith-bound-prop        16614
;  :arith-conflicts         947
;  :arith-eq-adapter        207960
;  :arith-fixed-eqs         278542
;  :arith-offset-eqs        93688
;  :arith-pivots            43940
;  :conflicts               2239
;  :datatype-accessor-ax    632
;  :datatype-constructor-ax 1561
;  :datatype-occurs-check   1309
;  :datatype-splits         1167
;  :decisions               128044
;  :del-clause              1992012
;  :final-checks            177
;  :interface-eqs           41
;  :max-generation          15
;  :max-memory              50.39
;  :memory                  45.79
;  :minimized-lits          297
;  :mk-bool-var             2316474
;  :mk-clause               1993614
;  :num-allocs              7740663
;  :num-checks              336
;  :propagations            860458
;  :quant-instantiations    1017177
;  :restarts                4
;  :rlimit-count            25337520)
(assert (< i1@275@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03))))
(pop) ; 17
; Joined path conditions
(assert (< i1@275@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@275@03)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@275@03)))
(push) ; 17
(assert (not (ite
  (and
    (<
      (inv@171@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@275@03))
      V@12@03)
    (<=
      0
      (inv@171@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@275@03))))
  (< $Perm.No $k@170@03)
  false)))
(check-sat)
; unsat
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1555106
;  :arith-add-rows          417195
;  :arith-assert-diseq      59625
;  :arith-assert-lower      428892
;  :arith-assert-upper      354371
;  :arith-bound-prop        16621
;  :arith-conflicts         948
;  :arith-eq-adapter        207967
;  :arith-fixed-eqs         278549
;  :arith-offset-eqs        93688
;  :arith-pivots            43948
;  :conflicts               2240
;  :datatype-accessor-ax    632
;  :datatype-constructor-ax 1561
;  :datatype-occurs-check   1309
;  :datatype-splits         1167
;  :decisions               128044
;  :del-clause              1992012
;  :final-checks            177
;  :interface-eqs           41
;  :max-generation          15
;  :max-memory              50.39
;  :memory                  45.80
;  :minimized-lits          297
;  :mk-bool-var             2316631
;  :mk-clause               1993706
;  :num-allocs              7741675
;  :num-checks              337
;  :propagations            860460
;  :quant-instantiations    1017241
;  :restarts                4
;  :rlimit-count            25341501)
; [eval] (None(): option[array])
(pop) ; 16
(push) ; 16
; [else-branch: 156 | !(i1@275@03 < V@12@03 && 0 <= i1@275@03)]
(assert (not (and (< i1@275@03 V@12@03) (<= 0 i1@275@03))))
(pop) ; 16
(pop) ; 15
; Joined path conditions
(assert (implies
  (and (< i1@275@03 V@12@03) (<= 0 i1@275@03))
  (and
    (< i1@275@03 V@12@03)
    (<= 0 i1@275@03)
    (< i1@275@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@275@03)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@275@03)))))
; Joined path conditions
(pop) ; 14
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@275@03 Int)) (!
  (implies
    (and (< i1@275@03 V@12@03) (<= 0 i1@275@03))
    (and
      (< i1@275@03 V@12@03)
      (<= 0 i1@275@03)
      (< i1@275@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@275@03)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@275@03))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@275@03))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(push) ; 14
(assert (not (forall ((i1@275@03 Int)) (!
  (implies
    (and (< i1@275@03 V@12@03) (<= 0 i1@275@03))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@275@03))
        (as None<option<array>>  option<array>))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@275@03))
  :qid |prog.l<no position>|))))
(check-sat)
; unsat
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1555115
;  :arith-add-rows          417214
;  :arith-assert-diseq      59625
;  :arith-assert-lower      428895
;  :arith-assert-upper      354372
;  :arith-bound-prop        16622
;  :arith-conflicts         948
;  :arith-eq-adapter        207968
;  :arith-fixed-eqs         278550
;  :arith-offset-eqs        93688
;  :arith-pivots            43958
;  :conflicts               2241
;  :datatype-accessor-ax    632
;  :datatype-constructor-ax 1561
;  :datatype-occurs-check   1309
;  :datatype-splits         1167
;  :decisions               128044
;  :del-clause              1992172
;  :final-checks            177
;  :interface-eqs           41
;  :max-generation          15
;  :max-memory              50.39
;  :memory                  45.79
;  :minimized-lits          297
;  :mk-bool-var             2316716
;  :mk-clause               1993774
;  :num-allocs              7742693
;  :num-checks              338
;  :propagations            860462
;  :quant-instantiations    1017291
;  :restarts                4
;  :rlimit-count            25344864
;  :time                    0.00)
(assert (forall ((i1@275@03 Int)) (!
  (implies
    (and (< i1@275@03 V@12@03) (<= 0 i1@275@03))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@275@03))
        (as None<option<array>>  option<array>))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@275@03))
  :qid |prog.l<no position>|)))
; [eval] (forall i1: Int :: { alen(opt_get1(aloc(opt_get1(Gf), i1).option$array$)) } 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(Gf), i1).option$array$)) == V)
(declare-const i1@276@03 Int)
(push) ; 14
; [eval] 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(Gf), i1).option$array$)) == V
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 15
; [then-branch: 157 | 0 <= i1@276@03 | live]
; [else-branch: 157 | !(0 <= i1@276@03) | live]
(push) ; 16
; [then-branch: 157 | 0 <= i1@276@03]
(assert (<= 0 i1@276@03))
; [eval] i1 < V
(pop) ; 16
(push) ; 16
; [else-branch: 157 | !(0 <= i1@276@03)]
(assert (not (<= 0 i1@276@03)))
(pop) ; 16
(pop) ; 15
; Joined path conditions
; Joined path conditions
(push) ; 15
; [then-branch: 158 | i1@276@03 < V@12@03 && 0 <= i1@276@03 | live]
; [else-branch: 158 | !(i1@276@03 < V@12@03 && 0 <= i1@276@03) | live]
(push) ; 16
; [then-branch: 158 | i1@276@03 < V@12@03 && 0 <= i1@276@03]
(assert (and (< i1@276@03 V@12@03) (<= 0 i1@276@03)))
; [eval] alen(opt_get1(aloc(opt_get1(Gf), i1).option$array$)) == V
; [eval] alen(opt_get1(aloc(opt_get1(Gf), i1).option$array$))
; [eval] opt_get1(aloc(opt_get1(Gf), i1).option$array$)
; [eval] aloc(opt_get1(Gf), i1)
; [eval] opt_get1(Gf)
(push) ; 17
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 17
; Joined path conditions
(push) ; 17
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 18
(assert (not (< i1@276@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))))
(check-sat)
; unsat
(pop) ; 18
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1555115
;  :arith-add-rows          417215
;  :arith-assert-diseq      59625
;  :arith-assert-lower      428897
;  :arith-assert-upper      354372
;  :arith-bound-prop        16622
;  :arith-conflicts         948
;  :arith-eq-adapter        207968
;  :arith-fixed-eqs         278550
;  :arith-offset-eqs        93688
;  :arith-pivots            43958
;  :conflicts               2241
;  :datatype-accessor-ax    632
;  :datatype-constructor-ax 1561
;  :datatype-occurs-check   1309
;  :datatype-splits         1167
;  :decisions               128044
;  :del-clause              1992172
;  :final-checks            177
;  :interface-eqs           41
;  :max-generation          15
;  :max-memory              50.39
;  :memory                  45.79
;  :minimized-lits          297
;  :mk-bool-var             2316719
;  :mk-clause               1993774
;  :num-allocs              7742996
;  :num-checks              339
;  :propagations            860462
;  :quant-instantiations    1017291
;  :restarts                4
;  :rlimit-count            25345364)
(assert (< i1@276@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03))))
(pop) ; 17
; Joined path conditions
(assert (< i1@276@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@276@03)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@276@03)))
(push) ; 17
(assert (not (ite
  (and
    (<
      (inv@171@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@276@03))
      V@12@03)
    (<=
      0
      (inv@171@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@276@03))))
  (< $Perm.No $k@170@03)
  false)))
(check-sat)
; unsat
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1555153
;  :arith-add-rows          417246
;  :arith-assert-diseq      59625
;  :arith-assert-lower      428904
;  :arith-assert-upper      354380
;  :arith-bound-prop        16629
;  :arith-conflicts         949
;  :arith-eq-adapter        207975
;  :arith-fixed-eqs         278557
;  :arith-offset-eqs        93688
;  :arith-pivots            43966
;  :conflicts               2242
;  :datatype-accessor-ax    632
;  :datatype-constructor-ax 1561
;  :datatype-occurs-check   1309
;  :datatype-splits         1167
;  :decisions               128044
;  :del-clause              1992172
;  :final-checks            177
;  :interface-eqs           41
;  :max-generation          15
;  :max-memory              50.39
;  :memory                  45.79
;  :minimized-lits          297
;  :mk-bool-var             2316876
;  :mk-clause               1993866
;  :num-allocs              7744020
;  :num-checks              340
;  :propagations            860464
;  :quant-instantiations    1017356
;  :restarts                4
;  :rlimit-count            25349555)
(push) ; 17
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 18
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@276@03))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 18
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1555153
;  :arith-add-rows          417246
;  :arith-assert-diseq      59625
;  :arith-assert-lower      428904
;  :arith-assert-upper      354380
;  :arith-bound-prop        16629
;  :arith-conflicts         949
;  :arith-eq-adapter        207975
;  :arith-fixed-eqs         278557
;  :arith-offset-eqs        93688
;  :arith-pivots            43966
;  :conflicts               2243
;  :datatype-accessor-ax    632
;  :datatype-constructor-ax 1561
;  :datatype-occurs-check   1309
;  :datatype-splits         1167
;  :decisions               128044
;  :del-clause              1992172
;  :final-checks            177
;  :interface-eqs           41
;  :max-generation          15
;  :max-memory              50.39
;  :memory                  45.79
;  :minimized-lits          297
;  :mk-bool-var             2316876
;  :mk-clause               1993866
;  :num-allocs              7744109
;  :num-checks              341
;  :propagations            860464
;  :quant-instantiations    1017356
;  :restarts                4
;  :rlimit-count            25349650)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@276@03))
    (as None<option<array>>  option<array>))))
(pop) ; 17
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@276@03))
    (as None<option<array>>  option<array>))))
(pop) ; 16
(push) ; 16
; [else-branch: 158 | !(i1@276@03 < V@12@03 && 0 <= i1@276@03)]
(assert (not (and (< i1@276@03 V@12@03) (<= 0 i1@276@03))))
(pop) ; 16
(pop) ; 15
; Joined path conditions
(assert (implies
  (and (< i1@276@03 V@12@03) (<= 0 i1@276@03))
  (and
    (< i1@276@03 V@12@03)
    (<= 0 i1@276@03)
    (< i1@276@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@276@03)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@276@03))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@276@03))
        (as None<option<array>>  option<array>))))))
; Joined path conditions
(pop) ; 14
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@276@03 Int)) (!
  (implies
    (and (< i1@276@03 V@12@03) (<= 0 i1@276@03))
    (and
      (< i1@276@03 V@12@03)
      (<= 0 i1@276@03)
      (< i1@276@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@276@03)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@276@03))
      (not
        (=
          ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@276@03))
          (as None<option<array>>  option<array>)))))
  :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@276@03)))))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(push) ; 14
(assert (not (forall ((i1@276@03 Int)) (!
  (implies
    (and (< i1@276@03 V@12@03) (<= 0 i1@276@03))
    (=
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@276@03))))
      V@12@03))
  :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@276@03)))))
  :qid |prog.l<no position>|))))
(check-sat)
; unsat
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1555153
;  :arith-add-rows          417257
;  :arith-assert-diseq      59625
;  :arith-assert-lower      428906
;  :arith-assert-upper      354380
;  :arith-bound-prop        16629
;  :arith-conflicts         949
;  :arith-eq-adapter        207976
;  :arith-fixed-eqs         278557
;  :arith-offset-eqs        93688
;  :arith-pivots            43974
;  :conflicts               2244
;  :datatype-accessor-ax    632
;  :datatype-constructor-ax 1561
;  :datatype-occurs-check   1309
;  :datatype-splits         1167
;  :decisions               128044
;  :del-clause              1992274
;  :final-checks            177
;  :interface-eqs           41
;  :max-generation          15
;  :max-memory              50.39
;  :memory                  45.78
;  :minimized-lits          297
;  :mk-bool-var             2316903
;  :mk-clause               1993876
;  :num-allocs              7744653
;  :num-checks              342
;  :propagations            860464
;  :quant-instantiations    1017379
;  :restarts                4
;  :rlimit-count            25351203)
(assert (forall ((i1@276@03 Int)) (!
  (implies
    (and (< i1@276@03 V@12@03) (<= 0 i1@276@03))
    (=
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@276@03))))
      V@12@03))
  :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@276@03)))))
  :qid |prog.l<no position>|)))
; [eval] (forall i1: Int :: { aloc(opt_get1(Gf), i1) } (forall i2: Int :: { aloc(opt_get1(Gf), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(Gf), i1).option$array$ == aloc(opt_get1(Gf), i2).option$array$ ==> i1 == i2))
(declare-const i1@277@03 Int)
(push) ; 14
; [eval] (forall i2: Int :: { aloc(opt_get1(Gf), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(Gf), i1).option$array$ == aloc(opt_get1(Gf), i2).option$array$ ==> i1 == i2)
(declare-const i2@278@03 Int)
(push) ; 15
; [eval] 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(Gf), i1).option$array$ == aloc(opt_get1(Gf), i2).option$array$ ==> i1 == i2
; [eval] 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(Gf), i1).option$array$ == aloc(opt_get1(Gf), i2).option$array$
; [eval] 0 <= i1
(push) ; 16
; [then-branch: 159 | 0 <= i1@277@03 | live]
; [else-branch: 159 | !(0 <= i1@277@03) | live]
(push) ; 17
; [then-branch: 159 | 0 <= i1@277@03]
(assert (<= 0 i1@277@03))
; [eval] i1 < V
(push) ; 18
; [then-branch: 160 | i1@277@03 < V@12@03 | live]
; [else-branch: 160 | !(i1@277@03 < V@12@03) | live]
(push) ; 19
; [then-branch: 160 | i1@277@03 < V@12@03]
(assert (< i1@277@03 V@12@03))
; [eval] 0 <= i2
(push) ; 20
; [then-branch: 161 | 0 <= i2@278@03 | live]
; [else-branch: 161 | !(0 <= i2@278@03) | live]
(push) ; 21
; [then-branch: 161 | 0 <= i2@278@03]
(assert (<= 0 i2@278@03))
; [eval] i2 < V
(push) ; 22
; [then-branch: 162 | i2@278@03 < V@12@03 | live]
; [else-branch: 162 | !(i2@278@03 < V@12@03) | live]
(push) ; 23
; [then-branch: 162 | i2@278@03 < V@12@03]
(assert (< i2@278@03 V@12@03))
; [eval] aloc(opt_get1(Gf), i1).option$array$ == aloc(opt_get1(Gf), i2).option$array$
; [eval] aloc(opt_get1(Gf), i1)
; [eval] opt_get1(Gf)
(push) ; 24
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 24
; Joined path conditions
(push) ; 24
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 25
(assert (not (< i1@277@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))))
(check-sat)
; unsat
(pop) ; 25
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1555153
;  :arith-add-rows          417259
;  :arith-assert-diseq      59625
;  :arith-assert-lower      428910
;  :arith-assert-upper      354380
;  :arith-bound-prop        16629
;  :arith-conflicts         949
;  :arith-eq-adapter        207976
;  :arith-fixed-eqs         278557
;  :arith-offset-eqs        93688
;  :arith-pivots            43974
;  :conflicts               2244
;  :datatype-accessor-ax    632
;  :datatype-constructor-ax 1561
;  :datatype-occurs-check   1309
;  :datatype-splits         1167
;  :decisions               128044
;  :del-clause              1992274
;  :final-checks            177
;  :interface-eqs           41
;  :max-generation          15
;  :max-memory              50.39
;  :memory                  45.78
;  :minimized-lits          297
;  :mk-bool-var             2316908
;  :mk-clause               1993876
;  :num-allocs              7745136
;  :num-checks              343
;  :propagations            860464
;  :quant-instantiations    1017379
;  :restarts                4
;  :rlimit-count            25351848)
(assert (< i1@277@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03))))
(pop) ; 24
; Joined path conditions
(assert (< i1@277@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@277@03)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@277@03)))
(push) ; 24
(assert (not (ite
  (and
    (<
      (inv@171@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@277@03))
      V@12@03)
    (<=
      0
      (inv@171@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@277@03))))
  (< $Perm.No $k@170@03)
  false)))
(check-sat)
; unsat
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1555191
;  :arith-add-rows          417290
;  :arith-assert-diseq      59625
;  :arith-assert-lower      428917
;  :arith-assert-upper      354388
;  :arith-bound-prop        16636
;  :arith-conflicts         950
;  :arith-eq-adapter        207983
;  :arith-fixed-eqs         278564
;  :arith-offset-eqs        93688
;  :arith-pivots            43982
;  :conflicts               2245
;  :datatype-accessor-ax    632
;  :datatype-constructor-ax 1561
;  :datatype-occurs-check   1309
;  :datatype-splits         1167
;  :decisions               128044
;  :del-clause              1992274
;  :final-checks            177
;  :interface-eqs           41
;  :max-generation          15
;  :max-memory              50.39
;  :memory                  45.78
;  :minimized-lits          297
;  :mk-bool-var             2317065
;  :mk-clause               1993968
;  :num-allocs              7746161
;  :num-checks              344
;  :propagations            860466
;  :quant-instantiations    1017444
;  :restarts                4
;  :rlimit-count            25356045)
; [eval] aloc(opt_get1(Gf), i2)
; [eval] opt_get1(Gf)
(push) ; 24
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 24
; Joined path conditions
(push) ; 24
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 25
(assert (not (< i2@278@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))))
(check-sat)
; unsat
(pop) ; 25
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1555191
;  :arith-add-rows          417290
;  :arith-assert-diseq      59625
;  :arith-assert-lower      428917
;  :arith-assert-upper      354388
;  :arith-bound-prop        16636
;  :arith-conflicts         950
;  :arith-eq-adapter        207983
;  :arith-fixed-eqs         278564
;  :arith-offset-eqs        93688
;  :arith-pivots            43982
;  :conflicts               2245
;  :datatype-accessor-ax    632
;  :datatype-constructor-ax 1561
;  :datatype-occurs-check   1309
;  :datatype-splits         1167
;  :decisions               128044
;  :del-clause              1992274
;  :final-checks            177
;  :interface-eqs           41
;  :max-generation          15
;  :max-memory              50.39
;  :memory                  45.78
;  :minimized-lits          297
;  :mk-bool-var             2317065
;  :mk-clause               1993968
;  :num-allocs              7746187
;  :num-checks              345
;  :propagations            860466
;  :quant-instantiations    1017444
;  :restarts                4
;  :rlimit-count            25356075)
(assert (< i2@278@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03))))
(pop) ; 24
; Joined path conditions
(assert (< i2@278@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@278@03)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@278@03)))
(push) ; 24
(assert (not (ite
  (and
    (<
      (inv@171@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@278@03))
      V@12@03)
    (<=
      0
      (inv@171@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@278@03))))
  (< $Perm.No $k@170@03)
  false)))
(check-sat)
; unsat
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1555227
;  :arith-add-rows          417323
;  :arith-assert-diseq      59625
;  :arith-assert-lower      428924
;  :arith-assert-upper      354396
;  :arith-bound-prop        16643
;  :arith-conflicts         951
;  :arith-eq-adapter        207991
;  :arith-fixed-eqs         278571
;  :arith-offset-eqs        93688
;  :arith-pivots            43990
;  :conflicts               2246
;  :datatype-accessor-ax    632
;  :datatype-constructor-ax 1561
;  :datatype-occurs-check   1309
;  :datatype-splits         1167
;  :decisions               128044
;  :del-clause              1992274
;  :final-checks            177
;  :interface-eqs           41
;  :max-generation          15
;  :max-memory              50.39
;  :memory                  45.79
;  :minimized-lits          297
;  :mk-bool-var             2317239
;  :mk-clause               1994078
;  :num-allocs              7747264
;  :num-checks              346
;  :propagations            860480
;  :quant-instantiations    1017520
;  :restarts                4
;  :rlimit-count            25361048)
(pop) ; 23
(push) ; 23
; [else-branch: 162 | !(i2@278@03 < V@12@03)]
(assert (not (< i2@278@03 V@12@03)))
(pop) ; 23
(pop) ; 22
; Joined path conditions
(assert (implies
  (< i2@278@03 V@12@03)
  (and
    (< i2@278@03 V@12@03)
    (< i1@277@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@277@03)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@277@03))
    (< i2@278@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@278@03)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@278@03)))))
; Joined path conditions
(pop) ; 21
(push) ; 21
; [else-branch: 161 | !(0 <= i2@278@03)]
(assert (not (<= 0 i2@278@03)))
(pop) ; 21
(pop) ; 20
; Joined path conditions
(assert (implies
  (<= 0 i2@278@03)
  (and
    (<= 0 i2@278@03)
    (implies
      (< i2@278@03 V@12@03)
      (and
        (< i2@278@03 V@12@03)
        (< i1@277@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@277@03)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@277@03))
        (< i2@278@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@278@03)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@278@03)))))))
; Joined path conditions
(pop) ; 19
(push) ; 19
; [else-branch: 160 | !(i1@277@03 < V@12@03)]
(assert (not (< i1@277@03 V@12@03)))
(pop) ; 19
(pop) ; 18
; Joined path conditions
(assert (implies
  (< i1@277@03 V@12@03)
  (and
    (< i1@277@03 V@12@03)
    (implies
      (<= 0 i2@278@03)
      (and
        (<= 0 i2@278@03)
        (implies
          (< i2@278@03 V@12@03)
          (and
            (< i2@278@03 V@12@03)
            (< i1@277@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@277@03)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@277@03))
            (< i2@278@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@278@03)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@278@03)))))))))
; Joined path conditions
(pop) ; 17
(push) ; 17
; [else-branch: 159 | !(0 <= i1@277@03)]
(assert (not (<= 0 i1@277@03)))
(pop) ; 17
(pop) ; 16
; Joined path conditions
(assert (implies
  (<= 0 i1@277@03)
  (and
    (<= 0 i1@277@03)
    (implies
      (< i1@277@03 V@12@03)
      (and
        (< i1@277@03 V@12@03)
        (implies
          (<= 0 i2@278@03)
          (and
            (<= 0 i2@278@03)
            (implies
              (< i2@278@03 V@12@03)
              (and
                (< i2@278@03 V@12@03)
                (< i1@277@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@277@03)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@277@03))
                (< i2@278@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@278@03)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@278@03)))))))))))
; Joined path conditions
(push) ; 16
; [then-branch: 163 | Lookup(option$array$,sm@172@03,aloc((_, _), opt_get1(_, Gf@11@03), i1@277@03)) == Lookup(option$array$,sm@172@03,aloc((_, _), opt_get1(_, Gf@11@03), i2@278@03)) && i2@278@03 < V@12@03 && 0 <= i2@278@03 && i1@277@03 < V@12@03 && 0 <= i1@277@03 | live]
; [else-branch: 163 | !(Lookup(option$array$,sm@172@03,aloc((_, _), opt_get1(_, Gf@11@03), i1@277@03)) == Lookup(option$array$,sm@172@03,aloc((_, _), opt_get1(_, Gf@11@03), i2@278@03)) && i2@278@03 < V@12@03 && 0 <= i2@278@03 && i1@277@03 < V@12@03 && 0 <= i1@277@03) | live]
(push) ; 17
; [then-branch: 163 | Lookup(option$array$,sm@172@03,aloc((_, _), opt_get1(_, Gf@11@03), i1@277@03)) == Lookup(option$array$,sm@172@03,aloc((_, _), opt_get1(_, Gf@11@03), i2@278@03)) && i2@278@03 < V@12@03 && 0 <= i2@278@03 && i1@277@03 < V@12@03 && 0 <= i1@277@03]
(assert (and
  (and
    (and
      (and
        (=
          ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@277@03))
          ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@278@03)))
        (< i2@278@03 V@12@03))
      (<= 0 i2@278@03))
    (< i1@277@03 V@12@03))
  (<= 0 i1@277@03)))
; [eval] i1 == i2
(pop) ; 17
(push) ; 17
; [else-branch: 163 | !(Lookup(option$array$,sm@172@03,aloc((_, _), opt_get1(_, Gf@11@03), i1@277@03)) == Lookup(option$array$,sm@172@03,aloc((_, _), opt_get1(_, Gf@11@03), i2@278@03)) && i2@278@03 < V@12@03 && 0 <= i2@278@03 && i1@277@03 < V@12@03 && 0 <= i1@277@03)]
(assert (not
  (and
    (and
      (and
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@277@03))
            ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@278@03)))
          (< i2@278@03 V@12@03))
        (<= 0 i2@278@03))
      (< i1@277@03 V@12@03))
    (<= 0 i1@277@03))))
(pop) ; 17
(pop) ; 16
; Joined path conditions
(assert (implies
  (and
    (and
      (and
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@277@03))
            ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@278@03)))
          (< i2@278@03 V@12@03))
        (<= 0 i2@278@03))
      (< i1@277@03 V@12@03))
    (<= 0 i1@277@03))
  (and
    (=
      ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@277@03))
      ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@278@03)))
    (< i2@278@03 V@12@03)
    (<= 0 i2@278@03)
    (< i1@277@03 V@12@03)
    (<= 0 i1@277@03))))
; Joined path conditions
(pop) ; 15
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i2@278@03 Int)) (!
  (and
    (implies
      (<= 0 i1@277@03)
      (and
        (<= 0 i1@277@03)
        (implies
          (< i1@277@03 V@12@03)
          (and
            (< i1@277@03 V@12@03)
            (implies
              (<= 0 i2@278@03)
              (and
                (<= 0 i2@278@03)
                (implies
                  (< i2@278@03 V@12@03)
                  (and
                    (< i2@278@03 V@12@03)
                    (< i1@277@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))
                    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@277@03)) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@277@03))
                    (< i2@278@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))
                    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@278@03)) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@278@03))))))))))
    (implies
      (and
        (and
          (and
            (and
              (=
                ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@277@03))
                ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@278@03)))
              (< i2@278@03 V@12@03))
            (<= 0 i2@278@03))
          (< i1@277@03 V@12@03))
        (<= 0 i1@277@03))
      (and
        (=
          ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@277@03))
          ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@278@03)))
        (< i2@278@03 V@12@03)
        (<= 0 i2@278@03)
        (< i1@277@03 V@12@03)
        (<= 0 i1@277@03))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@278@03))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 14
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@277@03 Int)) (!
  (forall ((i2@278@03 Int)) (!
    (and
      (implies
        (<= 0 i1@277@03)
        (and
          (<= 0 i1@277@03)
          (implies
            (< i1@277@03 V@12@03)
            (and
              (< i1@277@03 V@12@03)
              (implies
                (<= 0 i2@278@03)
                (and
                  (<= 0 i2@278@03)
                  (implies
                    (< i2@278@03 V@12@03)
                    (and
                      (< i2@278@03 V@12@03)
                      (< i1@277@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))
                      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@277@03)) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@277@03))
                      (< i2@278@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))
                      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@278@03)) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@278@03))))))))))
      (implies
        (and
          (and
            (and
              (and
                (=
                  ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@277@03))
                  ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@278@03)))
                (< i2@278@03 V@12@03))
              (<= 0 i2@278@03))
            (< i1@277@03 V@12@03))
          (<= 0 i1@277@03))
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@277@03))
            ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@278@03)))
          (< i2@278@03 V@12@03)
          (<= 0 i2@278@03)
          (< i1@277@03 V@12@03)
          (<= 0 i1@277@03))))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@278@03))
    :qid |prog.l<no position>-aux|))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@277@03))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(push) ; 14
(assert (not (forall ((i1@277@03 Int)) (!
  (forall ((i2@278@03 Int)) (!
    (implies
      (and
        (and
          (and
            (and
              (=
                ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@277@03))
                ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@278@03)))
              (< i2@278@03 V@12@03))
            (<= 0 i2@278@03))
          (< i1@277@03 V@12@03))
        (<= 0 i1@277@03))
      (= i1@277@03 i2@278@03))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@278@03))
    :qid |prog.l<no position>|))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@277@03))
  :qid |prog.l<no position>|))))
(check-sat)
; unsat
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1555273
;  :arith-add-rows          417365
;  :arith-assert-diseq      59626
;  :arith-assert-lower      428929
;  :arith-assert-upper      354399
;  :arith-bound-prop        16645
;  :arith-conflicts         951
;  :arith-eq-adapter        208006
;  :arith-fixed-eqs         278573
;  :arith-offset-eqs        93688
;  :arith-pivots            44010
;  :conflicts               2247
;  :datatype-accessor-ax    632
;  :datatype-constructor-ax 1561
;  :datatype-occurs-check   1309
;  :datatype-splits         1167
;  :decisions               128044
;  :del-clause              1992656
;  :final-checks            177
;  :interface-eqs           41
;  :max-generation          15
;  :max-memory              50.39
;  :memory                  45.77
;  :minimized-lits          297
;  :mk-bool-var             2317556
;  :mk-clause               1994258
;  :num-allocs              7749675
;  :num-checks              347
;  :propagations            860490
;  :quant-instantiations    1017656
;  :restarts                4
;  :rlimit-count            25371136
;  :time                    0.00)
(assert (forall ((i1@277@03 Int)) (!
  (forall ((i2@278@03 Int)) (!
    (implies
      (and
        (and
          (and
            (and
              (=
                ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@277@03))
                ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@278@03)))
              (< i2@278@03 V@12@03))
            (<= 0 i2@278@03))
          (< i1@277@03 V@12@03))
        (<= 0 i1@277@03))
      (= i1@277@03 i2@278@03))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@278@03))
    :qid |prog.l<no position>|))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@277@03))
  :qid |prog.l<no position>|)))
; [eval] p != (None(): option[array])
; [eval] (None(): option[array])
; [eval] alen(opt_get1(p)) == V
; [eval] alen(opt_get1(p))
; [eval] opt_get1(p)
(push) ; 14
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 14
; Joined path conditions
; [eval] 0 <= s
; [eval] s < V
; [eval] 0 <= t
; [eval] t < V
(declare-const i1@279@03 Int)
(declare-const j1@280@03 Int)
(push) ; 14
; [eval] 0 <= i1 && i1 < V && (0 <= j1 && j1 < V)
; [eval] 0 <= i1
(push) ; 15
; [then-branch: 164 | 0 <= i1@279@03 | live]
; [else-branch: 164 | !(0 <= i1@279@03) | live]
(push) ; 16
; [then-branch: 164 | 0 <= i1@279@03]
(assert (<= 0 i1@279@03))
; [eval] i1 < V
(push) ; 17
; [then-branch: 165 | i1@279@03 < V@12@03 | live]
; [else-branch: 165 | !(i1@279@03 < V@12@03) | live]
(push) ; 18
; [then-branch: 165 | i1@279@03 < V@12@03]
(assert (< i1@279@03 V@12@03))
; [eval] 0 <= j1
(push) ; 19
; [then-branch: 166 | 0 <= j1@280@03 | live]
; [else-branch: 166 | !(0 <= j1@280@03) | live]
(push) ; 20
; [then-branch: 166 | 0 <= j1@280@03]
(assert (<= 0 j1@280@03))
; [eval] j1 < V
(pop) ; 20
(push) ; 20
; [else-branch: 166 | !(0 <= j1@280@03)]
(assert (not (<= 0 j1@280@03)))
(pop) ; 20
(pop) ; 19
; Joined path conditions
; Joined path conditions
(pop) ; 18
(push) ; 18
; [else-branch: 165 | !(i1@279@03 < V@12@03)]
(assert (not (< i1@279@03 V@12@03)))
(pop) ; 18
(pop) ; 17
; Joined path conditions
; Joined path conditions
(pop) ; 16
(push) ; 16
; [else-branch: 164 | !(0 <= i1@279@03)]
(assert (not (<= 0 i1@279@03)))
(pop) ; 16
(pop) ; 15
; Joined path conditions
; Joined path conditions
(assert (and
  (and (and (< j1@280@03 V@12@03) (<= 0 j1@280@03)) (< i1@279@03 V@12@03))
  (<= 0 i1@279@03)))
; [eval] aloc(opt_get1(aloc(opt_get1(Gf), i1).option$array$), j1)
; [eval] opt_get1(aloc(opt_get1(Gf), i1).option$array$)
; [eval] aloc(opt_get1(Gf), i1)
; [eval] opt_get1(Gf)
(push) ; 15
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 15
; Joined path conditions
(push) ; 15
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 16
(assert (not (< i1@279@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))))
(check-sat)
; unsat
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1555273
;  :arith-add-rows          417368
;  :arith-assert-diseq      59626
;  :arith-assert-lower      428935
;  :arith-assert-upper      354399
;  :arith-bound-prop        16645
;  :arith-conflicts         951
;  :arith-eq-adapter        208006
;  :arith-fixed-eqs         278573
;  :arith-offset-eqs        93688
;  :arith-pivots            44010
;  :conflicts               2247
;  :datatype-accessor-ax    632
;  :datatype-constructor-ax 1561
;  :datatype-occurs-check   1309
;  :datatype-splits         1167
;  :decisions               128044
;  :del-clause              1992656
;  :final-checks            177
;  :interface-eqs           41
;  :max-generation          15
;  :max-memory              50.39
;  :memory                  45.77
;  :minimized-lits          297
;  :mk-bool-var             2317563
;  :mk-clause               1994258
;  :num-allocs              7750279
;  :num-checks              348
;  :propagations            860490
;  :quant-instantiations    1017656
;  :restarts                4
;  :rlimit-count            25372139)
(assert (< i1@279@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03))))
(pop) ; 15
; Joined path conditions
(assert (< i1@279@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@279@03)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@279@03)))
(push) ; 15
(assert (not (ite
  (and
    (<
      (inv@171@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@279@03))
      V@12@03)
    (<=
      0
      (inv@171@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@279@03))))
  (< $Perm.No $k@170@03)
  false)))
(check-sat)
; unsat
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1555310
;  :arith-add-rows          417399
;  :arith-assert-diseq      59626
;  :arith-assert-lower      428942
;  :arith-assert-upper      354407
;  :arith-bound-prop        16652
;  :arith-conflicts         952
;  :arith-eq-adapter        208013
;  :arith-fixed-eqs         278580
;  :arith-offset-eqs        93688
;  :arith-pivots            44018
;  :conflicts               2248
;  :datatype-accessor-ax    632
;  :datatype-constructor-ax 1561
;  :datatype-occurs-check   1309
;  :datatype-splits         1167
;  :decisions               128044
;  :del-clause              1992656
;  :final-checks            177
;  :interface-eqs           41
;  :max-generation          15
;  :max-memory              50.39
;  :memory                  45.79
;  :minimized-lits          297
;  :mk-bool-var             2317721
;  :mk-clause               1994350
;  :num-allocs              7751364
;  :num-checks              349
;  :propagations            860492
;  :quant-instantiations    1017724
;  :restarts                4
;  :rlimit-count            25376638)
(push) ; 15
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 16
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@279@03))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1555310
;  :arith-add-rows          417399
;  :arith-assert-diseq      59626
;  :arith-assert-lower      428942
;  :arith-assert-upper      354407
;  :arith-bound-prop        16652
;  :arith-conflicts         952
;  :arith-eq-adapter        208013
;  :arith-fixed-eqs         278580
;  :arith-offset-eqs        93688
;  :arith-pivots            44018
;  :conflicts               2249
;  :datatype-accessor-ax    632
;  :datatype-constructor-ax 1561
;  :datatype-occurs-check   1309
;  :datatype-splits         1167
;  :decisions               128044
;  :del-clause              1992656
;  :final-checks            177
;  :interface-eqs           41
;  :max-generation          15
;  :max-memory              50.39
;  :memory                  45.79
;  :minimized-lits          297
;  :mk-bool-var             2317721
;  :mk-clause               1994350
;  :num-allocs              7751453
;  :num-checks              350
;  :propagations            860492
;  :quant-instantiations    1017724
;  :restarts                4
;  :rlimit-count            25376733)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@279@03))
    (as None<option<array>>  option<array>))))
(pop) ; 15
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@279@03))
    (as None<option<array>>  option<array>))))
(push) ; 15
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 16
(assert (not (<
  j1@280@03
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@279@03)))))))
(check-sat)
; unsat
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1555316
;  :arith-add-rows          417405
;  :arith-assert-diseq      59626
;  :arith-assert-lower      428944
;  :arith-assert-upper      354409
;  :arith-bound-prop        16652
;  :arith-conflicts         953
;  :arith-eq-adapter        208014
;  :arith-fixed-eqs         278581
;  :arith-offset-eqs        93688
;  :arith-pivots            44022
;  :conflicts               2250
;  :datatype-accessor-ax    632
;  :datatype-constructor-ax 1561
;  :datatype-occurs-check   1309
;  :datatype-splits         1167
;  :decisions               128044
;  :del-clause              1992660
;  :final-checks            177
;  :interface-eqs           41
;  :max-generation          15
;  :max-memory              50.39
;  :memory                  45.79
;  :minimized-lits          297
;  :mk-bool-var             2317732
;  :mk-clause               1994354
;  :num-allocs              7751652
;  :num-checks              351
;  :propagations            860494
;  :quant-instantiations    1017733
;  :restarts                4
;  :rlimit-count            25377332)
(assert (<
  j1@280@03
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@279@03))))))
(pop) ; 15
; Joined path conditions
(assert (<
  j1@280@03
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@279@03))))))
(pop) ; 14
(declare-fun inv@281@03 ($Ref) Int)
(declare-fun inv@282@03 ($Ref) Int)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(assert (forall ((i1@279@03 Int) (j1@280@03 Int)) (!
  (and
    (< i1@279@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@279@03)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@279@03))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@279@03))
        (as None<option<array>>  option<array>)))
    (<
      j1@280@03
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@279@03))))))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@279@03))) j1@280@03))
  :qid |int-aux|)))
(declare-const sm@283@03 $FVF<Int>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@180@03 r) V@12@03) (<= 0 (inv@180@03 r)))
        (< (inv@179@03 r) V@12@03))
      (<= 0 (inv@179@03 r)))
    (=
      ($FVF.lookup_int (as sm@283@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@283@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03))))))))))))))) r))
  :qid |qp.fvfValDef125|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@183@03 r) V@12@03) (<= 0 (inv@183@03 r)))
    (=
      ($FVF.lookup_int (as sm@283@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03)))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@283@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03)))))))))))))))) r))
  :qid |qp.fvfValDef126|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03)))))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@283@03  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef127|)))
; Check receiver injectivity
(push) ; 14
(assert (not (forall ((i11@279@03 Int) (j11@280@03 Int) (i12@279@03 Int) (j12@280@03 Int)) (!
  (implies
    (and
      (and
        (and
          (and
            (and (< j11@280@03 V@12@03) (<= 0 j11@280@03))
            (< i11@279@03 V@12@03))
          (<= 0 i11@279@03))
        ($FVF.loc_int ($FVF.lookup_int (as sm@283@03  $FVF<Int>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i11@279@03))) j11@280@03)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i11@279@03))) j11@280@03)))
      (and
        (and
          (and
            (and (< j12@280@03 V@12@03) (<= 0 j12@280@03))
            (< i12@279@03 V@12@03))
          (<= 0 i12@279@03))
        ($FVF.loc_int ($FVF.lookup_int (as sm@283@03  $FVF<Int>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i12@279@03))) j12@280@03)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i12@279@03))) j12@280@03)))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i11@279@03))) j11@280@03)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i12@279@03))) j12@280@03)))
    (and (= i11@279@03 i12@279@03) (= j11@280@03 j12@280@03)))
  
  :qid |int-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1555368
;  :arith-add-rows          417436
;  :arith-assert-diseq      59626
;  :arith-assert-lower      428954
;  :arith-assert-upper      354409
;  :arith-bound-prop        16652
;  :arith-conflicts         953
;  :arith-eq-adapter        208024
;  :arith-fixed-eqs         278581
;  :arith-offset-eqs        93688
;  :arith-pivots            44032
;  :conflicts               2251
;  :datatype-accessor-ax    632
;  :datatype-constructor-ax 1561
;  :datatype-occurs-check   1309
;  :datatype-splits         1167
;  :decisions               128044
;  :del-clause              1992872
;  :final-checks            177
;  :interface-eqs           41
;  :max-generation          15
;  :max-memory              50.39
;  :memory                  45.77
;  :minimized-lits          297
;  :mk-bool-var             2317937
;  :mk-clause               1994474
;  :num-allocs              7753854
;  :num-checks              352
;  :propagations            860510
;  :quant-instantiations    1017837
;  :restarts                4
;  :rlimit-count            25384968
;  :time                    0.00)
; Definitional axioms for inverse functions
(assert (forall ((i1@279@03 Int) (j1@280@03 Int)) (!
  (implies
    (and
      (and (and (< j1@280@03 V@12@03) (<= 0 j1@280@03)) (< i1@279@03 V@12@03))
      (<= 0 i1@279@03))
    (and
      (=
        (inv@281@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@279@03))) j1@280@03))
        i1@279@03)
      (=
        (inv@282@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@279@03))) j1@280@03))
        j1@280@03)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@279@03))) j1@280@03))
  :qid |int-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@282@03 r) V@12@03) (<= 0 (inv@282@03 r)))
        (< (inv@281@03 r) V@12@03))
      (<= 0 (inv@281@03 r)))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) (inv@281@03 r)))) (inv@282@03 r))
      r))
  :pattern ((inv@281@03 r))
  :pattern ((inv@282@03 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@282@03 r) V@12@03) (<= 0 (inv@282@03 r)))
        (< (inv@281@03 r) V@12@03))
      (<= 0 (inv@281@03 r)))
    ($FVF.loc_int ($FVF.lookup_int (as sm@283@03  $FVF<Int>) r) r))
  :pattern ((inv@281@03 r) (inv@282@03 r))
  )))
; Precomputing data for removing quantified permissions
(define-fun pTaken@284@03 ((r $Ref)) $Perm
  (ite
    (and
      (and
        (and (< (inv@282@03 r) V@12@03) (<= 0 (inv@282@03 r)))
        (< (inv@281@03 r) V@12@03))
      (<= 0 (inv@281@03 r)))
    ($Perm.min
      (ite
        (and
          (and
            (and (< (inv@180@03 r) V@12@03) (<= 0 (inv@180@03 r)))
            (< (inv@179@03 r) V@12@03))
          (<= 0 (inv@179@03 r)))
        $Perm.Write
        $Perm.No)
      $Perm.Write)
    $Perm.No))
(define-fun pTaken@285@03 ((r $Ref)) $Perm
  (ite
    (and
      (and
        (and (< (inv@282@03 r) V@12@03) (<= 0 (inv@282@03 r)))
        (< (inv@281@03 r) V@12@03))
      (<= 0 (inv@281@03 r)))
    ($Perm.min
      (ite
        (and (< (inv@183@03 r) V@12@03) (<= 0 (inv@183@03 r)))
        $Perm.Write
        $Perm.No)
      (- $Perm.Write (pTaken@284@03 r)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 500)
(push) ; 14
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and
          (and
            (and (< (inv@180@03 r) V@12@03) (<= 0 (inv@180@03 r)))
            (< (inv@179@03 r) V@12@03))
          (<= 0 (inv@179@03 r)))
        $Perm.Write
        $Perm.No)
      (pTaken@284@03 r))
    $Perm.No)
  
  ))))
(check-sat)
; unsat
(pop) ; 14
; 0.03s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1557022
;  :arith-add-rows          417833
;  :arith-assert-diseq      59668
;  :arith-assert-lower      429289
;  :arith-assert-upper      354599
;  :arith-bound-prop        16683
;  :arith-conflicts         958
;  :arith-eq-adapter        208284
;  :arith-fixed-eqs         278792
;  :arith-offset-eqs        93919
;  :arith-pivots            44125
;  :conflicts               2274
;  :datatype-accessor-ax    632
;  :datatype-constructor-ax 1569
;  :datatype-occurs-check   1309
;  :datatype-splits         1167
;  :decisions               128111
;  :del-clause              1994882
;  :final-checks            177
;  :interface-eqs           41
;  :max-generation          15
;  :max-memory              50.39
;  :memory                  45.80
;  :minimized-lits          297
;  :mk-bool-var             2320983
;  :mk-clause               1996470
;  :num-allocs              7765948
;  :num-checks              354
;  :propagations            861388
;  :quant-instantiations    1018807
;  :restarts                4
;  :rlimit-count            25429734
;  :time                    0.02)
; Intermediate check if already taken enough permissions
(push) ; 14
(assert (not (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@282@03 r) V@12@03) (<= 0 (inv@282@03 r)))
        (< (inv@281@03 r) V@12@03))
      (<= 0 (inv@281@03 r)))
    (= (- $Perm.Write (pTaken@284@03 r)) $Perm.No))
  
  ))))
(check-sat)
; unsat
(pop) ; 14
; 0.02s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1557880
;  :arith-add-rows          417990
;  :arith-assert-diseq      59687
;  :arith-assert-lower      429449
;  :arith-assert-upper      354694
;  :arith-bound-prop        16694
;  :arith-conflicts         960
;  :arith-eq-adapter        208401
;  :arith-fixed-eqs         278898
;  :arith-offset-eqs        94031
;  :arith-pivots            44163
;  :conflicts               2292
;  :datatype-accessor-ax    632
;  :datatype-constructor-ax 1573
;  :datatype-occurs-check   1309
;  :datatype-splits         1167
;  :decisions               128148
;  :del-clause              1996009
;  :final-checks            177
;  :interface-eqs           41
;  :max-generation          15
;  :max-memory              50.39
;  :memory                  45.80
;  :minimized-lits          297
;  :mk-bool-var             2322257
;  :mk-clause               1997597
;  :num-allocs              7770595
;  :num-checks              355
;  :propagations            861822
;  :quant-instantiations    1019336
;  :restarts                4
;  :rlimit-count            25453475
;  :time                    0.02)
; Final check if taken enough permissions
; Done removing quantified permissions
; Definitional axioms for snapshot map values
(declare-const i1@286@03 Int)
(push) ; 14
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 15
; [then-branch: 167 | 0 <= i1@286@03 | live]
; [else-branch: 167 | !(0 <= i1@286@03) | live]
(push) ; 16
; [then-branch: 167 | 0 <= i1@286@03]
(assert (<= 0 i1@286@03))
; [eval] i1 < V
(pop) ; 16
(push) ; 16
; [else-branch: 167 | !(0 <= i1@286@03)]
(assert (not (<= 0 i1@286@03)))
(pop) ; 16
(pop) ; 15
; Joined path conditions
; Joined path conditions
(assert (and (< i1@286@03 V@12@03) (<= 0 i1@286@03)))
; [eval] aloc(opt_get1(p), i1)
; [eval] opt_get1(p)
(push) ; 15
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 15
; Joined path conditions
(push) ; 15
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 16
(assert (not (< i1@286@03 (alen<Int> (opt_get1 $Snap.unit p@15@03)))))
(check-sat)
; unsat
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1557880
;  :arith-add-rows          417991
;  :arith-assert-diseq      59687
;  :arith-assert-lower      429451
;  :arith-assert-upper      354694
;  :arith-bound-prop        16694
;  :arith-conflicts         960
;  :arith-eq-adapter        208401
;  :arith-fixed-eqs         278898
;  :arith-offset-eqs        94031
;  :arith-pivots            44163
;  :conflicts               2292
;  :datatype-accessor-ax    632
;  :datatype-constructor-ax 1573
;  :datatype-occurs-check   1309
;  :datatype-splits         1167
;  :decisions               128148
;  :del-clause              1996009
;  :final-checks            177
;  :interface-eqs           41
;  :max-generation          15
;  :max-memory              50.39
;  :memory                  45.80
;  :minimized-lits          297
;  :mk-bool-var             2322259
;  :mk-clause               1997597
;  :num-allocs              7770706
;  :num-checks              356
;  :propagations            861822
;  :quant-instantiations    1019336
;  :restarts                4
;  :rlimit-count            25453654)
(assert (< i1@286@03 (alen<Int> (opt_get1 $Snap.unit p@15@03))))
(pop) ; 15
; Joined path conditions
(assert (< i1@286@03 (alen<Int> (opt_get1 $Snap.unit p@15@03))))
(pop) ; 14
(declare-fun inv@287@03 ($Ref) Int)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(assert (forall ((i1@286@03 Int)) (!
  (< i1@286@03 (alen<Int> (opt_get1 $Snap.unit p@15@03)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) i1@286@03))
  :qid |int-aux|)))
(declare-const sm@288@03 $FVF<Int>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@183@03 r) V@12@03) (<= 0 (inv@183@03 r)))
    (=
      ($FVF.lookup_int (as sm@288@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03)))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@288@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03)))))))))))))))) r))
  :qid |qp.fvfValDef128|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03)))))))))))))))) r) r)
  :pattern (($FVF.lookup_int (as sm@288@03  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef129|)))
; Check receiver injectivity
(push) ; 14
(assert (not (forall ((i11@286@03 Int) (i12@286@03 Int)) (!
  (implies
    (and
      (and
        (and (< i11@286@03 V@12@03) (<= 0 i11@286@03))
        ($FVF.loc_int ($FVF.lookup_int (as sm@288@03  $FVF<Int>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit p@15@03) i11@286@03)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit p@15@03) i11@286@03)))
      (and
        (and (< i12@286@03 V@12@03) (<= 0 i12@286@03))
        ($FVF.loc_int ($FVF.lookup_int (as sm@288@03  $FVF<Int>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit p@15@03) i12@286@03)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit p@15@03) i12@286@03)))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) i11@286@03)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) i12@286@03)))
    (= i11@286@03 i12@286@03))
  
  :qid |int-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1557917
;  :arith-add-rows          417996
;  :arith-assert-diseq      59688
;  :arith-assert-lower      429455
;  :arith-assert-upper      354694
;  :arith-bound-prop        16694
;  :arith-conflicts         960
;  :arith-eq-adapter        208402
;  :arith-fixed-eqs         278898
;  :arith-offset-eqs        94031
;  :arith-pivots            44163
;  :conflicts               2293
;  :datatype-accessor-ax    632
;  :datatype-constructor-ax 1573
;  :datatype-occurs-check   1309
;  :datatype-splits         1167
;  :decisions               128148
;  :del-clause              1996016
;  :final-checks            177
;  :interface-eqs           41
;  :max-generation          15
;  :max-memory              50.39
;  :memory                  45.80
;  :minimized-lits          297
;  :mk-bool-var             2322313
;  :mk-clause               1997604
;  :num-allocs              7771681
;  :num-checks              357
;  :propagations            861822
;  :quant-instantiations    1019395
;  :restarts                4
;  :rlimit-count            25456478
;  :time                    0.00)
; Definitional axioms for inverse functions
(assert (forall ((i1@286@03 Int)) (!
  (implies
    (and (< i1@286@03 V@12@03) (<= 0 i1@286@03))
    (=
      (inv@287@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) i1@286@03))
      i1@286@03))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) i1@286@03))
  :qid |int-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@287@03 r) V@12@03) (<= 0 (inv@287@03 r)))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) (inv@287@03 r))
      r))
  :pattern ((inv@287@03 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@287@03 r) V@12@03) (<= 0 (inv@287@03 r)))
    ($FVF.loc_int ($FVF.lookup_int (as sm@288@03  $FVF<Int>) r) r))
  :pattern ((inv@287@03 r))
  )))
; Precomputing data for removing quantified permissions
(define-fun pTaken@289@03 ((r $Ref)) $Perm
  (ite
    (and (< (inv@287@03 r) V@12@03) (<= 0 (inv@287@03 r)))
    ($Perm.min
      (ite
        (and (< (inv@183@03 r) V@12@03) (<= 0 (inv@183@03 r)))
        $Perm.Write
        $Perm.No)
      $Perm.Write)
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 500)
(push) ; 14
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and (< (inv@183@03 r) V@12@03) (<= 0 (inv@183@03 r)))
        $Perm.Write
        $Perm.No)
      (pTaken@289@03 r))
    $Perm.No)
  
  ))))
(check-sat)
; unsat
(pop) ; 14
; 0.05s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1559284
;  :arith-add-rows          418394
;  :arith-assert-diseq      59723
;  :arith-assert-lower      429706
;  :arith-assert-upper      354839
;  :arith-bound-prop        16717
;  :arith-conflicts         963
;  :arith-eq-adapter        208627
;  :arith-fixed-eqs         279061
;  :arith-offset-eqs        94209
;  :arith-pivots            44227
;  :conflicts               2315
;  :datatype-accessor-ax    632
;  :datatype-constructor-ax 1581
;  :datatype-occurs-check   1309
;  :datatype-splits         1167
;  :decisions               128206
;  :del-clause              1997638
;  :final-checks            177
;  :interface-eqs           41
;  :max-generation          15
;  :max-memory              50.39
;  :memory                  45.80
;  :minimized-lits          297
;  :mk-bool-var             2324626
;  :mk-clause               1999224
;  :num-allocs              7780124
;  :num-checks              359
;  :propagations            862475
;  :quant-instantiations    1020174
;  :restarts                4
;  :rlimit-count            25487844
;  :time                    0.05)
; Intermediate check if already taken enough permissions
(push) ; 14
(assert (not (forall ((r $Ref)) (!
  (implies
    (and (< (inv@287@03 r) V@12@03) (<= 0 (inv@287@03 r)))
    (= (- $Perm.Write (pTaken@289@03 r)) $Perm.No))
  
  ))))
(check-sat)
; unsat
(pop) ; 14
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1559339
;  :arith-add-rows          418428
;  :arith-assert-diseq      59725
;  :arith-assert-lower      429719
;  :arith-assert-upper      354853
;  :arith-bound-prop        16718
;  :arith-conflicts         964
;  :arith-eq-adapter        208639
;  :arith-fixed-eqs         279071
;  :arith-offset-eqs        94209
;  :arith-pivots            44231
;  :conflicts               2316
;  :datatype-accessor-ax    632
;  :datatype-constructor-ax 1581
;  :datatype-occurs-check   1309
;  :datatype-splits         1167
;  :decisions               128206
;  :del-clause              1997810
;  :final-checks            177
;  :interface-eqs           41
;  :max-generation          15
;  :max-memory              50.39
;  :memory                  45.80
;  :minimized-lits          297
;  :mk-bool-var             2324838
;  :mk-clause               1999396
;  :num-allocs              7781084
;  :num-checks              360
;  :propagations            862482
;  :quant-instantiations    1020251
;  :restarts                4
;  :rlimit-count            25491473
;  :time                    0.01)
; Final check if taken enough permissions
; Done removing quantified permissions
; Definitional axioms for snapshot map values
; [eval] valid_graph_vertices(this, p, V)
(push) ; 14
; [eval] this != null
; [eval] p != (None(): option[array])
; [eval] (None(): option[array])
; [eval] alen(opt_get1(p)) == V
; [eval] alen(opt_get1(p))
; [eval] opt_get1(p)
(push) ; 15
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 15
; Joined path conditions
(declare-const i1@290@03 Int)
(push) ; 15
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 16
; [then-branch: 168 | 0 <= i1@290@03 | live]
; [else-branch: 168 | !(0 <= i1@290@03) | live]
(push) ; 17
; [then-branch: 168 | 0 <= i1@290@03]
(assert (<= 0 i1@290@03))
; [eval] i1 < V
(pop) ; 17
(push) ; 17
; [else-branch: 168 | !(0 <= i1@290@03)]
(assert (not (<= 0 i1@290@03)))
(pop) ; 17
(pop) ; 16
; Joined path conditions
; Joined path conditions
(assert (and (< i1@290@03 V@12@03) (<= 0 i1@290@03)))
(declare-const $k@291@03 $Perm)
(assert ($Perm.isReadVar $k@291@03 $Perm.Write))
; [eval] aloc(opt_get1(p), i1)
; [eval] opt_get1(p)
(push) ; 16
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 16
; Joined path conditions
(push) ; 16
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 17
(assert (not (< i1@290@03 (alen<Int> (opt_get1 $Snap.unit p@15@03)))))
(check-sat)
; unsat
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1559339
;  :arith-add-rows          418429
;  :arith-assert-diseq      59726
;  :arith-assert-lower      429723
;  :arith-assert-upper      354854
;  :arith-bound-prop        16718
;  :arith-conflicts         964
;  :arith-eq-adapter        208640
;  :arith-fixed-eqs         279071
;  :arith-offset-eqs        94209
;  :arith-pivots            44231
;  :conflicts               2316
;  :datatype-accessor-ax    632
;  :datatype-constructor-ax 1581
;  :datatype-occurs-check   1309
;  :datatype-splits         1167
;  :decisions               128206
;  :del-clause              1997810
;  :final-checks            177
;  :interface-eqs           41
;  :max-generation          15
;  :max-memory              50.39
;  :memory                  45.80
;  :minimized-lits          297
;  :mk-bool-var             2324844
;  :mk-clause               1999398
;  :num-allocs              7781262
;  :num-checks              361
;  :propagations            862483
;  :quant-instantiations    1020251
;  :restarts                4
;  :rlimit-count            25491803)
(assert (< i1@290@03 (alen<Int> (opt_get1 $Snap.unit p@15@03))))
(pop) ; 16
; Joined path conditions
(assert (< i1@290@03 (alen<Int> (opt_get1 $Snap.unit p@15@03))))
(pop) ; 15
(declare-fun inv@292@03 ($Ref) Int)
; Nested auxiliary terms: globals
(assert ($Perm.isReadVar $k@291@03 $Perm.Write))
; Nested auxiliary terms: non-globals
(assert (forall ((i1@290@03 Int)) (!
  (< i1@290@03 (alen<Int> (opt_get1 $Snap.unit p@15@03)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) i1@290@03))
  :qid |int-aux|)))
(push) ; 15
(assert (not (forall ((i1@290@03 Int)) (!
  (implies
    (and (< i1@290@03 V@12@03) (<= 0 i1@290@03))
    (or (= $k@291@03 $Perm.No) (< $Perm.No $k@291@03)))
  
  ))))
(check-sat)
; unsat
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1559339
;  :arith-add-rows          418430
;  :arith-assert-diseq      59727
;  :arith-assert-lower      429725
;  :arith-assert-upper      354855
;  :arith-bound-prop        16718
;  :arith-conflicts         964
;  :arith-eq-adapter        208641
;  :arith-fixed-eqs         279071
;  :arith-offset-eqs        94209
;  :arith-pivots            44231
;  :conflicts               2317
;  :datatype-accessor-ax    632
;  :datatype-constructor-ax 1581
;  :datatype-occurs-check   1309
;  :datatype-splits         1167
;  :decisions               128206
;  :del-clause              1997812
;  :final-checks            177
;  :interface-eqs           41
;  :max-generation          15
;  :max-memory              50.39
;  :memory                  45.80
;  :minimized-lits          297
;  :mk-bool-var             2324851
;  :mk-clause               1999400
;  :num-allocs              7781685
;  :num-checks              362
;  :propagations            862484
;  :quant-instantiations    1020251
;  :restarts                4
;  :rlimit-count            25492350)
(declare-const sm@293@03 $FVF<Int>)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@183@03 r) V@12@03) (<= 0 (inv@183@03 r)))
    (=
      ($FVF.lookup_int (as sm@293@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03)))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@293@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03)))))))))))))))) r))
  :qid |qp.fvfValDef130|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@180@03 r) V@12@03) (<= 0 (inv@180@03 r)))
        (< (inv@179@03 r) V@12@03))
      (<= 0 (inv@179@03 r)))
    (=
      ($FVF.lookup_int (as sm@293@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@293@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03))))))))))))))) r))
  :qid |qp.fvfValDef131|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03)))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03))))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@293@03  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef132|)))
; Check receiver injectivity
(push) ; 15
(assert (not (forall ((i11@290@03 Int) (i12@290@03 Int)) (!
  (implies
    (and
      (and
        (and
          (and (< i11@290@03 V@12@03) (<= 0 i11@290@03))
          ($FVF.loc_int ($FVF.lookup_int (as sm@293@03  $FVF<Int>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit p@15@03) i11@290@03)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit p@15@03) i11@290@03)))
        (< $Perm.No $k@291@03))
      (and
        (and
          (and (< i12@290@03 V@12@03) (<= 0 i12@290@03))
          ($FVF.loc_int ($FVF.lookup_int (as sm@293@03  $FVF<Int>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit p@15@03) i12@290@03)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit p@15@03) i12@290@03)))
        (< $Perm.No $k@291@03))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) i11@290@03)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) i12@290@03)))
    (= i11@290@03 i12@290@03))
  
  :qid |int-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1559379
;  :arith-add-rows          418437
;  :arith-assert-diseq      59728
;  :arith-assert-lower      429729
;  :arith-assert-upper      354855
;  :arith-bound-prop        16718
;  :arith-conflicts         964
;  :arith-eq-adapter        208642
;  :arith-fixed-eqs         279071
;  :arith-offset-eqs        94209
;  :arith-pivots            44231
;  :conflicts               2318
;  :datatype-accessor-ax    632
;  :datatype-constructor-ax 1581
;  :datatype-occurs-check   1309
;  :datatype-splits         1167
;  :decisions               128206
;  :del-clause              1997823
;  :final-checks            177
;  :interface-eqs           41
;  :max-generation          15
;  :max-memory              50.39
;  :memory                  45.79
;  :minimized-lits          297
;  :mk-bool-var             2324915
;  :mk-clause               1999411
;  :num-allocs              7782792
;  :num-checks              363
;  :propagations            862486
;  :quant-instantiations    1020315
;  :restarts                4
;  :rlimit-count            25495954
;  :time                    0.00)
; Definitional axioms for inverse functions
(assert (forall ((i1@290@03 Int)) (!
  (implies
    (and (and (< i1@290@03 V@12@03) (<= 0 i1@290@03)) (< $Perm.No $k@291@03))
    (=
      (inv@292@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) i1@290@03))
      i1@290@03))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) i1@290@03))
  :qid |int-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and (< (inv@292@03 r) V@12@03) (<= 0 (inv@292@03 r)))
      (< $Perm.No $k@291@03))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) (inv@292@03 r))
      r))
  :pattern ((inv@292@03 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@292@03 r) V@12@03) (<= 0 (inv@292@03 r)))
    ($FVF.loc_int ($FVF.lookup_int (as sm@293@03  $FVF<Int>) r) r))
  :pattern ((inv@292@03 r))
  )))
; Precomputing data for removing quantified permissions
(define-fun pTaken@294@03 ((r $Ref)) $Perm
  (ite
    (and (< (inv@292@03 r) V@12@03) (<= 0 (inv@292@03 r)))
    ($Perm.min
      (ite
        (and (< (inv@183@03 r) V@12@03) (<= 0 (inv@183@03 r)))
        $Perm.Write
        $Perm.No)
      $k@291@03)
    $Perm.No))
(define-fun pTaken@295@03 ((r $Ref)) $Perm
  (ite
    (and (< (inv@292@03 r) V@12@03) (<= 0 (inv@292@03 r)))
    ($Perm.min
      (ite
        (and
          (and
            (and (< (inv@180@03 r) V@12@03) (<= 0 (inv@180@03 r)))
            (< (inv@179@03 r) V@12@03))
          (<= 0 (inv@179@03 r)))
        $Perm.Write
        $Perm.No)
      (- $k@291@03 (pTaken@294@03 r)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Constrain original permissions $k@291@03
(assert (forall ((r $Ref)) (!
  (implies
    (not
      (=
        (ite
          (and (< (inv@183@03 r) V@12@03) (<= 0 (inv@183@03 r)))
          $Perm.Write
          $Perm.No)
        $Perm.No))
    (ite
      (and (< (inv@183@03 r) V@12@03) (<= 0 (inv@183@03 r)))
      (<
        (ite
          (and (< (inv@292@03 r) V@12@03) (<= 0 (inv@292@03 r)))
          $k@291@03
          $Perm.No)
        $Perm.Write)
      (<
        (ite
          (and (< (inv@292@03 r) V@12@03) (<= 0 (inv@292@03 r)))
          $k@291@03
          $Perm.No)
        $Perm.No)))
  :pattern ((inv@183@03 r))
  :pattern ((inv@292@03 r))
  :qid |qp.srp133|)))
; Intermediate check if already taken enough permissions
(set-option :timeout 500)
(push) ; 15
(assert (not (forall ((r $Ref)) (!
  (implies
    (and (< (inv@292@03 r) V@12@03) (<= 0 (inv@292@03 r)))
    (= (- $k@291@03 (pTaken@294@03 r)) $Perm.No))
  
  ))))
(check-sat)
; unsat
(pop) ; 15
; 0.02s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1561115
;  :arith-add-rows          418850
;  :arith-assert-diseq      59768
;  :arith-assert-lower      430045
;  :arith-assert-upper      355034
;  :arith-bound-prop        16750
;  :arith-conflicts         967
;  :arith-eq-adapter        208888
;  :arith-fixed-eqs         279274
;  :arith-offset-eqs        94482
;  :arith-pivots            44299
;  :conflicts               2340
;  :datatype-accessor-ax    632
;  :datatype-constructor-ax 1589
;  :datatype-occurs-check   1309
;  :datatype-splits         1167
;  :decisions               128271
;  :del-clause              1999744
;  :final-checks            177
;  :interface-eqs           41
;  :max-generation          15
;  :max-memory              50.39
;  :memory                  45.81
;  :minimized-lits          297
;  :mk-bool-var             2327302
;  :mk-clause               2001333
;  :num-allocs              7791958
;  :num-checks              365
;  :propagations            863416
;  :quant-instantiations    1021248
;  :restarts                4
;  :rlimit-count            25536053
;  :time                    0.02)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@296@03 $FVF<Int>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (iff
    (Set_in r ($FVF.domain_int (as sm@296@03  $FVF<Int>)))
    (and
      (and (< (inv@292@03 r) V@12@03) (<= 0 (inv@292@03 r)))
      (< $Perm.No $k@291@03)))
  :pattern ((Set_in r ($FVF.domain_int (as sm@296@03  $FVF<Int>))))
  :qid |qp.fvfDomDef137|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@292@03 r) V@12@03) (<= 0 (inv@292@03 r)))
        (< $Perm.No $k@291@03))
      (and (< (inv@183@03 r) V@12@03) (<= 0 (inv@183@03 r))))
    (=
      ($FVF.lookup_int (as sm@296@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03)))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@296@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03)))))))))))))))) r))
  :qid |qp.fvfValDef134|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@292@03 r) V@12@03) (<= 0 (inv@292@03 r)))
        (< $Perm.No $k@291@03))
      (and
        (and
          (and (< (inv@180@03 r) V@12@03) (<= 0 (inv@180@03 r)))
          (< (inv@179@03 r) V@12@03))
        (<= 0 (inv@179@03 r))))
    (=
      ($FVF.lookup_int (as sm@296@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@296@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03))))))))))))))) r))
  :qid |qp.fvfValDef135|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03)))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03))))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@296@03  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef136|)))
(pop) ; 14
; Joined path conditions
(assert ($Perm.isReadVar $k@291@03 $Perm.Write))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@183@03 r) V@12@03) (<= 0 (inv@183@03 r)))
    (=
      ($FVF.lookup_int (as sm@293@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03)))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@293@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03)))))))))))))))) r))
  :qid |qp.fvfValDef130|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@180@03 r) V@12@03) (<= 0 (inv@180@03 r)))
        (< (inv@179@03 r) V@12@03))
      (<= 0 (inv@179@03 r)))
    (=
      ($FVF.lookup_int (as sm@293@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@293@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03))))))))))))))) r))
  :qid |qp.fvfValDef131|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03)))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03))))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@293@03  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef132|)))
(assert (forall ((i1@290@03 Int)) (!
  (implies
    (and (and (< i1@290@03 V@12@03) (<= 0 i1@290@03)) (< $Perm.No $k@291@03))
    (=
      (inv@292@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) i1@290@03))
      i1@290@03))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) i1@290@03))
  :qid |int-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and (< (inv@292@03 r) V@12@03) (<= 0 (inv@292@03 r)))
      (< $Perm.No $k@291@03))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) (inv@292@03 r))
      r))
  :pattern ((inv@292@03 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (iff
    (Set_in r ($FVF.domain_int (as sm@296@03  $FVF<Int>)))
    (and
      (and (< (inv@292@03 r) V@12@03) (<= 0 (inv@292@03 r)))
      (< $Perm.No $k@291@03)))
  :pattern ((Set_in r ($FVF.domain_int (as sm@296@03  $FVF<Int>))))
  :qid |qp.fvfDomDef137|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@292@03 r) V@12@03) (<= 0 (inv@292@03 r)))
        (< $Perm.No $k@291@03))
      (and (< (inv@183@03 r) V@12@03) (<= 0 (inv@183@03 r))))
    (=
      ($FVF.lookup_int (as sm@296@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03)))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@296@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03)))))))))))))))) r))
  :qid |qp.fvfValDef134|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@292@03 r) V@12@03) (<= 0 (inv@292@03 r)))
        (< $Perm.No $k@291@03))
      (and
        (and
          (and (< (inv@180@03 r) V@12@03) (<= 0 (inv@180@03 r)))
          (< (inv@179@03 r) V@12@03))
        (<= 0 (inv@179@03 r))))
    (=
      ($FVF.lookup_int (as sm@296@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@296@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03))))))))))))))) r))
  :qid |qp.fvfValDef135|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03)))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03))))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@296@03  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef136|)))
(assert (and
  (forall ((i1@290@03 Int)) (!
    (< i1@290@03 (alen<Int> (opt_get1 $Snap.unit p@15@03)))
    :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) i1@290@03))
    :qid |int-aux|))
  (forall ((r $Ref)) (!
    (implies
      (and (< (inv@292@03 r) V@12@03) (<= 0 (inv@292@03 r)))
      ($FVF.loc_int ($FVF.lookup_int (as sm@293@03  $FVF<Int>) r) r))
    :pattern ((inv@292@03 r))
    ))
  (forall ((r $Ref)) (!
    (implies
      (not
        (=
          (ite
            (and (< (inv@183@03 r) V@12@03) (<= 0 (inv@183@03 r)))
            $Perm.Write
            $Perm.No)
          $Perm.No))
      (ite
        (and (< (inv@183@03 r) V@12@03) (<= 0 (inv@183@03 r)))
        (<
          (ite
            (and (< (inv@292@03 r) V@12@03) (<= 0 (inv@292@03 r)))
            $k@291@03
            $Perm.No)
          $Perm.Write)
        (<
          (ite
            (and (< (inv@292@03 r) V@12@03) (<= 0 (inv@292@03 r)))
            $k@291@03
            $Perm.No)
          $Perm.No)))
    :pattern ((inv@183@03 r))
    :pattern ((inv@292@03 r))
    :qid |qp.srp133|))))
(set-option :timeout 0)
(push) ; 14
(assert (not (valid_graph_vertices ($Snap.combine
  $Snap.unit
  ($Snap.combine
    $Snap.unit
    ($Snap.combine
      $Snap.unit
      ($SortWrappers.$FVF<Int>To$Snap (as sm@296@03  $FVF<Int>))))) this@9@03 p@15@03 V@12@03)))
(check-sat)
; unsat
(pop) ; 14
; 0.93s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1610277
;  :arith-add-rows          441949
;  :arith-assert-diseq      60955
;  :arith-assert-lower      443184
;  :arith-assert-upper      364764
;  :arith-bound-prop        17868
;  :arith-conflicts         1012
;  :arith-eq-adapter        215687
;  :arith-fixed-eqs         288083
;  :arith-offset-eqs        99154
;  :arith-pivots            47248
;  :conflicts               2427
;  :datatype-accessor-ax    635
;  :datatype-constructor-ax 1593
;  :datatype-occurs-check   1309
;  :datatype-splits         1167
;  :decisions               133555
;  :del-clause              2109233
;  :final-checks            177
;  :interface-eqs           41
;  :max-generation          15
;  :max-memory              50.39
;  :memory                  47.56
;  :minimized-lits          315
;  :mk-bool-var             2441410
;  :mk-clause               2110821
;  :num-allocs              8105215
;  :num-checks              366
;  :propagations            893679
;  :quant-instantiations    1055384
;  :restarts                4
;  :rlimit-count            26373199
;  :time                    0.93)
(assert (valid_graph_vertices ($Snap.combine
  $Snap.unit
  ($Snap.combine
    $Snap.unit
    ($Snap.combine
      $Snap.unit
      ($SortWrappers.$FVF<Int>To$Snap (as sm@296@03  $FVF<Int>))))) this@9@03 p@15@03 V@12@03))
; [eval] alen(opt_get1(visited)) == V
; [eval] alen(opt_get1(visited))
; [eval] opt_get1(visited)
(push) ; 14
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 14
; Joined path conditions
; [eval] 0 <= u
; [eval] u < V
; [eval] 0 <= v
(push) ; 14
(assert (not (<= 0 v@270@03)))
(check-sat)
; unsat
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1610290
;  :arith-add-rows          441970
;  :arith-assert-diseq      60955
;  :arith-assert-lower      443184
;  :arith-assert-upper      364765
;  :arith-bound-prop        17868
;  :arith-conflicts         1013
;  :arith-eq-adapter        215687
;  :arith-fixed-eqs         288083
;  :arith-offset-eqs        99154
;  :arith-pivots            47249
;  :conflicts               2428
;  :datatype-accessor-ax    638
;  :datatype-constructor-ax 1593
;  :datatype-occurs-check   1309
;  :datatype-splits         1167
;  :decisions               133555
;  :del-clause              2109233
;  :final-checks            177
;  :interface-eqs           41
;  :max-generation          15
;  :max-memory              50.39
;  :memory                  47.56
;  :minimized-lits          315
;  :mk-bool-var             2441485
;  :mk-clause               2110888
;  :num-allocs              8105629
;  :num-checks              367
;  :propagations            893690
;  :quant-instantiations    1055397
;  :restarts                4
;  :rlimit-count            26374530
;  :time                    0.00)
(assert (<= 0 v@270@03))
; [eval] v <= V
(push) ; 14
(assert (not (<= v@270@03 V@12@03)))
(check-sat)
; unsat
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1610290
;  :arith-add-rows          442009
;  :arith-assert-diseq      60955
;  :arith-assert-lower      443185
;  :arith-assert-upper      364766
;  :arith-bound-prop        17868
;  :arith-conflicts         1014
;  :arith-eq-adapter        215687
;  :arith-fixed-eqs         288083
;  :arith-offset-eqs        99154
;  :arith-pivots            47251
;  :conflicts               2429
;  :datatype-accessor-ax    638
;  :datatype-constructor-ax 1593
;  :datatype-occurs-check   1309
;  :datatype-splits         1167
;  :decisions               133555
;  :del-clause              2109233
;  :final-checks            177
;  :interface-eqs           41
;  :max-generation          15
;  :max-memory              50.39
;  :memory                  47.56
;  :minimized-lits          315
;  :mk-bool-var             2441487
;  :mk-clause               2110888
;  :num-allocs              8105785
;  :num-checks              368
;  :propagations            893690
;  :quant-instantiations    1055397
;  :restarts                4
;  :rlimit-count            26375712)
(assert (<= v@270@03 V@12@03))
; [eval] 0 <= k
; [eval] k < V
; [eval] valid_graph_vertices1(this, queue, V)
(push) ; 14
; [eval] this != null
(pop) ; 14
; Joined path conditions
(declare-const i1@297@03 Int)
(push) ; 14
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 15
; [then-branch: 169 | 0 <= i1@297@03 | live]
; [else-branch: 169 | !(0 <= i1@297@03) | live]
(push) ; 16
; [then-branch: 169 | 0 <= i1@297@03]
(assert (<= 0 i1@297@03))
; [eval] i1 < V
(pop) ; 16
(push) ; 16
; [else-branch: 169 | !(0 <= i1@297@03)]
(assert (not (<= 0 i1@297@03)))
(pop) ; 16
(pop) ; 15
; Joined path conditions
; Joined path conditions
(assert (and (< i1@297@03 V@12@03) (<= 0 i1@297@03)))
; [eval] aloc(opt_get1(visited), i1)
; [eval] opt_get1(visited)
(push) ; 15
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 15
; Joined path conditions
(push) ; 15
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 16
(assert (not (< i1@297@03 (alen<Int> (opt_get1 $Snap.unit res@79@03)))))
(check-sat)
; unsat
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1610290
;  :arith-add-rows          442011
;  :arith-assert-diseq      60955
;  :arith-assert-lower      443188
;  :arith-assert-upper      364766
;  :arith-bound-prop        17868
;  :arith-conflicts         1014
;  :arith-eq-adapter        215687
;  :arith-fixed-eqs         288083
;  :arith-offset-eqs        99154
;  :arith-pivots            47251
;  :conflicts               2429
;  :datatype-accessor-ax    638
;  :datatype-constructor-ax 1593
;  :datatype-occurs-check   1309
;  :datatype-splits         1167
;  :decisions               133555
;  :del-clause              2109233
;  :final-checks            177
;  :interface-eqs           41
;  :max-generation          15
;  :max-memory              50.39
;  :memory                  47.57
;  :minimized-lits          315
;  :mk-bool-var             2441490
;  :mk-clause               2110888
;  :num-allocs              8105965
;  :num-checks              369
;  :propagations            893690
;  :quant-instantiations    1055397
;  :restarts                4
;  :rlimit-count            26375960)
(assert (< i1@297@03 (alen<Int> (opt_get1 $Snap.unit res@79@03))))
(pop) ; 15
; Joined path conditions
(assert (< i1@297@03 (alen<Int> (opt_get1 $Snap.unit res@79@03))))
(pop) ; 14
(declare-fun inv@298@03 ($Ref) Int)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(assert (forall ((i1@297@03 Int)) (!
  (< i1@297@03 (alen<Int> (opt_get1 $Snap.unit res@79@03)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@79@03) i1@297@03))
  :qid |bool-aux|)))
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 14
(assert (not (forall ((i11@297@03 Int) (i12@297@03 Int)) (!
  (implies
    (and
      (and
        (and (< i11@297@03 V@12@03) (<= 0 i11@297@03))
        ($FVF.loc_bool ($FVF.lookup_bool (as sm@193@03  $FVF<Bool>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@79@03) i11@297@03)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@79@03) i11@297@03)))
      (and
        (and (< i12@297@03 V@12@03) (<= 0 i12@297@03))
        ($FVF.loc_bool ($FVF.lookup_bool (as sm@193@03  $FVF<Bool>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@79@03) i12@297@03)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@79@03) i12@297@03)))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@79@03) i11@297@03)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@79@03) i12@297@03)))
    (= i11@297@03 i12@297@03))
  
  :qid |bool-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1610309
;  :arith-add-rows          442016
;  :arith-assert-diseq      60956
;  :arith-assert-lower      443192
;  :arith-assert-upper      364766
;  :arith-bound-prop        17868
;  :arith-conflicts         1014
;  :arith-eq-adapter        215688
;  :arith-fixed-eqs         288083
;  :arith-offset-eqs        99154
;  :arith-pivots            47251
;  :conflicts               2430
;  :datatype-accessor-ax    638
;  :datatype-constructor-ax 1593
;  :datatype-occurs-check   1309
;  :datatype-splits         1167
;  :decisions               133555
;  :del-clause              2109244
;  :final-checks            177
;  :interface-eqs           41
;  :max-generation          15
;  :max-memory              50.39
;  :memory                  47.47
;  :minimized-lits          315
;  :mk-bool-var             2441527
;  :mk-clause               2110899
;  :num-allocs              8106564
;  :num-checks              370
;  :propagations            893690
;  :quant-instantiations    1055432
;  :restarts                4
;  :rlimit-count            26377348)
; Definitional axioms for inverse functions
(assert (forall ((i1@297@03 Int)) (!
  (implies
    (and (< i1@297@03 V@12@03) (<= 0 i1@297@03))
    (=
      (inv@298@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@79@03) i1@297@03))
      i1@297@03))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@79@03) i1@297@03))
  :qid |bool-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@298@03 r) V@12@03) (<= 0 (inv@298@03 r)))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@79@03) (inv@298@03 r))
      r))
  :pattern ((inv@298@03 r))
  :qid |bool-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@298@03 r) V@12@03) (<= 0 (inv@298@03 r)))
    ($FVF.loc_bool ($FVF.lookup_bool (as sm@193@03  $FVF<Bool>) r) r))
  :pattern ((inv@298@03 r))
  )))
; Precomputing data for removing quantified permissions
(define-fun pTaken@299@03 ((r $Ref)) $Perm
  (ite
    (and (< (inv@298@03 r) V@12@03) (<= 0 (inv@298@03 r)))
    ($Perm.min
      (ite
        (and (< (inv@192@03 r) V@12@03) (<= 0 (inv@192@03 r)))
        $Perm.Write
        $Perm.No)
      $Perm.Write)
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 500)
(push) ; 14
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and (< (inv@192@03 r) V@12@03) (<= 0 (inv@192@03 r)))
        $Perm.Write
        $Perm.No)
      (pTaken@299@03 r))
    $Perm.No)
  
  ))))
(check-sat)
; unsat
(pop) ; 14
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1612172
;  :arith-add-rows          442452
;  :arith-assert-diseq      60998
;  :arith-assert-lower      443550
;  :arith-assert-upper      364980
;  :arith-bound-prop        17887
;  :arith-conflicts         1017
;  :arith-eq-adapter        215960
;  :arith-fixed-eqs         288316
;  :arith-offset-eqs        99403
;  :arith-pivots            47325
;  :conflicts               2451
;  :datatype-accessor-ax    638
;  :datatype-constructor-ax 1601
;  :datatype-occurs-check   1309
;  :datatype-splits         1167
;  :decisions               133659
;  :del-clause              2112055
;  :final-checks            177
;  :interface-eqs           41
;  :max-generation          15
;  :max-memory              50.39
;  :memory                  47.31
;  :minimized-lits          316
;  :mk-bool-var             2444657
;  :mk-clause               2113696
;  :num-allocs              8117347
;  :num-checks              372
;  :propagations            894720
;  :quant-instantiations    1056612
;  :restarts                4
;  :rlimit-count            26424997
;  :time                    0.01)
; Intermediate check if already taken enough permissions
(push) ; 14
(assert (not (forall ((r $Ref)) (!
  (implies
    (and (< (inv@298@03 r) V@12@03) (<= 0 (inv@298@03 r)))
    (= (- $Perm.Write (pTaken@299@03 r)) $Perm.No))
  
  ))))
(check-sat)
; unsat
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1612204
;  :arith-add-rows          442473
;  :arith-assert-diseq      61000
;  :arith-assert-lower      443559
;  :arith-assert-upper      364990
;  :arith-bound-prop        17888
;  :arith-conflicts         1018
;  :arith-eq-adapter        215969
;  :arith-fixed-eqs         288322
;  :arith-offset-eqs        99403
;  :arith-pivots            47329
;  :conflicts               2452
;  :datatype-accessor-ax    638
;  :datatype-constructor-ax 1601
;  :datatype-occurs-check   1309
;  :datatype-splits         1167
;  :decisions               133659
;  :del-clause              2112094
;  :final-checks            177
;  :interface-eqs           41
;  :max-generation          15
;  :max-memory              50.39
;  :memory                  47.31
;  :minimized-lits          316
;  :mk-bool-var             2444735
;  :mk-clause               2113735
;  :num-allocs              8117884
;  :num-checks              373
;  :propagations            894725
;  :quant-instantiations    1056641
;  :restarts                4
;  :rlimit-count            26426737
;  :time                    0.00)
; Final check if taken enough permissions
; Done removing quantified permissions
; Definitional axioms for snapshot map values
(pop) ; 13
(push) ; 13
; [else-branch: 153 | 0 < Lookup(int,sm@268@03,aloc((_, _), opt_get1(_, Lookup(option$array$,sm@172@03,aloc((_, _), opt_get1(_, Gf@11@03), u@161@03))), v@166@03)) && !(Lookup(bool,sm@193@03,aloc((_, _), opt_get1(_, res@79@03), v@166@03)))]
(assert (and
  (<
    0
    ($FVF.lookup_int (as sm@268@03  $FVF<Int>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@172@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) u@161@03))) v@166@03)))
  (not
    ($FVF.lookup_bool (as sm@193@03  $FVF<Bool>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@79@03) v@166@03)))))
(pop) ; 13
(pop) ; 12
(push) ; 12
; [else-branch: 133 | !(v@166@03 < V@12@03)]
(assert (not (< v@166@03 V@12@03)))
(pop) ; 12
; [eval] !(v < V)
; [eval] v < V
(set-option :timeout 10)
(push) ; 12
(assert (not (< v@166@03 V@12@03)))
(check-sat)
; unknown
(pop) ; 12
; 0.02s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1612975
;  :arith-add-rows          442598
;  :arith-assert-diseq      61015
;  :arith-assert-lower      443705
;  :arith-assert-upper      365075
;  :arith-bound-prop        17932
;  :arith-conflicts         1018
;  :arith-eq-adapter        216080
;  :arith-fixed-eqs         288421
;  :arith-offset-eqs        99516
;  :arith-pivots            47357
;  :conflicts               2452
;  :datatype-accessor-ax    638
;  :datatype-constructor-ax 1605
;  :datatype-occurs-check   1309
;  :datatype-splits         1167
;  :decisions               133690
;  :del-clause              2113328
;  :final-checks            177
;  :interface-eqs           41
;  :max-generation          15
;  :max-memory              50.39
;  :memory                  44.86
;  :minimized-lits          316
;  :mk-bool-var             2445807
;  :mk-clause               2114764
;  :num-allocs              8121447
;  :num-checks              374
;  :propagations            895094
;  :quant-instantiations    1057100
;  :restarts                4
;  :rlimit-count            26445086
;  :time                    0.02)
(push) ; 12
(assert (not (not (< v@166@03 V@12@03))))
(check-sat)
; unknown
(pop) ; 12
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1613890
;  :arith-add-rows          442711
;  :arith-assert-diseq      61032
;  :arith-assert-lower      443899
;  :arith-assert-upper      365190
;  :arith-bound-prop        17984
;  :arith-conflicts         1018
;  :arith-eq-adapter        216205
;  :arith-fixed-eqs         288557
;  :arith-offset-eqs        99647
;  :arith-pivots            47375
;  :conflicts               2452
;  :datatype-accessor-ax    638
;  :datatype-constructor-ax 1609
;  :datatype-occurs-check   1309
;  :datatype-splits         1167
;  :decisions               133722
;  :del-clause              2114439
;  :final-checks            177
;  :interface-eqs           41
;  :max-generation          15
;  :max-memory              50.39
;  :memory                  44.86
;  :minimized-lits          316
;  :mk-bool-var             2447008
;  :mk-clause               2115875
;  :num-allocs              8125867
;  :num-checks              375
;  :propagations            895596
;  :quant-instantiations    1057607
;  :restarts                4
;  :rlimit-count            26469532
;  :time                    0.01)
; [then-branch: 170 | !(v@166@03 < V@12@03) | live]
; [else-branch: 170 | v@166@03 < V@12@03 | live]
(push) ; 12
; [then-branch: 170 | !(v@166@03 < V@12@03)]
(assert (not (< v@166@03 V@12@03)))
; Loop head block: Re-establish invariant
; [eval] exc == excBeforeLoop
; [eval] Gf != (None(): option[array])
; [eval] (None(): option[array])
; [eval] alen(opt_get1(Gf)) == V
; [eval] alen(opt_get1(Gf))
; [eval] opt_get1(Gf)
(push) ; 13
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 13
; Joined path conditions
(declare-const i1@300@03 Int)
(push) ; 13
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 14
; [then-branch: 171 | 0 <= i1@300@03 | live]
; [else-branch: 171 | !(0 <= i1@300@03) | live]
(push) ; 15
; [then-branch: 171 | 0 <= i1@300@03]
(assert (<= 0 i1@300@03))
; [eval] i1 < V
(pop) ; 15
(push) ; 15
; [else-branch: 171 | !(0 <= i1@300@03)]
(assert (not (<= 0 i1@300@03)))
(pop) ; 15
(pop) ; 14
; Joined path conditions
; Joined path conditions
(assert (and (< i1@300@03 V@12@03) (<= 0 i1@300@03)))
(declare-const $k@301@03 $Perm)
(assert ($Perm.isReadVar $k@301@03 $Perm.Write))
; [eval] aloc(opt_get1(Gf), i1)
; [eval] opt_get1(Gf)
(push) ; 14
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 14
; Joined path conditions
(push) ; 14
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 15
(assert (not (< i1@300@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))))
(check-sat)
; unsat
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1613891
;  :arith-add-rows          442712
;  :arith-assert-diseq      61033
;  :arith-assert-lower      443903
;  :arith-assert-upper      365192
;  :arith-bound-prop        17984
;  :arith-conflicts         1018
;  :arith-eq-adapter        216206
;  :arith-fixed-eqs         288558
;  :arith-offset-eqs        99647
;  :arith-pivots            47375
;  :conflicts               2452
;  :datatype-accessor-ax    638
;  :datatype-constructor-ax 1609
;  :datatype-occurs-check   1309
;  :datatype-splits         1167
;  :decisions               133722
;  :del-clause              2114439
;  :final-checks            177
;  :interface-eqs           41
;  :max-generation          15
;  :max-memory              50.39
;  :memory                  44.86
;  :minimized-lits          316
;  :mk-bool-var             2447015
;  :mk-clause               2115877
;  :num-allocs              8126112
;  :num-checks              376
;  :propagations            895597
;  :quant-instantiations    1057607
;  :restarts                4
;  :rlimit-count            26469927)
(assert (< i1@300@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03))))
(pop) ; 14
; Joined path conditions
(assert (< i1@300@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03))))
(pop) ; 13
(declare-fun inv@302@03 ($Ref) Int)
; Nested auxiliary terms: globals
(assert ($Perm.isReadVar $k@301@03 $Perm.Write))
; Nested auxiliary terms: non-globals
(assert (forall ((i1@300@03 Int)) (!
  (< i1@300@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@300@03))
  :qid |option$array$-aux|)))
(push) ; 13
(assert (not (forall ((i1@300@03 Int)) (!
  (implies
    (and (< i1@300@03 V@12@03) (<= 0 i1@300@03))
    (or (= $k@301@03 $Perm.No) (< $Perm.No $k@301@03)))
  
  ))))
(check-sat)
; unsat
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1613891
;  :arith-add-rows          442713
;  :arith-assert-diseq      61034
;  :arith-assert-lower      443905
;  :arith-assert-upper      365193
;  :arith-bound-prop        17984
;  :arith-conflicts         1018
;  :arith-eq-adapter        216207
;  :arith-fixed-eqs         288558
;  :arith-offset-eqs        99647
;  :arith-pivots            47375
;  :conflicts               2453
;  :datatype-accessor-ax    638
;  :datatype-constructor-ax 1609
;  :datatype-occurs-check   1309
;  :datatype-splits         1167
;  :decisions               133722
;  :del-clause              2114441
;  :final-checks            177
;  :interface-eqs           41
;  :max-generation          15
;  :max-memory              50.39
;  :memory                  44.86
;  :minimized-lits          316
;  :mk-bool-var             2447022
;  :mk-clause               2115879
;  :num-allocs              8126542
;  :num-checks              377
;  :propagations            895598
;  :quant-instantiations    1057607
;  :restarts                4
;  :rlimit-count            26470474)
(declare-const sm@303@03 $FVF<option<array>>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (ite
          (and (< (inv@108@03 r) V@12@03) (<= 0 (inv@108@03 r)))
          $k@107@03
          $Perm.No)
        (pTaken@197@03 r)))
    (=
      ($FVF.lookup_option$array$ (as sm@303@03  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@105@03))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@303@03  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@105@03))))) r))
  :qid |qp.fvfValDef138|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@171@03 r) V@12@03) (<= 0 (inv@171@03 r)))
      (< $Perm.No $k@170@03)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@303@03  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@168@03))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@303@03  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@168@03))))) r))
  :qid |qp.fvfValDef139|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@105@03))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@168@03))))) r) r))
  :pattern (($FVF.lookup_option$array$ (as sm@303@03  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef140|)))
; Check receiver injectivity
(push) ; 13
(assert (not (forall ((i11@300@03 Int) (i12@300@03 Int)) (!
  (implies
    (and
      (and
        (and
          (and (< i11@300@03 V@12@03) (<= 0 i11@300@03))
          ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@303@03  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i11@300@03)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i11@300@03)))
        (< $Perm.No $k@301@03))
      (and
        (and
          (and (< i12@300@03 V@12@03) (<= 0 i12@300@03))
          ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@303@03  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i12@300@03)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i12@300@03)))
        (< $Perm.No $k@301@03))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i11@300@03)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i12@300@03)))
    (= i11@300@03 i12@300@03))
  
  :qid |option$array$-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1613908
;  :arith-add-rows          442720
;  :arith-assert-diseq      61035
;  :arith-assert-lower      443909
;  :arith-assert-upper      365193
;  :arith-bound-prop        17984
;  :arith-conflicts         1018
;  :arith-eq-adapter        216208
;  :arith-fixed-eqs         288558
;  :arith-offset-eqs        99647
;  :arith-pivots            47375
;  :conflicts               2454
;  :datatype-accessor-ax    638
;  :datatype-constructor-ax 1609
;  :datatype-occurs-check   1309
;  :datatype-splits         1167
;  :decisions               133722
;  :del-clause              2114464
;  :final-checks            177
;  :interface-eqs           41
;  :max-generation          15
;  :max-memory              50.39
;  :memory                  44.87
;  :minimized-lits          316
;  :mk-bool-var             2447073
;  :mk-clause               2115902
;  :num-allocs              8127589
;  :num-checks              378
;  :propagations            895600
;  :quant-instantiations    1057637
;  :restarts                4
;  :rlimit-count            26473226
;  :time                    0.00)
; Definitional axioms for inverse functions
(assert (forall ((i1@300@03 Int)) (!
  (implies
    (and (and (< i1@300@03 V@12@03) (<= 0 i1@300@03)) (< $Perm.No $k@301@03))
    (=
      (inv@302@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@300@03))
      i1@300@03))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@300@03))
  :qid |option$array$-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and (< (inv@302@03 r) V@12@03) (<= 0 (inv@302@03 r)))
      (< $Perm.No $k@301@03))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) (inv@302@03 r))
      r))
  :pattern ((inv@302@03 r))
  :qid |option$array$-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@302@03 r) V@12@03) (<= 0 (inv@302@03 r)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@303@03  $FVF<option<array>>) r) r))
  :pattern ((inv@302@03 r))
  )))
; Precomputing data for removing quantified permissions
(define-fun pTaken@304@03 ((r $Ref)) $Perm
  (ite
    (and (< (inv@302@03 r) V@12@03) (<= 0 (inv@302@03 r)))
    ($Perm.min
      (-
        (ite
          (and (< (inv@108@03 r) V@12@03) (<= 0 (inv@108@03 r)))
          $k@107@03
          $Perm.No)
        (pTaken@197@03 r))
      $k@301@03)
    $Perm.No))
(define-fun pTaken@305@03 ((r $Ref)) $Perm
  (ite
    (and (< (inv@302@03 r) V@12@03) (<= 0 (inv@302@03 r)))
    ($Perm.min
      (ite
        (and (< (inv@171@03 r) V@12@03) (<= 0 (inv@171@03 r)))
        $k@170@03
        $Perm.No)
      (- $k@301@03 (pTaken@304@03 r)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Constrain original permissions $k@301@03
(assert (forall ((r $Ref)) (!
  (implies
    (not
      (=
        (-
          (ite
            (and (< (inv@108@03 r) V@12@03) (<= 0 (inv@108@03 r)))
            $k@107@03
            $Perm.No)
          (pTaken@197@03 r))
        $Perm.No))
    (<
      (ite
        (and (< (inv@302@03 r) V@12@03) (<= 0 (inv@302@03 r)))
        $k@301@03
        $Perm.No)
      (-
        (ite
          (and (< (inv@108@03 r) V@12@03) (<= 0 (inv@108@03 r)))
          $k@107@03
          $Perm.No)
        (pTaken@197@03 r))))
  :pattern ((inv@108@03 r))
  :pattern ((inv@302@03 r))
  :qid |qp.srp141|)))
; Intermediate check if already taken enough permissions
(set-option :timeout 500)
(push) ; 13
(assert (not (forall ((r $Ref)) (!
  (implies
    (and (< (inv@302@03 r) V@12@03) (<= 0 (inv@302@03 r)))
    (= (- $k@301@03 (pTaken@304@03 r)) $Perm.No))
  
  ))))
(check-sat)
; unsat
(pop) ; 13
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1615498
;  :arith-add-rows          443066
;  :arith-assert-diseq      61077
;  :arith-assert-lower      444231
;  :arith-assert-upper      365375
;  :arith-bound-prop        18049
;  :arith-conflicts         1022
;  :arith-eq-adapter        216464
;  :arith-fixed-eqs         288764
;  :arith-offset-eqs        99886
;  :arith-pivots            47426
;  :conflicts               2476
;  :datatype-accessor-ax    638
;  :datatype-constructor-ax 1617
;  :datatype-occurs-check   1309
;  :datatype-splits         1167
;  :decisions               133786
;  :del-clause              2116655
;  :final-checks            177
;  :interface-eqs           41
;  :max-generation          15
;  :max-memory              50.39
;  :memory                  44.94
;  :minimized-lits          318
;  :mk-bool-var             2449524
;  :mk-clause               2118144
;  :num-allocs              8137403
;  :num-checks              380
;  :propagations            896437
;  :quant-instantiations    1058571
;  :restarts                4
;  :rlimit-count            26520338
;  :time                    0.01)
; Final check if taken enough permissions
; Done removing quantified permissions
; Definitional axioms for snapshot map values
; [eval] (forall i1: Int :: { aloc(opt_get1(Gf), i1) } 0 <= i1 && i1 < V ==> aloc(opt_get1(Gf), i1).option$array$ != (None(): option[array]))
(declare-const i1@306@03 Int)
(push) ; 13
; [eval] 0 <= i1 && i1 < V ==> aloc(opt_get1(Gf), i1).option$array$ != (None(): option[array])
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 14
; [then-branch: 172 | 0 <= i1@306@03 | live]
; [else-branch: 172 | !(0 <= i1@306@03) | live]
(push) ; 15
; [then-branch: 172 | 0 <= i1@306@03]
(assert (<= 0 i1@306@03))
; [eval] i1 < V
(pop) ; 15
(push) ; 15
; [else-branch: 172 | !(0 <= i1@306@03)]
(assert (not (<= 0 i1@306@03)))
(pop) ; 15
(pop) ; 14
; Joined path conditions
; Joined path conditions
(push) ; 14
; [then-branch: 173 | i1@306@03 < V@12@03 && 0 <= i1@306@03 | live]
; [else-branch: 173 | !(i1@306@03 < V@12@03 && 0 <= i1@306@03) | live]
(push) ; 15
; [then-branch: 173 | i1@306@03 < V@12@03 && 0 <= i1@306@03]
(assert (and (< i1@306@03 V@12@03) (<= 0 i1@306@03)))
; [eval] aloc(opt_get1(Gf), i1).option$array$ != (None(): option[array])
; [eval] aloc(opt_get1(Gf), i1)
; [eval] opt_get1(Gf)
(push) ; 16
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 16
; Joined path conditions
(push) ; 16
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 17
(assert (not (< i1@306@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))))
(check-sat)
; unsat
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1615498
;  :arith-add-rows          443067
;  :arith-assert-diseq      61077
;  :arith-assert-lower      444233
;  :arith-assert-upper      365375
;  :arith-bound-prop        18049
;  :arith-conflicts         1022
;  :arith-eq-adapter        216464
;  :arith-fixed-eqs         288764
;  :arith-offset-eqs        99886
;  :arith-pivots            47426
;  :conflicts               2476
;  :datatype-accessor-ax    638
;  :datatype-constructor-ax 1617
;  :datatype-occurs-check   1309
;  :datatype-splits         1167
;  :decisions               133786
;  :del-clause              2116655
;  :final-checks            177
;  :interface-eqs           41
;  :max-generation          15
;  :max-memory              50.39
;  :memory                  44.94
;  :minimized-lits          318
;  :mk-bool-var             2449526
;  :mk-clause               2118144
;  :num-allocs              8137513
;  :num-checks              381
;  :propagations            896437
;  :quant-instantiations    1058571
;  :restarts                4
;  :rlimit-count            26520529)
(assert (< i1@306@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03))))
(pop) ; 16
; Joined path conditions
(assert (< i1@306@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@303@03  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@306@03)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@306@03)))
(push) ; 16
(assert (not (<
  $Perm.No
  (+
    (-
      (ite
        (and
          (<
            (inv@108@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@306@03))
            V@12@03)
          (<=
            0
            (inv@108@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@306@03))))
        $k@107@03
        $Perm.No)
      (pTaken@197@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@306@03)))
    (ite
      (and
        (<
          (inv@171@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@306@03))
          V@12@03)
        (<=
          0
          (inv@171@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@306@03))))
      $k@170@03
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 16
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1616316
;  :arith-add-rows          443252
;  :arith-assert-diseq      61096
;  :arith-assert-lower      444396
;  :arith-assert-upper      365469
;  :arith-bound-prop        18071
;  :arith-conflicts         1025
;  :arith-eq-adapter        216584
;  :arith-fixed-eqs         288871
;  :arith-offset-eqs        100017
;  :arith-pivots            47455
;  :conflicts               2495
;  :datatype-accessor-ax    638
;  :datatype-constructor-ax 1621
;  :datatype-occurs-check   1309
;  :datatype-splits         1167
;  :decisions               133814
;  :del-clause              2117670
;  :final-checks            177
;  :interface-eqs           41
;  :max-generation          15
;  :max-memory              50.39
;  :memory                  44.96
;  :minimized-lits          318
;  :mk-bool-var             2450822
;  :mk-clause               2119272
;  :num-allocs              8142096
;  :num-checks              382
;  :propagations            896861
;  :quant-instantiations    1059053
;  :restarts                4
;  :rlimit-count            26541659
;  :time                    0.01)
; [eval] (None(): option[array])
(pop) ; 15
(push) ; 15
; [else-branch: 173 | !(i1@306@03 < V@12@03 && 0 <= i1@306@03)]
(assert (not (and (< i1@306@03 V@12@03) (<= 0 i1@306@03))))
(pop) ; 15
(pop) ; 14
; Joined path conditions
(assert (implies
  (and (< i1@306@03 V@12@03) (<= 0 i1@306@03))
  (and
    (< i1@306@03 V@12@03)
    (<= 0 i1@306@03)
    (< i1@306@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@303@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@306@03)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@306@03)))))
; Joined path conditions
(pop) ; 13
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@306@03 Int)) (!
  (implies
    (and (< i1@306@03 V@12@03) (<= 0 i1@306@03))
    (and
      (< i1@306@03 V@12@03)
      (<= 0 i1@306@03)
      (< i1@306@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@303@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@306@03)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@306@03))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@306@03))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(push) ; 13
(assert (not (forall ((i1@306@03 Int)) (!
  (implies
    (and (< i1@306@03 V@12@03) (<= 0 i1@306@03))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@303@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@306@03))
        (as None<option<array>>  option<array>))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@306@03))
  :qid |prog.l<no position>|))))
(check-sat)
; unsat
(pop) ; 13
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1617107
;  :arith-add-rows          443424
;  :arith-assert-diseq      61111
;  :arith-assert-lower      444546
;  :arith-assert-upper      365557
;  :arith-bound-prop        18089
;  :arith-conflicts         1026
;  :arith-eq-adapter        216697
;  :arith-fixed-eqs         288974
;  :arith-offset-eqs        100148
;  :arith-pivots            47501
;  :conflicts               2513
;  :datatype-accessor-ax    638
;  :datatype-constructor-ax 1625
;  :datatype-occurs-check   1309
;  :datatype-splits         1167
;  :decisions               133841
;  :del-clause              2118880
;  :final-checks            177
;  :interface-eqs           41
;  :max-generation          15
;  :max-memory              50.39
;  :memory                  45.02
;  :minimized-lits          318
;  :mk-bool-var             2452010
;  :mk-clause               2120369
;  :num-allocs              8146473
;  :num-checks              383
;  :propagations            897292
;  :quant-instantiations    1059537
;  :restarts                4
;  :rlimit-count            26563791
;  :time                    0.01)
(assert (forall ((i1@306@03 Int)) (!
  (implies
    (and (< i1@306@03 V@12@03) (<= 0 i1@306@03))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@303@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@306@03))
        (as None<option<array>>  option<array>))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@306@03))
  :qid |prog.l<no position>|)))
; [eval] (forall i1: Int :: { alen(opt_get1(aloc(opt_get1(Gf), i1).option$array$)) } 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(Gf), i1).option$array$)) == V)
(declare-const i1@307@03 Int)
(push) ; 13
; [eval] 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(Gf), i1).option$array$)) == V
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 14
; [then-branch: 174 | 0 <= i1@307@03 | live]
; [else-branch: 174 | !(0 <= i1@307@03) | live]
(push) ; 15
; [then-branch: 174 | 0 <= i1@307@03]
(assert (<= 0 i1@307@03))
; [eval] i1 < V
(pop) ; 15
(push) ; 15
; [else-branch: 174 | !(0 <= i1@307@03)]
(assert (not (<= 0 i1@307@03)))
(pop) ; 15
(pop) ; 14
; Joined path conditions
; Joined path conditions
(push) ; 14
; [then-branch: 175 | i1@307@03 < V@12@03 && 0 <= i1@307@03 | live]
; [else-branch: 175 | !(i1@307@03 < V@12@03 && 0 <= i1@307@03) | live]
(push) ; 15
; [then-branch: 175 | i1@307@03 < V@12@03 && 0 <= i1@307@03]
(assert (and (< i1@307@03 V@12@03) (<= 0 i1@307@03)))
; [eval] alen(opt_get1(aloc(opt_get1(Gf), i1).option$array$)) == V
; [eval] alen(opt_get1(aloc(opt_get1(Gf), i1).option$array$))
; [eval] opt_get1(aloc(opt_get1(Gf), i1).option$array$)
; [eval] aloc(opt_get1(Gf), i1)
; [eval] opt_get1(Gf)
(push) ; 16
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 16
; Joined path conditions
(push) ; 16
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 17
(assert (not (< i1@307@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))))
(check-sat)
; unsat
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1617107
;  :arith-add-rows          443425
;  :arith-assert-diseq      61111
;  :arith-assert-lower      444548
;  :arith-assert-upper      365557
;  :arith-bound-prop        18089
;  :arith-conflicts         1026
;  :arith-eq-adapter        216697
;  :arith-fixed-eqs         288974
;  :arith-offset-eqs        100148
;  :arith-pivots            47501
;  :conflicts               2513
;  :datatype-accessor-ax    638
;  :datatype-constructor-ax 1625
;  :datatype-occurs-check   1309
;  :datatype-splits         1167
;  :decisions               133841
;  :del-clause              2118880
;  :final-checks            177
;  :interface-eqs           41
;  :max-generation          15
;  :max-memory              50.39
;  :memory                  45.02
;  :minimized-lits          318
;  :mk-bool-var             2452013
;  :mk-clause               2120369
;  :num-allocs              8146769
;  :num-checks              384
;  :propagations            897292
;  :quant-instantiations    1059537
;  :restarts                4
;  :rlimit-count            26564291)
(assert (< i1@307@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03))))
(pop) ; 16
; Joined path conditions
(assert (< i1@307@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@303@03  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@307@03)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@307@03)))
(push) ; 16
(assert (not (<
  $Perm.No
  (+
    (-
      (ite
        (and
          (<
            (inv@108@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@307@03))
            V@12@03)
          (<=
            0
            (inv@108@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@307@03))))
        $k@107@03
        $Perm.No)
      (pTaken@197@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@307@03)))
    (ite
      (and
        (<
          (inv@171@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@307@03))
          V@12@03)
        (<=
          0
          (inv@171@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@307@03))))
      $k@170@03
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 16
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1617929
;  :arith-add-rows          443584
;  :arith-assert-diseq      61130
;  :arith-assert-lower      444712
;  :arith-assert-upper      365650
;  :arith-bound-prop        18112
;  :arith-conflicts         1029
;  :arith-eq-adapter        216817
;  :arith-fixed-eqs         289081
;  :arith-offset-eqs        100279
;  :arith-pivots            47526
;  :conflicts               2532
;  :datatype-accessor-ax    638
;  :datatype-constructor-ax 1629
;  :datatype-occurs-check   1309
;  :datatype-splits         1167
;  :decisions               133869
;  :del-clause              2119895
;  :final-checks            177
;  :interface-eqs           41
;  :max-generation          15
;  :max-memory              50.39
;  :memory                  45.04
;  :minimized-lits          318
;  :mk-bool-var             2453314
;  :mk-clause               2121497
;  :num-allocs              8151366
;  :num-checks              385
;  :propagations            897716
;  :quant-instantiations    1060021
;  :restarts                4
;  :rlimit-count            26585147
;  :time                    0.01)
(push) ; 16
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 17
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@303@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@307@03))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1617929
;  :arith-add-rows          443584
;  :arith-assert-diseq      61130
;  :arith-assert-lower      444712
;  :arith-assert-upper      365650
;  :arith-bound-prop        18112
;  :arith-conflicts         1029
;  :arith-eq-adapter        216817
;  :arith-fixed-eqs         289081
;  :arith-offset-eqs        100279
;  :arith-pivots            47526
;  :conflicts               2533
;  :datatype-accessor-ax    638
;  :datatype-constructor-ax 1629
;  :datatype-occurs-check   1309
;  :datatype-splits         1167
;  :decisions               133869
;  :del-clause              2119895
;  :final-checks            177
;  :interface-eqs           41
;  :max-generation          15
;  :max-memory              50.39
;  :memory                  45.04
;  :minimized-lits          318
;  :mk-bool-var             2453314
;  :mk-clause               2121497
;  :num-allocs              8151457
;  :num-checks              386
;  :propagations            897716
;  :quant-instantiations    1060021
;  :restarts                4
;  :rlimit-count            26585242)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@303@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@307@03))
    (as None<option<array>>  option<array>))))
(pop) ; 16
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@303@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@307@03))
    (as None<option<array>>  option<array>))))
(pop) ; 15
(push) ; 15
; [else-branch: 175 | !(i1@307@03 < V@12@03 && 0 <= i1@307@03)]
(assert (not (and (< i1@307@03 V@12@03) (<= 0 i1@307@03))))
(pop) ; 15
(pop) ; 14
; Joined path conditions
(assert (implies
  (and (< i1@307@03 V@12@03) (<= 0 i1@307@03))
  (and
    (< i1@307@03 V@12@03)
    (<= 0 i1@307@03)
    (< i1@307@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@303@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@307@03)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@307@03))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@303@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@307@03))
        (as None<option<array>>  option<array>))))))
; Joined path conditions
(pop) ; 13
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@307@03 Int)) (!
  (implies
    (and (< i1@307@03 V@12@03) (<= 0 i1@307@03))
    (and
      (< i1@307@03 V@12@03)
      (<= 0 i1@307@03)
      (< i1@307@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@303@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@307@03)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@307@03))
      (not
        (=
          ($FVF.lookup_option$array$ (as sm@303@03  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@307@03))
          (as None<option<array>>  option<array>)))))
  :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@303@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@307@03)))))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(push) ; 13
(assert (not (forall ((i1@307@03 Int)) (!
  (implies
    (and (< i1@307@03 V@12@03) (<= 0 i1@307@03))
    (=
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@303@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@307@03))))
      V@12@03))
  :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@303@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@307@03)))))
  :qid |prog.l<no position>|))))
(check-sat)
; unsat
(pop) ; 13
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1618769
;  :arith-add-rows          443734
;  :arith-assert-diseq      61147
;  :arith-assert-lower      444868
;  :arith-assert-upper      365738
;  :arith-bound-prop        18130
;  :arith-conflicts         1030
;  :arith-eq-adapter        216931
;  :arith-fixed-eqs         289184
;  :arith-offset-eqs        100414
;  :arith-pivots            47565
;  :conflicts               2551
;  :datatype-accessor-ax    638
;  :datatype-constructor-ax 1633
;  :datatype-occurs-check   1309
;  :datatype-splits         1167
;  :decisions               133897
;  :del-clause              2121110
;  :final-checks            177
;  :interface-eqs           41
;  :max-generation          15
;  :max-memory              50.39
;  :memory                  45.02
;  :minimized-lits          318
;  :mk-bool-var             2454516
;  :mk-clause               2122599
;  :num-allocs              8155908
;  :num-checks              387
;  :propagations            898178
;  :quant-instantiations    1060518
;  :restarts                4
;  :rlimit-count            26607235
;  :time                    0.01)
(assert (forall ((i1@307@03 Int)) (!
  (implies
    (and (< i1@307@03 V@12@03) (<= 0 i1@307@03))
    (=
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@303@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@307@03))))
      V@12@03))
  :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@303@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@307@03)))))
  :qid |prog.l<no position>|)))
; [eval] (forall i1: Int :: { aloc(opt_get1(Gf), i1) } (forall i2: Int :: { aloc(opt_get1(Gf), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(Gf), i1).option$array$ == aloc(opt_get1(Gf), i2).option$array$ ==> i1 == i2))
(declare-const i1@308@03 Int)
(push) ; 13
; [eval] (forall i2: Int :: { aloc(opt_get1(Gf), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(Gf), i1).option$array$ == aloc(opt_get1(Gf), i2).option$array$ ==> i1 == i2)
(declare-const i2@309@03 Int)
(push) ; 14
; [eval] 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(Gf), i1).option$array$ == aloc(opt_get1(Gf), i2).option$array$ ==> i1 == i2
; [eval] 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(Gf), i1).option$array$ == aloc(opt_get1(Gf), i2).option$array$
; [eval] 0 <= i1
(push) ; 15
; [then-branch: 176 | 0 <= i1@308@03 | live]
; [else-branch: 176 | !(0 <= i1@308@03) | live]
(push) ; 16
; [then-branch: 176 | 0 <= i1@308@03]
(assert (<= 0 i1@308@03))
; [eval] i1 < V
(push) ; 17
; [then-branch: 177 | i1@308@03 < V@12@03 | live]
; [else-branch: 177 | !(i1@308@03 < V@12@03) | live]
(push) ; 18
; [then-branch: 177 | i1@308@03 < V@12@03]
(assert (< i1@308@03 V@12@03))
; [eval] 0 <= i2
(push) ; 19
; [then-branch: 178 | 0 <= i2@309@03 | live]
; [else-branch: 178 | !(0 <= i2@309@03) | live]
(push) ; 20
; [then-branch: 178 | 0 <= i2@309@03]
(assert (<= 0 i2@309@03))
; [eval] i2 < V
(push) ; 21
; [then-branch: 179 | i2@309@03 < V@12@03 | live]
; [else-branch: 179 | !(i2@309@03 < V@12@03) | live]
(push) ; 22
; [then-branch: 179 | i2@309@03 < V@12@03]
(assert (< i2@309@03 V@12@03))
; [eval] aloc(opt_get1(Gf), i1).option$array$ == aloc(opt_get1(Gf), i2).option$array$
; [eval] aloc(opt_get1(Gf), i1)
; [eval] opt_get1(Gf)
(push) ; 23
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 23
; Joined path conditions
(push) ; 23
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 24
(assert (not (< i1@308@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))))
(check-sat)
; unsat
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1618769
;  :arith-add-rows          443736
;  :arith-assert-diseq      61147
;  :arith-assert-lower      444872
;  :arith-assert-upper      365738
;  :arith-bound-prop        18130
;  :arith-conflicts         1030
;  :arith-eq-adapter        216931
;  :arith-fixed-eqs         289184
;  :arith-offset-eqs        100414
;  :arith-pivots            47565
;  :conflicts               2551
;  :datatype-accessor-ax    638
;  :datatype-constructor-ax 1633
;  :datatype-occurs-check   1309
;  :datatype-splits         1167
;  :decisions               133897
;  :del-clause              2121110
;  :final-checks            177
;  :interface-eqs           41
;  :max-generation          15
;  :max-memory              50.39
;  :memory                  45.02
;  :minimized-lits          318
;  :mk-bool-var             2454521
;  :mk-clause               2122599
;  :num-allocs              8156392
;  :num-checks              388
;  :propagations            898178
;  :quant-instantiations    1060518
;  :restarts                4
;  :rlimit-count            26607880)
(assert (< i1@308@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03))))
(pop) ; 23
; Joined path conditions
(assert (< i1@308@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@303@03  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@308@03)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@308@03)))
(push) ; 23
(assert (not (<
  $Perm.No
  (+
    (-
      (ite
        (and
          (<
            (inv@108@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@308@03))
            V@12@03)
          (<=
            0
            (inv@108@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@308@03))))
        $k@107@03
        $Perm.No)
      (pTaken@197@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@308@03)))
    (ite
      (and
        (<
          (inv@171@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@308@03))
          V@12@03)
        (<=
          0
          (inv@171@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@308@03))))
      $k@170@03
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 23
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1619589
;  :arith-add-rows          443877
;  :arith-assert-diseq      61166
;  :arith-assert-lower      445035
;  :arith-assert-upper      365832
;  :arith-bound-prop        18153
;  :arith-conflicts         1033
;  :arith-eq-adapter        217051
;  :arith-fixed-eqs         289291
;  :arith-offset-eqs        100545
;  :arith-pivots            47588
;  :conflicts               2570
;  :datatype-accessor-ax    638
;  :datatype-constructor-ax 1637
;  :datatype-occurs-check   1309
;  :datatype-splits         1167
;  :decisions               133925
;  :del-clause              2122125
;  :final-checks            177
;  :interface-eqs           41
;  :max-generation          15
;  :max-memory              50.39
;  :memory                  45.19
;  :minimized-lits          318
;  :mk-bool-var             2455820
;  :mk-clause               2123727
;  :num-allocs              8161002
;  :num-checks              389
;  :propagations            898602
;  :quant-instantiations    1061002
;  :restarts                4
;  :rlimit-count            26628667
;  :time                    0.01)
; [eval] aloc(opt_get1(Gf), i2)
; [eval] opt_get1(Gf)
(push) ; 23
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 23
; Joined path conditions
(push) ; 23
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 24
(assert (not (< i2@309@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))))
(check-sat)
; unsat
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1619589
;  :arith-add-rows          443877
;  :arith-assert-diseq      61166
;  :arith-assert-lower      445035
;  :arith-assert-upper      365832
;  :arith-bound-prop        18153
;  :arith-conflicts         1033
;  :arith-eq-adapter        217051
;  :arith-fixed-eqs         289291
;  :arith-offset-eqs        100545
;  :arith-pivots            47588
;  :conflicts               2570
;  :datatype-accessor-ax    638
;  :datatype-constructor-ax 1637
;  :datatype-occurs-check   1309
;  :datatype-splits         1167
;  :decisions               133925
;  :del-clause              2122125
;  :final-checks            177
;  :interface-eqs           41
;  :max-generation          15
;  :max-memory              50.39
;  :memory                  45.19
;  :minimized-lits          318
;  :mk-bool-var             2455820
;  :mk-clause               2123727
;  :num-allocs              8161029
;  :num-checks              390
;  :propagations            898602
;  :quant-instantiations    1061002
;  :restarts                4
;  :rlimit-count            26628697)
(assert (< i2@309@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03))))
(pop) ; 23
; Joined path conditions
(assert (< i2@309@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@303@03  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@309@03)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@309@03)))
(push) ; 23
(assert (not (<
  $Perm.No
  (+
    (-
      (ite
        (and
          (<
            (inv@108@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@309@03))
            V@12@03)
          (<=
            0
            (inv@108@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@309@03))))
        $k@107@03
        $Perm.No)
      (pTaken@197@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@309@03)))
    (ite
      (and
        (<
          (inv@171@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@309@03))
          V@12@03)
        (<=
          0
          (inv@171@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@309@03))))
      $k@170@03
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 23
; 0.02s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1620495
;  :arith-add-rows          444253
;  :arith-assert-diseq      61195
;  :arith-assert-lower      445244
;  :arith-assert-upper      365940
;  :arith-bound-prop        18194
;  :arith-conflicts         1038
;  :arith-eq-adapter        217189
;  :arith-fixed-eqs         289406
;  :arith-offset-eqs        100695
;  :arith-pivots            47638
;  :conflicts               2593
;  :datatype-accessor-ax    638
;  :datatype-constructor-ax 1641
;  :datatype-occurs-check   1309
;  :datatype-splits         1167
;  :decisions               133966
;  :del-clause              2123307
;  :final-checks            177
;  :interface-eqs           41
;  :max-generation          15
;  :max-memory              50.39
;  :memory                  45.21
;  :minimized-lits          319
;  :mk-bool-var             2457378
;  :mk-clause               2125054
;  :num-allocs              8166519
;  :num-checks              391
;  :propagations            899136
;  :quant-instantiations    1061503
;  :restarts                4
;  :rlimit-count            26654667
;  :time                    0.01)
(pop) ; 22
(push) ; 22
; [else-branch: 179 | !(i2@309@03 < V@12@03)]
(assert (not (< i2@309@03 V@12@03)))
(pop) ; 22
(pop) ; 21
; Joined path conditions
(assert (implies
  (< i2@309@03 V@12@03)
  (and
    (< i2@309@03 V@12@03)
    (< i1@308@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@303@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@308@03)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@308@03))
    (< i2@309@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@303@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@309@03)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@309@03)))))
; Joined path conditions
(pop) ; 20
(push) ; 20
; [else-branch: 178 | !(0 <= i2@309@03)]
(assert (not (<= 0 i2@309@03)))
(pop) ; 20
(pop) ; 19
; Joined path conditions
(assert (implies
  (<= 0 i2@309@03)
  (and
    (<= 0 i2@309@03)
    (implies
      (< i2@309@03 V@12@03)
      (and
        (< i2@309@03 V@12@03)
        (< i1@308@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@303@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@308@03)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@308@03))
        (< i2@309@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@303@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@309@03)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@309@03)))))))
; Joined path conditions
(pop) ; 18
(push) ; 18
; [else-branch: 177 | !(i1@308@03 < V@12@03)]
(assert (not (< i1@308@03 V@12@03)))
(pop) ; 18
(pop) ; 17
; Joined path conditions
(assert (implies
  (< i1@308@03 V@12@03)
  (and
    (< i1@308@03 V@12@03)
    (implies
      (<= 0 i2@309@03)
      (and
        (<= 0 i2@309@03)
        (implies
          (< i2@309@03 V@12@03)
          (and
            (< i2@309@03 V@12@03)
            (< i1@308@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@303@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@308@03)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@308@03))
            (< i2@309@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@303@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@309@03)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@309@03)))))))))
; Joined path conditions
(pop) ; 16
(push) ; 16
; [else-branch: 176 | !(0 <= i1@308@03)]
(assert (not (<= 0 i1@308@03)))
(pop) ; 16
(pop) ; 15
; Joined path conditions
(assert (implies
  (<= 0 i1@308@03)
  (and
    (<= 0 i1@308@03)
    (implies
      (< i1@308@03 V@12@03)
      (and
        (< i1@308@03 V@12@03)
        (implies
          (<= 0 i2@309@03)
          (and
            (<= 0 i2@309@03)
            (implies
              (< i2@309@03 V@12@03)
              (and
                (< i2@309@03 V@12@03)
                (< i1@308@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@303@03  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@308@03)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@308@03))
                (< i2@309@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@303@03  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@309@03)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@309@03)))))))))))
; Joined path conditions
(push) ; 15
; [then-branch: 180 | Lookup(option$array$,sm@303@03,aloc((_, _), opt_get1(_, Gf@11@03), i1@308@03)) == Lookup(option$array$,sm@303@03,aloc((_, _), opt_get1(_, Gf@11@03), i2@309@03)) && i2@309@03 < V@12@03 && 0 <= i2@309@03 && i1@308@03 < V@12@03 && 0 <= i1@308@03 | live]
; [else-branch: 180 | !(Lookup(option$array$,sm@303@03,aloc((_, _), opt_get1(_, Gf@11@03), i1@308@03)) == Lookup(option$array$,sm@303@03,aloc((_, _), opt_get1(_, Gf@11@03), i2@309@03)) && i2@309@03 < V@12@03 && 0 <= i2@309@03 && i1@308@03 < V@12@03 && 0 <= i1@308@03) | live]
(push) ; 16
; [then-branch: 180 | Lookup(option$array$,sm@303@03,aloc((_, _), opt_get1(_, Gf@11@03), i1@308@03)) == Lookup(option$array$,sm@303@03,aloc((_, _), opt_get1(_, Gf@11@03), i2@309@03)) && i2@309@03 < V@12@03 && 0 <= i2@309@03 && i1@308@03 < V@12@03 && 0 <= i1@308@03]
(assert (and
  (and
    (and
      (and
        (=
          ($FVF.lookup_option$array$ (as sm@303@03  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@308@03))
          ($FVF.lookup_option$array$ (as sm@303@03  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@309@03)))
        (< i2@309@03 V@12@03))
      (<= 0 i2@309@03))
    (< i1@308@03 V@12@03))
  (<= 0 i1@308@03)))
; [eval] i1 == i2
(pop) ; 16
(push) ; 16
; [else-branch: 180 | !(Lookup(option$array$,sm@303@03,aloc((_, _), opt_get1(_, Gf@11@03), i1@308@03)) == Lookup(option$array$,sm@303@03,aloc((_, _), opt_get1(_, Gf@11@03), i2@309@03)) && i2@309@03 < V@12@03 && 0 <= i2@309@03 && i1@308@03 < V@12@03 && 0 <= i1@308@03)]
(assert (not
  (and
    (and
      (and
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@303@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@308@03))
            ($FVF.lookup_option$array$ (as sm@303@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@309@03)))
          (< i2@309@03 V@12@03))
        (<= 0 i2@309@03))
      (< i1@308@03 V@12@03))
    (<= 0 i1@308@03))))
(pop) ; 16
(pop) ; 15
; Joined path conditions
(assert (implies
  (and
    (and
      (and
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@303@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@308@03))
            ($FVF.lookup_option$array$ (as sm@303@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@309@03)))
          (< i2@309@03 V@12@03))
        (<= 0 i2@309@03))
      (< i1@308@03 V@12@03))
    (<= 0 i1@308@03))
  (and
    (=
      ($FVF.lookup_option$array$ (as sm@303@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@308@03))
      ($FVF.lookup_option$array$ (as sm@303@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@309@03)))
    (< i2@309@03 V@12@03)
    (<= 0 i2@309@03)
    (< i1@308@03 V@12@03)
    (<= 0 i1@308@03))))
; Joined path conditions
(pop) ; 14
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i2@309@03 Int)) (!
  (and
    (implies
      (<= 0 i1@308@03)
      (and
        (<= 0 i1@308@03)
        (implies
          (< i1@308@03 V@12@03)
          (and
            (< i1@308@03 V@12@03)
            (implies
              (<= 0 i2@309@03)
              (and
                (<= 0 i2@309@03)
                (implies
                  (< i2@309@03 V@12@03)
                  (and
                    (< i2@309@03 V@12@03)
                    (< i1@308@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))
                    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@303@03  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@308@03)) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@308@03))
                    (< i2@309@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))
                    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@303@03  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@309@03)) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@309@03))))))))))
    (implies
      (and
        (and
          (and
            (and
              (=
                ($FVF.lookup_option$array$ (as sm@303@03  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@308@03))
                ($FVF.lookup_option$array$ (as sm@303@03  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@309@03)))
              (< i2@309@03 V@12@03))
            (<= 0 i2@309@03))
          (< i1@308@03 V@12@03))
        (<= 0 i1@308@03))
      (and
        (=
          ($FVF.lookup_option$array$ (as sm@303@03  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@308@03))
          ($FVF.lookup_option$array$ (as sm@303@03  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@309@03)))
        (< i2@309@03 V@12@03)
        (<= 0 i2@309@03)
        (< i1@308@03 V@12@03)
        (<= 0 i1@308@03))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@309@03))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 13
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@308@03 Int)) (!
  (forall ((i2@309@03 Int)) (!
    (and
      (implies
        (<= 0 i1@308@03)
        (and
          (<= 0 i1@308@03)
          (implies
            (< i1@308@03 V@12@03)
            (and
              (< i1@308@03 V@12@03)
              (implies
                (<= 0 i2@309@03)
                (and
                  (<= 0 i2@309@03)
                  (implies
                    (< i2@309@03 V@12@03)
                    (and
                      (< i2@309@03 V@12@03)
                      (< i1@308@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))
                      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@303@03  $FVF<option<array>>) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@308@03)) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@308@03))
                      (< i2@309@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))
                      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@303@03  $FVF<option<array>>) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@309@03)) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@309@03))))))))))
      (implies
        (and
          (and
            (and
              (and
                (=
                  ($FVF.lookup_option$array$ (as sm@303@03  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@308@03))
                  ($FVF.lookup_option$array$ (as sm@303@03  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@309@03)))
                (< i2@309@03 V@12@03))
              (<= 0 i2@309@03))
            (< i1@308@03 V@12@03))
          (<= 0 i1@308@03))
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@303@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@308@03))
            ($FVF.lookup_option$array$ (as sm@303@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@309@03)))
          (< i2@309@03 V@12@03)
          (<= 0 i2@309@03)
          (< i1@308@03 V@12@03)
          (<= 0 i1@308@03))))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@309@03))
    :qid |prog.l<no position>-aux|))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@308@03))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(push) ; 13
(assert (not (forall ((i1@308@03 Int)) (!
  (forall ((i2@309@03 Int)) (!
    (implies
      (and
        (and
          (and
            (and
              (=
                ($FVF.lookup_option$array$ (as sm@303@03  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@308@03))
                ($FVF.lookup_option$array$ (as sm@303@03  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@309@03)))
              (< i2@309@03 V@12@03))
            (<= 0 i2@309@03))
          (< i1@308@03 V@12@03))
        (<= 0 i1@308@03))
      (= i1@308@03 i2@309@03))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@309@03))
    :qid |prog.l<no position>|))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@308@03))
  :qid |prog.l<no position>|))))
(check-sat)
; unsat
(pop) ; 13
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1621366
;  :arith-add-rows          444482
;  :arith-assert-diseq      61212
;  :arith-assert-lower      445408
;  :arith-assert-upper      366038
;  :arith-bound-prop        18230
;  :arith-conflicts         1040
;  :arith-eq-adapter        217313
;  :arith-fixed-eqs         289518
;  :arith-offset-eqs        100845
;  :arith-pivots            47712
;  :conflicts               2611
;  :datatype-accessor-ax    638
;  :datatype-constructor-ax 1645
;  :datatype-occurs-check   1309
;  :datatype-splits         1167
;  :decisions               133996
;  :del-clause              2124809
;  :final-checks            177
;  :interface-eqs           41
;  :max-generation          15
;  :max-memory              50.39
;  :memory                  45.18
;  :minimized-lits          319
;  :mk-bool-var             2458812
;  :mk-clause               2126298
;  :num-allocs              8172399
;  :num-checks              392
;  :propagations            899603
;  :quant-instantiations    1062066
;  :restarts                4
;  :rlimit-count            26684530
;  :time                    0.01)
(assert (forall ((i1@308@03 Int)) (!
  (forall ((i2@309@03 Int)) (!
    (implies
      (and
        (and
          (and
            (and
              (=
                ($FVF.lookup_option$array$ (as sm@303@03  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@308@03))
                ($FVF.lookup_option$array$ (as sm@303@03  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@309@03)))
              (< i2@309@03 V@12@03))
            (<= 0 i2@309@03))
          (< i1@308@03 V@12@03))
        (<= 0 i1@308@03))
      (= i1@308@03 i2@309@03))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@309@03))
    :qid |prog.l<no position>|))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@308@03))
  :qid |prog.l<no position>|)))
; [eval] p != (None(): option[array])
; [eval] (None(): option[array])
; [eval] alen(opt_get1(p)) == V
; [eval] alen(opt_get1(p))
; [eval] opt_get1(p)
(push) ; 13
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 13
; Joined path conditions
; [eval] 0 <= s
; [eval] s < V
; [eval] 0 <= t
; [eval] t < V
(declare-const i1@310@03 Int)
(declare-const j1@311@03 Int)
(push) ; 13
; [eval] 0 <= i1 && i1 < V && (0 <= j1 && j1 < V)
; [eval] 0 <= i1
(push) ; 14
; [then-branch: 181 | 0 <= i1@310@03 | live]
; [else-branch: 181 | !(0 <= i1@310@03) | live]
(push) ; 15
; [then-branch: 181 | 0 <= i1@310@03]
(assert (<= 0 i1@310@03))
; [eval] i1 < V
(push) ; 16
; [then-branch: 182 | i1@310@03 < V@12@03 | live]
; [else-branch: 182 | !(i1@310@03 < V@12@03) | live]
(push) ; 17
; [then-branch: 182 | i1@310@03 < V@12@03]
(assert (< i1@310@03 V@12@03))
; [eval] 0 <= j1
(push) ; 18
; [then-branch: 183 | 0 <= j1@311@03 | live]
; [else-branch: 183 | !(0 <= j1@311@03) | live]
(push) ; 19
; [then-branch: 183 | 0 <= j1@311@03]
(assert (<= 0 j1@311@03))
; [eval] j1 < V
(pop) ; 19
(push) ; 19
; [else-branch: 183 | !(0 <= j1@311@03)]
(assert (not (<= 0 j1@311@03)))
(pop) ; 19
(pop) ; 18
; Joined path conditions
; Joined path conditions
(pop) ; 17
(push) ; 17
; [else-branch: 182 | !(i1@310@03 < V@12@03)]
(assert (not (< i1@310@03 V@12@03)))
(pop) ; 17
(pop) ; 16
; Joined path conditions
; Joined path conditions
(pop) ; 15
(push) ; 15
; [else-branch: 181 | !(0 <= i1@310@03)]
(assert (not (<= 0 i1@310@03)))
(pop) ; 15
(pop) ; 14
; Joined path conditions
; Joined path conditions
(assert (and
  (and (and (< j1@311@03 V@12@03) (<= 0 j1@311@03)) (< i1@310@03 V@12@03))
  (<= 0 i1@310@03)))
; [eval] aloc(opt_get1(aloc(opt_get1(Gf), i1).option$array$), j1)
; [eval] opt_get1(aloc(opt_get1(Gf), i1).option$array$)
; [eval] aloc(opt_get1(Gf), i1)
; [eval] opt_get1(Gf)
(push) ; 14
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 14
; Joined path conditions
(push) ; 14
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 15
(assert (not (< i1@310@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))))
(check-sat)
; unsat
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1621366
;  :arith-add-rows          444485
;  :arith-assert-diseq      61212
;  :arith-assert-lower      445414
;  :arith-assert-upper      366038
;  :arith-bound-prop        18230
;  :arith-conflicts         1040
;  :arith-eq-adapter        217313
;  :arith-fixed-eqs         289518
;  :arith-offset-eqs        100845
;  :arith-pivots            47712
;  :conflicts               2611
;  :datatype-accessor-ax    638
;  :datatype-constructor-ax 1645
;  :datatype-occurs-check   1309
;  :datatype-splits         1167
;  :decisions               133996
;  :del-clause              2124809
;  :final-checks            177
;  :interface-eqs           41
;  :max-generation          15
;  :max-memory              50.39
;  :memory                  45.18
;  :minimized-lits          319
;  :mk-bool-var             2458819
;  :mk-clause               2126298
;  :num-allocs              8173002
;  :num-checks              393
;  :propagations            899603
;  :quant-instantiations    1062066
;  :restarts                4
;  :rlimit-count            26685531)
(assert (< i1@310@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03))))
(pop) ; 14
; Joined path conditions
(assert (< i1@310@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@303@03  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@310@03)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@310@03)))
(push) ; 14
(assert (not (<
  $Perm.No
  (+
    (-
      (ite
        (and
          (<
            (inv@108@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@310@03))
            V@12@03)
          (<=
            0
            (inv@108@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@310@03))))
        $k@107@03
        $Perm.No)
      (pTaken@197@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@310@03)))
    (ite
      (and
        (<
          (inv@171@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@310@03))
          V@12@03)
        (<=
          0
          (inv@171@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@310@03))))
      $k@170@03
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 14
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1622188
;  :arith-add-rows          444652
;  :arith-assert-diseq      61231
;  :arith-assert-lower      445578
;  :arith-assert-upper      366131
;  :arith-bound-prop        18253
;  :arith-conflicts         1043
;  :arith-eq-adapter        217433
;  :arith-fixed-eqs         289625
;  :arith-offset-eqs        100976
;  :arith-pivots            47739
;  :conflicts               2630
;  :datatype-accessor-ax    638
;  :datatype-constructor-ax 1649
;  :datatype-occurs-check   1309
;  :datatype-splits         1167
;  :decisions               134024
;  :del-clause              2125824
;  :final-checks            177
;  :interface-eqs           41
;  :max-generation          15
;  :max-memory              50.39
;  :memory                  45.20
;  :minimized-lits          319
;  :mk-bool-var             2460129
;  :mk-clause               2127426
;  :num-allocs              8177673
;  :num-checks              394
;  :propagations            900027
;  :quant-instantiations    1062553
;  :restarts                4
;  :rlimit-count            26706817
;  :time                    0.01)
(push) ; 14
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 15
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@303@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@310@03))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1622188
;  :arith-add-rows          444652
;  :arith-assert-diseq      61231
;  :arith-assert-lower      445578
;  :arith-assert-upper      366131
;  :arith-bound-prop        18253
;  :arith-conflicts         1043
;  :arith-eq-adapter        217433
;  :arith-fixed-eqs         289625
;  :arith-offset-eqs        100976
;  :arith-pivots            47739
;  :conflicts               2631
;  :datatype-accessor-ax    638
;  :datatype-constructor-ax 1649
;  :datatype-occurs-check   1309
;  :datatype-splits         1167
;  :decisions               134024
;  :del-clause              2125824
;  :final-checks            177
;  :interface-eqs           41
;  :max-generation          15
;  :max-memory              50.39
;  :memory                  45.20
;  :minimized-lits          319
;  :mk-bool-var             2460129
;  :mk-clause               2127426
;  :num-allocs              8177763
;  :num-checks              395
;  :propagations            900027
;  :quant-instantiations    1062553
;  :restarts                4
;  :rlimit-count            26706912)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@303@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@310@03))
    (as None<option<array>>  option<array>))))
(pop) ; 14
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@303@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@310@03))
    (as None<option<array>>  option<array>))))
(push) ; 14
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 15
(assert (not (<
  j1@311@03
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@303@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@310@03)))))))
(check-sat)
; unsat
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1622194
;  :arith-add-rows          444658
;  :arith-assert-diseq      61231
;  :arith-assert-lower      445580
;  :arith-assert-upper      366133
;  :arith-bound-prop        18253
;  :arith-conflicts         1044
;  :arith-eq-adapter        217434
;  :arith-fixed-eqs         289626
;  :arith-offset-eqs        100976
;  :arith-pivots            47743
;  :conflicts               2632
;  :datatype-accessor-ax    638
;  :datatype-constructor-ax 1649
;  :datatype-occurs-check   1309
;  :datatype-splits         1167
;  :decisions               134024
;  :del-clause              2125828
;  :final-checks            177
;  :interface-eqs           41
;  :max-generation          15
;  :max-memory              50.39
;  :memory                  45.22
;  :minimized-lits          319
;  :mk-bool-var             2460140
;  :mk-clause               2127430
;  :num-allocs              8177958
;  :num-checks              396
;  :propagations            900029
;  :quant-instantiations    1062560
;  :restarts                4
;  :rlimit-count            26707457)
(assert (<
  j1@311@03
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@303@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@310@03))))))
(pop) ; 14
; Joined path conditions
(assert (<
  j1@311@03
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@303@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@310@03))))))
(pop) ; 13
(declare-fun inv@312@03 ($Ref) Int)
(declare-fun inv@313@03 ($Ref) Int)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(assert (forall ((i1@310@03 Int) (j1@311@03 Int)) (!
  (and
    (< i1@310@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@303@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@310@03)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@310@03))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@303@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@310@03))
        (as None<option<array>>  option<array>)))
    (<
      j1@311@03
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@303@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@310@03))))))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@303@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@310@03))) j1@311@03))
  :qid |int-aux|)))
(declare-const sm@314@03 $FVF<Int>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@183@03 r) V@12@03) (<= 0 (inv@183@03 r)))
    (=
      ($FVF.lookup_int (as sm@314@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03)))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@314@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03)))))))))))))))) r))
  :qid |qp.fvfValDef142|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@180@03 r) V@12@03) (<= 0 (inv@180@03 r)))
        (< (inv@179@03 r) V@12@03))
      (<= 0 (inv@179@03 r)))
    (=
      ($FVF.lookup_int (as sm@314@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@314@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03))))))))))))))) r))
  :qid |qp.fvfValDef143|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03)))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03))))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@314@03  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef144|)))
; Check receiver injectivity
(push) ; 13
(assert (not (forall ((i11@310@03 Int) (j11@311@03 Int) (i12@310@03 Int) (j12@311@03 Int)) (!
  (implies
    (and
      (and
        (and
          (and
            (and (< j11@311@03 V@12@03) (<= 0 j11@311@03))
            (< i11@310@03 V@12@03))
          (<= 0 i11@310@03))
        ($FVF.loc_int ($FVF.lookup_int (as sm@314@03  $FVF<Int>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@303@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i11@310@03))) j11@311@03)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@303@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i11@310@03))) j11@311@03)))
      (and
        (and
          (and
            (and (< j12@311@03 V@12@03) (<= 0 j12@311@03))
            (< i12@310@03 V@12@03))
          (<= 0 i12@310@03))
        ($FVF.loc_int ($FVF.lookup_int (as sm@314@03  $FVF<Int>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@303@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i12@310@03))) j12@311@03)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@303@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i12@310@03))) j12@311@03)))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@303@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i11@310@03))) j11@311@03)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@303@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i12@310@03))) j12@311@03)))
    (and (= i11@310@03 i12@310@03) (= j11@311@03 j12@311@03)))
  
  :qid |int-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 13
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1622289
;  :arith-add-rows          444720
;  :arith-assert-diseq      61231
;  :arith-assert-lower      445597
;  :arith-assert-upper      366140
;  :arith-bound-prop        18259
;  :arith-conflicts         1044
;  :arith-eq-adapter        217461
;  :arith-fixed-eqs         289632
;  :arith-offset-eqs        100976
;  :arith-pivots            47768
;  :conflicts               2633
;  :datatype-accessor-ax    638
;  :datatype-constructor-ax 1649
;  :datatype-occurs-check   1309
;  :datatype-splits         1167
;  :decisions               134024
;  :del-clause              2126287
;  :final-checks            177
;  :interface-eqs           41
;  :max-generation          15
;  :max-memory              50.39
;  :memory                  45.20
;  :minimized-lits          319
;  :mk-bool-var             2460749
;  :mk-clause               2127776
;  :num-allocs              8181405
;  :num-checks              397
;  :propagations            900063
;  :quant-instantiations    1062765
;  :restarts                4
;  :rlimit-count            26721653
;  :time                    0.01)
; Definitional axioms for inverse functions
(assert (forall ((i1@310@03 Int) (j1@311@03 Int)) (!
  (implies
    (and
      (and (and (< j1@311@03 V@12@03) (<= 0 j1@311@03)) (< i1@310@03 V@12@03))
      (<= 0 i1@310@03))
    (and
      (=
        (inv@312@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@303@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@310@03))) j1@311@03))
        i1@310@03)
      (=
        (inv@313@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@303@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@310@03))) j1@311@03))
        j1@311@03)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@303@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@310@03))) j1@311@03))
  :qid |int-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@313@03 r) V@12@03) (<= 0 (inv@313@03 r)))
        (< (inv@312@03 r) V@12@03))
      (<= 0 (inv@312@03 r)))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@303@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) (inv@312@03 r)))) (inv@313@03 r))
      r))
  :pattern ((inv@312@03 r))
  :pattern ((inv@313@03 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@313@03 r) V@12@03) (<= 0 (inv@313@03 r)))
        (< (inv@312@03 r) V@12@03))
      (<= 0 (inv@312@03 r)))
    ($FVF.loc_int ($FVF.lookup_int (as sm@314@03  $FVF<Int>) r) r))
  :pattern ((inv@312@03 r) (inv@313@03 r))
  )))
; Precomputing data for removing quantified permissions
(define-fun pTaken@315@03 ((r $Ref)) $Perm
  (ite
    (and
      (and
        (and (< (inv@313@03 r) V@12@03) (<= 0 (inv@313@03 r)))
        (< (inv@312@03 r) V@12@03))
      (<= 0 (inv@312@03 r)))
    ($Perm.min
      (ite
        (and (< (inv@183@03 r) V@12@03) (<= 0 (inv@183@03 r)))
        $Perm.Write
        $Perm.No)
      $Perm.Write)
    $Perm.No))
(define-fun pTaken@316@03 ((r $Ref)) $Perm
  (ite
    (and
      (and
        (and (< (inv@313@03 r) V@12@03) (<= 0 (inv@313@03 r)))
        (< (inv@312@03 r) V@12@03))
      (<= 0 (inv@312@03 r)))
    ($Perm.min
      (ite
        (and
          (and
            (and (< (inv@180@03 r) V@12@03) (<= 0 (inv@180@03 r)))
            (< (inv@179@03 r) V@12@03))
          (<= 0 (inv@179@03 r)))
        $Perm.Write
        $Perm.No)
      (- $Perm.Write (pTaken@315@03 r)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 500)
(push) ; 13
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and (< (inv@183@03 r) V@12@03) (<= 0 (inv@183@03 r)))
        $Perm.Write
        $Perm.No)
      (pTaken@315@03 r))
    $Perm.No)
  
  ))))
(check-sat)
; unknown
(pop) ; 13
; 0.50s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1654259
;  :arith-add-rows          454283
;  :arith-assert-diseq      61927
;  :arith-assert-lower      454335
;  :arith-assert-upper      371957
;  :arith-bound-prop        18716
;  :arith-conflicts         1073
;  :arith-eq-adapter        221822
;  :arith-fixed-eqs         294308
;  :arith-offset-eqs        104438
;  :arith-pivots            49112
;  :conflicts               2686
;  :datatype-accessor-ax    638
;  :datatype-constructor-ax 1657
;  :datatype-occurs-check   1309
;  :datatype-splits         1167
;  :decisions               137796
;  :del-clause              2188193
;  :final-checks            177
;  :interface-eqs           41
;  :max-generation          15
;  :max-memory              50.39
;  :memory                  45.21
;  :minimized-lits          326
;  :mk-bool-var             2520844
;  :mk-clause               2189682
;  :num-allocs              8331759
;  :num-checks              399
;  :propagations            919361
;  :quant-instantiations    1085399
;  :restarts                4
;  :rlimit-count            27279726
;  :time                    0.50)
; Intermediate check if already taken enough permissions
(push) ; 13
(assert (not (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@313@03 r) V@12@03) (<= 0 (inv@313@03 r)))
        (< (inv@312@03 r) V@12@03))
      (<= 0 (inv@312@03 r)))
    (= (- $Perm.Write (pTaken@315@03 r)) $Perm.No))
  
  ))))
(check-sat)
; unknown
(pop) ; 13
; 0.51s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1694506
;  :arith-add-rows          466335
;  :arith-assert-diseq      62847
;  :arith-assert-lower      464359
;  :arith-assert-upper      379068
;  :arith-bound-prop        19338
;  :arith-conflicts         1115
;  :arith-eq-adapter        227214
;  :arith-fixed-eqs         299192
;  :arith-offset-eqs        108036
;  :arith-pivots            50956
;  :conflicts               2764
;  :datatype-accessor-ax    638
;  :datatype-constructor-ax 1661
;  :datatype-occurs-check   1309
;  :datatype-splits         1167
;  :decisions               142408
;  :del-clause              2254817
;  :final-checks            177
;  :interface-eqs           41
;  :max-generation          15
;  :max-memory              50.39
;  :memory                  45.54
;  :minimized-lits          335
;  :mk-bool-var             2592708
;  :mk-clause               2256306
;  :num-allocs              8523674
;  :num-checks              400
;  :propagations            942093
;  :quant-instantiations    1115733
;  :restarts                4
;  :rlimit-count            27916064
;  :time                    0.51)
; Chunk depleted?
(push) ; 13
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and
          (and
            (and (< (inv@180@03 r) V@12@03) (<= 0 (inv@180@03 r)))
            (< (inv@179@03 r) V@12@03))
          (<= 0 (inv@179@03 r)))
        $Perm.Write
        $Perm.No)
      (pTaken@316@03 r))
    $Perm.No)
  
  ))))
(check-sat)
; unknown
(pop) ; 13
; 0.50s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1716178
;  :arith-add-rows          477534
;  :arith-assert-diseq      63576
;  :arith-assert-lower      470809
;  :arith-assert-upper      384123
;  :arith-bound-prop        19796
;  :arith-conflicts         1142
;  :arith-eq-adapter        230815
;  :arith-fixed-eqs         302945
;  :arith-offset-eqs        109571
;  :arith-pivots            52348
;  :conflicts               2818
;  :datatype-accessor-ax    638
;  :datatype-constructor-ax 1665
;  :datatype-occurs-check   1309
;  :datatype-splits         1167
;  :decisions               145621
;  :del-clause              2310671
;  :final-checks            177
;  :interface-eqs           41
;  :max-generation          15
;  :max-memory              50.39
;  :memory                  45.87
;  :minimized-lits          348
;  :mk-bool-var             2645316
;  :mk-clause               2312160
;  :num-allocs              8647930
;  :num-checks              401
;  :propagations            957658
;  :quant-instantiations    1132785
;  :restarts                4
;  :rlimit-count            28480869
;  :time                    0.50)
; Intermediate check if already taken enough permissions
(push) ; 13
(assert (not (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@313@03 r) V@12@03) (<= 0 (inv@313@03 r)))
        (< (inv@312@03 r) V@12@03))
      (<= 0 (inv@312@03 r)))
    (= (- (- $Perm.Write (pTaken@315@03 r)) (pTaken@316@03 r)) $Perm.No))
  
  ))))
(check-sat)
; unsat
(pop) ; 13
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1717223
;  :arith-add-rows          477888
;  :arith-assert-diseq      63610
;  :arith-assert-lower      471023
;  :arith-assert-upper      384272
;  :arith-bound-prop        19825
;  :arith-conflicts         1151
;  :arith-eq-adapter        230996
;  :arith-fixed-eqs         303079
;  :arith-offset-eqs        109715
;  :arith-pivots            52428
;  :conflicts               2842
;  :datatype-accessor-ax    638
;  :datatype-constructor-ax 1669
;  :datatype-occurs-check   1309
;  :datatype-splits         1167
;  :decisions               145658
;  :del-clause              2312029
;  :final-checks            177
;  :interface-eqs           41
;  :max-generation          15
;  :max-memory              50.39
;  :memory                  45.81
;  :minimized-lits          349
;  :mk-bool-var             2646883
;  :mk-clause               2313518
;  :num-allocs              8653539
;  :num-checks              402
;  :propagations            958215
;  :quant-instantiations    1133323
;  :restarts                4
;  :rlimit-count            28509965
;  :time                    0.01)
; Final check if taken enough permissions
; Done removing quantified permissions
; Definitional axioms for snapshot map values
(declare-const i1@317@03 Int)
(push) ; 13
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 14
; [then-branch: 184 | 0 <= i1@317@03 | live]
; [else-branch: 184 | !(0 <= i1@317@03) | live]
(push) ; 15
; [then-branch: 184 | 0 <= i1@317@03]
(assert (<= 0 i1@317@03))
; [eval] i1 < V
(pop) ; 15
(push) ; 15
; [else-branch: 184 | !(0 <= i1@317@03)]
(assert (not (<= 0 i1@317@03)))
(pop) ; 15
(pop) ; 14
; Joined path conditions
; Joined path conditions
(assert (and (< i1@317@03 V@12@03) (<= 0 i1@317@03)))
; [eval] aloc(opt_get1(p), i1)
; [eval] opt_get1(p)
(push) ; 14
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 14
; Joined path conditions
(push) ; 14
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 15
(assert (not (< i1@317@03 (alen<Int> (opt_get1 $Snap.unit p@15@03)))))
(check-sat)
; unsat
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1717223
;  :arith-add-rows          477889
;  :arith-assert-diseq      63610
;  :arith-assert-lower      471025
;  :arith-assert-upper      384272
;  :arith-bound-prop        19825
;  :arith-conflicts         1151
;  :arith-eq-adapter        230996
;  :arith-fixed-eqs         303079
;  :arith-offset-eqs        109715
;  :arith-pivots            52428
;  :conflicts               2842
;  :datatype-accessor-ax    638
;  :datatype-constructor-ax 1669
;  :datatype-occurs-check   1309
;  :datatype-splits         1167
;  :decisions               145658
;  :del-clause              2312029
;  :final-checks            177
;  :interface-eqs           41
;  :max-generation          15
;  :max-memory              50.39
;  :memory                  45.81
;  :minimized-lits          349
;  :mk-bool-var             2646885
;  :mk-clause               2313518
;  :num-allocs              8653651
;  :num-checks              403
;  :propagations            958215
;  :quant-instantiations    1133323
;  :restarts                4
;  :rlimit-count            28510146)
(assert (< i1@317@03 (alen<Int> (opt_get1 $Snap.unit p@15@03))))
(pop) ; 14
; Joined path conditions
(assert (< i1@317@03 (alen<Int> (opt_get1 $Snap.unit p@15@03))))
(pop) ; 13
(declare-fun inv@318@03 ($Ref) Int)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(assert (forall ((i1@317@03 Int)) (!
  (< i1@317@03 (alen<Int> (opt_get1 $Snap.unit p@15@03)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) i1@317@03))
  :qid |int-aux|)))
(declare-const sm@319@03 $FVF<Int>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (ite
          (and
            (and
              (and (< (inv@180@03 r) V@12@03) (<= 0 (inv@180@03 r)))
              (< (inv@179@03 r) V@12@03))
            (<= 0 (inv@179@03 r)))
          $Perm.Write
          $Perm.No)
        (pTaken@316@03 r)))
    (=
      ($FVF.lookup_int (as sm@319@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@319@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03))))))))))))))) r))
  :qid |qp.fvfValDef145|)))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (ite
          (and (< (inv@183@03 r) V@12@03) (<= 0 (inv@183@03 r)))
          $Perm.Write
          $Perm.No)
        (pTaken@315@03 r)))
    (=
      ($FVF.lookup_int (as sm@319@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03)))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@319@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03)))))))))))))))) r))
  :qid |qp.fvfValDef146|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03)))))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@319@03  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef147|)))
; Check receiver injectivity
(push) ; 13
(assert (not (forall ((i11@317@03 Int) (i12@317@03 Int)) (!
  (implies
    (and
      (and
        (and (< i11@317@03 V@12@03) (<= 0 i11@317@03))
        ($FVF.loc_int ($FVF.lookup_int (as sm@319@03  $FVF<Int>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit p@15@03) i11@317@03)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit p@15@03) i11@317@03)))
      (and
        (and (< i12@317@03 V@12@03) (<= 0 i12@317@03))
        ($FVF.loc_int ($FVF.lookup_int (as sm@319@03  $FVF<Int>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit p@15@03) i12@317@03)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit p@15@03) i12@317@03)))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) i11@317@03)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) i12@317@03)))
    (= i11@317@03 i12@317@03))
  
  :qid |int-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1717261
;  :arith-add-rows          477898
;  :arith-assert-diseq      63611
;  :arith-assert-lower      471029
;  :arith-assert-upper      384272
;  :arith-bound-prop        19825
;  :arith-conflicts         1151
;  :arith-eq-adapter        230997
;  :arith-fixed-eqs         303079
;  :arith-offset-eqs        109715
;  :arith-pivots            52428
;  :conflicts               2843
;  :datatype-accessor-ax    638
;  :datatype-constructor-ax 1669
;  :datatype-occurs-check   1309
;  :datatype-splits         1167
;  :decisions               145658
;  :del-clause              2312065
;  :final-checks            177
;  :interface-eqs           41
;  :max-generation          15
;  :max-memory              50.39
;  :memory                  45.77
;  :minimized-lits          349
;  :mk-bool-var             2646971
;  :mk-clause               2313554
;  :num-allocs              8655048
;  :num-checks              404
;  :propagations            958217
;  :quant-instantiations    1133383
;  :restarts                4
;  :rlimit-count            28515090
;  :time                    0.00)
; Definitional axioms for inverse functions
(assert (forall ((i1@317@03 Int)) (!
  (implies
    (and (< i1@317@03 V@12@03) (<= 0 i1@317@03))
    (=
      (inv@318@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) i1@317@03))
      i1@317@03))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) i1@317@03))
  :qid |int-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@318@03 r) V@12@03) (<= 0 (inv@318@03 r)))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) (inv@318@03 r))
      r))
  :pattern ((inv@318@03 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@318@03 r) V@12@03) (<= 0 (inv@318@03 r)))
    ($FVF.loc_int ($FVF.lookup_int (as sm@319@03  $FVF<Int>) r) r))
  :pattern ((inv@318@03 r))
  )))
; Precomputing data for removing quantified permissions
(define-fun pTaken@320@03 ((r $Ref)) $Perm
  (ite
    (and (< (inv@318@03 r) V@12@03) (<= 0 (inv@318@03 r)))
    ($Perm.min
      (-
        (ite
          (and
            (and
              (and (< (inv@180@03 r) V@12@03) (<= 0 (inv@180@03 r)))
              (< (inv@179@03 r) V@12@03))
            (<= 0 (inv@179@03 r)))
          $Perm.Write
          $Perm.No)
        (pTaken@316@03 r))
      $Perm.Write)
    $Perm.No))
(define-fun pTaken@321@03 ((r $Ref)) $Perm
  (ite
    (and (< (inv@318@03 r) V@12@03) (<= 0 (inv@318@03 r)))
    ($Perm.min
      (-
        (ite
          (and (< (inv@183@03 r) V@12@03) (<= 0 (inv@183@03 r)))
          $Perm.Write
          $Perm.No)
        (pTaken@315@03 r))
      (- $Perm.Write (pTaken@320@03 r)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 500)
(push) ; 13
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (-
        (ite
          (and
            (and
              (and (< (inv@180@03 r) V@12@03) (<= 0 (inv@180@03 r)))
              (< (inv@179@03 r) V@12@03))
            (<= 0 (inv@179@03 r)))
          $Perm.Write
          $Perm.No)
        (pTaken@316@03 r))
      (pTaken@320@03 r))
    $Perm.No)
  
  ))))
(check-sat)
; unsat
(pop) ; 13
; 0.05s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1721192
;  :arith-add-rows          479634
;  :arith-assert-diseq      63704
;  :arith-assert-lower      471923
;  :arith-assert-upper      384879
;  :arith-bound-prop        19942
;  :arith-conflicts         1163
;  :arith-eq-adapter        231624
;  :arith-fixed-eqs         303711
;  :arith-offset-eqs        110197
;  :arith-pivots            52831
;  :conflicts               2875
;  :datatype-accessor-ax    638
;  :datatype-constructor-ax 1677
;  :datatype-occurs-check   1309
;  :datatype-splits         1167
;  :decisions               145866
;  :del-clause              2319208
;  :final-checks            177
;  :interface-eqs           41
;  :max-generation          15
;  :max-memory              50.39
;  :memory                  45.79
;  :minimized-lits          353
;  :mk-bool-var             2655770
;  :mk-clause               2320704
;  :num-allocs              8684988
;  :num-checks              406
;  :propagations            960681
;  :quant-instantiations    1136152
;  :restarts                4
;  :rlimit-count            28627425
;  :time                    0.05)
; Intermediate check if already taken enough permissions
(push) ; 13
(assert (not (forall ((r $Ref)) (!
  (implies
    (and (< (inv@318@03 r) V@12@03) (<= 0 (inv@318@03 r)))
    (= (- $Perm.Write (pTaken@320@03 r)) $Perm.No))
  
  ))))
(check-sat)
; unknown
(pop) ; 13
; 0.51s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1756276
;  :arith-add-rows          496865
;  :arith-assert-diseq      64918
;  :arith-assert-lower      481488
;  :arith-assert-upper      392545
;  :arith-bound-prop        20755
;  :arith-conflicts         1216
;  :arith-eq-adapter        237280
;  :arith-fixed-eqs         308560
;  :arith-offset-eqs        112417
;  :arith-pivots            55615
;  :conflicts               2967
;  :datatype-accessor-ax    638
;  :datatype-constructor-ax 1681
;  :datatype-occurs-check   1309
;  :datatype-splits         1167
;  :decisions               150627
;  :del-clause              2401280
;  :final-checks            177
;  :interface-eqs           41
;  :max-generation          15
;  :max-memory              50.39
;  :memory                  45.44
;  :minimized-lits          381
;  :mk-bool-var             2735740
;  :mk-clause               2402776
;  :num-allocs              8889832
;  :num-checks              407
;  :propagations            983249
;  :quant-instantiations    1163518
;  :restarts                4
;  :rlimit-count            29421244
;  :time                    0.51)
; Chunk depleted?
(push) ; 13
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (-
        (ite
          (and (< (inv@183@03 r) V@12@03) (<= 0 (inv@183@03 r)))
          $Perm.Write
          $Perm.No)
        (pTaken@315@03 r))
      (pTaken@321@03 r))
    $Perm.No)
  
  ))))
(check-sat)
; unsat
(pop) ; 13
; 0.07s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1763631
;  :arith-add-rows          498469
;  :arith-assert-diseq      65088
;  :arith-assert-lower      482780
;  :arith-assert-upper      393373
;  :arith-bound-prop        20865
;  :arith-conflicts         1228
;  :arith-eq-adapter        238218
;  :arith-fixed-eqs         309452
;  :arith-offset-eqs        112841
;  :arith-pivots            55908
;  :conflicts               2991
;  :datatype-accessor-ax    638
;  :datatype-constructor-ax 1705
;  :datatype-occurs-check   1309
;  :datatype-splits         1167
;  :decisions               150888
;  :del-clause              2410491
;  :final-checks            177
;  :interface-eqs           41
;  :max-generation          15
;  :max-memory              50.39
;  :memory                  45.52
;  :minimized-lits          384
;  :mk-bool-var             2745212
;  :mk-clause               2411987
;  :num-allocs              8919926
;  :num-checks              408
;  :propagations            986890
;  :quant-instantiations    1167171
;  :restarts                4
;  :rlimit-count            29537145
;  :time                    0.07)
; Intermediate check if already taken enough permissions
(push) ; 13
(assert (not (forall ((r $Ref)) (!
  (implies
    (and (< (inv@318@03 r) V@12@03) (<= 0 (inv@318@03 r)))
    (= (- (- $Perm.Write (pTaken@320@03 r)) (pTaken@321@03 r)) $Perm.No))
  
  ))))
(check-sat)
; unsat
(pop) ; 13
; 0.29s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1779035
;  :arith-add-rows          508638
;  :arith-assert-diseq      65855
;  :arith-assert-lower      487261
;  :arith-assert-upper      397358
;  :arith-bound-prop        21258
;  :arith-conflicts         1263
;  :arith-eq-adapter        240953
;  :arith-fixed-eqs         311707
;  :arith-offset-eqs        114036
;  :arith-pivots            56981
;  :conflicts               3063
;  :datatype-accessor-ax    638
;  :datatype-constructor-ax 1709
;  :datatype-occurs-check   1309
;  :datatype-splits         1167
;  :decisions               153489
;  :del-clause              2456564
;  :final-checks            177
;  :interface-eqs           41
;  :max-generation          15
;  :max-memory              50.39
;  :memory                  45.66
;  :minimized-lits          405
;  :mk-bool-var             2790600
;  :mk-clause               2458060
;  :num-allocs              9034074
;  :num-checks              409
;  :propagations            998100
;  :quant-instantiations    1178386
;  :restarts                4
;  :rlimit-count            29947242
;  :time                    0.29)
; Final check if taken enough permissions
; Done removing quantified permissions
; Definitional axioms for snapshot map values
; [eval] valid_graph_vertices(this, p, V)
(push) ; 13
; [eval] this != null
; [eval] p != (None(): option[array])
; [eval] (None(): option[array])
; [eval] alen(opt_get1(p)) == V
; [eval] alen(opt_get1(p))
; [eval] opt_get1(p)
(push) ; 14
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 14
; Joined path conditions
(declare-const i1@322@03 Int)
(push) ; 14
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 15
; [then-branch: 185 | 0 <= i1@322@03 | live]
; [else-branch: 185 | !(0 <= i1@322@03) | live]
(push) ; 16
; [then-branch: 185 | 0 <= i1@322@03]
(assert (<= 0 i1@322@03))
; [eval] i1 < V
(pop) ; 16
(push) ; 16
; [else-branch: 185 | !(0 <= i1@322@03)]
(assert (not (<= 0 i1@322@03)))
(pop) ; 16
(pop) ; 15
; Joined path conditions
; Joined path conditions
(assert (and (< i1@322@03 V@12@03) (<= 0 i1@322@03)))
(declare-const $k@323@03 $Perm)
(assert ($Perm.isReadVar $k@323@03 $Perm.Write))
; [eval] aloc(opt_get1(p), i1)
; [eval] opt_get1(p)
(push) ; 15
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 15
; Joined path conditions
(push) ; 15
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 16
(assert (not (< i1@322@03 (alen<Int> (opt_get1 $Snap.unit p@15@03)))))
(check-sat)
; unsat
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1779035
;  :arith-add-rows          508639
;  :arith-assert-diseq      65856
;  :arith-assert-lower      487265
;  :arith-assert-upper      397359
;  :arith-bound-prop        21258
;  :arith-conflicts         1263
;  :arith-eq-adapter        240954
;  :arith-fixed-eqs         311707
;  :arith-offset-eqs        114036
;  :arith-pivots            56981
;  :conflicts               3063
;  :datatype-accessor-ax    638
;  :datatype-constructor-ax 1709
;  :datatype-occurs-check   1309
;  :datatype-splits         1167
;  :decisions               153489
;  :del-clause              2456564
;  :final-checks            177
;  :interface-eqs           41
;  :max-generation          15
;  :max-memory              50.39
;  :memory                  45.66
;  :minimized-lits          405
;  :mk-bool-var             2790606
;  :mk-clause               2458062
;  :num-allocs              9034251
;  :num-checks              410
;  :propagations            998101
;  :quant-instantiations    1178386
;  :restarts                4
;  :rlimit-count            29947573)
(assert (< i1@322@03 (alen<Int> (opt_get1 $Snap.unit p@15@03))))
(pop) ; 15
; Joined path conditions
(assert (< i1@322@03 (alen<Int> (opt_get1 $Snap.unit p@15@03))))
(pop) ; 14
(declare-fun inv@324@03 ($Ref) Int)
; Nested auxiliary terms: globals
(assert ($Perm.isReadVar $k@323@03 $Perm.Write))
; Nested auxiliary terms: non-globals
(assert (forall ((i1@322@03 Int)) (!
  (< i1@322@03 (alen<Int> (opt_get1 $Snap.unit p@15@03)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) i1@322@03))
  :qid |int-aux|)))
(push) ; 14
(assert (not (forall ((i1@322@03 Int)) (!
  (implies
    (and (< i1@322@03 V@12@03) (<= 0 i1@322@03))
    (or (= $k@323@03 $Perm.No) (< $Perm.No $k@323@03)))
  
  ))))
(check-sat)
; unsat
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1779035
;  :arith-add-rows          508640
;  :arith-assert-diseq      65857
;  :arith-assert-lower      487267
;  :arith-assert-upper      397360
;  :arith-bound-prop        21258
;  :arith-conflicts         1263
;  :arith-eq-adapter        240955
;  :arith-fixed-eqs         311707
;  :arith-offset-eqs        114036
;  :arith-pivots            56981
;  :conflicts               3064
;  :datatype-accessor-ax    638
;  :datatype-constructor-ax 1709
;  :datatype-occurs-check   1309
;  :datatype-splits         1167
;  :decisions               153489
;  :del-clause              2456566
;  :final-checks            177
;  :interface-eqs           41
;  :max-generation          15
;  :max-memory              50.39
;  :memory                  45.66
;  :minimized-lits          405
;  :mk-bool-var             2790613
;  :mk-clause               2458064
;  :num-allocs              9034677
;  :num-checks              411
;  :propagations            998102
;  :quant-instantiations    1178386
;  :restarts                4
;  :rlimit-count            29948120)
(declare-const sm@325@03 $FVF<Int>)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@180@03 r) V@12@03) (<= 0 (inv@180@03 r)))
        (< (inv@179@03 r) V@12@03))
      (<= 0 (inv@179@03 r)))
    (=
      ($FVF.lookup_int (as sm@325@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@325@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03))))))))))))))) r))
  :qid |qp.fvfValDef148|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@183@03 r) V@12@03) (<= 0 (inv@183@03 r)))
    (=
      ($FVF.lookup_int (as sm@325@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03)))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@325@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03)))))))))))))))) r))
  :qid |qp.fvfValDef149|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03)))))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@325@03  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef150|)))
; Check receiver injectivity
(push) ; 14
(assert (not (forall ((i11@322@03 Int) (i12@322@03 Int)) (!
  (implies
    (and
      (and
        (and
          (and (< i11@322@03 V@12@03) (<= 0 i11@322@03))
          ($FVF.loc_int ($FVF.lookup_int (as sm@325@03  $FVF<Int>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit p@15@03) i11@322@03)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit p@15@03) i11@322@03)))
        (< $Perm.No $k@323@03))
      (and
        (and
          (and (< i12@322@03 V@12@03) (<= 0 i12@322@03))
          ($FVF.loc_int ($FVF.lookup_int (as sm@325@03  $FVF<Int>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit p@15@03) i12@322@03)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit p@15@03) i12@322@03)))
        (< $Perm.No $k@323@03))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) i11@322@03)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) i12@322@03)))
    (= i11@322@03 i12@322@03))
  
  :qid |int-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1779075
;  :arith-add-rows          508647
;  :arith-assert-diseq      65858
;  :arith-assert-lower      487271
;  :arith-assert-upper      397360
;  :arith-bound-prop        21258
;  :arith-conflicts         1263
;  :arith-eq-adapter        240956
;  :arith-fixed-eqs         311707
;  :arith-offset-eqs        114036
;  :arith-pivots            56981
;  :conflicts               3065
;  :datatype-accessor-ax    638
;  :datatype-constructor-ax 1709
;  :datatype-occurs-check   1309
;  :datatype-splits         1167
;  :decisions               153489
;  :del-clause              2456577
;  :final-checks            177
;  :interface-eqs           41
;  :max-generation          15
;  :max-memory              50.39
;  :memory                  45.66
;  :minimized-lits          405
;  :mk-bool-var             2790677
;  :mk-clause               2458075
;  :num-allocs              9035782
;  :num-checks              412
;  :propagations            998104
;  :quant-instantiations    1178450
;  :restarts                4
;  :rlimit-count            29951727
;  :time                    0.00)
; Definitional axioms for inverse functions
(assert (forall ((i1@322@03 Int)) (!
  (implies
    (and (and (< i1@322@03 V@12@03) (<= 0 i1@322@03)) (< $Perm.No $k@323@03))
    (=
      (inv@324@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) i1@322@03))
      i1@322@03))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) i1@322@03))
  :qid |int-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and (< (inv@324@03 r) V@12@03) (<= 0 (inv@324@03 r)))
      (< $Perm.No $k@323@03))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) (inv@324@03 r))
      r))
  :pattern ((inv@324@03 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@324@03 r) V@12@03) (<= 0 (inv@324@03 r)))
    ($FVF.loc_int ($FVF.lookup_int (as sm@325@03  $FVF<Int>) r) r))
  :pattern ((inv@324@03 r))
  )))
; Precomputing data for removing quantified permissions
(define-fun pTaken@326@03 ((r $Ref)) $Perm
  (ite
    (and (< (inv@324@03 r) V@12@03) (<= 0 (inv@324@03 r)))
    ($Perm.min
      (ite
        (and
          (and
            (and (< (inv@180@03 r) V@12@03) (<= 0 (inv@180@03 r)))
            (< (inv@179@03 r) V@12@03))
          (<= 0 (inv@179@03 r)))
        $Perm.Write
        $Perm.No)
      $k@323@03)
    $Perm.No))
(define-fun pTaken@327@03 ((r $Ref)) $Perm
  (ite
    (and (< (inv@324@03 r) V@12@03) (<= 0 (inv@324@03 r)))
    ($Perm.min
      (ite
        (and (< (inv@183@03 r) V@12@03) (<= 0 (inv@183@03 r)))
        $Perm.Write
        $Perm.No)
      (- $k@323@03 (pTaken@326@03 r)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Constrain original permissions $k@323@03
(assert (forall ((r $Ref)) (!
  (implies
    (not
      (=
        (ite
          (and
            (and
              (and (< (inv@180@03 r) V@12@03) (<= 0 (inv@180@03 r)))
              (< (inv@179@03 r) V@12@03))
            (<= 0 (inv@179@03 r)))
          $Perm.Write
          $Perm.No)
        $Perm.No))
    (ite
      (and
        (and
          (and (< (inv@180@03 r) V@12@03) (<= 0 (inv@180@03 r)))
          (< (inv@179@03 r) V@12@03))
        (<= 0 (inv@179@03 r)))
      (<
        (ite
          (and (< (inv@324@03 r) V@12@03) (<= 0 (inv@324@03 r)))
          $k@323@03
          $Perm.No)
        $Perm.Write)
      (<
        (ite
          (and (< (inv@324@03 r) V@12@03) (<= 0 (inv@324@03 r)))
          $k@323@03
          $Perm.No)
        $Perm.No)))
  :pattern ((inv@180@03 r))
  :pattern ((inv@179@03 r))
  :pattern ((inv@324@03 r))
  :qid |qp.srp151|)))
; Intermediate check if already taken enough permissions
(set-option :timeout 500)
(push) ; 14
(assert (not (forall ((r $Ref)) (!
  (implies
    (and (< (inv@324@03 r) V@12@03) (<= 0 (inv@324@03 r)))
    (= (- $k@323@03 (pTaken@326@03 r)) $Perm.No))
  
  ))))
(check-sat)
; unknown
(pop) ; 14
; 0.50s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1810751
;  :arith-add-rows          521323
;  :arith-assert-diseq      66909
;  :arith-assert-lower      495403
;  :arith-assert-upper      404101
;  :arith-bound-prop        21820
;  :arith-conflicts         1300
;  :arith-eq-adapter        246083
;  :arith-fixed-eqs         315750
;  :arith-offset-eqs        116327
;  :arith-pivots            59148
;  :conflicts               3138
;  :datatype-accessor-ax    638
;  :datatype-constructor-ax 1717
;  :datatype-occurs-check   1309
;  :datatype-splits         1167
;  :decisions               157609
;  :del-clause              2523493
;  :final-checks            177
;  :interface-eqs           41
;  :max-generation          15
;  :max-memory              50.39
;  :memory                  45.46
;  :minimized-lits          430
;  :mk-bool-var             2859441
;  :mk-clause               2524995
;  :num-allocs              9220098
;  :num-checks              414
;  :propagations            1015747
;  :quant-instantiations    1203368
;  :restarts                4
;  :rlimit-count            30598324
;  :time                    0.50)
; Constrain original permissions $k@323@03
(assert (forall ((r $Ref)) (!
  (implies
    (not
      (=
        (ite
          (and (< (inv@183@03 r) V@12@03) (<= 0 (inv@183@03 r)))
          $Perm.Write
          $Perm.No)
        $Perm.No))
    (ite
      (and (< (inv@183@03 r) V@12@03) (<= 0 (inv@183@03 r)))
      (<
        (ite
          (and (< (inv@324@03 r) V@12@03) (<= 0 (inv@324@03 r)))
          $k@323@03
          $Perm.No)
        $Perm.Write)
      (<
        (ite
          (and (< (inv@324@03 r) V@12@03) (<= 0 (inv@324@03 r)))
          $k@323@03
          $Perm.No)
        $Perm.No)))
  :pattern ((inv@183@03 r))
  :pattern ((inv@324@03 r))
  :qid |qp.srp152|)))
; Intermediate check if already taken enough permissions
(push) ; 14
(assert (not (forall ((r $Ref)) (!
  (implies
    (and (< (inv@324@03 r) V@12@03) (<= 0 (inv@324@03 r)))
    (= (- (- $k@323@03 (pTaken@326@03 r)) (pTaken@327@03 r)) $Perm.No))
  
  ))))
(check-sat)
; unsat
(pop) ; 14
; 0.02s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1811654
;  :arith-add-rows          521563
;  :arith-assert-diseq      66942
;  :arith-assert-lower      495586
;  :arith-assert-upper      404231
;  :arith-bound-prop        21846
;  :arith-conflicts         1304
;  :arith-eq-adapter        246237
;  :arith-fixed-eqs         315867
;  :arith-offset-eqs        116392
;  :arith-pivots            59204
;  :conflicts               3149
;  :datatype-accessor-ax    638
;  :datatype-constructor-ax 1721
;  :datatype-occurs-check   1309
;  :datatype-splits         1167
;  :decisions               157643
;  :del-clause              2524840
;  :final-checks            177
;  :interface-eqs           41
;  :max-generation          15
;  :max-memory              50.39
;  :memory                  45.48
;  :minimized-lits          431
;  :mk-bool-var             2860869
;  :mk-clause               2526342
;  :num-allocs              9225693
;  :num-checks              415
;  :propagations            1016244
;  :quant-instantiations    1203912
;  :restarts                4
;  :rlimit-count            30626685
;  :time                    0.01)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@328@03 $FVF<Int>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (iff
    (Set_in r ($FVF.domain_int (as sm@328@03  $FVF<Int>)))
    (and
      (and (< (inv@324@03 r) V@12@03) (<= 0 (inv@324@03 r)))
      (< $Perm.No $k@323@03)))
  :pattern ((Set_in r ($FVF.domain_int (as sm@328@03  $FVF<Int>))))
  :qid |qp.fvfDomDef156|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@324@03 r) V@12@03) (<= 0 (inv@324@03 r)))
        (< $Perm.No $k@323@03))
      (and
        (and
          (and (< (inv@180@03 r) V@12@03) (<= 0 (inv@180@03 r)))
          (< (inv@179@03 r) V@12@03))
        (<= 0 (inv@179@03 r))))
    (=
      ($FVF.lookup_int (as sm@328@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@328@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03))))))))))))))) r))
  :qid |qp.fvfValDef153|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@324@03 r) V@12@03) (<= 0 (inv@324@03 r)))
        (< $Perm.No $k@323@03))
      (and (< (inv@183@03 r) V@12@03) (<= 0 (inv@183@03 r))))
    (=
      ($FVF.lookup_int (as sm@328@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03)))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@328@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03)))))))))))))))) r))
  :qid |qp.fvfValDef154|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03)))))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@328@03  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef155|)))
(pop) ; 13
; Joined path conditions
(assert ($Perm.isReadVar $k@323@03 $Perm.Write))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@180@03 r) V@12@03) (<= 0 (inv@180@03 r)))
        (< (inv@179@03 r) V@12@03))
      (<= 0 (inv@179@03 r)))
    (=
      ($FVF.lookup_int (as sm@325@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@325@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03))))))))))))))) r))
  :qid |qp.fvfValDef148|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@183@03 r) V@12@03) (<= 0 (inv@183@03 r)))
    (=
      ($FVF.lookup_int (as sm@325@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03)))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@325@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03)))))))))))))))) r))
  :qid |qp.fvfValDef149|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03)))))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@325@03  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef150|)))
(assert (forall ((i1@322@03 Int)) (!
  (implies
    (and (and (< i1@322@03 V@12@03) (<= 0 i1@322@03)) (< $Perm.No $k@323@03))
    (=
      (inv@324@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) i1@322@03))
      i1@322@03))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) i1@322@03))
  :qid |int-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and (< (inv@324@03 r) V@12@03) (<= 0 (inv@324@03 r)))
      (< $Perm.No $k@323@03))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) (inv@324@03 r))
      r))
  :pattern ((inv@324@03 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (iff
    (Set_in r ($FVF.domain_int (as sm@328@03  $FVF<Int>)))
    (and
      (and (< (inv@324@03 r) V@12@03) (<= 0 (inv@324@03 r)))
      (< $Perm.No $k@323@03)))
  :pattern ((Set_in r ($FVF.domain_int (as sm@328@03  $FVF<Int>))))
  :qid |qp.fvfDomDef156|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@324@03 r) V@12@03) (<= 0 (inv@324@03 r)))
        (< $Perm.No $k@323@03))
      (and
        (and
          (and (< (inv@180@03 r) V@12@03) (<= 0 (inv@180@03 r)))
          (< (inv@179@03 r) V@12@03))
        (<= 0 (inv@179@03 r))))
    (=
      ($FVF.lookup_int (as sm@328@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@328@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03))))))))))))))) r))
  :qid |qp.fvfValDef153|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@324@03 r) V@12@03) (<= 0 (inv@324@03 r)))
        (< $Perm.No $k@323@03))
      (and (< (inv@183@03 r) V@12@03) (<= 0 (inv@183@03 r))))
    (=
      ($FVF.lookup_int (as sm@328@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03)))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@328@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03)))))))))))))))) r))
  :qid |qp.fvfValDef154|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@168@03)))))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@328@03  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef155|)))
(assert (and
  (forall ((i1@322@03 Int)) (!
    (< i1@322@03 (alen<Int> (opt_get1 $Snap.unit p@15@03)))
    :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) i1@322@03))
    :qid |int-aux|))
  (forall ((r $Ref)) (!
    (implies
      (and (< (inv@324@03 r) V@12@03) (<= 0 (inv@324@03 r)))
      ($FVF.loc_int ($FVF.lookup_int (as sm@325@03  $FVF<Int>) r) r))
    :pattern ((inv@324@03 r))
    ))
  (forall ((r $Ref)) (!
    (implies
      (not
        (=
          (ite
            (and
              (and
                (and (< (inv@180@03 r) V@12@03) (<= 0 (inv@180@03 r)))
                (< (inv@179@03 r) V@12@03))
              (<= 0 (inv@179@03 r)))
            $Perm.Write
            $Perm.No)
          $Perm.No))
      (ite
        (and
          (and
            (and (< (inv@180@03 r) V@12@03) (<= 0 (inv@180@03 r)))
            (< (inv@179@03 r) V@12@03))
          (<= 0 (inv@179@03 r)))
        (<
          (ite
            (and (< (inv@324@03 r) V@12@03) (<= 0 (inv@324@03 r)))
            $k@323@03
            $Perm.No)
          $Perm.Write)
        (<
          (ite
            (and (< (inv@324@03 r) V@12@03) (<= 0 (inv@324@03 r)))
            $k@323@03
            $Perm.No)
          $Perm.No)))
    :pattern ((inv@180@03 r))
    :pattern ((inv@179@03 r))
    :pattern ((inv@324@03 r))
    :qid |qp.srp151|))
  (forall ((r $Ref)) (!
    (implies
      (not
        (=
          (ite
            (and (< (inv@183@03 r) V@12@03) (<= 0 (inv@183@03 r)))
            $Perm.Write
            $Perm.No)
          $Perm.No))
      (ite
        (and (< (inv@183@03 r) V@12@03) (<= 0 (inv@183@03 r)))
        (<
          (ite
            (and (< (inv@324@03 r) V@12@03) (<= 0 (inv@324@03 r)))
            $k@323@03
            $Perm.No)
          $Perm.Write)
        (<
          (ite
            (and (< (inv@324@03 r) V@12@03) (<= 0 (inv@324@03 r)))
            $k@323@03
            $Perm.No)
          $Perm.No)))
    :pattern ((inv@183@03 r))
    :pattern ((inv@324@03 r))
    :qid |qp.srp152|))))
(set-option :timeout 0)
(push) ; 13
(assert (not (valid_graph_vertices ($Snap.combine
  $Snap.unit
  ($Snap.combine
    $Snap.unit
    ($Snap.combine
      $Snap.unit
      ($SortWrappers.$FVF<Int>To$Snap (as sm@328@03  $FVF<Int>))))) this@9@03 p@15@03 V@12@03)))
(check-sat)
; unsat
(pop) ; 13
; 0.92s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1855045
;  :arith-add-rows          541955
;  :arith-assert-diseq      68653
;  :arith-assert-lower      508515
;  :arith-assert-upper      414031
;  :arith-bound-prop        22868
;  :arith-conflicts         1351
;  :arith-eq-adapter        253335
;  :arith-fixed-eqs         323428
;  :arith-offset-eqs        120769
;  :arith-pivots            62183
;  :conflicts               3231
;  :datatype-accessor-ax    641
;  :datatype-constructor-ax 1725
;  :datatype-occurs-check   1309
;  :datatype-splits         1167
;  :decisions               162786
;  :del-clause              2628196
;  :final-checks            177
;  :interface-eqs           41
;  :max-generation          15
;  :max-memory              50.39
;  :memory                  46.24
;  :minimized-lits          449
;  :mk-bool-var             2965831
;  :mk-clause               2629694
;  :num-allocs              9508117
;  :num-checks              416
;  :propagations            1043549
;  :quant-instantiations    1231984
;  :restarts                4
;  :rlimit-count            31415135
;  :time                    0.92)
(assert (valid_graph_vertices ($Snap.combine
  $Snap.unit
  ($Snap.combine
    $Snap.unit
    ($Snap.combine
      $Snap.unit
      ($SortWrappers.$FVF<Int>To$Snap (as sm@328@03  $FVF<Int>))))) this@9@03 p@15@03 V@12@03))
; [eval] 0 <= s
; [eval] s < V
; [eval] valid_graph_vertices1(this, queue, V)
(push) ; 13
; [eval] this != null
(pop) ; 13
; Joined path conditions
(declare-const i1@329@03 Int)
(push) ; 13
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 14
; [then-branch: 186 | 0 <= i1@329@03 | live]
; [else-branch: 186 | !(0 <= i1@329@03) | live]
(push) ; 15
; [then-branch: 186 | 0 <= i1@329@03]
(assert (<= 0 i1@329@03))
; [eval] i1 < V
(pop) ; 15
(push) ; 15
; [else-branch: 186 | !(0 <= i1@329@03)]
(assert (not (<= 0 i1@329@03)))
(pop) ; 15
(pop) ; 14
; Joined path conditions
; Joined path conditions
(assert (and (< i1@329@03 V@12@03) (<= 0 i1@329@03)))
; [eval] aloc(opt_get1(visited), i1)
; [eval] opt_get1(visited)
(push) ; 14
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 14
; Joined path conditions
(push) ; 14
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 15
(assert (not (< i1@329@03 (alen<Int> (opt_get1 $Snap.unit res@79@03)))))
(check-sat)
; unsat
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1855058
;  :arith-add-rows          541959
;  :arith-assert-diseq      68653
;  :arith-assert-lower      508517
;  :arith-assert-upper      414031
;  :arith-bound-prop        22868
;  :arith-conflicts         1351
;  :arith-eq-adapter        253335
;  :arith-fixed-eqs         323428
;  :arith-offset-eqs        120769
;  :arith-pivots            62183
;  :conflicts               3231
;  :datatype-accessor-ax    644
;  :datatype-constructor-ax 1725
;  :datatype-occurs-check   1309
;  :datatype-splits         1167
;  :decisions               162786
;  :del-clause              2628196
;  :final-checks            177
;  :interface-eqs           41
;  :max-generation          15
;  :max-memory              50.39
;  :memory                  46.25
;  :minimized-lits          449
;  :mk-bool-var             2965907
;  :mk-clause               2629759
;  :num-allocs              9508550
;  :num-checks              417
;  :propagations            1043560
;  :quant-instantiations    1231997
;  :restarts                4
;  :rlimit-count            31416001)
(assert (< i1@329@03 (alen<Int> (opt_get1 $Snap.unit res@79@03))))
(pop) ; 14
; Joined path conditions
(assert (< i1@329@03 (alen<Int> (opt_get1 $Snap.unit res@79@03))))
(pop) ; 13
(declare-fun inv@330@03 ($Ref) Int)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(assert (forall ((i1@329@03 Int)) (!
  (< i1@329@03 (alen<Int> (opt_get1 $Snap.unit res@79@03)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@79@03) i1@329@03))
  :qid |bool-aux|)))
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 13
(assert (not (forall ((i11@329@03 Int) (i12@329@03 Int)) (!
  (implies
    (and
      (and
        (and (< i11@329@03 V@12@03) (<= 0 i11@329@03))
        ($FVF.loc_bool ($FVF.lookup_bool (as sm@193@03  $FVF<Bool>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@79@03) i11@329@03)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@79@03) i11@329@03)))
      (and
        (and (< i12@329@03 V@12@03) (<= 0 i12@329@03))
        ($FVF.loc_bool ($FVF.lookup_bool (as sm@193@03  $FVF<Bool>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@79@03) i12@329@03)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@79@03) i12@329@03)))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@79@03) i11@329@03)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@79@03) i12@329@03)))
    (= i11@329@03 i12@329@03))
  
  :qid |bool-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1855078
;  :arith-add-rows          541964
;  :arith-assert-diseq      68654
;  :arith-assert-lower      508521
;  :arith-assert-upper      414031
;  :arith-bound-prop        22868
;  :arith-conflicts         1351
;  :arith-eq-adapter        253336
;  :arith-fixed-eqs         323428
;  :arith-offset-eqs        120769
;  :arith-pivots            62183
;  :conflicts               3232
;  :datatype-accessor-ax    644
;  :datatype-constructor-ax 1725
;  :datatype-occurs-check   1309
;  :datatype-splits         1167
;  :decisions               162786
;  :del-clause              2628207
;  :final-checks            177
;  :interface-eqs           41
;  :max-generation          15
;  :max-memory              50.39
;  :memory                  46.25
;  :minimized-lits          449
;  :mk-bool-var             2965945
;  :mk-clause               2629770
;  :num-allocs              9509146
;  :num-checks              418
;  :propagations            1043560
;  :quant-instantiations    1232031
;  :restarts                4
;  :rlimit-count            31417386
;  :time                    0.00)
; Definitional axioms for inverse functions
(assert (forall ((i1@329@03 Int)) (!
  (implies
    (and (< i1@329@03 V@12@03) (<= 0 i1@329@03))
    (=
      (inv@330@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@79@03) i1@329@03))
      i1@329@03))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@79@03) i1@329@03))
  :qid |bool-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@330@03 r) V@12@03) (<= 0 (inv@330@03 r)))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@79@03) (inv@330@03 r))
      r))
  :pattern ((inv@330@03 r))
  :qid |bool-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@330@03 r) V@12@03) (<= 0 (inv@330@03 r)))
    ($FVF.loc_bool ($FVF.lookup_bool (as sm@193@03  $FVF<Bool>) r) r))
  :pattern ((inv@330@03 r))
  )))
; Precomputing data for removing quantified permissions
(define-fun pTaken@331@03 ((r $Ref)) $Perm
  (ite
    (and (< (inv@330@03 r) V@12@03) (<= 0 (inv@330@03 r)))
    ($Perm.min
      (ite
        (and (< (inv@192@03 r) V@12@03) (<= 0 (inv@192@03 r)))
        $Perm.Write
        $Perm.No)
      $Perm.Write)
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 500)
(push) ; 13
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and (< (inv@192@03 r) V@12@03) (<= 0 (inv@192@03 r)))
        $Perm.Write
        $Perm.No)
      (pTaken@331@03 r))
    $Perm.No)
  
  ))))
(check-sat)
; unsat
(pop) ; 13
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1856754
;  :arith-add-rows          542398
;  :arith-assert-diseq      68696
;  :arith-assert-lower      508855
;  :arith-assert-upper      414228
;  :arith-bound-prop        22885
;  :arith-conflicts         1354
;  :arith-eq-adapter        253603
;  :arith-fixed-eqs         323646
;  :arith-offset-eqs        120923
;  :arith-pivots            62253
;  :conflicts               3253
;  :datatype-accessor-ax    644
;  :datatype-constructor-ax 1733
;  :datatype-occurs-check   1309
;  :datatype-splits         1167
;  :decisions               162858
;  :del-clause              2631037
;  :final-checks            177
;  :interface-eqs           41
;  :max-generation          15
;  :max-memory              50.39
;  :memory                  45.99
;  :minimized-lits          449
;  :mk-bool-var             2969046
;  :mk-clause               2632588
;  :num-allocs              9519358
;  :num-checks              420
;  :propagations            1044449
;  :quant-instantiations    1233135
;  :restarts                4
;  :rlimit-count            31460851
;  :time                    0.01)
; Intermediate check if already taken enough permissions
(push) ; 13
(assert (not (forall ((r $Ref)) (!
  (implies
    (and (< (inv@330@03 r) V@12@03) (<= 0 (inv@330@03 r)))
    (= (- $Perm.Write (pTaken@331@03 r)) $Perm.No))
  
  ))))
(check-sat)
; unsat
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1856790
;  :arith-add-rows          542419
;  :arith-assert-diseq      68698
;  :arith-assert-lower      508864
;  :arith-assert-upper      414238
;  :arith-bound-prop        22886
;  :arith-conflicts         1355
;  :arith-eq-adapter        253612
;  :arith-fixed-eqs         323652
;  :arith-offset-eqs        120923
;  :arith-pivots            62257
;  :conflicts               3254
;  :datatype-accessor-ax    644
;  :datatype-constructor-ax 1733
;  :datatype-occurs-check   1309
;  :datatype-splits         1167
;  :decisions               162858
;  :del-clause              2631124
;  :final-checks            177
;  :interface-eqs           41
;  :max-generation          15
;  :max-memory              50.39
;  :memory                  45.99
;  :minimized-lits          449
;  :mk-bool-var             2969167
;  :mk-clause               2632675
;  :num-allocs              9519942
;  :num-checks              421
;  :propagations            1044454
;  :quant-instantiations    1233171
;  :restarts                4
;  :rlimit-count            31462837
;  :time                    0.00)
; Final check if taken enough permissions
; Done removing quantified permissions
; Definitional axioms for snapshot map values
(pop) ; 12
(push) ; 12
; [else-branch: 170 | v@166@03 < V@12@03]
(assert (< v@166@03 V@12@03))
(pop) ; 12
(pop) ; 11
(pop) ; 10
(pop) ; 9
(push) ; 9
; [else-branch: 100 | |queue@102@03| == 0]
(assert (= (Seq_length queue@102@03) 0))
(pop) ; 9
; [eval] !!(|queue| == 0)
; [eval] !(|queue| == 0)
; [eval] |queue| == 0
; [eval] |queue|
(set-option :timeout 10)
(push) ; 9
(assert (not (not (= (Seq_length queue@102@03) 0))))
(check-sat)
; unknown
(pop) ; 9
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1857267
;  :arith-add-rows          543114
;  :arith-assert-diseq      68709
;  :arith-assert-lower      508971
;  :arith-assert-upper      414310
;  :arith-bound-prop        22908
;  :arith-conflicts         1357
;  :arith-eq-adapter        253708
;  :arith-fixed-eqs         323723
;  :arith-offset-eqs        120943
;  :arith-pivots            62418
;  :conflicts               3256
;  :datatype-accessor-ax    644
;  :datatype-constructor-ax 1737
;  :datatype-occurs-check   1309
;  :datatype-splits         1167
;  :decisions               162890
;  :del-clause              2632398
;  :final-checks            177
;  :interface-eqs           41
;  :max-generation          15
;  :max-memory              50.39
;  :memory                  45.10
;  :minimized-lits          449
;  :mk-bool-var             2969892
;  :mk-clause               2633276
;  :num-allocs              9522410
;  :num-checks              422
;  :propagations            1044690
;  :quant-instantiations    1233436
;  :restarts                4
;  :rlimit-count            31485847
;  :time                    0.01)
(push) ; 9
(assert (not (= (Seq_length queue@102@03) 0)))
(check-sat)
; unknown
(pop) ; 9
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1857934
;  :arith-add-rows          543368
;  :arith-assert-diseq      68726
;  :arith-assert-lower      509136
;  :arith-assert-upper      414427
;  :arith-bound-prop        22933
;  :arith-conflicts         1360
;  :arith-eq-adapter        253826
;  :arith-fixed-eqs         323839
;  :arith-offset-eqs        120973
;  :arith-pivots            62438
;  :conflicts               3259
;  :datatype-accessor-ax    644
;  :datatype-constructor-ax 1741
;  :datatype-occurs-check   1309
;  :datatype-splits         1167
;  :decisions               162951
;  :del-clause              2633384
;  :final-checks            177
;  :interface-eqs           41
;  :max-generation          15
;  :max-memory              50.39
;  :memory                  45.09
;  :minimized-lits          449
;  :mk-bool-var             2970931
;  :mk-clause               2634262
;  :num-allocs              9525833
;  :num-checks              423
;  :propagations            1045077
;  :quant-instantiations    1233791
;  :restarts                4
;  :rlimit-count            31502303
;  :time                    0.01)
; [then-branch: 187 | |queue@102@03| == 0 | live]
; [else-branch: 187 | |queue@102@03| != 0 | live]
(push) ; 9
; [then-branch: 187 | |queue@102@03| == 0]
(assert (= (Seq_length queue@102@03) 0))
; [exec]
; return := aloc(opt_get1(visited), t).bool
; [eval] aloc(opt_get1(visited), t)
; [eval] opt_get1(visited)
(push) ; 10
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 10
; Joined path conditions
(push) ; 10
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 11
(assert (not (< t@14@03 (alen<Int> (opt_get1 $Snap.unit res@79@03)))))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1857936
;  :arith-add-rows          543368
;  :arith-assert-diseq      68726
;  :arith-assert-lower      509137
;  :arith-assert-upper      414428
;  :arith-bound-prop        22933
;  :arith-conflicts         1360
;  :arith-eq-adapter        253827
;  :arith-fixed-eqs         323839
;  :arith-offset-eqs        120973
;  :arith-pivots            62438
;  :conflicts               3259
;  :datatype-accessor-ax    644
;  :datatype-constructor-ax 1741
;  :datatype-occurs-check   1309
;  :datatype-splits         1167
;  :decisions               162951
;  :del-clause              2633384
;  :final-checks            177
;  :interface-eqs           41
;  :max-generation          15
;  :max-memory              50.39
;  :memory                  45.09
;  :minimized-lits          449
;  :mk-bool-var             2970935
;  :mk-clause               2634265
;  :num-allocs              9525943
;  :num-checks              424
;  :propagations            1045079
;  :quant-instantiations    1233793
;  :restarts                4
;  :rlimit-count            31502425)
(assert (< t@14@03 (alen<Int> (opt_get1 $Snap.unit res@79@03))))
(pop) ; 10
; Joined path conditions
(assert (< t@14@03 (alen<Int> (opt_get1 $Snap.unit res@79@03))))
(assert ($FVF.loc_bool ($FVF.lookup_bool (as sm@130@03  $FVF<Bool>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit res@79@03) t@14@03)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit res@79@03) t@14@03)))
(push) ; 10
(assert (not (and
  (<
    (inv@129@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@79@03) t@14@03))
    V@12@03)
  (<=
    0
    (inv@129@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@79@03) t@14@03))))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1857955
;  :arith-add-rows          543388
;  :arith-assert-diseq      68726
;  :arith-assert-lower      509141
;  :arith-assert-upper      414433
;  :arith-bound-prop        22937
;  :arith-conflicts         1361
;  :arith-eq-adapter        253832
;  :arith-fixed-eqs         323843
;  :arith-offset-eqs        120973
;  :arith-pivots            62443
;  :conflicts               3260
;  :datatype-accessor-ax    644
;  :datatype-constructor-ax 1741
;  :datatype-occurs-check   1309
;  :datatype-splits         1167
;  :decisions               162951
;  :del-clause              2633384
;  :final-checks            177
;  :interface-eqs           41
;  :max-generation          15
;  :max-memory              50.39
;  :memory                  45.10
;  :minimized-lits          449
;  :mk-bool-var             2970982
;  :mk-clause               2634291
;  :num-allocs              9526337
;  :num-checks              425
;  :propagations            1045079
;  :quant-instantiations    1233813
;  :restarts                4
;  :rlimit-count            31503689)
(declare-const return@332@03 Bool)
(assert (=
  return@332@03
  ($FVF.lookup_bool (as sm@130@03  $FVF<Bool>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit res@79@03) t@14@03))))
; [exec]
; label end
; [exec]
; res := return
; [exec]
; label bubble
; [eval] exc == null
; [eval] exc == null ==> Gf != (None(): option[array])
; [eval] exc == null
(push) ; 10
(set-option :timeout 10)
(push) ; 11
(assert (not (not (= exc@89@03 $Ref.null))))
(check-sat)
; unknown
(pop) ; 11
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1858590
;  :arith-add-rows          544056
;  :arith-assert-diseq      68751
;  :arith-assert-lower      509333
;  :arith-assert-upper      414538
;  :arith-bound-prop        22980
;  :arith-conflicts         1365
;  :arith-eq-adapter        253939
;  :arith-fixed-eqs         323920
;  :arith-offset-eqs        121045
;  :arith-pivots            62493
;  :conflicts               3264
;  :datatype-accessor-ax    644
;  :datatype-constructor-ax 1745
;  :datatype-occurs-check   1309
;  :datatype-splits         1167
;  :decisions               163071
;  :del-clause              2634542
;  :final-checks            177
;  :interface-eqs           41
;  :max-generation          15
;  :max-memory              50.39
;  :memory                  45.19
;  :minimized-lits          449
;  :mk-bool-var             2972016
;  :mk-clause               2635451
;  :num-allocs              9529514
;  :num-checks              426
;  :propagations            1045556
;  :quant-instantiations    1234093
;  :restarts                4
;  :rlimit-count            31533043
;  :time                    0.01)
; [then-branch: 188 | exc@89@03 == Null | live]
; [else-branch: 188 | exc@89@03 != Null | dead]
(push) ; 11
; [then-branch: 188 | exc@89@03 == Null]
; [eval] Gf != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 11
(pop) ; 10
; Joined path conditions
(set-option :timeout 0)
(push) ; 10
(assert (not (implies
  (= exc@89@03 $Ref.null)
  (not (= Gf@11@03 (as None<option<array>>  option<array>))))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1858590
;  :arith-add-rows          544056
;  :arith-assert-diseq      68751
;  :arith-assert-lower      509333
;  :arith-assert-upper      414538
;  :arith-bound-prop        22980
;  :arith-conflicts         1365
;  :arith-eq-adapter        253939
;  :arith-fixed-eqs         323920
;  :arith-offset-eqs        121045
;  :arith-pivots            62493
;  :conflicts               3264
;  :datatype-accessor-ax    644
;  :datatype-constructor-ax 1745
;  :datatype-occurs-check   1309
;  :datatype-splits         1167
;  :decisions               163071
;  :del-clause              2634542
;  :final-checks            177
;  :interface-eqs           41
;  :max-generation          15
;  :max-memory              50.39
;  :memory                  45.19
;  :minimized-lits          449
;  :mk-bool-var             2972016
;  :mk-clause               2635451
;  :num-allocs              9529539
;  :num-checks              427
;  :propagations            1045556
;  :quant-instantiations    1234093
;  :restarts                4
;  :rlimit-count            31533063)
(assert (implies
  (= exc@89@03 $Ref.null)
  (not (= Gf@11@03 (as None<option<array>>  option<array>)))))
; [eval] exc == null ==> alen(opt_get1(Gf)) == V
; [eval] exc == null
(push) ; 10
(set-option :timeout 10)
(push) ; 11
(assert (not (not (= exc@89@03 $Ref.null))))
(check-sat)
; unknown
(pop) ; 11
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1859399
;  :arith-add-rows          544568
;  :arith-assert-diseq      68760
;  :arith-assert-lower      509515
;  :arith-assert-upper      414669
;  :arith-bound-prop        23014
;  :arith-conflicts         1373
;  :arith-eq-adapter        254058
;  :arith-fixed-eqs         324044
;  :arith-offset-eqs        121134
;  :arith-pivots            62526
;  :conflicts               3272
;  :datatype-accessor-ax    644
;  :datatype-constructor-ax 1749
;  :datatype-occurs-check   1309
;  :datatype-splits         1167
;  :decisions               163184
;  :del-clause              2635759
;  :final-checks            177
;  :interface-eqs           41
;  :max-generation          15
;  :max-memory              50.39
;  :memory                  45.11
;  :minimized-lits          449
;  :mk-bool-var             2973281
;  :mk-clause               2636668
;  :num-allocs              9533102
;  :num-checks              428
;  :propagations            1045919
;  :quant-instantiations    1234524
;  :restarts                4
;  :rlimit-count            31555767
;  :time                    0.01)
; [then-branch: 189 | exc@89@03 == Null | live]
; [else-branch: 189 | exc@89@03 != Null | dead]
(push) ; 11
; [then-branch: 189 | exc@89@03 == Null]
; [eval] alen(opt_get1(Gf)) == V
; [eval] alen(opt_get1(Gf))
; [eval] opt_get1(Gf)
(push) ; 12
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 12
; Joined path conditions
(pop) ; 11
(pop) ; 10
; Joined path conditions
(set-option :timeout 0)
(push) ; 10
(assert (not (implies
  (= exc@89@03 $Ref.null)
  (= (alen<Int> (opt_get1 $Snap.unit Gf@11@03)) V@12@03))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1859399
;  :arith-add-rows          544568
;  :arith-assert-diseq      68760
;  :arith-assert-lower      509515
;  :arith-assert-upper      414669
;  :arith-bound-prop        23014
;  :arith-conflicts         1373
;  :arith-eq-adapter        254058
;  :arith-fixed-eqs         324044
;  :arith-offset-eqs        121134
;  :arith-pivots            62526
;  :conflicts               3272
;  :datatype-accessor-ax    644
;  :datatype-constructor-ax 1749
;  :datatype-occurs-check   1309
;  :datatype-splits         1167
;  :decisions               163184
;  :del-clause              2635759
;  :final-checks            177
;  :interface-eqs           41
;  :max-generation          15
;  :max-memory              50.39
;  :memory                  45.11
;  :minimized-lits          449
;  :mk-bool-var             2973281
;  :mk-clause               2636668
;  :num-allocs              9533121
;  :num-checks              429
;  :propagations            1045919
;  :quant-instantiations    1234524
;  :restarts                4
;  :rlimit-count            31555792)
(assert (implies
  (= exc@89@03 $Ref.null)
  (= (alen<Int> (opt_get1 $Snap.unit Gf@11@03)) V@12@03)))
; [eval] exc == null
(set-option :timeout 10)
(push) ; 10
(assert (not (not (= exc@89@03 $Ref.null))))
(check-sat)
; unknown
(pop) ; 10
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1859798
;  :arith-add-rows          544782
;  :arith-assert-diseq      68761
;  :arith-assert-lower      509587
;  :arith-assert-upper      414727
;  :arith-bound-prop        23024
;  :arith-conflicts         1378
;  :arith-eq-adapter        254129
;  :arith-fixed-eqs         324101
;  :arith-offset-eqs        121152
;  :arith-pivots            62534
;  :conflicts               3277
;  :datatype-accessor-ax    644
;  :datatype-constructor-ax 1753
;  :datatype-occurs-check   1309
;  :datatype-splits         1167
;  :decisions               163224
;  :del-clause              2636307
;  :final-checks            177
;  :interface-eqs           41
;  :max-generation          15
;  :max-memory              50.39
;  :memory                  45.11
;  :minimized-lits          449
;  :mk-bool-var             2973959
;  :mk-clause               2637216
;  :num-allocs              9535467
;  :num-checks              430
;  :propagations            1046050
;  :quant-instantiations    1234772
;  :restarts                4
;  :rlimit-count            31567640
;  :time                    0.01)
; [then-branch: 190 | exc@89@03 == Null | live]
; [else-branch: 190 | exc@89@03 != Null | dead]
(push) ; 10
; [then-branch: 190 | exc@89@03 == Null]
(declare-const i1@333@03 Int)
(push) ; 11
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 12
; [then-branch: 191 | 0 <= i1@333@03 | live]
; [else-branch: 191 | !(0 <= i1@333@03) | live]
(push) ; 13
; [then-branch: 191 | 0 <= i1@333@03]
(assert (<= 0 i1@333@03))
; [eval] i1 < V
(pop) ; 13
(push) ; 13
; [else-branch: 191 | !(0 <= i1@333@03)]
(assert (not (<= 0 i1@333@03)))
(pop) ; 13
(pop) ; 12
; Joined path conditions
; Joined path conditions
(assert (and (< i1@333@03 V@12@03) (<= 0 i1@333@03)))
(declare-const $k@334@03 $Perm)
(assert ($Perm.isReadVar $k@334@03 $Perm.Write))
; [eval] aloc(opt_get1(Gf), i1)
; [eval] opt_get1(Gf)
(push) ; 12
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 12
; Joined path conditions
(push) ; 12
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 13
(assert (not (< i1@333@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))))
(check-sat)
; unsat
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1859798
;  :arith-add-rows          544783
;  :arith-assert-diseq      68762
;  :arith-assert-lower      509591
;  :arith-assert-upper      414728
;  :arith-bound-prop        23024
;  :arith-conflicts         1378
;  :arith-eq-adapter        254130
;  :arith-fixed-eqs         324101
;  :arith-offset-eqs        121152
;  :arith-pivots            62534
;  :conflicts               3277
;  :datatype-accessor-ax    644
;  :datatype-constructor-ax 1753
;  :datatype-occurs-check   1309
;  :datatype-splits         1167
;  :decisions               163224
;  :del-clause              2636307
;  :final-checks            177
;  :interface-eqs           41
;  :max-generation          15
;  :max-memory              50.39
;  :memory                  45.11
;  :minimized-lits          449
;  :mk-bool-var             2973965
;  :mk-clause               2637218
;  :num-allocs              9535633
;  :num-checks              431
;  :propagations            1046051
;  :quant-instantiations    1234772
;  :restarts                4
;  :rlimit-count            31567966)
(assert (< i1@333@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03))))
(pop) ; 12
; Joined path conditions
(assert (< i1@333@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03))))
(pop) ; 11
(declare-fun inv@335@03 ($Ref) Int)
; Nested auxiliary terms: globals
(assert ($Perm.isReadVar $k@334@03 $Perm.Write))
; Nested auxiliary terms: non-globals
(assert (forall ((i1@333@03 Int)) (!
  (< i1@333@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@333@03))
  :qid |option$array$-aux|)))
(push) ; 11
(assert (not (forall ((i1@333@03 Int)) (!
  (implies
    (and (< i1@333@03 V@12@03) (<= 0 i1@333@03))
    (or (= $k@334@03 $Perm.No) (< $Perm.No $k@334@03)))
  
  ))))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1859798
;  :arith-add-rows          544784
;  :arith-assert-diseq      68763
;  :arith-assert-lower      509593
;  :arith-assert-upper      414729
;  :arith-bound-prop        23024
;  :arith-conflicts         1378
;  :arith-eq-adapter        254131
;  :arith-fixed-eqs         324101
;  :arith-offset-eqs        121152
;  :arith-pivots            62534
;  :conflicts               3278
;  :datatype-accessor-ax    644
;  :datatype-constructor-ax 1753
;  :datatype-occurs-check   1309
;  :datatype-splits         1167
;  :decisions               163224
;  :del-clause              2636309
;  :final-checks            177
;  :interface-eqs           41
;  :max-generation          15
;  :max-memory              50.39
;  :memory                  45.11
;  :minimized-lits          449
;  :mk-bool-var             2973972
;  :mk-clause               2637220
;  :num-allocs              9536063
;  :num-checks              432
;  :propagations            1046052
;  :quant-instantiations    1234772
;  :restarts                4
;  :rlimit-count            31568512)
(declare-const sm@336@03 $FVF<option<array>>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (ite
          (and (< (inv@21@03 r) V@12@03) (<= 0 (inv@21@03 r)))
          $k@20@03
          $Perm.No)
        (pTaken@134@03 r)))
    (=
      ($FVF.lookup_option$array$ (as sm@336@03  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@18@03))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@336@03  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@18@03))))) r))
  :qid |qp.fvfValDef157|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@108@03 r) V@12@03) (<= 0 (inv@108@03 r)))
      (< $Perm.No $k@107@03)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@336@03  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@105@03))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@336@03  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@105@03))))) r))
  :qid |qp.fvfValDef158|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@18@03))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@105@03))))) r) r))
  :pattern (($FVF.lookup_option$array$ (as sm@336@03  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef159|)))
; Check receiver injectivity
(push) ; 11
(assert (not (forall ((i11@333@03 Int) (i12@333@03 Int)) (!
  (implies
    (and
      (and
        (and
          (and (< i11@333@03 V@12@03) (<= 0 i11@333@03))
          ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@336@03  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i11@333@03)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i11@333@03)))
        (< $Perm.No $k@334@03))
      (and
        (and
          (and (< i12@333@03 V@12@03) (<= 0 i12@333@03))
          ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@336@03  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i12@333@03)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i12@333@03)))
        (< $Perm.No $k@334@03))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i11@333@03)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i12@333@03)))
    (= i11@333@03 i12@333@03))
  
  :qid |option$array$-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1859812
;  :arith-add-rows          544792
;  :arith-assert-diseq      68764
;  :arith-assert-lower      509597
;  :arith-assert-upper      414729
;  :arith-bound-prop        23024
;  :arith-conflicts         1378
;  :arith-eq-adapter        254132
;  :arith-fixed-eqs         324101
;  :arith-offset-eqs        121152
;  :arith-pivots            62534
;  :conflicts               3279
;  :datatype-accessor-ax    644
;  :datatype-constructor-ax 1753
;  :datatype-occurs-check   1309
;  :datatype-splits         1167
;  :decisions               163224
;  :del-clause              2636332
;  :final-checks            177
;  :interface-eqs           41
;  :max-generation          15
;  :max-memory              50.39
;  :memory                  45.11
;  :minimized-lits          449
;  :mk-bool-var             2974020
;  :mk-clause               2637243
;  :num-allocs              9537077
;  :num-checks              433
;  :propagations            1046054
;  :quant-instantiations    1234794
;  :restarts                4
;  :rlimit-count            31571124)
; Definitional axioms for inverse functions
(assert (forall ((i1@333@03 Int)) (!
  (implies
    (and (and (< i1@333@03 V@12@03) (<= 0 i1@333@03)) (< $Perm.No $k@334@03))
    (=
      (inv@335@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@333@03))
      i1@333@03))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@333@03))
  :qid |option$array$-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and (< (inv@335@03 r) V@12@03) (<= 0 (inv@335@03 r)))
      (< $Perm.No $k@334@03))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) (inv@335@03 r))
      r))
  :pattern ((inv@335@03 r))
  :qid |option$array$-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@335@03 r) V@12@03) (<= 0 (inv@335@03 r)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@336@03  $FVF<option<array>>) r) r))
  :pattern ((inv@335@03 r))
  )))
; Precomputing data for removing quantified permissions
(define-fun pTaken@337@03 ((r $Ref)) $Perm
  (ite
    (and (< (inv@335@03 r) V@12@03) (<= 0 (inv@335@03 r)))
    ($Perm.min
      (-
        (ite
          (and (< (inv@21@03 r) V@12@03) (<= 0 (inv@21@03 r)))
          $k@20@03
          $Perm.No)
        (pTaken@134@03 r))
      $k@334@03)
    $Perm.No))
(define-fun pTaken@338@03 ((r $Ref)) $Perm
  (ite
    (and (< (inv@335@03 r) V@12@03) (<= 0 (inv@335@03 r)))
    ($Perm.min
      (ite
        (and (< (inv@108@03 r) V@12@03) (<= 0 (inv@108@03 r)))
        $k@107@03
        $Perm.No)
      (- $k@334@03 (pTaken@337@03 r)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Constrain original permissions $k@334@03
(assert (forall ((r $Ref)) (!
  (implies
    (not
      (=
        (-
          (ite
            (and (< (inv@21@03 r) V@12@03) (<= 0 (inv@21@03 r)))
            $k@20@03
            $Perm.No)
          (pTaken@134@03 r))
        $Perm.No))
    (<
      (ite
        (and (< (inv@335@03 r) V@12@03) (<= 0 (inv@335@03 r)))
        $k@334@03
        $Perm.No)
      (-
        (ite
          (and (< (inv@21@03 r) V@12@03) (<= 0 (inv@21@03 r)))
          $k@20@03
          $Perm.No)
        (pTaken@134@03 r))))
  :pattern ((inv@21@03 r))
  :pattern ((inv@335@03 r))
  :qid |qp.srp160|)))
; Intermediate check if already taken enough permissions
(set-option :timeout 500)
(push) ; 11
(assert (not (forall ((r $Ref)) (!
  (implies
    (and (< (inv@335@03 r) V@12@03) (<= 0 (inv@335@03 r)))
    (= (- $k@334@03 (pTaken@337@03 r)) $Perm.No))
  
  ))))
(check-sat)
; unsat
(pop) ; 11
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1860853
;  :arith-add-rows          545344
;  :arith-assert-diseq      68793
;  :arith-assert-lower      509842
;  :arith-assert-upper      414898
;  :arith-bound-prop        23060
;  :arith-conflicts         1388
;  :arith-eq-adapter        254342
;  :arith-fixed-eqs         324257
;  :arith-offset-eqs        121230
;  :arith-pivots            62588
;  :conflicts               3307
;  :datatype-accessor-ax    644
;  :datatype-constructor-ax 1761
;  :datatype-occurs-check   1309
;  :datatype-splits         1167
;  :decisions               163326
;  :del-clause              2637695
;  :final-checks            177
;  :interface-eqs           41
;  :max-generation          15
;  :max-memory              50.39
;  :memory                  45.15
;  :minimized-lits          450
;  :mk-bool-var             2975738
;  :mk-clause               2638639
;  :num-allocs              9544161
;  :num-checks              435
;  :propagations            1046516
;  :quant-instantiations    1235342
;  :restarts                4
;  :rlimit-count            31599812
;  :time                    0.01)
; Final check if taken enough permissions
; Done removing quantified permissions
; Definitional axioms for snapshot map values
; [eval] exc == null ==> (forall i1: Int :: { aloc(opt_get1(Gf), i1) } 0 <= i1 && i1 < V ==> aloc(opt_get1(Gf), i1).option$array$ != (None(): option[array]))
; [eval] exc == null
(push) ; 11
(set-option :timeout 10)
(push) ; 12
(assert (not (not (= exc@89@03 $Ref.null))))
(check-sat)
; unknown
(pop) ; 12
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1861424
;  :arith-add-rows          545550
;  :arith-assert-diseq      68810
;  :arith-assert-lower      509984
;  :arith-assert-upper      414993
;  :arith-bound-prop        23074
;  :arith-conflicts         1391
;  :arith-eq-adapter        254435
;  :arith-fixed-eqs         324319
;  :arith-offset-eqs        121263
;  :arith-pivots            62606
;  :conflicts               3310
;  :datatype-accessor-ax    644
;  :datatype-constructor-ax 1765
;  :datatype-occurs-check   1309
;  :datatype-splits         1167
;  :decisions               163463
;  :del-clause              2639033
;  :final-checks            177
;  :interface-eqs           41
;  :max-generation          15
;  :max-memory              50.39
;  :memory                  45.19
;  :minimized-lits          450
;  :mk-bool-var             2976847
;  :mk-clause               2639977
;  :num-allocs              9546631
;  :num-checks              436
;  :propagations            1046949
;  :quant-instantiations    1235632
;  :restarts                4
;  :rlimit-count            31616288
;  :time                    0.01)
; [then-branch: 192 | exc@89@03 == Null | live]
; [else-branch: 192 | exc@89@03 != Null | dead]
(push) ; 12
; [then-branch: 192 | exc@89@03 == Null]
; [eval] (forall i1: Int :: { aloc(opt_get1(Gf), i1) } 0 <= i1 && i1 < V ==> aloc(opt_get1(Gf), i1).option$array$ != (None(): option[array]))
(declare-const i1@339@03 Int)
(push) ; 13
; [eval] 0 <= i1 && i1 < V ==> aloc(opt_get1(Gf), i1).option$array$ != (None(): option[array])
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 14
; [then-branch: 193 | 0 <= i1@339@03 | live]
; [else-branch: 193 | !(0 <= i1@339@03) | live]
(push) ; 15
; [then-branch: 193 | 0 <= i1@339@03]
(assert (<= 0 i1@339@03))
; [eval] i1 < V
(pop) ; 15
(push) ; 15
; [else-branch: 193 | !(0 <= i1@339@03)]
(assert (not (<= 0 i1@339@03)))
(pop) ; 15
(pop) ; 14
; Joined path conditions
; Joined path conditions
(push) ; 14
; [then-branch: 194 | i1@339@03 < V@12@03 && 0 <= i1@339@03 | live]
; [else-branch: 194 | !(i1@339@03 < V@12@03 && 0 <= i1@339@03) | live]
(push) ; 15
; [then-branch: 194 | i1@339@03 < V@12@03 && 0 <= i1@339@03]
(assert (and (< i1@339@03 V@12@03) (<= 0 i1@339@03)))
; [eval] aloc(opt_get1(Gf), i1).option$array$ != (None(): option[array])
; [eval] aloc(opt_get1(Gf), i1)
; [eval] opt_get1(Gf)
(push) ; 16
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 16
; Joined path conditions
(push) ; 16
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 17
(assert (not (< i1@339@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))))
(check-sat)
; unsat
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1861424
;  :arith-add-rows          545551
;  :arith-assert-diseq      68810
;  :arith-assert-lower      509986
;  :arith-assert-upper      414993
;  :arith-bound-prop        23074
;  :arith-conflicts         1391
;  :arith-eq-adapter        254435
;  :arith-fixed-eqs         324319
;  :arith-offset-eqs        121263
;  :arith-pivots            62606
;  :conflicts               3310
;  :datatype-accessor-ax    644
;  :datatype-constructor-ax 1765
;  :datatype-occurs-check   1309
;  :datatype-splits         1167
;  :decisions               163463
;  :del-clause              2639033
;  :final-checks            177
;  :interface-eqs           41
;  :max-generation          15
;  :max-memory              50.39
;  :memory                  45.20
;  :minimized-lits          450
;  :mk-bool-var             2976849
;  :mk-clause               2639977
;  :num-allocs              9546736
;  :num-checks              437
;  :propagations            1046949
;  :quant-instantiations    1235632
;  :restarts                4
;  :rlimit-count            31616484)
(assert (< i1@339@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03))))
(pop) ; 16
; Joined path conditions
(assert (< i1@339@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@336@03  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@339@03)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@339@03)))
(push) ; 16
(assert (not (<
  $Perm.No
  (+
    (-
      (ite
        (and
          (<
            (inv@21@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@339@03))
            V@12@03)
          (<=
            0
            (inv@21@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@339@03))))
        $k@20@03
        $Perm.No)
      (pTaken@134@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@339@03)))
    (ite
      (and
        (<
          (inv@108@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@339@03))
          V@12@03)
        (<=
          0
          (inv@108@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@339@03))))
      $k@107@03
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1861538
;  :arith-add-rows          545667
;  :arith-assert-diseq      68823
;  :arith-assert-lower      510041
;  :arith-assert-upper      415022
;  :arith-bound-prop        23102
;  :arith-conflicts         1394
;  :arith-eq-adapter        254468
;  :arith-fixed-eqs         324339
;  :arith-offset-eqs        121279
;  :arith-pivots            62637
;  :conflicts               3316
;  :datatype-accessor-ax    644
;  :datatype-constructor-ax 1765
;  :datatype-occurs-check   1309
;  :datatype-splits         1167
;  :decisions               163468
;  :del-clause              2639113
;  :final-checks            177
;  :interface-eqs           41
;  :max-generation          15
;  :max-memory              50.39
;  :memory                  45.21
;  :minimized-lits          453
;  :mk-bool-var             2977076
;  :mk-clause               2640132
;  :num-allocs              9548075
;  :num-checks              438
;  :propagations            1046995
;  :quant-instantiations    1235680
;  :restarts                4
;  :rlimit-count            31621991
;  :time                    0.00)
; [eval] (None(): option[array])
(pop) ; 15
(push) ; 15
; [else-branch: 194 | !(i1@339@03 < V@12@03 && 0 <= i1@339@03)]
(assert (not (and (< i1@339@03 V@12@03) (<= 0 i1@339@03))))
(pop) ; 15
(pop) ; 14
; Joined path conditions
(assert (implies
  (and (< i1@339@03 V@12@03) (<= 0 i1@339@03))
  (and
    (< i1@339@03 V@12@03)
    (<= 0 i1@339@03)
    (< i1@339@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@336@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@339@03)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@339@03)))))
; Joined path conditions
(pop) ; 13
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@339@03 Int)) (!
  (implies
    (and (< i1@339@03 V@12@03) (<= 0 i1@339@03))
    (and
      (< i1@339@03 V@12@03)
      (<= 0 i1@339@03)
      (< i1@339@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@336@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@339@03)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@339@03))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@339@03))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 12
(pop) ; 11
; Joined path conditions
(assert (implies
  (= exc@89@03 $Ref.null)
  (forall ((i1@339@03 Int)) (!
    (implies
      (and (< i1@339@03 V@12@03) (<= 0 i1@339@03))
      (and
        (< i1@339@03 V@12@03)
        (<= 0 i1@339@03)
        (< i1@339@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@336@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@339@03)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@339@03))))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@339@03))
    :qid |prog.l<no position>-aux|))))
(push) ; 11
(assert (not (implies
  (= exc@89@03 $Ref.null)
  (forall ((i1@339@03 Int)) (!
    (implies
      (and (< i1@339@03 V@12@03) (<= 0 i1@339@03))
      (not
        (=
          ($FVF.lookup_option$array$ (as sm@336@03  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@339@03))
          (as None<option<array>>  option<array>))))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@339@03))
    :qid |prog.l<no position>|)))))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1861906
;  :arith-add-rows          545766
;  :arith-assert-diseq      68829
;  :arith-assert-lower      510116
;  :arith-assert-upper      415072
;  :arith-bound-prop        23118
;  :arith-conflicts         1395
;  :arith-eq-adapter        254539
;  :arith-fixed-eqs         324389
;  :arith-offset-eqs        121304
;  :arith-pivots            62664
;  :conflicts               3334
;  :datatype-accessor-ax    644
;  :datatype-constructor-ax 1769
;  :datatype-occurs-check   1309
;  :datatype-splits         1167
;  :decisions               163488
;  :del-clause              2639620
;  :final-checks            177
;  :interface-eqs           41
;  :max-generation          15
;  :max-memory              50.39
;  :memory                  45.19
;  :minimized-lits          453
;  :mk-bool-var             2977626
;  :mk-clause               2640564
;  :num-allocs              9550530
;  :num-checks              439
;  :propagations            1047165
;  :quant-instantiations    1235879
;  :restarts                4
;  :rlimit-count            31632465
;  :time                    0.01)
(assert (implies
  (= exc@89@03 $Ref.null)
  (forall ((i1@339@03 Int)) (!
    (implies
      (and (< i1@339@03 V@12@03) (<= 0 i1@339@03))
      (not
        (=
          ($FVF.lookup_option$array$ (as sm@336@03  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@339@03))
          (as None<option<array>>  option<array>))))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@339@03))
    :qid |prog.l<no position>|))))
; [eval] exc == null ==> (forall i1: Int :: { alen(opt_get1(aloc(opt_get1(Gf), i1).option$array$)) } 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(Gf), i1).option$array$)) == V)
; [eval] exc == null
(push) ; 11
(set-option :timeout 10)
(push) ; 12
(assert (not (not (= exc@89@03 $Ref.null))))
(check-sat)
; unknown
(pop) ; 12
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1862498
;  :arith-add-rows          546103
;  :arith-assert-diseq      68842
;  :arith-assert-lower      510257
;  :arith-assert-upper      415171
;  :arith-bound-prop        23136
;  :arith-conflicts         1400
;  :arith-eq-adapter        254627
;  :arith-fixed-eqs         324444
;  :arith-offset-eqs        121350
;  :arith-pivots            62689
;  :conflicts               3339
;  :datatype-accessor-ax    644
;  :datatype-constructor-ax 1773
;  :datatype-occurs-check   1309
;  :datatype-splits         1167
;  :decisions               163664
;  :del-clause              2641382
;  :final-checks            177
;  :interface-eqs           41
;  :max-generation          15
;  :max-memory              50.39
;  :memory                  45.20
;  :minimized-lits          453
;  :mk-bool-var             2978988
;  :mk-clause               2642326
;  :num-allocs              9553007
;  :num-checks              440
;  :propagations            1047679
;  :quant-instantiations    1236200
;  :restarts                4
;  :rlimit-count            31653490
;  :time                    0.01)
; [then-branch: 195 | exc@89@03 == Null | live]
; [else-branch: 195 | exc@89@03 != Null | dead]
(push) ; 12
; [then-branch: 195 | exc@89@03 == Null]
; [eval] (forall i1: Int :: { alen(opt_get1(aloc(opt_get1(Gf), i1).option$array$)) } 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(Gf), i1).option$array$)) == V)
(declare-const i1@340@03 Int)
(push) ; 13
; [eval] 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(Gf), i1).option$array$)) == V
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 14
; [then-branch: 196 | 0 <= i1@340@03 | live]
; [else-branch: 196 | !(0 <= i1@340@03) | live]
(push) ; 15
; [then-branch: 196 | 0 <= i1@340@03]
(assert (<= 0 i1@340@03))
; [eval] i1 < V
(pop) ; 15
(push) ; 15
; [else-branch: 196 | !(0 <= i1@340@03)]
(assert (not (<= 0 i1@340@03)))
(pop) ; 15
(pop) ; 14
; Joined path conditions
; Joined path conditions
(push) ; 14
; [then-branch: 197 | i1@340@03 < V@12@03 && 0 <= i1@340@03 | live]
; [else-branch: 197 | !(i1@340@03 < V@12@03 && 0 <= i1@340@03) | live]
(push) ; 15
; [then-branch: 197 | i1@340@03 < V@12@03 && 0 <= i1@340@03]
(assert (and (< i1@340@03 V@12@03) (<= 0 i1@340@03)))
; [eval] alen(opt_get1(aloc(opt_get1(Gf), i1).option$array$)) == V
; [eval] alen(opt_get1(aloc(opt_get1(Gf), i1).option$array$))
; [eval] opt_get1(aloc(opt_get1(Gf), i1).option$array$)
; [eval] aloc(opt_get1(Gf), i1)
; [eval] opt_get1(Gf)
(push) ; 16
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 16
; Joined path conditions
(push) ; 16
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 17
(assert (not (< i1@340@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))))
(check-sat)
; unsat
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1862498
;  :arith-add-rows          546104
;  :arith-assert-diseq      68842
;  :arith-assert-lower      510259
;  :arith-assert-upper      415171
;  :arith-bound-prop        23136
;  :arith-conflicts         1400
;  :arith-eq-adapter        254627
;  :arith-fixed-eqs         324444
;  :arith-offset-eqs        121350
;  :arith-pivots            62689
;  :conflicts               3339
;  :datatype-accessor-ax    644
;  :datatype-constructor-ax 1773
;  :datatype-occurs-check   1309
;  :datatype-splits         1167
;  :decisions               163664
;  :del-clause              2641382
;  :final-checks            177
;  :interface-eqs           41
;  :max-generation          15
;  :max-memory              50.39
;  :memory                  45.20
;  :minimized-lits          453
;  :mk-bool-var             2978990
;  :mk-clause               2642326
;  :num-allocs              9553112
;  :num-checks              441
;  :propagations            1047679
;  :quant-instantiations    1236200
;  :restarts                4
;  :rlimit-count            31653686)
(assert (< i1@340@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03))))
(pop) ; 16
; Joined path conditions
(assert (< i1@340@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@336@03  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@340@03)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@340@03)))
(push) ; 16
(assert (not (<
  $Perm.No
  (+
    (-
      (ite
        (and
          (<
            (inv@21@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@340@03))
            V@12@03)
          (<=
            0
            (inv@21@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@340@03))))
        $k@20@03
        $Perm.No)
      (pTaken@134@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@340@03)))
    (ite
      (and
        (<
          (inv@108@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@340@03))
          V@12@03)
        (<=
          0
          (inv@108@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@340@03))))
      $k@107@03
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 16
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1862902
;  :arith-add-rows          546277
;  :arith-assert-diseq      68852
;  :arith-assert-lower      510349
;  :arith-assert-upper      415227
;  :arith-bound-prop        23160
;  :arith-conflicts         1403
;  :arith-eq-adapter        254705
;  :arith-fixed-eqs         324501
;  :arith-offset-eqs        121376
;  :arith-pivots            62712
;  :conflicts               3358
;  :datatype-accessor-ax    644
;  :datatype-constructor-ax 1777
;  :datatype-occurs-check   1309
;  :datatype-splits         1167
;  :decisions               163685
;  :del-clause              2641794
;  :final-checks            177
;  :interface-eqs           41
;  :max-generation          15
;  :max-memory              50.39
;  :memory                  45.21
;  :minimized-lits          453
;  :mk-bool-var             2979687
;  :mk-clause               2642813
;  :num-allocs              9555886
;  :num-checks              442
;  :propagations            1047857
;  :quant-instantiations    1236399
;  :restarts                4
;  :rlimit-count            31664180
;  :time                    0.01)
(push) ; 16
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 17
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@336@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@340@03))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1862902
;  :arith-add-rows          546277
;  :arith-assert-diseq      68852
;  :arith-assert-lower      510349
;  :arith-assert-upper      415227
;  :arith-bound-prop        23160
;  :arith-conflicts         1403
;  :arith-eq-adapter        254705
;  :arith-fixed-eqs         324501
;  :arith-offset-eqs        121376
;  :arith-pivots            62712
;  :conflicts               3359
;  :datatype-accessor-ax    644
;  :datatype-constructor-ax 1777
;  :datatype-occurs-check   1309
;  :datatype-splits         1167
;  :decisions               163685
;  :del-clause              2641794
;  :final-checks            177
;  :interface-eqs           41
;  :max-generation          15
;  :max-memory              50.39
;  :memory                  45.21
;  :minimized-lits          453
;  :mk-bool-var             2979687
;  :mk-clause               2642813
;  :num-allocs              9555976
;  :num-checks              443
;  :propagations            1047857
;  :quant-instantiations    1236399
;  :restarts                4
;  :rlimit-count            31664275)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@336@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@340@03))
    (as None<option<array>>  option<array>))))
(pop) ; 16
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@336@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@340@03))
    (as None<option<array>>  option<array>))))
(pop) ; 15
(push) ; 15
; [else-branch: 197 | !(i1@340@03 < V@12@03 && 0 <= i1@340@03)]
(assert (not (and (< i1@340@03 V@12@03) (<= 0 i1@340@03))))
(pop) ; 15
(pop) ; 14
; Joined path conditions
(assert (implies
  (and (< i1@340@03 V@12@03) (<= 0 i1@340@03))
  (and
    (< i1@340@03 V@12@03)
    (<= 0 i1@340@03)
    (< i1@340@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@336@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@340@03)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@340@03))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@336@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@340@03))
        (as None<option<array>>  option<array>))))))
; Joined path conditions
(pop) ; 13
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@340@03 Int)) (!
  (implies
    (and (< i1@340@03 V@12@03) (<= 0 i1@340@03))
    (and
      (< i1@340@03 V@12@03)
      (<= 0 i1@340@03)
      (< i1@340@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@336@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@340@03)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@340@03))
      (not
        (=
          ($FVF.lookup_option$array$ (as sm@336@03  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@340@03))
          (as None<option<array>>  option<array>)))))
  :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@336@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@340@03)))))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 12
(pop) ; 11
; Joined path conditions
(assert (implies
  (= exc@89@03 $Ref.null)
  (forall ((i1@340@03 Int)) (!
    (implies
      (and (< i1@340@03 V@12@03) (<= 0 i1@340@03))
      (and
        (< i1@340@03 V@12@03)
        (<= 0 i1@340@03)
        (< i1@340@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@336@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@340@03)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@340@03))
        (not
          (=
            ($FVF.lookup_option$array$ (as sm@336@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@340@03))
            (as None<option<array>>  option<array>)))))
    :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@336@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@340@03)))))
    :qid |prog.l<no position>-aux|))))
(push) ; 11
(assert (not (implies
  (= exc@89@03 $Ref.null)
  (forall ((i1@340@03 Int)) (!
    (implies
      (and (< i1@340@03 V@12@03) (<= 0 i1@340@03))
      (=
        (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@336@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@340@03))))
        V@12@03))
    :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@336@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@340@03)))))
    :qid |prog.l<no position>|)))))
(check-sat)
; unsat
(pop) ; 11
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1863304
;  :arith-add-rows          546404
;  :arith-assert-diseq      68860
;  :arith-assert-lower      510426
;  :arith-assert-upper      415278
;  :arith-bound-prop        23180
;  :arith-conflicts         1404
;  :arith-eq-adapter        254776
;  :arith-fixed-eqs         324554
;  :arith-offset-eqs        121402
;  :arith-pivots            62743
;  :conflicts               3377
;  :datatype-accessor-ax    644
;  :datatype-constructor-ax 1781
;  :datatype-occurs-check   1309
;  :datatype-splits         1167
;  :decisions               163707
;  :del-clause              2642323
;  :final-checks            177
;  :interface-eqs           41
;  :max-generation          15
;  :max-memory              50.39
;  :memory                  45.20
;  :minimized-lits          453
;  :mk-bool-var             2980274
;  :mk-clause               2643267
;  :num-allocs              9558584
;  :num-checks              444
;  :propagations            1048048
;  :quant-instantiations    1236609
;  :restarts                4
;  :rlimit-count            31675295
;  :time                    0.01)
(assert (implies
  (= exc@89@03 $Ref.null)
  (forall ((i1@340@03 Int)) (!
    (implies
      (and (< i1@340@03 V@12@03) (<= 0 i1@340@03))
      (=
        (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@336@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@340@03))))
        V@12@03))
    :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@336@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@340@03)))))
    :qid |prog.l<no position>|))))
; [eval] exc == null ==> (forall i1: Int :: { aloc(opt_get1(Gf), i1) } (forall i2: Int :: { aloc(opt_get1(Gf), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(Gf), i1).option$array$ == aloc(opt_get1(Gf), i2).option$array$ ==> i1 == i2))
; [eval] exc == null
(push) ; 11
(set-option :timeout 10)
(push) ; 12
(assert (not (not (= exc@89@03 $Ref.null))))
(check-sat)
; unknown
(pop) ; 12
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1863866
;  :arith-add-rows          546660
;  :arith-assert-diseq      68876
;  :arith-assert-lower      510574
;  :arith-assert-upper      415377
;  :arith-bound-prop        23195
;  :arith-conflicts         1407
;  :arith-eq-adapter        254867
;  :arith-fixed-eqs         324614
;  :arith-offset-eqs        121453
;  :arith-pivots            62758
;  :conflicts               3380
;  :datatype-accessor-ax    644
;  :datatype-constructor-ax 1785
;  :datatype-occurs-check   1309
;  :datatype-splits         1167
;  :decisions               163836
;  :del-clause              2643606
;  :final-checks            177
;  :interface-eqs           41
;  :max-generation          15
;  :max-memory              50.39
;  :memory                  45.20
;  :minimized-lits          453
;  :mk-bool-var             2981325
;  :mk-clause               2644550
;  :num-allocs              9560837
;  :num-checks              445
;  :propagations            1048505
;  :quant-instantiations    1236876
;  :restarts                4
;  :rlimit-count            31692187
;  :time                    0.01)
; [then-branch: 198 | exc@89@03 == Null | live]
; [else-branch: 198 | exc@89@03 != Null | dead]
(push) ; 12
; [then-branch: 198 | exc@89@03 == Null]
; [eval] (forall i1: Int :: { aloc(opt_get1(Gf), i1) } (forall i2: Int :: { aloc(opt_get1(Gf), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(Gf), i1).option$array$ == aloc(opt_get1(Gf), i2).option$array$ ==> i1 == i2))
(declare-const i1@341@03 Int)
(push) ; 13
; [eval] (forall i2: Int :: { aloc(opt_get1(Gf), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(Gf), i1).option$array$ == aloc(opt_get1(Gf), i2).option$array$ ==> i1 == i2)
(declare-const i2@342@03 Int)
(push) ; 14
; [eval] 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(Gf), i1).option$array$ == aloc(opt_get1(Gf), i2).option$array$ ==> i1 == i2
; [eval] 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(Gf), i1).option$array$ == aloc(opt_get1(Gf), i2).option$array$
; [eval] 0 <= i1
(push) ; 15
; [then-branch: 199 | 0 <= i1@341@03 | live]
; [else-branch: 199 | !(0 <= i1@341@03) | live]
(push) ; 16
; [then-branch: 199 | 0 <= i1@341@03]
(assert (<= 0 i1@341@03))
; [eval] i1 < V
(push) ; 17
; [then-branch: 200 | i1@341@03 < V@12@03 | live]
; [else-branch: 200 | !(i1@341@03 < V@12@03) | live]
(push) ; 18
; [then-branch: 200 | i1@341@03 < V@12@03]
(assert (< i1@341@03 V@12@03))
; [eval] 0 <= i2
(push) ; 19
; [then-branch: 201 | 0 <= i2@342@03 | live]
; [else-branch: 201 | !(0 <= i2@342@03) | live]
(push) ; 20
; [then-branch: 201 | 0 <= i2@342@03]
(assert (<= 0 i2@342@03))
; [eval] i2 < V
(push) ; 21
; [then-branch: 202 | i2@342@03 < V@12@03 | live]
; [else-branch: 202 | !(i2@342@03 < V@12@03) | live]
(push) ; 22
; [then-branch: 202 | i2@342@03 < V@12@03]
(assert (< i2@342@03 V@12@03))
; [eval] aloc(opt_get1(Gf), i1).option$array$ == aloc(opt_get1(Gf), i2).option$array$
; [eval] aloc(opt_get1(Gf), i1)
; [eval] opt_get1(Gf)
(push) ; 23
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 23
; Joined path conditions
(push) ; 23
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 24
(assert (not (< i1@341@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))))
(check-sat)
; unsat
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1863866
;  :arith-add-rows          546662
;  :arith-assert-diseq      68876
;  :arith-assert-lower      510578
;  :arith-assert-upper      415377
;  :arith-bound-prop        23195
;  :arith-conflicts         1407
;  :arith-eq-adapter        254867
;  :arith-fixed-eqs         324614
;  :arith-offset-eqs        121453
;  :arith-pivots            62758
;  :conflicts               3380
;  :datatype-accessor-ax    644
;  :datatype-constructor-ax 1785
;  :datatype-occurs-check   1309
;  :datatype-splits         1167
;  :decisions               163836
;  :del-clause              2643606
;  :final-checks            177
;  :interface-eqs           41
;  :max-generation          15
;  :max-memory              50.39
;  :memory                  45.20
;  :minimized-lits          453
;  :mk-bool-var             2981329
;  :mk-clause               2644550
;  :num-allocs              9561120
;  :num-checks              446
;  :propagations            1048505
;  :quant-instantiations    1236876
;  :restarts                4
;  :rlimit-count            31692526)
(assert (< i1@341@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03))))
(pop) ; 23
; Joined path conditions
(assert (< i1@341@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@336@03  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@341@03)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@341@03)))
(push) ; 23
(assert (not (<
  $Perm.No
  (+
    (-
      (ite
        (and
          (<
            (inv@21@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@341@03))
            V@12@03)
          (<=
            0
            (inv@21@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@341@03))))
        $k@20@03
        $Perm.No)
      (pTaken@134@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@341@03)))
    (ite
      (and
        (<
          (inv@108@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@341@03))
          V@12@03)
        (<=
          0
          (inv@108@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@341@03))))
      $k@107@03
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 23
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1864255
;  :arith-add-rows          546803
;  :arith-assert-diseq      68886
;  :arith-assert-lower      510667
;  :arith-assert-upper      415432
;  :arith-bound-prop        23217
;  :arith-conflicts         1410
;  :arith-eq-adapter        254945
;  :arith-fixed-eqs         324669
;  :arith-offset-eqs        121480
;  :arith-pivots            62779
;  :conflicts               3399
;  :datatype-accessor-ax    644
;  :datatype-constructor-ax 1789
;  :datatype-occurs-check   1309
;  :datatype-splits         1167
;  :decisions               163857
;  :del-clause              2644007
;  :final-checks            177
;  :interface-eqs           41
;  :max-generation          15
;  :max-memory              50.39
;  :memory                  45.21
;  :minimized-lits          453
;  :mk-bool-var             2982005
;  :mk-clause               2645026
;  :num-allocs              9563838
;  :num-checks              447
;  :propagations            1048670
;  :quant-instantiations    1237075
;  :restarts                4
;  :rlimit-count            31702711
;  :time                    0.01)
; [eval] aloc(opt_get1(Gf), i2)
; [eval] opt_get1(Gf)
(push) ; 23
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 23
; Joined path conditions
(push) ; 23
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 24
(assert (not (< i2@342@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))))
(check-sat)
; unsat
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1864255
;  :arith-add-rows          546803
;  :arith-assert-diseq      68886
;  :arith-assert-lower      510667
;  :arith-assert-upper      415432
;  :arith-bound-prop        23217
;  :arith-conflicts         1410
;  :arith-eq-adapter        254945
;  :arith-fixed-eqs         324669
;  :arith-offset-eqs        121480
;  :arith-pivots            62779
;  :conflicts               3399
;  :datatype-accessor-ax    644
;  :datatype-constructor-ax 1789
;  :datatype-occurs-check   1309
;  :datatype-splits         1167
;  :decisions               163857
;  :del-clause              2644007
;  :final-checks            177
;  :interface-eqs           41
;  :max-generation          15
;  :max-memory              50.39
;  :memory                  45.21
;  :minimized-lits          453
;  :mk-bool-var             2982005
;  :mk-clause               2645026
;  :num-allocs              9563865
;  :num-checks              448
;  :propagations            1048670
;  :quant-instantiations    1237075
;  :restarts                4
;  :rlimit-count            31702741)
(assert (< i2@342@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03))))
(pop) ; 23
; Joined path conditions
(assert (< i2@342@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@336@03  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@342@03)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@342@03)))
(push) ; 23
(assert (not (<
  $Perm.No
  (+
    (-
      (ite
        (and
          (<
            (inv@21@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@342@03))
            V@12@03)
          (<=
            0
            (inv@21@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@342@03))))
        $k@20@03
        $Perm.No)
      (pTaken@134@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@342@03)))
    (ite
      (and
        (<
          (inv@108@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@342@03))
          V@12@03)
        (<=
          0
          (inv@108@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@342@03))))
      $k@107@03
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 23
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1864724
;  :arith-add-rows          547033
;  :arith-assert-diseq      68905
;  :arith-assert-lower      510805
;  :arith-assert-upper      415501
;  :arith-bound-prop        23260
;  :arith-conflicts         1414
;  :arith-eq-adapter        255042
;  :arith-fixed-eqs         324733
;  :arith-offset-eqs        121529
;  :arith-pivots            62814
;  :conflicts               3419
;  :datatype-accessor-ax    644
;  :datatype-constructor-ax 1793
;  :datatype-occurs-check   1309
;  :datatype-splits         1167
;  :decisions               163882
;  :del-clause              2644542
;  :final-checks            177
;  :interface-eqs           41
;  :max-generation          15
;  :max-memory              50.39
;  :memory                  45.22
;  :minimized-lits          454
;  :mk-bool-var             2982932
;  :mk-clause               2645666
;  :num-allocs              9567352
;  :num-checks              449
;  :propagations            1048916
;  :quant-instantiations    1237284
;  :restarts                4
;  :rlimit-count            31715330
;  :time                    0.01)
(pop) ; 22
(push) ; 22
; [else-branch: 202 | !(i2@342@03 < V@12@03)]
(assert (not (< i2@342@03 V@12@03)))
(pop) ; 22
(pop) ; 21
; Joined path conditions
(assert (implies
  (< i2@342@03 V@12@03)
  (and
    (< i2@342@03 V@12@03)
    (< i1@341@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@336@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@341@03)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@341@03))
    (< i2@342@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@336@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@342@03)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@342@03)))))
; Joined path conditions
(pop) ; 20
(push) ; 20
; [else-branch: 201 | !(0 <= i2@342@03)]
(assert (not (<= 0 i2@342@03)))
(pop) ; 20
(pop) ; 19
; Joined path conditions
(assert (implies
  (<= 0 i2@342@03)
  (and
    (<= 0 i2@342@03)
    (implies
      (< i2@342@03 V@12@03)
      (and
        (< i2@342@03 V@12@03)
        (< i1@341@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@336@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@341@03)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@341@03))
        (< i2@342@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@336@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@342@03)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@342@03)))))))
; Joined path conditions
(pop) ; 18
(push) ; 18
; [else-branch: 200 | !(i1@341@03 < V@12@03)]
(assert (not (< i1@341@03 V@12@03)))
(pop) ; 18
(pop) ; 17
; Joined path conditions
(assert (implies
  (< i1@341@03 V@12@03)
  (and
    (< i1@341@03 V@12@03)
    (implies
      (<= 0 i2@342@03)
      (and
        (<= 0 i2@342@03)
        (implies
          (< i2@342@03 V@12@03)
          (and
            (< i2@342@03 V@12@03)
            (< i1@341@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@336@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@341@03)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@341@03))
            (< i2@342@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@336@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@342@03)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@342@03)))))))))
; Joined path conditions
(pop) ; 16
(push) ; 16
; [else-branch: 199 | !(0 <= i1@341@03)]
(assert (not (<= 0 i1@341@03)))
(pop) ; 16
(pop) ; 15
; Joined path conditions
(assert (implies
  (<= 0 i1@341@03)
  (and
    (<= 0 i1@341@03)
    (implies
      (< i1@341@03 V@12@03)
      (and
        (< i1@341@03 V@12@03)
        (implies
          (<= 0 i2@342@03)
          (and
            (<= 0 i2@342@03)
            (implies
              (< i2@342@03 V@12@03)
              (and
                (< i2@342@03 V@12@03)
                (< i1@341@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@336@03  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@341@03)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@341@03))
                (< i2@342@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@336@03  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@342@03)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@342@03)))))))))))
; Joined path conditions
(push) ; 15
; [then-branch: 203 | Lookup(option$array$,sm@336@03,aloc((_, _), opt_get1(_, Gf@11@03), i1@341@03)) == Lookup(option$array$,sm@336@03,aloc((_, _), opt_get1(_, Gf@11@03), i2@342@03)) && i2@342@03 < V@12@03 && 0 <= i2@342@03 && i1@341@03 < V@12@03 && 0 <= i1@341@03 | live]
; [else-branch: 203 | !(Lookup(option$array$,sm@336@03,aloc((_, _), opt_get1(_, Gf@11@03), i1@341@03)) == Lookup(option$array$,sm@336@03,aloc((_, _), opt_get1(_, Gf@11@03), i2@342@03)) && i2@342@03 < V@12@03 && 0 <= i2@342@03 && i1@341@03 < V@12@03 && 0 <= i1@341@03) | live]
(push) ; 16
; [then-branch: 203 | Lookup(option$array$,sm@336@03,aloc((_, _), opt_get1(_, Gf@11@03), i1@341@03)) == Lookup(option$array$,sm@336@03,aloc((_, _), opt_get1(_, Gf@11@03), i2@342@03)) && i2@342@03 < V@12@03 && 0 <= i2@342@03 && i1@341@03 < V@12@03 && 0 <= i1@341@03]
(assert (and
  (and
    (and
      (and
        (=
          ($FVF.lookup_option$array$ (as sm@336@03  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@341@03))
          ($FVF.lookup_option$array$ (as sm@336@03  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@342@03)))
        (< i2@342@03 V@12@03))
      (<= 0 i2@342@03))
    (< i1@341@03 V@12@03))
  (<= 0 i1@341@03)))
; [eval] i1 == i2
(pop) ; 16
(push) ; 16
; [else-branch: 203 | !(Lookup(option$array$,sm@336@03,aloc((_, _), opt_get1(_, Gf@11@03), i1@341@03)) == Lookup(option$array$,sm@336@03,aloc((_, _), opt_get1(_, Gf@11@03), i2@342@03)) && i2@342@03 < V@12@03 && 0 <= i2@342@03 && i1@341@03 < V@12@03 && 0 <= i1@341@03)]
(assert (not
  (and
    (and
      (and
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@336@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@341@03))
            ($FVF.lookup_option$array$ (as sm@336@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@342@03)))
          (< i2@342@03 V@12@03))
        (<= 0 i2@342@03))
      (< i1@341@03 V@12@03))
    (<= 0 i1@341@03))))
(pop) ; 16
(pop) ; 15
; Joined path conditions
(assert (implies
  (and
    (and
      (and
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@336@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@341@03))
            ($FVF.lookup_option$array$ (as sm@336@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@342@03)))
          (< i2@342@03 V@12@03))
        (<= 0 i2@342@03))
      (< i1@341@03 V@12@03))
    (<= 0 i1@341@03))
  (and
    (=
      ($FVF.lookup_option$array$ (as sm@336@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@341@03))
      ($FVF.lookup_option$array$ (as sm@336@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@342@03)))
    (< i2@342@03 V@12@03)
    (<= 0 i2@342@03)
    (< i1@341@03 V@12@03)
    (<= 0 i1@341@03))))
; Joined path conditions
(pop) ; 14
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i2@342@03 Int)) (!
  (and
    (implies
      (<= 0 i1@341@03)
      (and
        (<= 0 i1@341@03)
        (implies
          (< i1@341@03 V@12@03)
          (and
            (< i1@341@03 V@12@03)
            (implies
              (<= 0 i2@342@03)
              (and
                (<= 0 i2@342@03)
                (implies
                  (< i2@342@03 V@12@03)
                  (and
                    (< i2@342@03 V@12@03)
                    (< i1@341@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))
                    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@336@03  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@341@03)) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@341@03))
                    (< i2@342@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))
                    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@336@03  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@342@03)) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@342@03))))))))))
    (implies
      (and
        (and
          (and
            (and
              (=
                ($FVF.lookup_option$array$ (as sm@336@03  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@341@03))
                ($FVF.lookup_option$array$ (as sm@336@03  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@342@03)))
              (< i2@342@03 V@12@03))
            (<= 0 i2@342@03))
          (< i1@341@03 V@12@03))
        (<= 0 i1@341@03))
      (and
        (=
          ($FVF.lookup_option$array$ (as sm@336@03  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@341@03))
          ($FVF.lookup_option$array$ (as sm@336@03  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@342@03)))
        (< i2@342@03 V@12@03)
        (<= 0 i2@342@03)
        (< i1@341@03 V@12@03)
        (<= 0 i1@341@03))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@342@03))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 13
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@341@03 Int)) (!
  (forall ((i2@342@03 Int)) (!
    (and
      (implies
        (<= 0 i1@341@03)
        (and
          (<= 0 i1@341@03)
          (implies
            (< i1@341@03 V@12@03)
            (and
              (< i1@341@03 V@12@03)
              (implies
                (<= 0 i2@342@03)
                (and
                  (<= 0 i2@342@03)
                  (implies
                    (< i2@342@03 V@12@03)
                    (and
                      (< i2@342@03 V@12@03)
                      (< i1@341@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))
                      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@336@03  $FVF<option<array>>) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@341@03)) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@341@03))
                      (< i2@342@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))
                      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@336@03  $FVF<option<array>>) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@342@03)) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@342@03))))))))))
      (implies
        (and
          (and
            (and
              (and
                (=
                  ($FVF.lookup_option$array$ (as sm@336@03  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@341@03))
                  ($FVF.lookup_option$array$ (as sm@336@03  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@342@03)))
                (< i2@342@03 V@12@03))
              (<= 0 i2@342@03))
            (< i1@341@03 V@12@03))
          (<= 0 i1@341@03))
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@336@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@341@03))
            ($FVF.lookup_option$array$ (as sm@336@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@342@03)))
          (< i2@342@03 V@12@03)
          (<= 0 i2@342@03)
          (< i1@341@03 V@12@03)
          (<= 0 i1@341@03))))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@342@03))
    :qid |prog.l<no position>-aux|))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@341@03))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 12
(pop) ; 11
; Joined path conditions
(assert (implies
  (= exc@89@03 $Ref.null)
  (forall ((i1@341@03 Int)) (!
    (forall ((i2@342@03 Int)) (!
      (and
        (implies
          (<= 0 i1@341@03)
          (and
            (<= 0 i1@341@03)
            (implies
              (< i1@341@03 V@12@03)
              (and
                (< i1@341@03 V@12@03)
                (implies
                  (<= 0 i2@342@03)
                  (and
                    (<= 0 i2@342@03)
                    (implies
                      (< i2@342@03 V@12@03)
                      (and
                        (< i2@342@03 V@12@03)
                        (< i1@341@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))
                        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@336@03  $FVF<option<array>>) (aloc ($Snap.combine
                          $Snap.unit
                          $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@341@03)) (aloc ($Snap.combine
                          $Snap.unit
                          $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@341@03))
                        (< i2@342@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))
                        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@336@03  $FVF<option<array>>) (aloc ($Snap.combine
                          $Snap.unit
                          $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@342@03)) (aloc ($Snap.combine
                          $Snap.unit
                          $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@342@03))))))))))
        (implies
          (and
            (and
              (and
                (and
                  (=
                    ($FVF.lookup_option$array$ (as sm@336@03  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@341@03))
                    ($FVF.lookup_option$array$ (as sm@336@03  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@342@03)))
                  (< i2@342@03 V@12@03))
                (<= 0 i2@342@03))
              (< i1@341@03 V@12@03))
            (<= 0 i1@341@03))
          (and
            (=
              ($FVF.lookup_option$array$ (as sm@336@03  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@341@03))
              ($FVF.lookup_option$array$ (as sm@336@03  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@342@03)))
            (< i2@342@03 V@12@03)
            (<= 0 i2@342@03)
            (< i1@341@03 V@12@03)
            (<= 0 i1@341@03))))
      :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@342@03))
      :qid |prog.l<no position>-aux|))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@341@03))
    :qid |prog.l<no position>-aux|))))
(push) ; 11
(assert (not (implies
  (= exc@89@03 $Ref.null)
  (forall ((i1@341@03 Int)) (!
    (forall ((i2@342@03 Int)) (!
      (implies
        (and
          (and
            (and
              (and
                (=
                  ($FVF.lookup_option$array$ (as sm@336@03  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@341@03))
                  ($FVF.lookup_option$array$ (as sm@336@03  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@342@03)))
                (< i2@342@03 V@12@03))
              (<= 0 i2@342@03))
            (< i1@341@03 V@12@03))
          (<= 0 i1@341@03))
        (= i1@341@03 i2@342@03))
      :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@342@03))
      :qid |prog.l<no position>|))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@341@03))
    :qid |prog.l<no position>|)))))
(check-sat)
; unsat
(pop) ; 11
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1865156
;  :arith-add-rows          547245
;  :arith-assert-diseq      68912
;  :arith-assert-lower      510892
;  :arith-assert-upper      415559
;  :arith-bound-prop        23292
;  :arith-conflicts         1416
;  :arith-eq-adapter        255122
;  :arith-fixed-eqs         324791
;  :arith-offset-eqs        121571
;  :arith-pivots            62871
;  :conflicts               3437
;  :datatype-accessor-ax    644
;  :datatype-constructor-ax 1797
;  :datatype-occurs-check   1309
;  :datatype-splits         1167
;  :decisions               163905
;  :del-clause              2645283
;  :final-checks            177
;  :interface-eqs           41
;  :max-generation          15
;  :max-memory              50.39
;  :memory                  45.20
;  :minimized-lits          454
;  :mk-bool-var             2983686
;  :mk-clause               2646227
;  :num-allocs              9571177
;  :num-checks              450
;  :propagations            1049118
;  :quant-instantiations    1237538
;  :restarts                4
;  :rlimit-count            31733172
;  :time                    0.01)
(assert (implies
  (= exc@89@03 $Ref.null)
  (forall ((i1@341@03 Int)) (!
    (forall ((i2@342@03 Int)) (!
      (implies
        (and
          (and
            (and
              (and
                (=
                  ($FVF.lookup_option$array$ (as sm@336@03  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@341@03))
                  ($FVF.lookup_option$array$ (as sm@336@03  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@342@03)))
                (< i2@342@03 V@12@03))
              (<= 0 i2@342@03))
            (< i1@341@03 V@12@03))
          (<= 0 i1@341@03))
        (= i1@341@03 i2@342@03))
      :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i2@342@03))
      :qid |prog.l<no position>|))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@341@03))
    :qid |prog.l<no position>|))))
; [eval] exc == null ==> p != (None(): option[array])
; [eval] exc == null
(push) ; 11
(set-option :timeout 10)
(push) ; 12
(assert (not (not (= exc@89@03 $Ref.null))))
(check-sat)
; unknown
(pop) ; 12
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1865817
;  :arith-add-rows          547646
;  :arith-assert-diseq      68927
;  :arith-assert-lower      511061
;  :arith-assert-upper      415664
;  :arith-bound-prop        23328
;  :arith-conflicts         1421
;  :arith-eq-adapter        255227
;  :arith-fixed-eqs         324872
;  :arith-offset-eqs        121624
;  :arith-pivots            62912
;  :conflicts               3443
;  :datatype-accessor-ax    644
;  :datatype-constructor-ax 1801
;  :datatype-occurs-check   1309
;  :datatype-splits         1167
;  :decisions               164034
;  :del-clause              2646709
;  :final-checks            177
;  :interface-eqs           41
;  :max-generation          15
;  :max-memory              50.39
;  :memory                  45.28
;  :minimized-lits          454
;  :mk-bool-var             2984950
;  :mk-clause               2647653
;  :num-allocs              9574505
;  :num-checks              451
;  :propagations            1049618
;  :quant-instantiations    1237894
;  :restarts                4
;  :rlimit-count            31757497
;  :time                    0.01)
; [then-branch: 204 | exc@89@03 == Null | live]
; [else-branch: 204 | exc@89@03 != Null | dead]
(push) ; 12
; [then-branch: 204 | exc@89@03 == Null]
; [eval] p != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 12
(pop) ; 11
; Joined path conditions
(set-option :timeout 0)
(push) ; 11
(assert (not (implies
  (= exc@89@03 $Ref.null)
  (not (= p@15@03 (as None<option<array>>  option<array>))))))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1865817
;  :arith-add-rows          547646
;  :arith-assert-diseq      68927
;  :arith-assert-lower      511061
;  :arith-assert-upper      415664
;  :arith-bound-prop        23328
;  :arith-conflicts         1421
;  :arith-eq-adapter        255227
;  :arith-fixed-eqs         324872
;  :arith-offset-eqs        121624
;  :arith-pivots            62912
;  :conflicts               3443
;  :datatype-accessor-ax    644
;  :datatype-constructor-ax 1801
;  :datatype-occurs-check   1309
;  :datatype-splits         1167
;  :decisions               164034
;  :del-clause              2646709
;  :final-checks            177
;  :interface-eqs           41
;  :max-generation          15
;  :max-memory              50.39
;  :memory                  45.28
;  :minimized-lits          454
;  :mk-bool-var             2984950
;  :mk-clause               2647653
;  :num-allocs              9574530
;  :num-checks              452
;  :propagations            1049618
;  :quant-instantiations    1237894
;  :restarts                4
;  :rlimit-count            31757517)
(assert (implies
  (= exc@89@03 $Ref.null)
  (not (= p@15@03 (as None<option<array>>  option<array>)))))
; [eval] exc == null ==> alen(opt_get1(p)) == V
; [eval] exc == null
(push) ; 11
(set-option :timeout 10)
(push) ; 12
(assert (not (not (= exc@89@03 $Ref.null))))
(check-sat)
; unknown
(pop) ; 12
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1866797
;  :arith-add-rows          548260
;  :arith-assert-diseq      68960
;  :arith-assert-lower      511318
;  :arith-assert-upper      415838
;  :arith-bound-prop        23366
;  :arith-conflicts         1430
;  :arith-eq-adapter        255379
;  :arith-fixed-eqs         324982
;  :arith-offset-eqs        121721
;  :arith-pivots            62973
;  :conflicts               3454
;  :datatype-accessor-ax    644
;  :datatype-constructor-ax 1805
;  :datatype-occurs-check   1309
;  :datatype-splits         1167
;  :decisions               164264
;  :del-clause              2648962
;  :final-checks            177
;  :interface-eqs           41
;  :max-generation          15
;  :max-memory              50.39
;  :memory                  45.28
;  :minimized-lits          454
;  :mk-bool-var             2986803
;  :mk-clause               2649906
;  :num-allocs              9578358
;  :num-checks              453
;  :propagations            1050355
;  :quant-instantiations    1238355
;  :restarts                4
;  :rlimit-count            31791611
;  :time                    0.01)
; [then-branch: 205 | exc@89@03 == Null | live]
; [else-branch: 205 | exc@89@03 != Null | dead]
(push) ; 12
; [then-branch: 205 | exc@89@03 == Null]
; [eval] alen(opt_get1(p)) == V
; [eval] alen(opt_get1(p))
; [eval] opt_get1(p)
(push) ; 13
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 13
; Joined path conditions
(pop) ; 12
(pop) ; 11
; Joined path conditions
(set-option :timeout 0)
(push) ; 11
(assert (not (implies
  (= exc@89@03 $Ref.null)
  (= (alen<Int> (opt_get1 $Snap.unit p@15@03)) V@12@03))))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1866797
;  :arith-add-rows          548260
;  :arith-assert-diseq      68960
;  :arith-assert-lower      511318
;  :arith-assert-upper      415838
;  :arith-bound-prop        23366
;  :arith-conflicts         1430
;  :arith-eq-adapter        255379
;  :arith-fixed-eqs         324982
;  :arith-offset-eqs        121721
;  :arith-pivots            62973
;  :conflicts               3454
;  :datatype-accessor-ax    644
;  :datatype-constructor-ax 1805
;  :datatype-occurs-check   1309
;  :datatype-splits         1167
;  :decisions               164264
;  :del-clause              2648962
;  :final-checks            177
;  :interface-eqs           41
;  :max-generation          15
;  :max-memory              50.39
;  :memory                  45.28
;  :minimized-lits          454
;  :mk-bool-var             2986803
;  :mk-clause               2649906
;  :num-allocs              9578377
;  :num-checks              454
;  :propagations            1050355
;  :quant-instantiations    1238355
;  :restarts                4
;  :rlimit-count            31791636)
(assert (implies
  (= exc@89@03 $Ref.null)
  (= (alen<Int> (opt_get1 $Snap.unit p@15@03)) V@12@03)))
; [eval] exc == null ==> 0 <= s
; [eval] exc == null
(push) ; 11
(set-option :timeout 10)
(push) ; 12
(assert (not (not (= exc@89@03 $Ref.null))))
(check-sat)
; unknown
(pop) ; 12
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1867875
;  :arith-add-rows          548997
;  :arith-assert-diseq      68998
;  :arith-assert-lower      511635
;  :arith-assert-upper      416034
;  :arith-bound-prop        23408
;  :arith-conflicts         1441
;  :arith-eq-adapter        255551
;  :arith-fixed-eqs         325096
;  :arith-offset-eqs        121850
;  :arith-pivots            63047
;  :conflicts               3469
;  :datatype-accessor-ax    644
;  :datatype-constructor-ax 1809
;  :datatype-occurs-check   1309
;  :datatype-splits         1167
;  :decisions               164537
;  :del-clause              2651594
;  :final-checks            177
;  :interface-eqs           41
;  :max-generation          15
;  :max-memory              50.39
;  :memory                  45.29
;  :minimized-lits          462
;  :mk-bool-var             2988990
;  :mk-clause               2652538
;  :num-allocs              9582797
;  :num-checks              455
;  :propagations            1051206
;  :quant-instantiations    1238859
;  :restarts                4
;  :rlimit-count            31829089
;  :time                    0.01)
; [then-branch: 206 | exc@89@03 == Null | live]
; [else-branch: 206 | exc@89@03 != Null | dead]
(push) ; 12
; [then-branch: 206 | exc@89@03 == Null]
; [eval] 0 <= s
(pop) ; 12
(pop) ; 11
; Joined path conditions
; [eval] exc == null ==> s < V
; [eval] exc == null
(push) ; 11
(push) ; 12
(assert (not (not (= exc@89@03 $Ref.null))))
(check-sat)
; unknown
(pop) ; 12
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1868993
;  :arith-add-rows          549641
;  :arith-assert-diseq      69049
;  :arith-assert-lower      511995
;  :arith-assert-upper      416234
;  :arith-bound-prop        23464
;  :arith-conflicts         1451
;  :arith-eq-adapter        255744
;  :arith-fixed-eqs         325215
;  :arith-offset-eqs        121964
;  :arith-pivots            63136
;  :conflicts               3483
;  :datatype-accessor-ax    644
;  :datatype-constructor-ax 1813
;  :datatype-occurs-check   1309
;  :datatype-splits         1167
;  :decisions               164825
;  :del-clause              2654534
;  :final-checks            177
;  :interface-eqs           41
;  :max-generation          15
;  :max-memory              50.39
;  :memory                  45.29
;  :minimized-lits          477
;  :mk-bool-var             2991359
;  :mk-clause               2655478
;  :num-allocs              9587670
;  :num-checks              456
;  :propagations            1052089
;  :quant-instantiations    1239419
;  :restarts                4
;  :rlimit-count            31865448
;  :time                    0.01)
; [then-branch: 207 | exc@89@03 == Null | live]
; [else-branch: 207 | exc@89@03 != Null | dead]
(push) ; 12
; [then-branch: 207 | exc@89@03 == Null]
; [eval] s < V
(pop) ; 12
(pop) ; 11
; Joined path conditions
; [eval] exc == null ==> 0 <= t
; [eval] exc == null
(push) ; 11
(push) ; 12
(assert (not (not (= exc@89@03 $Ref.null))))
(check-sat)
; unknown
(pop) ; 12
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1870256
;  :arith-add-rows          550398
;  :arith-assert-diseq      69097
;  :arith-assert-lower      512378
;  :arith-assert-upper      416465
;  :arith-bound-prop        23514
;  :arith-conflicts         1463
;  :arith-eq-adapter        255946
;  :arith-fixed-eqs         325359
;  :arith-offset-eqs        122126
;  :arith-pivots            63222
;  :conflicts               3499
;  :datatype-accessor-ax    644
;  :datatype-constructor-ax 1817
;  :datatype-occurs-check   1309
;  :datatype-splits         1167
;  :decisions               165128
;  :del-clause              2657536
;  :final-checks            177
;  :interface-eqs           41
;  :max-generation          15
;  :max-memory              50.39
;  :memory                  45.13
;  :minimized-lits          485
;  :mk-bool-var             2993847
;  :mk-clause               2658480
;  :num-allocs              9592665
;  :num-checks              457
;  :propagations            1053087
;  :quant-instantiations    1240005
;  :restarts                4
;  :rlimit-count            31904923
;  :time                    0.01)
; [then-branch: 208 | exc@89@03 == Null | live]
; [else-branch: 208 | exc@89@03 != Null | dead]
(push) ; 12
; [then-branch: 208 | exc@89@03 == Null]
; [eval] 0 <= t
(pop) ; 12
(pop) ; 11
; Joined path conditions
(set-option :timeout 0)
(push) ; 11
(assert (not (implies (= exc@89@03 $Ref.null) (<= 0 t@14@03))))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1870256
;  :arith-add-rows          550398
;  :arith-assert-diseq      69097
;  :arith-assert-lower      512378
;  :arith-assert-upper      416465
;  :arith-bound-prop        23514
;  :arith-conflicts         1463
;  :arith-eq-adapter        255946
;  :arith-fixed-eqs         325359
;  :arith-offset-eqs        122126
;  :arith-pivots            63222
;  :conflicts               3499
;  :datatype-accessor-ax    644
;  :datatype-constructor-ax 1817
;  :datatype-occurs-check   1309
;  :datatype-splits         1167
;  :decisions               165128
;  :del-clause              2657536
;  :final-checks            177
;  :interface-eqs           41
;  :max-generation          15
;  :max-memory              50.39
;  :memory                  45.13
;  :minimized-lits          485
;  :mk-bool-var             2993847
;  :mk-clause               2658480
;  :num-allocs              9592688
;  :num-checks              458
;  :propagations            1053087
;  :quant-instantiations    1240005
;  :restarts                4
;  :rlimit-count            31904949)
(assert (implies (= exc@89@03 $Ref.null) (<= 0 t@14@03)))
; [eval] exc == null ==> t < V
; [eval] exc == null
(push) ; 11
(set-option :timeout 10)
(push) ; 12
(assert (not (not (= exc@89@03 $Ref.null))))
(check-sat)
; unknown
(pop) ; 12
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1871258
;  :arith-add-rows          551113
;  :arith-assert-diseq      69117
;  :arith-assert-lower      512645
;  :arith-assert-upper      416613
;  :arith-bound-prop        23550
;  :arith-conflicts         1469
;  :arith-eq-adapter        256094
;  :arith-fixed-eqs         325477
;  :arith-offset-eqs        122222
;  :arith-pivots            63278
;  :conflicts               3508
;  :datatype-accessor-ax    644
;  :datatype-constructor-ax 1821
;  :datatype-occurs-check   1309
;  :datatype-splits         1167
;  :decisions               165308
;  :del-clause              2659356
;  :final-checks            177
;  :interface-eqs           41
;  :max-generation          15
;  :max-memory              50.39
;  :memory                  45.21
;  :minimized-lits          490
;  :mk-bool-var             2995515
;  :mk-clause               2660300
;  :num-allocs              9597303
;  :num-checks              459
;  :propagations            1053861
;  :quant-instantiations    1240500
;  :restarts                4
;  :rlimit-count            31941411
;  :time                    0.01)
; [then-branch: 209 | exc@89@03 == Null | live]
; [else-branch: 209 | exc@89@03 != Null | dead]
(push) ; 12
; [then-branch: 209 | exc@89@03 == Null]
; [eval] t < V
(pop) ; 12
(pop) ; 11
; Joined path conditions
(set-option :timeout 0)
(push) ; 11
(assert (not (implies (= exc@89@03 $Ref.null) (< t@14@03 V@12@03))))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1871258
;  :arith-add-rows          551113
;  :arith-assert-diseq      69117
;  :arith-assert-lower      512645
;  :arith-assert-upper      416613
;  :arith-bound-prop        23550
;  :arith-conflicts         1469
;  :arith-eq-adapter        256094
;  :arith-fixed-eqs         325477
;  :arith-offset-eqs        122222
;  :arith-pivots            63278
;  :conflicts               3508
;  :datatype-accessor-ax    644
;  :datatype-constructor-ax 1821
;  :datatype-occurs-check   1309
;  :datatype-splits         1167
;  :decisions               165308
;  :del-clause              2659356
;  :final-checks            177
;  :interface-eqs           41
;  :max-generation          15
;  :max-memory              50.39
;  :memory                  45.21
;  :minimized-lits          490
;  :mk-bool-var             2995515
;  :mk-clause               2660300
;  :num-allocs              9597338
;  :num-checks              460
;  :propagations            1053861
;  :quant-instantiations    1240500
;  :restarts                4
;  :rlimit-count            31941440)
(assert (implies (= exc@89@03 $Ref.null) (< t@14@03 V@12@03)))
; [eval] exc == null
(set-option :timeout 10)
(push) ; 11
(assert (not (not (= exc@89@03 $Ref.null))))
(check-sat)
; unknown
(pop) ; 11
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1872360
;  :arith-add-rows          551699
;  :arith-assert-diseq      69141
;  :arith-assert-lower      512946
;  :arith-assert-upper      416786
;  :arith-bound-prop        23590
;  :arith-conflicts         1476
;  :arith-eq-adapter        256260
;  :arith-fixed-eqs         325601
;  :arith-offset-eqs        122329
;  :arith-pivots            63340
;  :conflicts               3518
;  :datatype-accessor-ax    644
;  :datatype-constructor-ax 1825
;  :datatype-occurs-check   1309
;  :datatype-splits         1167
;  :decisions               165544
;  :del-clause              2661732
;  :final-checks            177
;  :interface-eqs           41
;  :max-generation          15
;  :max-memory              50.39
;  :memory                  45.21
;  :minimized-lits          494
;  :mk-bool-var             2997584
;  :mk-clause               2662676
;  :num-allocs              9602132
;  :num-checks              461
;  :propagations            1054800
;  :quant-instantiations    1241102
;  :restarts                4
;  :rlimit-count            31975369
;  :time                    0.01)
; [then-branch: 210 | exc@89@03 == Null | live]
; [else-branch: 210 | exc@89@03 != Null | dead]
(push) ; 11
; [then-branch: 210 | exc@89@03 == Null]
(declare-const i1@343@03 Int)
(declare-const j1@344@03 Int)
(push) ; 12
; [eval] 0 <= i1 && i1 < V && (0 <= j1 && j1 < V)
; [eval] 0 <= i1
(push) ; 13
; [then-branch: 211 | 0 <= i1@343@03 | live]
; [else-branch: 211 | !(0 <= i1@343@03) | live]
(push) ; 14
; [then-branch: 211 | 0 <= i1@343@03]
(assert (<= 0 i1@343@03))
; [eval] i1 < V
(push) ; 15
; [then-branch: 212 | i1@343@03 < V@12@03 | live]
; [else-branch: 212 | !(i1@343@03 < V@12@03) | live]
(push) ; 16
; [then-branch: 212 | i1@343@03 < V@12@03]
(assert (< i1@343@03 V@12@03))
; [eval] 0 <= j1
(push) ; 17
; [then-branch: 213 | 0 <= j1@344@03 | live]
; [else-branch: 213 | !(0 <= j1@344@03) | live]
(push) ; 18
; [then-branch: 213 | 0 <= j1@344@03]
(assert (<= 0 j1@344@03))
; [eval] j1 < V
(pop) ; 18
(push) ; 18
; [else-branch: 213 | !(0 <= j1@344@03)]
(assert (not (<= 0 j1@344@03)))
(pop) ; 18
(pop) ; 17
; Joined path conditions
; Joined path conditions
(pop) ; 16
(push) ; 16
; [else-branch: 212 | !(i1@343@03 < V@12@03)]
(assert (not (< i1@343@03 V@12@03)))
(pop) ; 16
(pop) ; 15
; Joined path conditions
; Joined path conditions
(pop) ; 14
(push) ; 14
; [else-branch: 211 | !(0 <= i1@343@03)]
(assert (not (<= 0 i1@343@03)))
(pop) ; 14
(pop) ; 13
; Joined path conditions
; Joined path conditions
(assert (and
  (and (and (< j1@344@03 V@12@03) (<= 0 j1@344@03)) (< i1@343@03 V@12@03))
  (<= 0 i1@343@03)))
; [eval] aloc(opt_get1(aloc(opt_get1(Gf), i1).option$array$), j1)
; [eval] opt_get1(aloc(opt_get1(Gf), i1).option$array$)
; [eval] aloc(opt_get1(Gf), i1)
; [eval] opt_get1(Gf)
(push) ; 13
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 13
; Joined path conditions
(push) ; 13
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 14
(assert (not (< i1@343@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))))
(check-sat)
; unsat
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1872360
;  :arith-add-rows          551702
;  :arith-assert-diseq      69141
;  :arith-assert-lower      512952
;  :arith-assert-upper      416786
;  :arith-bound-prop        23590
;  :arith-conflicts         1476
;  :arith-eq-adapter        256260
;  :arith-fixed-eqs         325601
;  :arith-offset-eqs        122329
;  :arith-pivots            63340
;  :conflicts               3518
;  :datatype-accessor-ax    644
;  :datatype-constructor-ax 1825
;  :datatype-occurs-check   1309
;  :datatype-splits         1167
;  :decisions               165544
;  :del-clause              2661732
;  :final-checks            177
;  :interface-eqs           41
;  :max-generation          15
;  :max-memory              50.39
;  :memory                  45.21
;  :minimized-lits          494
;  :mk-bool-var             2997590
;  :mk-clause               2662676
;  :num-allocs              9602408
;  :num-checks              462
;  :propagations            1054800
;  :quant-instantiations    1241102
;  :restarts                4
;  :rlimit-count            31975840)
(assert (< i1@343@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03))))
(pop) ; 13
; Joined path conditions
(assert (< i1@343@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@336@03  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@343@03)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@343@03)))
(push) ; 13
(assert (not (<
  $Perm.No
  (+
    (-
      (ite
        (and
          (<
            (inv@21@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@343@03))
            V@12@03)
          (<=
            0
            (inv@21@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@343@03))))
        $k@20@03
        $Perm.No)
      (pTaken@134@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@343@03)))
    (ite
      (and
        (<
          (inv@108@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@343@03))
          V@12@03)
        (<=
          0
          (inv@108@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@343@03))))
      $k@107@03
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1872777
;  :arith-add-rows          551847
;  :arith-assert-diseq      69151
;  :arith-assert-lower      513041
;  :arith-assert-upper      416841
;  :arith-bound-prop        23615
;  :arith-conflicts         1479
;  :arith-eq-adapter        256338
;  :arith-fixed-eqs         325657
;  :arith-offset-eqs        122378
;  :arith-pivots            63359
;  :conflicts               3537
;  :datatype-accessor-ax    644
;  :datatype-constructor-ax 1829
;  :datatype-occurs-check   1309
;  :datatype-splits         1167
;  :decisions               165565
;  :del-clause              2662141
;  :final-checks            177
;  :interface-eqs           41
;  :max-generation          15
;  :max-memory              50.39
;  :memory                  45.22
;  :minimized-lits          494
;  :mk-bool-var             2998293
;  :mk-clause               2663160
;  :num-allocs              9605228
;  :num-checks              463
;  :propagations            1054968
;  :quant-instantiations    1241304
;  :restarts                4
;  :rlimit-count            31986269
;  :time                    0.00)
(push) ; 13
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 14
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@336@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@343@03))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1872777
;  :arith-add-rows          551847
;  :arith-assert-diseq      69151
;  :arith-assert-lower      513041
;  :arith-assert-upper      416841
;  :arith-bound-prop        23615
;  :arith-conflicts         1479
;  :arith-eq-adapter        256338
;  :arith-fixed-eqs         325657
;  :arith-offset-eqs        122378
;  :arith-pivots            63359
;  :conflicts               3538
;  :datatype-accessor-ax    644
;  :datatype-constructor-ax 1829
;  :datatype-occurs-check   1309
;  :datatype-splits         1167
;  :decisions               165565
;  :del-clause              2662141
;  :final-checks            177
;  :interface-eqs           41
;  :max-generation          15
;  :max-memory              50.39
;  :memory                  45.22
;  :minimized-lits          494
;  :mk-bool-var             2998293
;  :mk-clause               2663160
;  :num-allocs              9605320
;  :num-checks              464
;  :propagations            1054968
;  :quant-instantiations    1241304
;  :restarts                4
;  :rlimit-count            31986364)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@336@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@343@03))
    (as None<option<array>>  option<array>))))
(pop) ; 13
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@336@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@343@03))
    (as None<option<array>>  option<array>))))
(push) ; 13
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 14
(assert (not (<
  j1@344@03
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@336@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@343@03)))))))
(check-sat)
; unsat
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1872783
;  :arith-add-rows          551853
;  :arith-assert-diseq      69151
;  :arith-assert-lower      513043
;  :arith-assert-upper      416843
;  :arith-bound-prop        23615
;  :arith-conflicts         1480
;  :arith-eq-adapter        256339
;  :arith-fixed-eqs         325658
;  :arith-offset-eqs        122378
;  :arith-pivots            63363
;  :conflicts               3539
;  :datatype-accessor-ax    644
;  :datatype-constructor-ax 1829
;  :datatype-occurs-check   1309
;  :datatype-splits         1167
;  :decisions               165565
;  :del-clause              2662145
;  :final-checks            177
;  :interface-eqs           41
;  :max-generation          15
;  :max-memory              50.39
;  :memory                  45.22
;  :minimized-lits          494
;  :mk-bool-var             2998304
;  :mk-clause               2663164
;  :num-allocs              9605508
;  :num-checks              465
;  :propagations            1054970
;  :quant-instantiations    1241311
;  :restarts                4
;  :rlimit-count            31986898)
(assert (<
  j1@344@03
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@336@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@343@03))))))
(pop) ; 13
; Joined path conditions
(assert (<
  j1@344@03
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@336@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@343@03))))))
(pop) ; 12
(declare-fun inv@345@03 ($Ref) Int)
(declare-fun inv@346@03 ($Ref) Int)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(assert (forall ((i1@343@03 Int) (j1@344@03 Int)) (!
  (and
    (< i1@343@03 (alen<Int> (opt_get1 $Snap.unit Gf@11@03)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@336@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@343@03)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@343@03))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@336@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@343@03))
        (as None<option<array>>  option<array>)))
    (<
      j1@344@03
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@336@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@343@03))))))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@336@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@343@03))) j1@344@03))
  :qid |int-aux|)))
(declare-const sm@347@03 $FVF<Int>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@120@03 r) V@12@03) (<= 0 (inv@120@03 r)))
    (=
      ($FVF.lookup_int (as sm@347@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03)))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@347@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03)))))))))))))))) r))
  :qid |qp.fvfValDef161|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@117@03 r) V@12@03) (<= 0 (inv@117@03 r)))
        (< (inv@116@03 r) V@12@03))
      (<= 0 (inv@116@03 r)))
    (=
      ($FVF.lookup_int (as sm@347@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@347@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03))))))))))))))) r))
  :qid |qp.fvfValDef162|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03)))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03))))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@347@03  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef163|)))
; Check receiver injectivity
(push) ; 12
(assert (not (forall ((i11@343@03 Int) (j11@344@03 Int) (i12@343@03 Int) (j12@344@03 Int)) (!
  (implies
    (and
      (and
        (and
          (and
            (and (< j11@344@03 V@12@03) (<= 0 j11@344@03))
            (< i11@343@03 V@12@03))
          (<= 0 i11@343@03))
        ($FVF.loc_int ($FVF.lookup_int (as sm@347@03  $FVF<Int>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@336@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i11@343@03))) j11@344@03)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@336@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i11@343@03))) j11@344@03)))
      (and
        (and
          (and
            (and (< j12@344@03 V@12@03) (<= 0 j12@344@03))
            (< i12@343@03 V@12@03))
          (<= 0 i12@343@03))
        ($FVF.loc_int ($FVF.lookup_int (as sm@347@03  $FVF<Int>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@336@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i12@343@03))) j12@344@03)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@336@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i12@343@03))) j12@344@03)))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@336@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i11@343@03))) j11@344@03)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@336@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i12@343@03))) j12@344@03)))
    (and (= i11@343@03 i12@343@03) (= j11@344@03 j12@344@03)))
  
  :qid |int-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1872864
;  :arith-add-rows          551910
;  :arith-assert-diseq      69151
;  :arith-assert-lower      513059
;  :arith-assert-upper      416851
;  :arith-bound-prop        23621
;  :arith-conflicts         1480
;  :arith-eq-adapter        256362
;  :arith-fixed-eqs         325664
;  :arith-offset-eqs        122378
;  :arith-pivots            63387
;  :conflicts               3540
;  :datatype-accessor-ax    644
;  :datatype-constructor-ax 1829
;  :datatype-occurs-check   1309
;  :datatype-splits         1167
;  :decisions               165565
;  :del-clause              2662486
;  :final-checks            177
;  :interface-eqs           41
;  :max-generation          15
;  :max-memory              50.39
;  :memory                  45.21
;  :minimized-lits          494
;  :mk-bool-var             2998780
;  :mk-clause               2663430
;  :num-allocs              9608387
;  :num-checks              466
;  :propagations            1055004
;  :quant-instantiations    1241464
;  :restarts                4
;  :rlimit-count            31998118
;  :time                    0.00)
; Definitional axioms for inverse functions
(assert (forall ((i1@343@03 Int) (j1@344@03 Int)) (!
  (implies
    (and
      (and (and (< j1@344@03 V@12@03) (<= 0 j1@344@03)) (< i1@343@03 V@12@03))
      (<= 0 i1@343@03))
    (and
      (=
        (inv@345@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@336@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@343@03))) j1@344@03))
        i1@343@03)
      (=
        (inv@346@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@336@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@343@03))) j1@344@03))
        j1@344@03)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@336@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) i1@343@03))) j1@344@03))
  :qid |int-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@346@03 r) V@12@03) (<= 0 (inv@346@03 r)))
        (< (inv@345@03 r) V@12@03))
      (<= 0 (inv@345@03 r)))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@336@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@11@03) (inv@345@03 r)))) (inv@346@03 r))
      r))
  :pattern ((inv@345@03 r))
  :pattern ((inv@346@03 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@346@03 r) V@12@03) (<= 0 (inv@346@03 r)))
        (< (inv@345@03 r) V@12@03))
      (<= 0 (inv@345@03 r)))
    ($FVF.loc_int ($FVF.lookup_int (as sm@347@03  $FVF<Int>) r) r))
  :pattern ((inv@345@03 r) (inv@346@03 r))
  )))
; Precomputing data for removing quantified permissions
(define-fun pTaken@348@03 ((r $Ref)) $Perm
  (ite
    (and
      (and
        (and (< (inv@346@03 r) V@12@03) (<= 0 (inv@346@03 r)))
        (< (inv@345@03 r) V@12@03))
      (<= 0 (inv@345@03 r)))
    ($Perm.min
      (ite
        (and (< (inv@120@03 r) V@12@03) (<= 0 (inv@120@03 r)))
        $Perm.Write
        $Perm.No)
      $Perm.Write)
    $Perm.No))
(define-fun pTaken@349@03 ((r $Ref)) $Perm
  (ite
    (and
      (and
        (and (< (inv@346@03 r) V@12@03) (<= 0 (inv@346@03 r)))
        (< (inv@345@03 r) V@12@03))
      (<= 0 (inv@345@03 r)))
    ($Perm.min
      (ite
        (and
          (and
            (and (< (inv@117@03 r) V@12@03) (<= 0 (inv@117@03 r)))
            (< (inv@116@03 r) V@12@03))
          (<= 0 (inv@116@03 r)))
        $Perm.Write
        $Perm.No)
      (- $Perm.Write (pTaken@348@03 r)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 500)
(push) ; 12
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and (< (inv@120@03 r) V@12@03) (<= 0 (inv@120@03 r)))
        $Perm.Write
        $Perm.No)
      (pTaken@348@03 r))
    $Perm.No)
  
  ))))
(check-sat)
; unknown
(pop) ; 12
; 0.11s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1882209
;  :arith-add-rows          555981
;  :arith-assert-diseq      69460
;  :arith-assert-lower      515660
;  :arith-assert-upper      418615
;  :arith-bound-prop        23957
;  :arith-conflicts         1506
;  :arith-eq-adapter        257805
;  :arith-fixed-eqs         326892
;  :arith-offset-eqs        123190
;  :arith-pivots            64096
;  :conflicts               3592
;  :datatype-accessor-ax    663
;  :datatype-constructor-ax 1885
;  :datatype-occurs-check   1371
;  :datatype-splits         1220
;  :decisions               166824
;  :del-clause              2676361
;  :final-checks            188
;  :interface-eqs           44
;  :max-generation          15
;  :max-memory              50.39
;  :memory                  45.49
;  :minimized-lits          512
;  :mk-bool-var             3013772
;  :mk-clause               2677419
;  :num-allocs              9659739
;  :num-checks              468
;  :propagations            1061184
;  :quant-instantiations    1247084
;  :restarts                4
;  :rlimit-count            32220551
;  :time                    0.09)
; Intermediate check if already taken enough permissions
(push) ; 12
(assert (not (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@346@03 r) V@12@03) (<= 0 (inv@346@03 r)))
        (< (inv@345@03 r) V@12@03))
      (<= 0 (inv@345@03 r)))
    (= (- $Perm.Write (pTaken@348@03 r)) $Perm.No))
  
  ))))
(check-sat)
; unknown
(pop) ; 12
; 0.12s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1892285
;  :arith-add-rows          561255
;  :arith-assert-diseq      69828
;  :arith-assert-lower      518675
;  :arith-assert-upper      420443
;  :arith-bound-prop        24205
;  :arith-conflicts         1529
;  :arith-eq-adapter        259319
;  :arith-fixed-eqs         328250
;  :arith-offset-eqs        124245
;  :arith-pivots            64843
;  :conflicts               3630
;  :datatype-accessor-ax    682
;  :datatype-constructor-ax 1936
;  :datatype-occurs-check   1427
;  :datatype-splits         1268
;  :decisions               167733
;  :del-clause              2686218
;  :final-checks            196
;  :interface-eqs           44
;  :max-generation          15
;  :max-memory              50.39
;  :memory                  45.68
;  :minimized-lits          516
;  :mk-bool-var             3025894
;  :mk-clause               2687276
;  :num-allocs              9702001
;  :num-checks              469
;  :propagations            1067732
;  :quant-instantiations    1251934
;  :restarts                4
;  :rlimit-count            32441728
;  :time                    0.12)
; Chunk depleted?
(push) ; 12
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and
          (and
            (and (< (inv@117@03 r) V@12@03) (<= 0 (inv@117@03 r)))
            (< (inv@116@03 r) V@12@03))
          (<= 0 (inv@116@03 r)))
        $Perm.Write
        $Perm.No)
      (pTaken@349@03 r))
    $Perm.No)
  
  ))))
(check-sat)
; unknown
(pop) ; 12
; 0.21s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1907272
;  :arith-add-rows          568464
;  :arith-assert-diseq      70275
;  :arith-assert-lower      523088
;  :arith-assert-upper      423046
;  :arith-bound-prop        24754
;  :arith-conflicts         1568
;  :arith-eq-adapter        261512
;  :arith-fixed-eqs         330441
;  :arith-offset-eqs        125809
;  :arith-pivots            66064
;  :conflicts               3686
;  :datatype-accessor-ax    701
;  :datatype-constructor-ax 1987
;  :datatype-occurs-check   1483
;  :datatype-splits         1316
;  :decisions               169103
;  :del-clause              2704453
;  :final-checks            204
;  :interface-eqs           44
;  :max-generation          15
;  :max-memory              50.39
;  :memory                  45.71
;  :minimized-lits          517
;  :mk-bool-var             3046119
;  :mk-clause               2705511
;  :num-allocs              9762787
;  :num-checks              470
;  :propagations            1077362
;  :quant-instantiations    1259361
;  :restarts                4
;  :rlimit-count            32749430
;  :time                    0.21)
; Intermediate check if already taken enough permissions
(push) ; 12
(assert (not (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@346@03 r) V@12@03) (<= 0 (inv@346@03 r)))
        (< (inv@345@03 r) V@12@03))
      (<= 0 (inv@345@03 r)))
    (= (- (- $Perm.Write (pTaken@348@03 r)) (pTaken@349@03 r)) $Perm.No))
  
  ))))
(check-sat)
; unsat
(pop) ; 12
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1907973
;  :arith-add-rows          568752
;  :arith-assert-diseq      70304
;  :arith-assert-lower      523231
;  :arith-assert-upper      423157
;  :arith-bound-prop        24802
;  :arith-conflicts         1576
;  :arith-eq-adapter        261653
;  :arith-fixed-eqs         330535
;  :arith-offset-eqs        125918
;  :arith-pivots            66135
;  :conflicts               3710
;  :datatype-accessor-ax    701
;  :datatype-constructor-ax 1991
;  :datatype-occurs-check   1483
;  :datatype-splits         1316
;  :decisions               169130
;  :del-clause              2705157
;  :final-checks            204
;  :interface-eqs           44
;  :max-generation          15
;  :max-memory              50.39
;  :memory                  45.66
;  :minimized-lits          520
;  :mk-bool-var             3047038
;  :mk-clause               2706215
;  :num-allocs              9766458
;  :num-checks              471
;  :propagations            1077721
;  :quant-instantiations    1259615
;  :restarts                4
;  :rlimit-count            32765869
;  :time                    0.01)
; Final check if taken enough permissions
; Done removing quantified permissions
; Definitional axioms for snapshot map values
; [eval] exc == null
(set-option :timeout 10)
(push) ; 12
(assert (not (not (= exc@89@03 $Ref.null))))
(check-sat)
; unknown
(pop) ; 12
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1908989
;  :arith-add-rows          569280
;  :arith-assert-diseq      70325
;  :arith-assert-lower      523445
;  :arith-assert-upper      423287
;  :arith-bound-prop        24851
;  :arith-conflicts         1584
;  :arith-eq-adapter        261787
;  :arith-fixed-eqs         330652
;  :arith-offset-eqs        126047
;  :arith-pivots            66199
;  :conflicts               3720
;  :datatype-accessor-ax    701
;  :datatype-constructor-ax 1995
;  :datatype-occurs-check   1483
;  :datatype-splits         1316
;  :decisions               169280
;  :del-clause              2706917
;  :final-checks            204
;  :interface-eqs           44
;  :max-generation          15
;  :max-memory              50.39
;  :memory                  45.64
;  :minimized-lits          526
;  :mk-bool-var             3048597
;  :mk-clause               2707975
;  :num-allocs              9770277
;  :num-checks              472
;  :propagations            1078346
;  :quant-instantiations    1260075
;  :restarts                4
;  :rlimit-count            32796893
;  :time                    0.01)
; [then-branch: 214 | exc@89@03 == Null | live]
; [else-branch: 214 | exc@89@03 != Null | dead]
(push) ; 12
; [then-branch: 214 | exc@89@03 == Null]
(declare-const i1@350@03 Int)
(push) ; 13
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 14
; [then-branch: 215 | 0 <= i1@350@03 | live]
; [else-branch: 215 | !(0 <= i1@350@03) | live]
(push) ; 15
; [then-branch: 215 | 0 <= i1@350@03]
(assert (<= 0 i1@350@03))
; [eval] i1 < V
(pop) ; 15
(push) ; 15
; [else-branch: 215 | !(0 <= i1@350@03)]
(assert (not (<= 0 i1@350@03)))
(pop) ; 15
(pop) ; 14
; Joined path conditions
; Joined path conditions
(assert (and (< i1@350@03 V@12@03) (<= 0 i1@350@03)))
; [eval] aloc(opt_get1(p), i1)
; [eval] opt_get1(p)
(push) ; 14
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 14
; Joined path conditions
(push) ; 14
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 15
(assert (not (< i1@350@03 (alen<Int> (opt_get1 $Snap.unit p@15@03)))))
(check-sat)
; unsat
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1908989
;  :arith-add-rows          569281
;  :arith-assert-diseq      70325
;  :arith-assert-lower      523446
;  :arith-assert-upper      423288
;  :arith-bound-prop        24851
;  :arith-conflicts         1584
;  :arith-eq-adapter        261787
;  :arith-fixed-eqs         330652
;  :arith-offset-eqs        126047
;  :arith-pivots            66199
;  :conflicts               3720
;  :datatype-accessor-ax    701
;  :datatype-constructor-ax 1995
;  :datatype-occurs-check   1483
;  :datatype-splits         1316
;  :decisions               169280
;  :del-clause              2706917
;  :final-checks            204
;  :interface-eqs           44
;  :max-generation          15
;  :max-memory              50.39
;  :memory                  45.64
;  :minimized-lits          526
;  :mk-bool-var             3048599
;  :mk-clause               2707975
;  :num-allocs              9770397
;  :num-checks              473
;  :propagations            1078346
;  :quant-instantiations    1260075
;  :restarts                4
;  :rlimit-count            32797071)
(assert (< i1@350@03 (alen<Int> (opt_get1 $Snap.unit p@15@03))))
(pop) ; 14
; Joined path conditions
(assert (< i1@350@03 (alen<Int> (opt_get1 $Snap.unit p@15@03))))
(pop) ; 13
(declare-fun inv@351@03 ($Ref) Int)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(assert (forall ((i1@350@03 Int)) (!
  (< i1@350@03 (alen<Int> (opt_get1 $Snap.unit p@15@03)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) i1@350@03))
  :qid |int-aux|)))
(declare-const sm@352@03 $FVF<Int>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (ite
          (and
            (and
              (and (< (inv@117@03 r) V@12@03) (<= 0 (inv@117@03 r)))
              (< (inv@116@03 r) V@12@03))
            (<= 0 (inv@116@03 r)))
          $Perm.Write
          $Perm.No)
        (pTaken@349@03 r)))
    (=
      ($FVF.lookup_int (as sm@352@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@352@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03))))))))))))))) r))
  :qid |qp.fvfValDef164|)))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (ite
          (and (< (inv@120@03 r) V@12@03) (<= 0 (inv@120@03 r)))
          $Perm.Write
          $Perm.No)
        (pTaken@348@03 r)))
    (=
      ($FVF.lookup_int (as sm@352@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03)))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@352@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03)))))))))))))))) r))
  :qid |qp.fvfValDef165|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03)))))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@352@03  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef166|)))
; Check receiver injectivity
(push) ; 13
(assert (not (forall ((i11@350@03 Int) (i12@350@03 Int)) (!
  (implies
    (and
      (and
        (and (< i11@350@03 V@12@03) (<= 0 i11@350@03))
        ($FVF.loc_int ($FVF.lookup_int (as sm@352@03  $FVF<Int>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit p@15@03) i11@350@03)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit p@15@03) i11@350@03)))
      (and
        (and (< i12@350@03 V@12@03) (<= 0 i12@350@03))
        ($FVF.loc_int ($FVF.lookup_int (as sm@352@03  $FVF<Int>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit p@15@03) i12@350@03)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit p@15@03) i12@350@03)))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) i11@350@03)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) i12@350@03)))
    (= i11@350@03 i12@350@03))
  
  :qid |int-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1909014
;  :arith-add-rows          569290
;  :arith-assert-diseq      70326
;  :arith-assert-lower      523450
;  :arith-assert-upper      423288
;  :arith-bound-prop        24851
;  :arith-conflicts         1584
;  :arith-eq-adapter        261788
;  :arith-fixed-eqs         330652
;  :arith-offset-eqs        126047
;  :arith-pivots            66199
;  :conflicts               3721
;  :datatype-accessor-ax    701
;  :datatype-constructor-ax 1995
;  :datatype-occurs-check   1483
;  :datatype-splits         1316
;  :decisions               169280
;  :del-clause              2706953
;  :final-checks            204
;  :interface-eqs           44
;  :max-generation          15
;  :max-memory              50.39
;  :memory                  45.64
;  :minimized-lits          526
;  :mk-bool-var             3048672
;  :mk-clause               2708011
;  :num-allocs              9771749
;  :num-checks              474
;  :propagations            1078348
;  :quant-instantiations    1260115
;  :restarts                4
;  :rlimit-count            32801638)
; Definitional axioms for inverse functions
(assert (forall ((i1@350@03 Int)) (!
  (implies
    (and (< i1@350@03 V@12@03) (<= 0 i1@350@03))
    (=
      (inv@351@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) i1@350@03))
      i1@350@03))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) i1@350@03))
  :qid |int-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@351@03 r) V@12@03) (<= 0 (inv@351@03 r)))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) (inv@351@03 r))
      r))
  :pattern ((inv@351@03 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@351@03 r) V@12@03) (<= 0 (inv@351@03 r)))
    ($FVF.loc_int ($FVF.lookup_int (as sm@352@03  $FVF<Int>) r) r))
  :pattern ((inv@351@03 r))
  )))
; Precomputing data for removing quantified permissions
(define-fun pTaken@353@03 ((r $Ref)) $Perm
  (ite
    (and (< (inv@351@03 r) V@12@03) (<= 0 (inv@351@03 r)))
    ($Perm.min
      (-
        (ite
          (and
            (and
              (and (< (inv@117@03 r) V@12@03) (<= 0 (inv@117@03 r)))
              (< (inv@116@03 r) V@12@03))
            (<= 0 (inv@116@03 r)))
          $Perm.Write
          $Perm.No)
        (pTaken@349@03 r))
      $Perm.Write)
    $Perm.No))
(define-fun pTaken@354@03 ((r $Ref)) $Perm
  (ite
    (and (< (inv@351@03 r) V@12@03) (<= 0 (inv@351@03 r)))
    ($Perm.min
      (-
        (ite
          (and (< (inv@120@03 r) V@12@03) (<= 0 (inv@120@03 r)))
          $Perm.Write
          $Perm.No)
        (pTaken@348@03 r))
      (- $Perm.Write (pTaken@353@03 r)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 500)
(push) ; 13
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (-
        (ite
          (and
            (and
              (and (< (inv@117@03 r) V@12@03) (<= 0 (inv@117@03 r)))
              (< (inv@116@03 r) V@12@03))
            (<= 0 (inv@116@03 r)))
          $Perm.Write
          $Perm.No)
        (pTaken@349@03 r))
      (pTaken@353@03 r))
    $Perm.No)
  
  ))))
(check-sat)
; unsat
(pop) ; 13
; 0.02s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1911488
;  :arith-add-rows          570469
;  :arith-assert-diseq      70372
;  :arith-assert-lower      524043
;  :arith-assert-upper      423690
;  :arith-bound-prop        24951
;  :arith-conflicts         1598
;  :arith-eq-adapter        262223
;  :arith-fixed-eqs         331008
;  :arith-offset-eqs        126307
;  :arith-pivots            66429
;  :conflicts               3758
;  :datatype-accessor-ax    701
;  :datatype-constructor-ax 2003
;  :datatype-occurs-check   1483
;  :datatype-splits         1316
;  :decisions               169498
;  :del-clause              2711012
;  :final-checks            204
;  :interface-eqs           44
;  :max-generation          15
;  :max-memory              50.39
;  :memory                  45.43
;  :minimized-lits          528
;  :mk-bool-var             3054376
;  :mk-clause               2712138
;  :num-allocs              9791957
;  :num-checks              476
;  :propagations            1079776
;  :quant-instantiations    1261585
;  :restarts                4
;  :rlimit-count            32878244
;  :time                    0.02)
; Intermediate check if already taken enough permissions
(push) ; 13
(assert (not (forall ((r $Ref)) (!
  (implies
    (and (< (inv@351@03 r) V@12@03) (<= 0 (inv@351@03 r)))
    (= (- $Perm.Write (pTaken@353@03 r)) $Perm.No))
  
  ))))
(check-sat)
; unknown
(pop) ; 13
; 0.13s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1923529
;  :arith-add-rows          574155
;  :arith-assert-diseq      70858
;  :arith-assert-lower      527300
;  :arith-assert-upper      426155
;  :arith-bound-prop        25144
;  :arith-conflicts         1621
;  :arith-eq-adapter        264100
;  :arith-fixed-eqs         332411
;  :arith-offset-eqs        127388
;  :arith-pivots            67146
;  :conflicts               3817
;  :datatype-accessor-ax    720
;  :datatype-constructor-ax 2055
;  :datatype-occurs-check   1545
;  :datatype-splits         1369
;  :decisions               171093
;  :del-clause              2727140
;  :final-checks            216
;  :interface-eqs           48
;  :max-generation          15
;  :max-memory              50.39
;  :memory                  45.74
;  :minimized-lits          542
;  :mk-bool-var             3073396
;  :mk-clause               2728266
;  :num-allocs              9858084
;  :num-checks              477
;  :propagations            1087825
;  :quant-instantiations    1269200
;  :restarts                4
;  :rlimit-count            33114385
;  :time                    0.13)
; Chunk depleted?
(push) ; 13
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (-
        (ite
          (and (< (inv@120@03 r) V@12@03) (<= 0 (inv@120@03 r)))
          $Perm.Write
          $Perm.No)
        (pTaken@348@03 r))
      (pTaken@354@03 r))
    $Perm.No)
  
  ))))
(check-sat)
; unsat
(pop) ; 13
; 0.03s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1925811
;  :arith-add-rows          576134
;  :arith-assert-diseq      70948
;  :arith-assert-lower      527868
;  :arith-assert-upper      426563
;  :arith-bound-prop        25273
;  :arith-conflicts         1644
;  :arith-eq-adapter        264603
;  :arith-fixed-eqs         332753
;  :arith-offset-eqs        127656
;  :arith-pivots            67472
;  :conflicts               3867
;  :datatype-accessor-ax    720
;  :datatype-constructor-ax 2059
;  :datatype-occurs-check   1545
;  :datatype-splits         1369
;  :decisions               171205
;  :del-clause              2731057
;  :final-checks            216
;  :interface-eqs           48
;  :max-generation          15
;  :max-memory              50.39
;  :memory                  45.70
;  :minimized-lits          558
;  :mk-bool-var             3078880
;  :mk-clause               2732183
;  :num-allocs              9878448
;  :num-checks              478
;  :propagations            1089189
;  :quant-instantiations    1270400
;  :restarts                4
;  :rlimit-count            33183222
;  :time                    0.03)
; Intermediate check if already taken enough permissions
(push) ; 13
(assert (not (forall ((r $Ref)) (!
  (implies
    (and (< (inv@351@03 r) V@12@03) (<= 0 (inv@351@03 r)))
    (= (- (- $Perm.Write (pTaken@353@03 r)) (pTaken@354@03 r)) $Perm.No))
  
  ))))
(check-sat)
; unsat
(pop) ; 13
; 0.04s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1928339
;  :arith-add-rows          577991
;  :arith-assert-diseq      71018
;  :arith-assert-lower      528509
;  :arith-assert-upper      427016
;  :arith-bound-prop        25409
;  :arith-conflicts         1661
;  :arith-eq-adapter        265093
;  :arith-fixed-eqs         333153
;  :arith-offset-eqs        127857
;  :arith-pivots            67781
;  :conflicts               3910
;  :datatype-accessor-ax    720
;  :datatype-constructor-ax 2063
;  :datatype-occurs-check   1545
;  :datatype-splits         1369
;  :decisions               171342
;  :del-clause              2735642
;  :final-checks            216
;  :interface-eqs           48
;  :max-generation          15
;  :max-memory              50.39
;  :memory                  45.70
;  :minimized-lits          572
;  :mk-bool-var             3085030
;  :mk-clause               2736768
;  :num-allocs              9900571
;  :num-checks              479
;  :propagations            1090943
;  :quant-instantiations    1271808
;  :restarts                4
;  :rlimit-count            33260350
;  :time                    0.04)
; Final check if taken enough permissions
; Done removing quantified permissions
; Definitional axioms for snapshot map values
; [eval] exc == null ==> valid_graph_vertices(this, p, V)
; [eval] exc == null
(push) ; 13
(set-option :timeout 10)
(push) ; 14
(assert (not (not (= exc@89@03 $Ref.null))))
(check-sat)
; unknown
(pop) ; 14
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1929455
;  :arith-add-rows          578234
;  :arith-assert-diseq      71037
;  :arith-assert-lower      528753
;  :arith-assert-upper      427173
;  :arith-bound-prop        25451
;  :arith-conflicts         1663
;  :arith-eq-adapter        265233
;  :arith-fixed-eqs         333326
;  :arith-offset-eqs        128044
;  :arith-pivots            67822
;  :conflicts               3912
;  :datatype-accessor-ax    720
;  :datatype-constructor-ax 2067
;  :datatype-occurs-check   1545
;  :datatype-splits         1369
;  :decisions               171427
;  :del-clause              2736906
;  :final-checks            216
;  :interface-eqs           48
;  :max-generation          15
;  :max-memory              50.39
;  :memory                  45.70
;  :minimized-lits          572
;  :mk-bool-var             3086414
;  :mk-clause               2738032
;  :num-allocs              9904875
;  :num-checks              480
;  :propagations            1091653
;  :quant-instantiations    1272332
;  :restarts                4
;  :rlimit-count            33284356
;  :time                    0.01)
; [then-branch: 216 | exc@89@03 == Null | live]
; [else-branch: 216 | exc@89@03 != Null | dead]
(push) ; 14
; [then-branch: 216 | exc@89@03 == Null]
; [eval] valid_graph_vertices(this, p, V)
(push) ; 15
; [eval] this != null
; [eval] p != (None(): option[array])
; [eval] (None(): option[array])
; [eval] alen(opt_get1(p)) == V
; [eval] alen(opt_get1(p))
; [eval] opt_get1(p)
(push) ; 16
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 16
; Joined path conditions
(declare-const i1@355@03 Int)
(push) ; 16
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 17
; [then-branch: 217 | 0 <= i1@355@03 | live]
; [else-branch: 217 | !(0 <= i1@355@03) | live]
(push) ; 18
; [then-branch: 217 | 0 <= i1@355@03]
(assert (<= 0 i1@355@03))
; [eval] i1 < V
(pop) ; 18
(push) ; 18
; [else-branch: 217 | !(0 <= i1@355@03)]
(assert (not (<= 0 i1@355@03)))
(pop) ; 18
(pop) ; 17
; Joined path conditions
; Joined path conditions
(assert (and (< i1@355@03 V@12@03) (<= 0 i1@355@03)))
(declare-const $k@356@03 $Perm)
(assert ($Perm.isReadVar $k@356@03 $Perm.Write))
; [eval] aloc(opt_get1(p), i1)
; [eval] opt_get1(p)
(push) ; 17
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 17
; Joined path conditions
(push) ; 17
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 18
(assert (not (< i1@355@03 (alen<Int> (opt_get1 $Snap.unit p@15@03)))))
(check-sat)
; unsat
(pop) ; 18
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1929455
;  :arith-add-rows          578235
;  :arith-assert-diseq      71038
;  :arith-assert-lower      528757
;  :arith-assert-upper      427174
;  :arith-bound-prop        25451
;  :arith-conflicts         1663
;  :arith-eq-adapter        265234
;  :arith-fixed-eqs         333326
;  :arith-offset-eqs        128044
;  :arith-pivots            67822
;  :conflicts               3912
;  :datatype-accessor-ax    720
;  :datatype-constructor-ax 2067
;  :datatype-occurs-check   1545
;  :datatype-splits         1369
;  :decisions               171427
;  :del-clause              2736906
;  :final-checks            216
;  :interface-eqs           48
;  :max-generation          15
;  :max-memory              50.39
;  :memory                  45.70
;  :minimized-lits          572
;  :mk-bool-var             3086420
;  :mk-clause               2738034
;  :num-allocs              9905046
;  :num-checks              481
;  :propagations            1091654
;  :quant-instantiations    1272332
;  :restarts                4
;  :rlimit-count            33284692)
(assert (< i1@355@03 (alen<Int> (opt_get1 $Snap.unit p@15@03))))
(pop) ; 17
; Joined path conditions
(assert (< i1@355@03 (alen<Int> (opt_get1 $Snap.unit p@15@03))))
(pop) ; 16
(declare-fun inv@357@03 ($Ref) Int)
; Nested auxiliary terms: globals
(assert ($Perm.isReadVar $k@356@03 $Perm.Write))
; Nested auxiliary terms: non-globals
(assert (forall ((i1@355@03 Int)) (!
  (< i1@355@03 (alen<Int> (opt_get1 $Snap.unit p@15@03)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) i1@355@03))
  :qid |int-aux|)))
(push) ; 16
(assert (not (forall ((i1@355@03 Int)) (!
  (implies
    (and (< i1@355@03 V@12@03) (<= 0 i1@355@03))
    (or (= $k@356@03 $Perm.No) (< $Perm.No $k@356@03)))
  
  ))))
(check-sat)
; unsat
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1929455
;  :arith-add-rows          578236
;  :arith-assert-diseq      71039
;  :arith-assert-lower      528759
;  :arith-assert-upper      427175
;  :arith-bound-prop        25451
;  :arith-conflicts         1663
;  :arith-eq-adapter        265235
;  :arith-fixed-eqs         333326
;  :arith-offset-eqs        128044
;  :arith-pivots            67822
;  :conflicts               3913
;  :datatype-accessor-ax    720
;  :datatype-constructor-ax 2067
;  :datatype-occurs-check   1545
;  :datatype-splits         1369
;  :decisions               171427
;  :del-clause              2736908
;  :final-checks            216
;  :interface-eqs           48
;  :max-generation          15
;  :max-memory              50.39
;  :memory                  45.70
;  :minimized-lits          572
;  :mk-bool-var             3086427
;  :mk-clause               2738036
;  :num-allocs              9905472
;  :num-checks              482
;  :propagations            1091655
;  :quant-instantiations    1272332
;  :restarts                4
;  :rlimit-count            33285239)
(declare-const sm@358@03 $FVF<Int>)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@117@03 r) V@12@03) (<= 0 (inv@117@03 r)))
        (< (inv@116@03 r) V@12@03))
      (<= 0 (inv@116@03 r)))
    (=
      ($FVF.lookup_int (as sm@358@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@358@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03))))))))))))))) r))
  :qid |qp.fvfValDef167|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@120@03 r) V@12@03) (<= 0 (inv@120@03 r)))
    (=
      ($FVF.lookup_int (as sm@358@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03)))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@358@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03)))))))))))))))) r))
  :qid |qp.fvfValDef168|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03)))))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@358@03  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef169|)))
; Check receiver injectivity
(push) ; 16
(assert (not (forall ((i11@355@03 Int) (i12@355@03 Int)) (!
  (implies
    (and
      (and
        (and
          (and (< i11@355@03 V@12@03) (<= 0 i11@355@03))
          ($FVF.loc_int ($FVF.lookup_int (as sm@358@03  $FVF<Int>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit p@15@03) i11@355@03)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit p@15@03) i11@355@03)))
        (< $Perm.No $k@356@03))
      (and
        (and
          (and (< i12@355@03 V@12@03) (<= 0 i12@355@03))
          ($FVF.loc_int ($FVF.lookup_int (as sm@358@03  $FVF<Int>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit p@15@03) i12@355@03)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit p@15@03) i12@355@03)))
        (< $Perm.No $k@356@03))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) i11@355@03)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) i12@355@03)))
    (= i11@355@03 i12@355@03))
  
  :qid |int-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1929482
;  :arith-add-rows          578243
;  :arith-assert-diseq      71040
;  :arith-assert-lower      528763
;  :arith-assert-upper      427175
;  :arith-bound-prop        25451
;  :arith-conflicts         1663
;  :arith-eq-adapter        265236
;  :arith-fixed-eqs         333326
;  :arith-offset-eqs        128044
;  :arith-pivots            67822
;  :conflicts               3914
;  :datatype-accessor-ax    720
;  :datatype-constructor-ax 2067
;  :datatype-occurs-check   1545
;  :datatype-splits         1369
;  :decisions               171427
;  :del-clause              2736919
;  :final-checks            216
;  :interface-eqs           48
;  :max-generation          15
;  :max-memory              50.39
;  :memory                  45.67
;  :minimized-lits          572
;  :mk-bool-var             3086478
;  :mk-clause               2738047
;  :num-allocs              9906511
;  :num-checks              483
;  :propagations            1091657
;  :quant-instantiations    1272376
;  :restarts                4
;  :rlimit-count            33288469
;  :time                    0.00)
; Definitional axioms for inverse functions
(assert (forall ((i1@355@03 Int)) (!
  (implies
    (and (and (< i1@355@03 V@12@03) (<= 0 i1@355@03)) (< $Perm.No $k@356@03))
    (=
      (inv@357@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) i1@355@03))
      i1@355@03))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) i1@355@03))
  :qid |int-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and (< (inv@357@03 r) V@12@03) (<= 0 (inv@357@03 r)))
      (< $Perm.No $k@356@03))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) (inv@357@03 r))
      r))
  :pattern ((inv@357@03 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@357@03 r) V@12@03) (<= 0 (inv@357@03 r)))
    ($FVF.loc_int ($FVF.lookup_int (as sm@358@03  $FVF<Int>) r) r))
  :pattern ((inv@357@03 r))
  )))
; Precomputing data for removing quantified permissions
(define-fun pTaken@359@03 ((r $Ref)) $Perm
  (ite
    (and (< (inv@357@03 r) V@12@03) (<= 0 (inv@357@03 r)))
    ($Perm.min
      (ite
        (and
          (and
            (and (< (inv@117@03 r) V@12@03) (<= 0 (inv@117@03 r)))
            (< (inv@116@03 r) V@12@03))
          (<= 0 (inv@116@03 r)))
        $Perm.Write
        $Perm.No)
      $k@356@03)
    $Perm.No))
(define-fun pTaken@360@03 ((r $Ref)) $Perm
  (ite
    (and (< (inv@357@03 r) V@12@03) (<= 0 (inv@357@03 r)))
    ($Perm.min
      (ite
        (and (< (inv@120@03 r) V@12@03) (<= 0 (inv@120@03 r)))
        $Perm.Write
        $Perm.No)
      (- $k@356@03 (pTaken@359@03 r)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Constrain original permissions $k@356@03
(assert (forall ((r $Ref)) (!
  (implies
    (not
      (=
        (ite
          (and
            (and
              (and (< (inv@117@03 r) V@12@03) (<= 0 (inv@117@03 r)))
              (< (inv@116@03 r) V@12@03))
            (<= 0 (inv@116@03 r)))
          $Perm.Write
          $Perm.No)
        $Perm.No))
    (ite
      (and
        (and
          (and (< (inv@117@03 r) V@12@03) (<= 0 (inv@117@03 r)))
          (< (inv@116@03 r) V@12@03))
        (<= 0 (inv@116@03 r)))
      (<
        (ite
          (and (< (inv@357@03 r) V@12@03) (<= 0 (inv@357@03 r)))
          $k@356@03
          $Perm.No)
        $Perm.Write)
      (<
        (ite
          (and (< (inv@357@03 r) V@12@03) (<= 0 (inv@357@03 r)))
          $k@356@03
          $Perm.No)
        $Perm.No)))
  :pattern ((inv@117@03 r))
  :pattern ((inv@116@03 r))
  :pattern ((inv@357@03 r))
  :qid |qp.srp170|)))
; Intermediate check if already taken enough permissions
(set-option :timeout 500)
(push) ; 16
(assert (not (forall ((r $Ref)) (!
  (implies
    (and (< (inv@357@03 r) V@12@03) (<= 0 (inv@357@03 r)))
    (= (- $k@356@03 (pTaken@359@03 r)) $Perm.No))
  
  ))))
(check-sat)
; unknown
(pop) ; 16
; 0.19s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1946640
;  :arith-add-rows          583350
;  :arith-assert-diseq      71733
;  :arith-assert-lower      533450
;  :arith-assert-upper      430848
;  :arith-bound-prop        25729
;  :arith-conflicts         1688
;  :arith-eq-adapter        268084
;  :arith-fixed-eqs         335484
;  :arith-offset-eqs        129373
;  :arith-pivots            68709
;  :conflicts               3987
;  :datatype-accessor-ax    739
;  :datatype-constructor-ax 2123
;  :datatype-occurs-check   1607
;  :datatype-splits         1422
;  :decisions               173469
;  :del-clause              2760546
;  :final-checks            227
;  :interface-eqs           51
;  :max-generation          15
;  :max-memory              50.39
;  :memory                  45.84
;  :minimized-lits          589
;  :mk-bool-var             3113356
;  :mk-clause               2761754
;  :num-allocs              9998259
;  :num-checks              485
;  :propagations            1103294
;  :quant-instantiations    1283514
;  :restarts                4
;  :rlimit-count            33618204
;  :time                    0.19)
; Constrain original permissions $k@356@03
(assert (forall ((r $Ref)) (!
  (implies
    (not
      (=
        (ite
          (and (< (inv@120@03 r) V@12@03) (<= 0 (inv@120@03 r)))
          $Perm.Write
          $Perm.No)
        $Perm.No))
    (ite
      (and (< (inv@120@03 r) V@12@03) (<= 0 (inv@120@03 r)))
      (<
        (ite
          (and (< (inv@357@03 r) V@12@03) (<= 0 (inv@357@03 r)))
          $k@356@03
          $Perm.No)
        $Perm.Write)
      (<
        (ite
          (and (< (inv@357@03 r) V@12@03) (<= 0 (inv@357@03 r)))
          $k@356@03
          $Perm.No)
        $Perm.No)))
  :pattern ((inv@120@03 r))
  :pattern ((inv@357@03 r))
  :qid |qp.srp171|)))
; Intermediate check if already taken enough permissions
(push) ; 16
(assert (not (forall ((r $Ref)) (!
  (implies
    (and (< (inv@357@03 r) V@12@03) (<= 0 (inv@357@03 r)))
    (= (- (- $k@356@03 (pTaken@359@03 r)) (pTaken@360@03 r)) $Perm.No))
  
  ))))
(check-sat)
; unsat
(pop) ; 16
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1947381
;  :arith-add-rows          583588
;  :arith-assert-diseq      71759
;  :arith-assert-lower      533598
;  :arith-assert-upper      430951
;  :arith-bound-prop        25758
;  :arith-conflicts         1694
;  :arith-eq-adapter        268240
;  :arith-fixed-eqs         335573
;  :arith-offset-eqs        129466
;  :arith-pivots            68763
;  :conflicts               4013
;  :datatype-accessor-ax    739
;  :datatype-constructor-ax 2127
;  :datatype-occurs-check   1607
;  :datatype-splits         1422
;  :decisions               173500
;  :del-clause              2761433
;  :final-checks            227
;  :interface-eqs           51
;  :max-generation          15
;  :max-memory              50.39
;  :memory                  45.78
;  :minimized-lits          593
;  :mk-bool-var             3114633
;  :mk-clause               2762641
;  :num-allocs              10003612
;  :num-checks              486
;  :propagations            1103718
;  :quant-instantiations    1283835
;  :restarts                4
;  :rlimit-count            33636055
;  :time                    0.01)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@361@03 $FVF<Int>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (iff
    (Set_in r ($FVF.domain_int (as sm@361@03  $FVF<Int>)))
    (and
      (and (< (inv@357@03 r) V@12@03) (<= 0 (inv@357@03 r)))
      (< $Perm.No $k@356@03)))
  :pattern ((Set_in r ($FVF.domain_int (as sm@361@03  $FVF<Int>))))
  :qid |qp.fvfDomDef175|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@357@03 r) V@12@03) (<= 0 (inv@357@03 r)))
        (< $Perm.No $k@356@03))
      (and
        (and
          (and (< (inv@117@03 r) V@12@03) (<= 0 (inv@117@03 r)))
          (< (inv@116@03 r) V@12@03))
        (<= 0 (inv@116@03 r))))
    (=
      ($FVF.lookup_int (as sm@361@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@361@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03))))))))))))))) r))
  :qid |qp.fvfValDef172|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@357@03 r) V@12@03) (<= 0 (inv@357@03 r)))
        (< $Perm.No $k@356@03))
      (and (< (inv@120@03 r) V@12@03) (<= 0 (inv@120@03 r))))
    (=
      ($FVF.lookup_int (as sm@361@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03)))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@361@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03)))))))))))))))) r))
  :qid |qp.fvfValDef173|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03)))))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@361@03  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef174|)))
(pop) ; 15
; Joined path conditions
(assert ($Perm.isReadVar $k@356@03 $Perm.Write))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@117@03 r) V@12@03) (<= 0 (inv@117@03 r)))
        (< (inv@116@03 r) V@12@03))
      (<= 0 (inv@116@03 r)))
    (=
      ($FVF.lookup_int (as sm@358@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@358@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03))))))))))))))) r))
  :qid |qp.fvfValDef167|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@120@03 r) V@12@03) (<= 0 (inv@120@03 r)))
    (=
      ($FVF.lookup_int (as sm@358@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03)))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@358@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03)))))))))))))))) r))
  :qid |qp.fvfValDef168|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03)))))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@358@03  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef169|)))
(assert (forall ((i1@355@03 Int)) (!
  (implies
    (and (and (< i1@355@03 V@12@03) (<= 0 i1@355@03)) (< $Perm.No $k@356@03))
    (=
      (inv@357@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) i1@355@03))
      i1@355@03))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) i1@355@03))
  :qid |int-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and (< (inv@357@03 r) V@12@03) (<= 0 (inv@357@03 r)))
      (< $Perm.No $k@356@03))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) (inv@357@03 r))
      r))
  :pattern ((inv@357@03 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (iff
    (Set_in r ($FVF.domain_int (as sm@361@03  $FVF<Int>)))
    (and
      (and (< (inv@357@03 r) V@12@03) (<= 0 (inv@357@03 r)))
      (< $Perm.No $k@356@03)))
  :pattern ((Set_in r ($FVF.domain_int (as sm@361@03  $FVF<Int>))))
  :qid |qp.fvfDomDef175|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@357@03 r) V@12@03) (<= 0 (inv@357@03 r)))
        (< $Perm.No $k@356@03))
      (and
        (and
          (and (< (inv@117@03 r) V@12@03) (<= 0 (inv@117@03 r)))
          (< (inv@116@03 r) V@12@03))
        (<= 0 (inv@116@03 r))))
    (=
      ($FVF.lookup_int (as sm@361@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@361@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03))))))))))))))) r))
  :qid |qp.fvfValDef172|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@357@03 r) V@12@03) (<= 0 (inv@357@03 r)))
        (< $Perm.No $k@356@03))
      (and (< (inv@120@03 r) V@12@03) (<= 0 (inv@120@03 r))))
    (=
      ($FVF.lookup_int (as sm@361@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03)))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@361@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03)))))))))))))))) r))
  :qid |qp.fvfValDef173|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03)))))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@361@03  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef174|)))
(assert (and
  (forall ((i1@355@03 Int)) (!
    (< i1@355@03 (alen<Int> (opt_get1 $Snap.unit p@15@03)))
    :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) i1@355@03))
    :qid |int-aux|))
  (forall ((r $Ref)) (!
    (implies
      (and (< (inv@357@03 r) V@12@03) (<= 0 (inv@357@03 r)))
      ($FVF.loc_int ($FVF.lookup_int (as sm@358@03  $FVF<Int>) r) r))
    :pattern ((inv@357@03 r))
    ))
  (forall ((r $Ref)) (!
    (implies
      (not
        (=
          (ite
            (and
              (and
                (and (< (inv@117@03 r) V@12@03) (<= 0 (inv@117@03 r)))
                (< (inv@116@03 r) V@12@03))
              (<= 0 (inv@116@03 r)))
            $Perm.Write
            $Perm.No)
          $Perm.No))
      (ite
        (and
          (and
            (and (< (inv@117@03 r) V@12@03) (<= 0 (inv@117@03 r)))
            (< (inv@116@03 r) V@12@03))
          (<= 0 (inv@116@03 r)))
        (<
          (ite
            (and (< (inv@357@03 r) V@12@03) (<= 0 (inv@357@03 r)))
            $k@356@03
            $Perm.No)
          $Perm.Write)
        (<
          (ite
            (and (< (inv@357@03 r) V@12@03) (<= 0 (inv@357@03 r)))
            $k@356@03
            $Perm.No)
          $Perm.No)))
    :pattern ((inv@117@03 r))
    :pattern ((inv@116@03 r))
    :pattern ((inv@357@03 r))
    :qid |qp.srp170|))
  (forall ((r $Ref)) (!
    (implies
      (not
        (=
          (ite
            (and (< (inv@120@03 r) V@12@03) (<= 0 (inv@120@03 r)))
            $Perm.Write
            $Perm.No)
          $Perm.No))
      (ite
        (and (< (inv@120@03 r) V@12@03) (<= 0 (inv@120@03 r)))
        (<
          (ite
            (and (< (inv@357@03 r) V@12@03) (<= 0 (inv@357@03 r)))
            $k@356@03
            $Perm.No)
          $Perm.Write)
        (<
          (ite
            (and (< (inv@357@03 r) V@12@03) (<= 0 (inv@357@03 r)))
            $k@356@03
            $Perm.No)
          $Perm.No)))
    :pattern ((inv@120@03 r))
    :pattern ((inv@357@03 r))
    :qid |qp.srp171|))))
(pop) ; 14
(pop) ; 13
; Joined path conditions
(assert ($Perm.isReadVar $k@356@03 $Perm.Write))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@117@03 r) V@12@03) (<= 0 (inv@117@03 r)))
        (< (inv@116@03 r) V@12@03))
      (<= 0 (inv@116@03 r)))
    (=
      ($FVF.lookup_int (as sm@358@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@358@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03))))))))))))))) r))
  :qid |qp.fvfValDef167|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@120@03 r) V@12@03) (<= 0 (inv@120@03 r)))
    (=
      ($FVF.lookup_int (as sm@358@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03)))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@358@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03)))))))))))))))) r))
  :qid |qp.fvfValDef168|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03)))))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@358@03  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef169|)))
(assert (forall ((i1@355@03 Int)) (!
  (implies
    (and (and (< i1@355@03 V@12@03) (<= 0 i1@355@03)) (< $Perm.No $k@356@03))
    (=
      (inv@357@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) i1@355@03))
      i1@355@03))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) i1@355@03))
  :qid |int-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and (< (inv@357@03 r) V@12@03) (<= 0 (inv@357@03 r)))
      (< $Perm.No $k@356@03))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) (inv@357@03 r))
      r))
  :pattern ((inv@357@03 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (iff
    (Set_in r ($FVF.domain_int (as sm@361@03  $FVF<Int>)))
    (and
      (and (< (inv@357@03 r) V@12@03) (<= 0 (inv@357@03 r)))
      (< $Perm.No $k@356@03)))
  :pattern ((Set_in r ($FVF.domain_int (as sm@361@03  $FVF<Int>))))
  :qid |qp.fvfDomDef175|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@357@03 r) V@12@03) (<= 0 (inv@357@03 r)))
        (< $Perm.No $k@356@03))
      (and
        (and
          (and (< (inv@117@03 r) V@12@03) (<= 0 (inv@117@03 r)))
          (< (inv@116@03 r) V@12@03))
        (<= 0 (inv@116@03 r))))
    (=
      ($FVF.lookup_int (as sm@361@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@361@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03))))))))))))))) r))
  :qid |qp.fvfValDef172|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@357@03 r) V@12@03) (<= 0 (inv@357@03 r)))
        (< $Perm.No $k@356@03))
      (and (< (inv@120@03 r) V@12@03) (<= 0 (inv@120@03 r))))
    (=
      ($FVF.lookup_int (as sm@361@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03)))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@361@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03)))))))))))))))) r))
  :qid |qp.fvfValDef173|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@105@03)))))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@361@03  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef174|)))
(assert (implies
  (= exc@89@03 $Ref.null)
  (and
    (forall ((i1@355@03 Int)) (!
      (< i1@355@03 (alen<Int> (opt_get1 $Snap.unit p@15@03)))
      :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@15@03) i1@355@03))
      :qid |int-aux|))
    (forall ((r $Ref)) (!
      (implies
        (and (< (inv@357@03 r) V@12@03) (<= 0 (inv@357@03 r)))
        ($FVF.loc_int ($FVF.lookup_int (as sm@358@03  $FVF<Int>) r) r))
      :pattern ((inv@357@03 r))
      ))
    (forall ((r $Ref)) (!
      (implies
        (not
          (=
            (ite
              (and
                (and
                  (and (< (inv@117@03 r) V@12@03) (<= 0 (inv@117@03 r)))
                  (< (inv@116@03 r) V@12@03))
                (<= 0 (inv@116@03 r)))
              $Perm.Write
              $Perm.No)
            $Perm.No))
        (ite
          (and
            (and
              (and (< (inv@117@03 r) V@12@03) (<= 0 (inv@117@03 r)))
              (< (inv@116@03 r) V@12@03))
            (<= 0 (inv@116@03 r)))
          (<
            (ite
              (and (< (inv@357@03 r) V@12@03) (<= 0 (inv@357@03 r)))
              $k@356@03
              $Perm.No)
            $Perm.Write)
          (<
            (ite
              (and (< (inv@357@03 r) V@12@03) (<= 0 (inv@357@03 r)))
              $k@356@03
              $Perm.No)
            $Perm.No)))
      :pattern ((inv@117@03 r))
      :pattern ((inv@116@03 r))
      :pattern ((inv@357@03 r))
      :qid |qp.srp170|))
    (forall ((r $Ref)) (!
      (implies
        (not
          (=
            (ite
              (and (< (inv@120@03 r) V@12@03) (<= 0 (inv@120@03 r)))
              $Perm.Write
              $Perm.No)
            $Perm.No))
        (ite
          (and (< (inv@120@03 r) V@12@03) (<= 0 (inv@120@03 r)))
          (<
            (ite
              (and (< (inv@357@03 r) V@12@03) (<= 0 (inv@357@03 r)))
              $k@356@03
              $Perm.No)
            $Perm.Write)
          (<
            (ite
              (and (< (inv@357@03 r) V@12@03) (<= 0 (inv@357@03 r)))
              $k@356@03
              $Perm.No)
            $Perm.No)))
      :pattern ((inv@120@03 r))
      :pattern ((inv@357@03 r))
      :qid |qp.srp171|)))))
(set-option :timeout 0)
(push) ; 13
(assert (not (implies
  (= exc@89@03 $Ref.null)
  (valid_graph_vertices ($Snap.combine
    $Snap.unit
    ($Snap.combine
      $Snap.unit
      ($Snap.combine
        $Snap.unit
        ($SortWrappers.$FVF<Int>To$Snap (as sm@361@03  $FVF<Int>))))) this@9@03 p@15@03 V@12@03))))
(check-sat)
; unsat
(pop) ; 13
; 0.06s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1951628
;  :arith-add-rows          586274
;  :arith-assert-diseq      71809
;  :arith-assert-lower      534632
;  :arith-assert-upper      431723
;  :arith-bound-prop        25958
;  :arith-conflicts         1705
;  :arith-eq-adapter        268830
;  :arith-fixed-eqs         336292
;  :arith-offset-eqs        129954
;  :arith-pivots            69246
;  :conflicts               4044
;  :datatype-accessor-ax    742
;  :datatype-constructor-ax 2131
;  :datatype-occurs-check   1607
;  :datatype-splits         1422
;  :decisions               173778
;  :del-clause              2769742
;  :final-checks            227
;  :interface-eqs           51
;  :max-generation          15
;  :max-memory              50.39
;  :memory                  45.75
;  :minimized-lits          595
;  :mk-bool-var             3126620
;  :mk-clause               2770870
;  :num-allocs              10046313
;  :num-checks              487
;  :propagations            1106140
;  :quant-instantiations    1286380
;  :restarts                4
;  :rlimit-count            33742018
;  :time                    0.06)
(assert (implies
  (= exc@89@03 $Ref.null)
  (valid_graph_vertices ($Snap.combine
    $Snap.unit
    ($Snap.combine
      $Snap.unit
      ($Snap.combine
        $Snap.unit
        ($SortWrappers.$FVF<Int>To$Snap (as sm@361@03  $FVF<Int>))))) this@9@03 p@15@03 V@12@03)))
(pop) ; 12
(pop) ; 11
(pop) ; 10
(pop) ; 9
(push) ; 9
; [else-branch: 187 | |queue@102@03| != 0]
(assert (not (= (Seq_length queue@102@03) 0)))
(pop) ; 9
(pop) ; 8
(pop) ; 7
(pop) ; 6
(pop) ; 5
(pop) ; 4
(pop) ; 3
(pop) ; 2
(pop) ; 1
