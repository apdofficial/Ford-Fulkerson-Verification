(get-info :version)
; (:version "4.8.6")
; Started: 2022-06-14 20:18:16
; Silicon.version: 1.1-SNAPSHOT (cd20cf02@(detached))
; Input file: -
; Verifier id: 00
; ------------------------------------------------------------
; Begin preamble
; ////////// Static preamble
; 
; ; /z3config.smt2
(set-option :print-success true) ; Boogie: false
(set-option :global-decls true) ; Boogie: default
(set-option :auto_config false) ; Usually a good idea
(set-option :smt.restart_strategy 0)
(set-option :smt.restart_factor |1.5|)
(set-option :smt.case_split 3)
(set-option :smt.delay_units true)
(set-option :smt.delay_units_threshold 16)
(set-option :nnf.sk_hack true)
(set-option :type_check true)
(set-option :smt.bv.reflect true)
(set-option :smt.mbqi false)
(set-option :smt.qi.eager_threshold 100)
(set-option :smt.qi.cost "(+ weight generation)")
(set-option :smt.qi.max_multi_patterns 1000)
(set-option :smt.phase_selection 0) ; default: 3, Boogie: 0
(set-option :sat.phase caching)
(set-option :sat.random_seed 0)
(set-option :nlsat.randomize true)
(set-option :nlsat.seed 0)
(set-option :nlsat.shuffle_vars false)
(set-option :fp.spacer.order_children 0) ; Not available with Z3 4.5
(set-option :fp.spacer.random_seed 0) ; Not available with Z3 4.5
(set-option :smt.arith.random_initial_value true) ; Boogie: true
(set-option :smt.random_seed 0)
(set-option :sls.random_offset true)
(set-option :sls.random_seed 0)
(set-option :sls.restart_init false)
(set-option :sls.walksat_ucb true)
(set-option :model.v2 true)
; 
; ; /preamble.smt2
(declare-datatypes () ((
    $Snap ($Snap.unit)
    ($Snap.combine ($Snap.first $Snap) ($Snap.second $Snap)))))
(declare-sort $Ref 0)
(declare-const $Ref.null $Ref)
(declare-sort $FPM)
(declare-sort $PPM)
(define-sort $Perm () Real)
(define-const $Perm.Write $Perm 1.0)
(define-const $Perm.No $Perm 0.0)
(define-fun $Perm.isValidVar ((p $Perm)) Bool
	(<= $Perm.No p))
(define-fun $Perm.isReadVar ((p $Perm) (ub $Perm)) Bool
    (and ($Perm.isValidVar p)
         (not (= p $Perm.No))
         (< p $Perm.Write)))
(define-fun $Perm.min ((p1 $Perm) (p2 $Perm)) Real
    (ite (<= p1 p2) p1 p2))
(define-fun $Math.min ((a Int) (b Int)) Int
    (ite (<= a b) a b))
(define-fun $Math.clip ((a Int)) Int
    (ite (< a 0) 0 a))
; ////////// Sorts
(declare-sort Seq<Seq<Int>>)
(declare-sort Seq<Int>)
(declare-sort Set<Seq<Seq<Int>>>)
(declare-sort Set<option<array>>)
(declare-sort Set<Seq<Int>>)
(declare-sort Set<Int>)
(declare-sort Set<Bool>)
(declare-sort Set<$Ref>)
(declare-sort Set<$Snap>)
(declare-sort t_null)
(declare-sort any)
(declare-sort void)
(declare-sort option<any>)
(declare-sort option<array>)
(declare-sort array)
(declare-sort $FVF<Int>)
(declare-sort $FVF<option<array>>)
(declare-sort $FVF<Bool>)
(declare-sort $FVF<Seq<Seq<Int>>>)
(declare-sort $FVF<Seq<Int>>)
(declare-sort $FVF<$Ref>)
; ////////// Sort wrappers
; Declaring additional sort wrappers
(declare-fun $SortWrappers.IntTo$Snap (Int) $Snap)
(declare-fun $SortWrappers.$SnapToInt ($Snap) Int)
(assert (forall ((x Int)) (!
    (= x ($SortWrappers.$SnapToInt($SortWrappers.IntTo$Snap x)))
    :pattern (($SortWrappers.IntTo$Snap x))
    :qid |$Snap.$SnapToIntTo$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.IntTo$Snap($SortWrappers.$SnapToInt x)))
    :pattern (($SortWrappers.$SnapToInt x))
    :qid |$Snap.IntTo$SnapToInt|
    )))
(declare-fun $SortWrappers.BoolTo$Snap (Bool) $Snap)
(declare-fun $SortWrappers.$SnapToBool ($Snap) Bool)
(assert (forall ((x Bool)) (!
    (= x ($SortWrappers.$SnapToBool($SortWrappers.BoolTo$Snap x)))
    :pattern (($SortWrappers.BoolTo$Snap x))
    :qid |$Snap.$SnapToBoolTo$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.BoolTo$Snap($SortWrappers.$SnapToBool x)))
    :pattern (($SortWrappers.$SnapToBool x))
    :qid |$Snap.BoolTo$SnapToBool|
    )))
(declare-fun $SortWrappers.$RefTo$Snap ($Ref) $Snap)
(declare-fun $SortWrappers.$SnapTo$Ref ($Snap) $Ref)
(assert (forall ((x $Ref)) (!
    (= x ($SortWrappers.$SnapTo$Ref($SortWrappers.$RefTo$Snap x)))
    :pattern (($SortWrappers.$RefTo$Snap x))
    :qid |$Snap.$SnapTo$RefTo$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.$RefTo$Snap($SortWrappers.$SnapTo$Ref x)))
    :pattern (($SortWrappers.$SnapTo$Ref x))
    :qid |$Snap.$RefTo$SnapTo$Ref|
    )))
(declare-fun $SortWrappers.$PermTo$Snap ($Perm) $Snap)
(declare-fun $SortWrappers.$SnapTo$Perm ($Snap) $Perm)
(assert (forall ((x $Perm)) (!
    (= x ($SortWrappers.$SnapTo$Perm($SortWrappers.$PermTo$Snap x)))
    :pattern (($SortWrappers.$PermTo$Snap x))
    :qid |$Snap.$SnapTo$PermTo$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.$PermTo$Snap($SortWrappers.$SnapTo$Perm x)))
    :pattern (($SortWrappers.$SnapTo$Perm x))
    :qid |$Snap.$PermTo$SnapTo$Perm|
    )))
; Declaring additional sort wrappers
(declare-fun $SortWrappers.Seq<Seq<Int>>To$Snap (Seq<Seq<Int>>) $Snap)
(declare-fun $SortWrappers.$SnapToSeq<Seq<Int>> ($Snap) Seq<Seq<Int>>)
(assert (forall ((x Seq<Seq<Int>>)) (!
    (= x ($SortWrappers.$SnapToSeq<Seq<Int>>($SortWrappers.Seq<Seq<Int>>To$Snap x)))
    :pattern (($SortWrappers.Seq<Seq<Int>>To$Snap x))
    :qid |$Snap.$SnapToSeq<Seq<Int>>To$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.Seq<Seq<Int>>To$Snap($SortWrappers.$SnapToSeq<Seq<Int>> x)))
    :pattern (($SortWrappers.$SnapToSeq<Seq<Int>> x))
    :qid |$Snap.Seq<Seq<Int>>To$SnapToSeq<Seq<Int>>|
    )))
(declare-fun $SortWrappers.Seq<Int>To$Snap (Seq<Int>) $Snap)
(declare-fun $SortWrappers.$SnapToSeq<Int> ($Snap) Seq<Int>)
(assert (forall ((x Seq<Int>)) (!
    (= x ($SortWrappers.$SnapToSeq<Int>($SortWrappers.Seq<Int>To$Snap x)))
    :pattern (($SortWrappers.Seq<Int>To$Snap x))
    :qid |$Snap.$SnapToSeq<Int>To$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.Seq<Int>To$Snap($SortWrappers.$SnapToSeq<Int> x)))
    :pattern (($SortWrappers.$SnapToSeq<Int> x))
    :qid |$Snap.Seq<Int>To$SnapToSeq<Int>|
    )))
; Declaring additional sort wrappers
(declare-fun $SortWrappers.Set<Seq<Seq<Int>>>To$Snap (Set<Seq<Seq<Int>>>) $Snap)
(declare-fun $SortWrappers.$SnapToSet<Seq<Seq<Int>>> ($Snap) Set<Seq<Seq<Int>>>)
(assert (forall ((x Set<Seq<Seq<Int>>>)) (!
    (= x ($SortWrappers.$SnapToSet<Seq<Seq<Int>>>($SortWrappers.Set<Seq<Seq<Int>>>To$Snap x)))
    :pattern (($SortWrappers.Set<Seq<Seq<Int>>>To$Snap x))
    :qid |$Snap.$SnapToSet<Seq<Seq<Int>>>To$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.Set<Seq<Seq<Int>>>To$Snap($SortWrappers.$SnapToSet<Seq<Seq<Int>>> x)))
    :pattern (($SortWrappers.$SnapToSet<Seq<Seq<Int>>> x))
    :qid |$Snap.Set<Seq<Seq<Int>>>To$SnapToSet<Seq<Seq<Int>>>|
    )))
(declare-fun $SortWrappers.Set<option<array>>To$Snap (Set<option<array>>) $Snap)
(declare-fun $SortWrappers.$SnapToSet<option<array>> ($Snap) Set<option<array>>)
(assert (forall ((x Set<option<array>>)) (!
    (= x ($SortWrappers.$SnapToSet<option<array>>($SortWrappers.Set<option<array>>To$Snap x)))
    :pattern (($SortWrappers.Set<option<array>>To$Snap x))
    :qid |$Snap.$SnapToSet<option<array>>To$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.Set<option<array>>To$Snap($SortWrappers.$SnapToSet<option<array>> x)))
    :pattern (($SortWrappers.$SnapToSet<option<array>> x))
    :qid |$Snap.Set<option<array>>To$SnapToSet<option<array>>|
    )))
(declare-fun $SortWrappers.Set<Seq<Int>>To$Snap (Set<Seq<Int>>) $Snap)
(declare-fun $SortWrappers.$SnapToSet<Seq<Int>> ($Snap) Set<Seq<Int>>)
(assert (forall ((x Set<Seq<Int>>)) (!
    (= x ($SortWrappers.$SnapToSet<Seq<Int>>($SortWrappers.Set<Seq<Int>>To$Snap x)))
    :pattern (($SortWrappers.Set<Seq<Int>>To$Snap x))
    :qid |$Snap.$SnapToSet<Seq<Int>>To$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.Set<Seq<Int>>To$Snap($SortWrappers.$SnapToSet<Seq<Int>> x)))
    :pattern (($SortWrappers.$SnapToSet<Seq<Int>> x))
    :qid |$Snap.Set<Seq<Int>>To$SnapToSet<Seq<Int>>|
    )))
(declare-fun $SortWrappers.Set<Int>To$Snap (Set<Int>) $Snap)
(declare-fun $SortWrappers.$SnapToSet<Int> ($Snap) Set<Int>)
(assert (forall ((x Set<Int>)) (!
    (= x ($SortWrappers.$SnapToSet<Int>($SortWrappers.Set<Int>To$Snap x)))
    :pattern (($SortWrappers.Set<Int>To$Snap x))
    :qid |$Snap.$SnapToSet<Int>To$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.Set<Int>To$Snap($SortWrappers.$SnapToSet<Int> x)))
    :pattern (($SortWrappers.$SnapToSet<Int> x))
    :qid |$Snap.Set<Int>To$SnapToSet<Int>|
    )))
(declare-fun $SortWrappers.Set<Bool>To$Snap (Set<Bool>) $Snap)
(declare-fun $SortWrappers.$SnapToSet<Bool> ($Snap) Set<Bool>)
(assert (forall ((x Set<Bool>)) (!
    (= x ($SortWrappers.$SnapToSet<Bool>($SortWrappers.Set<Bool>To$Snap x)))
    :pattern (($SortWrappers.Set<Bool>To$Snap x))
    :qid |$Snap.$SnapToSet<Bool>To$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.Set<Bool>To$Snap($SortWrappers.$SnapToSet<Bool> x)))
    :pattern (($SortWrappers.$SnapToSet<Bool> x))
    :qid |$Snap.Set<Bool>To$SnapToSet<Bool>|
    )))
(declare-fun $SortWrappers.Set<$Ref>To$Snap (Set<$Ref>) $Snap)
(declare-fun $SortWrappers.$SnapToSet<$Ref> ($Snap) Set<$Ref>)
(assert (forall ((x Set<$Ref>)) (!
    (= x ($SortWrappers.$SnapToSet<$Ref>($SortWrappers.Set<$Ref>To$Snap x)))
    :pattern (($SortWrappers.Set<$Ref>To$Snap x))
    :qid |$Snap.$SnapToSet<$Ref>To$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.Set<$Ref>To$Snap($SortWrappers.$SnapToSet<$Ref> x)))
    :pattern (($SortWrappers.$SnapToSet<$Ref> x))
    :qid |$Snap.Set<$Ref>To$SnapToSet<$Ref>|
    )))
(declare-fun $SortWrappers.Set<$Snap>To$Snap (Set<$Snap>) $Snap)
(declare-fun $SortWrappers.$SnapToSet<$Snap> ($Snap) Set<$Snap>)
(assert (forall ((x Set<$Snap>)) (!
    (= x ($SortWrappers.$SnapToSet<$Snap>($SortWrappers.Set<$Snap>To$Snap x)))
    :pattern (($SortWrappers.Set<$Snap>To$Snap x))
    :qid |$Snap.$SnapToSet<$Snap>To$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.Set<$Snap>To$Snap($SortWrappers.$SnapToSet<$Snap> x)))
    :pattern (($SortWrappers.$SnapToSet<$Snap> x))
    :qid |$Snap.Set<$Snap>To$SnapToSet<$Snap>|
    )))
; Declaring additional sort wrappers
(declare-fun $SortWrappers.t_nullTo$Snap (t_null) $Snap)
(declare-fun $SortWrappers.$SnapTot_null ($Snap) t_null)
(assert (forall ((x t_null)) (!
    (= x ($SortWrappers.$SnapTot_null($SortWrappers.t_nullTo$Snap x)))
    :pattern (($SortWrappers.t_nullTo$Snap x))
    :qid |$Snap.$SnapTot_nullTo$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.t_nullTo$Snap($SortWrappers.$SnapTot_null x)))
    :pattern (($SortWrappers.$SnapTot_null x))
    :qid |$Snap.t_nullTo$SnapTot_null|
    )))
(declare-fun $SortWrappers.anyTo$Snap (any) $Snap)
(declare-fun $SortWrappers.$SnapToany ($Snap) any)
(assert (forall ((x any)) (!
    (= x ($SortWrappers.$SnapToany($SortWrappers.anyTo$Snap x)))
    :pattern (($SortWrappers.anyTo$Snap x))
    :qid |$Snap.$SnapToanyTo$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.anyTo$Snap($SortWrappers.$SnapToany x)))
    :pattern (($SortWrappers.$SnapToany x))
    :qid |$Snap.anyTo$SnapToany|
    )))
(declare-fun $SortWrappers.voidTo$Snap (void) $Snap)
(declare-fun $SortWrappers.$SnapTovoid ($Snap) void)
(assert (forall ((x void)) (!
    (= x ($SortWrappers.$SnapTovoid($SortWrappers.voidTo$Snap x)))
    :pattern (($SortWrappers.voidTo$Snap x))
    :qid |$Snap.$SnapTovoidTo$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.voidTo$Snap($SortWrappers.$SnapTovoid x)))
    :pattern (($SortWrappers.$SnapTovoid x))
    :qid |$Snap.voidTo$SnapTovoid|
    )))
(declare-fun $SortWrappers.option<any>To$Snap (option<any>) $Snap)
(declare-fun $SortWrappers.$SnapTooption<any> ($Snap) option<any>)
(assert (forall ((x option<any>)) (!
    (= x ($SortWrappers.$SnapTooption<any>($SortWrappers.option<any>To$Snap x)))
    :pattern (($SortWrappers.option<any>To$Snap x))
    :qid |$Snap.$SnapTooption<any>To$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.option<any>To$Snap($SortWrappers.$SnapTooption<any> x)))
    :pattern (($SortWrappers.$SnapTooption<any> x))
    :qid |$Snap.option<any>To$SnapTooption<any>|
    )))
(declare-fun $SortWrappers.option<array>To$Snap (option<array>) $Snap)
(declare-fun $SortWrappers.$SnapTooption<array> ($Snap) option<array>)
(assert (forall ((x option<array>)) (!
    (= x ($SortWrappers.$SnapTooption<array>($SortWrappers.option<array>To$Snap x)))
    :pattern (($SortWrappers.option<array>To$Snap x))
    :qid |$Snap.$SnapTooption<array>To$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.option<array>To$Snap($SortWrappers.$SnapTooption<array> x)))
    :pattern (($SortWrappers.$SnapTooption<array> x))
    :qid |$Snap.option<array>To$SnapTooption<array>|
    )))
(declare-fun $SortWrappers.arrayTo$Snap (array) $Snap)
(declare-fun $SortWrappers.$SnapToarray ($Snap) array)
(assert (forall ((x array)) (!
    (= x ($SortWrappers.$SnapToarray($SortWrappers.arrayTo$Snap x)))
    :pattern (($SortWrappers.arrayTo$Snap x))
    :qid |$Snap.$SnapToarrayTo$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.arrayTo$Snap($SortWrappers.$SnapToarray x)))
    :pattern (($SortWrappers.$SnapToarray x))
    :qid |$Snap.arrayTo$SnapToarray|
    )))
; Declaring additional sort wrappers
(declare-fun $SortWrappers.$FVF<Int>To$Snap ($FVF<Int>) $Snap)
(declare-fun $SortWrappers.$SnapTo$FVF<Int> ($Snap) $FVF<Int>)
(assert (forall ((x $FVF<Int>)) (!
    (= x ($SortWrappers.$SnapTo$FVF<Int>($SortWrappers.$FVF<Int>To$Snap x)))
    :pattern (($SortWrappers.$FVF<Int>To$Snap x))
    :qid |$Snap.$SnapTo$FVF<Int>To$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.$FVF<Int>To$Snap($SortWrappers.$SnapTo$FVF<Int> x)))
    :pattern (($SortWrappers.$SnapTo$FVF<Int> x))
    :qid |$Snap.$FVF<Int>To$SnapTo$FVF<Int>|
    )))
(declare-fun $SortWrappers.$FVF<option<array>>To$Snap ($FVF<option<array>>) $Snap)
(declare-fun $SortWrappers.$SnapTo$FVF<option<array>> ($Snap) $FVF<option<array>>)
(assert (forall ((x $FVF<option<array>>)) (!
    (= x ($SortWrappers.$SnapTo$FVF<option<array>>($SortWrappers.$FVF<option<array>>To$Snap x)))
    :pattern (($SortWrappers.$FVF<option<array>>To$Snap x))
    :qid |$Snap.$SnapTo$FVF<option<array>>To$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.$FVF<option<array>>To$Snap($SortWrappers.$SnapTo$FVF<option<array>> x)))
    :pattern (($SortWrappers.$SnapTo$FVF<option<array>> x))
    :qid |$Snap.$FVF<option<array>>To$SnapTo$FVF<option<array>>|
    )))
(declare-fun $SortWrappers.$FVF<Bool>To$Snap ($FVF<Bool>) $Snap)
(declare-fun $SortWrappers.$SnapTo$FVF<Bool> ($Snap) $FVF<Bool>)
(assert (forall ((x $FVF<Bool>)) (!
    (= x ($SortWrappers.$SnapTo$FVF<Bool>($SortWrappers.$FVF<Bool>To$Snap x)))
    :pattern (($SortWrappers.$FVF<Bool>To$Snap x))
    :qid |$Snap.$SnapTo$FVF<Bool>To$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.$FVF<Bool>To$Snap($SortWrappers.$SnapTo$FVF<Bool> x)))
    :pattern (($SortWrappers.$SnapTo$FVF<Bool> x))
    :qid |$Snap.$FVF<Bool>To$SnapTo$FVF<Bool>|
    )))
(declare-fun $SortWrappers.$FVF<Seq<Seq<Int>>>To$Snap ($FVF<Seq<Seq<Int>>>) $Snap)
(declare-fun $SortWrappers.$SnapTo$FVF<Seq<Seq<Int>>> ($Snap) $FVF<Seq<Seq<Int>>>)
(assert (forall ((x $FVF<Seq<Seq<Int>>>)) (!
    (= x ($SortWrappers.$SnapTo$FVF<Seq<Seq<Int>>>($SortWrappers.$FVF<Seq<Seq<Int>>>To$Snap x)))
    :pattern (($SortWrappers.$FVF<Seq<Seq<Int>>>To$Snap x))
    :qid |$Snap.$SnapTo$FVF<Seq<Seq<Int>>>To$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.$FVF<Seq<Seq<Int>>>To$Snap($SortWrappers.$SnapTo$FVF<Seq<Seq<Int>>> x)))
    :pattern (($SortWrappers.$SnapTo$FVF<Seq<Seq<Int>>> x))
    :qid |$Snap.$FVF<Seq<Seq<Int>>>To$SnapTo$FVF<Seq<Seq<Int>>>|
    )))
(declare-fun $SortWrappers.$FVF<Seq<Int>>To$Snap ($FVF<Seq<Int>>) $Snap)
(declare-fun $SortWrappers.$SnapTo$FVF<Seq<Int>> ($Snap) $FVF<Seq<Int>>)
(assert (forall ((x $FVF<Seq<Int>>)) (!
    (= x ($SortWrappers.$SnapTo$FVF<Seq<Int>>($SortWrappers.$FVF<Seq<Int>>To$Snap x)))
    :pattern (($SortWrappers.$FVF<Seq<Int>>To$Snap x))
    :qid |$Snap.$SnapTo$FVF<Seq<Int>>To$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.$FVF<Seq<Int>>To$Snap($SortWrappers.$SnapTo$FVF<Seq<Int>> x)))
    :pattern (($SortWrappers.$SnapTo$FVF<Seq<Int>> x))
    :qid |$Snap.$FVF<Seq<Int>>To$SnapTo$FVF<Seq<Int>>|
    )))
(declare-fun $SortWrappers.$FVF<$Ref>To$Snap ($FVF<$Ref>) $Snap)
(declare-fun $SortWrappers.$SnapTo$FVF<$Ref> ($Snap) $FVF<$Ref>)
(assert (forall ((x $FVF<$Ref>)) (!
    (= x ($SortWrappers.$SnapTo$FVF<$Ref>($SortWrappers.$FVF<$Ref>To$Snap x)))
    :pattern (($SortWrappers.$FVF<$Ref>To$Snap x))
    :qid |$Snap.$SnapTo$FVF<$Ref>To$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.$FVF<$Ref>To$Snap($SortWrappers.$SnapTo$FVF<$Ref> x)))
    :pattern (($SortWrappers.$SnapTo$FVF<$Ref> x))
    :qid |$Snap.$FVF<$Ref>To$SnapTo$FVF<$Ref>|
    )))
; ////////// Symbols
(declare-fun Set_in (Seq<Seq<Int>> Set<Seq<Seq<Int>>>) Bool)
(declare-fun Set_card (Set<Seq<Seq<Int>>>) Int)
(declare-const Set_empty Set<Seq<Seq<Int>>>)
(declare-fun Set_singleton (Seq<Seq<Int>>) Set<Seq<Seq<Int>>>)
(declare-fun Set_unionone (Set<Seq<Seq<Int>>> Seq<Seq<Int>>) Set<Seq<Seq<Int>>>)
(declare-fun Set_union (Set<Seq<Seq<Int>>> Set<Seq<Seq<Int>>>) Set<Seq<Seq<Int>>>)
(declare-fun Set_disjoint (Set<Seq<Seq<Int>>> Set<Seq<Seq<Int>>>) Bool)
(declare-fun Set_difference (Set<Seq<Seq<Int>>> Set<Seq<Seq<Int>>>) Set<Seq<Seq<Int>>>)
(declare-fun Set_intersection (Set<Seq<Seq<Int>>> Set<Seq<Seq<Int>>>) Set<Seq<Seq<Int>>>)
(declare-fun Set_subset (Set<Seq<Seq<Int>>> Set<Seq<Seq<Int>>>) Bool)
(declare-fun Set_equal (Set<Seq<Seq<Int>>> Set<Seq<Seq<Int>>>) Bool)
(declare-fun Set_in (option<array> Set<option<array>>) Bool)
(declare-fun Set_card (Set<option<array>>) Int)
(declare-const Set_empty Set<option<array>>)
(declare-fun Set_singleton (option<array>) Set<option<array>>)
(declare-fun Set_unionone (Set<option<array>> option<array>) Set<option<array>>)
(declare-fun Set_union (Set<option<array>> Set<option<array>>) Set<option<array>>)
(declare-fun Set_disjoint (Set<option<array>> Set<option<array>>) Bool)
(declare-fun Set_difference (Set<option<array>> Set<option<array>>) Set<option<array>>)
(declare-fun Set_intersection (Set<option<array>> Set<option<array>>) Set<option<array>>)
(declare-fun Set_subset (Set<option<array>> Set<option<array>>) Bool)
(declare-fun Set_equal (Set<option<array>> Set<option<array>>) Bool)
(declare-fun Set_in (Seq<Int> Set<Seq<Int>>) Bool)
(declare-fun Set_card (Set<Seq<Int>>) Int)
(declare-const Set_empty Set<Seq<Int>>)
(declare-fun Set_singleton (Seq<Int>) Set<Seq<Int>>)
(declare-fun Set_unionone (Set<Seq<Int>> Seq<Int>) Set<Seq<Int>>)
(declare-fun Set_union (Set<Seq<Int>> Set<Seq<Int>>) Set<Seq<Int>>)
(declare-fun Set_disjoint (Set<Seq<Int>> Set<Seq<Int>>) Bool)
(declare-fun Set_difference (Set<Seq<Int>> Set<Seq<Int>>) Set<Seq<Int>>)
(declare-fun Set_intersection (Set<Seq<Int>> Set<Seq<Int>>) Set<Seq<Int>>)
(declare-fun Set_subset (Set<Seq<Int>> Set<Seq<Int>>) Bool)
(declare-fun Set_equal (Set<Seq<Int>> Set<Seq<Int>>) Bool)
(declare-fun Set_in (Int Set<Int>) Bool)
(declare-fun Set_card (Set<Int>) Int)
(declare-const Set_empty Set<Int>)
(declare-fun Set_singleton (Int) Set<Int>)
(declare-fun Set_unionone (Set<Int> Int) Set<Int>)
(declare-fun Set_union (Set<Int> Set<Int>) Set<Int>)
(declare-fun Set_disjoint (Set<Int> Set<Int>) Bool)
(declare-fun Set_difference (Set<Int> Set<Int>) Set<Int>)
(declare-fun Set_intersection (Set<Int> Set<Int>) Set<Int>)
(declare-fun Set_subset (Set<Int> Set<Int>) Bool)
(declare-fun Set_equal (Set<Int> Set<Int>) Bool)
(declare-fun Set_in (Bool Set<Bool>) Bool)
(declare-fun Set_card (Set<Bool>) Int)
(declare-const Set_empty Set<Bool>)
(declare-fun Set_singleton (Bool) Set<Bool>)
(declare-fun Set_unionone (Set<Bool> Bool) Set<Bool>)
(declare-fun Set_union (Set<Bool> Set<Bool>) Set<Bool>)
(declare-fun Set_disjoint (Set<Bool> Set<Bool>) Bool)
(declare-fun Set_difference (Set<Bool> Set<Bool>) Set<Bool>)
(declare-fun Set_intersection (Set<Bool> Set<Bool>) Set<Bool>)
(declare-fun Set_subset (Set<Bool> Set<Bool>) Bool)
(declare-fun Set_equal (Set<Bool> Set<Bool>) Bool)
(declare-fun Set_in ($Ref Set<$Ref>) Bool)
(declare-fun Set_card (Set<$Ref>) Int)
(declare-const Set_empty Set<$Ref>)
(declare-fun Set_singleton ($Ref) Set<$Ref>)
(declare-fun Set_unionone (Set<$Ref> $Ref) Set<$Ref>)
(declare-fun Set_union (Set<$Ref> Set<$Ref>) Set<$Ref>)
(declare-fun Set_disjoint (Set<$Ref> Set<$Ref>) Bool)
(declare-fun Set_difference (Set<$Ref> Set<$Ref>) Set<$Ref>)
(declare-fun Set_intersection (Set<$Ref> Set<$Ref>) Set<$Ref>)
(declare-fun Set_subset (Set<$Ref> Set<$Ref>) Bool)
(declare-fun Set_equal (Set<$Ref> Set<$Ref>) Bool)
(declare-fun Set_in ($Snap Set<$Snap>) Bool)
(declare-fun Set_card (Set<$Snap>) Int)
(declare-const Set_empty Set<$Snap>)
(declare-fun Set_singleton ($Snap) Set<$Snap>)
(declare-fun Set_unionone (Set<$Snap> $Snap) Set<$Snap>)
(declare-fun Set_union (Set<$Snap> Set<$Snap>) Set<$Snap>)
(declare-fun Set_disjoint (Set<$Snap> Set<$Snap>) Bool)
(declare-fun Set_difference (Set<$Snap> Set<$Snap>) Set<$Snap>)
(declare-fun Set_intersection (Set<$Snap> Set<$Snap>) Set<$Snap>)
(declare-fun Set_subset (Set<$Snap> Set<$Snap>) Bool)
(declare-fun Set_equal (Set<$Snap> Set<$Snap>) Bool)
(declare-fun Seq_length (Seq<Seq<Int>>) Int)
(declare-const Seq_empty Seq<Seq<Int>>)
(declare-fun Seq_singleton (Seq<Int>) Seq<Seq<Int>>)
(declare-fun Seq_build (Seq<Seq<Int>> Seq<Int>) Seq<Seq<Int>>)
(declare-fun Seq_index (Seq<Seq<Int>> Int) Seq<Int>)
(declare-fun Seq_append (Seq<Seq<Int>> Seq<Seq<Int>>) Seq<Seq<Int>>)
(declare-fun Seq_update (Seq<Seq<Int>> Int Seq<Int>) Seq<Seq<Int>>)
(declare-fun Seq_contains (Seq<Seq<Int>> Seq<Int>) Bool)
(declare-fun Seq_take (Seq<Seq<Int>> Int) Seq<Seq<Int>>)
(declare-fun Seq_drop (Seq<Seq<Int>> Int) Seq<Seq<Int>>)
(declare-fun Seq_equal (Seq<Seq<Int>> Seq<Seq<Int>>) Bool)
(declare-fun Seq_sameuntil (Seq<Seq<Int>> Seq<Seq<Int>> Int) Bool)
(declare-fun Seq_length (Seq<Int>) Int)
(declare-const Seq_empty Seq<Int>)
(declare-fun Seq_singleton (Int) Seq<Int>)
(declare-fun Seq_build (Seq<Int> Int) Seq<Int>)
(declare-fun Seq_index (Seq<Int> Int) Int)
(declare-fun Seq_append (Seq<Int> Seq<Int>) Seq<Int>)
(declare-fun Seq_update (Seq<Int> Int Int) Seq<Int>)
(declare-fun Seq_contains (Seq<Int> Int) Bool)
(declare-fun Seq_take (Seq<Int> Int) Seq<Int>)
(declare-fun Seq_drop (Seq<Int> Int) Seq<Int>)
(declare-fun Seq_equal (Seq<Int> Seq<Int>) Bool)
(declare-fun Seq_sameuntil (Seq<Int> Seq<Int> Int) Bool)
(declare-fun Seq_range (Int Int) Seq<Int>)
(declare-fun array_loc<Ref> (array Int) $Ref)
(declare-fun alen<Int> (array) Int)
(declare-fun loc_inv_1<array> ($Ref) array)
(declare-fun loc_inv_2<Int> ($Ref) Int)
(declare-const None<option<array>> option<array>)
(declare-fun some<option<array>> (array) option<array>)
(declare-fun option_get<array> (option<array>) array)
(declare-const v_null<t_null> t_null)
(declare-const None<option<any>> option<any>)
(declare-fun some<option<any>> (any) option<any>)
(declare-fun option_get<any> (option<any>) any)
(declare-const unit<void> void)
; /field_value_functions_declarations.smt2 [int: Int]
(declare-fun $FVF.domain_int ($FVF<Int>) Set<$Ref>)
(declare-fun $FVF.lookup_int ($FVF<Int> $Ref) Int)
(declare-fun $FVF.after_int ($FVF<Int> $FVF<Int>) Bool)
(declare-fun $FVF.loc_int (Int $Ref) Bool)
(declare-fun $FVF.perm_int ($FPM $Ref) $Perm)
(declare-const $fvfTOP_int $FVF<Int>)
; /field_value_functions_declarations.smt2 [option$array$: option[array]]
(declare-fun $FVF.domain_option$array$ ($FVF<option<array>>) Set<$Ref>)
(declare-fun $FVF.lookup_option$array$ ($FVF<option<array>> $Ref) option<array>)
(declare-fun $FVF.after_option$array$ ($FVF<option<array>> $FVF<option<array>>) Bool)
(declare-fun $FVF.loc_option$array$ (option<array> $Ref) Bool)
(declare-fun $FVF.perm_option$array$ ($FPM $Ref) $Perm)
(declare-const $fvfTOP_option$array$ $FVF<option<array>>)
; /field_value_functions_declarations.smt2 [bool: Bool]
(declare-fun $FVF.domain_bool ($FVF<Bool>) Set<$Ref>)
(declare-fun $FVF.lookup_bool ($FVF<Bool> $Ref) Bool)
(declare-fun $FVF.after_bool ($FVF<Bool> $FVF<Bool>) Bool)
(declare-fun $FVF.loc_bool (Bool $Ref) Bool)
(declare-fun $FVF.perm_bool ($FPM $Ref) $Perm)
(declare-const $fvfTOP_bool $FVF<Bool>)
; /field_value_functions_declarations.smt2 [Gf_seq: Seq[Seq[Int]]]
(declare-fun $FVF.domain_Gf_seq ($FVF<Seq<Seq<Int>>>) Set<$Ref>)
(declare-fun $FVF.lookup_Gf_seq ($FVF<Seq<Seq<Int>>> $Ref) Seq<Seq<Int>>)
(declare-fun $FVF.after_Gf_seq ($FVF<Seq<Seq<Int>>> $FVF<Seq<Seq<Int>>>) Bool)
(declare-fun $FVF.loc_Gf_seq (Seq<Seq<Int>> $Ref) Bool)
(declare-fun $FVF.perm_Gf_seq ($FPM $Ref) $Perm)
(declare-const $fvfTOP_Gf_seq $FVF<Seq<Seq<Int>>>)
; /field_value_functions_declarations.smt2 [P_seq: Seq[Int]]
(declare-fun $FVF.domain_P_seq ($FVF<Seq<Int>>) Set<$Ref>)
(declare-fun $FVF.lookup_P_seq ($FVF<Seq<Int>> $Ref) Seq<Int>)
(declare-fun $FVF.after_P_seq ($FVF<Seq<Int>> $FVF<Seq<Int>>) Bool)
(declare-fun $FVF.loc_P_seq (Seq<Int> $Ref) Bool)
(declare-fun $FVF.perm_P_seq ($FPM $Ref) $Perm)
(declare-const $fvfTOP_P_seq $FVF<Seq<Int>>)
; Declaring symbols related to program functions (from program analysis)
(declare-fun valid_graph_vertices1 ($Snap $Ref Seq<Int> Int) Bool)
(declare-fun valid_graph_vertices1%limited ($Snap $Ref Seq<Int> Int) Bool)
(declare-fun valid_graph_vertices1%stateless ($Ref Seq<Int> Int) Bool)
(declare-fun SquareIntMatrix ($Snap $Ref Seq<Seq<Int>> Int) Bool)
(declare-fun SquareIntMatrix%limited ($Snap $Ref Seq<Seq<Int>> Int) Bool)
(declare-fun SquareIntMatrix%stateless ($Ref Seq<Seq<Int>> Int) Bool)
(declare-fun SumOutgoingFlow ($Snap $Ref Seq<Seq<Int>> Int Int) Int)
(declare-fun SumOutgoingFlow%limited ($Snap $Ref Seq<Seq<Int>> Int Int) Int)
(declare-fun SumOutgoingFlow%stateless ($Ref Seq<Seq<Int>> Int Int) Bool)
(declare-fun SumIncomingFlow ($Snap $Ref Seq<Seq<Int>> Int Int) Int)
(declare-fun SumIncomingFlow%limited ($Snap $Ref Seq<Seq<Int>> Int Int) Int)
(declare-fun SumIncomingFlow%stateless ($Ref Seq<Seq<Int>> Int Int) Bool)
(declare-fun AugPath ($Snap $Ref Seq<Seq<Int>> Int Int Int Seq<Int>) Bool)
(declare-fun AugPath%limited ($Snap $Ref Seq<Seq<Int>> Int Int Int Seq<Int>) Bool)
(declare-fun AugPath%stateless ($Ref Seq<Seq<Int>> Int Int Int Seq<Int>) Bool)
(declare-fun aloc ($Snap array Int) $Ref)
(declare-fun aloc%limited ($Snap array Int) $Ref)
(declare-fun aloc%stateless (array Int) Bool)
(declare-fun opt_get1 ($Snap option<array>) array)
(declare-fun opt_get1%limited ($Snap option<array>) array)
(declare-fun opt_get1%stateless (option<array>) Bool)
(declare-fun NonNegativeCapacities ($Snap $Ref Seq<Seq<Int>> Int) Bool)
(declare-fun NonNegativeCapacities%limited ($Snap $Ref Seq<Seq<Int>> Int) Bool)
(declare-fun NonNegativeCapacities%stateless ($Ref Seq<Seq<Int>> Int) Bool)
(declare-fun SkewSymetry ($Snap $Ref Seq<Seq<Int>> Int) Bool)
(declare-fun SkewSymetry%limited ($Snap $Ref Seq<Seq<Int>> Int) Bool)
(declare-fun SkewSymetry%stateless ($Ref Seq<Seq<Int>> Int) Bool)
(declare-fun CapacityConstraint ($Snap $Ref Seq<Seq<Int>> Seq<Seq<Int>> Int) Bool)
(declare-fun CapacityConstraint%limited ($Snap $Ref Seq<Seq<Int>> Seq<Seq<Int>> Int) Bool)
(declare-fun CapacityConstraint%stateless ($Ref Seq<Seq<Int>> Seq<Seq<Int>> Int) Bool)
(declare-fun FlowConservation ($Snap $Ref Seq<Seq<Int>> Int Int Int) Bool)
(declare-fun FlowConservation%limited ($Snap $Ref Seq<Seq<Int>> Int Int Int) Bool)
(declare-fun FlowConservation%stateless ($Ref Seq<Seq<Int>> Int Int Int) Bool)
(declare-fun any_as ($Snap any) any)
(declare-fun any_as%limited ($Snap any) any)
(declare-fun any_as%stateless (any) Bool)
(declare-fun opt_get ($Snap option<any>) any)
(declare-fun opt_get%limited ($Snap option<any>) any)
(declare-fun opt_get%stateless (option<any>) Bool)
(declare-fun ExAugPath ($Snap $Ref Seq<Seq<Int>> Int Int Int) Bool)
(declare-fun ExAugPath%limited ($Snap $Ref Seq<Seq<Int>> Int Int Int) Bool)
(declare-fun ExAugPath%stateless ($Ref Seq<Seq<Int>> Int Int Int) Bool)
(declare-fun initializeSeqWithZeros ($Snap $Ref Seq<Int> Int) Seq<Int>)
(declare-fun initializeSeqWithZeros%limited ($Snap $Ref Seq<Int> Int) Seq<Int>)
(declare-fun initializeSeqWithZeros%stateless ($Ref Seq<Int> Int) Bool)
(declare-fun valid_graph_vertices ($Snap $Ref option<array> Int) Bool)
(declare-fun valid_graph_vertices%limited ($Snap $Ref option<array> Int) Bool)
(declare-fun valid_graph_vertices%stateless ($Ref option<array> Int) Bool)
(declare-fun FlowNetwork ($Snap $Ref Seq<Seq<Int>> Seq<Seq<Int>> Int Int Int) Bool)
(declare-fun FlowNetwork%limited ($Snap $Ref Seq<Seq<Int>> Seq<Seq<Int>> Int Int Int) Bool)
(declare-fun FlowNetwork%stateless ($Ref Seq<Seq<Int>> Seq<Seq<Int>> Int Int Int) Bool)
(declare-fun scale ($Snap $Perm) $Perm)
(declare-fun scale%limited ($Snap $Perm) $Perm)
(declare-fun scale%stateless ($Perm) Bool)
(declare-fun Flow ($Snap $Ref Seq<Seq<Int>> Seq<Seq<Int>> Int Int Int) Bool)
(declare-fun Flow%limited ($Snap $Ref Seq<Seq<Int>> Seq<Seq<Int>> Int Int Int) Bool)
(declare-fun Flow%stateless ($Ref Seq<Seq<Int>> Seq<Seq<Int>> Int Int Int) Bool)
(declare-fun as_any ($Snap any) any)
(declare-fun as_any%limited ($Snap any) any)
(declare-fun as_any%stateless (any) Bool)
(declare-fun type ($Snap $Ref) Int)
(declare-fun type%limited ($Snap $Ref) Int)
(declare-fun type%stateless ($Ref) Bool)
(declare-fun opt_or_else ($Snap option<any> any) any)
(declare-fun opt_or_else%limited ($Snap option<any> any) any)
(declare-fun opt_or_else%stateless (option<any> any) Bool)
(declare-fun subtype ($Snap Int Int) Bool)
(declare-fun subtype%limited ($Snap Int Int) Bool)
(declare-fun subtype%stateless (Int Int) Bool)
; Snapshot variable to be used during function verification
(declare-fun s@$ () $Snap)
; Declaring predicate trigger functions
(declare-fun lock_inv_FordFulkerson%trigger ($Snap $Ref) Bool)
(declare-fun lock_held_FordFulkerson%trigger ($Snap $Ref) Bool)
(declare-fun lock_inv_Object%trigger ($Snap $Ref) Bool)
(declare-fun lock_held_Object%trigger ($Snap $Ref) Bool)
; ////////// Uniqueness assumptions from domains
; ////////// Axioms
(assert (forall ((s Seq<Seq<Int>>)) (!
  (<= 0 (Seq_length s))
  :pattern ((Seq_length s))
  :qid |$Seq[Seq[Int]]_prog.seq_length_non_negative|)))
(assert (= (Seq_length (as Seq_empty  Seq<Seq<Int>>)) 0))
(assert (forall ((s Seq<Seq<Int>>)) (!
  (implies (= (Seq_length s) 0) (= s (as Seq_empty  Seq<Seq<Int>>)))
  :pattern ((Seq_length s))
  :qid |$Seq[Seq[Int]]_prog.only_empty_seq_length_zero|)))
(assert (forall ((e Seq<Int>)) (!
  (= (Seq_length (Seq_singleton e)) 1)
  :pattern ((Seq_length (Seq_singleton e)))
  :qid |$Seq[Seq[Int]]_prog.length_singleton_seq|)))
(assert (forall ((s Seq<Seq<Int>>) (e Seq<Int>)) (!
  (= (Seq_length (Seq_build s e)) (+ 1 (Seq_length s)))
  :pattern ((Seq_length (Seq_build s e)))
  :qid |$Seq[Seq[Int]]_prog.length_seq_build_inc_by_one|)))
(assert (forall ((s Seq<Seq<Int>>) (i Int) (e Seq<Int>)) (!
  (ite
    (= i (Seq_length s))
    (= (Seq_index (Seq_build s e) i) e)
    (= (Seq_index (Seq_build s e) i) (Seq_index s i)))
  :pattern ((Seq_index (Seq_build s e) i))
  :qid |$Seq[Seq[Int]]_prog.seq_index_over_build|)))
(assert (forall ((s1 Seq<Seq<Int>>) (s2 Seq<Seq<Int>>)) (!
  (implies
    (and
      (not (= s1 (as Seq_empty  Seq<Seq<Int>>)))
      (not (= s2 (as Seq_empty  Seq<Seq<Int>>))))
    (= (Seq_length (Seq_append s1 s2)) (+ (Seq_length s1) (Seq_length s2))))
  :pattern ((Seq_length (Seq_append s1 s2)))
  :qid |$Seq[Seq[Int]]_prog.seq_length_over_append|)))
(assert (forall ((e Seq<Int>)) (!
  (= (Seq_index (Seq_singleton e) 0) e)
  :pattern ((Seq_index (Seq_singleton e) 0))
  :qid |$Seq[Seq[Int]]_prog.seq_index_over_singleton|)))
(assert (forall ((e1 Seq<Int>) (e2 Seq<Int>)) (!
  (= (Seq_contains (Seq_singleton e1) e2) (= e1 e2))
  :pattern ((Seq_contains (Seq_singleton e1) e2))
  :qid |$Seq[Seq[Int]]_prog.seq_contains_over_singleton|)))
(assert (forall ((s Seq<Seq<Int>>)) (!
  (= (Seq_append (as Seq_empty  Seq<Seq<Int>>) s) s)
  :pattern ((Seq_append (as Seq_empty  Seq<Seq<Int>>) s))
  :qid |$Seq[Seq[Int]]_prog.seq_append_empty_left|)))
(assert (forall ((s Seq<Seq<Int>>)) (!
  (= (Seq_append s (as Seq_empty  Seq<Seq<Int>>)) s)
  :pattern ((Seq_append s (as Seq_empty  Seq<Seq<Int>>)))
  :qid |$Seq[Seq[Int]]_prog.seq_append_empty_right|)))
(assert (forall ((s1 Seq<Seq<Int>>) (s2 Seq<Seq<Int>>) (i Int)) (!
  (implies
    (and
      (not (= s1 (as Seq_empty  Seq<Seq<Int>>)))
      (not (= s2 (as Seq_empty  Seq<Seq<Int>>))))
    (ite
      (< i (Seq_length s1))
      (= (Seq_index (Seq_append s1 s2) i) (Seq_index s1 i))
      (= (Seq_index (Seq_append s1 s2) i) (Seq_index s2 (- i (Seq_length s1))))))
  :pattern ((Seq_index (Seq_append s1 s2) i))
  :pattern ((Seq_index s1 i) (Seq_append s1 s2))
  :qid |$Seq[Seq[Int]]_prog.seq_index_over_append|)))
(assert (forall ((s Seq<Seq<Int>>) (i Int) (e Seq<Int>)) (!
  (implies
    (and (<= 0 i) (< i (Seq_length s)))
    (= (Seq_length (Seq_update s i e)) (Seq_length s)))
  :pattern ((Seq_length (Seq_update s i e)))
  :qid |$Seq[Seq[Int]]_prog.seq_length_invariant_over_update|)))
(assert (forall ((s Seq<Seq<Int>>) (i Int) (e Seq<Int>) (j Int)) (!
  (ite
    (implies (and (<= 0 i) (< i (Seq_length s))) (= i j))
    (= (Seq_index (Seq_update s i e) j) e)
    (= (Seq_index (Seq_update s i e) j) (Seq_index s j)))
  :pattern ((Seq_index (Seq_update s i e) j))
  :qid |$Seq[Seq[Int]]_prog.seq_index_over_update|)))
(assert (forall ((s Seq<Seq<Int>>) (e Seq<Int>)) (!
  (=
    (Seq_contains s e)
    (exists ((i Int)) (!
      (and (<= 0 i) (and (< i (Seq_length s)) (= (Seq_index s i) e)))
      :pattern ((Seq_index s i))
      )))
  :pattern ((Seq_contains s e))
  :qid |$Seq[Seq[Int]]_prog.seq_element_contains_index_exists|)))
(assert (forall ((e Seq<Int>)) (!
  (not (Seq_contains (as Seq_empty  Seq<Seq<Int>>) e))
  :pattern ((Seq_contains (as Seq_empty  Seq<Seq<Int>>) e))
  :qid |$Seq[Seq[Int]]_prog.empty_seq_contains_nothing|)))
(assert (forall ((s1 Seq<Seq<Int>>) (s2 Seq<Seq<Int>>) (e Seq<Int>)) (!
  (=
    (Seq_contains (Seq_append s1 s2) e)
    (or (Seq_contains s1 e) (Seq_contains s2 e)))
  :pattern ((Seq_contains (Seq_append s1 s2) e))
  :qid |$Seq[Seq[Int]]_prog.seq_contains_over_append|)))
(assert (forall ((s Seq<Seq<Int>>) (e1 Seq<Int>) (e2 Seq<Int>)) (!
  (= (Seq_contains (Seq_build s e1) e2) (or (= e1 e2) (Seq_contains s e2)))
  :pattern ((Seq_contains (Seq_build s e1) e2))
  :qid |$Seq[Seq[Int]]_prog.seq_contains_over_build|)))
(assert (forall ((s Seq<Seq<Int>>) (n Int)) (!
  (implies (<= n 0) (= (Seq_take s n) (as Seq_empty  Seq<Seq<Int>>)))
  :pattern ((Seq_take s n))
  :qid |$Seq[Seq[Int]]_prog.seq_take_negative_length|)))
(assert (forall ((s Seq<Seq<Int>>) (n Int) (e Seq<Int>)) (!
  (=
    (Seq_contains (Seq_take s n) e)
    (exists ((i Int)) (!
      (and
        (<= 0 i)
        (and (< i n) (and (< i (Seq_length s)) (= (Seq_index s i) e))))
      :pattern ((Seq_index s i))
      )))
  :pattern ((Seq_contains (Seq_take s n) e))
  :qid |$Seq[Seq[Int]]_prog.seq_contains_over_take_index_exists|)))
(assert (forall ((s Seq<Seq<Int>>) (n Int)) (!
  (implies (<= n 0) (= (Seq_drop s n) s))
  :pattern ((Seq_drop s n))
  :qid |$Seq[Seq[Int]]_prog.seq_drop_negative_length|)))
(assert (forall ((s Seq<Seq<Int>>) (n Int) (e Seq<Int>)) (!
  (=
    (Seq_contains (Seq_drop s n) e)
    (exists ((i Int)) (!
      (and
        (<= 0 i)
        (and (<= n i) (and (< i (Seq_length s)) (= (Seq_index s i) e))))
      :pattern ((Seq_index s i))
      )))
  :pattern ((Seq_contains (Seq_drop s n) e))
  :qid |$Seq[Seq[Int]]_prog.seq_contains_over_drop_index_exists|)))
(assert (forall ((s1 Seq<Seq<Int>>) (s2 Seq<Seq<Int>>)) (!
  (=
    (Seq_equal s1 s2)
    (and
      (= (Seq_length s1) (Seq_length s2))
      (forall ((i Int)) (!
        (implies
          (and (<= 0 i) (< i (Seq_length s1)))
          (= (Seq_index s1 i) (Seq_index s2 i)))
        :pattern ((Seq_index s1 i))
        :pattern ((Seq_index s2 i))
        ))))
  :pattern ((Seq_equal s1 s2))
  :qid |$Seq[Seq[Int]]_prog.extensional_seq_equality|)))
(assert (forall ((s1 Seq<Seq<Int>>) (s2 Seq<Seq<Int>>)) (!
  (implies (Seq_equal s1 s2) (= s1 s2))
  :pattern ((Seq_equal s1 s2))
  :qid |$Seq[Seq[Int]]_prog.seq_equality_identity|)))
(assert (forall ((s1 Seq<Seq<Int>>) (s2 Seq<Seq<Int>>) (n Int)) (!
  (=
    (Seq_sameuntil s1 s2 n)
    (forall ((i Int)) (!
      (implies (and (<= 0 i) (< i n)) (= (Seq_index s1 i) (Seq_index s2 i)))
      :pattern ((Seq_index s1 i))
      :pattern ((Seq_index s2 i))
      )))
  :pattern ((Seq_sameuntil s1 s2 n))
  :qid |$Seq[Seq[Int]]_prog.extensional_seq_equality_prefix|)))
(assert (forall ((s Seq<Seq<Int>>) (n Int)) (!
  (implies
    (<= 0 n)
    (ite
      (<= n (Seq_length s))
      (= (Seq_length (Seq_take s n)) n)
      (= (Seq_length (Seq_take s n)) (Seq_length s))))
  :pattern ((Seq_length (Seq_take s n)))
  :qid |$Seq[Seq[Int]]_prog.seq_length_over_take|)))
(assert (forall ((s Seq<Seq<Int>>) (n Int) (i Int)) (!
  (implies
    (and (<= 0 i) (and (< i n) (< i (Seq_length s))))
    (= (Seq_index (Seq_take s n) i) (Seq_index s i)))
  :pattern ((Seq_index (Seq_take s n) i))
  :pattern ((Seq_index s i) (Seq_take s n))
  :qid |$Seq[Seq[Int]]_prog.seq_index_over_take|)))
(assert (forall ((s Seq<Seq<Int>>) (n Int)) (!
  (implies
    (<= 0 n)
    (ite
      (<= n (Seq_length s))
      (= (Seq_length (Seq_drop s n)) (- (Seq_length s) n))
      (= (Seq_length (Seq_drop s n)) 0)))
  :pattern ((Seq_length (Seq_drop s n)))
  :qid |$Seq[Seq[Int]]_prog.seq_length_over_drop|)))
(assert (forall ((s Seq<Seq<Int>>) (n Int) (i Int)) (!
  (implies
    (and (<= 0 n) (and (<= 0 i) (< i (- (Seq_length s) n))))
    (= (Seq_index (Seq_drop s n) i) (Seq_index s (+ i n))))
  :pattern ((Seq_index (Seq_drop s n) i))
  :qid |$Seq[Seq[Int]]_prog.seq_index_over_drop_1|)))
(assert (forall ((s Seq<Seq<Int>>) (n Int) (i Int)) (!
  (implies
    (and (<= 0 n) (and (<= n i) (< i (Seq_length s))))
    (= (Seq_index (Seq_drop s n) (- i n)) (Seq_index s i)))
  :pattern ((Seq_index s i) (Seq_drop s n))
  :qid |$Seq[Seq[Int]]_prog.seq_index_over_drop_2|)))
(assert (forall ((s Seq<Seq<Int>>) (i Int) (e Seq<Int>) (n Int)) (!
  (implies
    (and (<= 0 i) (and (< i n) (< n (Seq_length s))))
    (= (Seq_take (Seq_update s i e) n) (Seq_update (Seq_take s n) i e)))
  :pattern ((Seq_take (Seq_update s i e) n))
  :qid |$Seq[Seq[Int]]_prog.seq_take_over_update_1|)))
(assert (forall ((s Seq<Seq<Int>>) (i Int) (e Seq<Int>) (n Int)) (!
  (implies
    (and (<= n i) (< i (Seq_length s)))
    (= (Seq_take (Seq_update s i e) n) (Seq_take s n)))
  :pattern ((Seq_take (Seq_update s i e) n))
  :qid |$Seq[Seq[Int]]_prog.seq_take_over_update_2|)))
(assert (forall ((s Seq<Seq<Int>>) (i Int) (e Seq<Int>) (n Int)) (!
  (implies
    (and (<= 0 n) (and (<= n i) (< i (Seq_length s))))
    (= (Seq_drop (Seq_update s i e) n) (Seq_update (Seq_drop s n) (- i n) e)))
  :pattern ((Seq_drop (Seq_update s i e) n))
  :qid |$Seq[Seq[Int]]_prog.seq_drop_over_update_1|)))
(assert (forall ((s Seq<Seq<Int>>) (i Int) (e Seq<Int>) (n Int)) (!
  (implies
    (and (<= 0 i) (and (< i n) (< n (Seq_length s))))
    (= (Seq_drop (Seq_update s i e) n) (Seq_drop s n)))
  :pattern ((Seq_drop (Seq_update s i e) n))
  :qid |$Seq[Seq[Int]]_prog.seq_drop_over_update_2|)))
(assert (forall ((s Seq<Seq<Int>>) (e Seq<Int>) (n Int)) (!
  (implies
    (and (<= 0 n) (<= n (Seq_length s)))
    (= (Seq_drop (Seq_build s e) n) (Seq_build (Seq_drop s n) e)))
  :pattern ((Seq_drop (Seq_build s e) n))
  :qid |$Seq[Seq[Int]]_prog.seq_drop_over_build|)))
(assert (forall ((s Seq<Int>)) (!
  (<= 0 (Seq_length s))
  :pattern ((Seq_length s))
  :qid |$Seq[Int]_prog.seq_length_non_negative|)))
(assert (= (Seq_length (as Seq_empty  Seq<Int>)) 0))
(assert (forall ((s Seq<Int>)) (!
  (implies (= (Seq_length s) 0) (= s (as Seq_empty  Seq<Int>)))
  :pattern ((Seq_length s))
  :qid |$Seq[Int]_prog.only_empty_seq_length_zero|)))
(assert (forall ((e Int)) (!
  (= (Seq_length (Seq_singleton e)) 1)
  :pattern ((Seq_length (Seq_singleton e)))
  :qid |$Seq[Int]_prog.length_singleton_seq|)))
(assert (forall ((s Seq<Int>) (e Int)) (!
  (= (Seq_length (Seq_build s e)) (+ 1 (Seq_length s)))
  :pattern ((Seq_length (Seq_build s e)))
  :qid |$Seq[Int]_prog.length_seq_build_inc_by_one|)))
(assert (forall ((s Seq<Int>) (i Int) (e Int)) (!
  (ite
    (= i (Seq_length s))
    (= (Seq_index (Seq_build s e) i) e)
    (= (Seq_index (Seq_build s e) i) (Seq_index s i)))
  :pattern ((Seq_index (Seq_build s e) i))
  :qid |$Seq[Int]_prog.seq_index_over_build|)))
(assert (forall ((s1 Seq<Int>) (s2 Seq<Int>)) (!
  (implies
    (and
      (not (= s1 (as Seq_empty  Seq<Int>)))
      (not (= s2 (as Seq_empty  Seq<Int>))))
    (= (Seq_length (Seq_append s1 s2)) (+ (Seq_length s1) (Seq_length s2))))
  :pattern ((Seq_length (Seq_append s1 s2)))
  :qid |$Seq[Int]_prog.seq_length_over_append|)))
(assert (forall ((e Int)) (!
  (= (Seq_index (Seq_singleton e) 0) e)
  :pattern ((Seq_index (Seq_singleton e) 0))
  :qid |$Seq[Int]_prog.seq_index_over_singleton|)))
(assert (forall ((e1 Int) (e2 Int)) (!
  (= (Seq_contains (Seq_singleton e1) e2) (= e1 e2))
  :pattern ((Seq_contains (Seq_singleton e1) e2))
  :qid |$Seq[Int]_prog.seq_contains_over_singleton|)))
(assert (forall ((s Seq<Int>)) (!
  (= (Seq_append (as Seq_empty  Seq<Int>) s) s)
  :pattern ((Seq_append (as Seq_empty  Seq<Int>) s))
  :qid |$Seq[Int]_prog.seq_append_empty_left|)))
(assert (forall ((s Seq<Int>)) (!
  (= (Seq_append s (as Seq_empty  Seq<Int>)) s)
  :pattern ((Seq_append s (as Seq_empty  Seq<Int>)))
  :qid |$Seq[Int]_prog.seq_append_empty_right|)))
(assert (forall ((s1 Seq<Int>) (s2 Seq<Int>) (i Int)) (!
  (implies
    (and
      (not (= s1 (as Seq_empty  Seq<Int>)))
      (not (= s2 (as Seq_empty  Seq<Int>))))
    (ite
      (< i (Seq_length s1))
      (= (Seq_index (Seq_append s1 s2) i) (Seq_index s1 i))
      (= (Seq_index (Seq_append s1 s2) i) (Seq_index s2 (- i (Seq_length s1))))))
  :pattern ((Seq_index (Seq_append s1 s2) i))
  :pattern ((Seq_index s1 i) (Seq_append s1 s2))
  :qid |$Seq[Int]_prog.seq_index_over_append|)))
(assert (forall ((s Seq<Int>) (i Int) (e Int)) (!
  (implies
    (and (<= 0 i) (< i (Seq_length s)))
    (= (Seq_length (Seq_update s i e)) (Seq_length s)))
  :pattern ((Seq_length (Seq_update s i e)))
  :qid |$Seq[Int]_prog.seq_length_invariant_over_update|)))
(assert (forall ((s Seq<Int>) (i Int) (e Int) (j Int)) (!
  (ite
    (implies (and (<= 0 i) (< i (Seq_length s))) (= i j))
    (= (Seq_index (Seq_update s i e) j) e)
    (= (Seq_index (Seq_update s i e) j) (Seq_index s j)))
  :pattern ((Seq_index (Seq_update s i e) j))
  :qid |$Seq[Int]_prog.seq_index_over_update|)))
(assert (forall ((s Seq<Int>) (e Int)) (!
  (=
    (Seq_contains s e)
    (exists ((i Int)) (!
      (and (<= 0 i) (and (< i (Seq_length s)) (= (Seq_index s i) e)))
      :pattern ((Seq_index s i))
      )))
  :pattern ((Seq_contains s e))
  :qid |$Seq[Int]_prog.seq_element_contains_index_exists|)))
(assert (forall ((e Int)) (!
  (not (Seq_contains (as Seq_empty  Seq<Int>) e))
  :pattern ((Seq_contains (as Seq_empty  Seq<Int>) e))
  :qid |$Seq[Int]_prog.empty_seq_contains_nothing|)))
(assert (forall ((s1 Seq<Int>) (s2 Seq<Int>) (e Int)) (!
  (=
    (Seq_contains (Seq_append s1 s2) e)
    (or (Seq_contains s1 e) (Seq_contains s2 e)))
  :pattern ((Seq_contains (Seq_append s1 s2) e))
  :qid |$Seq[Int]_prog.seq_contains_over_append|)))
(assert (forall ((s Seq<Int>) (e1 Int) (e2 Int)) (!
  (= (Seq_contains (Seq_build s e1) e2) (or (= e1 e2) (Seq_contains s e2)))
  :pattern ((Seq_contains (Seq_build s e1) e2))
  :qid |$Seq[Int]_prog.seq_contains_over_build|)))
(assert (forall ((s Seq<Int>) (n Int)) (!
  (implies (<= n 0) (= (Seq_take s n) (as Seq_empty  Seq<Int>)))
  :pattern ((Seq_take s n))
  :qid |$Seq[Int]_prog.seq_take_negative_length|)))
(assert (forall ((s Seq<Int>) (n Int) (e Int)) (!
  (=
    (Seq_contains (Seq_take s n) e)
    (exists ((i Int)) (!
      (and
        (<= 0 i)
        (and (< i n) (and (< i (Seq_length s)) (= (Seq_index s i) e))))
      :pattern ((Seq_index s i))
      )))
  :pattern ((Seq_contains (Seq_take s n) e))
  :qid |$Seq[Int]_prog.seq_contains_over_take_index_exists|)))
(assert (forall ((s Seq<Int>) (n Int)) (!
  (implies (<= n 0) (= (Seq_drop s n) s))
  :pattern ((Seq_drop s n))
  :qid |$Seq[Int]_prog.seq_drop_negative_length|)))
(assert (forall ((s Seq<Int>) (n Int) (e Int)) (!
  (=
    (Seq_contains (Seq_drop s n) e)
    (exists ((i Int)) (!
      (and
        (<= 0 i)
        (and (<= n i) (and (< i (Seq_length s)) (= (Seq_index s i) e))))
      :pattern ((Seq_index s i))
      )))
  :pattern ((Seq_contains (Seq_drop s n) e))
  :qid |$Seq[Int]_prog.seq_contains_over_drop_index_exists|)))
(assert (forall ((s1 Seq<Int>) (s2 Seq<Int>)) (!
  (=
    (Seq_equal s1 s2)
    (and
      (= (Seq_length s1) (Seq_length s2))
      (forall ((i Int)) (!
        (implies
          (and (<= 0 i) (< i (Seq_length s1)))
          (= (Seq_index s1 i) (Seq_index s2 i)))
        :pattern ((Seq_index s1 i))
        :pattern ((Seq_index s2 i))
        ))))
  :pattern ((Seq_equal s1 s2))
  :qid |$Seq[Int]_prog.extensional_seq_equality|)))
(assert (forall ((s1 Seq<Int>) (s2 Seq<Int>)) (!
  (implies (Seq_equal s1 s2) (= s1 s2))
  :pattern ((Seq_equal s1 s2))
  :qid |$Seq[Int]_prog.seq_equality_identity|)))
(assert (forall ((s1 Seq<Int>) (s2 Seq<Int>) (n Int)) (!
  (=
    (Seq_sameuntil s1 s2 n)
    (forall ((i Int)) (!
      (implies (and (<= 0 i) (< i n)) (= (Seq_index s1 i) (Seq_index s2 i)))
      :pattern ((Seq_index s1 i))
      :pattern ((Seq_index s2 i))
      )))
  :pattern ((Seq_sameuntil s1 s2 n))
  :qid |$Seq[Int]_prog.extensional_seq_equality_prefix|)))
(assert (forall ((s Seq<Int>) (n Int)) (!
  (implies
    (<= 0 n)
    (ite
      (<= n (Seq_length s))
      (= (Seq_length (Seq_take s n)) n)
      (= (Seq_length (Seq_take s n)) (Seq_length s))))
  :pattern ((Seq_length (Seq_take s n)))
  :qid |$Seq[Int]_prog.seq_length_over_take|)))
(assert (forall ((s Seq<Int>) (n Int) (i Int)) (!
  (implies
    (and (<= 0 i) (and (< i n) (< i (Seq_length s))))
    (= (Seq_index (Seq_take s n) i) (Seq_index s i)))
  :pattern ((Seq_index (Seq_take s n) i))
  :pattern ((Seq_index s i) (Seq_take s n))
  :qid |$Seq[Int]_prog.seq_index_over_take|)))
(assert (forall ((s Seq<Int>) (n Int)) (!
  (implies
    (<= 0 n)
    (ite
      (<= n (Seq_length s))
      (= (Seq_length (Seq_drop s n)) (- (Seq_length s) n))
      (= (Seq_length (Seq_drop s n)) 0)))
  :pattern ((Seq_length (Seq_drop s n)))
  :qid |$Seq[Int]_prog.seq_length_over_drop|)))
(assert (forall ((s Seq<Int>) (n Int) (i Int)) (!
  (implies
    (and (<= 0 n) (and (<= 0 i) (< i (- (Seq_length s) n))))
    (= (Seq_index (Seq_drop s n) i) (Seq_index s (+ i n))))
  :pattern ((Seq_index (Seq_drop s n) i))
  :qid |$Seq[Int]_prog.seq_index_over_drop_1|)))
(assert (forall ((s Seq<Int>) (n Int) (i Int)) (!
  (implies
    (and (<= 0 n) (and (<= n i) (< i (Seq_length s))))
    (= (Seq_index (Seq_drop s n) (- i n)) (Seq_index s i)))
  :pattern ((Seq_index s i) (Seq_drop s n))
  :qid |$Seq[Int]_prog.seq_index_over_drop_2|)))
(assert (forall ((s Seq<Int>) (i Int) (e Int) (n Int)) (!
  (implies
    (and (<= 0 i) (and (< i n) (< n (Seq_length s))))
    (= (Seq_take (Seq_update s i e) n) (Seq_update (Seq_take s n) i e)))
  :pattern ((Seq_take (Seq_update s i e) n))
  :qid |$Seq[Int]_prog.seq_take_over_update_1|)))
(assert (forall ((s Seq<Int>) (i Int) (e Int) (n Int)) (!
  (implies
    (and (<= n i) (< i (Seq_length s)))
    (= (Seq_take (Seq_update s i e) n) (Seq_take s n)))
  :pattern ((Seq_take (Seq_update s i e) n))
  :qid |$Seq[Int]_prog.seq_take_over_update_2|)))
(assert (forall ((s Seq<Int>) (i Int) (e Int) (n Int)) (!
  (implies
    (and (<= 0 n) (and (<= n i) (< i (Seq_length s))))
    (= (Seq_drop (Seq_update s i e) n) (Seq_update (Seq_drop s n) (- i n) e)))
  :pattern ((Seq_drop (Seq_update s i e) n))
  :qid |$Seq[Int]_prog.seq_drop_over_update_1|)))
(assert (forall ((s Seq<Int>) (i Int) (e Int) (n Int)) (!
  (implies
    (and (<= 0 i) (and (< i n) (< n (Seq_length s))))
    (= (Seq_drop (Seq_update s i e) n) (Seq_drop s n)))
  :pattern ((Seq_drop (Seq_update s i e) n))
  :qid |$Seq[Int]_prog.seq_drop_over_update_2|)))
(assert (forall ((s Seq<Int>) (e Int) (n Int)) (!
  (implies
    (and (<= 0 n) (<= n (Seq_length s)))
    (= (Seq_drop (Seq_build s e) n) (Seq_build (Seq_drop s n) e)))
  :pattern ((Seq_drop (Seq_build s e) n))
  :qid |$Seq[Int]_prog.seq_drop_over_build|)))
(assert (forall ((min_ Int) (max Int)) (!
  (ite
    (< min_ max)
    (= (Seq_length (Seq_range min_ max)) (- max min_))
    (= (Seq_length (Seq_range min_ max)) 0))
  :pattern ((Seq_length (Seq_range min_ max)))
  :qid |$Seq[Int]_prog.ranged_seq_length|)))
(assert (forall ((min_ Int) (max Int) (i Int)) (!
  (implies
    (and (<= 0 i) (< i (- max min_)))
    (= (Seq_index (Seq_range min_ max) i) (+ min_ i)))
  :pattern ((Seq_index (Seq_range min_ max) i))
  :qid |$Seq[Int]_prog.ranged_seq_index|)))
(assert (forall ((min_ Int) (max Int) (e Int)) (!
  (= (Seq_contains (Seq_range min_ max) e) (and (<= min_ e) (< e max)))
  :pattern ((Seq_contains (Seq_range min_ max) e))
  :qid |$Seq[Int]_prog.ranged_seq_contains|)))
(assert (forall ((s Set<Seq<Seq<Int>>>)) (!
  (<= 0 (Set_card s))
  :pattern ((Set_card s))
  :qid |$Set[Seq[Seq[Int]]]_prog.card_non_negative|)))
(assert (forall ((e Seq<Seq<Int>>)) (!
  (not (Set_in e (as Set_empty  Set<Seq<Seq<Int>>>)))
  :pattern ((Set_in e (as Set_empty  Set<Seq<Seq<Int>>>)))
  :qid |$Set[Seq[Seq[Int]]]_prog.in_empty_set|)))
(assert (forall ((s Set<Seq<Seq<Int>>>)) (!
  (and
    (= (= (Set_card s) 0) (= s (as Set_empty  Set<Seq<Seq<Int>>>)))
    (implies
      (not (= (Set_card s) 0))
      (exists ((e Seq<Seq<Int>>)) (!
        (Set_in e s)
        :pattern ((Set_in e s))
        ))))
  :pattern ((Set_card s))
  :qid |$Set[Seq[Seq[Int]]]_prog.empty_set_cardinality|)))
(assert (forall ((e Seq<Seq<Int>>)) (!
  (Set_in e (Set_singleton e))
  :pattern ((Set_singleton e))
  :qid |$Set[Seq[Seq[Int]]]_prog.in_singleton_set|)))
(assert (forall ((e1 Seq<Seq<Int>>) (e2 Seq<Seq<Int>>)) (!
  (= (Set_in e1 (Set_singleton e2)) (= e1 e2))
  :pattern ((Set_in e1 (Set_singleton e2)))
  :qid |$Set[Seq[Seq[Int]]]_prog.in_singleton_set_equality|)))
(assert (forall ((e Seq<Seq<Int>>)) (!
  (= (Set_card (Set_singleton e)) 1)
  :pattern ((Set_card (Set_singleton e)))
  :qid |$Set[Seq[Seq[Int]]]_prog.singleton_set_cardinality|)))
(assert (forall ((s Set<Seq<Seq<Int>>>) (e Seq<Seq<Int>>)) (!
  (Set_in e (Set_unionone s e))
  :pattern ((Set_unionone s e))
  :qid |$Set[Seq[Seq[Int]]]_prog.in_unionone_same|)))
(assert (forall ((s Set<Seq<Seq<Int>>>) (e1 Seq<Seq<Int>>) (e2 Seq<Seq<Int>>)) (!
  (= (Set_in e1 (Set_unionone s e2)) (or (= e1 e2) (Set_in e1 s)))
  :pattern ((Set_in e1 (Set_unionone s e2)))
  :qid |$Set[Seq[Seq[Int]]]_prog.in_unionone_other|)))
(assert (forall ((s Set<Seq<Seq<Int>>>) (e1 Seq<Seq<Int>>) (e2 Seq<Seq<Int>>)) (!
  (implies (Set_in e1 s) (Set_in e1 (Set_unionone s e2)))
  :pattern ((Set_in e1 s) (Set_unionone s e2))
  :qid |$Set[Seq[Seq[Int]]]_prog.invariance_in_unionone|)))
(assert (forall ((s Set<Seq<Seq<Int>>>) (e Seq<Seq<Int>>)) (!
  (implies (Set_in e s) (= (Set_card (Set_unionone s e)) (Set_card s)))
  :pattern ((Set_card (Set_unionone s e)))
  :qid |$Set[Seq[Seq[Int]]]_prog.unionone_cardinality_invariant|)))
(assert (forall ((s Set<Seq<Seq<Int>>>) (e Seq<Seq<Int>>)) (!
  (implies
    (not (Set_in e s))
    (= (Set_card (Set_unionone s e)) (+ (Set_card s) 1)))
  :pattern ((Set_card (Set_unionone s e)))
  :qid |$Set[Seq[Seq[Int]]]_prog.unionone_cardinality_changed|)))
(assert (forall ((s1 Set<Seq<Seq<Int>>>) (s2 Set<Seq<Seq<Int>>>) (e Seq<Seq<Int>>)) (!
  (= (Set_in e (Set_union s1 s2)) (or (Set_in e s1) (Set_in e s2)))
  :pattern ((Set_in e (Set_union s1 s2)))
  :qid |$Set[Seq[Seq[Int]]]_prog.in_union_in_one|)))
(assert (forall ((s1 Set<Seq<Seq<Int>>>) (s2 Set<Seq<Seq<Int>>>) (e Seq<Seq<Int>>)) (!
  (implies (Set_in e s1) (Set_in e (Set_union s1 s2)))
  :pattern ((Set_in e s1) (Set_union s1 s2))
  :qid |$Set[Seq[Seq[Int]]]_prog.in_left_in_union|)))
(assert (forall ((s1 Set<Seq<Seq<Int>>>) (s2 Set<Seq<Seq<Int>>>) (e Seq<Seq<Int>>)) (!
  (implies (Set_in e s2) (Set_in e (Set_union s1 s2)))
  :pattern ((Set_in e s2) (Set_union s1 s2))
  :qid |$Set[Seq[Seq[Int]]]_prog.in_right_in_union|)))
(assert (forall ((s1 Set<Seq<Seq<Int>>>) (s2 Set<Seq<Seq<Int>>>) (e Seq<Seq<Int>>)) (!
  (= (Set_in e (Set_intersection s1 s2)) (and (Set_in e s1) (Set_in e s2)))
  :pattern ((Set_in e (Set_intersection s1 s2)))
  :pattern ((Set_intersection s1 s2) (Set_in e s1))
  :pattern ((Set_intersection s1 s2) (Set_in e s2))
  :qid |$Set[Seq[Seq[Int]]]_prog.in_intersection_in_both|)))
(assert (forall ((s1 Set<Seq<Seq<Int>>>) (s2 Set<Seq<Seq<Int>>>)) (!
  (= (Set_union s1 (Set_union s1 s2)) (Set_union s1 s2))
  :pattern ((Set_union s1 (Set_union s1 s2)))
  :qid |$Set[Seq[Seq[Int]]]_prog.union_left_idempotency|)))
(assert (forall ((s1 Set<Seq<Seq<Int>>>) (s2 Set<Seq<Seq<Int>>>)) (!
  (= (Set_union (Set_union s1 s2) s2) (Set_union s1 s2))
  :pattern ((Set_union (Set_union s1 s2) s2))
  :qid |$Set[Seq[Seq[Int]]]_prog.union_right_idempotency|)))
(assert (forall ((s1 Set<Seq<Seq<Int>>>) (s2 Set<Seq<Seq<Int>>>)) (!
  (= (Set_intersection s1 (Set_intersection s1 s2)) (Set_intersection s1 s2))
  :pattern ((Set_intersection s1 (Set_intersection s1 s2)))
  :qid |$Set[Seq[Seq[Int]]]_prog.intersection_left_idempotency|)))
(assert (forall ((s1 Set<Seq<Seq<Int>>>) (s2 Set<Seq<Seq<Int>>>)) (!
  (= (Set_intersection (Set_intersection s1 s2) s2) (Set_intersection s1 s2))
  :pattern ((Set_intersection (Set_intersection s1 s2) s2))
  :qid |$Set[Seq[Seq[Int]]]_prog.intersection_right_idempotency|)))
(assert (forall ((s1 Set<Seq<Seq<Int>>>) (s2 Set<Seq<Seq<Int>>>)) (!
  (=
    (+ (Set_card (Set_union s1 s2)) (Set_card (Set_intersection s1 s2)))
    (+ (Set_card s1) (Set_card s2)))
  :pattern ((Set_card (Set_union s1 s2)))
  :pattern ((Set_card (Set_intersection s1 s2)))
  :qid |$Set[Seq[Seq[Int]]]_prog.cardinality_sums|)))
(assert (forall ((s1 Set<Seq<Seq<Int>>>) (s2 Set<Seq<Seq<Int>>>) (e Seq<Seq<Int>>)) (!
  (= (Set_in e (Set_difference s1 s2)) (and (Set_in e s1) (not (Set_in e s2))))
  :pattern ((Set_in e (Set_difference s1 s2)))
  :qid |$Set[Seq[Seq[Int]]]_prog.in_difference|)))
(assert (forall ((s1 Set<Seq<Seq<Int>>>) (s2 Set<Seq<Seq<Int>>>) (e Seq<Seq<Int>>)) (!
  (implies (Set_in e s2) (not (Set_in e (Set_difference s1 s2))))
  :pattern ((Set_difference s1 s2) (Set_in e s2))
  :qid |$Set[Seq[Seq[Int]]]_prog.not_in_difference|)))
(assert (forall ((s1 Set<Seq<Seq<Int>>>) (s2 Set<Seq<Seq<Int>>>)) (!
  (=
    (Set_subset s1 s2)
    (forall ((e Seq<Seq<Int>>)) (!
      (implies (Set_in e s1) (Set_in e s2))
      :pattern ((Set_in e s1))
      :pattern ((Set_in e s2))
      )))
  :pattern ((Set_subset s1 s2))
  :qid |$Set[Seq[Seq[Int]]]_prog.subset_definition|)))
(assert (forall ((s1 Set<Seq<Seq<Int>>>) (s2 Set<Seq<Seq<Int>>>)) (!
  (=
    (Set_equal s1 s2)
    (forall ((e Seq<Seq<Int>>)) (!
      (= (Set_in e s1) (Set_in e s2))
      :pattern ((Set_in e s1))
      :pattern ((Set_in e s2))
      )))
  :pattern ((Set_equal s1 s2))
  :qid |$Set[Seq[Seq[Int]]]_prog.equality_definition|)))
(assert (forall ((s1 Set<Seq<Seq<Int>>>) (s2 Set<Seq<Seq<Int>>>)) (!
  (implies (Set_equal s1 s2) (= s1 s2))
  :pattern ((Set_equal s1 s2))
  :qid |$Set[Seq[Seq[Int]]]_prog.native_equality|)))
(assert (forall ((s1 Set<Seq<Seq<Int>>>) (s2 Set<Seq<Seq<Int>>>)) (!
  (=
    (Set_disjoint s1 s2)
    (forall ((e Seq<Seq<Int>>)) (!
      (or (not (Set_in e s1)) (not (Set_in e s2)))
      :pattern ((Set_in e s1))
      :pattern ((Set_in e s2))
      )))
  :pattern ((Set_disjoint s1 s2))
  :qid |$Set[Seq[Seq[Int]]]_prog.disjointness_definition|)))
(assert (forall ((s1 Set<Seq<Seq<Int>>>) (s2 Set<Seq<Seq<Int>>>)) (!
  (and
    (=
      (+
        (+ (Set_card (Set_difference s1 s2)) (Set_card (Set_difference s2 s1)))
        (Set_card (Set_intersection s1 s2)))
      (Set_card (Set_union s1 s2)))
    (=
      (Set_card (Set_difference s1 s2))
      (- (Set_card s1) (Set_card (Set_intersection s1 s2)))))
  :pattern ((Set_card (Set_difference s1 s2)))
  :qid |$Set[Seq[Seq[Int]]]_prog.cardinality_difference|)))
(assert (forall ((s Set<option<array>>)) (!
  (<= 0 (Set_card s))
  :pattern ((Set_card s))
  :qid |$Set[option[array]]_prog.card_non_negative|)))
(assert (forall ((e option<array>)) (!
  (not (Set_in e (as Set_empty  Set<option<array>>)))
  :pattern ((Set_in e (as Set_empty  Set<option<array>>)))
  :qid |$Set[option[array]]_prog.in_empty_set|)))
(assert (forall ((s Set<option<array>>)) (!
  (and
    (= (= (Set_card s) 0) (= s (as Set_empty  Set<option<array>>)))
    (implies
      (not (= (Set_card s) 0))
      (exists ((e option<array>)) (!
        (Set_in e s)
        :pattern ((Set_in e s))
        ))))
  :pattern ((Set_card s))
  :qid |$Set[option[array]]_prog.empty_set_cardinality|)))
(assert (forall ((e option<array>)) (!
  (Set_in e (Set_singleton e))
  :pattern ((Set_singleton e))
  :qid |$Set[option[array]]_prog.in_singleton_set|)))
(assert (forall ((e1 option<array>) (e2 option<array>)) (!
  (= (Set_in e1 (Set_singleton e2)) (= e1 e2))
  :pattern ((Set_in e1 (Set_singleton e2)))
  :qid |$Set[option[array]]_prog.in_singleton_set_equality|)))
(assert (forall ((e option<array>)) (!
  (= (Set_card (Set_singleton e)) 1)
  :pattern ((Set_card (Set_singleton e)))
  :qid |$Set[option[array]]_prog.singleton_set_cardinality|)))
(assert (forall ((s Set<option<array>>) (e option<array>)) (!
  (Set_in e (Set_unionone s e))
  :pattern ((Set_unionone s e))
  :qid |$Set[option[array]]_prog.in_unionone_same|)))
(assert (forall ((s Set<option<array>>) (e1 option<array>) (e2 option<array>)) (!
  (= (Set_in e1 (Set_unionone s e2)) (or (= e1 e2) (Set_in e1 s)))
  :pattern ((Set_in e1 (Set_unionone s e2)))
  :qid |$Set[option[array]]_prog.in_unionone_other|)))
(assert (forall ((s Set<option<array>>) (e1 option<array>) (e2 option<array>)) (!
  (implies (Set_in e1 s) (Set_in e1 (Set_unionone s e2)))
  :pattern ((Set_in e1 s) (Set_unionone s e2))
  :qid |$Set[option[array]]_prog.invariance_in_unionone|)))
(assert (forall ((s Set<option<array>>) (e option<array>)) (!
  (implies (Set_in e s) (= (Set_card (Set_unionone s e)) (Set_card s)))
  :pattern ((Set_card (Set_unionone s e)))
  :qid |$Set[option[array]]_prog.unionone_cardinality_invariant|)))
(assert (forall ((s Set<option<array>>) (e option<array>)) (!
  (implies
    (not (Set_in e s))
    (= (Set_card (Set_unionone s e)) (+ (Set_card s) 1)))
  :pattern ((Set_card (Set_unionone s e)))
  :qid |$Set[option[array]]_prog.unionone_cardinality_changed|)))
(assert (forall ((s1 Set<option<array>>) (s2 Set<option<array>>) (e option<array>)) (!
  (= (Set_in e (Set_union s1 s2)) (or (Set_in e s1) (Set_in e s2)))
  :pattern ((Set_in e (Set_union s1 s2)))
  :qid |$Set[option[array]]_prog.in_union_in_one|)))
(assert (forall ((s1 Set<option<array>>) (s2 Set<option<array>>) (e option<array>)) (!
  (implies (Set_in e s1) (Set_in e (Set_union s1 s2)))
  :pattern ((Set_in e s1) (Set_union s1 s2))
  :qid |$Set[option[array]]_prog.in_left_in_union|)))
(assert (forall ((s1 Set<option<array>>) (s2 Set<option<array>>) (e option<array>)) (!
  (implies (Set_in e s2) (Set_in e (Set_union s1 s2)))
  :pattern ((Set_in e s2) (Set_union s1 s2))
  :qid |$Set[option[array]]_prog.in_right_in_union|)))
(assert (forall ((s1 Set<option<array>>) (s2 Set<option<array>>) (e option<array>)) (!
  (= (Set_in e (Set_intersection s1 s2)) (and (Set_in e s1) (Set_in e s2)))
  :pattern ((Set_in e (Set_intersection s1 s2)))
  :pattern ((Set_intersection s1 s2) (Set_in e s1))
  :pattern ((Set_intersection s1 s2) (Set_in e s2))
  :qid |$Set[option[array]]_prog.in_intersection_in_both|)))
(assert (forall ((s1 Set<option<array>>) (s2 Set<option<array>>)) (!
  (= (Set_union s1 (Set_union s1 s2)) (Set_union s1 s2))
  :pattern ((Set_union s1 (Set_union s1 s2)))
  :qid |$Set[option[array]]_prog.union_left_idempotency|)))
(assert (forall ((s1 Set<option<array>>) (s2 Set<option<array>>)) (!
  (= (Set_union (Set_union s1 s2) s2) (Set_union s1 s2))
  :pattern ((Set_union (Set_union s1 s2) s2))
  :qid |$Set[option[array]]_prog.union_right_idempotency|)))
(assert (forall ((s1 Set<option<array>>) (s2 Set<option<array>>)) (!
  (= (Set_intersection s1 (Set_intersection s1 s2)) (Set_intersection s1 s2))
  :pattern ((Set_intersection s1 (Set_intersection s1 s2)))
  :qid |$Set[option[array]]_prog.intersection_left_idempotency|)))
(assert (forall ((s1 Set<option<array>>) (s2 Set<option<array>>)) (!
  (= (Set_intersection (Set_intersection s1 s2) s2) (Set_intersection s1 s2))
  :pattern ((Set_intersection (Set_intersection s1 s2) s2))
  :qid |$Set[option[array]]_prog.intersection_right_idempotency|)))
(assert (forall ((s1 Set<option<array>>) (s2 Set<option<array>>)) (!
  (=
    (+ (Set_card (Set_union s1 s2)) (Set_card (Set_intersection s1 s2)))
    (+ (Set_card s1) (Set_card s2)))
  :pattern ((Set_card (Set_union s1 s2)))
  :pattern ((Set_card (Set_intersection s1 s2)))
  :qid |$Set[option[array]]_prog.cardinality_sums|)))
(assert (forall ((s1 Set<option<array>>) (s2 Set<option<array>>) (e option<array>)) (!
  (= (Set_in e (Set_difference s1 s2)) (and (Set_in e s1) (not (Set_in e s2))))
  :pattern ((Set_in e (Set_difference s1 s2)))
  :qid |$Set[option[array]]_prog.in_difference|)))
(assert (forall ((s1 Set<option<array>>) (s2 Set<option<array>>) (e option<array>)) (!
  (implies (Set_in e s2) (not (Set_in e (Set_difference s1 s2))))
  :pattern ((Set_difference s1 s2) (Set_in e s2))
  :qid |$Set[option[array]]_prog.not_in_difference|)))
(assert (forall ((s1 Set<option<array>>) (s2 Set<option<array>>)) (!
  (=
    (Set_subset s1 s2)
    (forall ((e option<array>)) (!
      (implies (Set_in e s1) (Set_in e s2))
      :pattern ((Set_in e s1))
      :pattern ((Set_in e s2))
      )))
  :pattern ((Set_subset s1 s2))
  :qid |$Set[option[array]]_prog.subset_definition|)))
(assert (forall ((s1 Set<option<array>>) (s2 Set<option<array>>)) (!
  (=
    (Set_equal s1 s2)
    (forall ((e option<array>)) (!
      (= (Set_in e s1) (Set_in e s2))
      :pattern ((Set_in e s1))
      :pattern ((Set_in e s2))
      )))
  :pattern ((Set_equal s1 s2))
  :qid |$Set[option[array]]_prog.equality_definition|)))
(assert (forall ((s1 Set<option<array>>) (s2 Set<option<array>>)) (!
  (implies (Set_equal s1 s2) (= s1 s2))
  :pattern ((Set_equal s1 s2))
  :qid |$Set[option[array]]_prog.native_equality|)))
(assert (forall ((s1 Set<option<array>>) (s2 Set<option<array>>)) (!
  (=
    (Set_disjoint s1 s2)
    (forall ((e option<array>)) (!
      (or (not (Set_in e s1)) (not (Set_in e s2)))
      :pattern ((Set_in e s1))
      :pattern ((Set_in e s2))
      )))
  :pattern ((Set_disjoint s1 s2))
  :qid |$Set[option[array]]_prog.disjointness_definition|)))
(assert (forall ((s1 Set<option<array>>) (s2 Set<option<array>>)) (!
  (and
    (=
      (+
        (+ (Set_card (Set_difference s1 s2)) (Set_card (Set_difference s2 s1)))
        (Set_card (Set_intersection s1 s2)))
      (Set_card (Set_union s1 s2)))
    (=
      (Set_card (Set_difference s1 s2))
      (- (Set_card s1) (Set_card (Set_intersection s1 s2)))))
  :pattern ((Set_card (Set_difference s1 s2)))
  :qid |$Set[option[array]]_prog.cardinality_difference|)))
(assert (forall ((s Set<Seq<Int>>)) (!
  (<= 0 (Set_card s))
  :pattern ((Set_card s))
  :qid |$Set[Seq[Int]]_prog.card_non_negative|)))
(assert (forall ((e Seq<Int>)) (!
  (not (Set_in e (as Set_empty  Set<Seq<Int>>)))
  :pattern ((Set_in e (as Set_empty  Set<Seq<Int>>)))
  :qid |$Set[Seq[Int]]_prog.in_empty_set|)))
(assert (forall ((s Set<Seq<Int>>)) (!
  (and
    (= (= (Set_card s) 0) (= s (as Set_empty  Set<Seq<Int>>)))
    (implies
      (not (= (Set_card s) 0))
      (exists ((e Seq<Int>)) (!
        (Set_in e s)
        :pattern ((Set_in e s))
        ))))
  :pattern ((Set_card s))
  :qid |$Set[Seq[Int]]_prog.empty_set_cardinality|)))
(assert (forall ((e Seq<Int>)) (!
  (Set_in e (Set_singleton e))
  :pattern ((Set_singleton e))
  :qid |$Set[Seq[Int]]_prog.in_singleton_set|)))
(assert (forall ((e1 Seq<Int>) (e2 Seq<Int>)) (!
  (= (Set_in e1 (Set_singleton e2)) (= e1 e2))
  :pattern ((Set_in e1 (Set_singleton e2)))
  :qid |$Set[Seq[Int]]_prog.in_singleton_set_equality|)))
(assert (forall ((e Seq<Int>)) (!
  (= (Set_card (Set_singleton e)) 1)
  :pattern ((Set_card (Set_singleton e)))
  :qid |$Set[Seq[Int]]_prog.singleton_set_cardinality|)))
(assert (forall ((s Set<Seq<Int>>) (e Seq<Int>)) (!
  (Set_in e (Set_unionone s e))
  :pattern ((Set_unionone s e))
  :qid |$Set[Seq[Int]]_prog.in_unionone_same|)))
(assert (forall ((s Set<Seq<Int>>) (e1 Seq<Int>) (e2 Seq<Int>)) (!
  (= (Set_in e1 (Set_unionone s e2)) (or (= e1 e2) (Set_in e1 s)))
  :pattern ((Set_in e1 (Set_unionone s e2)))
  :qid |$Set[Seq[Int]]_prog.in_unionone_other|)))
(assert (forall ((s Set<Seq<Int>>) (e1 Seq<Int>) (e2 Seq<Int>)) (!
  (implies (Set_in e1 s) (Set_in e1 (Set_unionone s e2)))
  :pattern ((Set_in e1 s) (Set_unionone s e2))
  :qid |$Set[Seq[Int]]_prog.invariance_in_unionone|)))
(assert (forall ((s Set<Seq<Int>>) (e Seq<Int>)) (!
  (implies (Set_in e s) (= (Set_card (Set_unionone s e)) (Set_card s)))
  :pattern ((Set_card (Set_unionone s e)))
  :qid |$Set[Seq[Int]]_prog.unionone_cardinality_invariant|)))
(assert (forall ((s Set<Seq<Int>>) (e Seq<Int>)) (!
  (implies
    (not (Set_in e s))
    (= (Set_card (Set_unionone s e)) (+ (Set_card s) 1)))
  :pattern ((Set_card (Set_unionone s e)))
  :qid |$Set[Seq[Int]]_prog.unionone_cardinality_changed|)))
(assert (forall ((s1 Set<Seq<Int>>) (s2 Set<Seq<Int>>) (e Seq<Int>)) (!
  (= (Set_in e (Set_union s1 s2)) (or (Set_in e s1) (Set_in e s2)))
  :pattern ((Set_in e (Set_union s1 s2)))
  :qid |$Set[Seq[Int]]_prog.in_union_in_one|)))
(assert (forall ((s1 Set<Seq<Int>>) (s2 Set<Seq<Int>>) (e Seq<Int>)) (!
  (implies (Set_in e s1) (Set_in e (Set_union s1 s2)))
  :pattern ((Set_in e s1) (Set_union s1 s2))
  :qid |$Set[Seq[Int]]_prog.in_left_in_union|)))
(assert (forall ((s1 Set<Seq<Int>>) (s2 Set<Seq<Int>>) (e Seq<Int>)) (!
  (implies (Set_in e s2) (Set_in e (Set_union s1 s2)))
  :pattern ((Set_in e s2) (Set_union s1 s2))
  :qid |$Set[Seq[Int]]_prog.in_right_in_union|)))
(assert (forall ((s1 Set<Seq<Int>>) (s2 Set<Seq<Int>>) (e Seq<Int>)) (!
  (= (Set_in e (Set_intersection s1 s2)) (and (Set_in e s1) (Set_in e s2)))
  :pattern ((Set_in e (Set_intersection s1 s2)))
  :pattern ((Set_intersection s1 s2) (Set_in e s1))
  :pattern ((Set_intersection s1 s2) (Set_in e s2))
  :qid |$Set[Seq[Int]]_prog.in_intersection_in_both|)))
(assert (forall ((s1 Set<Seq<Int>>) (s2 Set<Seq<Int>>)) (!
  (= (Set_union s1 (Set_union s1 s2)) (Set_union s1 s2))
  :pattern ((Set_union s1 (Set_union s1 s2)))
  :qid |$Set[Seq[Int]]_prog.union_left_idempotency|)))
(assert (forall ((s1 Set<Seq<Int>>) (s2 Set<Seq<Int>>)) (!
  (= (Set_union (Set_union s1 s2) s2) (Set_union s1 s2))
  :pattern ((Set_union (Set_union s1 s2) s2))
  :qid |$Set[Seq[Int]]_prog.union_right_idempotency|)))
(assert (forall ((s1 Set<Seq<Int>>) (s2 Set<Seq<Int>>)) (!
  (= (Set_intersection s1 (Set_intersection s1 s2)) (Set_intersection s1 s2))
  :pattern ((Set_intersection s1 (Set_intersection s1 s2)))
  :qid |$Set[Seq[Int]]_prog.intersection_left_idempotency|)))
(assert (forall ((s1 Set<Seq<Int>>) (s2 Set<Seq<Int>>)) (!
  (= (Set_intersection (Set_intersection s1 s2) s2) (Set_intersection s1 s2))
  :pattern ((Set_intersection (Set_intersection s1 s2) s2))
  :qid |$Set[Seq[Int]]_prog.intersection_right_idempotency|)))
(assert (forall ((s1 Set<Seq<Int>>) (s2 Set<Seq<Int>>)) (!
  (=
    (+ (Set_card (Set_union s1 s2)) (Set_card (Set_intersection s1 s2)))
    (+ (Set_card s1) (Set_card s2)))
  :pattern ((Set_card (Set_union s1 s2)))
  :pattern ((Set_card (Set_intersection s1 s2)))
  :qid |$Set[Seq[Int]]_prog.cardinality_sums|)))
(assert (forall ((s1 Set<Seq<Int>>) (s2 Set<Seq<Int>>) (e Seq<Int>)) (!
  (= (Set_in e (Set_difference s1 s2)) (and (Set_in e s1) (not (Set_in e s2))))
  :pattern ((Set_in e (Set_difference s1 s2)))
  :qid |$Set[Seq[Int]]_prog.in_difference|)))
(assert (forall ((s1 Set<Seq<Int>>) (s2 Set<Seq<Int>>) (e Seq<Int>)) (!
  (implies (Set_in e s2) (not (Set_in e (Set_difference s1 s2))))
  :pattern ((Set_difference s1 s2) (Set_in e s2))
  :qid |$Set[Seq[Int]]_prog.not_in_difference|)))
(assert (forall ((s1 Set<Seq<Int>>) (s2 Set<Seq<Int>>)) (!
  (=
    (Set_subset s1 s2)
    (forall ((e Seq<Int>)) (!
      (implies (Set_in e s1) (Set_in e s2))
      :pattern ((Set_in e s1))
      :pattern ((Set_in e s2))
      )))
  :pattern ((Set_subset s1 s2))
  :qid |$Set[Seq[Int]]_prog.subset_definition|)))
(assert (forall ((s1 Set<Seq<Int>>) (s2 Set<Seq<Int>>)) (!
  (=
    (Set_equal s1 s2)
    (forall ((e Seq<Int>)) (!
      (= (Set_in e s1) (Set_in e s2))
      :pattern ((Set_in e s1))
      :pattern ((Set_in e s2))
      )))
  :pattern ((Set_equal s1 s2))
  :qid |$Set[Seq[Int]]_prog.equality_definition|)))
(assert (forall ((s1 Set<Seq<Int>>) (s2 Set<Seq<Int>>)) (!
  (implies (Set_equal s1 s2) (= s1 s2))
  :pattern ((Set_equal s1 s2))
  :qid |$Set[Seq[Int]]_prog.native_equality|)))
(assert (forall ((s1 Set<Seq<Int>>) (s2 Set<Seq<Int>>)) (!
  (=
    (Set_disjoint s1 s2)
    (forall ((e Seq<Int>)) (!
      (or (not (Set_in e s1)) (not (Set_in e s2)))
      :pattern ((Set_in e s1))
      :pattern ((Set_in e s2))
      )))
  :pattern ((Set_disjoint s1 s2))
  :qid |$Set[Seq[Int]]_prog.disjointness_definition|)))
(assert (forall ((s1 Set<Seq<Int>>) (s2 Set<Seq<Int>>)) (!
  (and
    (=
      (+
        (+ (Set_card (Set_difference s1 s2)) (Set_card (Set_difference s2 s1)))
        (Set_card (Set_intersection s1 s2)))
      (Set_card (Set_union s1 s2)))
    (=
      (Set_card (Set_difference s1 s2))
      (- (Set_card s1) (Set_card (Set_intersection s1 s2)))))
  :pattern ((Set_card (Set_difference s1 s2)))
  :qid |$Set[Seq[Int]]_prog.cardinality_difference|)))
(assert (forall ((s Set<Int>)) (!
  (<= 0 (Set_card s))
  :pattern ((Set_card s))
  :qid |$Set[Int]_prog.card_non_negative|)))
(assert (forall ((e Int)) (!
  (not (Set_in e (as Set_empty  Set<Int>)))
  :pattern ((Set_in e (as Set_empty  Set<Int>)))
  :qid |$Set[Int]_prog.in_empty_set|)))
(assert (forall ((s Set<Int>)) (!
  (and
    (= (= (Set_card s) 0) (= s (as Set_empty  Set<Int>)))
    (implies
      (not (= (Set_card s) 0))
      (exists ((e Int)) (!
        (Set_in e s)
        :pattern ((Set_in e s))
        ))))
  :pattern ((Set_card s))
  :qid |$Set[Int]_prog.empty_set_cardinality|)))
(assert (forall ((e Int)) (!
  (Set_in e (Set_singleton e))
  :pattern ((Set_singleton e))
  :qid |$Set[Int]_prog.in_singleton_set|)))
(assert (forall ((e1 Int) (e2 Int)) (!
  (= (Set_in e1 (Set_singleton e2)) (= e1 e2))
  :pattern ((Set_in e1 (Set_singleton e2)))
  :qid |$Set[Int]_prog.in_singleton_set_equality|)))
(assert (forall ((e Int)) (!
  (= (Set_card (Set_singleton e)) 1)
  :pattern ((Set_card (Set_singleton e)))
  :qid |$Set[Int]_prog.singleton_set_cardinality|)))
(assert (forall ((s Set<Int>) (e Int)) (!
  (Set_in e (Set_unionone s e))
  :pattern ((Set_unionone s e))
  :qid |$Set[Int]_prog.in_unionone_same|)))
(assert (forall ((s Set<Int>) (e1 Int) (e2 Int)) (!
  (= (Set_in e1 (Set_unionone s e2)) (or (= e1 e2) (Set_in e1 s)))
  :pattern ((Set_in e1 (Set_unionone s e2)))
  :qid |$Set[Int]_prog.in_unionone_other|)))
(assert (forall ((s Set<Int>) (e1 Int) (e2 Int)) (!
  (implies (Set_in e1 s) (Set_in e1 (Set_unionone s e2)))
  :pattern ((Set_in e1 s) (Set_unionone s e2))
  :qid |$Set[Int]_prog.invariance_in_unionone|)))
(assert (forall ((s Set<Int>) (e Int)) (!
  (implies (Set_in e s) (= (Set_card (Set_unionone s e)) (Set_card s)))
  :pattern ((Set_card (Set_unionone s e)))
  :qid |$Set[Int]_prog.unionone_cardinality_invariant|)))
(assert (forall ((s Set<Int>) (e Int)) (!
  (implies
    (not (Set_in e s))
    (= (Set_card (Set_unionone s e)) (+ (Set_card s) 1)))
  :pattern ((Set_card (Set_unionone s e)))
  :qid |$Set[Int]_prog.unionone_cardinality_changed|)))
(assert (forall ((s1 Set<Int>) (s2 Set<Int>) (e Int)) (!
  (= (Set_in e (Set_union s1 s2)) (or (Set_in e s1) (Set_in e s2)))
  :pattern ((Set_in e (Set_union s1 s2)))
  :qid |$Set[Int]_prog.in_union_in_one|)))
(assert (forall ((s1 Set<Int>) (s2 Set<Int>) (e Int)) (!
  (implies (Set_in e s1) (Set_in e (Set_union s1 s2)))
  :pattern ((Set_in e s1) (Set_union s1 s2))
  :qid |$Set[Int]_prog.in_left_in_union|)))
(assert (forall ((s1 Set<Int>) (s2 Set<Int>) (e Int)) (!
  (implies (Set_in e s2) (Set_in e (Set_union s1 s2)))
  :pattern ((Set_in e s2) (Set_union s1 s2))
  :qid |$Set[Int]_prog.in_right_in_union|)))
(assert (forall ((s1 Set<Int>) (s2 Set<Int>) (e Int)) (!
  (= (Set_in e (Set_intersection s1 s2)) (and (Set_in e s1) (Set_in e s2)))
  :pattern ((Set_in e (Set_intersection s1 s2)))
  :pattern ((Set_intersection s1 s2) (Set_in e s1))
  :pattern ((Set_intersection s1 s2) (Set_in e s2))
  :qid |$Set[Int]_prog.in_intersection_in_both|)))
(assert (forall ((s1 Set<Int>) (s2 Set<Int>)) (!
  (= (Set_union s1 (Set_union s1 s2)) (Set_union s1 s2))
  :pattern ((Set_union s1 (Set_union s1 s2)))
  :qid |$Set[Int]_prog.union_left_idempotency|)))
(assert (forall ((s1 Set<Int>) (s2 Set<Int>)) (!
  (= (Set_union (Set_union s1 s2) s2) (Set_union s1 s2))
  :pattern ((Set_union (Set_union s1 s2) s2))
  :qid |$Set[Int]_prog.union_right_idempotency|)))
(assert (forall ((s1 Set<Int>) (s2 Set<Int>)) (!
  (= (Set_intersection s1 (Set_intersection s1 s2)) (Set_intersection s1 s2))
  :pattern ((Set_intersection s1 (Set_intersection s1 s2)))
  :qid |$Set[Int]_prog.intersection_left_idempotency|)))
(assert (forall ((s1 Set<Int>) (s2 Set<Int>)) (!
  (= (Set_intersection (Set_intersection s1 s2) s2) (Set_intersection s1 s2))
  :pattern ((Set_intersection (Set_intersection s1 s2) s2))
  :qid |$Set[Int]_prog.intersection_right_idempotency|)))
(assert (forall ((s1 Set<Int>) (s2 Set<Int>)) (!
  (=
    (+ (Set_card (Set_union s1 s2)) (Set_card (Set_intersection s1 s2)))
    (+ (Set_card s1) (Set_card s2)))
  :pattern ((Set_card (Set_union s1 s2)))
  :pattern ((Set_card (Set_intersection s1 s2)))
  :qid |$Set[Int]_prog.cardinality_sums|)))
(assert (forall ((s1 Set<Int>) (s2 Set<Int>) (e Int)) (!
  (= (Set_in e (Set_difference s1 s2)) (and (Set_in e s1) (not (Set_in e s2))))
  :pattern ((Set_in e (Set_difference s1 s2)))
  :qid |$Set[Int]_prog.in_difference|)))
(assert (forall ((s1 Set<Int>) (s2 Set<Int>) (e Int)) (!
  (implies (Set_in e s2) (not (Set_in e (Set_difference s1 s2))))
  :pattern ((Set_difference s1 s2) (Set_in e s2))
  :qid |$Set[Int]_prog.not_in_difference|)))
(assert (forall ((s1 Set<Int>) (s2 Set<Int>)) (!
  (=
    (Set_subset s1 s2)
    (forall ((e Int)) (!
      (implies (Set_in e s1) (Set_in e s2))
      :pattern ((Set_in e s1))
      :pattern ((Set_in e s2))
      )))
  :pattern ((Set_subset s1 s2))
  :qid |$Set[Int]_prog.subset_definition|)))
(assert (forall ((s1 Set<Int>) (s2 Set<Int>)) (!
  (=
    (Set_equal s1 s2)
    (forall ((e Int)) (!
      (= (Set_in e s1) (Set_in e s2))
      :pattern ((Set_in e s1))
      :pattern ((Set_in e s2))
      )))
  :pattern ((Set_equal s1 s2))
  :qid |$Set[Int]_prog.equality_definition|)))
(assert (forall ((s1 Set<Int>) (s2 Set<Int>)) (!
  (implies (Set_equal s1 s2) (= s1 s2))
  :pattern ((Set_equal s1 s2))
  :qid |$Set[Int]_prog.native_equality|)))
(assert (forall ((s1 Set<Int>) (s2 Set<Int>)) (!
  (=
    (Set_disjoint s1 s2)
    (forall ((e Int)) (!
      (or (not (Set_in e s1)) (not (Set_in e s2)))
      :pattern ((Set_in e s1))
      :pattern ((Set_in e s2))
      )))
  :pattern ((Set_disjoint s1 s2))
  :qid |$Set[Int]_prog.disjointness_definition|)))
(assert (forall ((s1 Set<Int>) (s2 Set<Int>)) (!
  (and
    (=
      (+
        (+ (Set_card (Set_difference s1 s2)) (Set_card (Set_difference s2 s1)))
        (Set_card (Set_intersection s1 s2)))
      (Set_card (Set_union s1 s2)))
    (=
      (Set_card (Set_difference s1 s2))
      (- (Set_card s1) (Set_card (Set_intersection s1 s2)))))
  :pattern ((Set_card (Set_difference s1 s2)))
  :qid |$Set[Int]_prog.cardinality_difference|)))
(assert (forall ((s Set<Bool>)) (!
  (<= 0 (Set_card s))
  :pattern ((Set_card s))
  :qid |$Set[Bool]_prog.card_non_negative|)))
(assert (forall ((e Bool)) (!
  (not (Set_in e (as Set_empty  Set<Bool>)))
  :pattern ((Set_in e (as Set_empty  Set<Bool>)))
  :qid |$Set[Bool]_prog.in_empty_set|)))
(assert (forall ((s Set<Bool>)) (!
  (and
    (= (= (Set_card s) 0) (= s (as Set_empty  Set<Bool>)))
    (implies
      (not (= (Set_card s) 0))
      (exists ((e Bool)) (!
        (Set_in e s)
        :pattern ((Set_in e s))
        ))))
  :pattern ((Set_card s))
  :qid |$Set[Bool]_prog.empty_set_cardinality|)))
(assert (forall ((e Bool)) (!
  (Set_in e (Set_singleton e))
  :pattern ((Set_singleton e))
  :qid |$Set[Bool]_prog.in_singleton_set|)))
(assert (forall ((e1 Bool) (e2 Bool)) (!
  (= (Set_in e1 (Set_singleton e2)) (= e1 e2))
  :pattern ((Set_in e1 (Set_singleton e2)))
  :qid |$Set[Bool]_prog.in_singleton_set_equality|)))
(assert (forall ((e Bool)) (!
  (= (Set_card (Set_singleton e)) 1)
  :pattern ((Set_card (Set_singleton e)))
  :qid |$Set[Bool]_prog.singleton_set_cardinality|)))
(assert (forall ((s Set<Bool>) (e Bool)) (!
  (Set_in e (Set_unionone s e))
  :pattern ((Set_unionone s e))
  :qid |$Set[Bool]_prog.in_unionone_same|)))
(assert (forall ((s Set<Bool>) (e1 Bool) (e2 Bool)) (!
  (= (Set_in e1 (Set_unionone s e2)) (or (= e1 e2) (Set_in e1 s)))
  :pattern ((Set_in e1 (Set_unionone s e2)))
  :qid |$Set[Bool]_prog.in_unionone_other|)))
(assert (forall ((s Set<Bool>) (e1 Bool) (e2 Bool)) (!
  (implies (Set_in e1 s) (Set_in e1 (Set_unionone s e2)))
  :pattern ((Set_in e1 s) (Set_unionone s e2))
  :qid |$Set[Bool]_prog.invariance_in_unionone|)))
(assert (forall ((s Set<Bool>) (e Bool)) (!
  (implies (Set_in e s) (= (Set_card (Set_unionone s e)) (Set_card s)))
  :pattern ((Set_card (Set_unionone s e)))
  :qid |$Set[Bool]_prog.unionone_cardinality_invariant|)))
(assert (forall ((s Set<Bool>) (e Bool)) (!
  (implies
    (not (Set_in e s))
    (= (Set_card (Set_unionone s e)) (+ (Set_card s) 1)))
  :pattern ((Set_card (Set_unionone s e)))
  :qid |$Set[Bool]_prog.unionone_cardinality_changed|)))
(assert (forall ((s1 Set<Bool>) (s2 Set<Bool>) (e Bool)) (!
  (= (Set_in e (Set_union s1 s2)) (or (Set_in e s1) (Set_in e s2)))
  :pattern ((Set_in e (Set_union s1 s2)))
  :qid |$Set[Bool]_prog.in_union_in_one|)))
(assert (forall ((s1 Set<Bool>) (s2 Set<Bool>) (e Bool)) (!
  (implies (Set_in e s1) (Set_in e (Set_union s1 s2)))
  :pattern ((Set_in e s1) (Set_union s1 s2))
  :qid |$Set[Bool]_prog.in_left_in_union|)))
(assert (forall ((s1 Set<Bool>) (s2 Set<Bool>) (e Bool)) (!
  (implies (Set_in e s2) (Set_in e (Set_union s1 s2)))
  :pattern ((Set_in e s2) (Set_union s1 s2))
  :qid |$Set[Bool]_prog.in_right_in_union|)))
(assert (forall ((s1 Set<Bool>) (s2 Set<Bool>) (e Bool)) (!
  (= (Set_in e (Set_intersection s1 s2)) (and (Set_in e s1) (Set_in e s2)))
  :pattern ((Set_in e (Set_intersection s1 s2)))
  :pattern ((Set_intersection s1 s2) (Set_in e s1))
  :pattern ((Set_intersection s1 s2) (Set_in e s2))
  :qid |$Set[Bool]_prog.in_intersection_in_both|)))
(assert (forall ((s1 Set<Bool>) (s2 Set<Bool>)) (!
  (= (Set_union s1 (Set_union s1 s2)) (Set_union s1 s2))
  :pattern ((Set_union s1 (Set_union s1 s2)))
  :qid |$Set[Bool]_prog.union_left_idempotency|)))
(assert (forall ((s1 Set<Bool>) (s2 Set<Bool>)) (!
  (= (Set_union (Set_union s1 s2) s2) (Set_union s1 s2))
  :pattern ((Set_union (Set_union s1 s2) s2))
  :qid |$Set[Bool]_prog.union_right_idempotency|)))
(assert (forall ((s1 Set<Bool>) (s2 Set<Bool>)) (!
  (= (Set_intersection s1 (Set_intersection s1 s2)) (Set_intersection s1 s2))
  :pattern ((Set_intersection s1 (Set_intersection s1 s2)))
  :qid |$Set[Bool]_prog.intersection_left_idempotency|)))
(assert (forall ((s1 Set<Bool>) (s2 Set<Bool>)) (!
  (= (Set_intersection (Set_intersection s1 s2) s2) (Set_intersection s1 s2))
  :pattern ((Set_intersection (Set_intersection s1 s2) s2))
  :qid |$Set[Bool]_prog.intersection_right_idempotency|)))
(assert (forall ((s1 Set<Bool>) (s2 Set<Bool>)) (!
  (=
    (+ (Set_card (Set_union s1 s2)) (Set_card (Set_intersection s1 s2)))
    (+ (Set_card s1) (Set_card s2)))
  :pattern ((Set_card (Set_union s1 s2)))
  :pattern ((Set_card (Set_intersection s1 s2)))
  :qid |$Set[Bool]_prog.cardinality_sums|)))
(assert (forall ((s1 Set<Bool>) (s2 Set<Bool>) (e Bool)) (!
  (= (Set_in e (Set_difference s1 s2)) (and (Set_in e s1) (not (Set_in e s2))))
  :pattern ((Set_in e (Set_difference s1 s2)))
  :qid |$Set[Bool]_prog.in_difference|)))
(assert (forall ((s1 Set<Bool>) (s2 Set<Bool>) (e Bool)) (!
  (implies (Set_in e s2) (not (Set_in e (Set_difference s1 s2))))
  :pattern ((Set_difference s1 s2) (Set_in e s2))
  :qid |$Set[Bool]_prog.not_in_difference|)))
(assert (forall ((s1 Set<Bool>) (s2 Set<Bool>)) (!
  (=
    (Set_subset s1 s2)
    (forall ((e Bool)) (!
      (implies (Set_in e s1) (Set_in e s2))
      :pattern ((Set_in e s1))
      :pattern ((Set_in e s2))
      )))
  :pattern ((Set_subset s1 s2))
  :qid |$Set[Bool]_prog.subset_definition|)))
(assert (forall ((s1 Set<Bool>) (s2 Set<Bool>)) (!
  (=
    (Set_equal s1 s2)
    (forall ((e Bool)) (!
      (= (Set_in e s1) (Set_in e s2))
      :pattern ((Set_in e s1))
      :pattern ((Set_in e s2))
      )))
  :pattern ((Set_equal s1 s2))
  :qid |$Set[Bool]_prog.equality_definition|)))
(assert (forall ((s1 Set<Bool>) (s2 Set<Bool>)) (!
  (implies (Set_equal s1 s2) (= s1 s2))
  :pattern ((Set_equal s1 s2))
  :qid |$Set[Bool]_prog.native_equality|)))
(assert (forall ((s1 Set<Bool>) (s2 Set<Bool>)) (!
  (=
    (Set_disjoint s1 s2)
    (forall ((e Bool)) (!
      (or (not (Set_in e s1)) (not (Set_in e s2)))
      :pattern ((Set_in e s1))
      :pattern ((Set_in e s2))
      )))
  :pattern ((Set_disjoint s1 s2))
  :qid |$Set[Bool]_prog.disjointness_definition|)))
(assert (forall ((s1 Set<Bool>) (s2 Set<Bool>)) (!
  (and
    (=
      (+
        (+ (Set_card (Set_difference s1 s2)) (Set_card (Set_difference s2 s1)))
        (Set_card (Set_intersection s1 s2)))
      (Set_card (Set_union s1 s2)))
    (=
      (Set_card (Set_difference s1 s2))
      (- (Set_card s1) (Set_card (Set_intersection s1 s2)))))
  :pattern ((Set_card (Set_difference s1 s2)))
  :qid |$Set[Bool]_prog.cardinality_difference|)))
(assert (forall ((s Set<$Ref>)) (!
  (<= 0 (Set_card s))
  :pattern ((Set_card s))
  :qid |$Set[Ref]_prog.card_non_negative|)))
(assert (forall ((e $Ref)) (!
  (not (Set_in e (as Set_empty  Set<$Ref>)))
  :pattern ((Set_in e (as Set_empty  Set<$Ref>)))
  :qid |$Set[Ref]_prog.in_empty_set|)))
(assert (forall ((s Set<$Ref>)) (!
  (and
    (= (= (Set_card s) 0) (= s (as Set_empty  Set<$Ref>)))
    (implies
      (not (= (Set_card s) 0))
      (exists ((e $Ref)) (!
        (Set_in e s)
        :pattern ((Set_in e s))
        ))))
  :pattern ((Set_card s))
  :qid |$Set[Ref]_prog.empty_set_cardinality|)))
(assert (forall ((e $Ref)) (!
  (Set_in e (Set_singleton e))
  :pattern ((Set_singleton e))
  :qid |$Set[Ref]_prog.in_singleton_set|)))
(assert (forall ((e1 $Ref) (e2 $Ref)) (!
  (= (Set_in e1 (Set_singleton e2)) (= e1 e2))
  :pattern ((Set_in e1 (Set_singleton e2)))
  :qid |$Set[Ref]_prog.in_singleton_set_equality|)))
(assert (forall ((e $Ref)) (!
  (= (Set_card (Set_singleton e)) 1)
  :pattern ((Set_card (Set_singleton e)))
  :qid |$Set[Ref]_prog.singleton_set_cardinality|)))
(assert (forall ((s Set<$Ref>) (e $Ref)) (!
  (Set_in e (Set_unionone s e))
  :pattern ((Set_unionone s e))
  :qid |$Set[Ref]_prog.in_unionone_same|)))
(assert (forall ((s Set<$Ref>) (e1 $Ref) (e2 $Ref)) (!
  (= (Set_in e1 (Set_unionone s e2)) (or (= e1 e2) (Set_in e1 s)))
  :pattern ((Set_in e1 (Set_unionone s e2)))
  :qid |$Set[Ref]_prog.in_unionone_other|)))
(assert (forall ((s Set<$Ref>) (e1 $Ref) (e2 $Ref)) (!
  (implies (Set_in e1 s) (Set_in e1 (Set_unionone s e2)))
  :pattern ((Set_in e1 s) (Set_unionone s e2))
  :qid |$Set[Ref]_prog.invariance_in_unionone|)))
(assert (forall ((s Set<$Ref>) (e $Ref)) (!
  (implies (Set_in e s) (= (Set_card (Set_unionone s e)) (Set_card s)))
  :pattern ((Set_card (Set_unionone s e)))
  :qid |$Set[Ref]_prog.unionone_cardinality_invariant|)))
(assert (forall ((s Set<$Ref>) (e $Ref)) (!
  (implies
    (not (Set_in e s))
    (= (Set_card (Set_unionone s e)) (+ (Set_card s) 1)))
  :pattern ((Set_card (Set_unionone s e)))
  :qid |$Set[Ref]_prog.unionone_cardinality_changed|)))
(assert (forall ((s1 Set<$Ref>) (s2 Set<$Ref>) (e $Ref)) (!
  (= (Set_in e (Set_union s1 s2)) (or (Set_in e s1) (Set_in e s2)))
  :pattern ((Set_in e (Set_union s1 s2)))
  :qid |$Set[Ref]_prog.in_union_in_one|)))
(assert (forall ((s1 Set<$Ref>) (s2 Set<$Ref>) (e $Ref)) (!
  (implies (Set_in e s1) (Set_in e (Set_union s1 s2)))
  :pattern ((Set_in e s1) (Set_union s1 s2))
  :qid |$Set[Ref]_prog.in_left_in_union|)))
(assert (forall ((s1 Set<$Ref>) (s2 Set<$Ref>) (e $Ref)) (!
  (implies (Set_in e s2) (Set_in e (Set_union s1 s2)))
  :pattern ((Set_in e s2) (Set_union s1 s2))
  :qid |$Set[Ref]_prog.in_right_in_union|)))
(assert (forall ((s1 Set<$Ref>) (s2 Set<$Ref>) (e $Ref)) (!
  (= (Set_in e (Set_intersection s1 s2)) (and (Set_in e s1) (Set_in e s2)))
  :pattern ((Set_in e (Set_intersection s1 s2)))
  :pattern ((Set_intersection s1 s2) (Set_in e s1))
  :pattern ((Set_intersection s1 s2) (Set_in e s2))
  :qid |$Set[Ref]_prog.in_intersection_in_both|)))
(assert (forall ((s1 Set<$Ref>) (s2 Set<$Ref>)) (!
  (= (Set_union s1 (Set_union s1 s2)) (Set_union s1 s2))
  :pattern ((Set_union s1 (Set_union s1 s2)))
  :qid |$Set[Ref]_prog.union_left_idempotency|)))
(assert (forall ((s1 Set<$Ref>) (s2 Set<$Ref>)) (!
  (= (Set_union (Set_union s1 s2) s2) (Set_union s1 s2))
  :pattern ((Set_union (Set_union s1 s2) s2))
  :qid |$Set[Ref]_prog.union_right_idempotency|)))
(assert (forall ((s1 Set<$Ref>) (s2 Set<$Ref>)) (!
  (= (Set_intersection s1 (Set_intersection s1 s2)) (Set_intersection s1 s2))
  :pattern ((Set_intersection s1 (Set_intersection s1 s2)))
  :qid |$Set[Ref]_prog.intersection_left_idempotency|)))
(assert (forall ((s1 Set<$Ref>) (s2 Set<$Ref>)) (!
  (= (Set_intersection (Set_intersection s1 s2) s2) (Set_intersection s1 s2))
  :pattern ((Set_intersection (Set_intersection s1 s2) s2))
  :qid |$Set[Ref]_prog.intersection_right_idempotency|)))
(assert (forall ((s1 Set<$Ref>) (s2 Set<$Ref>)) (!
  (=
    (+ (Set_card (Set_union s1 s2)) (Set_card (Set_intersection s1 s2)))
    (+ (Set_card s1) (Set_card s2)))
  :pattern ((Set_card (Set_union s1 s2)))
  :pattern ((Set_card (Set_intersection s1 s2)))
  :qid |$Set[Ref]_prog.cardinality_sums|)))
(assert (forall ((s1 Set<$Ref>) (s2 Set<$Ref>) (e $Ref)) (!
  (= (Set_in e (Set_difference s1 s2)) (and (Set_in e s1) (not (Set_in e s2))))
  :pattern ((Set_in e (Set_difference s1 s2)))
  :qid |$Set[Ref]_prog.in_difference|)))
(assert (forall ((s1 Set<$Ref>) (s2 Set<$Ref>) (e $Ref)) (!
  (implies (Set_in e s2) (not (Set_in e (Set_difference s1 s2))))
  :pattern ((Set_difference s1 s2) (Set_in e s2))
  :qid |$Set[Ref]_prog.not_in_difference|)))
(assert (forall ((s1 Set<$Ref>) (s2 Set<$Ref>)) (!
  (=
    (Set_subset s1 s2)
    (forall ((e $Ref)) (!
      (implies (Set_in e s1) (Set_in e s2))
      :pattern ((Set_in e s1))
      :pattern ((Set_in e s2))
      )))
  :pattern ((Set_subset s1 s2))
  :qid |$Set[Ref]_prog.subset_definition|)))
(assert (forall ((s1 Set<$Ref>) (s2 Set<$Ref>)) (!
  (=
    (Set_equal s1 s2)
    (forall ((e $Ref)) (!
      (= (Set_in e s1) (Set_in e s2))
      :pattern ((Set_in e s1))
      :pattern ((Set_in e s2))
      )))
  :pattern ((Set_equal s1 s2))
  :qid |$Set[Ref]_prog.equality_definition|)))
(assert (forall ((s1 Set<$Ref>) (s2 Set<$Ref>)) (!
  (implies (Set_equal s1 s2) (= s1 s2))
  :pattern ((Set_equal s1 s2))
  :qid |$Set[Ref]_prog.native_equality|)))
(assert (forall ((s1 Set<$Ref>) (s2 Set<$Ref>)) (!
  (=
    (Set_disjoint s1 s2)
    (forall ((e $Ref)) (!
      (or (not (Set_in e s1)) (not (Set_in e s2)))
      :pattern ((Set_in e s1))
      :pattern ((Set_in e s2))
      )))
  :pattern ((Set_disjoint s1 s2))
  :qid |$Set[Ref]_prog.disjointness_definition|)))
(assert (forall ((s1 Set<$Ref>) (s2 Set<$Ref>)) (!
  (and
    (=
      (+
        (+ (Set_card (Set_difference s1 s2)) (Set_card (Set_difference s2 s1)))
        (Set_card (Set_intersection s1 s2)))
      (Set_card (Set_union s1 s2)))
    (=
      (Set_card (Set_difference s1 s2))
      (- (Set_card s1) (Set_card (Set_intersection s1 s2)))))
  :pattern ((Set_card (Set_difference s1 s2)))
  :qid |$Set[Ref]_prog.cardinality_difference|)))
(assert (forall ((s Set<$Snap>)) (!
  (<= 0 (Set_card s))
  :pattern ((Set_card s))
  :qid |$Set[Snap]_prog.card_non_negative|)))
(assert (forall ((e $Snap)) (!
  (not (Set_in e (as Set_empty  Set<$Snap>)))
  :pattern ((Set_in e (as Set_empty  Set<$Snap>)))
  :qid |$Set[Snap]_prog.in_empty_set|)))
(assert (forall ((s Set<$Snap>)) (!
  (and
    (= (= (Set_card s) 0) (= s (as Set_empty  Set<$Snap>)))
    (implies
      (not (= (Set_card s) 0))
      (exists ((e $Snap)) (!
        (Set_in e s)
        :pattern ((Set_in e s))
        ))))
  :pattern ((Set_card s))
  :qid |$Set[Snap]_prog.empty_set_cardinality|)))
(assert (forall ((e $Snap)) (!
  (Set_in e (Set_singleton e))
  :pattern ((Set_singleton e))
  :qid |$Set[Snap]_prog.in_singleton_set|)))
(assert (forall ((e1 $Snap) (e2 $Snap)) (!
  (= (Set_in e1 (Set_singleton e2)) (= e1 e2))
  :pattern ((Set_in e1 (Set_singleton e2)))
  :qid |$Set[Snap]_prog.in_singleton_set_equality|)))
(assert (forall ((e $Snap)) (!
  (= (Set_card (Set_singleton e)) 1)
  :pattern ((Set_card (Set_singleton e)))
  :qid |$Set[Snap]_prog.singleton_set_cardinality|)))
(assert (forall ((s Set<$Snap>) (e $Snap)) (!
  (Set_in e (Set_unionone s e))
  :pattern ((Set_unionone s e))
  :qid |$Set[Snap]_prog.in_unionone_same|)))
(assert (forall ((s Set<$Snap>) (e1 $Snap) (e2 $Snap)) (!
  (= (Set_in e1 (Set_unionone s e2)) (or (= e1 e2) (Set_in e1 s)))
  :pattern ((Set_in e1 (Set_unionone s e2)))
  :qid |$Set[Snap]_prog.in_unionone_other|)))
(assert (forall ((s Set<$Snap>) (e1 $Snap) (e2 $Snap)) (!
  (implies (Set_in e1 s) (Set_in e1 (Set_unionone s e2)))
  :pattern ((Set_in e1 s) (Set_unionone s e2))
  :qid |$Set[Snap]_prog.invariance_in_unionone|)))
(assert (forall ((s Set<$Snap>) (e $Snap)) (!
  (implies (Set_in e s) (= (Set_card (Set_unionone s e)) (Set_card s)))
  :pattern ((Set_card (Set_unionone s e)))
  :qid |$Set[Snap]_prog.unionone_cardinality_invariant|)))
(assert (forall ((s Set<$Snap>) (e $Snap)) (!
  (implies
    (not (Set_in e s))
    (= (Set_card (Set_unionone s e)) (+ (Set_card s) 1)))
  :pattern ((Set_card (Set_unionone s e)))
  :qid |$Set[Snap]_prog.unionone_cardinality_changed|)))
(assert (forall ((s1 Set<$Snap>) (s2 Set<$Snap>) (e $Snap)) (!
  (= (Set_in e (Set_union s1 s2)) (or (Set_in e s1) (Set_in e s2)))
  :pattern ((Set_in e (Set_union s1 s2)))
  :qid |$Set[Snap]_prog.in_union_in_one|)))
(assert (forall ((s1 Set<$Snap>) (s2 Set<$Snap>) (e $Snap)) (!
  (implies (Set_in e s1) (Set_in e (Set_union s1 s2)))
  :pattern ((Set_in e s1) (Set_union s1 s2))
  :qid |$Set[Snap]_prog.in_left_in_union|)))
(assert (forall ((s1 Set<$Snap>) (s2 Set<$Snap>) (e $Snap)) (!
  (implies (Set_in e s2) (Set_in e (Set_union s1 s2)))
  :pattern ((Set_in e s2) (Set_union s1 s2))
  :qid |$Set[Snap]_prog.in_right_in_union|)))
(assert (forall ((s1 Set<$Snap>) (s2 Set<$Snap>) (e $Snap)) (!
  (= (Set_in e (Set_intersection s1 s2)) (and (Set_in e s1) (Set_in e s2)))
  :pattern ((Set_in e (Set_intersection s1 s2)))
  :pattern ((Set_intersection s1 s2) (Set_in e s1))
  :pattern ((Set_intersection s1 s2) (Set_in e s2))
  :qid |$Set[Snap]_prog.in_intersection_in_both|)))
(assert (forall ((s1 Set<$Snap>) (s2 Set<$Snap>)) (!
  (= (Set_union s1 (Set_union s1 s2)) (Set_union s1 s2))
  :pattern ((Set_union s1 (Set_union s1 s2)))
  :qid |$Set[Snap]_prog.union_left_idempotency|)))
(assert (forall ((s1 Set<$Snap>) (s2 Set<$Snap>)) (!
  (= (Set_union (Set_union s1 s2) s2) (Set_union s1 s2))
  :pattern ((Set_union (Set_union s1 s2) s2))
  :qid |$Set[Snap]_prog.union_right_idempotency|)))
(assert (forall ((s1 Set<$Snap>) (s2 Set<$Snap>)) (!
  (= (Set_intersection s1 (Set_intersection s1 s2)) (Set_intersection s1 s2))
  :pattern ((Set_intersection s1 (Set_intersection s1 s2)))
  :qid |$Set[Snap]_prog.intersection_left_idempotency|)))
(assert (forall ((s1 Set<$Snap>) (s2 Set<$Snap>)) (!
  (= (Set_intersection (Set_intersection s1 s2) s2) (Set_intersection s1 s2))
  :pattern ((Set_intersection (Set_intersection s1 s2) s2))
  :qid |$Set[Snap]_prog.intersection_right_idempotency|)))
(assert (forall ((s1 Set<$Snap>) (s2 Set<$Snap>)) (!
  (=
    (+ (Set_card (Set_union s1 s2)) (Set_card (Set_intersection s1 s2)))
    (+ (Set_card s1) (Set_card s2)))
  :pattern ((Set_card (Set_union s1 s2)))
  :pattern ((Set_card (Set_intersection s1 s2)))
  :qid |$Set[Snap]_prog.cardinality_sums|)))
(assert (forall ((s1 Set<$Snap>) (s2 Set<$Snap>) (e $Snap)) (!
  (= (Set_in e (Set_difference s1 s2)) (and (Set_in e s1) (not (Set_in e s2))))
  :pattern ((Set_in e (Set_difference s1 s2)))
  :qid |$Set[Snap]_prog.in_difference|)))
(assert (forall ((s1 Set<$Snap>) (s2 Set<$Snap>) (e $Snap)) (!
  (implies (Set_in e s2) (not (Set_in e (Set_difference s1 s2))))
  :pattern ((Set_difference s1 s2) (Set_in e s2))
  :qid |$Set[Snap]_prog.not_in_difference|)))
(assert (forall ((s1 Set<$Snap>) (s2 Set<$Snap>)) (!
  (=
    (Set_subset s1 s2)
    (forall ((e $Snap)) (!
      (implies (Set_in e s1) (Set_in e s2))
      :pattern ((Set_in e s1))
      :pattern ((Set_in e s2))
      )))
  :pattern ((Set_subset s1 s2))
  :qid |$Set[Snap]_prog.subset_definition|)))
(assert (forall ((s1 Set<$Snap>) (s2 Set<$Snap>)) (!
  (=
    (Set_equal s1 s2)
    (forall ((e $Snap)) (!
      (= (Set_in e s1) (Set_in e s2))
      :pattern ((Set_in e s1))
      :pattern ((Set_in e s2))
      )))
  :pattern ((Set_equal s1 s2))
  :qid |$Set[Snap]_prog.equality_definition|)))
(assert (forall ((s1 Set<$Snap>) (s2 Set<$Snap>)) (!
  (implies (Set_equal s1 s2) (= s1 s2))
  :pattern ((Set_equal s1 s2))
  :qid |$Set[Snap]_prog.native_equality|)))
(assert (forall ((s1 Set<$Snap>) (s2 Set<$Snap>)) (!
  (=
    (Set_disjoint s1 s2)
    (forall ((e $Snap)) (!
      (or (not (Set_in e s1)) (not (Set_in e s2)))
      :pattern ((Set_in e s1))
      :pattern ((Set_in e s2))
      )))
  :pattern ((Set_disjoint s1 s2))
  :qid |$Set[Snap]_prog.disjointness_definition|)))
(assert (forall ((s1 Set<$Snap>) (s2 Set<$Snap>)) (!
  (and
    (=
      (+
        (+ (Set_card (Set_difference s1 s2)) (Set_card (Set_difference s2 s1)))
        (Set_card (Set_intersection s1 s2)))
      (Set_card (Set_union s1 s2)))
    (=
      (Set_card (Set_difference s1 s2))
      (- (Set_card s1) (Set_card (Set_intersection s1 s2)))))
  :pattern ((Set_card (Set_difference s1 s2)))
  :qid |$Set[Snap]_prog.cardinality_difference|)))
(assert (forall ((a2 array)) (!
  (forall ((i1 Int)) (!
    (and
      (= (loc_inv_1<array> (array_loc<Ref> a2 i1)) a2)
      (= (loc_inv_2<Int> (array_loc<Ref> a2 i1)) i1))
    :pattern ((loc_inv_1<array> (array_loc<Ref> a2 i1)))
    :pattern ((loc_inv_2<Int> (array_loc<Ref> a2 i1)))
    ))
  
  )))
(assert (forall ((a2 array)) (!
  (>= (alen<Int> a2) 0)
  :pattern ((alen<Int> a2))
  )))
(assert (forall ((x1 array)) (!
  (not (= (as None<option<array>>  option<array>) (some<option<array>> x1)))
  :pattern ((some<option<array>> x1))
  )))
(assert (forall ((x1 array)) (!
  (= (option_get<array> (some<option<array>> x1)) x1)
  :pattern ((option_get<array> (some<option<array>> x1)))
  )))
(assert (forall ((opt1 option<array>)) (!
  (= (some<option<array>> (option_get<array> opt1)) opt1)
  :pattern ((some<option<array>> (option_get<array> opt1)))
  )))
(assert (forall ((v t_null)) (!
  (= (as v_null<t_null>  t_null) v)
  
  )))
(assert (forall ((x1 any)) (!
  (not (= (as None<option<any>>  option<any>) (some<option<any>> x1)))
  :pattern ((some<option<any>> x1))
  )))
(assert (forall ((x1 any)) (!
  (= (option_get<any> (some<option<any>> x1)) x1)
  :pattern ((option_get<any> (some<option<any>> x1)))
  )))
(assert (forall ((opt1 option<any>)) (!
  (= (some<option<any>> (option_get<any> opt1)) opt1)
  :pattern ((some<option<any>> (option_get<any> opt1)))
  )))
(assert (forall ((v void)) (!
  (= (as unit<void>  void) v)
  
  )))
; /field_value_functions_axioms.smt2 [int: Int]
(assert (forall ((vs $FVF<Int>) (ws $FVF<Int>)) (!
    (implies
      (and
        (Set_equal ($FVF.domain_int vs) ($FVF.domain_int ws))
        (forall ((x $Ref)) (!
          (implies
            (Set_in x ($FVF.domain_int vs))
            (= ($FVF.lookup_int vs x) ($FVF.lookup_int ws x)))
          :pattern (($FVF.lookup_int vs x) ($FVF.lookup_int ws x))
          :qid |qp.$FVF<Int>-eq-inner|
          )))
      (= vs ws))
    :pattern (($SortWrappers.$FVF<Int>To$Snap vs)
              ($SortWrappers.$FVF<Int>To$Snap ws)
              )
    :qid |qp.$FVF<Int>-eq-outer|
    )))
(assert (forall ((r $Ref) (pm $FPM)) (!
    ($Perm.isValidVar ($FVF.perm_int pm r))
    :pattern ($FVF.perm_int pm r))))
(assert (forall ((r $Ref) (f Int)) (!
    (= ($FVF.loc_int f r) true)
    :pattern ($FVF.loc_int f r))))
; /field_value_functions_axioms.smt2 [option$array$: option[array]]
(assert (forall ((vs $FVF<option<array>>) (ws $FVF<option<array>>)) (!
    (implies
      (and
        (Set_equal ($FVF.domain_option$array$ vs) ($FVF.domain_option$array$ ws))
        (forall ((x $Ref)) (!
          (implies
            (Set_in x ($FVF.domain_option$array$ vs))
            (= ($FVF.lookup_option$array$ vs x) ($FVF.lookup_option$array$ ws x)))
          :pattern (($FVF.lookup_option$array$ vs x) ($FVF.lookup_option$array$ ws x))
          :qid |qp.$FVF<option<array>>-eq-inner|
          )))
      (= vs ws))
    :pattern (($SortWrappers.$FVF<option<array>>To$Snap vs)
              ($SortWrappers.$FVF<option<array>>To$Snap ws)
              )
    :qid |qp.$FVF<option<array>>-eq-outer|
    )))
(assert (forall ((r $Ref) (pm $FPM)) (!
    ($Perm.isValidVar ($FVF.perm_option$array$ pm r))
    :pattern ($FVF.perm_option$array$ pm r))))
(assert (forall ((r $Ref) (f option<array>)) (!
    (= ($FVF.loc_option$array$ f r) true)
    :pattern ($FVF.loc_option$array$ f r))))
; /field_value_functions_axioms.smt2 [bool: Bool]
(assert (forall ((vs $FVF<Bool>) (ws $FVF<Bool>)) (!
    (implies
      (and
        (Set_equal ($FVF.domain_bool vs) ($FVF.domain_bool ws))
        (forall ((x $Ref)) (!
          (implies
            (Set_in x ($FVF.domain_bool vs))
            (= ($FVF.lookup_bool vs x) ($FVF.lookup_bool ws x)))
          :pattern (($FVF.lookup_bool vs x) ($FVF.lookup_bool ws x))
          :qid |qp.$FVF<Bool>-eq-inner|
          )))
      (= vs ws))
    :pattern (($SortWrappers.$FVF<Bool>To$Snap vs)
              ($SortWrappers.$FVF<Bool>To$Snap ws)
              )
    :qid |qp.$FVF<Bool>-eq-outer|
    )))
(assert (forall ((r $Ref) (pm $FPM)) (!
    ($Perm.isValidVar ($FVF.perm_bool pm r))
    :pattern ($FVF.perm_bool pm r))))
(assert (forall ((r $Ref) (f Bool)) (!
    (= ($FVF.loc_bool f r) true)
    :pattern ($FVF.loc_bool f r))))
; /field_value_functions_axioms.smt2 [Gf_seq: Seq[Seq[Int]]]
(assert (forall ((vs $FVF<Seq<Seq<Int>>>) (ws $FVF<Seq<Seq<Int>>>)) (!
    (implies
      (and
        (Set_equal ($FVF.domain_Gf_seq vs) ($FVF.domain_Gf_seq ws))
        (forall ((x $Ref)) (!
          (implies
            (Set_in x ($FVF.domain_Gf_seq vs))
            (= ($FVF.lookup_Gf_seq vs x) ($FVF.lookup_Gf_seq ws x)))
          :pattern (($FVF.lookup_Gf_seq vs x) ($FVF.lookup_Gf_seq ws x))
          :qid |qp.$FVF<Seq<Seq<Int>>>-eq-inner|
          )))
      (= vs ws))
    :pattern (($SortWrappers.$FVF<Seq<Seq<Int>>>To$Snap vs)
              ($SortWrappers.$FVF<Seq<Seq<Int>>>To$Snap ws)
              )
    :qid |qp.$FVF<Seq<Seq<Int>>>-eq-outer|
    )))
(assert (forall ((r $Ref) (pm $FPM)) (!
    ($Perm.isValidVar ($FVF.perm_Gf_seq pm r))
    :pattern ($FVF.perm_Gf_seq pm r))))
(assert (forall ((r $Ref) (f Seq<Seq<Int>>)) (!
    (= ($FVF.loc_Gf_seq f r) true)
    :pattern ($FVF.loc_Gf_seq f r))))
; /field_value_functions_axioms.smt2 [P_seq: Seq[Int]]
(assert (forall ((vs $FVF<Seq<Int>>) (ws $FVF<Seq<Int>>)) (!
    (implies
      (and
        (Set_equal ($FVF.domain_P_seq vs) ($FVF.domain_P_seq ws))
        (forall ((x $Ref)) (!
          (implies
            (Set_in x ($FVF.domain_P_seq vs))
            (= ($FVF.lookup_P_seq vs x) ($FVF.lookup_P_seq ws x)))
          :pattern (($FVF.lookup_P_seq vs x) ($FVF.lookup_P_seq ws x))
          :qid |qp.$FVF<Seq<Int>>-eq-inner|
          )))
      (= vs ws))
    :pattern (($SortWrappers.$FVF<Seq<Int>>To$Snap vs)
              ($SortWrappers.$FVF<Seq<Int>>To$Snap ws)
              )
    :qid |qp.$FVF<Seq<Int>>-eq-outer|
    )))
(assert (forall ((r $Ref) (pm $FPM)) (!
    ($Perm.isValidVar ($FVF.perm_P_seq pm r))
    :pattern ($FVF.perm_P_seq pm r))))
(assert (forall ((r $Ref) (f Seq<Int>)) (!
    (= ($FVF.loc_P_seq f r) true)
    :pattern ($FVF.loc_P_seq f r))))
; End preamble
; ------------------------------------------------------------
; State saturation: after preamble
(set-option :timeout 100)
(check-sat)
; unknown
; ------------------------------------------------------------
; Begin function- and predicate-related preamble
; Declaring symbols related to program functions (from verification)
(declare-fun $k@113@00 () $Perm)
(declare-fun inv@114@00 ($Snap $Ref option<array> Int $Ref) Int)
(declare-fun sm@115@00 ($Snap $Ref option<array> Int) $FVF<Int>)
(assert (forall ((s@$ $Snap) (this@0@00 $Ref) (p@1@00 Seq<Int>) (V@2@00 Int)) (!
  (=
    (valid_graph_vertices1%limited s@$ this@0@00 p@1@00 V@2@00)
    (valid_graph_vertices1 s@$ this@0@00 p@1@00 V@2@00))
  :pattern ((valid_graph_vertices1 s@$ this@0@00 p@1@00 V@2@00))
  )))
(assert (forall ((s@$ $Snap) (this@0@00 $Ref) (p@1@00 Seq<Int>) (V@2@00 Int)) (!
  (valid_graph_vertices1%stateless this@0@00 p@1@00 V@2@00)
  :pattern ((valid_graph_vertices1%limited s@$ this@0@00 p@1@00 V@2@00))
  )))
(assert (forall ((s@$ $Snap) (this@0@00 $Ref) (p@1@00 Seq<Int>) (V@2@00 Int)) (!
  (implies
    (not (= this@0@00 $Ref.null))
    (=
      (valid_graph_vertices1 s@$ this@0@00 p@1@00 V@2@00)
      (and
        (forall ((unknown_ Int)) (!
          (implies
            (and (<= 0 unknown_) (< unknown_ (Seq_length p@1@00)))
            (<= 0 (Seq_index p@1@00 unknown_)))
          :pattern ((Seq_index p@1@00 unknown_))
          ))
        (forall ((unknown_ Int)) (!
          (implies
            (and (<= 0 unknown_) (< unknown_ (Seq_length p@1@00)))
            (< (Seq_index p@1@00 unknown_) V@2@00))
          :pattern ((Seq_index p@1@00 unknown_))
          )))))
  :pattern ((valid_graph_vertices1 s@$ this@0@00 p@1@00 V@2@00))
  )))
(assert (forall ((s@$ $Snap) (this@4@00 $Ref) (G@5@00 Seq<Seq<Int>>) (V@6@00 Int)) (!
  (=
    (SquareIntMatrix%limited s@$ this@4@00 G@5@00 V@6@00)
    (SquareIntMatrix s@$ this@4@00 G@5@00 V@6@00))
  :pattern ((SquareIntMatrix s@$ this@4@00 G@5@00 V@6@00))
  )))
(assert (forall ((s@$ $Snap) (this@4@00 $Ref) (G@5@00 Seq<Seq<Int>>) (V@6@00 Int)) (!
  (SquareIntMatrix%stateless this@4@00 G@5@00 V@6@00)
  :pattern ((SquareIntMatrix%limited s@$ this@4@00 G@5@00 V@6@00))
  )))
(assert (forall ((s@$ $Snap) (this@4@00 $Ref) (G@5@00 Seq<Seq<Int>>) (V@6@00 Int)) (!
  (implies
    (not (= this@4@00 $Ref.null))
    (=
      (SquareIntMatrix s@$ this@4@00 G@5@00 V@6@00)
      (and
        (= (Seq_length G@5@00) V@6@00)
        (forall ((e Seq<Int>)) (!
          (implies (Seq_contains G@5@00 e) (= (Seq_length e) V@6@00))
          :pattern ((Seq_contains G@5@00 e))
          :pattern ((Seq_length e))
          )))))
  :pattern ((SquareIntMatrix s@$ this@4@00 G@5@00 V@6@00))
  )))
(assert (forall ((s@$ $Snap) (this@8@00 $Ref) (G@9@00 Seq<Seq<Int>>) (n@10@00 Int) (v@11@00 Int)) (!
  (=
    (SumOutgoingFlow%limited s@$ this@8@00 G@9@00 n@10@00 v@11@00)
    (SumOutgoingFlow s@$ this@8@00 G@9@00 n@10@00 v@11@00))
  :pattern ((SumOutgoingFlow s@$ this@8@00 G@9@00 n@10@00 v@11@00))
  )))
(assert (forall ((s@$ $Snap) (this@8@00 $Ref) (G@9@00 Seq<Seq<Int>>) (n@10@00 Int) (v@11@00 Int)) (!
  (SumOutgoingFlow%stateless this@8@00 G@9@00 n@10@00 v@11@00)
  :pattern ((SumOutgoingFlow%limited s@$ this@8@00 G@9@00 n@10@00 v@11@00))
  )))
(assert (forall ((s@$ $Snap) (this@13@00 $Ref) (G@14@00 Seq<Seq<Int>>) (n@15@00 Int) (v@16@00 Int)) (!
  (=
    (SumIncomingFlow%limited s@$ this@13@00 G@14@00 n@15@00 v@16@00)
    (SumIncomingFlow s@$ this@13@00 G@14@00 n@15@00 v@16@00))
  :pattern ((SumIncomingFlow s@$ this@13@00 G@14@00 n@15@00 v@16@00))
  )))
(assert (forall ((s@$ $Snap) (this@13@00 $Ref) (G@14@00 Seq<Seq<Int>>) (n@15@00 Int) (v@16@00 Int)) (!
  (SumIncomingFlow%stateless this@13@00 G@14@00 n@15@00 v@16@00)
  :pattern ((SumIncomingFlow%limited s@$ this@13@00 G@14@00 n@15@00 v@16@00))
  )))
(assert (forall ((s@$ $Snap) (this@18@00 $Ref) (G@19@00 Seq<Seq<Int>>) (V@20@00 Int) (s@21@00 Int) (t@22@00 Int) (P@23@00 Seq<Int>)) (!
  (=
    (AugPath%limited s@$ this@18@00 G@19@00 V@20@00 s@21@00 t@22@00 P@23@00)
    (AugPath s@$ this@18@00 G@19@00 V@20@00 s@21@00 t@22@00 P@23@00))
  :pattern ((AugPath s@$ this@18@00 G@19@00 V@20@00 s@21@00 t@22@00 P@23@00))
  )))
(assert (forall ((s@$ $Snap) (this@18@00 $Ref) (G@19@00 Seq<Seq<Int>>) (V@20@00 Int) (s@21@00 Int) (t@22@00 Int) (P@23@00 Seq<Int>)) (!
  (AugPath%stateless this@18@00 G@19@00 V@20@00 s@21@00 t@22@00 P@23@00)
  :pattern ((AugPath%limited s@$ this@18@00 G@19@00 V@20@00 s@21@00 t@22@00 P@23@00))
  )))
(assert (forall ((s@$ $Snap) (this@18@00 $Ref) (G@19@00 Seq<Seq<Int>>) (V@20@00 Int) (s@21@00 Int) (t@22@00 Int) (P@23@00 Seq<Int>)) (!
  (implies
    (and
      (not (= this@18@00 $Ref.null))
      (SquareIntMatrix $Snap.unit this@18@00 G@19@00 V@20@00))
    (=
      (AugPath s@$ this@18@00 G@19@00 V@20@00 s@21@00 t@22@00 P@23@00)
      (and
        (and
          (and
            (implies
              (and
                (and
                  (and (and (<= 0 s@21@00) (< s@21@00 V@20@00)) (<= 0 t@22@00))
                  (< t@22@00 V@20@00))
                (< 1 (Seq_length P@23@00)))
              (not
                (=
                  (Seq_index P@23@00 0)
                  (Seq_index P@23@00 (- (Seq_length P@23@00) 1)))))
            (implies
              (and
                (and
                  (and (and (<= 0 s@21@00) (< s@21@00 V@20@00)) (<= 0 t@22@00))
                  (< t@22@00 V@20@00))
                (< 1 (Seq_length P@23@00)))
              (valid_graph_vertices1 $Snap.unit this@18@00 P@23@00 V@20@00)))
          (and
            (implies
              (and
                (and
                  (and (and (<= 0 s@21@00) (< s@21@00 V@20@00)) (<= 0 t@22@00))
                  (< t@22@00 V@20@00))
                (< 1 (Seq_length P@23@00)))
              (forall ((unknown_ Int)) (!
                (implies
                  (and (<= 0 unknown_) (< unknown_ (Seq_length P@23@00)))
                  (<= 0 (Seq_index P@23@00 unknown_)))
                :pattern ((Seq_index P@23@00 unknown_))
                )))
            (implies
              (and
                (and
                  (and (and (<= 0 s@21@00) (< s@21@00 V@20@00)) (<= 0 t@22@00))
                  (< t@22@00 V@20@00))
                (< 1 (Seq_length P@23@00)))
              (forall ((unknown_ Int)) (!
                (implies
                  (and (<= 0 unknown_) (< unknown_ (Seq_length P@23@00)))
                  (< (Seq_index P@23@00 unknown_) V@20@00))
                :pattern ((Seq_index P@23@00 unknown_))
                )))))
        (implies
          (and
            (and
              (and (and (<= 0 s@21@00) (< s@21@00 V@20@00)) (<= 0 t@22@00))
              (< t@22@00 V@20@00))
            (< 1 (Seq_length P@23@00)))
          (forall ((j Int)) (!
            (implies
              (and (<= 0 j) (< j (- (Seq_length P@23@00) 1)))
              (<
                0
                (Seq_index
                  (Seq_index G@19@00 (Seq_index P@23@00 j))
                  (Seq_index P@23@00 (+ j 1)))))
            :pattern ((Seq_index G@19@00 (Seq_index P@23@00 j)))
            ))))))
  :pattern ((AugPath s@$ this@18@00 G@19@00 V@20@00 s@21@00 t@22@00 P@23@00))
  )))
(assert (forall ((s@$ $Snap) (a2@25@00 array) (i1@26@00 Int)) (!
  (= (aloc%limited s@$ a2@25@00 i1@26@00) (aloc s@$ a2@25@00 i1@26@00))
  :pattern ((aloc s@$ a2@25@00 i1@26@00))
  )))
(assert (forall ((s@$ $Snap) (a2@25@00 array) (i1@26@00 Int)) (!
  (aloc%stateless a2@25@00 i1@26@00)
  :pattern ((aloc%limited s@$ a2@25@00 i1@26@00))
  )))
(assert (forall ((s@$ $Snap) (a2@25@00 array) (i1@26@00 Int)) (!
  (let ((result@27@00 (aloc%limited s@$ a2@25@00 i1@26@00))) (implies
    (and (<= 0 i1@26@00) (< i1@26@00 (alen<Int> a2@25@00)))
    (and
      (= (loc_inv_1<array> result@27@00) a2@25@00)
      (= (loc_inv_2<Int> result@27@00) i1@26@00))))
  :pattern ((aloc%limited s@$ a2@25@00 i1@26@00))
  )))
(assert (forall ((s@$ $Snap) (a2@25@00 array) (i1@26@00 Int)) (!
  (implies
    (and (<= 0 i1@26@00) (< i1@26@00 (alen<Int> a2@25@00)))
    (= (aloc s@$ a2@25@00 i1@26@00) (array_loc<Ref> a2@25@00 i1@26@00)))
  :pattern ((aloc s@$ a2@25@00 i1@26@00))
  )))
(assert (forall ((s@$ $Snap) (opt1@28@00 option<array>)) (!
  (= (opt_get1%limited s@$ opt1@28@00) (opt_get1 s@$ opt1@28@00))
  :pattern ((opt_get1 s@$ opt1@28@00))
  )))
(assert (forall ((s@$ $Snap) (opt1@28@00 option<array>)) (!
  (opt_get1%stateless opt1@28@00)
  :pattern ((opt_get1%limited s@$ opt1@28@00))
  )))
(assert (forall ((s@$ $Snap) (opt1@28@00 option<array>)) (!
  (let ((result@29@00 (opt_get1%limited s@$ opt1@28@00))) (implies
    (not (= opt1@28@00 (as None<option<array>>  option<array>)))
    (= (some<option<array>> result@29@00) opt1@28@00)))
  :pattern ((opt_get1%limited s@$ opt1@28@00))
  )))
(assert (forall ((s@$ $Snap) (opt1@28@00 option<array>)) (!
  (implies
    (not (= opt1@28@00 (as None<option<array>>  option<array>)))
    (= (opt_get1 s@$ opt1@28@00) (option_get<array> opt1@28@00)))
  :pattern ((opt_get1 s@$ opt1@28@00))
  )))
(assert (forall ((s@$ $Snap) (this@30@00 $Ref) (G@31@00 Seq<Seq<Int>>) (V@32@00 Int)) (!
  (=
    (NonNegativeCapacities%limited s@$ this@30@00 G@31@00 V@32@00)
    (NonNegativeCapacities s@$ this@30@00 G@31@00 V@32@00))
  :pattern ((NonNegativeCapacities s@$ this@30@00 G@31@00 V@32@00))
  )))
(assert (forall ((s@$ $Snap) (this@30@00 $Ref) (G@31@00 Seq<Seq<Int>>) (V@32@00 Int)) (!
  (NonNegativeCapacities%stateless this@30@00 G@31@00 V@32@00)
  :pattern ((NonNegativeCapacities%limited s@$ this@30@00 G@31@00 V@32@00))
  )))
(assert (forall ((s@$ $Snap) (this@34@00 $Ref) (G@35@00 Seq<Seq<Int>>) (V@36@00 Int)) (!
  (=
    (SkewSymetry%limited s@$ this@34@00 G@35@00 V@36@00)
    (SkewSymetry s@$ this@34@00 G@35@00 V@36@00))
  :pattern ((SkewSymetry s@$ this@34@00 G@35@00 V@36@00))
  )))
(assert (forall ((s@$ $Snap) (this@34@00 $Ref) (G@35@00 Seq<Seq<Int>>) (V@36@00 Int)) (!
  (SkewSymetry%stateless this@34@00 G@35@00 V@36@00)
  :pattern ((SkewSymetry%limited s@$ this@34@00 G@35@00 V@36@00))
  )))
(assert (forall ((s@$ $Snap) (this@38@00 $Ref) (G@39@00 Seq<Seq<Int>>) (Gf@40@00 Seq<Seq<Int>>) (V@41@00 Int)) (!
  (=
    (CapacityConstraint%limited s@$ this@38@00 G@39@00 Gf@40@00 V@41@00)
    (CapacityConstraint s@$ this@38@00 G@39@00 Gf@40@00 V@41@00))
  :pattern ((CapacityConstraint s@$ this@38@00 G@39@00 Gf@40@00 V@41@00))
  )))
(assert (forall ((s@$ $Snap) (this@38@00 $Ref) (G@39@00 Seq<Seq<Int>>) (Gf@40@00 Seq<Seq<Int>>) (V@41@00 Int)) (!
  (CapacityConstraint%stateless this@38@00 G@39@00 Gf@40@00 V@41@00)
  :pattern ((CapacityConstraint%limited s@$ this@38@00 G@39@00 Gf@40@00 V@41@00))
  )))
(assert (forall ((s@$ $Snap) (this@43@00 $Ref) (G@44@00 Seq<Seq<Int>>) (V@45@00 Int) (s@46@00 Int) (t@47@00 Int)) (!
  (=
    (FlowConservation%limited s@$ this@43@00 G@44@00 V@45@00 s@46@00 t@47@00)
    (FlowConservation s@$ this@43@00 G@44@00 V@45@00 s@46@00 t@47@00))
  :pattern ((FlowConservation s@$ this@43@00 G@44@00 V@45@00 s@46@00 t@47@00))
  )))
(assert (forall ((s@$ $Snap) (this@43@00 $Ref) (G@44@00 Seq<Seq<Int>>) (V@45@00 Int) (s@46@00 Int) (t@47@00 Int)) (!
  (FlowConservation%stateless this@43@00 G@44@00 V@45@00 s@46@00 t@47@00)
  :pattern ((FlowConservation%limited s@$ this@43@00 G@44@00 V@45@00 s@46@00 t@47@00))
  )))
(assert (forall ((s@$ $Snap) (t@49@00 any)) (!
  (= (any_as%limited s@$ t@49@00) (any_as s@$ t@49@00))
  :pattern ((any_as s@$ t@49@00))
  )))
(assert (forall ((s@$ $Snap) (t@49@00 any)) (!
  (any_as%stateless t@49@00)
  :pattern ((any_as%limited s@$ t@49@00))
  )))
(assert (forall ((s@$ $Snap) (opt1@51@00 option<any>)) (!
  (= (opt_get%limited s@$ opt1@51@00) (opt_get s@$ opt1@51@00))
  :pattern ((opt_get s@$ opt1@51@00))
  )))
(assert (forall ((s@$ $Snap) (opt1@51@00 option<any>)) (!
  (opt_get%stateless opt1@51@00)
  :pattern ((opt_get%limited s@$ opt1@51@00))
  )))
(assert (forall ((s@$ $Snap) (opt1@51@00 option<any>)) (!
  (let ((result@52@00 (opt_get%limited s@$ opt1@51@00))) (implies
    (not (= opt1@51@00 (as None<option<any>>  option<any>)))
    (= (some<option<any>> result@52@00) opt1@51@00)))
  :pattern ((opt_get%limited s@$ opt1@51@00))
  )))
(assert (forall ((s@$ $Snap) (opt1@51@00 option<any>)) (!
  (implies
    (not (= opt1@51@00 (as None<option<any>>  option<any>)))
    (= (opt_get s@$ opt1@51@00) (option_get<any> opt1@51@00)))
  :pattern ((opt_get s@$ opt1@51@00))
  )))
(assert (forall ((s@$ $Snap) (this@53@00 $Ref) (G@54@00 Seq<Seq<Int>>) (V@55@00 Int) (s@56@00 Int) (t@57@00 Int)) (!
  (=
    (ExAugPath%limited s@$ this@53@00 G@54@00 V@55@00 s@56@00 t@57@00)
    (ExAugPath s@$ this@53@00 G@54@00 V@55@00 s@56@00 t@57@00))
  :pattern ((ExAugPath s@$ this@53@00 G@54@00 V@55@00 s@56@00 t@57@00))
  )))
(assert (forall ((s@$ $Snap) (this@53@00 $Ref) (G@54@00 Seq<Seq<Int>>) (V@55@00 Int) (s@56@00 Int) (t@57@00 Int)) (!
  (ExAugPath%stateless this@53@00 G@54@00 V@55@00 s@56@00 t@57@00)
  :pattern ((ExAugPath%limited s@$ this@53@00 G@54@00 V@55@00 s@56@00 t@57@00))
  )))
(assert (forall ((s@$ $Snap) (this@53@00 $Ref) (G@54@00 Seq<Seq<Int>>) (V@55@00 Int) (s@56@00 Int) (t@57@00 Int)) (!
  (implies
    (and
      (not (= this@53@00 $Ref.null))
      (SquareIntMatrix $Snap.unit this@53@00 G@54@00 V@55@00))
    (=
      (ExAugPath s@$ this@53@00 G@54@00 V@55@00 s@56@00 t@57@00)
      (exists ((P Seq<Int>)) (!
        (and
          (AugPath ($Snap.combine $Snap.unit $Snap.unit) this@53@00 G@54@00 V@55@00 s@56@00 t@57@00 P)
          (<= (Seq_length P) V@55@00))
        :pattern ((AugPath%limited ($Snap.combine $Snap.unit $Snap.unit) this@53@00 G@54@00 V@55@00 s@56@00 t@57@00 P))
        :pattern ((Seq_length P))
        ))))
  :pattern ((ExAugPath s@$ this@53@00 G@54@00 V@55@00 s@56@00 t@57@00))
  )))
(assert (forall ((s@$ $Snap) (this@59@00 $Ref) (p@60@00 Seq<Int>) (n@61@00 Int)) (!
  (Seq_equal
    (initializeSeqWithZeros%limited s@$ this@59@00 p@60@00 n@61@00)
    (initializeSeqWithZeros s@$ this@59@00 p@60@00 n@61@00))
  :pattern ((initializeSeqWithZeros s@$ this@59@00 p@60@00 n@61@00))
  )))
(assert (forall ((s@$ $Snap) (this@59@00 $Ref) (p@60@00 Seq<Int>) (n@61@00 Int)) (!
  (initializeSeqWithZeros%stateless this@59@00 p@60@00 n@61@00)
  :pattern ((initializeSeqWithZeros%limited s@$ this@59@00 p@60@00 n@61@00))
  )))
(assert (forall ((s@$ $Snap) (this@59@00 $Ref) (p@60@00 Seq<Int>) (n@61@00 Int)) (!
  (let ((result@62@00 (initializeSeqWithZeros%limited s@$ this@59@00 p@60@00 n@61@00))) (implies
    (and (not (= this@59@00 $Ref.null)) (<= n@61@00 (Seq_length p@60@00)))
    (and
      (implies
        (< n@61@00 0)
        (=
          (Seq_length
            (initializeSeqWithZeros%limited ($Snap.combine $Snap.unit $Snap.unit) this@59@00 p@60@00 n@61@00))
          0))
      (implies
        (<= 0 n@61@00)
        (=
          (Seq_length
            (initializeSeqWithZeros%limited ($Snap.combine $Snap.unit $Snap.unit) this@59@00 p@60@00 n@61@00))
          n@61@00))
      (forall ((i1 Int)) (!
        (implies (and (<= 0 i1) (< i1 n@61@00)) (= (Seq_index p@60@00 i1) 0))
        :pattern ((Seq_index p@60@00 i1))
        )))))
  :pattern ((initializeSeqWithZeros%limited s@$ this@59@00 p@60@00 n@61@00))
  )))
(assert (forall ((s@$ $Snap) (this@59@00 $Ref) (p@60@00 Seq<Int>) (n@61@00 Int)) (!
  (implies
    (and (not (= this@59@00 $Ref.null)) (<= n@61@00 (Seq_length p@60@00)))
    (Seq_equal
      (initializeSeqWithZeros s@$ this@59@00 p@60@00 n@61@00)
      (ite
        (< 0 n@61@00)
        (Seq_append
          (Seq_singleton 0)
          (initializeSeqWithZeros%limited ($Snap.combine $Snap.unit $Snap.unit) this@59@00 p@60@00 (-
            n@61@00
            1)))
        (as Seq_empty  Seq<Int>))))
  :pattern ((initializeSeqWithZeros s@$ this@59@00 p@60@00 n@61@00))
  )))
(assert (forall ((s@$ $Snap) (this@63@00 $Ref) (p@64@00 option<array>) (V@65@00 Int)) (!
  (=
    (valid_graph_vertices%limited s@$ this@63@00 p@64@00 V@65@00)
    (valid_graph_vertices s@$ this@63@00 p@64@00 V@65@00))
  :pattern ((valid_graph_vertices s@$ this@63@00 p@64@00 V@65@00))
  )))
(assert (forall ((s@$ $Snap) (this@63@00 $Ref) (p@64@00 option<array>) (V@65@00 Int)) (!
  (valid_graph_vertices%stateless this@63@00 p@64@00 V@65@00)
  :pattern ((valid_graph_vertices%limited s@$ this@63@00 p@64@00 V@65@00))
  )))
(assert (forall ((s@$ $Snap) (this@63@00 $Ref) (p@64@00 option<array>) (V@65@00 Int)) (!
  (and
    (forall ((i1@112@00 Int)) (!
      (implies
        (and (and (< i1@112@00 V@65@00) (<= 0 i1@112@00)) (< $Perm.No $k@113@00))
        (=
          (inv@114@00 s@$ this@63@00 p@64@00 V@65@00 (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit p@64@00) i1@112@00))
          i1@112@00))
      :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@64@00) i1@112@00))
      ))
    (forall ((r $Ref)) (!
      (implies
        (and
          (and
            (< (inv@114@00 s@$ this@63@00 p@64@00 V@65@00 r) V@65@00)
            (<= 0 (inv@114@00 s@$ this@63@00 p@64@00 V@65@00 r)))
          (< $Perm.No $k@113@00))
        (=
          (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@64@00) (inv@114@00 s@$ this@63@00 p@64@00 V@65@00 r))
          r))
      :pattern ((inv@114@00 s@$ this@63@00 p@64@00 V@65@00 r))
      :qid |int-fctOfInv|))
    (forall ((r $Ref)) (!
      (implies
        (ite
          (and
            (< (inv@114@00 s@$ this@63@00 p@64@00 V@65@00 r) V@65@00)
            (<= 0 (inv@114@00 s@$ this@63@00 p@64@00 V@65@00 r)))
          (< $Perm.No $k@113@00)
          false)
        (=
          ($FVF.lookup_int (sm@115@00 s@$ this@63@00 p@64@00 V@65@00) r)
          ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second s@$)))) r)))
      :pattern (($FVF.lookup_int (sm@115@00 s@$ this@63@00 p@64@00 V@65@00) r))
      :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second s@$)))) r))
      :qid |qp.fvfValDef0|))
    (forall ((r $Ref)) (!
      ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second s@$)))) r) r)
      :pattern (($FVF.lookup_int (sm@115@00 s@$ this@63@00 p@64@00 V@65@00) r))
      :qid |qp.fvfResTrgDef1|))
    ($Perm.isReadVar $k@113@00 $Perm.Write)
    (implies
      (and
        (not (= this@63@00 $Ref.null))
        (not (= p@64@00 (as None<option<array>>  option<array>)))
        (= (alen<Int> (opt_get1 $Snap.unit p@64@00)) V@65@00))
      (=
        (valid_graph_vertices s@$ this@63@00 p@64@00 V@65@00)
        (and
          (forall ((unknown_ Int)) (!
            (implies
              (and
                (<= 0 unknown_)
                (< unknown_ (alen<Int> (opt_get1 $Snap.unit p@64@00))))
              (<=
                0
                ($FVF.lookup_int (sm@115@00 s@$ this@63@00 p@64@00 V@65@00) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit p@64@00) unknown_))))
            :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@64@00) unknown_))
            ))
          (forall ((unknown_ Int)) (!
            (implies
              (and
                (<= 0 unknown_)
                (< unknown_ (alen<Int> (opt_get1 $Snap.unit p@64@00))))
              (<
                ($FVF.lookup_int (sm@115@00 s@$ this@63@00 p@64@00 V@65@00) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit p@64@00) unknown_))
                V@65@00))
            :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@64@00) unknown_))
            ))))))
  :pattern ((valid_graph_vertices s@$ this@63@00 p@64@00 V@65@00))
  )))
(assert (forall ((s@$ $Snap) (this@67@00 $Ref) (G@68@00 Seq<Seq<Int>>) (Gf@69@00 Seq<Seq<Int>>) (V@70@00 Int) (s@71@00 Int) (t@72@00 Int)) (!
  (=
    (FlowNetwork%limited s@$ this@67@00 G@68@00 Gf@69@00 V@70@00 s@71@00 t@72@00)
    (FlowNetwork s@$ this@67@00 G@68@00 Gf@69@00 V@70@00 s@71@00 t@72@00))
  :pattern ((FlowNetwork s@$ this@67@00 G@68@00 Gf@69@00 V@70@00 s@71@00 t@72@00))
  )))
(assert (forall ((s@$ $Snap) (this@67@00 $Ref) (G@68@00 Seq<Seq<Int>>) (Gf@69@00 Seq<Seq<Int>>) (V@70@00 Int) (s@71@00 Int) (t@72@00 Int)) (!
  (FlowNetwork%stateless this@67@00 G@68@00 Gf@69@00 V@70@00 s@71@00 t@72@00)
  :pattern ((FlowNetwork%limited s@$ this@67@00 G@68@00 Gf@69@00 V@70@00 s@71@00 t@72@00))
  )))
(assert (forall ((s@$ $Snap) (this@67@00 $Ref) (G@68@00 Seq<Seq<Int>>) (Gf@69@00 Seq<Seq<Int>>) (V@70@00 Int) (s@71@00 Int) (t@72@00 Int)) (!
  (let ((result@73@00 (FlowNetwork%limited s@$ this@67@00 G@68@00 Gf@69@00 V@70@00 s@71@00 t@72@00))) (implies
    (and
      (not (= this@67@00 $Ref.null))
      (= V@70@00 (Seq_length G@68@00))
      (= V@70@00 (Seq_length Gf@69@00))
      (NonNegativeCapacities ($Snap.combine $Snap.unit $Snap.unit) this@67@00 G@68@00 V@70@00))
    (NonNegativeCapacities ($Snap.combine $Snap.unit $Snap.unit) this@67@00 G@68@00 V@70@00)))
  :pattern ((FlowNetwork%limited s@$ this@67@00 G@68@00 Gf@69@00 V@70@00 s@71@00 t@72@00))
  )))
(assert (forall ((s@$ $Snap) (this@67@00 $Ref) (G@68@00 Seq<Seq<Int>>) (Gf@69@00 Seq<Seq<Int>>) (V@70@00 Int) (s@71@00 Int) (t@72@00 Int)) (!
  (implies
    (and
      (not (= this@67@00 $Ref.null))
      (= V@70@00 (Seq_length G@68@00))
      (= V@70@00 (Seq_length Gf@69@00))
      (NonNegativeCapacities ($Snap.combine $Snap.unit $Snap.unit) this@67@00 G@68@00 V@70@00))
    (=
      (FlowNetwork s@$ this@67@00 G@68@00 Gf@69@00 V@70@00 s@71@00 t@72@00)
      (and
        (and
          (SquareIntMatrix $Snap.unit this@67@00 G@68@00 V@70@00)
          (SquareIntMatrix $Snap.unit this@67@00 Gf@69@00 V@70@00))
        (NonNegativeCapacities ($Snap.combine $Snap.unit $Snap.unit) this@67@00 G@68@00 V@70@00))))
  :pattern ((FlowNetwork s@$ this@67@00 G@68@00 Gf@69@00 V@70@00 s@71@00 t@72@00))
  )))
(assert (forall ((s@$ $Snap) (amount@74@00 $Perm)) (!
  (= (scale%limited s@$ amount@74@00) (scale s@$ amount@74@00))
  :pattern ((scale s@$ amount@74@00))
  )))
(assert (forall ((s@$ $Snap) (amount@74@00 $Perm)) (!
  (scale%stateless amount@74@00)
  :pattern ((scale%limited s@$ amount@74@00))
  )))
(assert (forall ((s@$ $Snap) (amount@74@00 $Perm)) (!
  (implies (>= amount@74@00 $Perm.No) (= (scale s@$ amount@74@00) amount@74@00))
  :pattern ((scale s@$ amount@74@00))
  )))
(assert (forall ((s@$ $Snap) (this@76@00 $Ref) (G@77@00 Seq<Seq<Int>>) (Gf@78@00 Seq<Seq<Int>>) (V@79@00 Int) (s@80@00 Int) (t@81@00 Int)) (!
  (=
    (Flow%limited s@$ this@76@00 G@77@00 Gf@78@00 V@79@00 s@80@00 t@81@00)
    (Flow s@$ this@76@00 G@77@00 Gf@78@00 V@79@00 s@80@00 t@81@00))
  :pattern ((Flow s@$ this@76@00 G@77@00 Gf@78@00 V@79@00 s@80@00 t@81@00))
  )))
(assert (forall ((s@$ $Snap) (this@76@00 $Ref) (G@77@00 Seq<Seq<Int>>) (Gf@78@00 Seq<Seq<Int>>) (V@79@00 Int) (s@80@00 Int) (t@81@00 Int)) (!
  (Flow%stateless this@76@00 G@77@00 Gf@78@00 V@79@00 s@80@00 t@81@00)
  :pattern ((Flow%limited s@$ this@76@00 G@77@00 Gf@78@00 V@79@00 s@80@00 t@81@00))
  )))
(assert (forall ((s@$ $Snap) (this@76@00 $Ref) (G@77@00 Seq<Seq<Int>>) (Gf@78@00 Seq<Seq<Int>>) (V@79@00 Int) (s@80@00 Int) (t@81@00 Int)) (!
  (let ((result@82@00 (Flow%limited s@$ this@76@00 G@77@00 Gf@78@00 V@79@00 s@80@00 t@81@00))) (implies
    (and
      (not (= this@76@00 $Ref.null))
      (= V@79@00 (Seq_length G@77@00))
      (= V@79@00 (Seq_length Gf@78@00)))
    (and
      (FlowConservation ($Snap.combine $Snap.unit $Snap.unit) this@76@00 G@77@00 V@79@00 s@80@00 t@81@00)
      (CapacityConstraint ($Snap.combine
        $Snap.unit
        ($Snap.combine $Snap.unit $Snap.unit)) this@76@00 G@77@00 Gf@78@00 V@79@00))))
  :pattern ((Flow%limited s@$ this@76@00 G@77@00 Gf@78@00 V@79@00 s@80@00 t@81@00))
  )))
(assert (forall ((s@$ $Snap) (t@83@00 any)) (!
  (= (as_any%limited s@$ t@83@00) (as_any s@$ t@83@00))
  :pattern ((as_any s@$ t@83@00))
  )))
(assert (forall ((s@$ $Snap) (t@83@00 any)) (!
  (as_any%stateless t@83@00)
  :pattern ((as_any%limited s@$ t@83@00))
  )))
(assert (forall ((s@$ $Snap) (t@83@00 any)) (!
  (let ((result@84@00 (as_any%limited s@$ t@83@00))) (=
    (any_as $Snap.unit result@84@00)
    t@83@00))
  :pattern ((as_any%limited s@$ t@83@00))
  )))
(assert (forall ((s@$ $Snap) (type1@85@00 $Ref)) (!
  (= (type%limited s@$ type1@85@00) (type s@$ type1@85@00))
  :pattern ((type s@$ type1@85@00))
  )))
(assert (forall ((s@$ $Snap) (type1@85@00 $Ref)) (!
  (type%stateless type1@85@00)
  :pattern ((type%limited s@$ type1@85@00))
  )))
(assert (forall ((s@$ $Snap) (type1@85@00 $Ref)) (!
  (let ((result@86@00 (type%limited s@$ type1@85@00))) (and
    (<= 0 result@86@00)
    (< result@86@00 3)
    (implies (= type1@85@00 $Ref.null) (= result@86@00 0))
    (implies (not (= type1@85@00 $Ref.null)) (not (= result@86@00 0)))))
  :pattern ((type%limited s@$ type1@85@00))
  )))
(assert (forall ((s@$ $Snap) (opt1@87@00 option<any>) (alt@88@00 any)) (!
  (=
    (opt_or_else%limited s@$ opt1@87@00 alt@88@00)
    (opt_or_else s@$ opt1@87@00 alt@88@00))
  :pattern ((opt_or_else s@$ opt1@87@00 alt@88@00))
  )))
(assert (forall ((s@$ $Snap) (opt1@87@00 option<any>) (alt@88@00 any)) (!
  (opt_or_else%stateless opt1@87@00 alt@88@00)
  :pattern ((opt_or_else%limited s@$ opt1@87@00 alt@88@00))
  )))
(assert (forall ((s@$ $Snap) (opt1@87@00 option<any>) (alt@88@00 any)) (!
  (let ((result@89@00 (opt_or_else%limited s@$ opt1@87@00 alt@88@00))) (and
    (implies
      (= opt1@87@00 (as None<option<any>>  option<any>))
      (= result@89@00 alt@88@00))
    (implies
      (not (= opt1@87@00 (as None<option<any>>  option<any>)))
      (= result@89@00 (opt_get $Snap.unit opt1@87@00)))))
  :pattern ((opt_or_else%limited s@$ opt1@87@00 alt@88@00))
  )))
(assert (forall ((s@$ $Snap) (opt1@87@00 option<any>) (alt@88@00 any)) (!
  (=
    (opt_or_else s@$ opt1@87@00 alt@88@00)
    (ite
      (= opt1@87@00 (as None<option<any>>  option<any>))
      alt@88@00
      (opt_get $Snap.unit opt1@87@00)))
  :pattern ((opt_or_else s@$ opt1@87@00 alt@88@00))
  )))
(assert (forall ((s@$ $Snap) (subtype1@90@00 Int) (subtype2@91@00 Int)) (!
  (=
    (subtype%limited s@$ subtype1@90@00 subtype2@91@00)
    (subtype s@$ subtype1@90@00 subtype2@91@00))
  :pattern ((subtype s@$ subtype1@90@00 subtype2@91@00))
  )))
(assert (forall ((s@$ $Snap) (subtype1@90@00 Int) (subtype2@91@00 Int)) (!
  (subtype%stateless subtype1@90@00 subtype2@91@00)
  :pattern ((subtype%limited s@$ subtype1@90@00 subtype2@91@00))
  )))
(assert (forall ((s@$ $Snap) (subtype1@90@00 Int) (subtype2@91@00 Int)) (!
  (implies
    (and
      (<= 0 subtype1@90@00)
      (< subtype1@90@00 3)
      (<= 0 subtype2@91@00)
      (<= subtype2@91@00 2))
    (=
      (subtype s@$ subtype1@90@00 subtype2@91@00)
      (and
        (implies (= subtype1@90@00 2) (= subtype2@91@00 2))
        (implies (= subtype1@90@00 1) (= subtype2@91@00 1)))))
  :pattern ((subtype s@$ subtype1@90@00 subtype2@91@00))
  )))
; End function- and predicate-related preamble
; ------------------------------------------------------------
; ---------- do_par_$unknown$ ----------
(declare-const P@0@04 option<array>)
(declare-const V@1@04 Int)
(declare-const exc@2@04 $Ref)
(declare-const res@3@04 void)
(declare-const P@4@04 option<array>)
(declare-const V@5@04 Int)
(declare-const exc@6@04 $Ref)
(declare-const res@7@04 void)
(push) ; 1
(declare-const $t@8@04 $Snap)
(assert (= $t@8@04 ($Snap.combine ($Snap.first $t@8@04) ($Snap.second $t@8@04))))
(assert (= ($Snap.first $t@8@04) $Snap.unit))
; [eval] 0 < V ==> P != (None(): option[array])
; [eval] 0 < V
(push) ; 2
(set-option :timeout 10)
(push) ; 3
(assert (not (not (< 0 V@5@04))))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               10
;  :arith-assert-lower      3
;  :arith-assert-upper      2
;  :arith-eq-adapter        2
;  :datatype-accessor-ax    2
;  :datatype-constructor-ax 1
;  :datatype-occurs-check   2
;  :datatype-splits         1
;  :decisions               1
;  :final-checks            2
;  :max-generation          1
;  :max-memory              4.38
;  :memory                  4.18
;  :mk-bool-var             413
;  :num-allocs              158063
;  :num-checks              1
;  :quant-instantiations    2
;  :rlimit-count            180175)
(push) ; 3
(assert (not (< 0 V@5@04)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               12
;  :arith-assert-lower      3
;  :arith-assert-upper      3
;  :arith-eq-adapter        2
;  :datatype-accessor-ax    2
;  :datatype-constructor-ax 2
;  :datatype-occurs-check   4
;  :datatype-splits         2
;  :decisions               2
;  :final-checks            4
;  :max-generation          1
;  :max-memory              4.38
;  :memory                  4.18
;  :mk-bool-var             415
;  :num-allocs              158433
;  :num-checks              2
;  :quant-instantiations    2
;  :rlimit-count            180671)
; [then-branch: 0 | 0 < V@5@04 | live]
; [else-branch: 0 | !(0 < V@5@04) | live]
(push) ; 3
; [then-branch: 0 | 0 < V@5@04]
(assert (< 0 V@5@04))
; [eval] P != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 3
(push) ; 3
; [else-branch: 0 | !(0 < V@5@04)]
(assert (not (< 0 V@5@04)))
(pop) ; 3
(pop) ; 2
; Joined path conditions
; Joined path conditions
(assert (implies (< 0 V@5@04) (not (= P@4@04 (as None<option<array>>  option<array>)))))
(assert (=
  ($Snap.second $t@8@04)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@8@04))
    ($Snap.second ($Snap.second $t@8@04)))))
(assert (= ($Snap.first ($Snap.second $t@8@04)) $Snap.unit))
; [eval] 0 < V ==> alen(opt_get1(P)) == V
; [eval] 0 < V
(push) ; 2
(push) ; 3
(assert (not (not (< 0 V@5@04))))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               20
;  :arith-assert-lower      4
;  :arith-assert-upper      3
;  :arith-eq-adapter        2
;  :datatype-accessor-ax    3
;  :datatype-constructor-ax 3
;  :datatype-occurs-check   6
;  :datatype-splits         3
;  :decisions               3
;  :final-checks            6
;  :max-generation          1
;  :max-memory              4.38
;  :memory                  4.20
;  :mk-bool-var             420
;  :mk-clause               1
;  :num-allocs              158976
;  :num-checks              3
;  :propagations            1
;  :quant-instantiations    2
;  :rlimit-count            181437)
(push) ; 3
(assert (not (< 0 V@5@04)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               22
;  :arith-assert-lower      4
;  :arith-assert-upper      4
;  :arith-eq-adapter        2
;  :datatype-accessor-ax    3
;  :datatype-constructor-ax 4
;  :datatype-occurs-check   8
;  :datatype-splits         4
;  :decisions               4
;  :final-checks            8
;  :max-generation          1
;  :max-memory              4.38
;  :memory                  4.20
;  :mk-bool-var             421
;  :mk-clause               1
;  :num-allocs              159345
;  :num-checks              4
;  :propagations            1
;  :quant-instantiations    2
;  :rlimit-count            181937)
; [then-branch: 1 | 0 < V@5@04 | live]
; [else-branch: 1 | !(0 < V@5@04) | live]
(push) ; 3
; [then-branch: 1 | 0 < V@5@04]
(assert (< 0 V@5@04))
; [eval] alen(opt_get1(P)) == V
; [eval] alen(opt_get1(P))
; [eval] opt_get1(P)
(push) ; 4
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(set-option :timeout 0)
(push) ; 5
(assert (not (not (= P@4@04 (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               22
;  :arith-assert-lower      5
;  :arith-assert-upper      4
;  :arith-eq-adapter        2
;  :conflicts               1
;  :datatype-accessor-ax    3
;  :datatype-constructor-ax 4
;  :datatype-occurs-check   8
;  :datatype-splits         4
;  :decisions               4
;  :final-checks            8
;  :max-generation          1
;  :max-memory              4.38
;  :memory                  4.20
;  :mk-bool-var             421
;  :mk-clause               1
;  :num-allocs              159487
;  :num-checks              5
;  :propagations            2
;  :quant-instantiations    2
;  :rlimit-count            182045)
(assert (not (= P@4@04 (as None<option<array>>  option<array>))))
(pop) ; 4
; Joined path conditions
(assert (not (= P@4@04 (as None<option<array>>  option<array>))))
(pop) ; 3
(push) ; 3
; [else-branch: 1 | !(0 < V@5@04)]
(assert (not (< 0 V@5@04)))
(pop) ; 3
(pop) ; 2
; Joined path conditions
(assert (implies
  (< 0 V@5@04)
  (and (< 0 V@5@04) (not (= P@4@04 (as None<option<array>>  option<array>))))))
; Joined path conditions
(assert (implies (< 0 V@5@04) (= (alen<Int> (opt_get1 $Snap.unit P@4@04)) V@5@04)))
(declare-const i1@9@04 Int)
(push) ; 2
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 3
; [then-branch: 2 | 0 <= i1@9@04 | live]
; [else-branch: 2 | !(0 <= i1@9@04) | live]
(push) ; 4
; [then-branch: 2 | 0 <= i1@9@04]
(assert (<= 0 i1@9@04))
; [eval] i1 < V
(pop) ; 4
(push) ; 4
; [else-branch: 2 | !(0 <= i1@9@04)]
(assert (not (<= 0 i1@9@04)))
(pop) ; 4
(pop) ; 3
; Joined path conditions
; Joined path conditions
(assert (and (< i1@9@04 V@5@04) (<= 0 i1@9@04)))
; [eval] aloc(opt_get1(P), i1)
; [eval] opt_get1(P)
(push) ; 3
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 4
(assert (not (not (= P@4@04 (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               28
;  :arith-assert-lower      10
;  :arith-assert-upper      5
;  :arith-bound-prop        1
;  :arith-eq-adapter        3
;  :arith-fixed-eqs         1
;  :arith-pivots            1
;  :conflicts               2
;  :datatype-accessor-ax    3
;  :datatype-constructor-ax 4
;  :datatype-occurs-check   8
;  :datatype-splits         4
;  :decisions               4
;  :final-checks            8
;  :max-generation          2
;  :max-memory              4.38
;  :memory                  4.21
;  :mk-bool-var             433
;  :mk-clause               7
;  :num-allocs              159880
;  :num-checks              6
;  :propagations            5
;  :quant-instantiations    7
;  :rlimit-count            182564)
(assert (not (= P@4@04 (as None<option<array>>  option<array>))))
(pop) ; 3
; Joined path conditions
(assert (not (= P@4@04 (as None<option<array>>  option<array>))))
(push) ; 3
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 4
(assert (not (< i1@9@04 (alen<Int> (opt_get1 $Snap.unit P@4@04)))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               28
;  :arith-add-rows          3
;  :arith-assert-lower      10
;  :arith-assert-upper      6
;  :arith-bound-prop        1
;  :arith-conflicts         1
;  :arith-eq-adapter        3
;  :arith-fixed-eqs         1
;  :arith-pivots            3
;  :conflicts               3
;  :datatype-accessor-ax    3
;  :datatype-constructor-ax 4
;  :datatype-occurs-check   8
;  :datatype-splits         4
;  :decisions               4
;  :final-checks            8
;  :max-generation          2
;  :max-memory              4.38
;  :memory                  4.20
;  :mk-bool-var             434
;  :mk-clause               7
;  :num-allocs              160037
;  :num-checks              7
;  :propagations            5
;  :quant-instantiations    7
;  :rlimit-count            182766)
(assert (< i1@9@04 (alen<Int> (opt_get1 $Snap.unit P@4@04))))
(pop) ; 3
; Joined path conditions
(assert (< i1@9@04 (alen<Int> (opt_get1 $Snap.unit P@4@04))))
(pop) ; 2
(declare-fun inv@10@04 ($Ref) Int)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(assert (forall ((i1@9@04 Int)) (!
  (and
    (not (= P@4@04 (as None<option<array>>  option<array>)))
    (< i1@9@04 (alen<Int> (opt_get1 $Snap.unit P@4@04))))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@4@04) i1@9@04))
  :qid |int-aux|)))
; Check receiver injectivity
(push) ; 2
(assert (not (forall ((i11@9@04 Int) (i12@9@04 Int)) (!
  (implies
    (and
      (and (< i11@9@04 V@5@04) (<= 0 i11@9@04))
      (and (< i12@9@04 V@5@04) (<= 0 i12@9@04))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@4@04) i11@9@04)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@4@04) i12@9@04)))
    (= i11@9@04 i12@9@04))
  
  :qid |int-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 2
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               50
;  :arith-add-rows          9
;  :arith-assert-diseq      2
;  :arith-assert-lower      17
;  :arith-assert-upper      6
;  :arith-bound-prop        2
;  :arith-conflicts         1
;  :arith-eq-adapter        5
;  :arith-fixed-eqs         1
;  :arith-pivots            10
;  :conflicts               4
;  :datatype-accessor-ax    4
;  :datatype-constructor-ax 4
;  :datatype-occurs-check   8
;  :datatype-splits         4
;  :decisions               4
;  :del-clause              28
;  :final-checks            8
;  :max-generation          2
;  :max-memory              4.38
;  :memory                  4.23
;  :mk-bool-var             474
;  :mk-clause               34
;  :num-allocs              160767
;  :num-checks              8
;  :propagations            21
;  :quant-instantiations    24
;  :rlimit-count            184020)
; Definitional axioms for inverse functions
(assert (forall ((i1@9@04 Int)) (!
  (implies
    (and (< i1@9@04 V@5@04) (<= 0 i1@9@04))
    (=
      (inv@10@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@4@04) i1@9@04))
      i1@9@04))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@4@04) i1@9@04))
  )))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@10@04 r) V@5@04) (<= 0 (inv@10@04 r)))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@4@04) (inv@10@04 r))
      r))
  :pattern ((inv@10@04 r))
  :qid |int-fctOfInv|)))
; Permissions are non-negative
; Field permissions are at most one
; Permission implies non-null receiver
(assert (forall ((i1@9@04 Int)) (!
  (implies
    (and (< i1@9@04 V@5@04) (<= 0 i1@9@04))
    (not
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@4@04) i1@9@04)
        $Ref.null)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@4@04) i1@9@04))
  :qid |int-permImpliesNonNull|)))
(declare-const sm@11@04 $FVF<Int>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@10@04 r) V@5@04) (<= 0 (inv@10@04 r)))
    (=
      ($FVF.lookup_int (as sm@11@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second $t@8@04))) r)))
  :pattern (($FVF.lookup_int (as sm@11@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second $t@8@04))) r))
  :qid |qp.fvfValDef0|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second $t@8@04))) r) r)
  :pattern (($FVF.lookup_int (as sm@11@04  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef1|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@10@04 r) V@5@04) (<= 0 (inv@10@04 r)))
    ($FVF.loc_int ($FVF.lookup_int (as sm@11@04  $FVF<Int>) r) r))
  :pattern ((inv@10@04 r))
  )))
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
(push) ; 2
(declare-const $t@12@04 $Snap)
(assert (= $t@12@04 ($Snap.combine ($Snap.first $t@12@04) ($Snap.second $t@12@04))))
(assert (= ($Snap.first $t@12@04) $Snap.unit))
; [eval] exc == null
(assert (= exc@6@04 $Ref.null))
(assert (=
  ($Snap.second $t@12@04)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@12@04))
    ($Snap.second ($Snap.second $t@12@04)))))
(assert (= ($Snap.first ($Snap.second $t@12@04)) $Snap.unit))
; [eval] exc == null && 0 < V ==> P != (None(): option[array])
; [eval] exc == null && 0 < V
; [eval] exc == null
(push) ; 3
; [then-branch: 3 | exc@6@04 == Null | live]
; [else-branch: 3 | exc@6@04 != Null | live]
(push) ; 4
; [then-branch: 3 | exc@6@04 == Null]
; [eval] 0 < V
(pop) ; 4
(push) ; 4
; [else-branch: 3 | exc@6@04 != Null]
(assert (not (= exc@6@04 $Ref.null)))
(pop) ; 4
(pop) ; 3
; Joined path conditions
; Joined path conditions
(push) ; 3
(set-option :timeout 10)
(push) ; 4
(assert (not (not (and (< 0 V@5@04) (= exc@6@04 $Ref.null)))))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               79
;  :arith-add-rows          9
;  :arith-assert-diseq      2
;  :arith-assert-lower      20
;  :arith-assert-upper      8
;  :arith-bound-prop        2
;  :arith-conflicts         1
;  :arith-eq-adapter        6
;  :arith-fixed-eqs         2
;  :arith-pivots            12
;  :conflicts               4
;  :datatype-accessor-ax    6
;  :datatype-constructor-ax 7
;  :datatype-occurs-check   16
;  :datatype-splits         7
;  :decisions               9
;  :del-clause              29
;  :final-checks            12
;  :max-generation          2
;  :max-memory              4.38
;  :memory                  4.25
;  :mk-bool-var             496
;  :mk-clause               35
;  :num-allocs              162656
;  :num-checks              10
;  :propagations            25
;  :quant-instantiations    29
;  :rlimit-count            186981
;  :time                    0.00)
(push) ; 4
(assert (not (and (< 0 V@5@04) (= exc@6@04 $Ref.null))))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               86
;  :arith-add-rows          9
;  :arith-assert-diseq      2
;  :arith-assert-lower      20
;  :arith-assert-upper      9
;  :arith-bound-prop        2
;  :arith-conflicts         1
;  :arith-eq-adapter        6
;  :arith-fixed-eqs         2
;  :arith-pivots            12
;  :conflicts               4
;  :datatype-accessor-ax    6
;  :datatype-constructor-ax 9
;  :datatype-occurs-check   21
;  :datatype-splits         9
;  :decisions               11
;  :del-clause              29
;  :final-checks            14
;  :max-generation          2
;  :max-memory              4.38
;  :memory                  4.25
;  :mk-bool-var             498
;  :mk-clause               35
;  :num-allocs              163054
;  :num-checks              11
;  :propagations            26
;  :quant-instantiations    29
;  :rlimit-count            187515)
; [then-branch: 4 | 0 < V@5@04 && exc@6@04 == Null | live]
; [else-branch: 4 | !(0 < V@5@04 && exc@6@04 == Null) | live]
(push) ; 4
; [then-branch: 4 | 0 < V@5@04 && exc@6@04 == Null]
(assert (and (< 0 V@5@04) (= exc@6@04 $Ref.null)))
; [eval] P != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 4
(push) ; 4
; [else-branch: 4 | !(0 < V@5@04 && exc@6@04 == Null)]
(assert (not (and (< 0 V@5@04) (= exc@6@04 $Ref.null))))
(pop) ; 4
(pop) ; 3
; Joined path conditions
; Joined path conditions
(assert (implies
  (and (< 0 V@5@04) (= exc@6@04 $Ref.null))
  (not (= P@4@04 (as None<option<array>>  option<array>)))))
(assert (=
  ($Snap.second ($Snap.second $t@12@04))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second $t@12@04)))
    ($Snap.second ($Snap.second ($Snap.second $t@12@04))))))
(assert (= ($Snap.first ($Snap.second ($Snap.second $t@12@04))) $Snap.unit))
; [eval] exc == null && 0 < V ==> alen(opt_get1(P)) == V
; [eval] exc == null && 0 < V
; [eval] exc == null
(push) ; 3
; [then-branch: 5 | exc@6@04 == Null | live]
; [else-branch: 5 | exc@6@04 != Null | live]
(push) ; 4
; [then-branch: 5 | exc@6@04 == Null]
(assert (= exc@6@04 $Ref.null))
; [eval] 0 < V
(pop) ; 4
(push) ; 4
; [else-branch: 5 | exc@6@04 != Null]
(assert (not (= exc@6@04 $Ref.null)))
(pop) ; 4
(pop) ; 3
; Joined path conditions
; Joined path conditions
(push) ; 3
(push) ; 4
(assert (not (not (and (< 0 V@5@04) (= exc@6@04 $Ref.null)))))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               105
;  :arith-add-rows          9
;  :arith-assert-diseq      2
;  :arith-assert-lower      23
;  :arith-assert-upper      10
;  :arith-bound-prop        2
;  :arith-conflicts         1
;  :arith-eq-adapter        7
;  :arith-fixed-eqs         3
;  :arith-pivots            14
;  :conflicts               4
;  :datatype-accessor-ax    7
;  :datatype-constructor-ax 11
;  :datatype-occurs-check   26
;  :datatype-splits         11
;  :decisions               13
;  :del-clause              30
;  :final-checks            16
;  :max-generation          2
;  :max-memory              4.38
;  :memory                  4.26
;  :mk-bool-var             510
;  :mk-clause               36
;  :num-allocs              163685
;  :num-checks              12
;  :propagations            29
;  :quant-instantiations    34
;  :rlimit-count            188401)
(push) ; 4
(assert (not (and (< 0 V@5@04) (= exc@6@04 $Ref.null))))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               112
;  :arith-add-rows          9
;  :arith-assert-diseq      2
;  :arith-assert-lower      23
;  :arith-assert-upper      11
;  :arith-bound-prop        2
;  :arith-conflicts         1
;  :arith-eq-adapter        7
;  :arith-fixed-eqs         3
;  :arith-pivots            14
;  :conflicts               4
;  :datatype-accessor-ax    7
;  :datatype-constructor-ax 13
;  :datatype-occurs-check   31
;  :datatype-splits         13
;  :decisions               15
;  :del-clause              30
;  :final-checks            18
;  :max-generation          2
;  :max-memory              4.38
;  :memory                  4.26
;  :mk-bool-var             512
;  :mk-clause               36
;  :num-allocs              164087
;  :num-checks              13
;  :propagations            30
;  :quant-instantiations    34
;  :rlimit-count            188937)
; [then-branch: 6 | 0 < V@5@04 && exc@6@04 == Null | live]
; [else-branch: 6 | !(0 < V@5@04 && exc@6@04 == Null) | live]
(push) ; 4
; [then-branch: 6 | 0 < V@5@04 && exc@6@04 == Null]
(assert (and (< 0 V@5@04) (= exc@6@04 $Ref.null)))
; [eval] alen(opt_get1(P)) == V
; [eval] alen(opt_get1(P))
; [eval] opt_get1(P)
(push) ; 5
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(set-option :timeout 0)
(push) ; 6
(assert (not (not (= P@4@04 (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               118
;  :arith-add-rows          9
;  :arith-assert-diseq      2
;  :arith-assert-lower      26
;  :arith-assert-upper      12
;  :arith-bound-prop        2
;  :arith-conflicts         1
;  :arith-eq-adapter        8
;  :arith-fixed-eqs         4
;  :arith-pivots            15
;  :conflicts               5
;  :datatype-accessor-ax    7
;  :datatype-constructor-ax 13
;  :datatype-occurs-check   31
;  :datatype-splits         13
;  :decisions               15
;  :del-clause              30
;  :final-checks            18
;  :max-generation          2
;  :max-memory              4.38
;  :memory                  4.26
;  :mk-bool-var             520
;  :mk-clause               36
;  :num-allocs              164261
;  :num-checks              14
;  :propagations            33
;  :quant-instantiations    39
;  :rlimit-count            189143)
(assert (not (= P@4@04 (as None<option<array>>  option<array>))))
(pop) ; 5
; Joined path conditions
(assert (not (= P@4@04 (as None<option<array>>  option<array>))))
(pop) ; 4
(push) ; 4
; [else-branch: 6 | !(0 < V@5@04 && exc@6@04 == Null)]
(assert (not (and (< 0 V@5@04) (= exc@6@04 $Ref.null))))
(pop) ; 4
(pop) ; 3
; Joined path conditions
(assert (implies
  (and (< 0 V@5@04) (= exc@6@04 $Ref.null))
  (and
    (< 0 V@5@04)
    (= exc@6@04 $Ref.null)
    (not (= P@4@04 (as None<option<array>>  option<array>))))))
; Joined path conditions
(assert (implies
  (and (< 0 V@5@04) (= exc@6@04 $Ref.null))
  (= (alen<Int> (opt_get1 $Snap.unit P@4@04)) V@5@04)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second $t@12@04)))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@12@04))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@12@04)))))))
; [eval] exc == null
(set-option :timeout 10)
(push) ; 3
(assert (not (not (= exc@6@04 $Ref.null))))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               132
;  :arith-add-rows          9
;  :arith-assert-diseq      2
;  :arith-assert-lower      26
;  :arith-assert-upper      13
;  :arith-bound-prop        2
;  :arith-conflicts         1
;  :arith-eq-adapter        8
;  :arith-fixed-eqs         4
;  :arith-pivots            16
;  :conflicts               5
;  :datatype-accessor-ax    8
;  :datatype-constructor-ax 16
;  :datatype-occurs-check   36
;  :datatype-splits         16
;  :decisions               20
;  :del-clause              30
;  :final-checks            20
;  :max-generation          2
;  :max-memory              4.38
;  :memory                  4.26
;  :mk-bool-var             524
;  :mk-clause               36
;  :num-allocs              164754
;  :num-checks              15
;  :propagations            34
;  :quant-instantiations    39
;  :rlimit-count            189948)
(push) ; 3
(assert (not (= exc@6@04 $Ref.null)))
(check-sat)
; unsat
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               132
;  :arith-add-rows          9
;  :arith-assert-diseq      2
;  :arith-assert-lower      26
;  :arith-assert-upper      13
;  :arith-bound-prop        2
;  :arith-conflicts         1
;  :arith-eq-adapter        8
;  :arith-fixed-eqs         4
;  :arith-pivots            16
;  :conflicts               5
;  :datatype-accessor-ax    8
;  :datatype-constructor-ax 16
;  :datatype-occurs-check   36
;  :datatype-splits         16
;  :decisions               20
;  :del-clause              30
;  :final-checks            20
;  :max-generation          2
;  :max-memory              4.38
;  :memory                  4.26
;  :mk-bool-var             524
;  :mk-clause               36
;  :num-allocs              164770
;  :num-checks              16
;  :propagations            34
;  :quant-instantiations    39
;  :rlimit-count            189959)
; [then-branch: 7 | exc@6@04 == Null | live]
; [else-branch: 7 | exc@6@04 != Null | dead]
(push) ; 3
; [then-branch: 7 | exc@6@04 == Null]
(assert (= exc@6@04 $Ref.null))
(declare-const unknown@13@04 Int)
(push) ; 4
; [eval] 0 <= unknown && unknown < V
; [eval] 0 <= unknown
(push) ; 5
; [then-branch: 8 | 0 <= unknown@13@04 | live]
; [else-branch: 8 | !(0 <= unknown@13@04) | live]
(push) ; 6
; [then-branch: 8 | 0 <= unknown@13@04]
(assert (<= 0 unknown@13@04))
; [eval] unknown < V
(pop) ; 6
(push) ; 6
; [else-branch: 8 | !(0 <= unknown@13@04)]
(assert (not (<= 0 unknown@13@04)))
(pop) ; 6
(pop) ; 5
; Joined path conditions
; Joined path conditions
(assert (and (< unknown@13@04 V@5@04) (<= 0 unknown@13@04)))
; [eval] aloc(opt_get1(P), unknown)
; [eval] opt_get1(P)
(push) ; 5
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(set-option :timeout 0)
(push) ; 6
(assert (not (not (= P@4@04 (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               138
;  :arith-add-rows          10
;  :arith-assert-diseq      2
;  :arith-assert-lower      31
;  :arith-assert-upper      14
;  :arith-bound-prop        3
;  :arith-conflicts         1
;  :arith-eq-adapter        9
;  :arith-fixed-eqs         5
;  :arith-pivots            18
;  :conflicts               6
;  :datatype-accessor-ax    8
;  :datatype-constructor-ax 16
;  :datatype-occurs-check   36
;  :datatype-splits         16
;  :decisions               20
;  :del-clause              30
;  :final-checks            20
;  :max-generation          2
;  :max-memory              4.38
;  :memory                  4.26
;  :mk-bool-var             534
;  :mk-clause               37
;  :num-allocs              164956
;  :num-checks              17
;  :propagations            37
;  :quant-instantiations    44
;  :rlimit-count            190275)
(assert (not (= P@4@04 (as None<option<array>>  option<array>))))
(pop) ; 5
; Joined path conditions
(assert (not (= P@4@04 (as None<option<array>>  option<array>))))
(push) ; 5
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 6
(assert (not (< unknown@13@04 (alen<Int> (opt_get1 $Snap.unit P@4@04)))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               138
;  :arith-add-rows          11
;  :arith-assert-diseq      2
;  :arith-assert-lower      31
;  :arith-assert-upper      15
;  :arith-bound-prop        3
;  :arith-conflicts         2
;  :arith-eq-adapter        9
;  :arith-fixed-eqs         5
;  :arith-pivots            18
;  :conflicts               7
;  :datatype-accessor-ax    8
;  :datatype-constructor-ax 16
;  :datatype-occurs-check   36
;  :datatype-splits         16
;  :decisions               20
;  :del-clause              30
;  :final-checks            20
;  :max-generation          2
;  :max-memory              4.38
;  :memory                  4.25
;  :mk-bool-var             535
;  :mk-clause               37
;  :num-allocs              165101
;  :num-checks              18
;  :propagations            37
;  :quant-instantiations    44
;  :rlimit-count            190429)
(assert (< unknown@13@04 (alen<Int> (opt_get1 $Snap.unit P@4@04))))
(pop) ; 5
; Joined path conditions
(assert (< unknown@13@04 (alen<Int> (opt_get1 $Snap.unit P@4@04))))
(pop) ; 4
(declare-fun inv@14@04 ($Ref) Int)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(assert (forall ((unknown@13@04 Int)) (!
  (and
    (not (= P@4@04 (as None<option<array>>  option<array>)))
    (< unknown@13@04 (alen<Int> (opt_get1 $Snap.unit P@4@04))))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@4@04) unknown@13@04))
  :qid |int-aux|)))
; Check receiver injectivity
(push) ; 4
(assert (not (forall ((unknown1@13@04 Int) (unknown2@13@04 Int)) (!
  (implies
    (and
      (and (< unknown1@13@04 V@5@04) (<= 0 unknown1@13@04))
      (and (< unknown2@13@04 V@5@04) (<= 0 unknown2@13@04))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@4@04) unknown1@13@04)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@4@04) unknown2@13@04)))
    (= unknown1@13@04 unknown2@13@04))
  
  :qid |int-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               150
;  :arith-add-rows          11
;  :arith-assert-diseq      3
;  :arith-assert-lower      33
;  :arith-assert-upper      17
;  :arith-bound-prop        4
;  :arith-conflicts         2
;  :arith-eq-adapter        10
;  :arith-fixed-eqs         5
;  :arith-pivots            20
;  :conflicts               8
;  :datatype-accessor-ax    8
;  :datatype-constructor-ax 16
;  :datatype-occurs-check   36
;  :datatype-splits         16
;  :decisions               20
;  :del-clause              45
;  :final-checks            20
;  :max-generation          2
;  :max-memory              4.38
;  :memory                  4.27
;  :mk-bool-var             558
;  :mk-clause               51
;  :num-allocs              165603
;  :num-checks              19
;  :propagations            45
;  :quant-instantiations    57
;  :rlimit-count            191416)
; Definitional axioms for inverse functions
(assert (forall ((unknown@13@04 Int)) (!
  (implies
    (and (< unknown@13@04 V@5@04) (<= 0 unknown@13@04))
    (=
      (inv@14@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@4@04) unknown@13@04))
      unknown@13@04))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@4@04) unknown@13@04))
  )))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@14@04 r) V@5@04) (<= 0 (inv@14@04 r)))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@4@04) (inv@14@04 r))
      r))
  :pattern ((inv@14@04 r))
  :qid |int-fctOfInv|)))
; Permissions are non-negative
; Field permissions are at most one
; Permission implies non-null receiver
(assert (forall ((unknown@13@04 Int)) (!
  (implies
    (and (< unknown@13@04 V@5@04) (<= 0 unknown@13@04))
    (not
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@4@04) unknown@13@04)
        $Ref.null)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@4@04) unknown@13@04))
  :qid |int-permImpliesNonNull|)))
(declare-const sm@15@04 $FVF<Int>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@14@04 r) V@5@04) (<= 0 (inv@14@04 r)))
    (=
      ($FVF.lookup_int (as sm@15@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@12@04))))) r)))
  :pattern (($FVF.lookup_int (as sm@15@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@12@04))))) r))
  :qid |qp.fvfValDef2|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@12@04))))) r) r)
  :pattern (($FVF.lookup_int (as sm@15@04  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef3|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@14@04 r) V@5@04) (<= 0 (inv@14@04 r)))
    ($FVF.loc_int ($FVF.lookup_int (as sm@15@04  $FVF<Int>) r) r))
  :pattern ((inv@14@04 r))
  )))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@12@04))))
  $Snap.unit))
; [eval] exc == null ==> (forall unknown: Int :: { aloc(opt_get1(P), unknown) } 0 <= unknown && unknown < V ==> aloc(opt_get1(P), unknown).int == 0)
; [eval] exc == null
(push) ; 4
(set-option :timeout 10)
(push) ; 5
(assert (not (not (= exc@6@04 $Ref.null))))
(check-sat)
; unknown
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               159
;  :arith-add-rows          11
;  :arith-assert-diseq      3
;  :arith-assert-lower      33
;  :arith-assert-upper      18
;  :arith-bound-prop        4
;  :arith-conflicts         2
;  :arith-eq-adapter        10
;  :arith-fixed-eqs         5
;  :arith-pivots            20
;  :conflicts               8
;  :datatype-accessor-ax    8
;  :datatype-constructor-ax 18
;  :datatype-occurs-check   41
;  :datatype-splits         18
;  :decisions               24
;  :del-clause              45
;  :final-checks            22
;  :max-generation          2
;  :max-memory              4.38
;  :memory                  4.27
;  :mk-bool-var             567
;  :mk-clause               51
;  :num-allocs              166888
;  :num-checks              20
;  :propagations            46
;  :quant-instantiations    57
;  :rlimit-count            193608)
; [then-branch: 9 | exc@6@04 == Null | live]
; [else-branch: 9 | exc@6@04 != Null | dead]
(push) ; 5
; [then-branch: 9 | exc@6@04 == Null]
; [eval] (forall unknown: Int :: { aloc(opt_get1(P), unknown) } 0 <= unknown && unknown < V ==> aloc(opt_get1(P), unknown).int == 0)
(declare-const unknown@16@04 Int)
(push) ; 6
; [eval] 0 <= unknown && unknown < V ==> aloc(opt_get1(P), unknown).int == 0
; [eval] 0 <= unknown && unknown < V
; [eval] 0 <= unknown
(push) ; 7
; [then-branch: 10 | 0 <= unknown@16@04 | live]
; [else-branch: 10 | !(0 <= unknown@16@04) | live]
(push) ; 8
; [then-branch: 10 | 0 <= unknown@16@04]
(assert (<= 0 unknown@16@04))
; [eval] unknown < V
(pop) ; 8
(push) ; 8
; [else-branch: 10 | !(0 <= unknown@16@04)]
(assert (not (<= 0 unknown@16@04)))
(pop) ; 8
(pop) ; 7
; Joined path conditions
; Joined path conditions
(push) ; 7
; [then-branch: 11 | unknown@16@04 < V@5@04 && 0 <= unknown@16@04 | live]
; [else-branch: 11 | !(unknown@16@04 < V@5@04 && 0 <= unknown@16@04) | live]
(push) ; 8
; [then-branch: 11 | unknown@16@04 < V@5@04 && 0 <= unknown@16@04]
(assert (and (< unknown@16@04 V@5@04) (<= 0 unknown@16@04)))
; [eval] aloc(opt_get1(P), unknown).int == 0
; [eval] aloc(opt_get1(P), unknown)
; [eval] opt_get1(P)
(push) ; 9
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(set-option :timeout 0)
(push) ; 10
(assert (not (not (= P@4@04 (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               165
;  :arith-add-rows          12
;  :arith-assert-diseq      3
;  :arith-assert-lower      37
;  :arith-assert-upper      20
;  :arith-bound-prop        5
;  :arith-conflicts         2
;  :arith-eq-adapter        11
;  :arith-fixed-eqs         6
;  :arith-pivots            22
;  :conflicts               9
;  :datatype-accessor-ax    8
;  :datatype-constructor-ax 18
;  :datatype-occurs-check   41
;  :datatype-splits         18
;  :decisions               24
;  :del-clause              45
;  :final-checks            22
;  :max-generation          2
;  :max-memory              4.38
;  :memory                  4.28
;  :mk-bool-var             577
;  :mk-clause               52
;  :num-allocs              167090
;  :num-checks              21
;  :propagations            49
;  :quant-instantiations    62
;  :rlimit-count            193921)
(assert (not (= P@4@04 (as None<option<array>>  option<array>))))
(pop) ; 9
; Joined path conditions
(assert (not (= P@4@04 (as None<option<array>>  option<array>))))
(push) ; 9
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 10
(assert (not (< unknown@16@04 (alen<Int> (opt_get1 $Snap.unit P@4@04)))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               165
;  :arith-add-rows          13
;  :arith-assert-diseq      3
;  :arith-assert-lower      38
;  :arith-assert-upper      20
;  :arith-bound-prop        5
;  :arith-conflicts         3
;  :arith-eq-adapter        11
;  :arith-fixed-eqs         6
;  :arith-pivots            22
;  :conflicts               10
;  :datatype-accessor-ax    8
;  :datatype-constructor-ax 18
;  :datatype-occurs-check   41
;  :datatype-splits         18
;  :decisions               24
;  :del-clause              45
;  :final-checks            22
;  :max-generation          2
;  :max-memory              4.38
;  :memory                  4.27
;  :mk-bool-var             578
;  :mk-clause               52
;  :num-allocs              167240
;  :num-checks              22
;  :propagations            49
;  :quant-instantiations    62
;  :rlimit-count            194075)
(assert (< unknown@16@04 (alen<Int> (opt_get1 $Snap.unit P@4@04))))
(pop) ; 9
; Joined path conditions
(assert (< unknown@16@04 (alen<Int> (opt_get1 $Snap.unit P@4@04))))
(assert ($FVF.loc_int ($FVF.lookup_int (as sm@15@04  $FVF<Int>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit P@4@04) unknown@16@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit P@4@04) unknown@16@04)))
(push) ; 9
(assert (not (and
  (<
    (inv@14@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@4@04) unknown@16@04))
    V@5@04)
  (<=
    0
    (inv@14@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@4@04) unknown@16@04))))))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               189
;  :arith-add-rows          18
;  :arith-assert-diseq      3
;  :arith-assert-lower      40
;  :arith-assert-upper      23
;  :arith-bound-prop        9
;  :arith-conflicts         3
;  :arith-eq-adapter        13
;  :arith-fixed-eqs         8
;  :arith-offset-eqs        5
;  :arith-pivots            24
;  :conflicts               11
;  :datatype-accessor-ax    8
;  :datatype-constructor-ax 18
;  :datatype-occurs-check   41
;  :datatype-splits         18
;  :decisions               24
;  :del-clause              45
;  :final-checks            22
;  :max-generation          3
;  :max-memory              4.38
;  :memory                  4.32
;  :mk-bool-var             618
;  :mk-clause               72
;  :num-allocs              167706
;  :num-checks              23
;  :propagations            55
;  :quant-instantiations    81
;  :rlimit-count            195094)
(pop) ; 8
(push) ; 8
; [else-branch: 11 | !(unknown@16@04 < V@5@04 && 0 <= unknown@16@04)]
(assert (not (and (< unknown@16@04 V@5@04) (<= 0 unknown@16@04))))
(pop) ; 8
(pop) ; 7
; Joined path conditions
(assert (implies
  (and (< unknown@16@04 V@5@04) (<= 0 unknown@16@04))
  (and
    (< unknown@16@04 V@5@04)
    (<= 0 unknown@16@04)
    (not (= P@4@04 (as None<option<array>>  option<array>)))
    (< unknown@16@04 (alen<Int> (opt_get1 $Snap.unit P@4@04)))
    ($FVF.loc_int ($FVF.lookup_int (as sm@15@04  $FVF<Int>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit P@4@04) unknown@16@04)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit P@4@04) unknown@16@04)))))
; Joined path conditions
(pop) ; 6
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((unknown@16@04 Int)) (!
  (implies
    (and (< unknown@16@04 V@5@04) (<= 0 unknown@16@04))
    (and
      (< unknown@16@04 V@5@04)
      (<= 0 unknown@16@04)
      (not (= P@4@04 (as None<option<array>>  option<array>)))
      (< unknown@16@04 (alen<Int> (opt_get1 $Snap.unit P@4@04)))
      ($FVF.loc_int ($FVF.lookup_int (as sm@15@04  $FVF<Int>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit P@4@04) unknown@16@04)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit P@4@04) unknown@16@04))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@4@04) unknown@16@04))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (implies
  (= exc@6@04 $Ref.null)
  (forall ((unknown@16@04 Int)) (!
    (implies
      (and (< unknown@16@04 V@5@04) (<= 0 unknown@16@04))
      (and
        (< unknown@16@04 V@5@04)
        (<= 0 unknown@16@04)
        (not (= P@4@04 (as None<option<array>>  option<array>)))
        (< unknown@16@04 (alen<Int> (opt_get1 $Snap.unit P@4@04)))
        ($FVF.loc_int ($FVF.lookup_int (as sm@15@04  $FVF<Int>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit P@4@04) unknown@16@04)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit P@4@04) unknown@16@04))))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@4@04) unknown@16@04))
    :qid |prog.l<no position>-aux|))))
(assert (implies
  (= exc@6@04 $Ref.null)
  (forall ((unknown@16@04 Int)) (!
    (implies
      (and (< unknown@16@04 V@5@04) (<= 0 unknown@16@04))
      (=
        ($FVF.lookup_int (as sm@15@04  $FVF<Int>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit P@4@04) unknown@16@04))
        0))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@4@04) unknown@16@04))
    :qid |prog.l<no position>|))))
(pop) ; 3
(pop) ; 2
(push) ; 2
; [exec]
; inhale false
(pop) ; 2
(pop) ; 1
; ---------- copy ----------
(declare-const this@17@04 $Ref)
(declare-const tid@18@04 Int)
(declare-const source@19@04 option<array>)
(declare-const target@20@04 option<array>)
(declare-const V@21@04 Int)
(declare-const exc@22@04 $Ref)
(declare-const res@23@04 void)
(declare-const this@24@04 $Ref)
(declare-const tid@25@04 Int)
(declare-const source@26@04 option<array>)
(declare-const target@27@04 option<array>)
(declare-const V@28@04 Int)
(declare-const exc@29@04 $Ref)
(declare-const res@30@04 void)
(push) ; 1
(declare-const $t@31@04 $Snap)
(assert (= $t@31@04 ($Snap.combine ($Snap.first $t@31@04) ($Snap.second $t@31@04))))
(assert (= ($Snap.first $t@31@04) $Snap.unit))
; [eval] this != null
(assert (not (= this@24@04 $Ref.null)))
(assert (=
  ($Snap.second $t@31@04)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@31@04))
    ($Snap.second ($Snap.second $t@31@04)))))
(assert (= ($Snap.first ($Snap.second $t@31@04)) $Snap.unit))
; [eval] source != (None(): option[array])
; [eval] (None(): option[array])
(assert (not (= source@26@04 (as None<option<array>>  option<array>))))
(assert (=
  ($Snap.second ($Snap.second $t@31@04))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second $t@31@04)))
    ($Snap.second ($Snap.second ($Snap.second $t@31@04))))))
(assert (= ($Snap.first ($Snap.second ($Snap.second $t@31@04))) $Snap.unit))
; [eval] alen(opt_get1(source)) == V
; [eval] alen(opt_get1(source))
; [eval] opt_get1(source)
(push) ; 2
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 2
; Joined path conditions
(assert (= (alen<Int> (opt_get1 $Snap.unit source@26@04)) V@28@04))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second $t@31@04)))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@31@04))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@31@04)))))))
(declare-const i1@32@04 Int)
(push) ; 2
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 3
; [then-branch: 12 | 0 <= i1@32@04 | live]
; [else-branch: 12 | !(0 <= i1@32@04) | live]
(push) ; 4
; [then-branch: 12 | 0 <= i1@32@04]
(assert (<= 0 i1@32@04))
; [eval] i1 < V
(pop) ; 4
(push) ; 4
; [else-branch: 12 | !(0 <= i1@32@04)]
(assert (not (<= 0 i1@32@04)))
(pop) ; 4
(pop) ; 3
; Joined path conditions
; Joined path conditions
(assert (and (< i1@32@04 V@28@04) (<= 0 i1@32@04)))
; [eval] aloc(opt_get1(source), i1)
; [eval] opt_get1(source)
(push) ; 3
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 3
; Joined path conditions
(push) ; 3
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 4
(assert (not (< i1@32@04 (alen<Int> (opt_get1 $Snap.unit source@26@04)))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               217
;  :arith-add-rows          20
;  :arith-assert-diseq      3
;  :arith-assert-lower      43
;  :arith-assert-upper      25
;  :arith-bound-prop        9
;  :arith-conflicts         3
;  :arith-eq-adapter        14
;  :arith-fixed-eqs         9
;  :arith-offset-eqs        5
;  :arith-pivots            29
;  :conflicts               11
;  :datatype-accessor-ax    13
;  :datatype-constructor-ax 18
;  :datatype-occurs-check   41
;  :datatype-splits         18
;  :decisions               24
;  :del-clause              72
;  :final-checks            22
;  :max-generation          3
;  :max-memory              4.38
;  :memory                  4.31
;  :mk-bool-var             637
;  :mk-clause               72
;  :num-allocs              168322
;  :num-checks              24
;  :propagations            55
;  :quant-instantiations    86
;  :rlimit-count            196281)
(assert (< i1@32@04 (alen<Int> (opt_get1 $Snap.unit source@26@04))))
(pop) ; 3
; Joined path conditions
(assert (< i1@32@04 (alen<Int> (opt_get1 $Snap.unit source@26@04))))
(declare-const $k@33@04 $Perm)
(assert ($Perm.isReadVar $k@33@04 $Perm.Write))
(pop) ; 2
(declare-fun inv@34@04 ($Ref) Int)
; Nested auxiliary terms: globals
(assert ($Perm.isReadVar $k@33@04 $Perm.Write))
; Nested auxiliary terms: non-globals
(assert (forall ((i1@32@04 Int)) (!
  (< i1@32@04 (alen<Int> (opt_get1 $Snap.unit source@26@04)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@32@04))
  :qid |option$array$-aux|)))
(push) ; 2
(assert (not (forall ((i1@32@04 Int)) (!
  (implies
    (and (< i1@32@04 V@28@04) (<= 0 i1@32@04))
    (or (= $k@33@04 $Perm.No) (< $Perm.No $k@33@04)))
  
  ))))
(check-sat)
; unsat
(pop) ; 2
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               219
;  :arith-add-rows          20
;  :arith-assert-diseq      4
;  :arith-assert-lower      45
;  :arith-assert-upper      26
;  :arith-bound-prop        9
;  :arith-conflicts         3
;  :arith-eq-adapter        15
;  :arith-fixed-eqs         9
;  :arith-offset-eqs        5
;  :arith-pivots            30
;  :conflicts               12
;  :datatype-accessor-ax    14
;  :datatype-constructor-ax 18
;  :datatype-occurs-check   41
;  :datatype-splits         18
;  :decisions               24
;  :del-clause              72
;  :final-checks            22
;  :max-generation          3
;  :max-memory              4.38
;  :memory                  4.31
;  :mk-bool-var             644
;  :mk-clause               74
;  :num-allocs              168801
;  :num-checks              25
;  :propagations            56
;  :quant-instantiations    86
;  :rlimit-count            196852)
; Check receiver injectivity
(push) ; 2
(assert (not (forall ((i11@32@04 Int) (i12@32@04 Int)) (!
  (implies
    (and
      (and (and (< i11@32@04 V@28@04) (<= 0 i11@32@04)) (< $Perm.No $k@33@04))
      (and (and (< i12@32@04 V@28@04) (<= 0 i12@32@04)) (< $Perm.No $k@33@04))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i11@32@04)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i12@32@04)))
    (= i11@32@04 i12@32@04))
  
  :qid |option$array$-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 2
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               230
;  :arith-add-rows          28
;  :arith-assert-diseq      6
;  :arith-assert-lower      49
;  :arith-assert-upper      29
;  :arith-bound-prop        10
;  :arith-conflicts         4
;  :arith-eq-adapter        17
;  :arith-fixed-eqs         10
;  :arith-offset-eqs        6
;  :arith-pivots            36
;  :conflicts               13
;  :datatype-accessor-ax    14
;  :datatype-constructor-ax 18
;  :datatype-occurs-check   41
;  :datatype-splits         18
;  :decisions               24
;  :del-clause              87
;  :final-checks            22
;  :max-generation          3
;  :max-memory              4.38
;  :memory                  4.31
;  :mk-bool-var             668
;  :mk-clause               89
;  :num-allocs              169154
;  :num-checks              26
;  :propagations            61
;  :quant-instantiations    96
;  :rlimit-count            197731)
; Definitional axioms for inverse functions
(assert (forall ((i1@32@04 Int)) (!
  (implies
    (and (and (< i1@32@04 V@28@04) (<= 0 i1@32@04)) (< $Perm.No $k@33@04))
    (=
      (inv@34@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@32@04))
      i1@32@04))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@32@04))
  )))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and (< (inv@34@04 r) V@28@04) (<= 0 (inv@34@04 r)))
      (< $Perm.No $k@33@04))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) (inv@34@04 r))
      r))
  :pattern ((inv@34@04 r))
  :qid |option$array$-fctOfInv|)))
; Permissions are non-negative
(assert (forall ((i1@32@04 Int)) (!
  (<= $Perm.No $k@33@04)
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@32@04))
  :qid |option$array$-permAtLeastZero|)))
; Field permissions are at most one
(assert (forall ((i1@32@04 Int)) (!
  (<= $k@33@04 $Perm.Write)
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@32@04))
  :qid |option$array$-permAtMostOne|)))
; Permission implies non-null receiver
(assert (forall ((i1@32@04 Int)) (!
  (implies
    (and (and (< i1@32@04 V@28@04) (<= 0 i1@32@04)) (< $Perm.No $k@33@04))
    (not
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@32@04)
        $Ref.null)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@32@04))
  :qid |option$array$-permImpliesNonNull|)))
(declare-const sm@35@04 $FVF<option<array>>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@34@04 r) V@28@04) (<= 0 (inv@34@04 r)))
      (< $Perm.No $k@33@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@35@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@31@04))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@35@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@31@04))))) r))
  :qid |qp.fvfValDef4|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@31@04))))) r) r)
  :pattern (($FVF.lookup_option$array$ (as sm@35@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef5|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@34@04 r) V@28@04) (<= 0 (inv@34@04 r)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@35@04  $FVF<option<array>>) r) r))
  :pattern ((inv@34@04 r))
  )))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@31@04))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@31@04)))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@31@04))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@31@04)))))
  $Snap.unit))
; [eval] (forall i1: Int :: { aloc(opt_get1(source), i1) } 0 <= i1 && i1 < V ==> aloc(opt_get1(source), i1).option$array$ != (None(): option[array]))
(declare-const i1@36@04 Int)
(push) ; 2
; [eval] 0 <= i1 && i1 < V ==> aloc(opt_get1(source), i1).option$array$ != (None(): option[array])
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 3
; [then-branch: 13 | 0 <= i1@36@04 | live]
; [else-branch: 13 | !(0 <= i1@36@04) | live]
(push) ; 4
; [then-branch: 13 | 0 <= i1@36@04]
(assert (<= 0 i1@36@04))
; [eval] i1 < V
(pop) ; 4
(push) ; 4
; [else-branch: 13 | !(0 <= i1@36@04)]
(assert (not (<= 0 i1@36@04)))
(pop) ; 4
(pop) ; 3
; Joined path conditions
; Joined path conditions
(push) ; 3
; [then-branch: 14 | i1@36@04 < V@28@04 && 0 <= i1@36@04 | live]
; [else-branch: 14 | !(i1@36@04 < V@28@04 && 0 <= i1@36@04) | live]
(push) ; 4
; [then-branch: 14 | i1@36@04 < V@28@04 && 0 <= i1@36@04]
(assert (and (< i1@36@04 V@28@04) (<= 0 i1@36@04)))
; [eval] aloc(opt_get1(source), i1).option$array$ != (None(): option[array])
; [eval] aloc(opt_get1(source), i1)
; [eval] opt_get1(source)
(push) ; 5
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 5
; Joined path conditions
(push) ; 5
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 6
(assert (not (< i1@36@04 (alen<Int> (opt_get1 $Snap.unit source@26@04)))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               237
;  :arith-add-rows          28
;  :arith-assert-diseq      6
;  :arith-assert-lower      52
;  :arith-assert-upper      31
;  :arith-bound-prop        10
;  :arith-conflicts         4
;  :arith-eq-adapter        18
;  :arith-fixed-eqs         11
;  :arith-offset-eqs        6
;  :arith-pivots            37
;  :conflicts               13
;  :datatype-accessor-ax    15
;  :datatype-constructor-ax 18
;  :datatype-occurs-check   41
;  :datatype-splits         18
;  :decisions               24
;  :del-clause              87
;  :final-checks            22
;  :max-generation          3
;  :max-memory              4.38
;  :memory                  4.32
;  :mk-bool-var             681
;  :mk-clause               89
;  :num-allocs              170379
;  :num-checks              27
;  :propagations            61
;  :quant-instantiations    96
;  :rlimit-count            200085)
(assert (< i1@36@04 (alen<Int> (opt_get1 $Snap.unit source@26@04))))
(pop) ; 5
; Joined path conditions
(assert (< i1@36@04 (alen<Int> (opt_get1 $Snap.unit source@26@04))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@35@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@36@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@36@04)))
(push) ; 5
(assert (not (ite
  (and
    (<
      (inv@34@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@36@04))
      V@28@04)
    (<=
      0
      (inv@34@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@36@04))))
  (< $Perm.No $k@33@04)
  false)))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               242
;  :arith-add-rows          33
;  :arith-assert-diseq      6
;  :arith-assert-lower      53
;  :arith-assert-upper      33
;  :arith-bound-prop        11
;  :arith-conflicts         5
;  :arith-eq-adapter        19
;  :arith-fixed-eqs         12
;  :arith-offset-eqs        6
;  :arith-pivots            39
;  :conflicts               14
;  :datatype-accessor-ax    15
;  :datatype-constructor-ax 18
;  :datatype-occurs-check   41
;  :datatype-splits         18
;  :decisions               24
;  :del-clause              87
;  :final-checks            22
;  :max-generation          3
;  :max-memory              4.38
;  :memory                  4.34
;  :mk-bool-var             699
;  :mk-clause               96
;  :num-allocs              170671
;  :num-checks              28
;  :propagations            61
;  :quant-instantiations    106
;  :rlimit-count            200755)
; [eval] (None(): option[array])
(pop) ; 4
(push) ; 4
; [else-branch: 14 | !(i1@36@04 < V@28@04 && 0 <= i1@36@04)]
(assert (not (and (< i1@36@04 V@28@04) (<= 0 i1@36@04))))
(pop) ; 4
(pop) ; 3
; Joined path conditions
(assert (implies
  (and (< i1@36@04 V@28@04) (<= 0 i1@36@04))
  (and
    (< i1@36@04 V@28@04)
    (<= 0 i1@36@04)
    (< i1@36@04 (alen<Int> (opt_get1 $Snap.unit source@26@04)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@35@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@36@04)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@36@04)))))
; Joined path conditions
(pop) ; 2
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@36@04 Int)) (!
  (implies
    (and (< i1@36@04 V@28@04) (<= 0 i1@36@04))
    (and
      (< i1@36@04 V@28@04)
      (<= 0 i1@36@04)
      (< i1@36@04 (alen<Int> (opt_get1 $Snap.unit source@26@04)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@35@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@36@04)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@36@04))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@36@04))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(assert (forall ((i1@36@04 Int)) (!
  (implies
    (and (< i1@36@04 V@28@04) (<= 0 i1@36@04))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@35@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@36@04))
        (as None<option<array>>  option<array>))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@36@04))
  :qid |prog.l<no position>|)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@31@04)))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@31@04))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@31@04)))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@31@04))))))
  $Snap.unit))
; [eval] (forall i1: Int :: { alen(opt_get1(aloc(opt_get1(source), i1).option$array$)) } 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(source), i1).option$array$)) == V)
(declare-const i1@37@04 Int)
(push) ; 2
; [eval] 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(source), i1).option$array$)) == V
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 3
; [then-branch: 15 | 0 <= i1@37@04 | live]
; [else-branch: 15 | !(0 <= i1@37@04) | live]
(push) ; 4
; [then-branch: 15 | 0 <= i1@37@04]
(assert (<= 0 i1@37@04))
; [eval] i1 < V
(pop) ; 4
(push) ; 4
; [else-branch: 15 | !(0 <= i1@37@04)]
(assert (not (<= 0 i1@37@04)))
(pop) ; 4
(pop) ; 3
; Joined path conditions
; Joined path conditions
(push) ; 3
; [then-branch: 16 | i1@37@04 < V@28@04 && 0 <= i1@37@04 | live]
; [else-branch: 16 | !(i1@37@04 < V@28@04 && 0 <= i1@37@04) | live]
(push) ; 4
; [then-branch: 16 | i1@37@04 < V@28@04 && 0 <= i1@37@04]
(assert (and (< i1@37@04 V@28@04) (<= 0 i1@37@04)))
; [eval] alen(opt_get1(aloc(opt_get1(source), i1).option$array$)) == V
; [eval] alen(opt_get1(aloc(opt_get1(source), i1).option$array$))
; [eval] opt_get1(aloc(opt_get1(source), i1).option$array$)
; [eval] aloc(opt_get1(source), i1)
; [eval] opt_get1(source)
(push) ; 5
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 5
; Joined path conditions
(push) ; 5
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 6
(assert (not (< i1@37@04 (alen<Int> (opt_get1 $Snap.unit source@26@04)))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               249
;  :arith-add-rows          36
;  :arith-assert-diseq      6
;  :arith-assert-lower      56
;  :arith-assert-upper      34
;  :arith-bound-prop        11
;  :arith-conflicts         5
;  :arith-eq-adapter        20
;  :arith-fixed-eqs         13
;  :arith-offset-eqs        6
;  :arith-pivots            44
;  :conflicts               14
;  :datatype-accessor-ax    16
;  :datatype-constructor-ax 18
;  :datatype-occurs-check   41
;  :datatype-splits         18
;  :decisions               24
;  :del-clause              94
;  :final-checks            22
;  :max-generation          3
;  :max-memory              4.38
;  :memory                  4.33
;  :mk-bool-var             707
;  :mk-clause               96
;  :num-allocs              171241
;  :num-checks              29
;  :propagations            61
;  :quant-instantiations    106
;  :rlimit-count            201936)
(assert (< i1@37@04 (alen<Int> (opt_get1 $Snap.unit source@26@04))))
(pop) ; 5
; Joined path conditions
(assert (< i1@37@04 (alen<Int> (opt_get1 $Snap.unit source@26@04))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@35@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@37@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@37@04)))
(push) ; 5
(assert (not (ite
  (and
    (<
      (inv@34@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@37@04))
      V@28@04)
    (<=
      0
      (inv@34@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@37@04))))
  (< $Perm.No $k@33@04)
  false)))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               259
;  :arith-add-rows          39
;  :arith-assert-diseq      6
;  :arith-assert-lower      57
;  :arith-assert-upper      35
;  :arith-bound-prop        14
;  :arith-conflicts         5
;  :arith-eq-adapter        21
;  :arith-fixed-eqs         14
;  :arith-offset-eqs        7
;  :arith-pivots            45
;  :conflicts               15
;  :datatype-accessor-ax    16
;  :datatype-constructor-ax 18
;  :datatype-occurs-check   41
;  :datatype-splits         18
;  :decisions               24
;  :del-clause              94
;  :final-checks            22
;  :max-generation          3
;  :max-memory              4.38
;  :memory                  4.34
;  :mk-bool-var             726
;  :mk-clause               104
;  :num-allocs              171518
;  :num-checks              30
;  :propagations            65
;  :quant-instantiations    118
;  :rlimit-count            202599)
(push) ; 5
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 6
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@35@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@37@04))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               259
;  :arith-add-rows          39
;  :arith-assert-diseq      6
;  :arith-assert-lower      57
;  :arith-assert-upper      35
;  :arith-bound-prop        14
;  :arith-conflicts         5
;  :arith-eq-adapter        21
;  :arith-fixed-eqs         14
;  :arith-offset-eqs        7
;  :arith-pivots            45
;  :conflicts               16
;  :datatype-accessor-ax    16
;  :datatype-constructor-ax 18
;  :datatype-occurs-check   41
;  :datatype-splits         18
;  :decisions               24
;  :del-clause              94
;  :final-checks            22
;  :max-generation          3
;  :max-memory              4.38
;  :memory                  4.34
;  :mk-bool-var             726
;  :mk-clause               104
;  :num-allocs              171607
;  :num-checks              31
;  :propagations            65
;  :quant-instantiations    118
;  :rlimit-count            202694)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@35@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@37@04))
    (as None<option<array>>  option<array>))))
(pop) ; 5
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@35@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@37@04))
    (as None<option<array>>  option<array>))))
(pop) ; 4
(push) ; 4
; [else-branch: 16 | !(i1@37@04 < V@28@04 && 0 <= i1@37@04)]
(assert (not (and (< i1@37@04 V@28@04) (<= 0 i1@37@04))))
(pop) ; 4
(pop) ; 3
; Joined path conditions
(assert (implies
  (and (< i1@37@04 V@28@04) (<= 0 i1@37@04))
  (and
    (< i1@37@04 V@28@04)
    (<= 0 i1@37@04)
    (< i1@37@04 (alen<Int> (opt_get1 $Snap.unit source@26@04)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@35@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@37@04)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@37@04))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@35@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@37@04))
        (as None<option<array>>  option<array>))))))
; Joined path conditions
(pop) ; 2
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@37@04 Int)) (!
  (implies
    (and (< i1@37@04 V@28@04) (<= 0 i1@37@04))
    (and
      (< i1@37@04 V@28@04)
      (<= 0 i1@37@04)
      (< i1@37@04 (alen<Int> (opt_get1 $Snap.unit source@26@04)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@35@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@37@04)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@37@04))
      (not
        (=
          ($FVF.lookup_option$array$ (as sm@35@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@37@04))
          (as None<option<array>>  option<array>)))))
  :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@35@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@37@04)))))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(assert (forall ((i1@37@04 Int)) (!
  (implies
    (and (< i1@37@04 V@28@04) (<= 0 i1@37@04))
    (=
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@35@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@37@04))))
      V@28@04))
  :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@35@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@37@04)))))
  :qid |prog.l<no position>|)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@31@04))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@31@04)))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@31@04))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@31@04)))))))
  $Snap.unit))
; [eval] (forall i1: Int :: { aloc(opt_get1(source), i1) } (forall i2: Int :: { aloc(opt_get1(source), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(source), i1).option$array$ == aloc(opt_get1(source), i2).option$array$ ==> i1 == i2))
(declare-const i1@38@04 Int)
(push) ; 2
; [eval] (forall i2: Int :: { aloc(opt_get1(source), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(source), i1).option$array$ == aloc(opt_get1(source), i2).option$array$ ==> i1 == i2)
(declare-const i2@39@04 Int)
(push) ; 3
; [eval] 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(source), i1).option$array$ == aloc(opt_get1(source), i2).option$array$ ==> i1 == i2
; [eval] 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(source), i1).option$array$ == aloc(opt_get1(source), i2).option$array$
; [eval] 0 <= i1
(push) ; 4
; [then-branch: 17 | 0 <= i1@38@04 | live]
; [else-branch: 17 | !(0 <= i1@38@04) | live]
(push) ; 5
; [then-branch: 17 | 0 <= i1@38@04]
(assert (<= 0 i1@38@04))
; [eval] i1 < V
(push) ; 6
; [then-branch: 18 | i1@38@04 < V@28@04 | live]
; [else-branch: 18 | !(i1@38@04 < V@28@04) | live]
(push) ; 7
; [then-branch: 18 | i1@38@04 < V@28@04]
(assert (< i1@38@04 V@28@04))
; [eval] 0 <= i2
(push) ; 8
; [then-branch: 19 | 0 <= i2@39@04 | live]
; [else-branch: 19 | !(0 <= i2@39@04) | live]
(push) ; 9
; [then-branch: 19 | 0 <= i2@39@04]
(assert (<= 0 i2@39@04))
; [eval] i2 < V
(push) ; 10
; [then-branch: 20 | i2@39@04 < V@28@04 | live]
; [else-branch: 20 | !(i2@39@04 < V@28@04) | live]
(push) ; 11
; [then-branch: 20 | i2@39@04 < V@28@04]
(assert (< i2@39@04 V@28@04))
; [eval] aloc(opt_get1(source), i1).option$array$ == aloc(opt_get1(source), i2).option$array$
; [eval] aloc(opt_get1(source), i1)
; [eval] opt_get1(source)
(push) ; 12
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 12
; Joined path conditions
(push) ; 12
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 13
(assert (not (< i1@38@04 (alen<Int> (opt_get1 $Snap.unit source@26@04)))))
(check-sat)
; unsat
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               266
;  :arith-add-rows          40
;  :arith-assert-diseq      6
;  :arith-assert-lower      61
;  :arith-assert-upper      37
;  :arith-bound-prop        14
;  :arith-conflicts         5
;  :arith-eq-adapter        22
;  :arith-fixed-eqs         15
;  :arith-offset-eqs        7
;  :arith-pivots            49
;  :conflicts               16
;  :datatype-accessor-ax    17
;  :datatype-constructor-ax 18
;  :datatype-occurs-check   41
;  :datatype-splits         18
;  :decisions               24
;  :del-clause              102
;  :final-checks            22
;  :max-generation          3
;  :max-memory              4.38
;  :memory                  4.35
;  :mk-bool-var             736
;  :mk-clause               104
;  :num-allocs              172440
;  :num-checks              32
;  :propagations            65
;  :quant-instantiations    118
;  :rlimit-count            204068)
(assert (< i1@38@04 (alen<Int> (opt_get1 $Snap.unit source@26@04))))
(pop) ; 12
; Joined path conditions
(assert (< i1@38@04 (alen<Int> (opt_get1 $Snap.unit source@26@04))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@35@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@38@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@38@04)))
(push) ; 12
(assert (not (ite
  (and
    (<
      (inv@34@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@38@04))
      V@28@04)
    (<=
      0
      (inv@34@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@38@04))))
  (< $Perm.No $k@33@04)
  false)))
(check-sat)
; unsat
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               271
;  :arith-add-rows          45
;  :arith-assert-diseq      6
;  :arith-assert-lower      62
;  :arith-assert-upper      39
;  :arith-bound-prop        15
;  :arith-conflicts         6
;  :arith-eq-adapter        23
;  :arith-fixed-eqs         16
;  :arith-offset-eqs        7
;  :arith-pivots            51
;  :conflicts               17
;  :datatype-accessor-ax    17
;  :datatype-constructor-ax 18
;  :datatype-occurs-check   41
;  :datatype-splits         18
;  :decisions               24
;  :del-clause              102
;  :final-checks            22
;  :max-generation          3
;  :max-memory              4.38
;  :memory                  4.37
;  :mk-bool-var             756
;  :mk-clause               111
;  :num-allocs              172715
;  :num-checks              33
;  :propagations            65
;  :quant-instantiations    130
;  :rlimit-count            204773)
; [eval] aloc(opt_get1(source), i2)
; [eval] opt_get1(source)
(push) ; 12
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 12
; Joined path conditions
(push) ; 12
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 13
(assert (not (< i2@39@04 (alen<Int> (opt_get1 $Snap.unit source@26@04)))))
(check-sat)
; unsat
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               271
;  :arith-add-rows          45
;  :arith-assert-diseq      6
;  :arith-assert-lower      62
;  :arith-assert-upper      39
;  :arith-bound-prop        15
;  :arith-conflicts         6
;  :arith-eq-adapter        23
;  :arith-fixed-eqs         16
;  :arith-offset-eqs        7
;  :arith-pivots            51
;  :conflicts               17
;  :datatype-accessor-ax    17
;  :datatype-constructor-ax 18
;  :datatype-occurs-check   41
;  :datatype-splits         18
;  :decisions               24
;  :del-clause              102
;  :final-checks            22
;  :max-generation          3
;  :max-memory              4.38
;  :memory                  4.37
;  :mk-bool-var             756
;  :mk-clause               111
;  :num-allocs              172746
;  :num-checks              34
;  :propagations            65
;  :quant-instantiations    130
;  :rlimit-count            204803)
(assert (< i2@39@04 (alen<Int> (opt_get1 $Snap.unit source@26@04))))
(pop) ; 12
; Joined path conditions
(assert (< i2@39@04 (alen<Int> (opt_get1 $Snap.unit source@26@04))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@35@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@39@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@39@04)))
(push) ; 12
(assert (not (ite
  (and
    (<
      (inv@34@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@39@04))
      V@28@04)
    (<=
      0
      (inv@34@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@39@04))))
  (< $Perm.No $k@33@04)
  false)))
(check-sat)
; unsat
(pop) ; 12
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               275
;  :arith-add-rows          50
;  :arith-assert-diseq      6
;  :arith-assert-lower      63
;  :arith-assert-upper      41
;  :arith-bound-prop        16
;  :arith-conflicts         7
;  :arith-eq-adapter        24
;  :arith-fixed-eqs         17
;  :arith-offset-eqs        7
;  :arith-pivots            53
;  :conflicts               18
;  :datatype-accessor-ax    17
;  :datatype-constructor-ax 18
;  :datatype-occurs-check   41
;  :datatype-splits         18
;  :decisions               24
;  :del-clause              102
;  :final-checks            22
;  :max-generation          3
;  :max-memory              4.39
;  :memory                  4.38
;  :mk-bool-var             775
;  :mk-clause               118
;  :num-allocs              173061
;  :num-checks              35
;  :propagations            65
;  :quant-instantiations    141
;  :rlimit-count            205496)
(pop) ; 11
(push) ; 11
; [else-branch: 20 | !(i2@39@04 < V@28@04)]
(assert (not (< i2@39@04 V@28@04)))
(pop) ; 11
(pop) ; 10
; Joined path conditions
(assert (implies
  (< i2@39@04 V@28@04)
  (and
    (< i2@39@04 V@28@04)
    (< i1@38@04 (alen<Int> (opt_get1 $Snap.unit source@26@04)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@35@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@38@04)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@38@04))
    (< i2@39@04 (alen<Int> (opt_get1 $Snap.unit source@26@04)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@35@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@39@04)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@39@04)))))
; Joined path conditions
(pop) ; 9
(push) ; 9
; [else-branch: 19 | !(0 <= i2@39@04)]
(assert (not (<= 0 i2@39@04)))
(pop) ; 9
(pop) ; 8
; Joined path conditions
(assert (implies
  (<= 0 i2@39@04)
  (and
    (<= 0 i2@39@04)
    (implies
      (< i2@39@04 V@28@04)
      (and
        (< i2@39@04 V@28@04)
        (< i1@38@04 (alen<Int> (opt_get1 $Snap.unit source@26@04)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@35@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@38@04)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@38@04))
        (< i2@39@04 (alen<Int> (opt_get1 $Snap.unit source@26@04)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@35@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@39@04)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@39@04)))))))
; Joined path conditions
(pop) ; 7
(push) ; 7
; [else-branch: 18 | !(i1@38@04 < V@28@04)]
(assert (not (< i1@38@04 V@28@04)))
(pop) ; 7
(pop) ; 6
; Joined path conditions
(assert (implies
  (< i1@38@04 V@28@04)
  (and
    (< i1@38@04 V@28@04)
    (implies
      (<= 0 i2@39@04)
      (and
        (<= 0 i2@39@04)
        (implies
          (< i2@39@04 V@28@04)
          (and
            (< i2@39@04 V@28@04)
            (< i1@38@04 (alen<Int> (opt_get1 $Snap.unit source@26@04)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@35@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@38@04)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@38@04))
            (< i2@39@04 (alen<Int> (opt_get1 $Snap.unit source@26@04)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@35@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@39@04)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@39@04)))))))))
; Joined path conditions
(pop) ; 5
(push) ; 5
; [else-branch: 17 | !(0 <= i1@38@04)]
(assert (not (<= 0 i1@38@04)))
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (implies
  (<= 0 i1@38@04)
  (and
    (<= 0 i1@38@04)
    (implies
      (< i1@38@04 V@28@04)
      (and
        (< i1@38@04 V@28@04)
        (implies
          (<= 0 i2@39@04)
          (and
            (<= 0 i2@39@04)
            (implies
              (< i2@39@04 V@28@04)
              (and
                (< i2@39@04 V@28@04)
                (< i1@38@04 (alen<Int> (opt_get1 $Snap.unit source@26@04)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@35@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@38@04)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@38@04))
                (< i2@39@04 (alen<Int> (opt_get1 $Snap.unit source@26@04)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@35@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@39@04)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@39@04)))))))))))
; Joined path conditions
(push) ; 4
; [then-branch: 21 | Lookup(option$array$,sm@35@04,aloc((_, _), opt_get1(_, source@26@04), i1@38@04)) == Lookup(option$array$,sm@35@04,aloc((_, _), opt_get1(_, source@26@04), i2@39@04)) && i2@39@04 < V@28@04 && 0 <= i2@39@04 && i1@38@04 < V@28@04 && 0 <= i1@38@04 | live]
; [else-branch: 21 | !(Lookup(option$array$,sm@35@04,aloc((_, _), opt_get1(_, source@26@04), i1@38@04)) == Lookup(option$array$,sm@35@04,aloc((_, _), opt_get1(_, source@26@04), i2@39@04)) && i2@39@04 < V@28@04 && 0 <= i2@39@04 && i1@38@04 < V@28@04 && 0 <= i1@38@04) | live]
(push) ; 5
; [then-branch: 21 | Lookup(option$array$,sm@35@04,aloc((_, _), opt_get1(_, source@26@04), i1@38@04)) == Lookup(option$array$,sm@35@04,aloc((_, _), opt_get1(_, source@26@04), i2@39@04)) && i2@39@04 < V@28@04 && 0 <= i2@39@04 && i1@38@04 < V@28@04 && 0 <= i1@38@04]
(assert (and
  (and
    (and
      (and
        (=
          ($FVF.lookup_option$array$ (as sm@35@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@38@04))
          ($FVF.lookup_option$array$ (as sm@35@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@39@04)))
        (< i2@39@04 V@28@04))
      (<= 0 i2@39@04))
    (< i1@38@04 V@28@04))
  (<= 0 i1@38@04)))
; [eval] i1 == i2
(pop) ; 5
(push) ; 5
; [else-branch: 21 | !(Lookup(option$array$,sm@35@04,aloc((_, _), opt_get1(_, source@26@04), i1@38@04)) == Lookup(option$array$,sm@35@04,aloc((_, _), opt_get1(_, source@26@04), i2@39@04)) && i2@39@04 < V@28@04 && 0 <= i2@39@04 && i1@38@04 < V@28@04 && 0 <= i1@38@04)]
(assert (not
  (and
    (and
      (and
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@35@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@38@04))
            ($FVF.lookup_option$array$ (as sm@35@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@39@04)))
          (< i2@39@04 V@28@04))
        (<= 0 i2@39@04))
      (< i1@38@04 V@28@04))
    (<= 0 i1@38@04))))
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (implies
  (and
    (and
      (and
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@35@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@38@04))
            ($FVF.lookup_option$array$ (as sm@35@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@39@04)))
          (< i2@39@04 V@28@04))
        (<= 0 i2@39@04))
      (< i1@38@04 V@28@04))
    (<= 0 i1@38@04))
  (and
    (=
      ($FVF.lookup_option$array$ (as sm@35@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@38@04))
      ($FVF.lookup_option$array$ (as sm@35@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@39@04)))
    (< i2@39@04 V@28@04)
    (<= 0 i2@39@04)
    (< i1@38@04 V@28@04)
    (<= 0 i1@38@04))))
; Joined path conditions
(pop) ; 3
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i2@39@04 Int)) (!
  (and
    (implies
      (<= 0 i1@38@04)
      (and
        (<= 0 i1@38@04)
        (implies
          (< i1@38@04 V@28@04)
          (and
            (< i1@38@04 V@28@04)
            (implies
              (<= 0 i2@39@04)
              (and
                (<= 0 i2@39@04)
                (implies
                  (< i2@39@04 V@28@04)
                  (and
                    (< i2@39@04 V@28@04)
                    (< i1@38@04 (alen<Int> (opt_get1 $Snap.unit source@26@04)))
                    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@35@04  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@38@04)) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@38@04))
                    (< i2@39@04 (alen<Int> (opt_get1 $Snap.unit source@26@04)))
                    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@35@04  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@39@04)) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@39@04))))))))))
    (implies
      (and
        (and
          (and
            (and
              (=
                ($FVF.lookup_option$array$ (as sm@35@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@38@04))
                ($FVF.lookup_option$array$ (as sm@35@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@39@04)))
              (< i2@39@04 V@28@04))
            (<= 0 i2@39@04))
          (< i1@38@04 V@28@04))
        (<= 0 i1@38@04))
      (and
        (=
          ($FVF.lookup_option$array$ (as sm@35@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@38@04))
          ($FVF.lookup_option$array$ (as sm@35@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@39@04)))
        (< i2@39@04 V@28@04)
        (<= 0 i2@39@04)
        (< i1@38@04 V@28@04)
        (<= 0 i1@38@04))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@39@04))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 2
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@38@04 Int)) (!
  (forall ((i2@39@04 Int)) (!
    (and
      (implies
        (<= 0 i1@38@04)
        (and
          (<= 0 i1@38@04)
          (implies
            (< i1@38@04 V@28@04)
            (and
              (< i1@38@04 V@28@04)
              (implies
                (<= 0 i2@39@04)
                (and
                  (<= 0 i2@39@04)
                  (implies
                    (< i2@39@04 V@28@04)
                    (and
                      (< i2@39@04 V@28@04)
                      (< i1@38@04 (alen<Int> (opt_get1 $Snap.unit source@26@04)))
                      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@35@04  $FVF<option<array>>) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@38@04)) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@38@04))
                      (< i2@39@04 (alen<Int> (opt_get1 $Snap.unit source@26@04)))
                      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@35@04  $FVF<option<array>>) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@39@04)) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@39@04))))))))))
      (implies
        (and
          (and
            (and
              (and
                (=
                  ($FVF.lookup_option$array$ (as sm@35@04  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@38@04))
                  ($FVF.lookup_option$array$ (as sm@35@04  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@39@04)))
                (< i2@39@04 V@28@04))
              (<= 0 i2@39@04))
            (< i1@38@04 V@28@04))
          (<= 0 i1@38@04))
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@35@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@38@04))
            ($FVF.lookup_option$array$ (as sm@35@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@39@04)))
          (< i2@39@04 V@28@04)
          (<= 0 i2@39@04)
          (< i1@38@04 V@28@04)
          (<= 0 i1@38@04))))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@39@04))
    :qid |prog.l<no position>-aux|))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@38@04))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(assert (forall ((i1@38@04 Int)) (!
  (forall ((i2@39@04 Int)) (!
    (implies
      (and
        (and
          (and
            (and
              (=
                ($FVF.lookup_option$array$ (as sm@35@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@38@04))
                ($FVF.lookup_option$array$ (as sm@35@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@39@04)))
              (< i2@39@04 V@28@04))
            (<= 0 i2@39@04))
          (< i1@38@04 V@28@04))
        (<= 0 i1@38@04))
      (= i1@38@04 i2@39@04))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@39@04))
    :qid |prog.l<no position>|))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@38@04))
  :qid |prog.l<no position>|)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@31@04)))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@31@04))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@31@04)))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@31@04))))))))
  $Snap.unit))
; [eval] target != (None(): option[array])
; [eval] (None(): option[array])
(assert (not (= target@27@04 (as None<option<array>>  option<array>))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@31@04))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@31@04)))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@31@04))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@31@04)))))))))
  $Snap.unit))
; [eval] alen(opt_get1(target)) == V
; [eval] alen(opt_get1(target))
; [eval] opt_get1(target)
(push) ; 2
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 2
; Joined path conditions
(assert (= (alen<Int> (opt_get1 $Snap.unit target@27@04)) V@28@04))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@31@04)))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@31@04))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@31@04)))))))))))))
(declare-const i1@40@04 Int)
(push) ; 2
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 3
; [then-branch: 22 | 0 <= i1@40@04 | live]
; [else-branch: 22 | !(0 <= i1@40@04) | live]
(push) ; 4
; [then-branch: 22 | 0 <= i1@40@04]
(assert (<= 0 i1@40@04))
; [eval] i1 < V
(pop) ; 4
(push) ; 4
; [else-branch: 22 | !(0 <= i1@40@04)]
(assert (not (<= 0 i1@40@04)))
(pop) ; 4
(pop) ; 3
; Joined path conditions
; Joined path conditions
(assert (and (< i1@40@04 V@28@04) (<= 0 i1@40@04)))
; [eval] aloc(opt_get1(target), i1)
; [eval] opt_get1(target)
(push) ; 3
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 3
; Joined path conditions
(push) ; 3
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 4
(assert (not (< i1@40@04 (alen<Int> (opt_get1 $Snap.unit target@27@04)))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               300
;  :arith-add-rows          61
;  :arith-assert-diseq      6
;  :arith-assert-lower      69
;  :arith-assert-upper      44
;  :arith-bound-prop        16
;  :arith-conflicts         7
;  :arith-eq-adapter        27
;  :arith-fixed-eqs         20
;  :arith-offset-eqs        7
;  :arith-pivots            63
;  :conflicts               18
;  :datatype-accessor-ax    20
;  :datatype-constructor-ax 18
;  :datatype-occurs-check   41
;  :datatype-splits         18
;  :decisions               24
;  :del-clause              140
;  :final-checks            22
;  :max-generation          3
;  :max-memory              4.40
;  :memory                  4.39
;  :mk-bool-var             811
;  :mk-clause               142
;  :num-allocs              174443
;  :num-checks              36
;  :propagations            65
;  :quant-instantiations    146
;  :rlimit-count            208861)
(assert (< i1@40@04 (alen<Int> (opt_get1 $Snap.unit target@27@04))))
(pop) ; 3
; Joined path conditions
(assert (< i1@40@04 (alen<Int> (opt_get1 $Snap.unit target@27@04))))
(declare-const $k@41@04 $Perm)
(assert ($Perm.isReadVar $k@41@04 $Perm.Write))
(pop) ; 2
(declare-fun inv@42@04 ($Ref) Int)
; Nested auxiliary terms: globals
(assert ($Perm.isReadVar $k@41@04 $Perm.Write))
; Nested auxiliary terms: non-globals
(assert (forall ((i1@40@04 Int)) (!
  (< i1@40@04 (alen<Int> (opt_get1 $Snap.unit target@27@04)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@40@04))
  :qid |option$array$-aux|)))
(push) ; 2
(assert (not (forall ((i1@40@04 Int)) (!
  (implies
    (and (< i1@40@04 V@28@04) (<= 0 i1@40@04))
    (or (= $k@41@04 $Perm.No) (< $Perm.No $k@41@04)))
  
  ))))
(check-sat)
; unsat
(pop) ; 2
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               300
;  :arith-add-rows          62
;  :arith-assert-diseq      7
;  :arith-assert-lower      71
;  :arith-assert-upper      45
;  :arith-bound-prop        16
;  :arith-conflicts         7
;  :arith-eq-adapter        28
;  :arith-fixed-eqs         20
;  :arith-offset-eqs        7
;  :arith-pivots            65
;  :conflicts               19
;  :datatype-accessor-ax    20
;  :datatype-constructor-ax 18
;  :datatype-occurs-check   41
;  :datatype-splits         18
;  :decisions               24
;  :del-clause              140
;  :final-checks            22
;  :max-generation          3
;  :max-memory              4.40
;  :memory                  4.39
;  :mk-bool-var             818
;  :mk-clause               144
;  :num-allocs              174902
;  :num-checks              37
;  :propagations            66
;  :quant-instantiations    146
;  :rlimit-count            209456)
; Check receiver injectivity
(push) ; 2
(assert (not (forall ((i11@40@04 Int) (i12@40@04 Int)) (!
  (implies
    (and
      (and (and (< i11@40@04 V@28@04) (<= 0 i11@40@04)) (< $Perm.No $k@41@04))
      (and (and (< i12@40@04 V@28@04) (<= 0 i12@40@04)) (< $Perm.No $k@41@04))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i11@40@04)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i12@40@04)))
    (= i11@40@04 i12@40@04))
  
  :qid |option$array$-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 2
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               315
;  :arith-add-rows          71
;  :arith-assert-diseq      9
;  :arith-assert-lower      76
;  :arith-assert-upper      46
;  :arith-bound-prop        18
;  :arith-conflicts         7
;  :arith-eq-adapter        30
;  :arith-fixed-eqs         21
;  :arith-offset-eqs        9
;  :arith-pivots            71
;  :conflicts               20
;  :datatype-accessor-ax    20
;  :datatype-constructor-ax 18
;  :datatype-occurs-check   41
;  :datatype-splits         18
;  :decisions               24
;  :del-clause              155
;  :final-checks            22
;  :max-generation          3
;  :max-memory              4.40
;  :memory                  4.40
;  :mk-bool-var             843
;  :mk-clause               159
;  :num-allocs              175302
;  :num-checks              38
;  :propagations            72
;  :quant-instantiations    156
;  :rlimit-count            210391)
; Definitional axioms for inverse functions
(assert (forall ((i1@40@04 Int)) (!
  (implies
    (and (and (< i1@40@04 V@28@04) (<= 0 i1@40@04)) (< $Perm.No $k@41@04))
    (=
      (inv@42@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@40@04))
      i1@40@04))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@40@04))
  )))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and (< (inv@42@04 r) V@28@04) (<= 0 (inv@42@04 r)))
      (< $Perm.No $k@41@04))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) (inv@42@04 r))
      r))
  :pattern ((inv@42@04 r))
  :qid |option$array$-fctOfInv|)))
; Permissions are non-negative
(assert (forall ((i1@40@04 Int)) (!
  (<= $Perm.No $k@41@04)
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@40@04))
  :qid |option$array$-permAtLeastZero|)))
; Field permissions are at most one
(assert (forall ((i1@40@04 Int)) (!
  (<= $k@41@04 $Perm.Write)
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@40@04))
  :qid |option$array$-permAtMostOne|)))
; Permission implies non-null receiver
(assert (forall ((i1@40@04 Int)) (!
  (implies
    (and (and (< i1@40@04 V@28@04) (<= 0 i1@40@04)) (< $Perm.No $k@41@04))
    (not
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@40@04)
        $Ref.null)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@40@04))
  :qid |option$array$-permImpliesNonNull|)))
(declare-const sm@43@04 $FVF<option<array>>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@42@04 r) V@28@04) (<= 0 (inv@42@04 r)))
      (< $Perm.No $k@41@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@31@04))))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@31@04))))))))))) r))
  :qid |qp.fvfValDef6|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@34@04 r) V@28@04) (<= 0 (inv@34@04 r)))
      (< $Perm.No $k@33@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@31@04))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@31@04))))) r))
  :qid |qp.fvfValDef7|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@31@04))))))))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@31@04))))) r) r))
  :pattern (($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef8|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@42@04 r) V@28@04) (<= 0 (inv@42@04 r)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) r) r))
  :pattern ((inv@42@04 r))
  )))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@31@04))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@31@04)))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@31@04))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@31@04)))))))))))
  $Snap.unit))
; [eval] (forall i1: Int :: { aloc(opt_get1(target), i1) } 0 <= i1 && i1 < V ==> aloc(opt_get1(target), i1).option$array$ != (None(): option[array]))
(declare-const i1@44@04 Int)
(push) ; 2
; [eval] 0 <= i1 && i1 < V ==> aloc(opt_get1(target), i1).option$array$ != (None(): option[array])
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 3
; [then-branch: 23 | 0 <= i1@44@04 | live]
; [else-branch: 23 | !(0 <= i1@44@04) | live]
(push) ; 4
; [then-branch: 23 | 0 <= i1@44@04]
(assert (<= 0 i1@44@04))
; [eval] i1 < V
(pop) ; 4
(push) ; 4
; [else-branch: 23 | !(0 <= i1@44@04)]
(assert (not (<= 0 i1@44@04)))
(pop) ; 4
(pop) ; 3
; Joined path conditions
; Joined path conditions
(push) ; 3
; [then-branch: 24 | i1@44@04 < V@28@04 && 0 <= i1@44@04 | live]
; [else-branch: 24 | !(i1@44@04 < V@28@04 && 0 <= i1@44@04) | live]
(push) ; 4
; [then-branch: 24 | i1@44@04 < V@28@04 && 0 <= i1@44@04]
(assert (and (< i1@44@04 V@28@04) (<= 0 i1@44@04)))
; [eval] aloc(opt_get1(target), i1).option$array$ != (None(): option[array])
; [eval] aloc(opt_get1(target), i1)
; [eval] opt_get1(target)
(push) ; 5
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 5
; Joined path conditions
(push) ; 5
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 6
(assert (not (< i1@44@04 (alen<Int> (opt_get1 $Snap.unit target@27@04)))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               322
;  :arith-add-rows          74
;  :arith-assert-diseq      9
;  :arith-assert-lower      79
;  :arith-assert-upper      48
;  :arith-bound-prop        18
;  :arith-conflicts         7
;  :arith-eq-adapter        31
;  :arith-fixed-eqs         22
;  :arith-offset-eqs        9
;  :arith-pivots            73
;  :conflicts               20
;  :datatype-accessor-ax    21
;  :datatype-constructor-ax 18
;  :datatype-occurs-check   41
;  :datatype-splits         18
;  :decisions               24
;  :del-clause              155
;  :final-checks            22
;  :max-generation          3
;  :max-memory              4.46
;  :memory                  4.45
;  :mk-bool-var             857
;  :mk-clause               159
;  :num-allocs              176723
;  :num-checks              39
;  :propagations            72
;  :quant-instantiations    156
;  :rlimit-count            213648)
(assert (< i1@44@04 (alen<Int> (opt_get1 $Snap.unit target@27@04))))
(pop) ; 5
; Joined path conditions
(assert (< i1@44@04 (alen<Int> (opt_get1 $Snap.unit target@27@04))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@44@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@44@04)))
(push) ; 5
(assert (not (<
  $Perm.No
  (+
    (ite
      (and
        (<
          (inv@42@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@44@04))
          V@28@04)
        (<=
          0
          (inv@42@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@44@04))))
      $k@41@04
      $Perm.No)
    (ite
      (and
        (<
          (inv@34@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@44@04))
          V@28@04)
        (<=
          0
          (inv@34@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@44@04))))
      $k@33@04
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               357
;  :arith-add-rows          89
;  :arith-assert-diseq      13
;  :arith-assert-lower      92
;  :arith-assert-upper      55
;  :arith-bound-prop        25
;  :arith-conflicts         9
;  :arith-eq-adapter        43
;  :arith-fixed-eqs         25
;  :arith-offset-eqs        14
;  :arith-pivots            81
;  :conflicts               26
;  :datatype-accessor-ax    21
;  :datatype-constructor-ax 18
;  :datatype-occurs-check   41
;  :datatype-splits         18
;  :decisions               33
;  :del-clause              218
;  :final-checks            22
;  :max-generation          3
;  :max-memory              4.49
;  :memory                  4.49
;  :mk-bool-var             957
;  :mk-clause               242
;  :num-allocs              177453
;  :num-checks              40
;  :propagations            114
;  :quant-instantiations    177
;  :rlimit-count            215436)
; [eval] (None(): option[array])
(pop) ; 4
(push) ; 4
; [else-branch: 24 | !(i1@44@04 < V@28@04 && 0 <= i1@44@04)]
(assert (not (and (< i1@44@04 V@28@04) (<= 0 i1@44@04))))
(pop) ; 4
(pop) ; 3
; Joined path conditions
(assert (implies
  (and (< i1@44@04 V@28@04) (<= 0 i1@44@04))
  (and
    (< i1@44@04 V@28@04)
    (<= 0 i1@44@04)
    (< i1@44@04 (alen<Int> (opt_get1 $Snap.unit target@27@04)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@44@04)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@44@04)))))
; Joined path conditions
(pop) ; 2
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@44@04 Int)) (!
  (implies
    (and (< i1@44@04 V@28@04) (<= 0 i1@44@04))
    (and
      (< i1@44@04 V@28@04)
      (<= 0 i1@44@04)
      (< i1@44@04 (alen<Int> (opt_get1 $Snap.unit target@27@04)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@44@04)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@44@04))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@44@04))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(assert (forall ((i1@44@04 Int)) (!
  (implies
    (and (< i1@44@04 V@28@04) (<= 0 i1@44@04))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@44@04))
        (as None<option<array>>  option<array>))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@44@04))
  :qid |prog.l<no position>|)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@31@04)))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@31@04))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@31@04)))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@31@04))))))))))))
  $Snap.unit))
; [eval] (forall i1: Int :: { alen(opt_get1(aloc(opt_get1(target), i1).option$array$)) } 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(target), i1).option$array$)) == V)
(declare-const i1@45@04 Int)
(push) ; 2
; [eval] 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(target), i1).option$array$)) == V
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 3
; [then-branch: 25 | 0 <= i1@45@04 | live]
; [else-branch: 25 | !(0 <= i1@45@04) | live]
(push) ; 4
; [then-branch: 25 | 0 <= i1@45@04]
(assert (<= 0 i1@45@04))
; [eval] i1 < V
(pop) ; 4
(push) ; 4
; [else-branch: 25 | !(0 <= i1@45@04)]
(assert (not (<= 0 i1@45@04)))
(pop) ; 4
(pop) ; 3
; Joined path conditions
; Joined path conditions
(push) ; 3
; [then-branch: 26 | i1@45@04 < V@28@04 && 0 <= i1@45@04 | live]
; [else-branch: 26 | !(i1@45@04 < V@28@04 && 0 <= i1@45@04) | live]
(push) ; 4
; [then-branch: 26 | i1@45@04 < V@28@04 && 0 <= i1@45@04]
(assert (and (< i1@45@04 V@28@04) (<= 0 i1@45@04)))
; [eval] alen(opt_get1(aloc(opt_get1(target), i1).option$array$)) == V
; [eval] alen(opt_get1(aloc(opt_get1(target), i1).option$array$))
; [eval] opt_get1(aloc(opt_get1(target), i1).option$array$)
; [eval] aloc(opt_get1(target), i1)
; [eval] opt_get1(target)
(push) ; 5
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 5
; Joined path conditions
(push) ; 5
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 6
(assert (not (< i1@45@04 (alen<Int> (opt_get1 $Snap.unit target@27@04)))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               364
;  :arith-add-rows          94
;  :arith-assert-diseq      13
;  :arith-assert-lower      95
;  :arith-assert-upper      56
;  :arith-bound-prop        25
;  :arith-conflicts         9
;  :arith-eq-adapter        44
;  :arith-fixed-eqs         26
;  :arith-offset-eqs        14
;  :arith-pivots            86
;  :conflicts               26
;  :datatype-accessor-ax    22
;  :datatype-constructor-ax 18
;  :datatype-occurs-check   41
;  :datatype-splits         18
;  :decisions               33
;  :del-clause              238
;  :final-checks            22
;  :max-generation          3
;  :max-memory              4.50
;  :memory                  4.49
;  :mk-bool-var             965
;  :mk-clause               242
;  :num-allocs              178027
;  :num-checks              41
;  :propagations            114
;  :quant-instantiations    177
;  :rlimit-count            216713)
(assert (< i1@45@04 (alen<Int> (opt_get1 $Snap.unit target@27@04))))
(pop) ; 5
; Joined path conditions
(assert (< i1@45@04 (alen<Int> (opt_get1 $Snap.unit target@27@04))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@45@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@45@04)))
(push) ; 5
(assert (not (<
  $Perm.No
  (+
    (ite
      (and
        (<
          (inv@42@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@45@04))
          V@28@04)
        (<=
          0
          (inv@42@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@45@04))))
      $k@41@04
      $Perm.No)
    (ite
      (and
        (<
          (inv@34@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@45@04))
          V@28@04)
        (<=
          0
          (inv@34@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@45@04))))
      $k@33@04
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               398
;  :arith-add-rows          110
;  :arith-assert-diseq      17
;  :arith-assert-lower      108
;  :arith-assert-upper      63
;  :arith-bound-prop        32
;  :arith-conflicts         11
;  :arith-eq-adapter        56
;  :arith-fixed-eqs         29
;  :arith-offset-eqs        19
;  :arith-pivots            93
;  :conflicts               32
;  :datatype-accessor-ax    22
;  :datatype-constructor-ax 18
;  :datatype-occurs-check   41
;  :datatype-splits         18
;  :decisions               42
;  :del-clause              301
;  :final-checks            22
;  :max-generation          3
;  :max-memory              4.53
;  :memory                  4.52
;  :mk-bool-var             1066
;  :mk-clause               325
;  :num-allocs              178564
;  :num-checks              42
;  :propagations            156
;  :quant-instantiations    200
;  :rlimit-count            218400)
(push) ; 5
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 6
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@45@04))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               398
;  :arith-add-rows          110
;  :arith-assert-diseq      17
;  :arith-assert-lower      108
;  :arith-assert-upper      63
;  :arith-bound-prop        32
;  :arith-conflicts         11
;  :arith-eq-adapter        56
;  :arith-fixed-eqs         29
;  :arith-offset-eqs        19
;  :arith-pivots            93
;  :conflicts               33
;  :datatype-accessor-ax    22
;  :datatype-constructor-ax 18
;  :datatype-occurs-check   41
;  :datatype-splits         18
;  :decisions               42
;  :del-clause              301
;  :final-checks            22
;  :max-generation          3
;  :max-memory              4.53
;  :memory                  4.52
;  :mk-bool-var             1066
;  :mk-clause               325
;  :num-allocs              178653
;  :num-checks              43
;  :propagations            156
;  :quant-instantiations    200
;  :rlimit-count            218495)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@45@04))
    (as None<option<array>>  option<array>))))
(pop) ; 5
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@45@04))
    (as None<option<array>>  option<array>))))
(pop) ; 4
(push) ; 4
; [else-branch: 26 | !(i1@45@04 < V@28@04 && 0 <= i1@45@04)]
(assert (not (and (< i1@45@04 V@28@04) (<= 0 i1@45@04))))
(pop) ; 4
(pop) ; 3
; Joined path conditions
(assert (implies
  (and (< i1@45@04 V@28@04) (<= 0 i1@45@04))
  (and
    (< i1@45@04 V@28@04)
    (<= 0 i1@45@04)
    (< i1@45@04 (alen<Int> (opt_get1 $Snap.unit target@27@04)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@45@04)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@45@04))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@45@04))
        (as None<option<array>>  option<array>))))))
; Joined path conditions
(pop) ; 2
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@45@04 Int)) (!
  (implies
    (and (< i1@45@04 V@28@04) (<= 0 i1@45@04))
    (and
      (< i1@45@04 V@28@04)
      (<= 0 i1@45@04)
      (< i1@45@04 (alen<Int> (opt_get1 $Snap.unit target@27@04)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@45@04)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@45@04))
      (not
        (=
          ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@45@04))
          (as None<option<array>>  option<array>)))))
  :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@45@04)))))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(assert (forall ((i1@45@04 Int)) (!
  (implies
    (and (< i1@45@04 V@28@04) (<= 0 i1@45@04))
    (=
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@45@04))))
      V@28@04))
  :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@45@04)))))
  :qid |prog.l<no position>|)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@31@04))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@31@04)))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@31@04))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@31@04)))))))))))))
  $Snap.unit))
; [eval] (forall i1: Int :: { aloc(opt_get1(target), i1) } (forall i2: Int :: { aloc(opt_get1(target), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(target), i1).option$array$ == aloc(opt_get1(target), i2).option$array$ ==> i1 == i2))
(declare-const i1@46@04 Int)
(push) ; 2
; [eval] (forall i2: Int :: { aloc(opt_get1(target), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(target), i1).option$array$ == aloc(opt_get1(target), i2).option$array$ ==> i1 == i2)
(declare-const i2@47@04 Int)
(push) ; 3
; [eval] 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(target), i1).option$array$ == aloc(opt_get1(target), i2).option$array$ ==> i1 == i2
; [eval] 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(target), i1).option$array$ == aloc(opt_get1(target), i2).option$array$
; [eval] 0 <= i1
(push) ; 4
; [then-branch: 27 | 0 <= i1@46@04 | live]
; [else-branch: 27 | !(0 <= i1@46@04) | live]
(push) ; 5
; [then-branch: 27 | 0 <= i1@46@04]
(assert (<= 0 i1@46@04))
; [eval] i1 < V
(push) ; 6
; [then-branch: 28 | i1@46@04 < V@28@04 | live]
; [else-branch: 28 | !(i1@46@04 < V@28@04) | live]
(push) ; 7
; [then-branch: 28 | i1@46@04 < V@28@04]
(assert (< i1@46@04 V@28@04))
; [eval] 0 <= i2
(push) ; 8
; [then-branch: 29 | 0 <= i2@47@04 | live]
; [else-branch: 29 | !(0 <= i2@47@04) | live]
(push) ; 9
; [then-branch: 29 | 0 <= i2@47@04]
(assert (<= 0 i2@47@04))
; [eval] i2 < V
(push) ; 10
; [then-branch: 30 | i2@47@04 < V@28@04 | live]
; [else-branch: 30 | !(i2@47@04 < V@28@04) | live]
(push) ; 11
; [then-branch: 30 | i2@47@04 < V@28@04]
(assert (< i2@47@04 V@28@04))
; [eval] aloc(opt_get1(target), i1).option$array$ == aloc(opt_get1(target), i2).option$array$
; [eval] aloc(opt_get1(target), i1)
; [eval] opt_get1(target)
(push) ; 12
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 12
; Joined path conditions
(push) ; 12
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 13
(assert (not (< i1@46@04 (alen<Int> (opt_get1 $Snap.unit target@27@04)))))
(check-sat)
; unsat
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               405
;  :arith-add-rows          117
;  :arith-assert-diseq      17
;  :arith-assert-lower      113
;  :arith-assert-upper      64
;  :arith-bound-prop        32
;  :arith-conflicts         11
;  :arith-eq-adapter        57
;  :arith-fixed-eqs         30
;  :arith-offset-eqs        19
;  :arith-pivots            100
;  :conflicts               33
;  :datatype-accessor-ax    23
;  :datatype-constructor-ax 18
;  :datatype-occurs-check   41
;  :datatype-splits         18
;  :decisions               42
;  :del-clause              321
;  :final-checks            22
;  :max-generation          3
;  :max-memory              4.53
;  :memory                  4.53
;  :mk-bool-var             1076
;  :mk-clause               325
;  :num-allocs              179416
;  :num-checks              44
;  :propagations            156
;  :quant-instantiations    200
;  :rlimit-count            220040)
(assert (< i1@46@04 (alen<Int> (opt_get1 $Snap.unit target@27@04))))
(pop) ; 12
; Joined path conditions
(assert (< i1@46@04 (alen<Int> (opt_get1 $Snap.unit target@27@04))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@46@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@46@04)))
(push) ; 12
(assert (not (<
  $Perm.No
  (+
    (ite
      (and
        (<
          (inv@42@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@46@04))
          V@28@04)
        (<=
          0
          (inv@42@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@46@04))))
      $k@41@04
      $Perm.No)
    (ite
      (and
        (<
          (inv@34@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@46@04))
          V@28@04)
        (<=
          0
          (inv@34@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@46@04))))
      $k@33@04
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               439
;  :arith-add-rows          132
;  :arith-assert-diseq      21
;  :arith-assert-lower      126
;  :arith-assert-upper      71
;  :arith-bound-prop        39
;  :arith-conflicts         13
;  :arith-eq-adapter        69
;  :arith-fixed-eqs         33
;  :arith-offset-eqs        24
;  :arith-pivots            109
;  :conflicts               39
;  :datatype-accessor-ax    23
;  :datatype-constructor-ax 18
;  :datatype-occurs-check   41
;  :datatype-splits         18
;  :decisions               51
;  :del-clause              384
;  :final-checks            22
;  :max-generation          3
;  :max-memory              4.84
;  :memory                  4.70
;  :mk-bool-var             1177
;  :mk-clause               408
;  :num-allocs              179970
;  :num-checks              45
;  :propagations            198
;  :quant-instantiations    223
;  :rlimit-count            221757)
; [eval] aloc(opt_get1(target), i2)
; [eval] opt_get1(target)
(push) ; 12
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 12
; Joined path conditions
(push) ; 12
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 13
(assert (not (< i2@47@04 (alen<Int> (opt_get1 $Snap.unit target@27@04)))))
(check-sat)
; unsat
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               439
;  :arith-add-rows          132
;  :arith-assert-diseq      21
;  :arith-assert-lower      126
;  :arith-assert-upper      71
;  :arith-bound-prop        39
;  :arith-conflicts         13
;  :arith-eq-adapter        69
;  :arith-fixed-eqs         33
;  :arith-offset-eqs        24
;  :arith-pivots            109
;  :conflicts               39
;  :datatype-accessor-ax    23
;  :datatype-constructor-ax 18
;  :datatype-occurs-check   41
;  :datatype-splits         18
;  :decisions               51
;  :del-clause              384
;  :final-checks            22
;  :max-generation          3
;  :max-memory              4.84
;  :memory                  4.70
;  :mk-bool-var             1177
;  :mk-clause               408
;  :num-allocs              179995
;  :num-checks              46
;  :propagations            198
;  :quant-instantiations    223
;  :rlimit-count            221787)
(assert (< i2@47@04 (alen<Int> (opt_get1 $Snap.unit target@27@04))))
(pop) ; 12
; Joined path conditions
(assert (< i2@47@04 (alen<Int> (opt_get1 $Snap.unit target@27@04))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@47@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@47@04)))
(push) ; 12
(assert (not (<
  $Perm.No
  (+
    (ite
      (and
        (<
          (inv@42@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@47@04))
          V@28@04)
        (<=
          0
          (inv@42@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@47@04))))
      $k@41@04
      $Perm.No)
    (ite
      (and
        (<
          (inv@34@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@47@04))
          V@28@04)
        (<=
          0
          (inv@34@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@47@04))))
      $k@33@04
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               473
;  :arith-add-rows          152
;  :arith-assert-diseq      25
;  :arith-assert-lower      139
;  :arith-assert-upper      79
;  :arith-bound-prop        47
;  :arith-conflicts         15
;  :arith-eq-adapter        81
;  :arith-fixed-eqs         36
;  :arith-offset-eqs        29
;  :arith-pivots            115
;  :conflicts               49
;  :datatype-accessor-ax    23
;  :datatype-constructor-ax 18
;  :datatype-occurs-check   41
;  :datatype-splits         18
;  :decisions               60
;  :del-clause              444
;  :final-checks            22
;  :max-generation          3
;  :max-memory              4.84
;  :memory                  4.73
;  :mk-bool-var             1283
;  :mk-clause               480
;  :num-allocs              180726
;  :num-checks              47
;  :propagations            236
;  :quant-instantiations    242
;  :rlimit-count            223317)
(pop) ; 11
(push) ; 11
; [else-branch: 30 | !(i2@47@04 < V@28@04)]
(assert (not (< i2@47@04 V@28@04)))
(pop) ; 11
(pop) ; 10
; Joined path conditions
(assert (implies
  (< i2@47@04 V@28@04)
  (and
    (< i2@47@04 V@28@04)
    (< i1@46@04 (alen<Int> (opt_get1 $Snap.unit target@27@04)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@46@04)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@46@04))
    (< i2@47@04 (alen<Int> (opt_get1 $Snap.unit target@27@04)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@47@04)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@47@04)))))
; Joined path conditions
(pop) ; 9
(push) ; 9
; [else-branch: 29 | !(0 <= i2@47@04)]
(assert (not (<= 0 i2@47@04)))
(pop) ; 9
(pop) ; 8
; Joined path conditions
(assert (implies
  (<= 0 i2@47@04)
  (and
    (<= 0 i2@47@04)
    (implies
      (< i2@47@04 V@28@04)
      (and
        (< i2@47@04 V@28@04)
        (< i1@46@04 (alen<Int> (opt_get1 $Snap.unit target@27@04)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@46@04)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@46@04))
        (< i2@47@04 (alen<Int> (opt_get1 $Snap.unit target@27@04)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@47@04)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@47@04)))))))
; Joined path conditions
(pop) ; 7
(push) ; 7
; [else-branch: 28 | !(i1@46@04 < V@28@04)]
(assert (not (< i1@46@04 V@28@04)))
(pop) ; 7
(pop) ; 6
; Joined path conditions
(assert (implies
  (< i1@46@04 V@28@04)
  (and
    (< i1@46@04 V@28@04)
    (implies
      (<= 0 i2@47@04)
      (and
        (<= 0 i2@47@04)
        (implies
          (< i2@47@04 V@28@04)
          (and
            (< i2@47@04 V@28@04)
            (< i1@46@04 (alen<Int> (opt_get1 $Snap.unit target@27@04)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@46@04)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@46@04))
            (< i2@47@04 (alen<Int> (opt_get1 $Snap.unit target@27@04)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@47@04)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@47@04)))))))))
; Joined path conditions
(pop) ; 5
(push) ; 5
; [else-branch: 27 | !(0 <= i1@46@04)]
(assert (not (<= 0 i1@46@04)))
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (implies
  (<= 0 i1@46@04)
  (and
    (<= 0 i1@46@04)
    (implies
      (< i1@46@04 V@28@04)
      (and
        (< i1@46@04 V@28@04)
        (implies
          (<= 0 i2@47@04)
          (and
            (<= 0 i2@47@04)
            (implies
              (< i2@47@04 V@28@04)
              (and
                (< i2@47@04 V@28@04)
                (< i1@46@04 (alen<Int> (opt_get1 $Snap.unit target@27@04)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@46@04)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@46@04))
                (< i2@47@04 (alen<Int> (opt_get1 $Snap.unit target@27@04)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@47@04)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@47@04)))))))))))
; Joined path conditions
(push) ; 4
; [then-branch: 31 | Lookup(option$array$,sm@43@04,aloc((_, _), opt_get1(_, target@27@04), i1@46@04)) == Lookup(option$array$,sm@43@04,aloc((_, _), opt_get1(_, target@27@04), i2@47@04)) && i2@47@04 < V@28@04 && 0 <= i2@47@04 && i1@46@04 < V@28@04 && 0 <= i1@46@04 | live]
; [else-branch: 31 | !(Lookup(option$array$,sm@43@04,aloc((_, _), opt_get1(_, target@27@04), i1@46@04)) == Lookup(option$array$,sm@43@04,aloc((_, _), opt_get1(_, target@27@04), i2@47@04)) && i2@47@04 < V@28@04 && 0 <= i2@47@04 && i1@46@04 < V@28@04 && 0 <= i1@46@04) | live]
(push) ; 5
; [then-branch: 31 | Lookup(option$array$,sm@43@04,aloc((_, _), opt_get1(_, target@27@04), i1@46@04)) == Lookup(option$array$,sm@43@04,aloc((_, _), opt_get1(_, target@27@04), i2@47@04)) && i2@47@04 < V@28@04 && 0 <= i2@47@04 && i1@46@04 < V@28@04 && 0 <= i1@46@04]
(assert (and
  (and
    (and
      (and
        (=
          ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@46@04))
          ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@47@04)))
        (< i2@47@04 V@28@04))
      (<= 0 i2@47@04))
    (< i1@46@04 V@28@04))
  (<= 0 i1@46@04)))
; [eval] i1 == i2
(pop) ; 5
(push) ; 5
; [else-branch: 31 | !(Lookup(option$array$,sm@43@04,aloc((_, _), opt_get1(_, target@27@04), i1@46@04)) == Lookup(option$array$,sm@43@04,aloc((_, _), opt_get1(_, target@27@04), i2@47@04)) && i2@47@04 < V@28@04 && 0 <= i2@47@04 && i1@46@04 < V@28@04 && 0 <= i1@46@04)]
(assert (not
  (and
    (and
      (and
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@46@04))
            ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@47@04)))
          (< i2@47@04 V@28@04))
        (<= 0 i2@47@04))
      (< i1@46@04 V@28@04))
    (<= 0 i1@46@04))))
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (implies
  (and
    (and
      (and
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@46@04))
            ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@47@04)))
          (< i2@47@04 V@28@04))
        (<= 0 i2@47@04))
      (< i1@46@04 V@28@04))
    (<= 0 i1@46@04))
  (and
    (=
      ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@46@04))
      ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@47@04)))
    (< i2@47@04 V@28@04)
    (<= 0 i2@47@04)
    (< i1@46@04 V@28@04)
    (<= 0 i1@46@04))))
; Joined path conditions
(pop) ; 3
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i2@47@04 Int)) (!
  (and
    (implies
      (<= 0 i1@46@04)
      (and
        (<= 0 i1@46@04)
        (implies
          (< i1@46@04 V@28@04)
          (and
            (< i1@46@04 V@28@04)
            (implies
              (<= 0 i2@47@04)
              (and
                (<= 0 i2@47@04)
                (implies
                  (< i2@47@04 V@28@04)
                  (and
                    (< i2@47@04 V@28@04)
                    (< i1@46@04 (alen<Int> (opt_get1 $Snap.unit target@27@04)))
                    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@46@04)) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@46@04))
                    (< i2@47@04 (alen<Int> (opt_get1 $Snap.unit target@27@04)))
                    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@47@04)) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@47@04))))))))))
    (implies
      (and
        (and
          (and
            (and
              (=
                ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@46@04))
                ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@47@04)))
              (< i2@47@04 V@28@04))
            (<= 0 i2@47@04))
          (< i1@46@04 V@28@04))
        (<= 0 i1@46@04))
      (and
        (=
          ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@46@04))
          ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@47@04)))
        (< i2@47@04 V@28@04)
        (<= 0 i2@47@04)
        (< i1@46@04 V@28@04)
        (<= 0 i1@46@04))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@47@04))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 2
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@46@04 Int)) (!
  (forall ((i2@47@04 Int)) (!
    (and
      (implies
        (<= 0 i1@46@04)
        (and
          (<= 0 i1@46@04)
          (implies
            (< i1@46@04 V@28@04)
            (and
              (< i1@46@04 V@28@04)
              (implies
                (<= 0 i2@47@04)
                (and
                  (<= 0 i2@47@04)
                  (implies
                    (< i2@47@04 V@28@04)
                    (and
                      (< i2@47@04 V@28@04)
                      (< i1@46@04 (alen<Int> (opt_get1 $Snap.unit target@27@04)))
                      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@46@04)) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@46@04))
                      (< i2@47@04 (alen<Int> (opt_get1 $Snap.unit target@27@04)))
                      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@47@04)) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@47@04))))))))))
      (implies
        (and
          (and
            (and
              (and
                (=
                  ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@46@04))
                  ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@47@04)))
                (< i2@47@04 V@28@04))
              (<= 0 i2@47@04))
            (< i1@46@04 V@28@04))
          (<= 0 i1@46@04))
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@46@04))
            ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@47@04)))
          (< i2@47@04 V@28@04)
          (<= 0 i2@47@04)
          (< i1@46@04 V@28@04)
          (<= 0 i1@46@04))))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@47@04))
    :qid |prog.l<no position>-aux|))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@46@04))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(assert (forall ((i1@46@04 Int)) (!
  (forall ((i2@47@04 Int)) (!
    (implies
      (and
        (and
          (and
            (and
              (=
                ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@46@04))
                ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@47@04)))
              (< i2@47@04 V@28@04))
            (<= 0 i2@47@04))
          (< i1@46@04 V@28@04))
        (<= 0 i1@46@04))
      (= i1@46@04 i2@47@04))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@47@04))
    :qid |prog.l<no position>|))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@46@04))
  :qid |prog.l<no position>|)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@31@04)))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@31@04))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@31@04)))))))))))))))))
(declare-const i1@48@04 Int)
(declare-const j1@49@04 Int)
(push) ; 2
; [eval] 0 <= i1 && i1 < V && (0 <= j1 && j1 < V)
; [eval] 0 <= i1
(push) ; 3
; [then-branch: 32 | 0 <= i1@48@04 | live]
; [else-branch: 32 | !(0 <= i1@48@04) | live]
(push) ; 4
; [then-branch: 32 | 0 <= i1@48@04]
(assert (<= 0 i1@48@04))
; [eval] i1 < V
(push) ; 5
; [then-branch: 33 | i1@48@04 < V@28@04 | live]
; [else-branch: 33 | !(i1@48@04 < V@28@04) | live]
(push) ; 6
; [then-branch: 33 | i1@48@04 < V@28@04]
(assert (< i1@48@04 V@28@04))
; [eval] 0 <= j1
(push) ; 7
; [then-branch: 34 | 0 <= j1@49@04 | live]
; [else-branch: 34 | !(0 <= j1@49@04) | live]
(push) ; 8
; [then-branch: 34 | 0 <= j1@49@04]
(assert (<= 0 j1@49@04))
; [eval] j1 < V
(pop) ; 8
(push) ; 8
; [else-branch: 34 | !(0 <= j1@49@04)]
(assert (not (<= 0 j1@49@04)))
(pop) ; 8
(pop) ; 7
; Joined path conditions
; Joined path conditions
(pop) ; 6
(push) ; 6
; [else-branch: 33 | !(i1@48@04 < V@28@04)]
(assert (not (< i1@48@04 V@28@04)))
(pop) ; 6
(pop) ; 5
; Joined path conditions
; Joined path conditions
(pop) ; 4
(push) ; 4
; [else-branch: 32 | !(0 <= i1@48@04)]
(assert (not (<= 0 i1@48@04)))
(pop) ; 4
(pop) ; 3
; Joined path conditions
; Joined path conditions
(assert (and
  (and (and (< j1@49@04 V@28@04) (<= 0 j1@49@04)) (< i1@48@04 V@28@04))
  (<= 0 i1@48@04)))
; [eval] aloc(opt_get1(aloc(opt_get1(source), i1).option$array$), j1)
; [eval] opt_get1(aloc(opt_get1(source), i1).option$array$)
; [eval] aloc(opt_get1(source), i1)
; [eval] opt_get1(source)
(push) ; 3
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 3
; Joined path conditions
(push) ; 3
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 4
(assert (not (< i1@48@04 (alen<Int> (opt_get1 $Snap.unit source@26@04)))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               481
;  :arith-add-rows          169
;  :arith-assert-diseq      25
;  :arith-assert-lower      148
;  :arith-assert-upper      82
;  :arith-bound-prop        47
;  :arith-conflicts         15
;  :arith-eq-adapter        84
;  :arith-fixed-eqs         39
;  :arith-offset-eqs        29
;  :arith-pivots            129
;  :conflicts               49
;  :datatype-accessor-ax    24
;  :datatype-constructor-ax 18
;  :datatype-occurs-check   41
;  :datatype-splits         18
;  :decisions               60
;  :del-clause              500
;  :final-checks            22
;  :max-generation          3
;  :max-memory              4.84
;  :memory                  4.75
;  :mk-bool-var             1311
;  :mk-clause               504
;  :num-allocs              181965
;  :num-checks              48
;  :propagations            236
;  :quant-instantiations    242
;  :rlimit-count            226476)
(assert (< i1@48@04 (alen<Int> (opt_get1 $Snap.unit source@26@04))))
(pop) ; 3
; Joined path conditions
(assert (< i1@48@04 (alen<Int> (opt_get1 $Snap.unit source@26@04))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@48@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@48@04)))
(push) ; 3
(assert (not (<
  $Perm.No
  (+
    (ite
      (and
        (<
          (inv@42@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@48@04))
          V@28@04)
        (<=
          0
          (inv@42@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@48@04))))
      $k@41@04
      $Perm.No)
    (ite
      (and
        (<
          (inv@34@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@48@04))
          V@28@04)
        (<=
          0
          (inv@34@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@48@04))))
      $k@33@04
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               527
;  :arith-add-rows          180
;  :arith-assert-diseq      28
;  :arith-assert-lower      158
;  :arith-assert-upper      90
;  :arith-bound-prop        51
;  :arith-conflicts         17
;  :arith-eq-adapter        95
;  :arith-fixed-eqs         42
;  :arith-offset-eqs        33
;  :arith-pivots            137
;  :conflicts               55
;  :datatype-accessor-ax    24
;  :datatype-constructor-ax 18
;  :datatype-occurs-check   41
;  :datatype-splits         18
;  :decisions               65
;  :del-clause              531
;  :final-checks            22
;  :max-generation          3
;  :max-memory              4.84
;  :memory                  4.78
;  :mk-bool-var             1393
;  :mk-clause               558
;  :num-allocs              182542
;  :num-checks              49
;  :propagations            268
;  :quant-instantiations    265
;  :rlimit-count            228214)
(push) ; 3
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 4
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@48@04))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               540
;  :arith-add-rows          180
;  :arith-assert-diseq      28
;  :arith-assert-lower      158
;  :arith-assert-upper      92
;  :arith-bound-prop        52
;  :arith-conflicts         18
;  :arith-eq-adapter        95
;  :arith-fixed-eqs         42
;  :arith-offset-eqs        33
;  :arith-pivots            137
;  :conflicts               59
;  :datatype-accessor-ax    24
;  :datatype-constructor-ax 18
;  :datatype-occurs-check   41
;  :datatype-splits         18
;  :decisions               68
;  :del-clause              535
;  :final-checks            22
;  :max-generation          3
;  :max-memory              4.84
;  :memory                  4.78
;  :mk-bool-var             1398
;  :mk-clause               562
;  :num-allocs              182645
;  :num-checks              50
;  :propagations            274
;  :quant-instantiations    267
;  :rlimit-count            228446)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@48@04))
    (as None<option<array>>  option<array>))))
(pop) ; 3
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@48@04))
    (as None<option<array>>  option<array>))))
(push) ; 3
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 4
(assert (not (<
  j1@49@04
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@48@04)))))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               568
;  :arith-add-rows          188
;  :arith-assert-diseq      28
;  :arith-assert-lower      163
;  :arith-assert-upper      95
;  :arith-bound-prop        53
;  :arith-conflicts         20
;  :arith-eq-adapter        97
;  :arith-fixed-eqs         43
;  :arith-offset-eqs        34
;  :arith-pivots            139
;  :conflicts               64
;  :datatype-accessor-ax    24
;  :datatype-constructor-ax 18
;  :datatype-occurs-check   41
;  :datatype-splits         18
;  :decisions               72
;  :del-clause              540
;  :final-checks            22
;  :max-generation          3
;  :max-memory              4.84
;  :memory                  4.78
;  :mk-bool-var             1421
;  :mk-clause               567
;  :num-allocs              182888
;  :num-checks              51
;  :propagations            280
;  :quant-instantiations    278
;  :rlimit-count            229100)
(assert (<
  j1@49@04
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@48@04))))))
(pop) ; 3
; Joined path conditions
(assert (<
  j1@49@04
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@48@04))))))
(declare-const $k@50@04 $Perm)
(assert ($Perm.isReadVar $k@50@04 $Perm.Write))
(pop) ; 2
(declare-fun inv@51@04 ($Ref) Int)
(declare-fun inv@52@04 ($Ref) Int)
; Nested auxiliary terms: globals
(assert ($Perm.isReadVar $k@50@04 $Perm.Write))
; Nested auxiliary terms: non-globals
(assert (forall ((i1@48@04 Int) (j1@49@04 Int)) (!
  (and
    (< i1@48@04 (alen<Int> (opt_get1 $Snap.unit source@26@04)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@48@04)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@48@04))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@48@04))
        (as None<option<array>>  option<array>)))
    (<
      j1@49@04
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@48@04))))))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@48@04))) j1@49@04))
  :qid |int-aux|)))
(push) ; 2
(assert (not (forall ((i1@48@04 Int) (j1@49@04 Int)) (!
  (implies
    (and
      (and (and (< j1@49@04 V@28@04) (<= 0 j1@49@04)) (< i1@48@04 V@28@04))
      (<= 0 i1@48@04))
    (or (= $k@50@04 $Perm.No) (< $Perm.No $k@50@04)))
  
  ))))
(check-sat)
; unsat
(pop) ; 2
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               568
;  :arith-add-rows          190
;  :arith-assert-diseq      29
;  :arith-assert-lower      165
;  :arith-assert-upper      96
;  :arith-bound-prop        53
;  :arith-conflicts         20
;  :arith-eq-adapter        98
;  :arith-fixed-eqs         43
;  :arith-offset-eqs        34
;  :arith-pivots            142
;  :conflicts               65
;  :datatype-accessor-ax    24
;  :datatype-constructor-ax 18
;  :datatype-occurs-check   41
;  :datatype-splits         18
;  :decisions               72
;  :del-clause              563
;  :final-checks            22
;  :max-generation          3
;  :max-memory              4.84
;  :memory                  4.78
;  :mk-bool-var             1430
;  :mk-clause               569
;  :num-allocs              183460
;  :num-checks              52
;  :propagations            281
;  :quant-instantiations    278
;  :rlimit-count            230060)
; Check receiver injectivity
(push) ; 2
(assert (not (forall ((i11@48@04 Int) (j11@49@04 Int) (i12@48@04 Int) (j12@49@04 Int)) (!
  (implies
    (and
      (and
        (and
          (and
            (and (< j11@49@04 V@28@04) (<= 0 j11@49@04))
            (< i11@48@04 V@28@04))
          (<= 0 i11@48@04))
        (< $Perm.No $k@50@04))
      (and
        (and
          (and
            (and (< j12@49@04 V@28@04) (<= 0 j12@49@04))
            (< i12@48@04 V@28@04))
          (<= 0 i12@48@04))
        (< $Perm.No $k@50@04))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@26@04) i11@48@04))) j11@49@04)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@26@04) i12@48@04))) j12@49@04)))
    (and (= i11@48@04 i12@48@04) (= j11@49@04 j12@49@04)))
  
  :qid |int-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 2
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               649
;  :arith-add-rows          242
;  :arith-assert-diseq      31
;  :arith-assert-lower      184
;  :arith-assert-upper      113
;  :arith-bound-prop        57
;  :arith-conflicts         23
;  :arith-eq-adapter        105
;  :arith-fixed-eqs         49
;  :arith-offset-eqs        44
;  :arith-pivots            170
;  :conflicts               70
;  :datatype-accessor-ax    24
;  :datatype-constructor-ax 18
;  :datatype-occurs-check   41
;  :datatype-splits         18
;  :decisions               78
;  :del-clause              645
;  :final-checks            22
;  :max-generation          3
;  :max-memory              4.86
;  :memory                  4.85
;  :mk-bool-var             1591
;  :mk-clause               651
;  :num-allocs              184645
;  :num-checks              53
;  :propagations            325
;  :quant-instantiations    348
;  :rlimit-count            234645
;  :time                    0.00)
; Definitional axioms for inverse functions
(assert (forall ((i1@48@04 Int) (j1@49@04 Int)) (!
  (implies
    (and
      (and
        (and (and (< j1@49@04 V@28@04) (<= 0 j1@49@04)) (< i1@48@04 V@28@04))
        (<= 0 i1@48@04))
      (< $Perm.No $k@50@04))
    (and
      (=
        (inv@51@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@48@04))) j1@49@04))
        i1@48@04)
      (=
        (inv@52@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@48@04))) j1@49@04))
        j1@49@04)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@48@04))) j1@49@04))
  )))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and
          (and (< (inv@52@04 r) V@28@04) (<= 0 (inv@52@04 r)))
          (< (inv@51@04 r) V@28@04))
        (<= 0 (inv@51@04 r)))
      (< $Perm.No $k@50@04))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@26@04) (inv@51@04 r)))) (inv@52@04 r))
      r))
  :pattern ((inv@51@04 r))
  :pattern ((inv@52@04 r))
  :qid |int-fctOfInv|)))
; Permissions are non-negative
(assert (forall ((i1@48@04 Int) (j1@49@04 Int)) (!
  (<= $Perm.No $k@50@04)
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@48@04))) j1@49@04))
  :qid |int-permAtLeastZero|)))
; Field permissions are at most one
(assert (forall ((i1@48@04 Int) (j1@49@04 Int)) (!
  (<= $k@50@04 $Perm.Write)
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@48@04))) j1@49@04))
  :qid |int-permAtMostOne|)))
; Permission implies non-null receiver
(assert (forall ((i1@48@04 Int) (j1@49@04 Int)) (!
  (implies
    (and
      (and
        (and (and (< j1@49@04 V@28@04) (<= 0 j1@49@04)) (< i1@48@04 V@28@04))
        (<= 0 i1@48@04))
      (< $Perm.No $k@50@04))
    (not
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@48@04))) j1@49@04)
        $Ref.null)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@48@04))) j1@49@04))
  :qid |int-permImpliesNonNull|)))
(declare-const sm@53@04 $FVF<Int>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and
        (and
          (and (< (inv@52@04 r) V@28@04) (<= 0 (inv@52@04 r)))
          (< (inv@51@04 r) V@28@04))
        (<= 0 (inv@51@04 r)))
      (< $Perm.No $k@50@04)
      false)
    (=
      ($FVF.lookup_int (as sm@53@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@31@04))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@53@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@31@04))))))))))))))) r))
  :qid |qp.fvfValDef9|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@31@04))))))))))))))) r) r)
  :pattern (($FVF.lookup_int (as sm@53@04  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef10|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@52@04 r) V@28@04) (<= 0 (inv@52@04 r)))
        (< (inv@51@04 r) V@28@04))
      (<= 0 (inv@51@04 r)))
    ($FVF.loc_int ($FVF.lookup_int (as sm@53@04  $FVF<Int>) r) r))
  :pattern ((inv@51@04 r) (inv@52@04 r))
  )))
(declare-const i1@54@04 Int)
(declare-const j1@55@04 Int)
(push) ; 2
; [eval] 0 <= i1 && i1 < V && (0 <= j1 && j1 < V)
; [eval] 0 <= i1
(push) ; 3
; [then-branch: 35 | 0 <= i1@54@04 | live]
; [else-branch: 35 | !(0 <= i1@54@04) | live]
(push) ; 4
; [then-branch: 35 | 0 <= i1@54@04]
(assert (<= 0 i1@54@04))
; [eval] i1 < V
(push) ; 5
; [then-branch: 36 | i1@54@04 < V@28@04 | live]
; [else-branch: 36 | !(i1@54@04 < V@28@04) | live]
(push) ; 6
; [then-branch: 36 | i1@54@04 < V@28@04]
(assert (< i1@54@04 V@28@04))
; [eval] 0 <= j1
(push) ; 7
; [then-branch: 37 | 0 <= j1@55@04 | live]
; [else-branch: 37 | !(0 <= j1@55@04) | live]
(push) ; 8
; [then-branch: 37 | 0 <= j1@55@04]
(assert (<= 0 j1@55@04))
; [eval] j1 < V
(pop) ; 8
(push) ; 8
; [else-branch: 37 | !(0 <= j1@55@04)]
(assert (not (<= 0 j1@55@04)))
(pop) ; 8
(pop) ; 7
; Joined path conditions
; Joined path conditions
(pop) ; 6
(push) ; 6
; [else-branch: 36 | !(i1@54@04 < V@28@04)]
(assert (not (< i1@54@04 V@28@04)))
(pop) ; 6
(pop) ; 5
; Joined path conditions
; Joined path conditions
(pop) ; 4
(push) ; 4
; [else-branch: 35 | !(0 <= i1@54@04)]
(assert (not (<= 0 i1@54@04)))
(pop) ; 4
(pop) ; 3
; Joined path conditions
; Joined path conditions
(assert (and
  (and (and (< j1@55@04 V@28@04) (<= 0 j1@55@04)) (< i1@54@04 V@28@04))
  (<= 0 i1@54@04)))
; [eval] aloc(opt_get1(aloc(opt_get1(target), i1).option$array$), j1)
; [eval] opt_get1(aloc(opt_get1(target), i1).option$array$)
; [eval] aloc(opt_get1(target), i1)
; [eval] opt_get1(target)
(push) ; 3
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 3
; Joined path conditions
(push) ; 3
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 4
(assert (not (< i1@54@04 (alen<Int> (opt_get1 $Snap.unit target@27@04)))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               651
;  :arith-add-rows          248
;  :arith-assert-diseq      31
;  :arith-assert-lower      192
;  :arith-assert-upper      116
;  :arith-bound-prop        57
;  :arith-conflicts         23
;  :arith-eq-adapter        107
;  :arith-fixed-eqs         51
;  :arith-offset-eqs        44
;  :arith-pivots            177
;  :conflicts               70
;  :datatype-accessor-ax    24
;  :datatype-constructor-ax 18
;  :datatype-occurs-check   41
;  :datatype-splits         18
;  :decisions               78
;  :del-clause              645
;  :final-checks            22
;  :max-generation          3
;  :max-memory              4.86
;  :memory                  4.86
;  :mk-bool-var             1608
;  :mk-clause               651
;  :num-allocs              186098
;  :num-checks              54
;  :propagations            325
;  :quant-instantiations    348
;  :rlimit-count            238474)
(assert (< i1@54@04 (alen<Int> (opt_get1 $Snap.unit target@27@04))))
(pop) ; 3
; Joined path conditions
(assert (< i1@54@04 (alen<Int> (opt_get1 $Snap.unit target@27@04))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@54@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@54@04)))
(push) ; 3
(assert (not (<
  $Perm.No
  (+
    (ite
      (and
        (<
          (inv@42@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@54@04))
          V@28@04)
        (<=
          0
          (inv@42@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@54@04))))
      $k@41@04
      $Perm.No)
    (ite
      (and
        (<
          (inv@34@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@54@04))
          V@28@04)
        (<=
          0
          (inv@34@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@54@04))))
      $k@33@04
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               681
;  :arith-add-rows          259
;  :arith-assert-diseq      34
;  :arith-assert-lower      202
;  :arith-assert-upper      125
;  :arith-bound-prop        61
;  :arith-conflicts         26
;  :arith-eq-adapter        116
;  :arith-fixed-eqs         54
;  :arith-offset-eqs        47
;  :arith-pivots            184
;  :conflicts               74
;  :datatype-accessor-ax    24
;  :datatype-constructor-ax 18
;  :datatype-occurs-check   41
;  :datatype-splits         18
;  :decisions               81
;  :del-clause              664
;  :final-checks            22
;  :max-generation          3
;  :max-memory              4.88
;  :memory                  4.87
;  :mk-bool-var             1679
;  :mk-clause               690
;  :num-allocs              186606
;  :num-checks              55
;  :propagations            345
;  :quant-instantiations    371
;  :rlimit-count            240042)
(push) ; 3
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 4
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@54@04))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               681
;  :arith-add-rows          259
;  :arith-assert-diseq      34
;  :arith-assert-lower      202
;  :arith-assert-upper      125
;  :arith-bound-prop        61
;  :arith-conflicts         26
;  :arith-eq-adapter        116
;  :arith-fixed-eqs         54
;  :arith-offset-eqs        47
;  :arith-pivots            184
;  :conflicts               75
;  :datatype-accessor-ax    24
;  :datatype-constructor-ax 18
;  :datatype-occurs-check   41
;  :datatype-splits         18
;  :decisions               81
;  :del-clause              664
;  :final-checks            22
;  :max-generation          3
;  :max-memory              4.88
;  :memory                  4.87
;  :mk-bool-var             1679
;  :mk-clause               690
;  :num-allocs              186695
;  :num-checks              56
;  :propagations            345
;  :quant-instantiations    371
;  :rlimit-count            240137)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@54@04))
    (as None<option<array>>  option<array>))))
(pop) ; 3
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@54@04))
    (as None<option<array>>  option<array>))))
(push) ; 3
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 4
(assert (not (<
  j1@55@04
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@54@04)))))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               687
;  :arith-add-rows          262
;  :arith-assert-diseq      34
;  :arith-assert-lower      205
;  :arith-assert-upper      126
;  :arith-bound-prop        61
;  :arith-conflicts         27
;  :arith-eq-adapter        117
;  :arith-fixed-eqs         55
;  :arith-offset-eqs        47
;  :arith-pivots            186
;  :conflicts               76
;  :datatype-accessor-ax    24
;  :datatype-constructor-ax 18
;  :datatype-occurs-check   41
;  :datatype-splits         18
;  :decisions               81
;  :del-clause              668
;  :final-checks            22
;  :max-generation          3
;  :max-memory              4.88
;  :memory                  4.87
;  :mk-bool-var             1690
;  :mk-clause               694
;  :num-allocs              186898
;  :num-checks              57
;  :propagations            347
;  :quant-instantiations    378
;  :rlimit-count            240587)
(assert (<
  j1@55@04
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@54@04))))))
(pop) ; 3
; Joined path conditions
(assert (<
  j1@55@04
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@54@04))))))
(pop) ; 2
(declare-fun inv@56@04 ($Ref) Int)
(declare-fun inv@57@04 ($Ref) Int)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(assert (forall ((i1@54@04 Int) (j1@55@04 Int)) (!
  (and
    (< i1@54@04 (alen<Int> (opt_get1 $Snap.unit target@27@04)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@54@04)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@54@04))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@54@04))
        (as None<option<array>>  option<array>)))
    (<
      j1@55@04
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@54@04))))))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@54@04))) j1@55@04))
  :qid |int-aux|)))
; Check receiver injectivity
(push) ; 2
(assert (not (forall ((i11@54@04 Int) (j11@55@04 Int) (i12@54@04 Int) (j12@55@04 Int)) (!
  (implies
    (and
      (and
        (and (and (< j11@55@04 V@28@04) (<= 0 j11@55@04)) (< i11@54@04 V@28@04))
        (<= 0 i11@54@04))
      (and
        (and (and (< j12@55@04 V@28@04) (<= 0 j12@55@04)) (< i12@54@04 V@28@04))
        (<= 0 i12@54@04))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@27@04) i11@54@04))) j11@55@04)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@27@04) i12@54@04))) j12@55@04)))
    (and (= i11@54@04 i12@54@04) (= j11@55@04 j12@55@04)))
  
  :qid |int-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 2
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               737
;  :arith-add-rows          297
;  :arith-assert-diseq      34
;  :arith-assert-lower      218
;  :arith-assert-upper      131
;  :arith-bound-prop        65
;  :arith-conflicts         27
;  :arith-eq-adapter        124
;  :arith-fixed-eqs         58
;  :arith-offset-eqs        53
;  :arith-pivots            208
;  :conflicts               77
;  :datatype-accessor-ax    24
;  :datatype-constructor-ax 18
;  :datatype-occurs-check   41
;  :datatype-splits         18
;  :decisions               81
;  :del-clause              766
;  :final-checks            22
;  :max-generation          3
;  :max-memory              4.94
;  :memory                  4.93
;  :mk-bool-var             1848
;  :mk-clause               772
;  :num-allocs              188111
;  :num-checks              58
;  :propagations            381
;  :quant-instantiations    443
;  :rlimit-count            244836
;  :time                    0.00)
; Definitional axioms for inverse functions
(assert (forall ((i1@54@04 Int) (j1@55@04 Int)) (!
  (implies
    (and
      (and (and (< j1@55@04 V@28@04) (<= 0 j1@55@04)) (< i1@54@04 V@28@04))
      (<= 0 i1@54@04))
    (and
      (=
        (inv@56@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@54@04))) j1@55@04))
        i1@54@04)
      (=
        (inv@57@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@54@04))) j1@55@04))
        j1@55@04)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@54@04))) j1@55@04))
  )))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@57@04 r) V@28@04) (<= 0 (inv@57@04 r)))
        (< (inv@56@04 r) V@28@04))
      (<= 0 (inv@56@04 r)))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@27@04) (inv@56@04 r)))) (inv@57@04 r))
      r))
  :pattern ((inv@56@04 r))
  :pattern ((inv@57@04 r))
  :qid |int-fctOfInv|)))
; Permissions are non-negative
; Field permissions are at most one
; Permission implies non-null receiver
(assert (forall ((i1@54@04 Int) (j1@55@04 Int)) (!
  (implies
    (and
      (and (and (< j1@55@04 V@28@04) (<= 0 j1@55@04)) (< i1@54@04 V@28@04))
      (<= 0 i1@54@04))
    (not
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@54@04))) j1@55@04)
        $Ref.null)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@54@04))) j1@55@04))
  :qid |int-permImpliesNonNull|)))
(declare-const sm@58@04 $FVF<Int>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@57@04 r) V@28@04) (<= 0 (inv@57@04 r)))
        (< (inv@56@04 r) V@28@04))
      (<= 0 (inv@56@04 r)))
    (=
      ($FVF.lookup_int (as sm@58@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@31@04))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@58@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@31@04))))))))))))))) r))
  :qid |qp.fvfValDef11|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and
        (and
          (and (< (inv@52@04 r) V@28@04) (<= 0 (inv@52@04 r)))
          (< (inv@51@04 r) V@28@04))
        (<= 0 (inv@51@04 r)))
      (< $Perm.No $k@50@04)
      false)
    (=
      ($FVF.lookup_int (as sm@58@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@31@04))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@58@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@31@04))))))))))))))) r))
  :qid |qp.fvfValDef12|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@31@04))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@31@04))))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@58@04  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef13|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@57@04 r) V@28@04) (<= 0 (inv@57@04 r)))
        (< (inv@56@04 r) V@28@04))
      (<= 0 (inv@56@04 r)))
    ($FVF.loc_int ($FVF.lookup_int (as sm@58@04  $FVF<Int>) r) r))
  :pattern ((inv@56@04 r) (inv@57@04 r))
  )))
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
(push) ; 2
(declare-const $t@59@04 $Snap)
(assert (= $t@59@04 ($Snap.combine ($Snap.first $t@59@04) ($Snap.second $t@59@04))))
(assert (= ($Snap.first $t@59@04) $Snap.unit))
; [eval] exc == null
(assert (= exc@29@04 $Ref.null))
(assert (=
  ($Snap.second $t@59@04)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@59@04))
    ($Snap.second ($Snap.second $t@59@04)))))
(assert (= ($Snap.first ($Snap.second $t@59@04)) $Snap.unit))
; [eval] exc == null ==> source != (None(): option[array])
; [eval] exc == null
(push) ; 3
(set-option :timeout 10)
(push) ; 4
(assert (not (not (= exc@29@04 $Ref.null))))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               776
;  :arith-add-rows          297
;  :arith-assert-diseq      34
;  :arith-assert-lower      218
;  :arith-assert-upper      131
;  :arith-bound-prop        65
;  :arith-conflicts         27
;  :arith-eq-adapter        124
;  :arith-fixed-eqs         58
;  :arith-offset-eqs        53
;  :arith-pivots            208
;  :conflicts               77
;  :datatype-accessor-ax    26
;  :datatype-constructor-ax 27
;  :datatype-occurs-check   47
;  :datatype-splits         23
;  :decisions               90
;  :del-clause              772
;  :final-checks            26
;  :max-generation          3
;  :max-memory              4.96
;  :memory                  4.95
;  :mk-bool-var             1865
;  :mk-clause               772
;  :num-allocs              190464
;  :num-checks              60
;  :propagations            381
;  :quant-instantiations    443
;  :rlimit-count            249801)
; [then-branch: 38 | exc@29@04 == Null | live]
; [else-branch: 38 | exc@29@04 != Null | dead]
(push) ; 4
; [then-branch: 38 | exc@29@04 == Null]
; [eval] source != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 4
(pop) ; 3
; Joined path conditions
(assert (implies
  (= exc@29@04 $Ref.null)
  (not (= source@26@04 (as None<option<array>>  option<array>)))))
(assert (=
  ($Snap.second ($Snap.second $t@59@04))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second $t@59@04)))
    ($Snap.second ($Snap.second ($Snap.second $t@59@04))))))
(assert (= ($Snap.first ($Snap.second ($Snap.second $t@59@04))) $Snap.unit))
; [eval] exc == null ==> alen(opt_get1(source)) == V
; [eval] exc == null
(push) ; 3
(push) ; 4
(assert (not (not (= exc@29@04 $Ref.null))))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               798
;  :arith-add-rows          297
;  :arith-assert-diseq      34
;  :arith-assert-lower      218
;  :arith-assert-upper      131
;  :arith-bound-prop        65
;  :arith-conflicts         27
;  :arith-eq-adapter        124
;  :arith-fixed-eqs         58
;  :arith-offset-eqs        53
;  :arith-pivots            208
;  :conflicts               77
;  :datatype-accessor-ax    27
;  :datatype-constructor-ax 32
;  :datatype-occurs-check   50
;  :datatype-splits         24
;  :decisions               95
;  :del-clause              772
;  :final-checks            28
;  :max-generation          3
;  :max-memory              4.96
;  :memory                  4.95
;  :mk-bool-var             1868
;  :mk-clause               772
;  :num-allocs              191101
;  :num-checks              61
;  :propagations            381
;  :quant-instantiations    443
;  :rlimit-count            250567)
; [then-branch: 39 | exc@29@04 == Null | live]
; [else-branch: 39 | exc@29@04 != Null | dead]
(push) ; 4
; [then-branch: 39 | exc@29@04 == Null]
; [eval] alen(opt_get1(source)) == V
; [eval] alen(opt_get1(source))
; [eval] opt_get1(source)
(push) ; 5
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 5
; Joined path conditions
(pop) ; 4
(pop) ; 3
; Joined path conditions
(assert (implies
  (= exc@29@04 $Ref.null)
  (= (alen<Int> (opt_get1 $Snap.unit source@26@04)) V@28@04)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second $t@59@04)))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@59@04))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@59@04)))))))
; [eval] exc == null
(push) ; 3
(assert (not (not (= exc@29@04 $Ref.null))))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               822
;  :arith-add-rows          297
;  :arith-assert-diseq      34
;  :arith-assert-lower      218
;  :arith-assert-upper      131
;  :arith-bound-prop        65
;  :arith-conflicts         27
;  :arith-eq-adapter        124
;  :arith-fixed-eqs         58
;  :arith-offset-eqs        53
;  :arith-pivots            208
;  :conflicts               77
;  :datatype-accessor-ax    28
;  :datatype-constructor-ax 38
;  :datatype-occurs-check   53
;  :datatype-splits         26
;  :decisions               101
;  :del-clause              772
;  :final-checks            30
;  :max-generation          3
;  :max-memory              4.96
;  :memory                  4.95
;  :mk-bool-var             1871
;  :mk-clause               772
;  :num-allocs              191742
;  :num-checks              62
;  :propagations            381
;  :quant-instantiations    443
;  :rlimit-count            251325)
; [then-branch: 40 | exc@29@04 == Null | live]
; [else-branch: 40 | exc@29@04 != Null | dead]
(push) ; 3
; [then-branch: 40 | exc@29@04 == Null]
(declare-const i1@60@04 Int)
(push) ; 4
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 5
; [then-branch: 41 | 0 <= i1@60@04 | live]
; [else-branch: 41 | !(0 <= i1@60@04) | live]
(push) ; 6
; [then-branch: 41 | 0 <= i1@60@04]
(assert (<= 0 i1@60@04))
; [eval] i1 < V
(pop) ; 6
(push) ; 6
; [else-branch: 41 | !(0 <= i1@60@04)]
(assert (not (<= 0 i1@60@04)))
(pop) ; 6
(pop) ; 5
; Joined path conditions
; Joined path conditions
(assert (and (< i1@60@04 V@28@04) (<= 0 i1@60@04)))
; [eval] aloc(opt_get1(source), i1)
; [eval] opt_get1(source)
(push) ; 5
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 5
; Joined path conditions
(push) ; 5
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 6
(assert (not (< i1@60@04 (alen<Int> (opt_get1 $Snap.unit source@26@04)))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               823
;  :arith-add-rows          299
;  :arith-assert-diseq      34
;  :arith-assert-lower      221
;  :arith-assert-upper      132
;  :arith-bound-prop        65
;  :arith-conflicts         27
;  :arith-eq-adapter        125
;  :arith-fixed-eqs         59
;  :arith-offset-eqs        53
;  :arith-pivots            209
;  :conflicts               77
;  :datatype-accessor-ax    28
;  :datatype-constructor-ax 38
;  :datatype-occurs-check   53
;  :datatype-splits         26
;  :decisions               101
;  :del-clause              772
;  :final-checks            30
;  :max-generation          3
;  :max-memory              4.96
;  :memory                  4.95
;  :mk-bool-var             1875
;  :mk-clause               772
;  :num-allocs              191858
;  :num-checks              63
;  :propagations            381
;  :quant-instantiations    443
;  :rlimit-count            251548)
(assert (< i1@60@04 (alen<Int> (opt_get1 $Snap.unit source@26@04))))
(pop) ; 5
; Joined path conditions
(assert (< i1@60@04 (alen<Int> (opt_get1 $Snap.unit source@26@04))))
(declare-const $k@61@04 $Perm)
(assert ($Perm.isReadVar $k@61@04 $Perm.Write))
(pop) ; 4
(declare-fun inv@62@04 ($Ref) Int)
; Nested auxiliary terms: globals
(assert ($Perm.isReadVar $k@61@04 $Perm.Write))
; Nested auxiliary terms: non-globals
(assert (forall ((i1@60@04 Int)) (!
  (< i1@60@04 (alen<Int> (opt_get1 $Snap.unit source@26@04)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@60@04))
  :qid |option$array$-aux|)))
(push) ; 4
(assert (not (forall ((i1@60@04 Int)) (!
  (implies
    (and (< i1@60@04 V@28@04) (<= 0 i1@60@04))
    (or (= $k@61@04 $Perm.No) (< $Perm.No $k@61@04)))
  
  ))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               823
;  :arith-add-rows          300
;  :arith-assert-diseq      35
;  :arith-assert-lower      223
;  :arith-assert-upper      133
;  :arith-bound-prop        65
;  :arith-conflicts         27
;  :arith-eq-adapter        126
;  :arith-fixed-eqs         59
;  :arith-offset-eqs        53
;  :arith-pivots            210
;  :conflicts               78
;  :datatype-accessor-ax    28
;  :datatype-constructor-ax 38
;  :datatype-occurs-check   53
;  :datatype-splits         26
;  :decisions               101
;  :del-clause              772
;  :final-checks            30
;  :max-generation          3
;  :max-memory              4.96
;  :memory                  4.95
;  :mk-bool-var             1882
;  :mk-clause               774
;  :num-allocs              192323
;  :num-checks              64
;  :propagations            382
;  :quant-instantiations    443
;  :rlimit-count            252137)
; Check receiver injectivity
(push) ; 4
(assert (not (forall ((i11@60@04 Int) (i12@60@04 Int)) (!
  (implies
    (and
      (and (and (< i11@60@04 V@28@04) (<= 0 i11@60@04)) (< $Perm.No $k@61@04))
      (and (and (< i12@60@04 V@28@04) (<= 0 i12@60@04)) (< $Perm.No $k@61@04))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i11@60@04)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i12@60@04)))
    (= i11@60@04 i12@60@04))
  
  :qid |option$array$-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               829
;  :arith-add-rows          305
;  :arith-assert-diseq      36
;  :arith-assert-lower      227
;  :arith-assert-upper      133
;  :arith-bound-prop        65
;  :arith-conflicts         27
;  :arith-eq-adapter        128
;  :arith-fixed-eqs         59
;  :arith-offset-eqs        53
;  :arith-pivots            212
;  :conflicts               79
;  :datatype-accessor-ax    28
;  :datatype-constructor-ax 38
;  :datatype-occurs-check   53
;  :datatype-splits         26
;  :decisions               101
;  :del-clause              779
;  :final-checks            30
;  :max-generation          3
;  :max-memory              4.96
;  :memory                  4.94
;  :mk-bool-var             1901
;  :mk-clause               781
;  :num-allocs              192695
;  :num-checks              65
;  :propagations            382
;  :quant-instantiations    454
;  :rlimit-count            252861)
; Definitional axioms for inverse functions
(assert (forall ((i1@60@04 Int)) (!
  (implies
    (and (and (< i1@60@04 V@28@04) (<= 0 i1@60@04)) (< $Perm.No $k@61@04))
    (=
      (inv@62@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@60@04))
      i1@60@04))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@60@04))
  )))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and (< (inv@62@04 r) V@28@04) (<= 0 (inv@62@04 r)))
      (< $Perm.No $k@61@04))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) (inv@62@04 r))
      r))
  :pattern ((inv@62@04 r))
  :qid |option$array$-fctOfInv|)))
; Permissions are non-negative
(assert (forall ((i1@60@04 Int)) (!
  (<= $Perm.No $k@61@04)
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@60@04))
  :qid |option$array$-permAtLeastZero|)))
; Field permissions are at most one
(assert (forall ((i1@60@04 Int)) (!
  (<= $k@61@04 $Perm.Write)
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@60@04))
  :qid |option$array$-permAtMostOne|)))
; Permission implies non-null receiver
(assert (forall ((i1@60@04 Int)) (!
  (implies
    (and (and (< i1@60@04 V@28@04) (<= 0 i1@60@04)) (< $Perm.No $k@61@04))
    (not
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@60@04)
        $Ref.null)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@60@04))
  :qid |option$array$-permImpliesNonNull|)))
(declare-const sm@63@04 $FVF<option<array>>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@62@04 r) V@28@04) (<= 0 (inv@62@04 r)))
      (< $Perm.No $k@61@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@63@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@59@04))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@63@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@59@04))))) r))
  :qid |qp.fvfValDef14|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@59@04))))) r) r)
  :pattern (($FVF.lookup_option$array$ (as sm@63@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef15|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@62@04 r) V@28@04) (<= 0 (inv@62@04 r)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@63@04  $FVF<option<array>>) r) r))
  :pattern ((inv@62@04 r))
  )))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@59@04))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@59@04)))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@59@04))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@59@04)))))
  $Snap.unit))
; [eval] exc == null ==> (forall i1: Int :: { aloc(opt_get1(source), i1) } 0 <= i1 && i1 < V ==> aloc(opt_get1(source), i1).option$array$ != (None(): option[array]))
; [eval] exc == null
(push) ; 4
(set-option :timeout 10)
(push) ; 5
(assert (not (not (= exc@29@04 $Ref.null))))
(check-sat)
; unknown
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               856
;  :arith-add-rows          305
;  :arith-assert-diseq      36
;  :arith-assert-lower      227
;  :arith-assert-upper      134
;  :arith-bound-prop        65
;  :arith-conflicts         27
;  :arith-eq-adapter        128
;  :arith-fixed-eqs         59
;  :arith-offset-eqs        53
;  :arith-pivots            212
;  :conflicts               79
;  :datatype-accessor-ax    29
;  :datatype-constructor-ax 44
;  :datatype-occurs-check   56
;  :datatype-splits         28
;  :decisions               107
;  :del-clause              779
;  :final-checks            32
;  :max-generation          3
;  :max-memory              4.96
;  :memory                  4.96
;  :mk-bool-var             1912
;  :mk-clause               781
;  :num-allocs              194334
;  :num-checks              66
;  :propagations            382
;  :quant-instantiations    454
;  :rlimit-count            255644)
; [then-branch: 42 | exc@29@04 == Null | live]
; [else-branch: 42 | exc@29@04 != Null | dead]
(push) ; 5
; [then-branch: 42 | exc@29@04 == Null]
; [eval] (forall i1: Int :: { aloc(opt_get1(source), i1) } 0 <= i1 && i1 < V ==> aloc(opt_get1(source), i1).option$array$ != (None(): option[array]))
(declare-const i1@64@04 Int)
(push) ; 6
; [eval] 0 <= i1 && i1 < V ==> aloc(opt_get1(source), i1).option$array$ != (None(): option[array])
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 7
; [then-branch: 43 | 0 <= i1@64@04 | live]
; [else-branch: 43 | !(0 <= i1@64@04) | live]
(push) ; 8
; [then-branch: 43 | 0 <= i1@64@04]
(assert (<= 0 i1@64@04))
; [eval] i1 < V
(pop) ; 8
(push) ; 8
; [else-branch: 43 | !(0 <= i1@64@04)]
(assert (not (<= 0 i1@64@04)))
(pop) ; 8
(pop) ; 7
; Joined path conditions
; Joined path conditions
(push) ; 7
; [then-branch: 44 | i1@64@04 < V@28@04 && 0 <= i1@64@04 | live]
; [else-branch: 44 | !(i1@64@04 < V@28@04 && 0 <= i1@64@04) | live]
(push) ; 8
; [then-branch: 44 | i1@64@04 < V@28@04 && 0 <= i1@64@04]
(assert (and (< i1@64@04 V@28@04) (<= 0 i1@64@04)))
; [eval] aloc(opt_get1(source), i1).option$array$ != (None(): option[array])
; [eval] aloc(opt_get1(source), i1)
; [eval] opt_get1(source)
(push) ; 9
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 9
; Joined path conditions
(push) ; 9
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 10
(assert (not (< i1@64@04 (alen<Int> (opt_get1 $Snap.unit source@26@04)))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               857
;  :arith-add-rows          308
;  :arith-assert-diseq      36
;  :arith-assert-lower      230
;  :arith-assert-upper      135
;  :arith-bound-prop        65
;  :arith-conflicts         27
;  :arith-eq-adapter        129
;  :arith-fixed-eqs         60
;  :arith-offset-eqs        53
;  :arith-pivots            214
;  :conflicts               79
;  :datatype-accessor-ax    29
;  :datatype-constructor-ax 44
;  :datatype-occurs-check   56
;  :datatype-splits         28
;  :decisions               107
;  :del-clause              779
;  :final-checks            32
;  :max-generation          3
;  :max-memory              4.96
;  :memory                  4.96
;  :mk-bool-var             1916
;  :mk-clause               781
;  :num-allocs              194450
;  :num-checks              67
;  :propagations            382
;  :quant-instantiations    454
;  :rlimit-count            255899)
(assert (< i1@64@04 (alen<Int> (opt_get1 $Snap.unit source@26@04))))
(pop) ; 9
; Joined path conditions
(assert (< i1@64@04 (alen<Int> (opt_get1 $Snap.unit source@26@04))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@63@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@64@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@64@04)))
(push) ; 9
(assert (not (ite
  (and
    (<
      (inv@62@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@64@04))
      V@28@04)
    (<=
      0
      (inv@62@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@64@04))))
  (< $Perm.No $k@61@04)
  false)))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               873
;  :arith-add-rows          321
;  :arith-assert-diseq      36
;  :arith-assert-lower      232
;  :arith-assert-upper      138
;  :arith-bound-prop        68
;  :arith-conflicts         28
;  :arith-eq-adapter        131
;  :arith-fixed-eqs         62
;  :arith-offset-eqs        58
;  :arith-pivots            217
;  :conflicts               80
;  :datatype-accessor-ax    29
;  :datatype-constructor-ax 44
;  :datatype-occurs-check   56
;  :datatype-splits         28
;  :decisions               107
;  :del-clause              779
;  :final-checks            32
;  :max-generation          4
;  :max-memory              4.98
;  :memory                  4.97
;  :mk-bool-var             1964
;  :mk-clause               802
;  :num-allocs              194884
;  :num-checks              68
;  :propagations            386
;  :quant-instantiations    478
;  :rlimit-count            257353)
; [eval] (None(): option[array])
(pop) ; 8
(push) ; 8
; [else-branch: 44 | !(i1@64@04 < V@28@04 && 0 <= i1@64@04)]
(assert (not (and (< i1@64@04 V@28@04) (<= 0 i1@64@04))))
(pop) ; 8
(pop) ; 7
; Joined path conditions
(assert (implies
  (and (< i1@64@04 V@28@04) (<= 0 i1@64@04))
  (and
    (< i1@64@04 V@28@04)
    (<= 0 i1@64@04)
    (< i1@64@04 (alen<Int> (opt_get1 $Snap.unit source@26@04)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@63@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@64@04)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@64@04)))))
; Joined path conditions
(pop) ; 6
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@64@04 Int)) (!
  (implies
    (and (< i1@64@04 V@28@04) (<= 0 i1@64@04))
    (and
      (< i1@64@04 V@28@04)
      (<= 0 i1@64@04)
      (< i1@64@04 (alen<Int> (opt_get1 $Snap.unit source@26@04)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@63@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@64@04)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@64@04))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@64@04))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (implies
  (= exc@29@04 $Ref.null)
  (forall ((i1@64@04 Int)) (!
    (implies
      (and (< i1@64@04 V@28@04) (<= 0 i1@64@04))
      (and
        (< i1@64@04 V@28@04)
        (<= 0 i1@64@04)
        (< i1@64@04 (alen<Int> (opt_get1 $Snap.unit source@26@04)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@63@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@64@04)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@64@04))))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@64@04))
    :qid |prog.l<no position>-aux|))))
(assert (implies
  (= exc@29@04 $Ref.null)
  (forall ((i1@64@04 Int)) (!
    (implies
      (and (< i1@64@04 V@28@04) (<= 0 i1@64@04))
      (not
        (=
          ($FVF.lookup_option$array$ (as sm@63@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@64@04))
          (as None<option<array>>  option<array>))))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@64@04))
    :qid |prog.l<no position>|))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@59@04)))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@59@04))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@59@04)))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@59@04))))))
  $Snap.unit))
; [eval] exc == null ==> (forall i1: Int :: { alen(opt_get1(aloc(opt_get1(source), i1).option$array$)) } 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(source), i1).option$array$)) == V)
; [eval] exc == null
(push) ; 4
(set-option :timeout 10)
(push) ; 5
(assert (not (not (= exc@29@04 $Ref.null))))
(check-sat)
; unknown
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               901
;  :arith-add-rows          325
;  :arith-assert-diseq      36
;  :arith-assert-lower      232
;  :arith-assert-upper      138
;  :arith-bound-prop        68
;  :arith-conflicts         28
;  :arith-eq-adapter        131
;  :arith-fixed-eqs         62
;  :arith-offset-eqs        58
;  :arith-pivots            221
;  :conflicts               80
;  :datatype-accessor-ax    30
;  :datatype-constructor-ax 50
;  :datatype-occurs-check   59
;  :datatype-splits         30
;  :decisions               113
;  :del-clause              800
;  :final-checks            34
;  :max-generation          4
;  :max-memory              4.98
;  :memory                  4.97
;  :mk-bool-var             1970
;  :mk-clause               802
;  :num-allocs              195916
;  :num-checks              69
;  :propagations            386
;  :quant-instantiations    478
;  :rlimit-count            259036)
; [then-branch: 45 | exc@29@04 == Null | live]
; [else-branch: 45 | exc@29@04 != Null | dead]
(push) ; 5
; [then-branch: 45 | exc@29@04 == Null]
; [eval] (forall i1: Int :: { alen(opt_get1(aloc(opt_get1(source), i1).option$array$)) } 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(source), i1).option$array$)) == V)
(declare-const i1@65@04 Int)
(push) ; 6
; [eval] 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(source), i1).option$array$)) == V
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 7
; [then-branch: 46 | 0 <= i1@65@04 | live]
; [else-branch: 46 | !(0 <= i1@65@04) | live]
(push) ; 8
; [then-branch: 46 | 0 <= i1@65@04]
(assert (<= 0 i1@65@04))
; [eval] i1 < V
(pop) ; 8
(push) ; 8
; [else-branch: 46 | !(0 <= i1@65@04)]
(assert (not (<= 0 i1@65@04)))
(pop) ; 8
(pop) ; 7
; Joined path conditions
; Joined path conditions
(push) ; 7
; [then-branch: 47 | i1@65@04 < V@28@04 && 0 <= i1@65@04 | live]
; [else-branch: 47 | !(i1@65@04 < V@28@04 && 0 <= i1@65@04) | live]
(push) ; 8
; [then-branch: 47 | i1@65@04 < V@28@04 && 0 <= i1@65@04]
(assert (and (< i1@65@04 V@28@04) (<= 0 i1@65@04)))
; [eval] alen(opt_get1(aloc(opt_get1(source), i1).option$array$)) == V
; [eval] alen(opt_get1(aloc(opt_get1(source), i1).option$array$))
; [eval] opt_get1(aloc(opt_get1(source), i1).option$array$)
; [eval] aloc(opt_get1(source), i1)
; [eval] opt_get1(source)
(push) ; 9
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 9
; Joined path conditions
(push) ; 9
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 10
(assert (not (< i1@65@04 (alen<Int> (opt_get1 $Snap.unit source@26@04)))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               902
;  :arith-add-rows          328
;  :arith-assert-diseq      36
;  :arith-assert-lower      235
;  :arith-assert-upper      139
;  :arith-bound-prop        68
;  :arith-conflicts         28
;  :arith-eq-adapter        132
;  :arith-fixed-eqs         63
;  :arith-offset-eqs        58
;  :arith-pivots            223
;  :conflicts               80
;  :datatype-accessor-ax    30
;  :datatype-constructor-ax 50
;  :datatype-occurs-check   59
;  :datatype-splits         30
;  :decisions               113
;  :del-clause              800
;  :final-checks            34
;  :max-generation          4
;  :max-memory              4.98
;  :memory                  4.98
;  :mk-bool-var             1974
;  :mk-clause               802
;  :num-allocs              196032
;  :num-checks              70
;  :propagations            386
;  :quant-instantiations    478
;  :rlimit-count            259291)
(assert (< i1@65@04 (alen<Int> (opt_get1 $Snap.unit source@26@04))))
(pop) ; 9
; Joined path conditions
(assert (< i1@65@04 (alen<Int> (opt_get1 $Snap.unit source@26@04))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@63@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@65@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@65@04)))
(push) ; 9
(assert (not (ite
  (and
    (<
      (inv@62@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@65@04))
      V@28@04)
    (<=
      0
      (inv@62@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@65@04))))
  (< $Perm.No $k@61@04)
  false)))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               919
;  :arith-add-rows          341
;  :arith-assert-diseq      36
;  :arith-assert-lower      237
;  :arith-assert-upper      142
;  :arith-bound-prop        71
;  :arith-conflicts         29
;  :arith-eq-adapter        134
;  :arith-fixed-eqs         65
;  :arith-offset-eqs        63
;  :arith-pivots            226
;  :conflicts               81
;  :datatype-accessor-ax    30
;  :datatype-constructor-ax 50
;  :datatype-occurs-check   59
;  :datatype-splits         30
;  :decisions               113
;  :del-clause              800
;  :final-checks            34
;  :max-generation          4
;  :max-memory              4.99
;  :memory                  4.98
;  :mk-bool-var             2025
;  :mk-clause               823
;  :num-allocs              196470
;  :num-checks              71
;  :propagations            390
;  :quant-instantiations    504
;  :rlimit-count            260774)
(push) ; 9
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 10
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@63@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@65@04))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               919
;  :arith-add-rows          341
;  :arith-assert-diseq      36
;  :arith-assert-lower      237
;  :arith-assert-upper      142
;  :arith-bound-prop        71
;  :arith-conflicts         29
;  :arith-eq-adapter        134
;  :arith-fixed-eqs         65
;  :arith-offset-eqs        63
;  :arith-pivots            226
;  :conflicts               82
;  :datatype-accessor-ax    30
;  :datatype-constructor-ax 50
;  :datatype-occurs-check   59
;  :datatype-splits         30
;  :decisions               113
;  :del-clause              800
;  :final-checks            34
;  :max-generation          4
;  :max-memory              4.99
;  :memory                  4.98
;  :mk-bool-var             2025
;  :mk-clause               823
;  :num-allocs              196559
;  :num-checks              72
;  :propagations            390
;  :quant-instantiations    504
;  :rlimit-count            260869)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@63@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@65@04))
    (as None<option<array>>  option<array>))))
(pop) ; 9
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@63@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@65@04))
    (as None<option<array>>  option<array>))))
(pop) ; 8
(push) ; 8
; [else-branch: 47 | !(i1@65@04 < V@28@04 && 0 <= i1@65@04)]
(assert (not (and (< i1@65@04 V@28@04) (<= 0 i1@65@04))))
(pop) ; 8
(pop) ; 7
; Joined path conditions
(assert (implies
  (and (< i1@65@04 V@28@04) (<= 0 i1@65@04))
  (and
    (< i1@65@04 V@28@04)
    (<= 0 i1@65@04)
    (< i1@65@04 (alen<Int> (opt_get1 $Snap.unit source@26@04)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@63@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@65@04)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@65@04))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@63@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@65@04))
        (as None<option<array>>  option<array>))))))
; Joined path conditions
(pop) ; 6
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@65@04 Int)) (!
  (implies
    (and (< i1@65@04 V@28@04) (<= 0 i1@65@04))
    (and
      (< i1@65@04 V@28@04)
      (<= 0 i1@65@04)
      (< i1@65@04 (alen<Int> (opt_get1 $Snap.unit source@26@04)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@63@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@65@04)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@65@04))
      (not
        (=
          ($FVF.lookup_option$array$ (as sm@63@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@65@04))
          (as None<option<array>>  option<array>)))))
  :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@63@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@65@04)))))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (implies
  (= exc@29@04 $Ref.null)
  (forall ((i1@65@04 Int)) (!
    (implies
      (and (< i1@65@04 V@28@04) (<= 0 i1@65@04))
      (and
        (< i1@65@04 V@28@04)
        (<= 0 i1@65@04)
        (< i1@65@04 (alen<Int> (opt_get1 $Snap.unit source@26@04)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@63@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@65@04)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@65@04))
        (not
          (=
            ($FVF.lookup_option$array$ (as sm@63@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@65@04))
            (as None<option<array>>  option<array>)))))
    :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@63@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@65@04)))))
    :qid |prog.l<no position>-aux|))))
(assert (implies
  (= exc@29@04 $Ref.null)
  (forall ((i1@65@04 Int)) (!
    (implies
      (and (< i1@65@04 V@28@04) (<= 0 i1@65@04))
      (=
        (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@63@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@65@04))))
        V@28@04))
    :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@63@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@65@04)))))
    :qid |prog.l<no position>|))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@59@04))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@59@04)))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@59@04))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@59@04)))))))
  $Snap.unit))
; [eval] exc == null ==> (forall i1: Int :: { aloc(opt_get1(source), i1) } (forall i2: Int :: { aloc(opt_get1(source), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(source), i1).option$array$ == aloc(opt_get1(source), i2).option$array$ ==> i1 == i2))
; [eval] exc == null
(push) ; 4
(set-option :timeout 10)
(push) ; 5
(assert (not (not (= exc@29@04 $Ref.null))))
(check-sat)
; unknown
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               948
;  :arith-add-rows          345
;  :arith-assert-diseq      36
;  :arith-assert-lower      237
;  :arith-assert-upper      142
;  :arith-bound-prop        71
;  :arith-conflicts         29
;  :arith-eq-adapter        134
;  :arith-fixed-eqs         65
;  :arith-offset-eqs        63
;  :arith-pivots            230
;  :conflicts               82
;  :datatype-accessor-ax    31
;  :datatype-constructor-ax 56
;  :datatype-occurs-check   62
;  :datatype-splits         32
;  :decisions               119
;  :del-clause              821
;  :final-checks            36
;  :max-generation          4
;  :max-memory              5.00
;  :memory                  4.99
;  :mk-bool-var             2031
;  :mk-clause               823
;  :num-allocs              197614
;  :num-checks              73
;  :propagations            390
;  :quant-instantiations    504
;  :rlimit-count            262657)
; [then-branch: 48 | exc@29@04 == Null | live]
; [else-branch: 48 | exc@29@04 != Null | dead]
(push) ; 5
; [then-branch: 48 | exc@29@04 == Null]
; [eval] (forall i1: Int :: { aloc(opt_get1(source), i1) } (forall i2: Int :: { aloc(opt_get1(source), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(source), i1).option$array$ == aloc(opt_get1(source), i2).option$array$ ==> i1 == i2))
(declare-const i1@66@04 Int)
(push) ; 6
; [eval] (forall i2: Int :: { aloc(opt_get1(source), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(source), i1).option$array$ == aloc(opt_get1(source), i2).option$array$ ==> i1 == i2)
(declare-const i2@67@04 Int)
(push) ; 7
; [eval] 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(source), i1).option$array$ == aloc(opt_get1(source), i2).option$array$ ==> i1 == i2
; [eval] 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(source), i1).option$array$ == aloc(opt_get1(source), i2).option$array$
; [eval] 0 <= i1
(push) ; 8
; [then-branch: 49 | 0 <= i1@66@04 | live]
; [else-branch: 49 | !(0 <= i1@66@04) | live]
(push) ; 9
; [then-branch: 49 | 0 <= i1@66@04]
(assert (<= 0 i1@66@04))
; [eval] i1 < V
(push) ; 10
; [then-branch: 50 | i1@66@04 < V@28@04 | live]
; [else-branch: 50 | !(i1@66@04 < V@28@04) | live]
(push) ; 11
; [then-branch: 50 | i1@66@04 < V@28@04]
(assert (< i1@66@04 V@28@04))
; [eval] 0 <= i2
(push) ; 12
; [then-branch: 51 | 0 <= i2@67@04 | live]
; [else-branch: 51 | !(0 <= i2@67@04) | live]
(push) ; 13
; [then-branch: 51 | 0 <= i2@67@04]
(assert (<= 0 i2@67@04))
; [eval] i2 < V
(push) ; 14
; [then-branch: 52 | i2@67@04 < V@28@04 | live]
; [else-branch: 52 | !(i2@67@04 < V@28@04) | live]
(push) ; 15
; [then-branch: 52 | i2@67@04 < V@28@04]
(assert (< i2@67@04 V@28@04))
; [eval] aloc(opt_get1(source), i1).option$array$ == aloc(opt_get1(source), i2).option$array$
; [eval] aloc(opt_get1(source), i1)
; [eval] opt_get1(source)
(push) ; 16
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 16
; Joined path conditions
(push) ; 16
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 17
(assert (not (< i1@66@04 (alen<Int> (opt_get1 $Snap.unit source@26@04)))))
(check-sat)
; unsat
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               949
;  :arith-add-rows          349
;  :arith-assert-diseq      36
;  :arith-assert-lower      242
;  :arith-assert-upper      143
;  :arith-bound-prop        71
;  :arith-conflicts         29
;  :arith-eq-adapter        135
;  :arith-fixed-eqs         66
;  :arith-offset-eqs        63
;  :arith-pivots            232
;  :conflicts               82
;  :datatype-accessor-ax    31
;  :datatype-constructor-ax 56
;  :datatype-occurs-check   62
;  :datatype-splits         32
;  :decisions               119
;  :del-clause              821
;  :final-checks            36
;  :max-generation          4
;  :max-memory              5.00
;  :memory                  5.00
;  :mk-bool-var             2037
;  :mk-clause               823
;  :num-allocs              197908
;  :num-checks              74
;  :propagations            390
;  :quant-instantiations    504
;  :rlimit-count            263058)
(assert (< i1@66@04 (alen<Int> (opt_get1 $Snap.unit source@26@04))))
(pop) ; 16
; Joined path conditions
(assert (< i1@66@04 (alen<Int> (opt_get1 $Snap.unit source@26@04))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@63@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@66@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@66@04)))
(push) ; 16
(assert (not (ite
  (and
    (<
      (inv@62@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@66@04))
      V@28@04)
    (<=
      0
      (inv@62@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@66@04))))
  (< $Perm.No $k@61@04)
  false)))
(check-sat)
; unsat
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               967
;  :arith-add-rows          362
;  :arith-assert-diseq      36
;  :arith-assert-lower      244
;  :arith-assert-upper      146
;  :arith-bound-prop        74
;  :arith-conflicts         30
;  :arith-eq-adapter        137
;  :arith-fixed-eqs         68
;  :arith-offset-eqs        68
;  :arith-pivots            235
;  :conflicts               83
;  :datatype-accessor-ax    31
;  :datatype-constructor-ax 56
;  :datatype-occurs-check   62
;  :datatype-splits         32
;  :decisions               119
;  :del-clause              821
;  :final-checks            36
;  :max-generation          4
;  :max-memory              5.01
;  :memory                  4.99
;  :mk-bool-var             2089
;  :mk-clause               844
;  :num-allocs              198338
;  :num-checks              75
;  :propagations            394
;  :quant-instantiations    530
;  :rlimit-count            264543)
; [eval] aloc(opt_get1(source), i2)
; [eval] opt_get1(source)
(push) ; 16
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 16
; Joined path conditions
(push) ; 16
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 17
(assert (not (< i2@67@04 (alen<Int> (opt_get1 $Snap.unit source@26@04)))))
(check-sat)
; unsat
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               967
;  :arith-add-rows          362
;  :arith-assert-diseq      36
;  :arith-assert-lower      244
;  :arith-assert-upper      146
;  :arith-bound-prop        74
;  :arith-conflicts         30
;  :arith-eq-adapter        137
;  :arith-fixed-eqs         68
;  :arith-offset-eqs        68
;  :arith-pivots            235
;  :conflicts               83
;  :datatype-accessor-ax    31
;  :datatype-constructor-ax 56
;  :datatype-occurs-check   62
;  :datatype-splits         32
;  :decisions               119
;  :del-clause              821
;  :final-checks            36
;  :max-generation          4
;  :max-memory              5.01
;  :memory                  4.99
;  :mk-bool-var             2089
;  :mk-clause               844
;  :num-allocs              198363
;  :num-checks              76
;  :propagations            394
;  :quant-instantiations    530
;  :rlimit-count            264573)
(assert (< i2@67@04 (alen<Int> (opt_get1 $Snap.unit source@26@04))))
(pop) ; 16
; Joined path conditions
(assert (< i2@67@04 (alen<Int> (opt_get1 $Snap.unit source@26@04))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@63@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@67@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@67@04)))
(push) ; 16
(assert (not (ite
  (and
    (<
      (inv@62@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@67@04))
      V@28@04)
    (<=
      0
      (inv@62@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@67@04))))
  (< $Perm.No $k@61@04)
  false)))
(check-sat)
; unsat
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               976
;  :arith-add-rows          374
;  :arith-assert-diseq      36
;  :arith-assert-lower      246
;  :arith-assert-upper      149
;  :arith-bound-prop        76
;  :arith-conflicts         31
;  :arith-eq-adapter        140
;  :arith-fixed-eqs         70
;  :arith-offset-eqs        68
;  :arith-pivots            238
;  :conflicts               84
;  :datatype-accessor-ax    31
;  :datatype-constructor-ax 56
;  :datatype-occurs-check   62
;  :datatype-splits         32
;  :decisions               119
;  :del-clause              821
;  :final-checks            36
;  :max-generation          4
;  :max-memory              5.02
;  :memory                  5.01
;  :mk-bool-var             2148
;  :mk-clause               877
;  :num-allocs              198827
;  :num-checks              77
;  :propagations            401
;  :quant-instantiations    556
;  :rlimit-count            266155)
(pop) ; 15
(push) ; 15
; [else-branch: 52 | !(i2@67@04 < V@28@04)]
(assert (not (< i2@67@04 V@28@04)))
(pop) ; 15
(pop) ; 14
; Joined path conditions
(assert (implies
  (< i2@67@04 V@28@04)
  (and
    (< i2@67@04 V@28@04)
    (< i1@66@04 (alen<Int> (opt_get1 $Snap.unit source@26@04)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@63@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@66@04)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@66@04))
    (< i2@67@04 (alen<Int> (opt_get1 $Snap.unit source@26@04)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@63@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@67@04)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@67@04)))))
; Joined path conditions
(pop) ; 13
(push) ; 13
; [else-branch: 51 | !(0 <= i2@67@04)]
(assert (not (<= 0 i2@67@04)))
(pop) ; 13
(pop) ; 12
; Joined path conditions
(assert (implies
  (<= 0 i2@67@04)
  (and
    (<= 0 i2@67@04)
    (implies
      (< i2@67@04 V@28@04)
      (and
        (< i2@67@04 V@28@04)
        (< i1@66@04 (alen<Int> (opt_get1 $Snap.unit source@26@04)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@63@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@66@04)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@66@04))
        (< i2@67@04 (alen<Int> (opt_get1 $Snap.unit source@26@04)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@63@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@67@04)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@67@04)))))))
; Joined path conditions
(pop) ; 11
(push) ; 11
; [else-branch: 50 | !(i1@66@04 < V@28@04)]
(assert (not (< i1@66@04 V@28@04)))
(pop) ; 11
(pop) ; 10
; Joined path conditions
(assert (implies
  (< i1@66@04 V@28@04)
  (and
    (< i1@66@04 V@28@04)
    (implies
      (<= 0 i2@67@04)
      (and
        (<= 0 i2@67@04)
        (implies
          (< i2@67@04 V@28@04)
          (and
            (< i2@67@04 V@28@04)
            (< i1@66@04 (alen<Int> (opt_get1 $Snap.unit source@26@04)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@63@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@66@04)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@66@04))
            (< i2@67@04 (alen<Int> (opt_get1 $Snap.unit source@26@04)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@63@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@67@04)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@67@04)))))))))
; Joined path conditions
(pop) ; 9
(push) ; 9
; [else-branch: 49 | !(0 <= i1@66@04)]
(assert (not (<= 0 i1@66@04)))
(pop) ; 9
(pop) ; 8
; Joined path conditions
(assert (implies
  (<= 0 i1@66@04)
  (and
    (<= 0 i1@66@04)
    (implies
      (< i1@66@04 V@28@04)
      (and
        (< i1@66@04 V@28@04)
        (implies
          (<= 0 i2@67@04)
          (and
            (<= 0 i2@67@04)
            (implies
              (< i2@67@04 V@28@04)
              (and
                (< i2@67@04 V@28@04)
                (< i1@66@04 (alen<Int> (opt_get1 $Snap.unit source@26@04)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@63@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@66@04)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@66@04))
                (< i2@67@04 (alen<Int> (opt_get1 $Snap.unit source@26@04)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@63@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@67@04)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@67@04)))))))))))
; Joined path conditions
(push) ; 8
; [then-branch: 53 | Lookup(option$array$,sm@63@04,aloc((_, _), opt_get1(_, source@26@04), i1@66@04)) == Lookup(option$array$,sm@63@04,aloc((_, _), opt_get1(_, source@26@04), i2@67@04)) && i2@67@04 < V@28@04 && 0 <= i2@67@04 && i1@66@04 < V@28@04 && 0 <= i1@66@04 | live]
; [else-branch: 53 | !(Lookup(option$array$,sm@63@04,aloc((_, _), opt_get1(_, source@26@04), i1@66@04)) == Lookup(option$array$,sm@63@04,aloc((_, _), opt_get1(_, source@26@04), i2@67@04)) && i2@67@04 < V@28@04 && 0 <= i2@67@04 && i1@66@04 < V@28@04 && 0 <= i1@66@04) | live]
(push) ; 9
; [then-branch: 53 | Lookup(option$array$,sm@63@04,aloc((_, _), opt_get1(_, source@26@04), i1@66@04)) == Lookup(option$array$,sm@63@04,aloc((_, _), opt_get1(_, source@26@04), i2@67@04)) && i2@67@04 < V@28@04 && 0 <= i2@67@04 && i1@66@04 < V@28@04 && 0 <= i1@66@04]
(assert (and
  (and
    (and
      (and
        (=
          ($FVF.lookup_option$array$ (as sm@63@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@66@04))
          ($FVF.lookup_option$array$ (as sm@63@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@67@04)))
        (< i2@67@04 V@28@04))
      (<= 0 i2@67@04))
    (< i1@66@04 V@28@04))
  (<= 0 i1@66@04)))
; [eval] i1 == i2
(pop) ; 9
(push) ; 9
; [else-branch: 53 | !(Lookup(option$array$,sm@63@04,aloc((_, _), opt_get1(_, source@26@04), i1@66@04)) == Lookup(option$array$,sm@63@04,aloc((_, _), opt_get1(_, source@26@04), i2@67@04)) && i2@67@04 < V@28@04 && 0 <= i2@67@04 && i1@66@04 < V@28@04 && 0 <= i1@66@04)]
(assert (not
  (and
    (and
      (and
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@63@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@66@04))
            ($FVF.lookup_option$array$ (as sm@63@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@67@04)))
          (< i2@67@04 V@28@04))
        (<= 0 i2@67@04))
      (< i1@66@04 V@28@04))
    (<= 0 i1@66@04))))
(pop) ; 9
(pop) ; 8
; Joined path conditions
(assert (implies
  (and
    (and
      (and
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@63@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@66@04))
            ($FVF.lookup_option$array$ (as sm@63@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@67@04)))
          (< i2@67@04 V@28@04))
        (<= 0 i2@67@04))
      (< i1@66@04 V@28@04))
    (<= 0 i1@66@04))
  (and
    (=
      ($FVF.lookup_option$array$ (as sm@63@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@66@04))
      ($FVF.lookup_option$array$ (as sm@63@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@67@04)))
    (< i2@67@04 V@28@04)
    (<= 0 i2@67@04)
    (< i1@66@04 V@28@04)
    (<= 0 i1@66@04))))
; Joined path conditions
(pop) ; 7
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i2@67@04 Int)) (!
  (and
    (implies
      (<= 0 i1@66@04)
      (and
        (<= 0 i1@66@04)
        (implies
          (< i1@66@04 V@28@04)
          (and
            (< i1@66@04 V@28@04)
            (implies
              (<= 0 i2@67@04)
              (and
                (<= 0 i2@67@04)
                (implies
                  (< i2@67@04 V@28@04)
                  (and
                    (< i2@67@04 V@28@04)
                    (< i1@66@04 (alen<Int> (opt_get1 $Snap.unit source@26@04)))
                    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@63@04  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@66@04)) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@66@04))
                    (< i2@67@04 (alen<Int> (opt_get1 $Snap.unit source@26@04)))
                    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@63@04  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@67@04)) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@67@04))))))))))
    (implies
      (and
        (and
          (and
            (and
              (=
                ($FVF.lookup_option$array$ (as sm@63@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@66@04))
                ($FVF.lookup_option$array$ (as sm@63@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@67@04)))
              (< i2@67@04 V@28@04))
            (<= 0 i2@67@04))
          (< i1@66@04 V@28@04))
        (<= 0 i1@66@04))
      (and
        (=
          ($FVF.lookup_option$array$ (as sm@63@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@66@04))
          ($FVF.lookup_option$array$ (as sm@63@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@67@04)))
        (< i2@67@04 V@28@04)
        (<= 0 i2@67@04)
        (< i1@66@04 V@28@04)
        (<= 0 i1@66@04))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@67@04))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 6
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@66@04 Int)) (!
  (forall ((i2@67@04 Int)) (!
    (and
      (implies
        (<= 0 i1@66@04)
        (and
          (<= 0 i1@66@04)
          (implies
            (< i1@66@04 V@28@04)
            (and
              (< i1@66@04 V@28@04)
              (implies
                (<= 0 i2@67@04)
                (and
                  (<= 0 i2@67@04)
                  (implies
                    (< i2@67@04 V@28@04)
                    (and
                      (< i2@67@04 V@28@04)
                      (< i1@66@04 (alen<Int> (opt_get1 $Snap.unit source@26@04)))
                      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@63@04  $FVF<option<array>>) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@66@04)) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@66@04))
                      (< i2@67@04 (alen<Int> (opt_get1 $Snap.unit source@26@04)))
                      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@63@04  $FVF<option<array>>) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@67@04)) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@67@04))))))))))
      (implies
        (and
          (and
            (and
              (and
                (=
                  ($FVF.lookup_option$array$ (as sm@63@04  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@66@04))
                  ($FVF.lookup_option$array$ (as sm@63@04  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@67@04)))
                (< i2@67@04 V@28@04))
              (<= 0 i2@67@04))
            (< i1@66@04 V@28@04))
          (<= 0 i1@66@04))
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@63@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@66@04))
            ($FVF.lookup_option$array$ (as sm@63@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@67@04)))
          (< i2@67@04 V@28@04)
          (<= 0 i2@67@04)
          (< i1@66@04 V@28@04)
          (<= 0 i1@66@04))))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@67@04))
    :qid |prog.l<no position>-aux|))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@66@04))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (implies
  (= exc@29@04 $Ref.null)
  (forall ((i1@66@04 Int)) (!
    (forall ((i2@67@04 Int)) (!
      (and
        (implies
          (<= 0 i1@66@04)
          (and
            (<= 0 i1@66@04)
            (implies
              (< i1@66@04 V@28@04)
              (and
                (< i1@66@04 V@28@04)
                (implies
                  (<= 0 i2@67@04)
                  (and
                    (<= 0 i2@67@04)
                    (implies
                      (< i2@67@04 V@28@04)
                      (and
                        (< i2@67@04 V@28@04)
                        (<
                          i1@66@04
                          (alen<Int> (opt_get1 $Snap.unit source@26@04)))
                        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@63@04  $FVF<option<array>>) (aloc ($Snap.combine
                          $Snap.unit
                          $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@66@04)) (aloc ($Snap.combine
                          $Snap.unit
                          $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@66@04))
                        (<
                          i2@67@04
                          (alen<Int> (opt_get1 $Snap.unit source@26@04)))
                        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@63@04  $FVF<option<array>>) (aloc ($Snap.combine
                          $Snap.unit
                          $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@67@04)) (aloc ($Snap.combine
                          $Snap.unit
                          $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@67@04))))))))))
        (implies
          (and
            (and
              (and
                (and
                  (=
                    ($FVF.lookup_option$array$ (as sm@63@04  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@66@04))
                    ($FVF.lookup_option$array$ (as sm@63@04  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@67@04)))
                  (< i2@67@04 V@28@04))
                (<= 0 i2@67@04))
              (< i1@66@04 V@28@04))
            (<= 0 i1@66@04))
          (and
            (=
              ($FVF.lookup_option$array$ (as sm@63@04  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@66@04))
              ($FVF.lookup_option$array$ (as sm@63@04  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@67@04)))
            (< i2@67@04 V@28@04)
            (<= 0 i2@67@04)
            (< i1@66@04 V@28@04)
            (<= 0 i1@66@04))))
      :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@67@04))
      :qid |prog.l<no position>-aux|))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@66@04))
    :qid |prog.l<no position>-aux|))))
(assert (implies
  (= exc@29@04 $Ref.null)
  (forall ((i1@66@04 Int)) (!
    (forall ((i2@67@04 Int)) (!
      (implies
        (and
          (and
            (and
              (and
                (=
                  ($FVF.lookup_option$array$ (as sm@63@04  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@66@04))
                  ($FVF.lookup_option$array$ (as sm@63@04  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@67@04)))
                (< i2@67@04 V@28@04))
              (<= 0 i2@67@04))
            (< i1@66@04 V@28@04))
          (<= 0 i1@66@04))
        (= i1@66@04 i2@67@04))
      :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@67@04))
      :qid |prog.l<no position>|))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@66@04))
    :qid |prog.l<no position>|))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@59@04)))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@59@04))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@59@04)))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@59@04))))))))
  $Snap.unit))
; [eval] exc == null ==> target != (None(): option[array])
; [eval] exc == null
(push) ; 4
(set-option :timeout 10)
(push) ; 5
(assert (not (not (= exc@29@04 $Ref.null))))
(check-sat)
; unknown
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1007
;  :arith-add-rows          386
;  :arith-assert-diseq      36
;  :arith-assert-lower      247
;  :arith-assert-upper      150
;  :arith-bound-prop        76
;  :arith-conflicts         31
;  :arith-eq-adapter        141
;  :arith-fixed-eqs         71
;  :arith-offset-eqs        68
;  :arith-pivots            247
;  :conflicts               84
;  :datatype-accessor-ax    32
;  :datatype-constructor-ax 62
;  :datatype-occurs-check   65
;  :datatype-splits         34
;  :decisions               125
;  :del-clause              899
;  :final-checks            38
;  :max-generation          4
;  :max-memory              5.02
;  :memory                  5.01
;  :mk-bool-var             2169
;  :mk-clause               901
;  :num-allocs              200448
;  :num-checks              78
;  :propagations            401
;  :quant-instantiations    556
;  :rlimit-count            269595)
; [then-branch: 54 | exc@29@04 == Null | live]
; [else-branch: 54 | exc@29@04 != Null | dead]
(push) ; 5
; [then-branch: 54 | exc@29@04 == Null]
; [eval] target != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (implies
  (= exc@29@04 $Ref.null)
  (not (= target@27@04 (as None<option<array>>  option<array>)))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@59@04))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@59@04)))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@59@04))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@59@04)))))))))
  $Snap.unit))
; [eval] exc == null ==> alen(opt_get1(target)) == V
; [eval] exc == null
(push) ; 4
(push) ; 5
(assert (not (not (= exc@29@04 $Ref.null))))
(check-sat)
; unknown
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1038
;  :arith-add-rows          386
;  :arith-assert-diseq      36
;  :arith-assert-lower      247
;  :arith-assert-upper      150
;  :arith-bound-prop        76
;  :arith-conflicts         31
;  :arith-eq-adapter        141
;  :arith-fixed-eqs         71
;  :arith-offset-eqs        68
;  :arith-pivots            247
;  :conflicts               84
;  :datatype-accessor-ax    33
;  :datatype-constructor-ax 68
;  :datatype-occurs-check   68
;  :datatype-splits         36
;  :decisions               131
;  :del-clause              899
;  :final-checks            40
;  :max-generation          4
;  :max-memory              5.03
;  :memory                  5.02
;  :mk-bool-var             2173
;  :mk-clause               901
;  :num-allocs              201122
;  :num-checks              79
;  :propagations            401
;  :quant-instantiations    556
;  :rlimit-count            270468)
; [then-branch: 55 | exc@29@04 == Null | live]
; [else-branch: 55 | exc@29@04 != Null | dead]
(push) ; 5
; [then-branch: 55 | exc@29@04 == Null]
; [eval] alen(opt_get1(target)) == V
; [eval] alen(opt_get1(target))
; [eval] opt_get1(target)
(push) ; 6
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 6
; Joined path conditions
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (implies
  (= exc@29@04 $Ref.null)
  (= (alen<Int> (opt_get1 $Snap.unit target@27@04)) V@28@04)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@59@04)))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@59@04))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@59@04)))))))))))))
; [eval] exc == null
(push) ; 4
(assert (not (not (= exc@29@04 $Ref.null))))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1071
;  :arith-add-rows          386
;  :arith-assert-diseq      36
;  :arith-assert-lower      247
;  :arith-assert-upper      150
;  :arith-bound-prop        76
;  :arith-conflicts         31
;  :arith-eq-adapter        141
;  :arith-fixed-eqs         71
;  :arith-offset-eqs        68
;  :arith-pivots            247
;  :conflicts               84
;  :datatype-accessor-ax    34
;  :datatype-constructor-ax 75
;  :datatype-occurs-check   71
;  :datatype-splits         39
;  :decisions               138
;  :del-clause              899
;  :final-checks            42
;  :max-generation          4
;  :max-memory              5.03
;  :memory                  5.02
;  :mk-bool-var             2177
;  :mk-clause               901
;  :num-allocs              201797
;  :num-checks              80
;  :propagations            401
;  :quant-instantiations    556
;  :rlimit-count            271333)
; [then-branch: 56 | exc@29@04 == Null | live]
; [else-branch: 56 | exc@29@04 != Null | dead]
(push) ; 4
; [then-branch: 56 | exc@29@04 == Null]
(declare-const i1@68@04 Int)
(push) ; 5
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 6
; [then-branch: 57 | 0 <= i1@68@04 | live]
; [else-branch: 57 | !(0 <= i1@68@04) | live]
(push) ; 7
; [then-branch: 57 | 0 <= i1@68@04]
(assert (<= 0 i1@68@04))
; [eval] i1 < V
(pop) ; 7
(push) ; 7
; [else-branch: 57 | !(0 <= i1@68@04)]
(assert (not (<= 0 i1@68@04)))
(pop) ; 7
(pop) ; 6
; Joined path conditions
; Joined path conditions
(assert (and (< i1@68@04 V@28@04) (<= 0 i1@68@04)))
; [eval] aloc(opt_get1(target), i1)
; [eval] opt_get1(target)
(push) ; 6
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 6
; Joined path conditions
(push) ; 6
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 7
(assert (not (< i1@68@04 (alen<Int> (opt_get1 $Snap.unit target@27@04)))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1072
;  :arith-add-rows          388
;  :arith-assert-diseq      36
;  :arith-assert-lower      250
;  :arith-assert-upper      151
;  :arith-bound-prop        76
;  :arith-conflicts         31
;  :arith-eq-adapter        142
;  :arith-fixed-eqs         72
;  :arith-offset-eqs        68
;  :arith-pivots            248
;  :conflicts               84
;  :datatype-accessor-ax    34
;  :datatype-constructor-ax 75
;  :datatype-occurs-check   71
;  :datatype-splits         39
;  :decisions               138
;  :del-clause              899
;  :final-checks            42
;  :max-generation          4
;  :max-memory              5.03
;  :memory                  5.02
;  :mk-bool-var             2181
;  :mk-clause               901
;  :num-allocs              201913
;  :num-checks              81
;  :propagations            401
;  :quant-instantiations    556
;  :rlimit-count            271556)
(assert (< i1@68@04 (alen<Int> (opt_get1 $Snap.unit target@27@04))))
(pop) ; 6
; Joined path conditions
(assert (< i1@68@04 (alen<Int> (opt_get1 $Snap.unit target@27@04))))
(declare-const $k@69@04 $Perm)
(assert ($Perm.isReadVar $k@69@04 $Perm.Write))
(pop) ; 5
(declare-fun inv@70@04 ($Ref) Int)
; Nested auxiliary terms: globals
(assert ($Perm.isReadVar $k@69@04 $Perm.Write))
; Nested auxiliary terms: non-globals
(assert (forall ((i1@68@04 Int)) (!
  (< i1@68@04 (alen<Int> (opt_get1 $Snap.unit target@27@04)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@68@04))
  :qid |option$array$-aux|)))
(push) ; 5
(assert (not (forall ((i1@68@04 Int)) (!
  (implies
    (and (< i1@68@04 V@28@04) (<= 0 i1@68@04))
    (or (= $k@69@04 $Perm.No) (< $Perm.No $k@69@04)))
  
  ))))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1072
;  :arith-add-rows          389
;  :arith-assert-diseq      37
;  :arith-assert-lower      252
;  :arith-assert-upper      152
;  :arith-bound-prop        76
;  :arith-conflicts         31
;  :arith-eq-adapter        143
;  :arith-fixed-eqs         72
;  :arith-offset-eqs        68
;  :arith-pivots            249
;  :conflicts               85
;  :datatype-accessor-ax    34
;  :datatype-constructor-ax 75
;  :datatype-occurs-check   71
;  :datatype-splits         39
;  :decisions               138
;  :del-clause              899
;  :final-checks            42
;  :max-generation          4
;  :max-memory              5.03
;  :memory                  5.02
;  :mk-bool-var             2188
;  :mk-clause               903
;  :num-allocs              202372
;  :num-checks              82
;  :propagations            402
;  :quant-instantiations    556
;  :rlimit-count            272145)
; Check receiver injectivity
(push) ; 5
(assert (not (forall ((i11@68@04 Int) (i12@68@04 Int)) (!
  (implies
    (and
      (and (and (< i11@68@04 V@28@04) (<= 0 i11@68@04)) (< $Perm.No $k@69@04))
      (and (and (< i12@68@04 V@28@04) (<= 0 i12@68@04)) (< $Perm.No $k@69@04))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i11@68@04)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i12@68@04)))
    (= i11@68@04 i12@68@04))
  
  :qid |option$array$-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1078
;  :arith-add-rows          390
;  :arith-assert-diseq      38
;  :arith-assert-lower      256
;  :arith-assert-upper      152
;  :arith-bound-prop        76
;  :arith-conflicts         31
;  :arith-eq-adapter        145
;  :arith-fixed-eqs         72
;  :arith-offset-eqs        68
;  :arith-pivots            249
;  :conflicts               86
;  :datatype-accessor-ax    34
;  :datatype-constructor-ax 75
;  :datatype-occurs-check   71
;  :datatype-splits         39
;  :decisions               138
;  :del-clause              906
;  :final-checks            42
;  :max-generation          4
;  :max-memory              5.03
;  :memory                  5.01
;  :mk-bool-var             2207
;  :mk-clause               910
;  :num-allocs              202745
;  :num-checks              83
;  :propagations            402
;  :quant-instantiations    567
;  :rlimit-count            272845)
; Definitional axioms for inverse functions
(assert (forall ((i1@68@04 Int)) (!
  (implies
    (and (and (< i1@68@04 V@28@04) (<= 0 i1@68@04)) (< $Perm.No $k@69@04))
    (=
      (inv@70@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@68@04))
      i1@68@04))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@68@04))
  )))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and (< (inv@70@04 r) V@28@04) (<= 0 (inv@70@04 r)))
      (< $Perm.No $k@69@04))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) (inv@70@04 r))
      r))
  :pattern ((inv@70@04 r))
  :qid |option$array$-fctOfInv|)))
; Permissions are non-negative
(assert (forall ((i1@68@04 Int)) (!
  (<= $Perm.No $k@69@04)
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@68@04))
  :qid |option$array$-permAtLeastZero|)))
; Field permissions are at most one
(assert (forall ((i1@68@04 Int)) (!
  (<= $k@69@04 $Perm.Write)
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@68@04))
  :qid |option$array$-permAtMostOne|)))
; Permission implies non-null receiver
(assert (forall ((i1@68@04 Int)) (!
  (implies
    (and (and (< i1@68@04 V@28@04) (<= 0 i1@68@04)) (< $Perm.No $k@69@04))
    (not
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@68@04)
        $Ref.null)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@68@04))
  :qid |option$array$-permImpliesNonNull|)))
(declare-const sm@71@04 $FVF<option<array>>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@70@04 r) V@28@04) (<= 0 (inv@70@04 r)))
      (< $Perm.No $k@69@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@59@04))))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@59@04))))))))))) r))
  :qid |qp.fvfValDef16|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@62@04 r) V@28@04) (<= 0 (inv@62@04 r)))
      (< $Perm.No $k@61@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@59@04))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@59@04))))) r))
  :qid |qp.fvfValDef17|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@59@04))))))))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@59@04))))) r) r))
  :pattern (($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef18|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@70@04 r) V@28@04) (<= 0 (inv@70@04 r)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) r) r))
  :pattern ((inv@70@04 r))
  )))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@59@04))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@59@04)))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@59@04))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@59@04)))))))))))
  $Snap.unit))
; [eval] exc == null ==> (forall i1: Int :: { aloc(opt_get1(target), i1) } 0 <= i1 && i1 < V ==> aloc(opt_get1(target), i1).option$array$ != (None(): option[array]))
; [eval] exc == null
(push) ; 5
(set-option :timeout 10)
(push) ; 6
(assert (not (not (= exc@29@04 $Ref.null))))
(check-sat)
; unknown
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1114
;  :arith-add-rows          390
;  :arith-assert-diseq      38
;  :arith-assert-lower      256
;  :arith-assert-upper      153
;  :arith-bound-prop        76
;  :arith-conflicts         31
;  :arith-eq-adapter        145
;  :arith-fixed-eqs         72
;  :arith-offset-eqs        68
;  :arith-pivots            249
;  :conflicts               86
;  :datatype-accessor-ax    35
;  :datatype-constructor-ax 82
;  :datatype-occurs-check   74
;  :datatype-splits         42
;  :decisions               145
;  :del-clause              906
;  :final-checks            44
;  :max-generation          4
;  :max-memory              5.04
;  :memory                  5.03
;  :mk-bool-var             2220
;  :mk-clause               910
;  :num-allocs              204620
;  :num-checks              84
;  :propagations            402
;  :quant-instantiations    567
;  :rlimit-count            276536)
; [then-branch: 58 | exc@29@04 == Null | live]
; [else-branch: 58 | exc@29@04 != Null | dead]
(push) ; 6
; [then-branch: 58 | exc@29@04 == Null]
; [eval] (forall i1: Int :: { aloc(opt_get1(target), i1) } 0 <= i1 && i1 < V ==> aloc(opt_get1(target), i1).option$array$ != (None(): option[array]))
(declare-const i1@72@04 Int)
(push) ; 7
; [eval] 0 <= i1 && i1 < V ==> aloc(opt_get1(target), i1).option$array$ != (None(): option[array])
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 8
; [then-branch: 59 | 0 <= i1@72@04 | live]
; [else-branch: 59 | !(0 <= i1@72@04) | live]
(push) ; 9
; [then-branch: 59 | 0 <= i1@72@04]
(assert (<= 0 i1@72@04))
; [eval] i1 < V
(pop) ; 9
(push) ; 9
; [else-branch: 59 | !(0 <= i1@72@04)]
(assert (not (<= 0 i1@72@04)))
(pop) ; 9
(pop) ; 8
; Joined path conditions
; Joined path conditions
(push) ; 8
; [then-branch: 60 | i1@72@04 < V@28@04 && 0 <= i1@72@04 | live]
; [else-branch: 60 | !(i1@72@04 < V@28@04 && 0 <= i1@72@04) | live]
(push) ; 9
; [then-branch: 60 | i1@72@04 < V@28@04 && 0 <= i1@72@04]
(assert (and (< i1@72@04 V@28@04) (<= 0 i1@72@04)))
; [eval] aloc(opt_get1(target), i1).option$array$ != (None(): option[array])
; [eval] aloc(opt_get1(target), i1)
; [eval] opt_get1(target)
(push) ; 10
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 10
; Joined path conditions
(push) ; 10
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 11
(assert (not (< i1@72@04 (alen<Int> (opt_get1 $Snap.unit target@27@04)))))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1115
;  :arith-add-rows          392
;  :arith-assert-diseq      38
;  :arith-assert-lower      259
;  :arith-assert-upper      154
;  :arith-bound-prop        76
;  :arith-conflicts         31
;  :arith-eq-adapter        146
;  :arith-fixed-eqs         73
;  :arith-offset-eqs        68
;  :arith-pivots            250
;  :conflicts               86
;  :datatype-accessor-ax    35
;  :datatype-constructor-ax 82
;  :datatype-occurs-check   74
;  :datatype-splits         42
;  :decisions               145
;  :del-clause              906
;  :final-checks            44
;  :max-generation          4
;  :max-memory              5.04
;  :memory                  5.03
;  :mk-bool-var             2224
;  :mk-clause               910
;  :num-allocs              204736
;  :num-checks              85
;  :propagations            402
;  :quant-instantiations    567
;  :rlimit-count            276766)
(assert (< i1@72@04 (alen<Int> (opt_get1 $Snap.unit target@27@04))))
(pop) ; 10
; Joined path conditions
(assert (< i1@72@04 (alen<Int> (opt_get1 $Snap.unit target@27@04))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@72@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@72@04)))
(push) ; 10
(assert (not (<
  $Perm.No
  (+
    (ite
      (and
        (<
          (inv@70@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@72@04))
          V@28@04)
        (<=
          0
          (inv@70@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@72@04))))
      $k@69@04
      $Perm.No)
    (ite
      (and
        (<
          (inv@62@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@72@04))
          V@28@04)
        (<=
          0
          (inv@62@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@72@04))))
      $k@61@04
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1207
;  :arith-add-rows          402
;  :arith-assert-diseq      41
;  :arith-assert-lower      270
;  :arith-assert-upper      163
;  :arith-bound-prop        83
;  :arith-conflicts         33
;  :arith-eq-adapter        155
;  :arith-fixed-eqs         77
;  :arith-offset-eqs        71
;  :arith-pivots            257
;  :conflicts               94
;  :datatype-accessor-ax    35
;  :datatype-constructor-ax 86
;  :datatype-occurs-check   74
;  :datatype-splits         42
;  :decisions               152
;  :del-clause              925
;  :final-checks            44
;  :max-generation          4
;  :max-memory              5.09
;  :memory                  5.07
;  :mk-bool-var             2367
;  :mk-clause               1001
;  :num-allocs              205581
;  :num-checks              86
;  :propagations            425
;  :quant-instantiations    610
;  :rlimit-count            279365)
; [eval] (None(): option[array])
(pop) ; 9
(push) ; 9
; [else-branch: 60 | !(i1@72@04 < V@28@04 && 0 <= i1@72@04)]
(assert (not (and (< i1@72@04 V@28@04) (<= 0 i1@72@04))))
(pop) ; 9
(pop) ; 8
; Joined path conditions
(assert (implies
  (and (< i1@72@04 V@28@04) (<= 0 i1@72@04))
  (and
    (< i1@72@04 V@28@04)
    (<= 0 i1@72@04)
    (< i1@72@04 (alen<Int> (opt_get1 $Snap.unit target@27@04)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@72@04)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@72@04)))))
; Joined path conditions
(pop) ; 7
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@72@04 Int)) (!
  (implies
    (and (< i1@72@04 V@28@04) (<= 0 i1@72@04))
    (and
      (< i1@72@04 V@28@04)
      (<= 0 i1@72@04)
      (< i1@72@04 (alen<Int> (opt_get1 $Snap.unit target@27@04)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@72@04)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@72@04))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@72@04))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 6
(pop) ; 5
; Joined path conditions
(assert (implies
  (= exc@29@04 $Ref.null)
  (forall ((i1@72@04 Int)) (!
    (implies
      (and (< i1@72@04 V@28@04) (<= 0 i1@72@04))
      (and
        (< i1@72@04 V@28@04)
        (<= 0 i1@72@04)
        (< i1@72@04 (alen<Int> (opt_get1 $Snap.unit target@27@04)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@72@04)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@72@04))))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@72@04))
    :qid |prog.l<no position>-aux|))))
(assert (implies
  (= exc@29@04 $Ref.null)
  (forall ((i1@72@04 Int)) (!
    (implies
      (and (< i1@72@04 V@28@04) (<= 0 i1@72@04))
      (not
        (=
          ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@72@04))
          (as None<option<array>>  option<array>))))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@72@04))
    :qid |prog.l<no position>|))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@59@04)))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@59@04))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@59@04)))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@59@04))))))))))))
  $Snap.unit))
; [eval] exc == null ==> (forall i1: Int :: { alen(opt_get1(aloc(opt_get1(target), i1).option$array$)) } 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(target), i1).option$array$)) == V)
; [eval] exc == null
(push) ; 5
(set-option :timeout 10)
(push) ; 6
(assert (not (not (= exc@29@04 $Ref.null))))
(check-sat)
; unknown
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1244
;  :arith-add-rows          404
;  :arith-assert-diseq      41
;  :arith-assert-lower      270
;  :arith-assert-upper      163
;  :arith-bound-prop        83
;  :arith-conflicts         33
;  :arith-eq-adapter        155
;  :arith-fixed-eqs         77
;  :arith-offset-eqs        71
;  :arith-pivots            261
;  :conflicts               94
;  :datatype-accessor-ax    36
;  :datatype-constructor-ax 93
;  :datatype-occurs-check   77
;  :datatype-splits         45
;  :decisions               159
;  :del-clause              997
;  :final-checks            46
;  :max-generation          4
;  :max-memory              5.09
;  :memory                  5.07
;  :mk-bool-var             2374
;  :mk-clause               1001
;  :num-allocs              206633
;  :num-checks              87
;  :propagations            425
;  :quant-instantiations    610
;  :rlimit-count            281108)
; [then-branch: 61 | exc@29@04 == Null | live]
; [else-branch: 61 | exc@29@04 != Null | dead]
(push) ; 6
; [then-branch: 61 | exc@29@04 == Null]
; [eval] (forall i1: Int :: { alen(opt_get1(aloc(opt_get1(target), i1).option$array$)) } 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(target), i1).option$array$)) == V)
(declare-const i1@73@04 Int)
(push) ; 7
; [eval] 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(target), i1).option$array$)) == V
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 8
; [then-branch: 62 | 0 <= i1@73@04 | live]
; [else-branch: 62 | !(0 <= i1@73@04) | live]
(push) ; 9
; [then-branch: 62 | 0 <= i1@73@04]
(assert (<= 0 i1@73@04))
; [eval] i1 < V
(pop) ; 9
(push) ; 9
; [else-branch: 62 | !(0 <= i1@73@04)]
(assert (not (<= 0 i1@73@04)))
(pop) ; 9
(pop) ; 8
; Joined path conditions
; Joined path conditions
(push) ; 8
; [then-branch: 63 | i1@73@04 < V@28@04 && 0 <= i1@73@04 | live]
; [else-branch: 63 | !(i1@73@04 < V@28@04 && 0 <= i1@73@04) | live]
(push) ; 9
; [then-branch: 63 | i1@73@04 < V@28@04 && 0 <= i1@73@04]
(assert (and (< i1@73@04 V@28@04) (<= 0 i1@73@04)))
; [eval] alen(opt_get1(aloc(opt_get1(target), i1).option$array$)) == V
; [eval] alen(opt_get1(aloc(opt_get1(target), i1).option$array$))
; [eval] opt_get1(aloc(opt_get1(target), i1).option$array$)
; [eval] aloc(opt_get1(target), i1)
; [eval] opt_get1(target)
(push) ; 10
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 10
; Joined path conditions
(push) ; 10
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 11
(assert (not (< i1@73@04 (alen<Int> (opt_get1 $Snap.unit target@27@04)))))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1245
;  :arith-add-rows          407
;  :arith-assert-diseq      41
;  :arith-assert-lower      273
;  :arith-assert-upper      164
;  :arith-bound-prop        83
;  :arith-conflicts         33
;  :arith-eq-adapter        156
;  :arith-fixed-eqs         78
;  :arith-offset-eqs        71
;  :arith-pivots            263
;  :conflicts               94
;  :datatype-accessor-ax    36
;  :datatype-constructor-ax 93
;  :datatype-occurs-check   77
;  :datatype-splits         45
;  :decisions               159
;  :del-clause              997
;  :final-checks            46
;  :max-generation          4
;  :max-memory              5.09
;  :memory                  5.07
;  :mk-bool-var             2378
;  :mk-clause               1001
;  :num-allocs              206749
;  :num-checks              88
;  :propagations            425
;  :quant-instantiations    610
;  :rlimit-count            281363)
(assert (< i1@73@04 (alen<Int> (opt_get1 $Snap.unit target@27@04))))
(pop) ; 10
; Joined path conditions
(assert (< i1@73@04 (alen<Int> (opt_get1 $Snap.unit target@27@04))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@73@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@73@04)))
(push) ; 10
(assert (not (<
  $Perm.No
  (+
    (ite
      (and
        (<
          (inv@70@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@73@04))
          V@28@04)
        (<=
          0
          (inv@70@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@73@04))))
      $k@69@04
      $Perm.No)
    (ite
      (and
        (<
          (inv@62@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@73@04))
          V@28@04)
        (<=
          0
          (inv@62@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@73@04))))
      $k@61@04
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1346
;  :arith-add-rows          425
;  :arith-assert-diseq      44
;  :arith-assert-lower      284
;  :arith-assert-upper      174
;  :arith-bound-prop        90
;  :arith-conflicts         36
;  :arith-eq-adapter        167
;  :arith-fixed-eqs         82
;  :arith-offset-eqs        76
;  :arith-pivots            270
;  :conflicts               102
;  :datatype-accessor-ax    36
;  :datatype-constructor-ax 97
;  :datatype-occurs-check   77
;  :datatype-splits         45
;  :decisions               166
;  :del-clause              1024
;  :final-checks            46
;  :max-generation          4
;  :max-memory              5.10
;  :memory                  5.09
;  :mk-bool-var             2535
;  :mk-clause               1098
;  :num-allocs              207551
;  :num-checks              89
;  :propagations            457
;  :quant-instantiations    654
;  :rlimit-count            284036)
(push) ; 10
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 11
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@73@04))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1346
;  :arith-add-rows          425
;  :arith-assert-diseq      44
;  :arith-assert-lower      284
;  :arith-assert-upper      174
;  :arith-bound-prop        90
;  :arith-conflicts         36
;  :arith-eq-adapter        167
;  :arith-fixed-eqs         82
;  :arith-offset-eqs        76
;  :arith-pivots            270
;  :conflicts               103
;  :datatype-accessor-ax    36
;  :datatype-constructor-ax 97
;  :datatype-occurs-check   77
;  :datatype-splits         45
;  :decisions               166
;  :del-clause              1024
;  :final-checks            46
;  :max-generation          4
;  :max-memory              5.10
;  :memory                  5.09
;  :mk-bool-var             2535
;  :mk-clause               1098
;  :num-allocs              207644
;  :num-checks              90
;  :propagations            457
;  :quant-instantiations    654
;  :rlimit-count            284131)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@73@04))
    (as None<option<array>>  option<array>))))
(pop) ; 10
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@73@04))
    (as None<option<array>>  option<array>))))
(pop) ; 9
(push) ; 9
; [else-branch: 63 | !(i1@73@04 < V@28@04 && 0 <= i1@73@04)]
(assert (not (and (< i1@73@04 V@28@04) (<= 0 i1@73@04))))
(pop) ; 9
(pop) ; 8
; Joined path conditions
(assert (implies
  (and (< i1@73@04 V@28@04) (<= 0 i1@73@04))
  (and
    (< i1@73@04 V@28@04)
    (<= 0 i1@73@04)
    (< i1@73@04 (alen<Int> (opt_get1 $Snap.unit target@27@04)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@73@04)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@73@04))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@73@04))
        (as None<option<array>>  option<array>))))))
; Joined path conditions
(pop) ; 7
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@73@04 Int)) (!
  (implies
    (and (< i1@73@04 V@28@04) (<= 0 i1@73@04))
    (and
      (< i1@73@04 V@28@04)
      (<= 0 i1@73@04)
      (< i1@73@04 (alen<Int> (opt_get1 $Snap.unit target@27@04)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@73@04)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@73@04))
      (not
        (=
          ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@73@04))
          (as None<option<array>>  option<array>)))))
  :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@73@04)))))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 6
(pop) ; 5
; Joined path conditions
(assert (implies
  (= exc@29@04 $Ref.null)
  (forall ((i1@73@04 Int)) (!
    (implies
      (and (< i1@73@04 V@28@04) (<= 0 i1@73@04))
      (and
        (< i1@73@04 V@28@04)
        (<= 0 i1@73@04)
        (< i1@73@04 (alen<Int> (opt_get1 $Snap.unit target@27@04)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@73@04)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@73@04))
        (not
          (=
            ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@73@04))
            (as None<option<array>>  option<array>)))))
    :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@73@04)))))
    :qid |prog.l<no position>-aux|))))
(assert (implies
  (= exc@29@04 $Ref.null)
  (forall ((i1@73@04 Int)) (!
    (implies
      (and (< i1@73@04 V@28@04) (<= 0 i1@73@04))
      (=
        (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@73@04))))
        V@28@04))
    :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@73@04)))))
    :qid |prog.l<no position>|))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@59@04))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@59@04)))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@59@04))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@59@04)))))))))))))
  $Snap.unit))
; [eval] exc == null ==> (forall i1: Int :: { aloc(opt_get1(target), i1) } (forall i2: Int :: { aloc(opt_get1(target), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(target), i1).option$array$ == aloc(opt_get1(target), i2).option$array$ ==> i1 == i2))
; [eval] exc == null
(push) ; 5
(set-option :timeout 10)
(push) ; 6
(assert (not (not (= exc@29@04 $Ref.null))))
(check-sat)
; unknown
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1384
;  :arith-add-rows          429
;  :arith-assert-diseq      44
;  :arith-assert-lower      284
;  :arith-assert-upper      174
;  :arith-bound-prop        90
;  :arith-conflicts         36
;  :arith-eq-adapter        167
;  :arith-fixed-eqs         82
;  :arith-offset-eqs        76
;  :arith-pivots            274
;  :conflicts               103
;  :datatype-accessor-ax    37
;  :datatype-constructor-ax 104
;  :datatype-occurs-check   80
;  :datatype-splits         48
;  :decisions               173
;  :del-clause              1094
;  :final-checks            48
;  :max-generation          4
;  :max-memory              5.11
;  :memory                  5.09
;  :mk-bool-var             2542
;  :mk-clause               1098
;  :num-allocs              208732
;  :num-checks              91
;  :propagations            457
;  :quant-instantiations    654
;  :rlimit-count            286029)
; [then-branch: 64 | exc@29@04 == Null | live]
; [else-branch: 64 | exc@29@04 != Null | dead]
(push) ; 6
; [then-branch: 64 | exc@29@04 == Null]
; [eval] (forall i1: Int :: { aloc(opt_get1(target), i1) } (forall i2: Int :: { aloc(opt_get1(target), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(target), i1).option$array$ == aloc(opt_get1(target), i2).option$array$ ==> i1 == i2))
(declare-const i1@74@04 Int)
(push) ; 7
; [eval] (forall i2: Int :: { aloc(opt_get1(target), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(target), i1).option$array$ == aloc(opt_get1(target), i2).option$array$ ==> i1 == i2)
(declare-const i2@75@04 Int)
(push) ; 8
; [eval] 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(target), i1).option$array$ == aloc(opt_get1(target), i2).option$array$ ==> i1 == i2
; [eval] 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(target), i1).option$array$ == aloc(opt_get1(target), i2).option$array$
; [eval] 0 <= i1
(push) ; 9
; [then-branch: 65 | 0 <= i1@74@04 | live]
; [else-branch: 65 | !(0 <= i1@74@04) | live]
(push) ; 10
; [then-branch: 65 | 0 <= i1@74@04]
(assert (<= 0 i1@74@04))
; [eval] i1 < V
(push) ; 11
; [then-branch: 66 | i1@74@04 < V@28@04 | live]
; [else-branch: 66 | !(i1@74@04 < V@28@04) | live]
(push) ; 12
; [then-branch: 66 | i1@74@04 < V@28@04]
(assert (< i1@74@04 V@28@04))
; [eval] 0 <= i2
(push) ; 13
; [then-branch: 67 | 0 <= i2@75@04 | live]
; [else-branch: 67 | !(0 <= i2@75@04) | live]
(push) ; 14
; [then-branch: 67 | 0 <= i2@75@04]
(assert (<= 0 i2@75@04))
; [eval] i2 < V
(push) ; 15
; [then-branch: 68 | i2@75@04 < V@28@04 | live]
; [else-branch: 68 | !(i2@75@04 < V@28@04) | live]
(push) ; 16
; [then-branch: 68 | i2@75@04 < V@28@04]
(assert (< i2@75@04 V@28@04))
; [eval] aloc(opt_get1(target), i1).option$array$ == aloc(opt_get1(target), i2).option$array$
; [eval] aloc(opt_get1(target), i1)
; [eval] opt_get1(target)
(push) ; 17
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 17
; Joined path conditions
(push) ; 17
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 18
(assert (not (< i1@74@04 (alen<Int> (opt_get1 $Snap.unit target@27@04)))))
(check-sat)
; unsat
(pop) ; 18
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1385
;  :arith-add-rows          433
;  :arith-assert-diseq      44
;  :arith-assert-lower      289
;  :arith-assert-upper      175
;  :arith-bound-prop        90
;  :arith-conflicts         36
;  :arith-eq-adapter        168
;  :arith-fixed-eqs         83
;  :arith-offset-eqs        76
;  :arith-pivots            277
;  :conflicts               103
;  :datatype-accessor-ax    37
;  :datatype-constructor-ax 104
;  :datatype-occurs-check   80
;  :datatype-splits         48
;  :decisions               173
;  :del-clause              1094
;  :final-checks            48
;  :max-generation          4
;  :max-memory              5.11
;  :memory                  5.10
;  :mk-bool-var             2548
;  :mk-clause               1098
;  :num-allocs              209027
;  :num-checks              92
;  :propagations            457
;  :quant-instantiations    654
;  :rlimit-count            286437)
(assert (< i1@74@04 (alen<Int> (opt_get1 $Snap.unit target@27@04))))
(pop) ; 17
; Joined path conditions
(assert (< i1@74@04 (alen<Int> (opt_get1 $Snap.unit target@27@04))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@74@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@74@04)))
(push) ; 17
(assert (not (<
  $Perm.No
  (+
    (ite
      (and
        (<
          (inv@70@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@74@04))
          V@28@04)
        (<=
          0
          (inv@70@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@74@04))))
      $k@69@04
      $Perm.No)
    (ite
      (and
        (<
          (inv@62@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@74@04))
          V@28@04)
        (<=
          0
          (inv@62@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@74@04))))
      $k@61@04
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1485
;  :arith-add-rows          456
;  :arith-assert-diseq      47
;  :arith-assert-lower      300
;  :arith-assert-upper      185
;  :arith-bound-prop        97
;  :arith-conflicts         39
;  :arith-eq-adapter        179
;  :arith-fixed-eqs         87
;  :arith-offset-eqs        81
;  :arith-pivots            284
;  :conflicts               111
;  :datatype-accessor-ax    37
;  :datatype-constructor-ax 108
;  :datatype-occurs-check   80
;  :datatype-splits         48
;  :decisions               180
;  :del-clause              1121
;  :final-checks            48
;  :max-generation          4
;  :max-memory              5.11
;  :memory                  5.10
;  :mk-bool-var             2704
;  :mk-clause               1195
;  :num-allocs              209811
;  :num-checks              93
;  :propagations            489
;  :quant-instantiations    698
;  :rlimit-count            289117)
; [eval] aloc(opt_get1(target), i2)
; [eval] opt_get1(target)
(push) ; 17
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 17
; Joined path conditions
(push) ; 17
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 18
(assert (not (< i2@75@04 (alen<Int> (opt_get1 $Snap.unit target@27@04)))))
(check-sat)
; unsat
(pop) ; 18
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1485
;  :arith-add-rows          456
;  :arith-assert-diseq      47
;  :arith-assert-lower      300
;  :arith-assert-upper      185
;  :arith-bound-prop        97
;  :arith-conflicts         39
;  :arith-eq-adapter        179
;  :arith-fixed-eqs         87
;  :arith-offset-eqs        81
;  :arith-pivots            284
;  :conflicts               111
;  :datatype-accessor-ax    37
;  :datatype-constructor-ax 108
;  :datatype-occurs-check   80
;  :datatype-splits         48
;  :decisions               180
;  :del-clause              1121
;  :final-checks            48
;  :max-generation          4
;  :max-memory              5.11
;  :memory                  5.10
;  :mk-bool-var             2704
;  :mk-clause               1195
;  :num-allocs              209836
;  :num-checks              94
;  :propagations            489
;  :quant-instantiations    698
;  :rlimit-count            289147)
(assert (< i2@75@04 (alen<Int> (opt_get1 $Snap.unit target@27@04))))
(pop) ; 17
; Joined path conditions
(assert (< i2@75@04 (alen<Int> (opt_get1 $Snap.unit target@27@04))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@75@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@75@04)))
(push) ; 17
(assert (not (<
  $Perm.No
  (+
    (ite
      (and
        (<
          (inv@70@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@75@04))
          V@28@04)
        (<=
          0
          (inv@70@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@75@04))))
      $k@69@04
      $Perm.No)
    (ite
      (and
        (<
          (inv@62@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@75@04))
          V@28@04)
        (<=
          0
          (inv@62@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@75@04))))
      $k@61@04
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1587
;  :arith-add-rows          477
;  :arith-assert-diseq      50
;  :arith-assert-lower      312
;  :arith-assert-upper      197
;  :arith-bound-prop        106
;  :arith-conflicts         43
;  :arith-eq-adapter        191
;  :arith-fixed-eqs         91
;  :arith-offset-eqs        86
;  :arith-pivots            291
;  :conflicts               128
;  :datatype-accessor-ax    37
;  :datatype-constructor-ax 112
;  :datatype-occurs-check   80
;  :datatype-splits         48
;  :decisions               196
;  :del-clause              1206
;  :final-checks            48
;  :max-generation          4
;  :max-memory              5.20
;  :memory                  5.20
;  :mk-bool-var             2892
;  :mk-clause               1322
;  :num-allocs              211028
;  :num-checks              95
;  :propagations            541
;  :quant-instantiations    738
;  :rlimit-count            292345
;  :time                    0.00)
(pop) ; 16
(push) ; 16
; [else-branch: 68 | !(i2@75@04 < V@28@04)]
(assert (not (< i2@75@04 V@28@04)))
(pop) ; 16
(pop) ; 15
; Joined path conditions
(assert (implies
  (< i2@75@04 V@28@04)
  (and
    (< i2@75@04 V@28@04)
    (< i1@74@04 (alen<Int> (opt_get1 $Snap.unit target@27@04)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@74@04)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@74@04))
    (< i2@75@04 (alen<Int> (opt_get1 $Snap.unit target@27@04)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@75@04)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@75@04)))))
; Joined path conditions
(pop) ; 14
(push) ; 14
; [else-branch: 67 | !(0 <= i2@75@04)]
(assert (not (<= 0 i2@75@04)))
(pop) ; 14
(pop) ; 13
; Joined path conditions
(assert (implies
  (<= 0 i2@75@04)
  (and
    (<= 0 i2@75@04)
    (implies
      (< i2@75@04 V@28@04)
      (and
        (< i2@75@04 V@28@04)
        (< i1@74@04 (alen<Int> (opt_get1 $Snap.unit target@27@04)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@74@04)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@74@04))
        (< i2@75@04 (alen<Int> (opt_get1 $Snap.unit target@27@04)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@75@04)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@75@04)))))))
; Joined path conditions
(pop) ; 12
(push) ; 12
; [else-branch: 66 | !(i1@74@04 < V@28@04)]
(assert (not (< i1@74@04 V@28@04)))
(pop) ; 12
(pop) ; 11
; Joined path conditions
(assert (implies
  (< i1@74@04 V@28@04)
  (and
    (< i1@74@04 V@28@04)
    (implies
      (<= 0 i2@75@04)
      (and
        (<= 0 i2@75@04)
        (implies
          (< i2@75@04 V@28@04)
          (and
            (< i2@75@04 V@28@04)
            (< i1@74@04 (alen<Int> (opt_get1 $Snap.unit target@27@04)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@74@04)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@74@04))
            (< i2@75@04 (alen<Int> (opt_get1 $Snap.unit target@27@04)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@75@04)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@75@04)))))))))
; Joined path conditions
(pop) ; 10
(push) ; 10
; [else-branch: 65 | !(0 <= i1@74@04)]
(assert (not (<= 0 i1@74@04)))
(pop) ; 10
(pop) ; 9
; Joined path conditions
(assert (implies
  (<= 0 i1@74@04)
  (and
    (<= 0 i1@74@04)
    (implies
      (< i1@74@04 V@28@04)
      (and
        (< i1@74@04 V@28@04)
        (implies
          (<= 0 i2@75@04)
          (and
            (<= 0 i2@75@04)
            (implies
              (< i2@75@04 V@28@04)
              (and
                (< i2@75@04 V@28@04)
                (< i1@74@04 (alen<Int> (opt_get1 $Snap.unit target@27@04)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@74@04)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@74@04))
                (< i2@75@04 (alen<Int> (opt_get1 $Snap.unit target@27@04)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@75@04)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@75@04)))))))))))
; Joined path conditions
(push) ; 9
; [then-branch: 69 | Lookup(option$array$,sm@71@04,aloc((_, _), opt_get1(_, target@27@04), i1@74@04)) == Lookup(option$array$,sm@71@04,aloc((_, _), opt_get1(_, target@27@04), i2@75@04)) && i2@75@04 < V@28@04 && 0 <= i2@75@04 && i1@74@04 < V@28@04 && 0 <= i1@74@04 | live]
; [else-branch: 69 | !(Lookup(option$array$,sm@71@04,aloc((_, _), opt_get1(_, target@27@04), i1@74@04)) == Lookup(option$array$,sm@71@04,aloc((_, _), opt_get1(_, target@27@04), i2@75@04)) && i2@75@04 < V@28@04 && 0 <= i2@75@04 && i1@74@04 < V@28@04 && 0 <= i1@74@04) | live]
(push) ; 10
; [then-branch: 69 | Lookup(option$array$,sm@71@04,aloc((_, _), opt_get1(_, target@27@04), i1@74@04)) == Lookup(option$array$,sm@71@04,aloc((_, _), opt_get1(_, target@27@04), i2@75@04)) && i2@75@04 < V@28@04 && 0 <= i2@75@04 && i1@74@04 < V@28@04 && 0 <= i1@74@04]
(assert (and
  (and
    (and
      (and
        (=
          ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@74@04))
          ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@75@04)))
        (< i2@75@04 V@28@04))
      (<= 0 i2@75@04))
    (< i1@74@04 V@28@04))
  (<= 0 i1@74@04)))
; [eval] i1 == i2
(pop) ; 10
(push) ; 10
; [else-branch: 69 | !(Lookup(option$array$,sm@71@04,aloc((_, _), opt_get1(_, target@27@04), i1@74@04)) == Lookup(option$array$,sm@71@04,aloc((_, _), opt_get1(_, target@27@04), i2@75@04)) && i2@75@04 < V@28@04 && 0 <= i2@75@04 && i1@74@04 < V@28@04 && 0 <= i1@74@04)]
(assert (not
  (and
    (and
      (and
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@74@04))
            ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@75@04)))
          (< i2@75@04 V@28@04))
        (<= 0 i2@75@04))
      (< i1@74@04 V@28@04))
    (<= 0 i1@74@04))))
(pop) ; 10
(pop) ; 9
; Joined path conditions
(assert (implies
  (and
    (and
      (and
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@74@04))
            ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@75@04)))
          (< i2@75@04 V@28@04))
        (<= 0 i2@75@04))
      (< i1@74@04 V@28@04))
    (<= 0 i1@74@04))
  (and
    (=
      ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@74@04))
      ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@75@04)))
    (< i2@75@04 V@28@04)
    (<= 0 i2@75@04)
    (< i1@74@04 V@28@04)
    (<= 0 i1@74@04))))
; Joined path conditions
(pop) ; 8
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i2@75@04 Int)) (!
  (and
    (implies
      (<= 0 i1@74@04)
      (and
        (<= 0 i1@74@04)
        (implies
          (< i1@74@04 V@28@04)
          (and
            (< i1@74@04 V@28@04)
            (implies
              (<= 0 i2@75@04)
              (and
                (<= 0 i2@75@04)
                (implies
                  (< i2@75@04 V@28@04)
                  (and
                    (< i2@75@04 V@28@04)
                    (< i1@74@04 (alen<Int> (opt_get1 $Snap.unit target@27@04)))
                    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@74@04)) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@74@04))
                    (< i2@75@04 (alen<Int> (opt_get1 $Snap.unit target@27@04)))
                    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@75@04)) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@75@04))))))))))
    (implies
      (and
        (and
          (and
            (and
              (=
                ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@74@04))
                ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@75@04)))
              (< i2@75@04 V@28@04))
            (<= 0 i2@75@04))
          (< i1@74@04 V@28@04))
        (<= 0 i1@74@04))
      (and
        (=
          ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@74@04))
          ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@75@04)))
        (< i2@75@04 V@28@04)
        (<= 0 i2@75@04)
        (< i1@74@04 V@28@04)
        (<= 0 i1@74@04))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@75@04))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 7
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@74@04 Int)) (!
  (forall ((i2@75@04 Int)) (!
    (and
      (implies
        (<= 0 i1@74@04)
        (and
          (<= 0 i1@74@04)
          (implies
            (< i1@74@04 V@28@04)
            (and
              (< i1@74@04 V@28@04)
              (implies
                (<= 0 i2@75@04)
                (and
                  (<= 0 i2@75@04)
                  (implies
                    (< i2@75@04 V@28@04)
                    (and
                      (< i2@75@04 V@28@04)
                      (< i1@74@04 (alen<Int> (opt_get1 $Snap.unit target@27@04)))
                      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@74@04)) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@74@04))
                      (< i2@75@04 (alen<Int> (opt_get1 $Snap.unit target@27@04)))
                      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@75@04)) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@75@04))))))))))
      (implies
        (and
          (and
            (and
              (and
                (=
                  ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@74@04))
                  ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@75@04)))
                (< i2@75@04 V@28@04))
              (<= 0 i2@75@04))
            (< i1@74@04 V@28@04))
          (<= 0 i1@74@04))
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@74@04))
            ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@75@04)))
          (< i2@75@04 V@28@04)
          (<= 0 i2@75@04)
          (< i1@74@04 V@28@04)
          (<= 0 i1@74@04))))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@75@04))
    :qid |prog.l<no position>-aux|))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@74@04))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 6
(pop) ; 5
; Joined path conditions
(assert (implies
  (= exc@29@04 $Ref.null)
  (forall ((i1@74@04 Int)) (!
    (forall ((i2@75@04 Int)) (!
      (and
        (implies
          (<= 0 i1@74@04)
          (and
            (<= 0 i1@74@04)
            (implies
              (< i1@74@04 V@28@04)
              (and
                (< i1@74@04 V@28@04)
                (implies
                  (<= 0 i2@75@04)
                  (and
                    (<= 0 i2@75@04)
                    (implies
                      (< i2@75@04 V@28@04)
                      (and
                        (< i2@75@04 V@28@04)
                        (<
                          i1@74@04
                          (alen<Int> (opt_get1 $Snap.unit target@27@04)))
                        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
                          $Snap.unit
                          $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@74@04)) (aloc ($Snap.combine
                          $Snap.unit
                          $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@74@04))
                        (<
                          i2@75@04
                          (alen<Int> (opt_get1 $Snap.unit target@27@04)))
                        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
                          $Snap.unit
                          $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@75@04)) (aloc ($Snap.combine
                          $Snap.unit
                          $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@75@04))))))))))
        (implies
          (and
            (and
              (and
                (and
                  (=
                    ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@74@04))
                    ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@75@04)))
                  (< i2@75@04 V@28@04))
                (<= 0 i2@75@04))
              (< i1@74@04 V@28@04))
            (<= 0 i1@74@04))
          (and
            (=
              ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@74@04))
              ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@75@04)))
            (< i2@75@04 V@28@04)
            (<= 0 i2@75@04)
            (< i1@74@04 V@28@04)
            (<= 0 i1@74@04))))
      :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@75@04))
      :qid |prog.l<no position>-aux|))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@74@04))
    :qid |prog.l<no position>-aux|))))
(assert (implies
  (= exc@29@04 $Ref.null)
  (forall ((i1@74@04 Int)) (!
    (forall ((i2@75@04 Int)) (!
      (implies
        (and
          (and
            (and
              (and
                (=
                  ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@74@04))
                  ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@75@04)))
                (< i2@75@04 V@28@04))
              (<= 0 i2@75@04))
            (< i1@74@04 V@28@04))
          (<= 0 i1@74@04))
        (= i1@74@04 i2@75@04))
      :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@75@04))
      :qid |prog.l<no position>|))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@74@04))
    :qid |prog.l<no position>|))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@59@04)))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@59@04))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@59@04)))))))))))))))))
; [eval] exc == null
(set-option :timeout 10)
(push) ; 5
(assert (not (not (= exc@29@04 $Ref.null))))
(check-sat)
; unknown
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1628
;  :arith-add-rows          489
;  :arith-assert-diseq      50
;  :arith-assert-lower      313
;  :arith-assert-upper      198
;  :arith-bound-prop        106
;  :arith-conflicts         43
;  :arith-eq-adapter        192
;  :arith-fixed-eqs         92
;  :arith-offset-eqs        86
;  :arith-pivots            300
;  :conflicts               128
;  :datatype-accessor-ax    38
;  :datatype-constructor-ax 120
;  :datatype-occurs-check   85
;  :datatype-splits         52
;  :decisions               204
;  :del-clause              1342
;  :final-checks            50
;  :max-generation          4
;  :max-memory              5.21
;  :memory                  5.20
;  :mk-bool-var             2914
;  :mk-clause               1346
;  :num-allocs              212611
;  :num-checks              96
;  :propagations            541
;  :quant-instantiations    738
;  :rlimit-count            295732)
; [then-branch: 70 | exc@29@04 == Null | live]
; [else-branch: 70 | exc@29@04 != Null | dead]
(push) ; 5
; [then-branch: 70 | exc@29@04 == Null]
(declare-const i1@76@04 Int)
(declare-const j1@77@04 Int)
(push) ; 6
; [eval] 0 <= i1 && i1 < V && (0 <= j1 && j1 < V)
; [eval] 0 <= i1
(push) ; 7
; [then-branch: 71 | 0 <= i1@76@04 | live]
; [else-branch: 71 | !(0 <= i1@76@04) | live]
(push) ; 8
; [then-branch: 71 | 0 <= i1@76@04]
(assert (<= 0 i1@76@04))
; [eval] i1 < V
(push) ; 9
; [then-branch: 72 | i1@76@04 < V@28@04 | live]
; [else-branch: 72 | !(i1@76@04 < V@28@04) | live]
(push) ; 10
; [then-branch: 72 | i1@76@04 < V@28@04]
(assert (< i1@76@04 V@28@04))
; [eval] 0 <= j1
(push) ; 11
; [then-branch: 73 | 0 <= j1@77@04 | live]
; [else-branch: 73 | !(0 <= j1@77@04) | live]
(push) ; 12
; [then-branch: 73 | 0 <= j1@77@04]
(assert (<= 0 j1@77@04))
; [eval] j1 < V
(pop) ; 12
(push) ; 12
; [else-branch: 73 | !(0 <= j1@77@04)]
(assert (not (<= 0 j1@77@04)))
(pop) ; 12
(pop) ; 11
; Joined path conditions
; Joined path conditions
(pop) ; 10
(push) ; 10
; [else-branch: 72 | !(i1@76@04 < V@28@04)]
(assert (not (< i1@76@04 V@28@04)))
(pop) ; 10
(pop) ; 9
; Joined path conditions
; Joined path conditions
(pop) ; 8
(push) ; 8
; [else-branch: 71 | !(0 <= i1@76@04)]
(assert (not (<= 0 i1@76@04)))
(pop) ; 8
(pop) ; 7
; Joined path conditions
; Joined path conditions
(assert (and
  (and (and (< j1@77@04 V@28@04) (<= 0 j1@77@04)) (< i1@76@04 V@28@04))
  (<= 0 i1@76@04)))
; [eval] aloc(opt_get1(aloc(opt_get1(source), i1).option$array$), j1)
; [eval] opt_get1(aloc(opt_get1(source), i1).option$array$)
; [eval] aloc(opt_get1(source), i1)
; [eval] opt_get1(source)
(push) ; 7
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 7
; Joined path conditions
(push) ; 7
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 8
(assert (not (< i1@76@04 (alen<Int> (opt_get1 $Snap.unit source@26@04)))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1630
;  :arith-add-rows          495
;  :arith-assert-diseq      50
;  :arith-assert-lower      321
;  :arith-assert-upper      200
;  :arith-bound-prop        106
;  :arith-conflicts         43
;  :arith-eq-adapter        194
;  :arith-fixed-eqs         94
;  :arith-offset-eqs        86
;  :arith-pivots            304
;  :conflicts               128
;  :datatype-accessor-ax    38
;  :datatype-constructor-ax 120
;  :datatype-occurs-check   85
;  :datatype-splits         52
;  :decisions               204
;  :del-clause              1342
;  :final-checks            50
;  :max-generation          4
;  :max-memory              5.21
;  :memory                  5.20
;  :mk-bool-var             2924
;  :mk-clause               1346
;  :num-allocs              212914
;  :num-checks              97
;  :propagations            541
;  :quant-instantiations    738
;  :rlimit-count            296315)
(assert (< i1@76@04 (alen<Int> (opt_get1 $Snap.unit source@26@04))))
(pop) ; 7
; Joined path conditions
(assert (< i1@76@04 (alen<Int> (opt_get1 $Snap.unit source@26@04))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@76@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@76@04)))
(push) ; 7
(assert (not (<
  $Perm.No
  (+
    (ite
      (and
        (<
          (inv@70@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@76@04))
          V@28@04)
        (<=
          0
          (inv@70@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@76@04))))
      $k@69@04
      $Perm.No)
    (ite
      (and
        (<
          (inv@62@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@76@04))
          V@28@04)
        (<=
          0
          (inv@62@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@76@04))))
      $k@61@04
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1700
;  :arith-add-rows          511
;  :arith-assert-diseq      53
;  :arith-assert-lower      332
;  :arith-assert-upper      209
;  :arith-bound-prop        112
;  :arith-conflicts         45
;  :arith-eq-adapter        205
;  :arith-fixed-eqs         98
;  :arith-offset-eqs        94
;  :arith-pivots            310
;  :conflicts               137
;  :datatype-accessor-ax    38
;  :datatype-constructor-ax 124
;  :datatype-occurs-check   85
;  :datatype-splits         52
;  :decisions               212
;  :del-clause              1382
;  :final-checks            50
;  :max-generation          4
;  :max-memory              5.26
;  :memory                  5.24
;  :mk-bool-var             3063
;  :mk-clause               1431
;  :num-allocs              213716
;  :num-checks              98
;  :propagations            576
;  :quant-instantiations    778
;  :rlimit-count            298941)
(push) ; 7
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 8
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@76@04))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1723
;  :arith-add-rows          512
;  :arith-assert-diseq      53
;  :arith-assert-lower      332
;  :arith-assert-upper      211
;  :arith-bound-prop        113
;  :arith-conflicts         46
;  :arith-eq-adapter        205
;  :arith-fixed-eqs         98
;  :arith-offset-eqs        94
;  :arith-pivots            310
;  :conflicts               145
;  :datatype-accessor-ax    38
;  :datatype-constructor-ax 128
;  :datatype-occurs-check   85
;  :datatype-splits         52
;  :decisions               219
;  :del-clause              1387
;  :final-checks            50
;  :max-generation          4
;  :max-memory              5.26
;  :memory                  5.23
;  :mk-bool-var             3071
;  :mk-clause               1436
;  :num-allocs              213830
;  :num-checks              99
;  :propagations            581
;  :quant-instantiations    781
;  :rlimit-count            299249)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@76@04))
    (as None<option<array>>  option<array>))))
(pop) ; 7
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@76@04))
    (as None<option<array>>  option<array>))))
(push) ; 7
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 8
(assert (not (<
  j1@77@04
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@76@04)))))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1774
;  :arith-add-rows          527
;  :arith-assert-diseq      53
;  :arith-assert-lower      337
;  :arith-assert-upper      214
;  :arith-bound-prop        115
;  :arith-conflicts         48
;  :arith-eq-adapter        207
;  :arith-fixed-eqs         99
;  :arith-offset-eqs        97
;  :arith-pivots            312
;  :conflicts               153
;  :datatype-accessor-ax    38
;  :datatype-constructor-ax 132
;  :datatype-occurs-check   85
;  :datatype-splits         52
;  :decisions               226
;  :del-clause              1394
;  :final-checks            50
;  :max-generation          4
;  :max-memory              5.26
;  :memory                  5.23
;  :mk-bool-var             3100
;  :mk-clause               1443
;  :num-allocs              214080
;  :num-checks              100
;  :propagations            593
;  :quant-instantiations    793
;  :rlimit-count            300012)
(assert (<
  j1@77@04
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@76@04))))))
(pop) ; 7
; Joined path conditions
(assert (<
  j1@77@04
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@76@04))))))
(declare-const $k@78@04 $Perm)
(assert ($Perm.isReadVar $k@78@04 $Perm.Write))
(pop) ; 6
(declare-fun inv@79@04 ($Ref) Int)
(declare-fun inv@80@04 ($Ref) Int)
; Nested auxiliary terms: globals
(assert ($Perm.isReadVar $k@78@04 $Perm.Write))
; Nested auxiliary terms: non-globals
(assert (forall ((i1@76@04 Int) (j1@77@04 Int)) (!
  (and
    (< i1@76@04 (alen<Int> (opt_get1 $Snap.unit source@26@04)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@76@04)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@76@04))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@76@04))
        (as None<option<array>>  option<array>)))
    (<
      j1@77@04
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@76@04))))))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@76@04))) j1@77@04))
  :qid |int-aux|)))
(push) ; 6
(assert (not (forall ((i1@76@04 Int) (j1@77@04 Int)) (!
  (implies
    (and
      (and (and (< j1@77@04 V@28@04) (<= 0 j1@77@04)) (< i1@76@04 V@28@04))
      (<= 0 i1@76@04))
    (or (= $k@78@04 $Perm.No) (< $Perm.No $k@78@04)))
  
  ))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1774
;  :arith-add-rows          530
;  :arith-assert-diseq      54
;  :arith-assert-lower      339
;  :arith-assert-upper      215
;  :arith-bound-prop        115
;  :arith-conflicts         48
;  :arith-eq-adapter        208
;  :arith-fixed-eqs         99
;  :arith-offset-eqs        97
;  :arith-pivots            316
;  :conflicts               154
;  :datatype-accessor-ax    38
;  :datatype-constructor-ax 132
;  :datatype-occurs-check   85
;  :datatype-splits         52
;  :decisions               226
;  :del-clause              1439
;  :final-checks            50
;  :max-generation          4
;  :max-memory              5.26
;  :memory                  5.23
;  :mk-bool-var             3109
;  :mk-clause               1445
;  :num-allocs              214646
;  :num-checks              101
;  :propagations            594
;  :quant-instantiations    793
;  :rlimit-count            300999)
; Check receiver injectivity
(push) ; 6
(assert (not (forall ((i11@76@04 Int) (j11@77@04 Int) (i12@76@04 Int) (j12@77@04 Int)) (!
  (implies
    (and
      (and
        (and
          (and
            (and (< j11@77@04 V@28@04) (<= 0 j11@77@04))
            (< i11@76@04 V@28@04))
          (<= 0 i11@76@04))
        (< $Perm.No $k@78@04))
      (and
        (and
          (and
            (and (< j12@77@04 V@28@04) (<= 0 j12@77@04))
            (< i12@76@04 V@28@04))
          (<= 0 i12@76@04))
        (< $Perm.No $k@78@04))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@26@04) i11@76@04))) j11@77@04)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@26@04) i12@76@04))) j12@77@04)))
    (and (= i11@76@04 i12@76@04) (= j11@77@04 j12@77@04)))
  
  :qid |int-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1882
;  :arith-add-rows          585
;  :arith-assert-diseq      56
;  :arith-assert-lower      360
;  :arith-assert-upper      230
;  :arith-bound-prop        121
;  :arith-conflicts         50
;  :arith-eq-adapter        217
;  :arith-fixed-eqs         107
;  :arith-offset-eqs        102
;  :arith-pivots            345
;  :conflicts               166
;  :datatype-accessor-ax    38
;  :datatype-constructor-ax 136
;  :datatype-occurs-check   85
;  :datatype-splits         52
;  :decisions               237
;  :del-clause              1562
;  :final-checks            50
;  :max-generation          4
;  :max-memory              5.44
;  :memory                  5.42
;  :mk-bool-var             3359
;  :mk-clause               1568
;  :num-allocs              216078
;  :num-checks              102
;  :propagations            639
;  :quant-instantiations    897
;  :rlimit-count            307437
;  :time                    0.00)
; Definitional axioms for inverse functions
(assert (forall ((i1@76@04 Int) (j1@77@04 Int)) (!
  (implies
    (and
      (and
        (and (and (< j1@77@04 V@28@04) (<= 0 j1@77@04)) (< i1@76@04 V@28@04))
        (<= 0 i1@76@04))
      (< $Perm.No $k@78@04))
    (and
      (=
        (inv@79@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@76@04))) j1@77@04))
        i1@76@04)
      (=
        (inv@80@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@76@04))) j1@77@04))
        j1@77@04)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@76@04))) j1@77@04))
  )))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and
          (and (< (inv@80@04 r) V@28@04) (<= 0 (inv@80@04 r)))
          (< (inv@79@04 r) V@28@04))
        (<= 0 (inv@79@04 r)))
      (< $Perm.No $k@78@04))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@26@04) (inv@79@04 r)))) (inv@80@04 r))
      r))
  :pattern ((inv@79@04 r))
  :pattern ((inv@80@04 r))
  :qid |int-fctOfInv|)))
; Permissions are non-negative
(assert (forall ((i1@76@04 Int) (j1@77@04 Int)) (!
  (<= $Perm.No $k@78@04)
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@76@04))) j1@77@04))
  :qid |int-permAtLeastZero|)))
; Field permissions are at most one
(assert (forall ((i1@76@04 Int) (j1@77@04 Int)) (!
  (<= $k@78@04 $Perm.Write)
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@76@04))) j1@77@04))
  :qid |int-permAtMostOne|)))
; Permission implies non-null receiver
(assert (forall ((i1@76@04 Int) (j1@77@04 Int)) (!
  (implies
    (and
      (and
        (and (and (< j1@77@04 V@28@04) (<= 0 j1@77@04)) (< i1@76@04 V@28@04))
        (<= 0 i1@76@04))
      (< $Perm.No $k@78@04))
    (not
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@76@04))) j1@77@04)
        $Ref.null)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@76@04))) j1@77@04))
  :qid |int-permImpliesNonNull|)))
(declare-const sm@81@04 $FVF<Int>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and
        (and
          (and (< (inv@80@04 r) V@28@04) (<= 0 (inv@80@04 r)))
          (< (inv@79@04 r) V@28@04))
        (<= 0 (inv@79@04 r)))
      (< $Perm.No $k@78@04)
      false)
    (=
      ($FVF.lookup_int (as sm@81@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@59@04))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@81@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@59@04))))))))))))))) r))
  :qid |qp.fvfValDef19|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@59@04))))))))))))))) r) r)
  :pattern (($FVF.lookup_int (as sm@81@04  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef20|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@80@04 r) V@28@04) (<= 0 (inv@80@04 r)))
        (< (inv@79@04 r) V@28@04))
      (<= 0 (inv@79@04 r)))
    ($FVF.loc_int ($FVF.lookup_int (as sm@81@04  $FVF<Int>) r) r))
  :pattern ((inv@79@04 r) (inv@80@04 r))
  )))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@59@04))))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@59@04)))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@59@04))))))))))))))))))
; [eval] exc == null
(set-option :timeout 10)
(push) ; 6
(assert (not (not (= exc@29@04 $Ref.null))))
(check-sat)
; unknown
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1925
;  :arith-add-rows          585
;  :arith-assert-diseq      56
;  :arith-assert-lower      360
;  :arith-assert-upper      231
;  :arith-bound-prop        121
;  :arith-conflicts         50
;  :arith-eq-adapter        217
;  :arith-fixed-eqs         107
;  :arith-offset-eqs        102
;  :arith-pivots            345
;  :conflicts               166
;  :datatype-accessor-ax    39
;  :datatype-constructor-ax 145
;  :datatype-occurs-check   90
;  :datatype-splits         57
;  :decisions               246
;  :del-clause              1562
;  :final-checks            52
;  :max-generation          4
;  :max-memory              5.45
;  :memory                  5.43
;  :mk-bool-var             3372
;  :mk-clause               1568
;  :num-allocs              217892
;  :num-checks              103
;  :propagations            639
;  :quant-instantiations    897
;  :rlimit-count            311642)
; [then-branch: 74 | exc@29@04 == Null | live]
; [else-branch: 74 | exc@29@04 != Null | dead]
(push) ; 6
; [then-branch: 74 | exc@29@04 == Null]
(declare-const i1@82@04 Int)
(declare-const j1@83@04 Int)
(push) ; 7
; [eval] 0 <= i1 && i1 < V && (0 <= j1 && j1 < V)
; [eval] 0 <= i1
(push) ; 8
; [then-branch: 75 | 0 <= i1@82@04 | live]
; [else-branch: 75 | !(0 <= i1@82@04) | live]
(push) ; 9
; [then-branch: 75 | 0 <= i1@82@04]
(assert (<= 0 i1@82@04))
; [eval] i1 < V
(push) ; 10
; [then-branch: 76 | i1@82@04 < V@28@04 | live]
; [else-branch: 76 | !(i1@82@04 < V@28@04) | live]
(push) ; 11
; [then-branch: 76 | i1@82@04 < V@28@04]
(assert (< i1@82@04 V@28@04))
; [eval] 0 <= j1
(push) ; 12
; [then-branch: 77 | 0 <= j1@83@04 | live]
; [else-branch: 77 | !(0 <= j1@83@04) | live]
(push) ; 13
; [then-branch: 77 | 0 <= j1@83@04]
(assert (<= 0 j1@83@04))
; [eval] j1 < V
(pop) ; 13
(push) ; 13
; [else-branch: 77 | !(0 <= j1@83@04)]
(assert (not (<= 0 j1@83@04)))
(pop) ; 13
(pop) ; 12
; Joined path conditions
; Joined path conditions
(pop) ; 11
(push) ; 11
; [else-branch: 76 | !(i1@82@04 < V@28@04)]
(assert (not (< i1@82@04 V@28@04)))
(pop) ; 11
(pop) ; 10
; Joined path conditions
; Joined path conditions
(pop) ; 9
(push) ; 9
; [else-branch: 75 | !(0 <= i1@82@04)]
(assert (not (<= 0 i1@82@04)))
(pop) ; 9
(pop) ; 8
; Joined path conditions
; Joined path conditions
(assert (and
  (and (and (< j1@83@04 V@28@04) (<= 0 j1@83@04)) (< i1@82@04 V@28@04))
  (<= 0 i1@82@04)))
; [eval] aloc(opt_get1(aloc(opt_get1(target), i1).option$array$), j1)
; [eval] opt_get1(aloc(opt_get1(target), i1).option$array$)
; [eval] aloc(opt_get1(target), i1)
; [eval] opt_get1(target)
(push) ; 8
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 8
; Joined path conditions
(push) ; 8
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 9
(assert (not (< i1@82@04 (alen<Int> (opt_get1 $Snap.unit target@27@04)))))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1927
;  :arith-add-rows          593
;  :arith-assert-diseq      56
;  :arith-assert-lower      368
;  :arith-assert-upper      233
;  :arith-bound-prop        121
;  :arith-conflicts         50
;  :arith-eq-adapter        219
;  :arith-fixed-eqs         109
;  :arith-offset-eqs        102
;  :arith-pivots            352
;  :conflicts               166
;  :datatype-accessor-ax    39
;  :datatype-constructor-ax 145
;  :datatype-occurs-check   90
;  :datatype-splits         57
;  :decisions               246
;  :del-clause              1562
;  :final-checks            52
;  :max-generation          4
;  :max-memory              5.45
;  :memory                  5.43
;  :mk-bool-var             3382
;  :mk-clause               1568
;  :num-allocs              218197
;  :num-checks              104
;  :propagations            639
;  :quant-instantiations    897
;  :rlimit-count            312281)
(assert (< i1@82@04 (alen<Int> (opt_get1 $Snap.unit target@27@04))))
(pop) ; 8
; Joined path conditions
(assert (< i1@82@04 (alen<Int> (opt_get1 $Snap.unit target@27@04))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@82@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@82@04)))
(push) ; 8
(assert (not (<
  $Perm.No
  (+
    (ite
      (and
        (<
          (inv@70@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@82@04))
          V@28@04)
        (<=
          0
          (inv@70@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@82@04))))
      $k@69@04
      $Perm.No)
    (ite
      (and
        (<
          (inv@62@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@82@04))
          V@28@04)
        (<=
          0
          (inv@62@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@82@04))))
      $k@61@04
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               2036
;  :arith-add-rows          618
;  :arith-assert-diseq      60
;  :arith-assert-lower      382
;  :arith-assert-upper      241
;  :arith-bound-prop        130
;  :arith-conflicts         52
;  :arith-eq-adapter        232
;  :arith-fixed-eqs         113
;  :arith-offset-eqs        109
;  :arith-pivots            360
;  :conflicts               177
;  :datatype-accessor-ax    39
;  :datatype-constructor-ax 149
;  :datatype-occurs-check   90
;  :datatype-splits         57
;  :decisions               272
;  :del-clause              1709
;  :final-checks            52
;  :max-generation          4
;  :max-memory              5.45
;  :memory                  5.43
;  :mk-bool-var             3663
;  :mk-clause               1785
;  :num-allocs              219223
;  :num-checks              105
;  :propagations            706
;  :quant-instantiations    956
;  :rlimit-count            316244
;  :time                    0.00)
(push) ; 8
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 9
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@82@04))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               2036
;  :arith-add-rows          618
;  :arith-assert-diseq      60
;  :arith-assert-lower      382
;  :arith-assert-upper      241
;  :arith-bound-prop        130
;  :arith-conflicts         52
;  :arith-eq-adapter        232
;  :arith-fixed-eqs         113
;  :arith-offset-eqs        109
;  :arith-pivots            360
;  :conflicts               178
;  :datatype-accessor-ax    39
;  :datatype-constructor-ax 149
;  :datatype-occurs-check   90
;  :datatype-splits         57
;  :decisions               272
;  :del-clause              1709
;  :final-checks            52
;  :max-generation          4
;  :max-memory              5.45
;  :memory                  5.43
;  :mk-bool-var             3663
;  :mk-clause               1785
;  :num-allocs              219312
;  :num-checks              106
;  :propagations            706
;  :quant-instantiations    956
;  :rlimit-count            316339)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@82@04))
    (as None<option<array>>  option<array>))))
(pop) ; 8
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@82@04))
    (as None<option<array>>  option<array>))))
(push) ; 8
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 9
(assert (not (<
  j1@83@04
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@82@04)))))))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               2042
;  :arith-add-rows          621
;  :arith-assert-diseq      60
;  :arith-assert-lower      385
;  :arith-assert-upper      242
;  :arith-bound-prop        130
;  :arith-conflicts         53
;  :arith-eq-adapter        233
;  :arith-fixed-eqs         114
;  :arith-offset-eqs        109
;  :arith-pivots            362
;  :conflicts               179
;  :datatype-accessor-ax    39
;  :datatype-constructor-ax 149
;  :datatype-occurs-check   90
;  :datatype-splits         57
;  :decisions               272
;  :del-clause              1713
;  :final-checks            52
;  :max-generation          4
;  :max-memory              5.45
;  :memory                  5.43
;  :mk-bool-var             3674
;  :mk-clause               1789
;  :num-allocs              219513
;  :num-checks              107
;  :propagations            708
;  :quant-instantiations    963
;  :rlimit-count            316796)
(assert (<
  j1@83@04
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@82@04))))))
(pop) ; 8
; Joined path conditions
(assert (<
  j1@83@04
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@82@04))))))
(pop) ; 7
(declare-fun inv@84@04 ($Ref) Int)
(declare-fun inv@85@04 ($Ref) Int)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(assert (forall ((i1@82@04 Int) (j1@83@04 Int)) (!
  (and
    (< i1@82@04 (alen<Int> (opt_get1 $Snap.unit target@27@04)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@82@04)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@82@04))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@82@04))
        (as None<option<array>>  option<array>)))
    (<
      j1@83@04
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@82@04))))))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@82@04))) j1@83@04))
  :qid |int-aux|)))
; Check receiver injectivity
(push) ; 7
(assert (not (forall ((i11@82@04 Int) (j11@83@04 Int) (i12@82@04 Int) (j12@83@04 Int)) (!
  (implies
    (and
      (and
        (and (and (< j11@83@04 V@28@04) (<= 0 j11@83@04)) (< i11@82@04 V@28@04))
        (<= 0 i11@82@04))
      (and
        (and (and (< j12@83@04 V@28@04) (<= 0 j12@83@04)) (< i12@82@04 V@28@04))
        (<= 0 i12@82@04))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@27@04) i11@82@04))) j11@83@04)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@27@04) i12@82@04))) j12@83@04)))
    (and (= i11@82@04 i12@82@04) (= j11@83@04 j12@83@04)))
  
  :qid |int-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               2084
;  :arith-add-rows          653
;  :arith-assert-diseq      60
;  :arith-assert-lower      400
;  :arith-assert-upper      245
;  :arith-bound-prop        132
;  :arith-conflicts         53
;  :arith-eq-adapter        242
;  :arith-fixed-eqs         117
;  :arith-offset-eqs        110
;  :arith-pivots            381
;  :conflicts               180
;  :datatype-accessor-ax    39
;  :datatype-constructor-ax 149
;  :datatype-occurs-check   90
;  :datatype-splits         57
;  :decisions               272
;  :del-clause              1881
;  :final-checks            52
;  :max-generation          4
;  :max-memory              5.49
;  :memory                  5.47
;  :mk-bool-var             3893
;  :mk-clause               1887
;  :num-allocs              221015
;  :num-checks              108
;  :propagations            738
;  :quant-instantiations    1054
;  :rlimit-count            322236
;  :time                    0.00)
; Definitional axioms for inverse functions
(assert (forall ((i1@82@04 Int) (j1@83@04 Int)) (!
  (implies
    (and
      (and (and (< j1@83@04 V@28@04) (<= 0 j1@83@04)) (< i1@82@04 V@28@04))
      (<= 0 i1@82@04))
    (and
      (=
        (inv@84@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@82@04))) j1@83@04))
        i1@82@04)
      (=
        (inv@85@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@82@04))) j1@83@04))
        j1@83@04)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@82@04))) j1@83@04))
  )))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@85@04 r) V@28@04) (<= 0 (inv@85@04 r)))
        (< (inv@84@04 r) V@28@04))
      (<= 0 (inv@84@04 r)))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@27@04) (inv@84@04 r)))) (inv@85@04 r))
      r))
  :pattern ((inv@84@04 r))
  :pattern ((inv@85@04 r))
  :qid |int-fctOfInv|)))
; Permissions are non-negative
; Field permissions are at most one
; Permission implies non-null receiver
(assert (forall ((i1@82@04 Int) (j1@83@04 Int)) (!
  (implies
    (and
      (and (and (< j1@83@04 V@28@04) (<= 0 j1@83@04)) (< i1@82@04 V@28@04))
      (<= 0 i1@82@04))
    (not
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@82@04))) j1@83@04)
        $Ref.null)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@82@04))) j1@83@04))
  :qid |int-permImpliesNonNull|)))
(declare-const sm@86@04 $FVF<Int>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@85@04 r) V@28@04) (<= 0 (inv@85@04 r)))
        (< (inv@84@04 r) V@28@04))
      (<= 0 (inv@84@04 r)))
    (=
      ($FVF.lookup_int (as sm@86@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@59@04)))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@86@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@59@04)))))))))))))))) r))
  :qid |qp.fvfValDef21|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and
        (and
          (and (< (inv@80@04 r) V@28@04) (<= 0 (inv@80@04 r)))
          (< (inv@79@04 r) V@28@04))
        (<= 0 (inv@79@04 r)))
      (< $Perm.No $k@78@04)
      false)
    (=
      ($FVF.lookup_int (as sm@86@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@59@04))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@86@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@59@04))))))))))))))) r))
  :qid |qp.fvfValDef22|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@59@04)))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@59@04))))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@86@04  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef23|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@85@04 r) V@28@04) (<= 0 (inv@85@04 r)))
        (< (inv@84@04 r) V@28@04))
      (<= 0 (inv@84@04 r)))
    ($FVF.loc_int ($FVF.lookup_int (as sm@86@04  $FVF<Int>) r) r))
  :pattern ((inv@84@04 r) (inv@85@04 r))
  )))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@59@04)))))))))))))))
  $Snap.unit))
; [eval] exc == null ==> (forall unknown: Int :: { opt_get1(aloc(opt_get1(target), unknown).option$array$) } { opt_get1(aloc(opt_get1(source), unknown).option$array$) } 0 <= unknown && unknown < V ==> (forall unknown1: Int :: { aloc(opt_get1(aloc(opt_get1(target), unknown).option$array$), unknown1) } { aloc(opt_get1(aloc(opt_get1(source), unknown).option$array$), unknown1) } 0 <= unknown1 && unknown1 < V ==> aloc(opt_get1(aloc(opt_get1(target), unknown).option$array$), unknown1).int == aloc(opt_get1(aloc(opt_get1(source), unknown).option$array$), unknown1).int))
; [eval] exc == null
(push) ; 7
(set-option :timeout 10)
(push) ; 8
(assert (not (not (= exc@29@04 $Ref.null))))
(check-sat)
; unknown
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               2122
;  :arith-add-rows          653
;  :arith-assert-diseq      60
;  :arith-assert-lower      400
;  :arith-assert-upper      245
;  :arith-bound-prop        132
;  :arith-conflicts         53
;  :arith-eq-adapter        242
;  :arith-fixed-eqs         117
;  :arith-offset-eqs        110
;  :arith-pivots            381
;  :conflicts               180
;  :datatype-accessor-ax    39
;  :datatype-constructor-ax 157
;  :datatype-occurs-check   95
;  :datatype-splits         61
;  :decisions               280
;  :del-clause              1881
;  :final-checks            54
;  :max-generation          4
;  :max-memory              5.49
;  :memory                  5.48
;  :mk-bool-var             3905
;  :mk-clause               1887
;  :num-allocs              222779
;  :num-checks              109
;  :propagations            738
;  :quant-instantiations    1054
;  :rlimit-count            326695)
; [then-branch: 78 | exc@29@04 == Null | live]
; [else-branch: 78 | exc@29@04 != Null | dead]
(push) ; 8
; [then-branch: 78 | exc@29@04 == Null]
; [eval] (forall unknown: Int :: { opt_get1(aloc(opt_get1(target), unknown).option$array$) } { opt_get1(aloc(opt_get1(source), unknown).option$array$) } 0 <= unknown && unknown < V ==> (forall unknown1: Int :: { aloc(opt_get1(aloc(opt_get1(target), unknown).option$array$), unknown1) } { aloc(opt_get1(aloc(opt_get1(source), unknown).option$array$), unknown1) } 0 <= unknown1 && unknown1 < V ==> aloc(opt_get1(aloc(opt_get1(target), unknown).option$array$), unknown1).int == aloc(opt_get1(aloc(opt_get1(source), unknown).option$array$), unknown1).int))
(declare-const unknown@87@04 Int)
(push) ; 9
; [eval] 0 <= unknown && unknown < V ==> (forall unknown1: Int :: { aloc(opt_get1(aloc(opt_get1(target), unknown).option$array$), unknown1) } { aloc(opt_get1(aloc(opt_get1(source), unknown).option$array$), unknown1) } 0 <= unknown1 && unknown1 < V ==> aloc(opt_get1(aloc(opt_get1(target), unknown).option$array$), unknown1).int == aloc(opt_get1(aloc(opt_get1(source), unknown).option$array$), unknown1).int)
; [eval] 0 <= unknown && unknown < V
; [eval] 0 <= unknown
(push) ; 10
; [then-branch: 79 | 0 <= unknown@87@04 | live]
; [else-branch: 79 | !(0 <= unknown@87@04) | live]
(push) ; 11
; [then-branch: 79 | 0 <= unknown@87@04]
(assert (<= 0 unknown@87@04))
; [eval] unknown < V
(pop) ; 11
(push) ; 11
; [else-branch: 79 | !(0 <= unknown@87@04)]
(assert (not (<= 0 unknown@87@04)))
(pop) ; 11
(pop) ; 10
; Joined path conditions
; Joined path conditions
(push) ; 10
; [then-branch: 80 | unknown@87@04 < V@28@04 && 0 <= unknown@87@04 | live]
; [else-branch: 80 | !(unknown@87@04 < V@28@04 && 0 <= unknown@87@04) | live]
(push) ; 11
; [then-branch: 80 | unknown@87@04 < V@28@04 && 0 <= unknown@87@04]
(assert (and (< unknown@87@04 V@28@04) (<= 0 unknown@87@04)))
; [eval] (forall unknown1: Int :: { aloc(opt_get1(aloc(opt_get1(target), unknown).option$array$), unknown1) } { aloc(opt_get1(aloc(opt_get1(source), unknown).option$array$), unknown1) } 0 <= unknown1 && unknown1 < V ==> aloc(opt_get1(aloc(opt_get1(target), unknown).option$array$), unknown1).int == aloc(opt_get1(aloc(opt_get1(source), unknown).option$array$), unknown1).int)
(declare-const unknown1@88@04 Int)
(push) ; 12
; [eval] 0 <= unknown1 && unknown1 < V ==> aloc(opt_get1(aloc(opt_get1(target), unknown).option$array$), unknown1).int == aloc(opt_get1(aloc(opt_get1(source), unknown).option$array$), unknown1).int
; [eval] 0 <= unknown1 && unknown1 < V
; [eval] 0 <= unknown1
(push) ; 13
; [then-branch: 81 | 0 <= unknown1@88@04 | live]
; [else-branch: 81 | !(0 <= unknown1@88@04) | live]
(push) ; 14
; [then-branch: 81 | 0 <= unknown1@88@04]
(assert (<= 0 unknown1@88@04))
; [eval] unknown1 < V
(pop) ; 14
(push) ; 14
; [else-branch: 81 | !(0 <= unknown1@88@04)]
(assert (not (<= 0 unknown1@88@04)))
(pop) ; 14
(pop) ; 13
; Joined path conditions
; Joined path conditions
(push) ; 13
; [then-branch: 82 | unknown1@88@04 < V@28@04 && 0 <= unknown1@88@04 | live]
; [else-branch: 82 | !(unknown1@88@04 < V@28@04 && 0 <= unknown1@88@04) | live]
(push) ; 14
; [then-branch: 82 | unknown1@88@04 < V@28@04 && 0 <= unknown1@88@04]
(assert (and (< unknown1@88@04 V@28@04) (<= 0 unknown1@88@04)))
; [eval] aloc(opt_get1(aloc(opt_get1(target), unknown).option$array$), unknown1).int == aloc(opt_get1(aloc(opt_get1(source), unknown).option$array$), unknown1).int
; [eval] aloc(opt_get1(aloc(opt_get1(target), unknown).option$array$), unknown1)
; [eval] opt_get1(aloc(opt_get1(target), unknown).option$array$)
; [eval] aloc(opt_get1(target), unknown)
; [eval] opt_get1(target)
(push) ; 15
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 15
; Joined path conditions
(push) ; 15
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 16
(assert (not (< unknown@87@04 (alen<Int> (opt_get1 $Snap.unit target@27@04)))))
(check-sat)
; unsat
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               2123
;  :arith-add-rows          656
;  :arith-assert-diseq      60
;  :arith-assert-lower      405
;  :arith-assert-upper      246
;  :arith-bound-prop        132
;  :arith-conflicts         53
;  :arith-eq-adapter        243
;  :arith-fixed-eqs         118
;  :arith-offset-eqs        110
;  :arith-pivots            382
;  :conflicts               180
;  :datatype-accessor-ax    39
;  :datatype-constructor-ax 157
;  :datatype-occurs-check   95
;  :datatype-splits         61
;  :decisions               280
;  :del-clause              1881
;  :final-checks            54
;  :max-generation          4
;  :max-memory              5.49
;  :memory                  5.48
;  :mk-bool-var             3911
;  :mk-clause               1887
;  :num-allocs              222977
;  :num-checks              110
;  :propagations            738
;  :quant-instantiations    1054
;  :rlimit-count            327089)
(assert (< unknown@87@04 (alen<Int> (opt_get1 $Snap.unit target@27@04))))
(pop) ; 15
; Joined path conditions
(assert (< unknown@87@04 (alen<Int> (opt_get1 $Snap.unit target@27@04))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@87@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@87@04)))
(push) ; 15
(assert (not (<
  $Perm.No
  (+
    (ite
      (and
        (<
          (inv@70@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@87@04))
          V@28@04)
        (<=
          0
          (inv@70@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@87@04))))
      $k@69@04
      $Perm.No)
    (ite
      (and
        (<
          (inv@62@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@87@04))
          V@28@04)
        (<=
          0
          (inv@62@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@87@04))))
      $k@61@04
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               2230
;  :arith-add-rows          679
;  :arith-assert-diseq      64
;  :arith-assert-lower      419
;  :arith-assert-upper      256
;  :arith-bound-prop        142
;  :arith-conflicts         55
;  :arith-eq-adapter        256
;  :arith-fixed-eqs         122
;  :arith-offset-eqs        117
;  :arith-pivots            391
;  :conflicts               191
;  :datatype-accessor-ax    39
;  :datatype-constructor-ax 161
;  :datatype-occurs-check   95
;  :datatype-splits         61
;  :decisions               306
;  :del-clause              2029
;  :final-checks            54
;  :max-generation          4
;  :max-memory              5.49
;  :memory                  5.49
;  :mk-bool-var             4196
;  :mk-clause               2105
;  :num-allocs              223977
;  :num-checks              111
;  :propagations            806
;  :quant-instantiations    1117
;  :rlimit-count            331145
;  :time                    0.00)
(push) ; 15
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 16
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@87@04))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               2230
;  :arith-add-rows          679
;  :arith-assert-diseq      64
;  :arith-assert-lower      419
;  :arith-assert-upper      256
;  :arith-bound-prop        142
;  :arith-conflicts         55
;  :arith-eq-adapter        256
;  :arith-fixed-eqs         122
;  :arith-offset-eqs        117
;  :arith-pivots            391
;  :conflicts               192
;  :datatype-accessor-ax    39
;  :datatype-constructor-ax 161
;  :datatype-occurs-check   95
;  :datatype-splits         61
;  :decisions               306
;  :del-clause              2029
;  :final-checks            54
;  :max-generation          4
;  :max-memory              5.49
;  :memory                  5.49
;  :mk-bool-var             4196
;  :mk-clause               2105
;  :num-allocs              224070
;  :num-checks              112
;  :propagations            806
;  :quant-instantiations    1117
;  :rlimit-count            331240)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@87@04))
    (as None<option<array>>  option<array>))))
(pop) ; 15
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@87@04))
    (as None<option<array>>  option<array>))))
(push) ; 15
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 16
(assert (not (<
  unknown1@88@04
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@87@04)))))))
(check-sat)
; unsat
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               2236
;  :arith-add-rows          685
;  :arith-assert-diseq      64
;  :arith-assert-lower      421
;  :arith-assert-upper      258
;  :arith-bound-prop        142
;  :arith-conflicts         56
;  :arith-eq-adapter        257
;  :arith-fixed-eqs         123
;  :arith-offset-eqs        117
;  :arith-pivots            395
;  :conflicts               193
;  :datatype-accessor-ax    39
;  :datatype-constructor-ax 161
;  :datatype-occurs-check   95
;  :datatype-splits         61
;  :decisions               306
;  :del-clause              2033
;  :final-checks            54
;  :max-generation          4
;  :max-memory              5.49
;  :memory                  5.49
;  :mk-bool-var             4207
;  :mk-clause               2109
;  :num-allocs              224269
;  :num-checks              113
;  :propagations            808
;  :quant-instantiations    1124
;  :rlimit-count            331757)
(assert (<
  unknown1@88@04
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@87@04))))))
(pop) ; 15
; Joined path conditions
(assert (<
  unknown1@88@04
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@87@04))))))
(assert ($FVF.loc_int ($FVF.lookup_int (as sm@86@04  $FVF<Int>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@87@04))) unknown1@88@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@87@04))) unknown1@88@04)))
(push) ; 15
(assert (not (<
  $Perm.No
  (+
    (ite
      (and
        (and
          (and
            (<
              (inv@85@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@87@04))) unknown1@88@04))
              V@28@04)
            (<=
              0
              (inv@85@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@87@04))) unknown1@88@04))))
          (<
            (inv@84@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@87@04))) unknown1@88@04))
            V@28@04))
        (<=
          0
          (inv@84@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@87@04))) unknown1@88@04))))
      $Perm.Write
      $Perm.No)
    (ite
      (and
        (and
          (and
            (<
              (inv@80@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@87@04))) unknown1@88@04))
              V@28@04)
            (<=
              0
              (inv@80@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@87@04))) unknown1@88@04))))
          (<
            (inv@79@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@87@04))) unknown1@88@04))
            V@28@04))
        (<=
          0
          (inv@79@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@87@04))) unknown1@88@04))))
      $k@78@04
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               2347
;  :arith-add-rows          726
;  :arith-assert-diseq      66
;  :arith-assert-lower      437
;  :arith-assert-upper      272
;  :arith-bound-prop        151
;  :arith-conflicts         60
;  :arith-eq-adapter        271
;  :arith-fixed-eqs         126
;  :arith-offset-eqs        128
;  :arith-pivots            403
;  :conflicts               214
;  :datatype-accessor-ax    39
;  :datatype-constructor-ax 165
;  :datatype-occurs-check   95
;  :datatype-splits         61
;  :decisions               332
;  :del-clause              2177
;  :final-checks            54
;  :max-generation          4
;  :max-memory              5.52
;  :memory                  5.51
;  :mk-bool-var             4439
;  :mk-clause               2281
;  :num-allocs              225279
;  :num-checks              114
;  :propagations            878
;  :quant-instantiations    1163
;  :rlimit-count            335365
;  :time                    0.00)
; [eval] aloc(opt_get1(aloc(opt_get1(source), unknown).option$array$), unknown1)
; [eval] opt_get1(aloc(opt_get1(source), unknown).option$array$)
; [eval] aloc(opt_get1(source), unknown)
; [eval] opt_get1(source)
(push) ; 15
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 15
; Joined path conditions
(push) ; 15
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 16
(assert (not (< unknown@87@04 (alen<Int> (opt_get1 $Snap.unit source@26@04)))))
(check-sat)
; unsat
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               2347
;  :arith-add-rows          726
;  :arith-assert-diseq      66
;  :arith-assert-lower      437
;  :arith-assert-upper      272
;  :arith-bound-prop        151
;  :arith-conflicts         60
;  :arith-eq-adapter        271
;  :arith-fixed-eqs         126
;  :arith-offset-eqs        128
;  :arith-pivots            403
;  :conflicts               214
;  :datatype-accessor-ax    39
;  :datatype-constructor-ax 165
;  :datatype-occurs-check   95
;  :datatype-splits         61
;  :decisions               332
;  :del-clause              2177
;  :final-checks            54
;  :max-generation          4
;  :max-memory              5.52
;  :memory                  5.51
;  :mk-bool-var             4439
;  :mk-clause               2281
;  :num-allocs              225304
;  :num-checks              115
;  :propagations            878
;  :quant-instantiations    1163
;  :rlimit-count            335395)
(assert (< unknown@87@04 (alen<Int> (opt_get1 $Snap.unit source@26@04))))
(pop) ; 15
; Joined path conditions
(assert (< unknown@87@04 (alen<Int> (opt_get1 $Snap.unit source@26@04))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@87@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@87@04)))
(push) ; 15
(assert (not (<
  $Perm.No
  (+
    (ite
      (and
        (<
          (inv@70@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@87@04))
          V@28@04)
        (<=
          0
          (inv@70@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@87@04))))
      $k@69@04
      $Perm.No)
    (ite
      (and
        (<
          (inv@62@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@87@04))
          V@28@04)
        (<=
          0
          (inv@62@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@87@04))))
      $k@61@04
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               2465
;  :arith-add-rows          780
;  :arith-assert-diseq      69
;  :arith-assert-lower      450
;  :arith-assert-upper      287
;  :arith-bound-prop        165
;  :arith-conflicts         64
;  :arith-eq-adapter        281
;  :arith-fixed-eqs         130
;  :arith-offset-eqs        138
;  :arith-pivots            411
;  :conflicts               234
;  :datatype-accessor-ax    39
;  :datatype-constructor-ax 169
;  :datatype-occurs-check   95
;  :datatype-splits         61
;  :decisions               359
;  :del-clause              2309
;  :final-checks            54
;  :max-generation          4
;  :max-memory              5.54
;  :memory                  5.54
;  :mk-bool-var             4658
;  :mk-clause               2432
;  :num-allocs              226323
;  :num-checks              116
;  :propagations            946
;  :quant-instantiations    1211
;  :rlimit-count            339293
;  :time                    0.00)
(push) ; 15
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 16
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@87@04))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               2532
;  :arith-add-rows          805
;  :arith-assert-diseq      69
;  :arith-assert-lower      452
;  :arith-assert-upper      291
;  :arith-bound-prop        175
;  :arith-conflicts         66
;  :arith-eq-adapter        281
;  :arith-fixed-eqs         130
;  :arith-offset-eqs        142
;  :arith-pivots            413
;  :conflicts               252
;  :datatype-accessor-ax    39
;  :datatype-constructor-ax 173
;  :datatype-occurs-check   95
;  :datatype-splits         61
;  :decisions               376
;  :del-clause              2371
;  :final-checks            54
;  :max-generation          4
;  :max-memory              5.54
;  :memory                  5.54
;  :mk-bool-var             4711
;  :mk-clause               2494
;  :num-allocs              226481
;  :num-checks              117
;  :propagations            971
;  :quant-instantiations    1223
;  :rlimit-count            340853)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@87@04))
    (as None<option<array>>  option<array>))))
(pop) ; 15
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@87@04))
    (as None<option<array>>  option<array>))))
(push) ; 15
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 16
(assert (not (<
  unknown1@88@04
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@87@04)))))))
(check-sat)
; unsat
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               2633
;  :arith-add-rows          873
;  :arith-assert-diseq      69
;  :arith-assert-lower      457
;  :arith-assert-upper      297
;  :arith-bound-prop        185
;  :arith-conflicts         69
;  :arith-eq-adapter        283
;  :arith-fixed-eqs         131
;  :arith-offset-eqs        146
;  :arith-pivots            419
;  :conflicts               270
;  :datatype-accessor-ax    39
;  :datatype-constructor-ax 177
;  :datatype-occurs-check   95
;  :datatype-splits         61
;  :decisions               393
;  :del-clause              2434
;  :final-checks            54
;  :max-generation          4
;  :max-memory              5.54
;  :memory                  5.54
;  :mk-bool-var             4794
;  :mk-clause               2557
;  :num-allocs              226823
;  :num-checks              118
;  :propagations            1012
;  :quant-instantiations    1244
;  :rlimit-count            343100
;  :time                    0.00)
(assert (<
  unknown1@88@04
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@87@04))))))
(pop) ; 15
; Joined path conditions
(assert (<
  unknown1@88@04
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@87@04))))))
(assert ($FVF.loc_int ($FVF.lookup_int (as sm@86@04  $FVF<Int>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@87@04))) unknown1@88@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@87@04))) unknown1@88@04)))
(push) ; 15
(assert (not (<
  $Perm.No
  (+
    (ite
      (and
        (and
          (and
            (<
              (inv@85@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@87@04))) unknown1@88@04))
              V@28@04)
            (<=
              0
              (inv@85@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@87@04))) unknown1@88@04))))
          (<
            (inv@84@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@87@04))) unknown1@88@04))
            V@28@04))
        (<=
          0
          (inv@84@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@87@04))) unknown1@88@04))))
      $Perm.Write
      $Perm.No)
    (ite
      (and
        (and
          (and
            (<
              (inv@80@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@87@04))) unknown1@88@04))
              V@28@04)
            (<=
              0
              (inv@80@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@87@04))) unknown1@88@04))))
          (<
            (inv@79@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@87@04))) unknown1@88@04))
            V@28@04))
        (<=
          0
          (inv@79@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@87@04))) unknown1@88@04))))
      $k@78@04
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               2769
;  :arith-add-rows          941
;  :arith-assert-diseq      71
;  :arith-assert-lower      475
;  :arith-assert-upper      316
;  :arith-bound-prop        201
;  :arith-conflicts         74
;  :arith-eq-adapter        295
;  :arith-fixed-eqs         136
;  :arith-offset-eqs        161
;  :arith-pivots            429
;  :conflicts               290
;  :datatype-accessor-ax    39
;  :datatype-constructor-ax 181
;  :datatype-occurs-check   95
;  :datatype-splits         61
;  :decisions               422
;  :del-clause              2560
;  :final-checks            54
;  :max-generation          4
;  :max-memory              5.60
;  :memory                  5.60
;  :mk-bool-var             4977
;  :mk-clause               2699
;  :num-allocs              227685
;  :num-checks              119
;  :propagations            1096
;  :quant-instantiations    1285
;  :rlimit-count            347264
;  :time                    0.00)
(pop) ; 14
(push) ; 14
; [else-branch: 82 | !(unknown1@88@04 < V@28@04 && 0 <= unknown1@88@04)]
(assert (not (and (< unknown1@88@04 V@28@04) (<= 0 unknown1@88@04))))
(pop) ; 14
(pop) ; 13
; Joined path conditions
(assert (implies
  (and (< unknown1@88@04 V@28@04) (<= 0 unknown1@88@04))
  (and
    (< unknown1@88@04 V@28@04)
    (<= 0 unknown1@88@04)
    (< unknown@87@04 (alen<Int> (opt_get1 $Snap.unit target@27@04)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@87@04)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@87@04))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@87@04))
        (as None<option<array>>  option<array>)))
    (<
      unknown1@88@04
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@87@04)))))
    ($FVF.loc_int ($FVF.lookup_int (as sm@86@04  $FVF<Int>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@87@04))) unknown1@88@04)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@87@04))) unknown1@88@04))
    (< unknown@87@04 (alen<Int> (opt_get1 $Snap.unit source@26@04)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@87@04)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@87@04))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@87@04))
        (as None<option<array>>  option<array>)))
    (<
      unknown1@88@04
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@87@04)))))
    ($FVF.loc_int ($FVF.lookup_int (as sm@86@04  $FVF<Int>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@87@04))) unknown1@88@04)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@87@04))) unknown1@88@04)))))
; Joined path conditions
(pop) ; 12
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((unknown1@88@04 Int)) (!
  (implies
    (and (< unknown1@88@04 V@28@04) (<= 0 unknown1@88@04))
    (and
      (< unknown1@88@04 V@28@04)
      (<= 0 unknown1@88@04)
      (< unknown@87@04 (alen<Int> (opt_get1 $Snap.unit target@27@04)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@87@04)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@87@04))
      (not
        (=
          ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@87@04))
          (as None<option<array>>  option<array>)))
      (<
        unknown1@88@04
        (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@87@04)))))
      ($FVF.loc_int ($FVF.lookup_int (as sm@86@04  $FVF<Int>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@87@04))) unknown1@88@04)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@87@04))) unknown1@88@04))
      (< unknown@87@04 (alen<Int> (opt_get1 $Snap.unit source@26@04)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@87@04)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@87@04))
      (not
        (=
          ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@87@04))
          (as None<option<array>>  option<array>)))
      (<
        unknown1@88@04
        (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@87@04)))))
      ($FVF.loc_int ($FVF.lookup_int (as sm@86@04  $FVF<Int>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@87@04))) unknown1@88@04)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@87@04))) unknown1@88@04))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@87@04))) unknown1@88@04))
  :qid |prog.l<no position>-aux|)))
(assert (forall ((unknown1@88@04 Int)) (!
  (implies
    (and (< unknown1@88@04 V@28@04) (<= 0 unknown1@88@04))
    (and
      (< unknown1@88@04 V@28@04)
      (<= 0 unknown1@88@04)
      (< unknown@87@04 (alen<Int> (opt_get1 $Snap.unit target@27@04)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@87@04)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@87@04))
      (not
        (=
          ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@87@04))
          (as None<option<array>>  option<array>)))
      (<
        unknown1@88@04
        (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@87@04)))))
      ($FVF.loc_int ($FVF.lookup_int (as sm@86@04  $FVF<Int>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@87@04))) unknown1@88@04)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@87@04))) unknown1@88@04))
      (< unknown@87@04 (alen<Int> (opt_get1 $Snap.unit source@26@04)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@87@04)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@87@04))
      (not
        (=
          ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@87@04))
          (as None<option<array>>  option<array>)))
      (<
        unknown1@88@04
        (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@87@04)))))
      ($FVF.loc_int ($FVF.lookup_int (as sm@86@04  $FVF<Int>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@87@04))) unknown1@88@04)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@87@04))) unknown1@88@04))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@87@04))) unknown1@88@04))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 11
(push) ; 11
; [else-branch: 80 | !(unknown@87@04 < V@28@04 && 0 <= unknown@87@04)]
(assert (not (and (< unknown@87@04 V@28@04) (<= 0 unknown@87@04))))
(pop) ; 11
(pop) ; 10
; Joined path conditions
(assert (implies
  (and (< unknown@87@04 V@28@04) (<= 0 unknown@87@04))
  (and
    (< unknown@87@04 V@28@04)
    (<= 0 unknown@87@04)
    (forall ((unknown1@88@04 Int)) (!
      (implies
        (and (< unknown1@88@04 V@28@04) (<= 0 unknown1@88@04))
        (and
          (< unknown1@88@04 V@28@04)
          (<= 0 unknown1@88@04)
          (< unknown@87@04 (alen<Int> (opt_get1 $Snap.unit target@27@04)))
          ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@87@04)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@87@04))
          (not
            (=
              ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@87@04))
              (as None<option<array>>  option<array>)))
          (<
            unknown1@88@04
            (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@87@04)))))
          ($FVF.loc_int ($FVF.lookup_int (as sm@86@04  $FVF<Int>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@87@04))) unknown1@88@04)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@87@04))) unknown1@88@04))
          (< unknown@87@04 (alen<Int> (opt_get1 $Snap.unit source@26@04)))
          ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@87@04)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@87@04))
          (not
            (=
              ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@87@04))
              (as None<option<array>>  option<array>)))
          (<
            unknown1@88@04
            (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@87@04)))))
          ($FVF.loc_int ($FVF.lookup_int (as sm@86@04  $FVF<Int>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@87@04))) unknown1@88@04)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@87@04))) unknown1@88@04))))
      :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@87@04))) unknown1@88@04))
      :qid |prog.l<no position>-aux|))
    (forall ((unknown1@88@04 Int)) (!
      (implies
        (and (< unknown1@88@04 V@28@04) (<= 0 unknown1@88@04))
        (and
          (< unknown1@88@04 V@28@04)
          (<= 0 unknown1@88@04)
          (< unknown@87@04 (alen<Int> (opt_get1 $Snap.unit target@27@04)))
          ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@87@04)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@87@04))
          (not
            (=
              ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@87@04))
              (as None<option<array>>  option<array>)))
          (<
            unknown1@88@04
            (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@87@04)))))
          ($FVF.loc_int ($FVF.lookup_int (as sm@86@04  $FVF<Int>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@87@04))) unknown1@88@04)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@87@04))) unknown1@88@04))
          (< unknown@87@04 (alen<Int> (opt_get1 $Snap.unit source@26@04)))
          ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@87@04)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@87@04))
          (not
            (=
              ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@87@04))
              (as None<option<array>>  option<array>)))
          (<
            unknown1@88@04
            (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@87@04)))))
          ($FVF.loc_int ($FVF.lookup_int (as sm@86@04  $FVF<Int>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@87@04))) unknown1@88@04)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@87@04))) unknown1@88@04))))
      :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@87@04))) unknown1@88@04))
      :qid |prog.l<no position>-aux|)))))
; Joined path conditions
(pop) ; 9
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((unknown@87@04 Int)) (!
  (implies
    (and (< unknown@87@04 V@28@04) (<= 0 unknown@87@04))
    (and
      (< unknown@87@04 V@28@04)
      (<= 0 unknown@87@04)
      (forall ((unknown1@88@04 Int)) (!
        (implies
          (and (< unknown1@88@04 V@28@04) (<= 0 unknown1@88@04))
          (and
            (< unknown1@88@04 V@28@04)
            (<= 0 unknown1@88@04)
            (< unknown@87@04 (alen<Int> (opt_get1 $Snap.unit target@27@04)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@87@04)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@87@04))
            (not
              (=
                ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@87@04))
                (as None<option<array>>  option<array>)))
            (<
              unknown1@88@04
              (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@87@04)))))
            ($FVF.loc_int ($FVF.lookup_int (as sm@86@04  $FVF<Int>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@87@04))) unknown1@88@04)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@87@04))) unknown1@88@04))
            (< unknown@87@04 (alen<Int> (opt_get1 $Snap.unit source@26@04)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@87@04)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@87@04))
            (not
              (=
                ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@87@04))
                (as None<option<array>>  option<array>)))
            (<
              unknown1@88@04
              (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@87@04)))))
            ($FVF.loc_int ($FVF.lookup_int (as sm@86@04  $FVF<Int>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@87@04))) unknown1@88@04)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@87@04))) unknown1@88@04))))
        :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@87@04))) unknown1@88@04))
        :qid |prog.l<no position>-aux|))
      (forall ((unknown1@88@04 Int)) (!
        (implies
          (and (< unknown1@88@04 V@28@04) (<= 0 unknown1@88@04))
          (and
            (< unknown1@88@04 V@28@04)
            (<= 0 unknown1@88@04)
            (< unknown@87@04 (alen<Int> (opt_get1 $Snap.unit target@27@04)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@87@04)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@87@04))
            (not
              (=
                ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@87@04))
                (as None<option<array>>  option<array>)))
            (<
              unknown1@88@04
              (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@87@04)))))
            ($FVF.loc_int ($FVF.lookup_int (as sm@86@04  $FVF<Int>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@87@04))) unknown1@88@04)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@87@04))) unknown1@88@04))
            (< unknown@87@04 (alen<Int> (opt_get1 $Snap.unit source@26@04)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@87@04)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@87@04))
            (not
              (=
                ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@87@04))
                (as None<option<array>>  option<array>)))
            (<
              unknown1@88@04
              (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@87@04)))))
            ($FVF.loc_int ($FVF.lookup_int (as sm@86@04  $FVF<Int>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@87@04))) unknown1@88@04)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@87@04))) unknown1@88@04))))
        :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@87@04))) unknown1@88@04))
        :qid |prog.l<no position>-aux|))))
  :pattern ((opt_get1%limited $Snap.unit ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@87@04))))
  :qid |prog.l<no position>-aux|)))
(assert (forall ((unknown@87@04 Int)) (!
  (implies
    (and (< unknown@87@04 V@28@04) (<= 0 unknown@87@04))
    (and
      (< unknown@87@04 V@28@04)
      (<= 0 unknown@87@04)
      (forall ((unknown1@88@04 Int)) (!
        (implies
          (and (< unknown1@88@04 V@28@04) (<= 0 unknown1@88@04))
          (and
            (< unknown1@88@04 V@28@04)
            (<= 0 unknown1@88@04)
            (< unknown@87@04 (alen<Int> (opt_get1 $Snap.unit target@27@04)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@87@04)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@87@04))
            (not
              (=
                ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@87@04))
                (as None<option<array>>  option<array>)))
            (<
              unknown1@88@04
              (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@87@04)))))
            ($FVF.loc_int ($FVF.lookup_int (as sm@86@04  $FVF<Int>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@87@04))) unknown1@88@04)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@87@04))) unknown1@88@04))
            (< unknown@87@04 (alen<Int> (opt_get1 $Snap.unit source@26@04)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@87@04)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@87@04))
            (not
              (=
                ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@87@04))
                (as None<option<array>>  option<array>)))
            (<
              unknown1@88@04
              (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@87@04)))))
            ($FVF.loc_int ($FVF.lookup_int (as sm@86@04  $FVF<Int>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@87@04))) unknown1@88@04)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@87@04))) unknown1@88@04))))
        :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@87@04))) unknown1@88@04))
        :qid |prog.l<no position>-aux|))
      (forall ((unknown1@88@04 Int)) (!
        (implies
          (and (< unknown1@88@04 V@28@04) (<= 0 unknown1@88@04))
          (and
            (< unknown1@88@04 V@28@04)
            (<= 0 unknown1@88@04)
            (< unknown@87@04 (alen<Int> (opt_get1 $Snap.unit target@27@04)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@87@04)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@87@04))
            (not
              (=
                ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@87@04))
                (as None<option<array>>  option<array>)))
            (<
              unknown1@88@04
              (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@87@04)))))
            ($FVF.loc_int ($FVF.lookup_int (as sm@86@04  $FVF<Int>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@87@04))) unknown1@88@04)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@87@04))) unknown1@88@04))
            (< unknown@87@04 (alen<Int> (opt_get1 $Snap.unit source@26@04)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@87@04)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@87@04))
            (not
              (=
                ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@87@04))
                (as None<option<array>>  option<array>)))
            (<
              unknown1@88@04
              (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@87@04)))))
            ($FVF.loc_int ($FVF.lookup_int (as sm@86@04  $FVF<Int>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@87@04))) unknown1@88@04)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@87@04))) unknown1@88@04))))
        :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@87@04))) unknown1@88@04))
        :qid |prog.l<no position>-aux|))))
  :pattern ((opt_get1%limited $Snap.unit ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@87@04))))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 8
(pop) ; 7
; Joined path conditions
(assert (implies
  (= exc@29@04 $Ref.null)
  (and
    (forall ((unknown@87@04 Int)) (!
      (implies
        (and (< unknown@87@04 V@28@04) (<= 0 unknown@87@04))
        (and
          (< unknown@87@04 V@28@04)
          (<= 0 unknown@87@04)
          (forall ((unknown1@88@04 Int)) (!
            (implies
              (and (< unknown1@88@04 V@28@04) (<= 0 unknown1@88@04))
              (and
                (< unknown1@88@04 V@28@04)
                (<= 0 unknown1@88@04)
                (< unknown@87@04 (alen<Int> (opt_get1 $Snap.unit target@27@04)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@87@04)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@87@04))
                (not
                  (=
                    ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@87@04))
                    (as None<option<array>>  option<array>)))
                (<
                  unknown1@88@04
                  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@87@04)))))
                ($FVF.loc_int ($FVF.lookup_int (as sm@86@04  $FVF<Int>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@87@04))) unknown1@88@04)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@87@04))) unknown1@88@04))
                (< unknown@87@04 (alen<Int> (opt_get1 $Snap.unit source@26@04)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@87@04)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@87@04))
                (not
                  (=
                    ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@87@04))
                    (as None<option<array>>  option<array>)))
                (<
                  unknown1@88@04
                  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@87@04)))))
                ($FVF.loc_int ($FVF.lookup_int (as sm@86@04  $FVF<Int>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@87@04))) unknown1@88@04)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@87@04))) unknown1@88@04))))
            :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@87@04))) unknown1@88@04))
            :qid |prog.l<no position>-aux|))
          (forall ((unknown1@88@04 Int)) (!
            (implies
              (and (< unknown1@88@04 V@28@04) (<= 0 unknown1@88@04))
              (and
                (< unknown1@88@04 V@28@04)
                (<= 0 unknown1@88@04)
                (< unknown@87@04 (alen<Int> (opt_get1 $Snap.unit target@27@04)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@87@04)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@87@04))
                (not
                  (=
                    ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@87@04))
                    (as None<option<array>>  option<array>)))
                (<
                  unknown1@88@04
                  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@87@04)))))
                ($FVF.loc_int ($FVF.lookup_int (as sm@86@04  $FVF<Int>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@87@04))) unknown1@88@04)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@87@04))) unknown1@88@04))
                (< unknown@87@04 (alen<Int> (opt_get1 $Snap.unit source@26@04)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@87@04)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@87@04))
                (not
                  (=
                    ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@87@04))
                    (as None<option<array>>  option<array>)))
                (<
                  unknown1@88@04
                  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@87@04)))))
                ($FVF.loc_int ($FVF.lookup_int (as sm@86@04  $FVF<Int>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@87@04))) unknown1@88@04)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@87@04))) unknown1@88@04))))
            :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@87@04))) unknown1@88@04))
            :qid |prog.l<no position>-aux|))))
      :pattern ((opt_get1%limited $Snap.unit ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@87@04))))
      :qid |prog.l<no position>-aux|))
    (forall ((unknown@87@04 Int)) (!
      (implies
        (and (< unknown@87@04 V@28@04) (<= 0 unknown@87@04))
        (and
          (< unknown@87@04 V@28@04)
          (<= 0 unknown@87@04)
          (forall ((unknown1@88@04 Int)) (!
            (implies
              (and (< unknown1@88@04 V@28@04) (<= 0 unknown1@88@04))
              (and
                (< unknown1@88@04 V@28@04)
                (<= 0 unknown1@88@04)
                (< unknown@87@04 (alen<Int> (opt_get1 $Snap.unit target@27@04)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@87@04)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@87@04))
                (not
                  (=
                    ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@87@04))
                    (as None<option<array>>  option<array>)))
                (<
                  unknown1@88@04
                  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@87@04)))))
                ($FVF.loc_int ($FVF.lookup_int (as sm@86@04  $FVF<Int>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@87@04))) unknown1@88@04)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@87@04))) unknown1@88@04))
                (< unknown@87@04 (alen<Int> (opt_get1 $Snap.unit source@26@04)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@87@04)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@87@04))
                (not
                  (=
                    ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@87@04))
                    (as None<option<array>>  option<array>)))
                (<
                  unknown1@88@04
                  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@87@04)))))
                ($FVF.loc_int ($FVF.lookup_int (as sm@86@04  $FVF<Int>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@87@04))) unknown1@88@04)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@87@04))) unknown1@88@04))))
            :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@87@04))) unknown1@88@04))
            :qid |prog.l<no position>-aux|))
          (forall ((unknown1@88@04 Int)) (!
            (implies
              (and (< unknown1@88@04 V@28@04) (<= 0 unknown1@88@04))
              (and
                (< unknown1@88@04 V@28@04)
                (<= 0 unknown1@88@04)
                (< unknown@87@04 (alen<Int> (opt_get1 $Snap.unit target@27@04)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@87@04)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@87@04))
                (not
                  (=
                    ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@87@04))
                    (as None<option<array>>  option<array>)))
                (<
                  unknown1@88@04
                  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@87@04)))))
                ($FVF.loc_int ($FVF.lookup_int (as sm@86@04  $FVF<Int>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@87@04))) unknown1@88@04)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@87@04))) unknown1@88@04))
                (< unknown@87@04 (alen<Int> (opt_get1 $Snap.unit source@26@04)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@87@04)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@87@04))
                (not
                  (=
                    ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@87@04))
                    (as None<option<array>>  option<array>)))
                (<
                  unknown1@88@04
                  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@87@04)))))
                ($FVF.loc_int ($FVF.lookup_int (as sm@86@04  $FVF<Int>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@87@04))) unknown1@88@04)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@87@04))) unknown1@88@04))))
            :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@87@04))) unknown1@88@04))
            :qid |prog.l<no position>-aux|))))
      :pattern ((opt_get1%limited $Snap.unit ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@87@04))))
      :qid |prog.l<no position>-aux|)))))
(assert (implies
  (= exc@29@04 $Ref.null)
  (forall ((unknown@87@04 Int)) (!
    (implies
      (and (< unknown@87@04 V@28@04) (<= 0 unknown@87@04))
      (forall ((unknown1@88@04 Int)) (!
        (implies
          (and (< unknown1@88@04 V@28@04) (<= 0 unknown1@88@04))
          (=
            ($FVF.lookup_int (as sm@86@04  $FVF<Int>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@87@04))) unknown1@88@04))
            ($FVF.lookup_int (as sm@86@04  $FVF<Int>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@87@04))) unknown1@88@04))))
        :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@87@04))) unknown1@88@04))
        :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@87@04))) unknown1@88@04))
        :qid |prog.l<no position>|)))
    :pattern ((opt_get1%limited $Snap.unit ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@87@04))))
    :pattern ((opt_get1%limited $Snap.unit ($FVF.lookup_option$array$ (as sm@71@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@87@04))))
    :qid |prog.l<no position>|))))
(pop) ; 6
(pop) ; 5
(pop) ; 4
(pop) ; 3
(pop) ; 2
(push) ; 2
; [exec]
; var return: void
(declare-const return@89@04 void)
; [exec]
; var res1: void
(declare-const res1@90@04 void)
; [exec]
; var evaluationDummy: void
(declare-const evaluationDummy@91@04 void)
; [exec]
; exc := null
; [exec]
; exc, res1 := do_par_$unknown$1(V, source, target)
; [eval] 0 < V ==> source != (None(): option[array])
; [eval] 0 < V
(push) ; 3
(set-option :timeout 10)
(push) ; 4
(assert (not (not (< 0 V@28@04))))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               2781
;  :arith-add-rows          966
;  :arith-assert-diseq      71
;  :arith-assert-lower      477
;  :arith-assert-upper      317
;  :arith-bound-prop        201
;  :arith-conflicts         74
;  :arith-eq-adapter        296
;  :arith-fixed-eqs         137
;  :arith-offset-eqs        161
;  :arith-pivots            449
;  :conflicts               290
;  :datatype-accessor-ax    39
;  :datatype-constructor-ax 185
;  :datatype-occurs-check   96
;  :datatype-splits         61
;  :decisions               426
;  :del-clause              2700
;  :final-checks            55
;  :max-generation          4
;  :max-memory              5.61
;  :memory                  5.58
;  :mk-bool-var             4980
;  :mk-clause               2700
;  :num-allocs              229300
;  :num-checks              120
;  :propagations            1096
;  :quant-instantiations    1285
;  :rlimit-count            349843)
(push) ; 4
(assert (not (< 0 V@28@04)))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               2793
;  :arith-add-rows          969
;  :arith-assert-diseq      71
;  :arith-assert-lower      478
;  :arith-assert-upper      319
;  :arith-bound-prop        201
;  :arith-conflicts         74
;  :arith-eq-adapter        297
;  :arith-fixed-eqs         138
;  :arith-offset-eqs        161
;  :arith-pivots            452
;  :conflicts               290
;  :datatype-accessor-ax    39
;  :datatype-constructor-ax 189
;  :datatype-occurs-check   97
;  :datatype-splits         61
;  :decisions               430
;  :del-clause              2701
;  :final-checks            56
;  :max-generation          4
;  :max-memory              5.61
;  :memory                  5.58
;  :mk-bool-var             4983
;  :mk-clause               2701
;  :num-allocs              229900
;  :num-checks              121
;  :propagations            1096
;  :quant-instantiations    1285
;  :rlimit-count            350508)
; [then-branch: 83 | 0 < V@28@04 | live]
; [else-branch: 83 | !(0 < V@28@04) | live]
(push) ; 4
; [then-branch: 83 | 0 < V@28@04]
(assert (< 0 V@28@04))
; [eval] source != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 4
(push) ; 4
; [else-branch: 83 | !(0 < V@28@04)]
(assert (not (< 0 V@28@04)))
(pop) ; 4
(pop) ; 3
; Joined path conditions
; Joined path conditions
(set-option :timeout 0)
(push) ; 3
(assert (not (implies
  (< 0 V@28@04)
  (not (= source@26@04 (as None<option<array>>  option<array>))))))
(check-sat)
; unsat
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               2793
;  :arith-add-rows          969
;  :arith-assert-diseq      71
;  :arith-assert-lower      478
;  :arith-assert-upper      319
;  :arith-bound-prop        201
;  :arith-conflicts         74
;  :arith-eq-adapter        297
;  :arith-fixed-eqs         138
;  :arith-offset-eqs        161
;  :arith-pivots            452
;  :conflicts               290
;  :datatype-accessor-ax    39
;  :datatype-constructor-ax 189
;  :datatype-occurs-check   97
;  :datatype-splits         61
;  :decisions               430
;  :del-clause              2701
;  :final-checks            56
;  :max-generation          4
;  :max-memory              5.61
;  :memory                  5.58
;  :mk-bool-var             4983
;  :mk-clause               2701
;  :num-allocs              229931
;  :num-checks              122
;  :propagations            1096
;  :quant-instantiations    1285
;  :rlimit-count            350553)
(assert (implies
  (< 0 V@28@04)
  (not (= source@26@04 (as None<option<array>>  option<array>)))))
; [eval] 0 < V ==> alen(opt_get1(source)) == V
; [eval] 0 < V
(push) ; 3
(set-option :timeout 10)
(push) ; 4
(assert (not (not (< 0 V@28@04))))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               2805
;  :arith-add-rows          972
;  :arith-assert-diseq      71
;  :arith-assert-lower      480
;  :arith-assert-upper      320
;  :arith-bound-prop        201
;  :arith-conflicts         74
;  :arith-eq-adapter        298
;  :arith-fixed-eqs         139
;  :arith-offset-eqs        161
;  :arith-pivots            455
;  :conflicts               290
;  :datatype-accessor-ax    39
;  :datatype-constructor-ax 193
;  :datatype-occurs-check   98
;  :datatype-splits         61
;  :decisions               434
;  :del-clause              2702
;  :final-checks            57
;  :max-generation          4
;  :max-memory              5.61
;  :memory                  5.58
;  :mk-bool-var             4986
;  :mk-clause               2702
;  :num-allocs              230521
;  :num-checks              123
;  :propagations            1096
;  :quant-instantiations    1285
;  :rlimit-count            351248)
(push) ; 4
(assert (not (< 0 V@28@04)))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               2817
;  :arith-add-rows          975
;  :arith-assert-diseq      71
;  :arith-assert-lower      481
;  :arith-assert-upper      322
;  :arith-bound-prop        201
;  :arith-conflicts         74
;  :arith-eq-adapter        299
;  :arith-fixed-eqs         140
;  :arith-offset-eqs        161
;  :arith-pivots            457
;  :conflicts               290
;  :datatype-accessor-ax    39
;  :datatype-constructor-ax 197
;  :datatype-occurs-check   99
;  :datatype-splits         61
;  :decisions               438
;  :del-clause              2703
;  :final-checks            58
;  :max-generation          4
;  :max-memory              5.61
;  :memory                  5.58
;  :mk-bool-var             4989
;  :mk-clause               2703
;  :num-allocs              231121
;  :num-checks              124
;  :propagations            1096
;  :quant-instantiations    1285
;  :rlimit-count            351908)
; [then-branch: 84 | 0 < V@28@04 | live]
; [else-branch: 84 | !(0 < V@28@04) | live]
(push) ; 4
; [then-branch: 84 | 0 < V@28@04]
(assert (< 0 V@28@04))
; [eval] alen(opt_get1(source)) == V
; [eval] alen(opt_get1(source))
; [eval] opt_get1(source)
(push) ; 5
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 5
; Joined path conditions
(pop) ; 4
(push) ; 4
; [else-branch: 84 | !(0 < V@28@04)]
(assert (not (< 0 V@28@04)))
(pop) ; 4
(pop) ; 3
; Joined path conditions
; Joined path conditions
(set-option :timeout 0)
(push) ; 3
(assert (not (implies
  (< 0 V@28@04)
  (= (alen<Int> (opt_get1 $Snap.unit source@26@04)) V@28@04))))
(check-sat)
; unsat
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               2818
;  :arith-add-rows          978
;  :arith-assert-diseq      71
;  :arith-assert-lower      483
;  :arith-assert-upper      323
;  :arith-bound-prop        201
;  :arith-conflicts         74
;  :arith-eq-adapter        300
;  :arith-fixed-eqs         141
;  :arith-offset-eqs        161
;  :arith-pivots            459
;  :conflicts               290
;  :datatype-accessor-ax    39
;  :datatype-constructor-ax 197
;  :datatype-occurs-check   99
;  :datatype-splits         61
;  :decisions               438
;  :del-clause              2703
;  :final-checks            58
;  :max-generation          4
;  :max-memory              5.61
;  :memory                  5.58
;  :mk-bool-var             4992
;  :mk-clause               2703
;  :num-allocs              231225
;  :num-checks              125
;  :propagations            1096
;  :quant-instantiations    1285
;  :rlimit-count            352062)
(assert (implies
  (< 0 V@28@04)
  (= (alen<Int> (opt_get1 $Snap.unit source@26@04)) V@28@04)))
; [eval] 0 < V
(set-option :timeout 10)
(push) ; 3
(assert (not (not (< 0 V@28@04))))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               2830
;  :arith-add-rows          979
;  :arith-assert-diseq      71
;  :arith-assert-lower      485
;  :arith-assert-upper      324
;  :arith-bound-prop        201
;  :arith-conflicts         74
;  :arith-eq-adapter        301
;  :arith-fixed-eqs         142
;  :arith-offset-eqs        161
;  :arith-pivots            461
;  :conflicts               290
;  :datatype-accessor-ax    39
;  :datatype-constructor-ax 201
;  :datatype-occurs-check   100
;  :datatype-splits         61
;  :decisions               442
;  :del-clause              2704
;  :final-checks            59
;  :max-generation          4
;  :max-memory              5.61
;  :memory                  5.58
;  :mk-bool-var             4995
;  :mk-clause               2704
;  :num-allocs              231816
;  :num-checks              126
;  :propagations            1096
;  :quant-instantiations    1285
;  :rlimit-count            352714)
(push) ; 3
(assert (not (< 0 V@28@04)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               2842
;  :arith-add-rows          982
;  :arith-assert-diseq      71
;  :arith-assert-lower      486
;  :arith-assert-upper      326
;  :arith-bound-prop        201
;  :arith-conflicts         74
;  :arith-eq-adapter        302
;  :arith-fixed-eqs         143
;  :arith-offset-eqs        161
;  :arith-pivots            464
;  :conflicts               290
;  :datatype-accessor-ax    39
;  :datatype-constructor-ax 205
;  :datatype-occurs-check   101
;  :datatype-splits         61
;  :decisions               446
;  :del-clause              2705
;  :final-checks            60
;  :max-generation          4
;  :max-memory              5.61
;  :memory                  5.58
;  :mk-bool-var             4998
;  :mk-clause               2705
;  :num-allocs              232416
;  :num-checks              127
;  :propagations            1096
;  :quant-instantiations    1285
;  :rlimit-count            353379)
; [then-branch: 85 | 0 < V@28@04 | live]
; [else-branch: 85 | !(0 < V@28@04) | live]
(push) ; 3
; [then-branch: 85 | 0 < V@28@04]
(assert (< 0 V@28@04))
(declare-const i1@92@04 Int)
(push) ; 4
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 5
; [then-branch: 86 | 0 <= i1@92@04 | live]
; [else-branch: 86 | !(0 <= i1@92@04) | live]
(push) ; 6
; [then-branch: 86 | 0 <= i1@92@04]
(assert (<= 0 i1@92@04))
; [eval] i1 < V
(pop) ; 6
(push) ; 6
; [else-branch: 86 | !(0 <= i1@92@04)]
(assert (not (<= 0 i1@92@04)))
(pop) ; 6
(pop) ; 5
; Joined path conditions
; Joined path conditions
(assert (and (< i1@92@04 V@28@04) (<= 0 i1@92@04)))
; [eval] scale(V * V * write) * wildcard
; [eval] scale(V * V * write)
; [eval] V * V * write
; [eval] V * V
(push) ; 5
; [eval] amount >= 0 * write
; [eval] 0 * write
(set-option :timeout 0)
(push) ; 6
(assert (not (>= (* (to_real (* V@28@04 V@28@04)) $Perm.Write) $Perm.No)))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               2854
;  :arith-add-rows          984
;  :arith-assert-diseq      71
;  :arith-assert-lower      491
;  :arith-assert-upper      329
;  :arith-bound-prop        201
;  :arith-conflicts         75
;  :arith-eq-adapter        303
;  :arith-fixed-eqs         144
;  :arith-max-min           3
;  :arith-offset-eqs        161
;  :arith-pivots            466
;  :conflicts               291
;  :datatype-accessor-ax    39
;  :datatype-constructor-ax 209
;  :datatype-occurs-check   101
;  :datatype-splits         61
;  :decisions               450
;  :del-clause              2705
;  :final-checks            61
;  :max-generation          4
;  :max-memory              5.61
;  :memory                  5.57
;  :mk-bool-var             5004
;  :mk-clause               2705
;  :num-allocs              232703
;  :num-checks              128
;  :propagations            1096
;  :quant-instantiations    1285
;  :rlimit-count            353803)
(assert (>= (* (to_real (* V@28@04 V@28@04)) $Perm.Write) $Perm.No))
(pop) ; 5
; Joined path conditions
(assert (>= (* (to_real (* V@28@04 V@28@04)) $Perm.Write) $Perm.No))
(declare-const $k@93@04 $Perm)
(assert ($Perm.isReadVar $k@93@04 $Perm.Write))
; [eval] aloc(opt_get1(source), i1)
; [eval] opt_get1(source)
(push) ; 5
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 5
; Joined path conditions
(push) ; 5
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 6
(assert (not (< i1@92@04 (alen<Int> (opt_get1 $Snap.unit source@26@04)))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               2854
;  :arith-add-rows          984
;  :arith-assert-diseq      72
;  :arith-assert-lower      494
;  :arith-assert-upper      330
;  :arith-bound-prop        201
;  :arith-conflicts         75
;  :arith-eq-adapter        304
;  :arith-fixed-eqs         144
;  :arith-max-min           3
;  :arith-offset-eqs        161
;  :arith-pivots            466
;  :conflicts               291
;  :datatype-accessor-ax    39
;  :datatype-constructor-ax 209
;  :datatype-occurs-check   101
;  :datatype-splits         61
;  :decisions               450
;  :del-clause              2705
;  :final-checks            61
;  :max-generation          4
;  :max-memory              5.61
;  :memory                  5.57
;  :mk-bool-var             5009
;  :mk-clause               2707
;  :num-allocs              232909
;  :num-checks              129
;  :propagations            1097
;  :quant-instantiations    1285
;  :rlimit-count            354060)
(assert (< i1@92@04 (alen<Int> (opt_get1 $Snap.unit source@26@04))))
(pop) ; 5
; Joined path conditions
(assert (< i1@92@04 (alen<Int> (opt_get1 $Snap.unit source@26@04))))
(pop) ; 4
(declare-fun inv@94@04 ($Ref) Int)
; Nested auxiliary terms: globals
(assert ($Perm.isReadVar $k@93@04 $Perm.Write))
; Nested auxiliary terms: non-globals
(assert (forall ((i1@92@04 Int)) (!
  (and
    (>= (* (to_real (* V@28@04 V@28@04)) $Perm.Write) $Perm.No)
    (< i1@92@04 (alen<Int> (opt_get1 $Snap.unit source@26@04))))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@92@04))
  :qid |option$array$-aux|)))
(push) ; 4
(assert (not (forall ((i1@92@04 Int)) (!
  (implies
    (and (< i1@92@04 V@28@04) (<= 0 i1@92@04))
    (or
      (=
        (*
          (scale $Snap.unit (* (to_real (* V@28@04 V@28@04)) $Perm.Write))
          $k@93@04)
        $Perm.No)
      (<
        $Perm.No
        (*
          (scale $Snap.unit (* (to_real (* V@28@04 V@28@04)) $Perm.Write))
          $k@93@04))))
  
  ))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               2868
;  :arith-add-rows          984
;  :arith-assert-diseq      74
;  :arith-assert-lower      508
;  :arith-assert-upper      336
;  :arith-bound-prop        201
;  :arith-conflicts         77
;  :arith-eq-adapter        307
;  :arith-fixed-eqs         144
;  :arith-max-min           18
;  :arith-nonlinear-bounds  2
;  :arith-offset-eqs        162
;  :arith-pivots            468
;  :conflicts               297
;  :datatype-accessor-ax    39
;  :datatype-constructor-ax 213
;  :datatype-occurs-check   102
;  :datatype-splits         61
;  :decisions               455
;  :del-clause              2714
;  :final-checks            63
;  :max-generation          4
;  :max-memory              5.61
;  :memory                  5.57
;  :mk-bool-var             5025
;  :mk-clause               2716
;  :num-allocs              233538
;  :num-checks              130
;  :propagations            1102
;  :quant-instantiations    1288
;  :rlimit-count            355026)
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 4
(assert (not (forall ((i11@92@04 Int) (i12@92@04 Int)) (!
  (implies
    (and
      (and
        (and
          (and (< i11@92@04 V@28@04) (<= 0 i11@92@04))
          ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@26@04) i11@92@04)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@26@04) i11@92@04)))
        (<
          $Perm.No
          (*
            (scale $Snap.unit (* (to_real (* V@28@04 V@28@04)) $Perm.Write))
            $k@93@04)))
      (and
        (and
          (and (< i12@92@04 V@28@04) (<= 0 i12@92@04))
          ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@26@04) i12@92@04)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@26@04) i12@92@04)))
        (<
          $Perm.No
          (*
            (scale $Snap.unit (* (to_real (* V@28@04 V@28@04)) $Perm.Write))
            $k@93@04)))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i11@92@04)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i12@92@04)))
    (= i11@92@04 i12@92@04))
  
  :qid |option$array$-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               2879
;  :arith-add-rows          988
;  :arith-assert-diseq      75
;  :arith-assert-lower      513
;  :arith-assert-upper      336
;  :arith-bound-prop        201
;  :arith-conflicts         77
;  :arith-eq-adapter        309
;  :arith-fixed-eqs         144
;  :arith-max-min           18
;  :arith-nonlinear-bounds  2
;  :arith-offset-eqs        162
;  :arith-pivots            470
;  :conflicts               298
;  :datatype-accessor-ax    39
;  :datatype-constructor-ax 213
;  :datatype-occurs-check   102
;  :datatype-splits         61
;  :decisions               455
;  :del-clause              2734
;  :final-checks            63
;  :max-generation          4
;  :max-memory              5.61
;  :memory                  5.57
;  :mk-bool-var             5062
;  :mk-clause               2736
;  :num-allocs              234006
;  :num-checks              131
;  :propagations            1108
;  :quant-instantiations    1304
;  :rlimit-count            356062)
; Definitional axioms for inverse functions
(assert (forall ((i1@92@04 Int)) (!
  (implies
    (and
      (and (< i1@92@04 V@28@04) (<= 0 i1@92@04))
      (<
        $Perm.No
        (*
          (scale $Snap.unit (* (to_real (* V@28@04 V@28@04)) $Perm.Write))
          $k@93@04)))
    (=
      (inv@94@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@92@04))
      i1@92@04))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@92@04))
  :qid |option$array$-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and (< (inv@94@04 r) V@28@04) (<= 0 (inv@94@04 r)))
      (<
        $Perm.No
        (*
          (scale $Snap.unit (* (to_real (* V@28@04 V@28@04)) $Perm.Write))
          $k@93@04)))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) (inv@94@04 r))
      r))
  :pattern ((inv@94@04 r))
  :qid |option$array$-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@94@04 r) V@28@04) (<= 0 (inv@94@04 r)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) r) r))
  :pattern ((inv@94@04 r))
  )))
; Precomputing data for removing quantified permissions
(define-fun pTaken@95@04 ((r $Ref)) $Perm
  (ite
    (and (< (inv@94@04 r) V@28@04) (<= 0 (inv@94@04 r)))
    ($Perm.min
      (ite
        (and (< (inv@42@04 r) V@28@04) (<= 0 (inv@42@04 r)))
        $k@41@04
        $Perm.No)
      (*
        (scale $Snap.unit (* (to_real (* V@28@04 V@28@04)) $Perm.Write))
        $k@93@04))
    $Perm.No))
(define-fun pTaken@96@04 ((r $Ref)) $Perm
  (ite
    (and (< (inv@94@04 r) V@28@04) (<= 0 (inv@94@04 r)))
    ($Perm.min
      (ite
        (and (< (inv@34@04 r) V@28@04) (<= 0 (inv@34@04 r)))
        $k@33@04
        $Perm.No)
      (-
        (*
          (scale $Snap.unit (* (to_real (* V@28@04 V@28@04)) $Perm.Write))
          $k@93@04)
        (pTaken@95@04 r)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Constrain original permissions scale(_, V@28@04 * V@28@04 * W) * $k@93@04
(assert (forall ((r $Ref)) (!
  (implies
    (not
      (=
        (ite
          (and (< (inv@42@04 r) V@28@04) (<= 0 (inv@42@04 r)))
          $k@41@04
          $Perm.No)
        $Perm.No))
    (ite
      (and (< (inv@42@04 r) V@28@04) (<= 0 (inv@42@04 r)))
      (<
        (ite
          (and (< (inv@94@04 r) V@28@04) (<= 0 (inv@94@04 r)))
          (*
            (scale $Snap.unit (* (to_real (* V@28@04 V@28@04)) $Perm.Write))
            $k@93@04)
          $Perm.No)
        $k@41@04)
      (<
        (ite
          (and (< (inv@94@04 r) V@28@04) (<= 0 (inv@94@04 r)))
          (*
            (scale $Snap.unit (* (to_real (* V@28@04 V@28@04)) $Perm.Write))
            $k@93@04)
          $Perm.No)
        $Perm.No)))
  :pattern ((inv@42@04 r))
  :pattern ((inv@94@04 r))
  :qid |qp.srp24|)))
; Intermediate check if already taken enough permissions
(set-option :timeout 500)
(push) ; 4
(assert (not (forall ((r $Ref)) (!
  (implies
    (and (< (inv@94@04 r) V@28@04) (<= 0 (inv@94@04 r)))
    (=
      (-
        (*
          (scale $Snap.unit (* (to_real (* V@28@04 V@28@04)) $Perm.Write))
          $k@93@04)
        (pTaken@95@04 r))
      $Perm.No))
  
  ))))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               2967
;  :arith-add-rows          1020
;  :arith-assert-diseq      83
;  :arith-assert-lower      541
;  :arith-assert-upper      352
;  :arith-bound-prop        212
;  :arith-conflicts         80
;  :arith-eq-adapter        325
;  :arith-fixed-eqs         149
;  :arith-max-min           27
;  :arith-nonlinear-bounds  3
;  :arith-offset-eqs        168
;  :arith-pivots            492
;  :conflicts               302
;  :datatype-accessor-ax    39
;  :datatype-constructor-ax 221
;  :datatype-occurs-check   105
;  :datatype-splits         61
;  :decisions               470
;  :del-clause              2815
;  :final-checks            67
;  :interface-eqs           1
;  :max-generation          4
;  :max-memory              5.62
;  :memory                  5.59
;  :minimized-lits          2
;  :mk-bool-var             5185
;  :mk-clause               2815
;  :num-allocs              236969
;  :num-checks              133
;  :propagations            1142
;  :quant-instantiations    1339
;  :rlimit-count            361497
;  :time                    0.00)
; Constrain original permissions scale(_, V@28@04 * V@28@04 * W) * $k@93@04
(assert (forall ((r $Ref)) (!
  (implies
    (not
      (=
        (ite
          (and (< (inv@34@04 r) V@28@04) (<= 0 (inv@34@04 r)))
          $k@33@04
          $Perm.No)
        $Perm.No))
    (ite
      (and (< (inv@34@04 r) V@28@04) (<= 0 (inv@34@04 r)))
      (<
        (ite
          (and (< (inv@94@04 r) V@28@04) (<= 0 (inv@94@04 r)))
          (*
            (scale $Snap.unit (* (to_real (* V@28@04 V@28@04)) $Perm.Write))
            $k@93@04)
          $Perm.No)
        $k@33@04)
      (<
        (ite
          (and (< (inv@94@04 r) V@28@04) (<= 0 (inv@94@04 r)))
          (*
            (scale $Snap.unit (* (to_real (* V@28@04 V@28@04)) $Perm.Write))
            $k@93@04)
          $Perm.No)
        $Perm.No)))
  :pattern ((inv@34@04 r))
  :pattern ((inv@94@04 r))
  :qid |qp.srp25|)))
; Intermediate check if already taken enough permissions
(push) ; 4
(assert (not (forall ((r $Ref)) (!
  (implies
    (and (< (inv@94@04 r) V@28@04) (<= 0 (inv@94@04 r)))
    (=
      (-
        (-
          (*
            (scale $Snap.unit (* (to_real (* V@28@04 V@28@04)) $Perm.Write))
            $k@93@04)
          (pTaken@95@04 r))
        (pTaken@96@04 r))
      $Perm.No))
  
  ))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               3110
;  :arith-add-rows          1148
;  :arith-assert-diseq      102
;  :arith-assert-lower      595
;  :arith-assert-upper      383
;  :arith-bound-prop        238
;  :arith-conflicts         87
;  :arith-eq-adapter        368
;  :arith-fixed-eqs         163
;  :arith-max-min           27
;  :arith-nonlinear-bounds  3
;  :arith-offset-eqs        192
;  :arith-pivots            526
;  :conflicts               315
;  :datatype-accessor-ax    39
;  :datatype-constructor-ax 225
;  :datatype-occurs-check   105
;  :datatype-splits         61
;  :decisions               483
;  :del-clause              3014
;  :final-checks            67
;  :interface-eqs           1
;  :max-generation          4
;  :max-memory              5.62
;  :memory                  5.60
;  :minimized-lits          14
;  :mk-bool-var             5470
;  :mk-clause               3014
;  :num-allocs              238739
;  :num-checks              134
;  :propagations            1213
;  :quant-instantiations    1391
;  :rlimit-count            367319
;  :time                    0.00)
; Final check if taken enough permissions
; Done removing quantified permissions
; Definitional axioms for snapshot map values
; [eval] 0 < V ==> (forall i1: Int :: { aloc(opt_get1(source), i1) } 0 <= i1 && i1 < V ==> aloc(opt_get1(source), i1).option$array$ != (None(): option[array]))
; [eval] 0 < V
(push) ; 4
(set-option :timeout 10)
(push) ; 5
(assert (not (not (< 0 V@28@04))))
(check-sat)
; unknown
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               3121
;  :arith-add-rows          1148
;  :arith-assert-diseq      102
;  :arith-assert-lower      595
;  :arith-assert-upper      383
;  :arith-bound-prop        238
;  :arith-conflicts         87
;  :arith-eq-adapter        368
;  :arith-fixed-eqs         163
;  :arith-max-min           27
;  :arith-nonlinear-bounds  3
;  :arith-offset-eqs        192
;  :arith-pivots            526
;  :conflicts               315
;  :datatype-accessor-ax    39
;  :datatype-constructor-ax 229
;  :datatype-occurs-check   106
;  :datatype-splits         61
;  :decisions               487
;  :del-clause              3014
;  :final-checks            68
;  :interface-eqs           1
;  :max-generation          4
;  :max-memory              5.62
;  :memory                  5.61
;  :minimized-lits          14
;  :mk-bool-var             5470
;  :mk-clause               3014
;  :num-allocs              239287
;  :num-checks              135
;  :propagations            1213
;  :quant-instantiations    1391
;  :rlimit-count            367903)
; [then-branch: 87 | 0 < V@28@04 | live]
; [else-branch: 87 | !(0 < V@28@04) | dead]
(push) ; 5
; [then-branch: 87 | 0 < V@28@04]
; [eval] (forall i1: Int :: { aloc(opt_get1(source), i1) } 0 <= i1 && i1 < V ==> aloc(opt_get1(source), i1).option$array$ != (None(): option[array]))
(declare-const i1@97@04 Int)
(push) ; 6
; [eval] 0 <= i1 && i1 < V ==> aloc(opt_get1(source), i1).option$array$ != (None(): option[array])
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 7
; [then-branch: 88 | 0 <= i1@97@04 | live]
; [else-branch: 88 | !(0 <= i1@97@04) | live]
(push) ; 8
; [then-branch: 88 | 0 <= i1@97@04]
(assert (<= 0 i1@97@04))
; [eval] i1 < V
(pop) ; 8
(push) ; 8
; [else-branch: 88 | !(0 <= i1@97@04)]
(assert (not (<= 0 i1@97@04)))
(pop) ; 8
(pop) ; 7
; Joined path conditions
; Joined path conditions
(push) ; 7
; [then-branch: 89 | i1@97@04 < V@28@04 && 0 <= i1@97@04 | live]
; [else-branch: 89 | !(i1@97@04 < V@28@04 && 0 <= i1@97@04) | live]
(push) ; 8
; [then-branch: 89 | i1@97@04 < V@28@04 && 0 <= i1@97@04]
(assert (and (< i1@97@04 V@28@04) (<= 0 i1@97@04)))
; [eval] aloc(opt_get1(source), i1).option$array$ != (None(): option[array])
; [eval] aloc(opt_get1(source), i1)
; [eval] opt_get1(source)
(push) ; 9
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 9
; Joined path conditions
(push) ; 9
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 10
(assert (not (< i1@97@04 (alen<Int> (opt_get1 $Snap.unit source@26@04)))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               3121
;  :arith-add-rows          1148
;  :arith-assert-diseq      102
;  :arith-assert-lower      597
;  :arith-assert-upper      383
;  :arith-bound-prop        238
;  :arith-conflicts         87
;  :arith-eq-adapter        368
;  :arith-fixed-eqs         163
;  :arith-max-min           27
;  :arith-nonlinear-bounds  3
;  :arith-offset-eqs        192
;  :arith-pivots            527
;  :conflicts               315
;  :datatype-accessor-ax    39
;  :datatype-constructor-ax 229
;  :datatype-occurs-check   106
;  :datatype-splits         61
;  :decisions               487
;  :del-clause              3014
;  :final-checks            68
;  :interface-eqs           1
;  :max-generation          4
;  :max-memory              5.62
;  :memory                  5.61
;  :minimized-lits          14
;  :mk-bool-var             5472
;  :mk-clause               3014
;  :num-allocs              239391
;  :num-checks              136
;  :propagations            1213
;  :quant-instantiations    1391
;  :rlimit-count            368102)
(assert (< i1@97@04 (alen<Int> (opt_get1 $Snap.unit source@26@04))))
(pop) ; 9
; Joined path conditions
(assert (< i1@97@04 (alen<Int> (opt_get1 $Snap.unit source@26@04))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@97@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@97@04)))
(push) ; 9
(assert (not (<
  $Perm.No
  (+
    (ite
      (and
        (<
          (inv@42@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@97@04))
          V@28@04)
        (<=
          0
          (inv@42@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@97@04))))
      $k@41@04
      $Perm.No)
    (ite
      (and
        (<
          (inv@34@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@97@04))
          V@28@04)
        (<=
          0
          (inv@34@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@97@04))))
      $k@33@04
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               3185
;  :arith-add-rows          1159
;  :arith-assert-diseq      105
;  :arith-assert-lower      612
;  :arith-assert-upper      396
;  :arith-bound-prop        243
;  :arith-conflicts         89
;  :arith-eq-adapter        380
;  :arith-fixed-eqs         167
;  :arith-max-min           27
;  :arith-nonlinear-bounds  3
;  :arith-offset-eqs        197
;  :arith-pivots            537
;  :conflicts               324
;  :datatype-accessor-ax    39
;  :datatype-constructor-ax 233
;  :datatype-occurs-check   106
;  :datatype-splits         61
;  :decisions               496
;  :del-clause              3057
;  :final-checks            68
;  :interface-eqs           1
;  :max-generation          4
;  :max-memory              5.62
;  :memory                  5.61
;  :minimized-lits          14
;  :mk-bool-var             5587
;  :mk-clause               3098
;  :num-allocs              240078
;  :num-checks              137
;  :propagations            1251
;  :quant-instantiations    1421
;  :rlimit-count            370142)
; [eval] (None(): option[array])
(pop) ; 8
(push) ; 8
; [else-branch: 89 | !(i1@97@04 < V@28@04 && 0 <= i1@97@04)]
(assert (not (and (< i1@97@04 V@28@04) (<= 0 i1@97@04))))
(pop) ; 8
(pop) ; 7
; Joined path conditions
(assert (implies
  (and (< i1@97@04 V@28@04) (<= 0 i1@97@04))
  (and
    (< i1@97@04 V@28@04)
    (<= 0 i1@97@04)
    (< i1@97@04 (alen<Int> (opt_get1 $Snap.unit source@26@04)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@97@04)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@97@04)))))
; Joined path conditions
(pop) ; 6
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@97@04 Int)) (!
  (implies
    (and (< i1@97@04 V@28@04) (<= 0 i1@97@04))
    (and
      (< i1@97@04 V@28@04)
      (<= 0 i1@97@04)
      (< i1@97@04 (alen<Int> (opt_get1 $Snap.unit source@26@04)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@97@04)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@97@04))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@97@04))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (implies
  (< 0 V@28@04)
  (forall ((i1@97@04 Int)) (!
    (implies
      (and (< i1@97@04 V@28@04) (<= 0 i1@97@04))
      (and
        (< i1@97@04 V@28@04)
        (<= 0 i1@97@04)
        (< i1@97@04 (alen<Int> (opt_get1 $Snap.unit source@26@04)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@97@04)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@97@04))))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@97@04))
    :qid |prog.l<no position>-aux|))))
(push) ; 4
(assert (not (implies
  (< 0 V@28@04)
  (forall ((i1@97@04 Int)) (!
    (implies
      (and (< i1@97@04 V@28@04) (<= 0 i1@97@04))
      (not
        (=
          ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@97@04))
          (as None<option<array>>  option<array>))))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@97@04))
    :qid |prog.l<no position>|)))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               3228
;  :arith-add-rows          1167
;  :arith-assert-diseq      106
;  :arith-assert-lower      616
;  :arith-assert-upper      399
;  :arith-bound-prop        245
;  :arith-conflicts         90
;  :arith-eq-adapter        381
;  :arith-fixed-eqs         168
;  :arith-max-min           27
;  :arith-nonlinear-bounds  3
;  :arith-offset-eqs        197
;  :arith-pivots            544
;  :conflicts               331
;  :datatype-accessor-ax    39
;  :datatype-constructor-ax 237
;  :datatype-occurs-check   106
;  :datatype-splits         61
;  :decisions               502
;  :del-clause              3147
;  :final-checks            68
;  :interface-eqs           1
;  :max-generation          4
;  :max-memory              5.62
;  :memory                  5.60
;  :minimized-lits          14
;  :mk-bool-var             5659
;  :mk-clause               3147
;  :num-allocs              240813
;  :num-checks              138
;  :propagations            1267
;  :quant-instantiations    1448
;  :rlimit-count            372283
;  :time                    0.00)
(assert (implies
  (< 0 V@28@04)
  (forall ((i1@97@04 Int)) (!
    (implies
      (and (< i1@97@04 V@28@04) (<= 0 i1@97@04))
      (not
        (=
          ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@97@04))
          (as None<option<array>>  option<array>))))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@97@04))
    :qid |prog.l<no position>|))))
; [eval] 0 < V ==> (forall i1: Int :: { alen(opt_get1(aloc(opt_get1(source), i1).option$array$)) } 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(source), i1).option$array$)) == V)
; [eval] 0 < V
(push) ; 4
(set-option :timeout 10)
(push) ; 5
(assert (not (not (< 0 V@28@04))))
(check-sat)
; unknown
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               3239
;  :arith-add-rows          1167
;  :arith-assert-diseq      106
;  :arith-assert-lower      616
;  :arith-assert-upper      399
;  :arith-bound-prop        245
;  :arith-conflicts         90
;  :arith-eq-adapter        381
;  :arith-fixed-eqs         168
;  :arith-max-min           27
;  :arith-nonlinear-bounds  3
;  :arith-offset-eqs        197
;  :arith-pivots            544
;  :conflicts               331
;  :datatype-accessor-ax    39
;  :datatype-constructor-ax 241
;  :datatype-occurs-check   107
;  :datatype-splits         61
;  :decisions               506
;  :del-clause              3147
;  :final-checks            69
;  :interface-eqs           1
;  :max-generation          4
;  :max-memory              5.62
;  :memory                  5.61
;  :minimized-lits          14
;  :mk-bool-var             5660
;  :mk-clause               3147
;  :num-allocs              241555
;  :num-checks              139
;  :propagations            1267
;  :quant-instantiations    1448
;  :rlimit-count            373184)
; [then-branch: 90 | 0 < V@28@04 | live]
; [else-branch: 90 | !(0 < V@28@04) | dead]
(push) ; 5
; [then-branch: 90 | 0 < V@28@04]
; [eval] (forall i1: Int :: { alen(opt_get1(aloc(opt_get1(source), i1).option$array$)) } 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(source), i1).option$array$)) == V)
(declare-const i1@98@04 Int)
(push) ; 6
; [eval] 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(source), i1).option$array$)) == V
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 7
; [then-branch: 91 | 0 <= i1@98@04 | live]
; [else-branch: 91 | !(0 <= i1@98@04) | live]
(push) ; 8
; [then-branch: 91 | 0 <= i1@98@04]
(assert (<= 0 i1@98@04))
; [eval] i1 < V
(pop) ; 8
(push) ; 8
; [else-branch: 91 | !(0 <= i1@98@04)]
(assert (not (<= 0 i1@98@04)))
(pop) ; 8
(pop) ; 7
; Joined path conditions
; Joined path conditions
(push) ; 7
; [then-branch: 92 | i1@98@04 < V@28@04 && 0 <= i1@98@04 | live]
; [else-branch: 92 | !(i1@98@04 < V@28@04 && 0 <= i1@98@04) | live]
(push) ; 8
; [then-branch: 92 | i1@98@04 < V@28@04 && 0 <= i1@98@04]
(assert (and (< i1@98@04 V@28@04) (<= 0 i1@98@04)))
; [eval] alen(opt_get1(aloc(opt_get1(source), i1).option$array$)) == V
; [eval] alen(opt_get1(aloc(opt_get1(source), i1).option$array$))
; [eval] opt_get1(aloc(opt_get1(source), i1).option$array$)
; [eval] aloc(opt_get1(source), i1)
; [eval] opt_get1(source)
(push) ; 9
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 9
; Joined path conditions
(push) ; 9
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 10
(assert (not (< i1@98@04 (alen<Int> (opt_get1 $Snap.unit source@26@04)))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               3239
;  :arith-add-rows          1167
;  :arith-assert-diseq      106
;  :arith-assert-lower      618
;  :arith-assert-upper      399
;  :arith-bound-prop        245
;  :arith-conflicts         90
;  :arith-eq-adapter        381
;  :arith-fixed-eqs         168
;  :arith-max-min           27
;  :arith-nonlinear-bounds  3
;  :arith-offset-eqs        197
;  :arith-pivots            544
;  :conflicts               331
;  :datatype-accessor-ax    39
;  :datatype-constructor-ax 241
;  :datatype-occurs-check   107
;  :datatype-splits         61
;  :decisions               506
;  :del-clause              3147
;  :final-checks            69
;  :interface-eqs           1
;  :max-generation          4
;  :max-memory              5.62
;  :memory                  5.61
;  :minimized-lits          14
;  :mk-bool-var             5662
;  :mk-clause               3147
;  :num-allocs              241660
;  :num-checks              140
;  :propagations            1267
;  :quant-instantiations    1448
;  :rlimit-count            373379)
(assert (< i1@98@04 (alen<Int> (opt_get1 $Snap.unit source@26@04))))
(pop) ; 9
; Joined path conditions
(assert (< i1@98@04 (alen<Int> (opt_get1 $Snap.unit source@26@04))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@98@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@98@04)))
(push) ; 9
(assert (not (<
  $Perm.No
  (+
    (ite
      (and
        (<
          (inv@42@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@98@04))
          V@28@04)
        (<=
          0
          (inv@42@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@98@04))))
      $k@41@04
      $Perm.No)
    (ite
      (and
        (<
          (inv@34@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@98@04))
          V@28@04)
        (<=
          0
          (inv@34@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@98@04))))
      $k@33@04
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               3320
;  :arith-add-rows          1185
;  :arith-assert-diseq      109
;  :arith-assert-lower      638
;  :arith-assert-upper      410
;  :arith-bound-prop        252
;  :arith-conflicts         92
;  :arith-eq-adapter        395
;  :arith-fixed-eqs         173
;  :arith-max-min           27
;  :arith-nonlinear-bounds  3
;  :arith-offset-eqs        210
;  :arith-pivots            556
;  :conflicts               341
;  :datatype-accessor-ax    39
;  :datatype-constructor-ax 245
;  :datatype-occurs-check   107
;  :datatype-splits         61
;  :decisions               515
;  :del-clause              3203
;  :final-checks            69
;  :interface-eqs           1
;  :max-generation          4
;  :max-memory              5.62
;  :memory                  5.61
;  :minimized-lits          14
;  :mk-bool-var             5798
;  :mk-clause               3244
;  :num-allocs              242418
;  :num-checks              141
;  :propagations            1308
;  :quant-instantiations    1480
;  :rlimit-count            375613)
(push) ; 9
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 10
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@98@04))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               3320
;  :arith-add-rows          1185
;  :arith-assert-diseq      109
;  :arith-assert-lower      638
;  :arith-assert-upper      410
;  :arith-bound-prop        252
;  :arith-conflicts         92
;  :arith-eq-adapter        395
;  :arith-fixed-eqs         173
;  :arith-max-min           27
;  :arith-nonlinear-bounds  3
;  :arith-offset-eqs        210
;  :arith-pivots            556
;  :conflicts               342
;  :datatype-accessor-ax    39
;  :datatype-constructor-ax 245
;  :datatype-occurs-check   107
;  :datatype-splits         61
;  :decisions               515
;  :del-clause              3203
;  :final-checks            69
;  :interface-eqs           1
;  :max-generation          4
;  :max-memory              5.62
;  :memory                  5.61
;  :minimized-lits          14
;  :mk-bool-var             5798
;  :mk-clause               3244
;  :num-allocs              242509
;  :num-checks              142
;  :propagations            1308
;  :quant-instantiations    1480
;  :rlimit-count            375708)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@98@04))
    (as None<option<array>>  option<array>))))
(pop) ; 9
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@98@04))
    (as None<option<array>>  option<array>))))
(pop) ; 8
(push) ; 8
; [else-branch: 92 | !(i1@98@04 < V@28@04 && 0 <= i1@98@04)]
(assert (not (and (< i1@98@04 V@28@04) (<= 0 i1@98@04))))
(pop) ; 8
(pop) ; 7
; Joined path conditions
(assert (implies
  (and (< i1@98@04 V@28@04) (<= 0 i1@98@04))
  (and
    (< i1@98@04 V@28@04)
    (<= 0 i1@98@04)
    (< i1@98@04 (alen<Int> (opt_get1 $Snap.unit source@26@04)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@98@04)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@98@04))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@98@04))
        (as None<option<array>>  option<array>))))))
; Joined path conditions
(pop) ; 6
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@98@04 Int)) (!
  (implies
    (and (< i1@98@04 V@28@04) (<= 0 i1@98@04))
    (and
      (< i1@98@04 V@28@04)
      (<= 0 i1@98@04)
      (< i1@98@04 (alen<Int> (opt_get1 $Snap.unit source@26@04)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@98@04)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@98@04))
      (not
        (=
          ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@98@04))
          (as None<option<array>>  option<array>)))))
  :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@98@04)))))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (implies
  (< 0 V@28@04)
  (forall ((i1@98@04 Int)) (!
    (implies
      (and (< i1@98@04 V@28@04) (<= 0 i1@98@04))
      (and
        (< i1@98@04 V@28@04)
        (<= 0 i1@98@04)
        (< i1@98@04 (alen<Int> (opt_get1 $Snap.unit source@26@04)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@98@04)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@98@04))
        (not
          (=
            ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@98@04))
            (as None<option<array>>  option<array>)))))
    :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@98@04)))))
    :qid |prog.l<no position>-aux|))))
(push) ; 4
(assert (not (implies
  (< 0 V@28@04)
  (forall ((i1@98@04 Int)) (!
    (implies
      (and (< i1@98@04 V@28@04) (<= 0 i1@98@04))
      (=
        (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@98@04))))
        V@28@04))
    :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@98@04)))))
    :qid |prog.l<no position>|)))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               3378
;  :arith-add-rows          1202
;  :arith-assert-diseq      112
;  :arith-assert-lower      645
;  :arith-assert-upper      415
;  :arith-bound-prop        255
;  :arith-conflicts         93
;  :arith-eq-adapter        398
;  :arith-fixed-eqs         175
;  :arith-max-min           27
;  :arith-nonlinear-bounds  3
;  :arith-offset-eqs        210
;  :arith-pivots            565
;  :conflicts               350
;  :datatype-accessor-ax    39
;  :datatype-constructor-ax 249
;  :datatype-occurs-check   107
;  :datatype-splits         61
;  :decisions               525
;  :del-clause              3306
;  :final-checks            69
;  :interface-eqs           1
;  :max-generation          4
;  :max-memory              5.62
;  :memory                  5.60
;  :minimized-lits          14
;  :mk-bool-var             5896
;  :mk-clause               3306
;  :num-allocs              243306
;  :num-checks              143
;  :propagations            1329
;  :quant-instantiations    1516
;  :rlimit-count            378352
;  :time                    0.00)
(assert (implies
  (< 0 V@28@04)
  (forall ((i1@98@04 Int)) (!
    (implies
      (and (< i1@98@04 V@28@04) (<= 0 i1@98@04))
      (=
        (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@98@04))))
        V@28@04))
    :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@98@04)))))
    :qid |prog.l<no position>|))))
; [eval] 0 < V ==> (forall i1: Int :: { aloc(opt_get1(source), i1) } (forall i2: Int :: { aloc(opt_get1(source), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(source), i1).option$array$ == aloc(opt_get1(source), i2).option$array$ ==> i1 == i2))
; [eval] 0 < V
(push) ; 4
(set-option :timeout 10)
(push) ; 5
(assert (not (not (< 0 V@28@04))))
(check-sat)
; unknown
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               3389
;  :arith-add-rows          1202
;  :arith-assert-diseq      112
;  :arith-assert-lower      645
;  :arith-assert-upper      415
;  :arith-bound-prop        255
;  :arith-conflicts         93
;  :arith-eq-adapter        398
;  :arith-fixed-eqs         175
;  :arith-max-min           27
;  :arith-nonlinear-bounds  3
;  :arith-offset-eqs        210
;  :arith-pivots            565
;  :conflicts               350
;  :datatype-accessor-ax    39
;  :datatype-constructor-ax 253
;  :datatype-occurs-check   108
;  :datatype-splits         61
;  :decisions               529
;  :del-clause              3306
;  :final-checks            70
;  :interface-eqs           1
;  :max-generation          4
;  :max-memory              5.62
;  :memory                  5.61
;  :minimized-lits          14
;  :mk-bool-var             5897
;  :mk-clause               3306
;  :num-allocs              244050
;  :num-checks              144
;  :propagations            1329
;  :quant-instantiations    1516
;  :rlimit-count            379255
;  :time                    0.00)
; [then-branch: 93 | 0 < V@28@04 | live]
; [else-branch: 93 | !(0 < V@28@04) | dead]
(push) ; 5
; [then-branch: 93 | 0 < V@28@04]
; [eval] (forall i1: Int :: { aloc(opt_get1(source), i1) } (forall i2: Int :: { aloc(opt_get1(source), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(source), i1).option$array$ == aloc(opt_get1(source), i2).option$array$ ==> i1 == i2))
(declare-const i1@99@04 Int)
(push) ; 6
; [eval] (forall i2: Int :: { aloc(opt_get1(source), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(source), i1).option$array$ == aloc(opt_get1(source), i2).option$array$ ==> i1 == i2)
(declare-const i2@100@04 Int)
(push) ; 7
; [eval] 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(source), i1).option$array$ == aloc(opt_get1(source), i2).option$array$ ==> i1 == i2
; [eval] 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(source), i1).option$array$ == aloc(opt_get1(source), i2).option$array$
; [eval] 0 <= i1
(push) ; 8
; [then-branch: 94 | 0 <= i1@99@04 | live]
; [else-branch: 94 | !(0 <= i1@99@04) | live]
(push) ; 9
; [then-branch: 94 | 0 <= i1@99@04]
(assert (<= 0 i1@99@04))
; [eval] i1 < V
(push) ; 10
; [then-branch: 95 | i1@99@04 < V@28@04 | live]
; [else-branch: 95 | !(i1@99@04 < V@28@04) | live]
(push) ; 11
; [then-branch: 95 | i1@99@04 < V@28@04]
(assert (< i1@99@04 V@28@04))
; [eval] 0 <= i2
(push) ; 12
; [then-branch: 96 | 0 <= i2@100@04 | live]
; [else-branch: 96 | !(0 <= i2@100@04) | live]
(push) ; 13
; [then-branch: 96 | 0 <= i2@100@04]
(assert (<= 0 i2@100@04))
; [eval] i2 < V
(push) ; 14
; [then-branch: 97 | i2@100@04 < V@28@04 | live]
; [else-branch: 97 | !(i2@100@04 < V@28@04) | live]
(push) ; 15
; [then-branch: 97 | i2@100@04 < V@28@04]
(assert (< i2@100@04 V@28@04))
; [eval] aloc(opt_get1(source), i1).option$array$ == aloc(opt_get1(source), i2).option$array$
; [eval] aloc(opt_get1(source), i1)
; [eval] opt_get1(source)
(push) ; 16
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 16
; Joined path conditions
(push) ; 16
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 17
(assert (not (< i1@99@04 (alen<Int> (opt_get1 $Snap.unit source@26@04)))))
(check-sat)
; unsat
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               3389
;  :arith-add-rows          1202
;  :arith-assert-diseq      112
;  :arith-assert-lower      649
;  :arith-assert-upper      415
;  :arith-bound-prop        255
;  :arith-conflicts         93
;  :arith-eq-adapter        398
;  :arith-fixed-eqs         175
;  :arith-max-min           27
;  :arith-nonlinear-bounds  3
;  :arith-offset-eqs        210
;  :arith-pivots            567
;  :conflicts               350
;  :datatype-accessor-ax    39
;  :datatype-constructor-ax 253
;  :datatype-occurs-check   108
;  :datatype-splits         61
;  :decisions               529
;  :del-clause              3306
;  :final-checks            70
;  :interface-eqs           1
;  :max-generation          4
;  :max-memory              5.62
;  :memory                  5.61
;  :minimized-lits          14
;  :mk-bool-var             5901
;  :mk-clause               3306
;  :num-allocs              244331
;  :num-checks              145
;  :propagations            1329
;  :quant-instantiations    1516
;  :rlimit-count            379604)
(assert (< i1@99@04 (alen<Int> (opt_get1 $Snap.unit source@26@04))))
(pop) ; 16
; Joined path conditions
(assert (< i1@99@04 (alen<Int> (opt_get1 $Snap.unit source@26@04))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@99@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@99@04)))
(push) ; 16
(assert (not (<
  $Perm.No
  (+
    (ite
      (and
        (<
          (inv@42@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@99@04))
          V@28@04)
        (<=
          0
          (inv@42@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@99@04))))
      $k@41@04
      $Perm.No)
    (ite
      (and
        (<
          (inv@34@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@99@04))
          V@28@04)
        (<=
          0
          (inv@34@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@99@04))))
      $k@33@04
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               3462
;  :arith-add-rows          1221
;  :arith-assert-diseq      115
;  :arith-assert-lower      669
;  :arith-assert-upper      426
;  :arith-bound-prop        262
;  :arith-conflicts         95
;  :arith-eq-adapter        412
;  :arith-fixed-eqs         180
;  :arith-max-min           27
;  :arith-nonlinear-bounds  3
;  :arith-offset-eqs        218
;  :arith-pivots            577
;  :conflicts               359
;  :datatype-accessor-ax    39
;  :datatype-constructor-ax 257
;  :datatype-occurs-check   108
;  :datatype-splits         61
;  :decisions               537
;  :del-clause              3356
;  :final-checks            70
;  :interface-eqs           1
;  :max-generation          4
;  :max-memory              5.62
;  :memory                  5.61
;  :minimized-lits          14
;  :mk-bool-var             6031
;  :mk-clause               3397
;  :num-allocs              245083
;  :num-checks              146
;  :propagations            1369
;  :quant-instantiations    1547
;  :rlimit-count            381758)
; [eval] aloc(opt_get1(source), i2)
; [eval] opt_get1(source)
(push) ; 16
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 16
; Joined path conditions
(push) ; 16
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 17
(assert (not (< i2@100@04 (alen<Int> (opt_get1 $Snap.unit source@26@04)))))
(check-sat)
; unsat
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               3462
;  :arith-add-rows          1221
;  :arith-assert-diseq      115
;  :arith-assert-lower      669
;  :arith-assert-upper      426
;  :arith-bound-prop        262
;  :arith-conflicts         95
;  :arith-eq-adapter        412
;  :arith-fixed-eqs         180
;  :arith-max-min           27
;  :arith-nonlinear-bounds  3
;  :arith-offset-eqs        218
;  :arith-pivots            577
;  :conflicts               359
;  :datatype-accessor-ax    39
;  :datatype-constructor-ax 257
;  :datatype-occurs-check   108
;  :datatype-splits         61
;  :decisions               537
;  :del-clause              3356
;  :final-checks            70
;  :interface-eqs           1
;  :max-generation          4
;  :max-memory              5.62
;  :memory                  5.61
;  :minimized-lits          14
;  :mk-bool-var             6031
;  :mk-clause               3397
;  :num-allocs              245110
;  :num-checks              147
;  :propagations            1369
;  :quant-instantiations    1547
;  :rlimit-count            381788)
(assert (< i2@100@04 (alen<Int> (opt_get1 $Snap.unit source@26@04))))
(pop) ; 16
; Joined path conditions
(assert (< i2@100@04 (alen<Int> (opt_get1 $Snap.unit source@26@04))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@100@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@100@04)))
(push) ; 16
(assert (not (<
  $Perm.No
  (+
    (ite
      (and
        (<
          (inv@42@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@100@04))
          V@28@04)
        (<=
          0
          (inv@42@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@100@04))))
      $k@41@04
      $Perm.No)
    (ite
      (and
        (<
          (inv@34@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@100@04))
          V@28@04)
        (<=
          0
          (inv@34@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@100@04))))
      $k@33@04
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               3567
;  :arith-add-rows          1281
;  :arith-assert-diseq      124
;  :arith-assert-lower      700
;  :arith-assert-upper      442
;  :arith-bound-prop        273
;  :arith-conflicts         98
;  :arith-eq-adapter        431
;  :arith-fixed-eqs         187
;  :arith-max-min           27
;  :arith-nonlinear-bounds  3
;  :arith-offset-eqs        228
;  :arith-pivots            594
;  :conflicts               374
;  :datatype-accessor-ax    39
;  :datatype-constructor-ax 261
;  :datatype-occurs-check   108
;  :datatype-splits         61
;  :decisions               553
;  :del-clause              3443
;  :final-checks            70
;  :interface-eqs           1
;  :max-generation          4
;  :max-memory              5.66
;  :memory                  5.63
;  :minimized-lits          14
;  :mk-bool-var             6227
;  :mk-clause               3535
;  :num-allocs              246050
;  :num-checks              148
;  :propagations            1434
;  :quant-instantiations    1580
;  :rlimit-count            385014
;  :time                    0.00)
(pop) ; 15
(push) ; 15
; [else-branch: 97 | !(i2@100@04 < V@28@04)]
(assert (not (< i2@100@04 V@28@04)))
(pop) ; 15
(pop) ; 14
; Joined path conditions
(assert (implies
  (< i2@100@04 V@28@04)
  (and
    (< i2@100@04 V@28@04)
    (< i1@99@04 (alen<Int> (opt_get1 $Snap.unit source@26@04)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@99@04)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@99@04))
    (< i2@100@04 (alen<Int> (opt_get1 $Snap.unit source@26@04)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@100@04)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@100@04)))))
; Joined path conditions
(pop) ; 13
(push) ; 13
; [else-branch: 96 | !(0 <= i2@100@04)]
(assert (not (<= 0 i2@100@04)))
(pop) ; 13
(pop) ; 12
; Joined path conditions
(assert (implies
  (<= 0 i2@100@04)
  (and
    (<= 0 i2@100@04)
    (implies
      (< i2@100@04 V@28@04)
      (and
        (< i2@100@04 V@28@04)
        (< i1@99@04 (alen<Int> (opt_get1 $Snap.unit source@26@04)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@99@04)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@99@04))
        (< i2@100@04 (alen<Int> (opt_get1 $Snap.unit source@26@04)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@100@04)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@100@04)))))))
; Joined path conditions
(pop) ; 11
(push) ; 11
; [else-branch: 95 | !(i1@99@04 < V@28@04)]
(assert (not (< i1@99@04 V@28@04)))
(pop) ; 11
(pop) ; 10
; Joined path conditions
(assert (implies
  (< i1@99@04 V@28@04)
  (and
    (< i1@99@04 V@28@04)
    (implies
      (<= 0 i2@100@04)
      (and
        (<= 0 i2@100@04)
        (implies
          (< i2@100@04 V@28@04)
          (and
            (< i2@100@04 V@28@04)
            (< i1@99@04 (alen<Int> (opt_get1 $Snap.unit source@26@04)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@99@04)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@99@04))
            (< i2@100@04 (alen<Int> (opt_get1 $Snap.unit source@26@04)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@100@04)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@100@04)))))))))
; Joined path conditions
(pop) ; 9
(push) ; 9
; [else-branch: 94 | !(0 <= i1@99@04)]
(assert (not (<= 0 i1@99@04)))
(pop) ; 9
(pop) ; 8
; Joined path conditions
(assert (implies
  (<= 0 i1@99@04)
  (and
    (<= 0 i1@99@04)
    (implies
      (< i1@99@04 V@28@04)
      (and
        (< i1@99@04 V@28@04)
        (implies
          (<= 0 i2@100@04)
          (and
            (<= 0 i2@100@04)
            (implies
              (< i2@100@04 V@28@04)
              (and
                (< i2@100@04 V@28@04)
                (< i1@99@04 (alen<Int> (opt_get1 $Snap.unit source@26@04)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@99@04)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@99@04))
                (< i2@100@04 (alen<Int> (opt_get1 $Snap.unit source@26@04)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@100@04)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@100@04)))))))))))
; Joined path conditions
(push) ; 8
; [then-branch: 98 | Lookup(option$array$,sm@43@04,aloc((_, _), opt_get1(_, source@26@04), i1@99@04)) == Lookup(option$array$,sm@43@04,aloc((_, _), opt_get1(_, source@26@04), i2@100@04)) && i2@100@04 < V@28@04 && 0 <= i2@100@04 && i1@99@04 < V@28@04 && 0 <= i1@99@04 | live]
; [else-branch: 98 | !(Lookup(option$array$,sm@43@04,aloc((_, _), opt_get1(_, source@26@04), i1@99@04)) == Lookup(option$array$,sm@43@04,aloc((_, _), opt_get1(_, source@26@04), i2@100@04)) && i2@100@04 < V@28@04 && 0 <= i2@100@04 && i1@99@04 < V@28@04 && 0 <= i1@99@04) | live]
(push) ; 9
; [then-branch: 98 | Lookup(option$array$,sm@43@04,aloc((_, _), opt_get1(_, source@26@04), i1@99@04)) == Lookup(option$array$,sm@43@04,aloc((_, _), opt_get1(_, source@26@04), i2@100@04)) && i2@100@04 < V@28@04 && 0 <= i2@100@04 && i1@99@04 < V@28@04 && 0 <= i1@99@04]
(assert (and
  (and
    (and
      (and
        (=
          ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@99@04))
          ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@100@04)))
        (< i2@100@04 V@28@04))
      (<= 0 i2@100@04))
    (< i1@99@04 V@28@04))
  (<= 0 i1@99@04)))
; [eval] i1 == i2
(pop) ; 9
(push) ; 9
; [else-branch: 98 | !(Lookup(option$array$,sm@43@04,aloc((_, _), opt_get1(_, source@26@04), i1@99@04)) == Lookup(option$array$,sm@43@04,aloc((_, _), opt_get1(_, source@26@04), i2@100@04)) && i2@100@04 < V@28@04 && 0 <= i2@100@04 && i1@99@04 < V@28@04 && 0 <= i1@99@04)]
(assert (not
  (and
    (and
      (and
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@99@04))
            ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@100@04)))
          (< i2@100@04 V@28@04))
        (<= 0 i2@100@04))
      (< i1@99@04 V@28@04))
    (<= 0 i1@99@04))))
(pop) ; 9
(pop) ; 8
; Joined path conditions
(assert (implies
  (and
    (and
      (and
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@99@04))
            ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@100@04)))
          (< i2@100@04 V@28@04))
        (<= 0 i2@100@04))
      (< i1@99@04 V@28@04))
    (<= 0 i1@99@04))
  (and
    (=
      ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@99@04))
      ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@100@04)))
    (< i2@100@04 V@28@04)
    (<= 0 i2@100@04)
    (< i1@99@04 V@28@04)
    (<= 0 i1@99@04))))
; Joined path conditions
(pop) ; 7
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i2@100@04 Int)) (!
  (and
    (implies
      (<= 0 i1@99@04)
      (and
        (<= 0 i1@99@04)
        (implies
          (< i1@99@04 V@28@04)
          (and
            (< i1@99@04 V@28@04)
            (implies
              (<= 0 i2@100@04)
              (and
                (<= 0 i2@100@04)
                (implies
                  (< i2@100@04 V@28@04)
                  (and
                    (< i2@100@04 V@28@04)
                    (< i1@99@04 (alen<Int> (opt_get1 $Snap.unit source@26@04)))
                    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@99@04)) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@99@04))
                    (< i2@100@04 (alen<Int> (opt_get1 $Snap.unit source@26@04)))
                    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@100@04)) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@100@04))))))))))
    (implies
      (and
        (and
          (and
            (and
              (=
                ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@99@04))
                ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@100@04)))
              (< i2@100@04 V@28@04))
            (<= 0 i2@100@04))
          (< i1@99@04 V@28@04))
        (<= 0 i1@99@04))
      (and
        (=
          ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@99@04))
          ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@100@04)))
        (< i2@100@04 V@28@04)
        (<= 0 i2@100@04)
        (< i1@99@04 V@28@04)
        (<= 0 i1@99@04))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@100@04))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 6
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@99@04 Int)) (!
  (forall ((i2@100@04 Int)) (!
    (and
      (implies
        (<= 0 i1@99@04)
        (and
          (<= 0 i1@99@04)
          (implies
            (< i1@99@04 V@28@04)
            (and
              (< i1@99@04 V@28@04)
              (implies
                (<= 0 i2@100@04)
                (and
                  (<= 0 i2@100@04)
                  (implies
                    (< i2@100@04 V@28@04)
                    (and
                      (< i2@100@04 V@28@04)
                      (< i1@99@04 (alen<Int> (opt_get1 $Snap.unit source@26@04)))
                      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@99@04)) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@99@04))
                      (<
                        i2@100@04
                        (alen<Int> (opt_get1 $Snap.unit source@26@04)))
                      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@100@04)) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@100@04))))))))))
      (implies
        (and
          (and
            (and
              (and
                (=
                  ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@99@04))
                  ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@100@04)))
                (< i2@100@04 V@28@04))
              (<= 0 i2@100@04))
            (< i1@99@04 V@28@04))
          (<= 0 i1@99@04))
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@99@04))
            ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@100@04)))
          (< i2@100@04 V@28@04)
          (<= 0 i2@100@04)
          (< i1@99@04 V@28@04)
          (<= 0 i1@99@04))))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@100@04))
    :qid |prog.l<no position>-aux|))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@99@04))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (implies
  (< 0 V@28@04)
  (forall ((i1@99@04 Int)) (!
    (forall ((i2@100@04 Int)) (!
      (and
        (implies
          (<= 0 i1@99@04)
          (and
            (<= 0 i1@99@04)
            (implies
              (< i1@99@04 V@28@04)
              (and
                (< i1@99@04 V@28@04)
                (implies
                  (<= 0 i2@100@04)
                  (and
                    (<= 0 i2@100@04)
                    (implies
                      (< i2@100@04 V@28@04)
                      (and
                        (< i2@100@04 V@28@04)
                        (<
                          i1@99@04
                          (alen<Int> (opt_get1 $Snap.unit source@26@04)))
                        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
                          $Snap.unit
                          $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@99@04)) (aloc ($Snap.combine
                          $Snap.unit
                          $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@99@04))
                        (<
                          i2@100@04
                          (alen<Int> (opt_get1 $Snap.unit source@26@04)))
                        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
                          $Snap.unit
                          $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@100@04)) (aloc ($Snap.combine
                          $Snap.unit
                          $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@100@04))))))))))
        (implies
          (and
            (and
              (and
                (and
                  (=
                    ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@99@04))
                    ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@100@04)))
                  (< i2@100@04 V@28@04))
                (<= 0 i2@100@04))
              (< i1@99@04 V@28@04))
            (<= 0 i1@99@04))
          (and
            (=
              ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@99@04))
              ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@100@04)))
            (< i2@100@04 V@28@04)
            (<= 0 i2@100@04)
            (< i1@99@04 V@28@04)
            (<= 0 i1@99@04))))
      :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@100@04))
      :qid |prog.l<no position>-aux|))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@99@04))
    :qid |prog.l<no position>-aux|))))
(push) ; 4
(assert (not (implies
  (< 0 V@28@04)
  (forall ((i1@99@04 Int)) (!
    (forall ((i2@100@04 Int)) (!
      (implies
        (and
          (and
            (and
              (and
                (=
                  ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@99@04))
                  ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@100@04)))
                (< i2@100@04 V@28@04))
              (<= 0 i2@100@04))
            (< i1@99@04 V@28@04))
          (<= 0 i1@99@04))
        (= i1@99@04 i2@100@04))
      :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@100@04))
      :qid |prog.l<no position>|))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@99@04))
    :qid |prog.l<no position>|)))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               3635
;  :arith-add-rows          1329
;  :arith-assert-diseq      128
;  :arith-assert-lower      710
;  :arith-assert-upper      448
;  :arith-bound-prop        278
;  :arith-conflicts         100
;  :arith-eq-adapter        434
;  :arith-fixed-eqs         189
;  :arith-max-min           27
;  :arith-nonlinear-bounds  3
;  :arith-offset-eqs        231
;  :arith-pivots            612
;  :conflicts               384
;  :datatype-accessor-ax    39
;  :datatype-constructor-ax 265
;  :datatype-occurs-check   108
;  :datatype-splits         61
;  :decisions               562
;  :del-clause              3656
;  :final-checks            70
;  :interface-eqs           1
;  :max-generation          4
;  :max-memory              5.66
;  :memory                  5.62
;  :minimized-lits          14
;  :mk-bool-var             6417
;  :mk-clause               3656
;  :num-allocs              247709
;  :num-checks              149
;  :propagations            1467
;  :quant-instantiations    1640
;  :rlimit-count            391347
;  :time                    0.00)
(assert (implies
  (< 0 V@28@04)
  (forall ((i1@99@04 Int)) (!
    (forall ((i2@100@04 Int)) (!
      (implies
        (and
          (and
            (and
              (and
                (=
                  ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@99@04))
                  ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@100@04)))
                (< i2@100@04 V@28@04))
              (<= 0 i2@100@04))
            (< i1@99@04 V@28@04))
          (<= 0 i1@99@04))
        (= i1@99@04 i2@100@04))
      :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@100@04))
      :qid |prog.l<no position>|))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@99@04))
    :qid |prog.l<no position>|))))
; [eval] 0 < V ==> target != (None(): option[array])
; [eval] 0 < V
(push) ; 4
(set-option :timeout 10)
(push) ; 5
(assert (not (not (< 0 V@28@04))))
(check-sat)
; unknown
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               3646
;  :arith-add-rows          1329
;  :arith-assert-diseq      128
;  :arith-assert-lower      710
;  :arith-assert-upper      448
;  :arith-bound-prop        278
;  :arith-conflicts         100
;  :arith-eq-adapter        434
;  :arith-fixed-eqs         189
;  :arith-max-min           27
;  :arith-nonlinear-bounds  3
;  :arith-offset-eqs        231
;  :arith-pivots            612
;  :conflicts               384
;  :datatype-accessor-ax    39
;  :datatype-constructor-ax 269
;  :datatype-occurs-check   109
;  :datatype-splits         61
;  :decisions               566
;  :del-clause              3656
;  :final-checks            71
;  :interface-eqs           1
;  :max-generation          4
;  :max-memory              5.66
;  :memory                  5.63
;  :minimized-lits          14
;  :mk-bool-var             6418
;  :mk-clause               3656
;  :num-allocs              248583
;  :num-checks              150
;  :propagations            1467
;  :quant-instantiations    1640
;  :rlimit-count            392472)
; [then-branch: 99 | 0 < V@28@04 | live]
; [else-branch: 99 | !(0 < V@28@04) | dead]
(push) ; 5
; [then-branch: 99 | 0 < V@28@04]
; [eval] target != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 5
(pop) ; 4
; Joined path conditions
(set-option :timeout 0)
(push) ; 4
(assert (not (implies
  (< 0 V@28@04)
  (not (= target@27@04 (as None<option<array>>  option<array>))))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               3646
;  :arith-add-rows          1329
;  :arith-assert-diseq      128
;  :arith-assert-lower      710
;  :arith-assert-upper      448
;  :arith-bound-prop        278
;  :arith-conflicts         100
;  :arith-eq-adapter        434
;  :arith-fixed-eqs         189
;  :arith-max-min           27
;  :arith-nonlinear-bounds  3
;  :arith-offset-eqs        231
;  :arith-pivots            612
;  :conflicts               384
;  :datatype-accessor-ax    39
;  :datatype-constructor-ax 269
;  :datatype-occurs-check   109
;  :datatype-splits         61
;  :decisions               566
;  :del-clause              3656
;  :final-checks            71
;  :interface-eqs           1
;  :max-generation          4
;  :max-memory              5.66
;  :memory                  5.63
;  :minimized-lits          14
;  :mk-bool-var             6418
;  :mk-clause               3656
;  :num-allocs              248608
;  :num-checks              151
;  :propagations            1467
;  :quant-instantiations    1640
;  :rlimit-count            392494)
(assert (implies
  (< 0 V@28@04)
  (not (= target@27@04 (as None<option<array>>  option<array>)))))
; [eval] 0 < V ==> alen(opt_get1(target)) == V
; [eval] 0 < V
(push) ; 4
(set-option :timeout 10)
(push) ; 5
(assert (not (not (< 0 V@28@04))))
(check-sat)
; unknown
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               3657
;  :arith-add-rows          1329
;  :arith-assert-diseq      128
;  :arith-assert-lower      710
;  :arith-assert-upper      448
;  :arith-bound-prop        278
;  :arith-conflicts         100
;  :arith-eq-adapter        434
;  :arith-fixed-eqs         189
;  :arith-max-min           27
;  :arith-nonlinear-bounds  3
;  :arith-offset-eqs        231
;  :arith-pivots            612
;  :conflicts               384
;  :datatype-accessor-ax    39
;  :datatype-constructor-ax 273
;  :datatype-occurs-check   110
;  :datatype-splits         61
;  :decisions               570
;  :del-clause              3656
;  :final-checks            72
;  :interface-eqs           1
;  :max-generation          4
;  :max-memory              5.66
;  :memory                  5.63
;  :minimized-lits          14
;  :mk-bool-var             6418
;  :mk-clause               3656
;  :num-allocs              249150
;  :num-checks              152
;  :propagations            1467
;  :quant-instantiations    1640
;  :rlimit-count            393089)
; [then-branch: 100 | 0 < V@28@04 | live]
; [else-branch: 100 | !(0 < V@28@04) | dead]
(push) ; 5
; [then-branch: 100 | 0 < V@28@04]
; [eval] alen(opt_get1(target)) == V
; [eval] alen(opt_get1(target))
; [eval] opt_get1(target)
(push) ; 6
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 6
; Joined path conditions
(pop) ; 5
(pop) ; 4
; Joined path conditions
(set-option :timeout 0)
(push) ; 4
(assert (not (implies
  (< 0 V@28@04)
  (= (alen<Int> (opt_get1 $Snap.unit target@27@04)) V@28@04))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               3657
;  :arith-add-rows          1329
;  :arith-assert-diseq      128
;  :arith-assert-lower      710
;  :arith-assert-upper      448
;  :arith-bound-prop        278
;  :arith-conflicts         100
;  :arith-eq-adapter        434
;  :arith-fixed-eqs         189
;  :arith-max-min           27
;  :arith-nonlinear-bounds  3
;  :arith-offset-eqs        231
;  :arith-pivots            612
;  :conflicts               384
;  :datatype-accessor-ax    39
;  :datatype-constructor-ax 273
;  :datatype-occurs-check   110
;  :datatype-splits         61
;  :decisions               570
;  :del-clause              3656
;  :final-checks            72
;  :interface-eqs           1
;  :max-generation          4
;  :max-memory              5.66
;  :memory                  5.63
;  :minimized-lits          14
;  :mk-bool-var             6418
;  :mk-clause               3656
;  :num-allocs              249169
;  :num-checks              153
;  :propagations            1467
;  :quant-instantiations    1640
;  :rlimit-count            393116)
(assert (implies
  (< 0 V@28@04)
  (= (alen<Int> (opt_get1 $Snap.unit target@27@04)) V@28@04)))
; [eval] 0 < V
(set-option :timeout 10)
(push) ; 4
(assert (not (not (< 0 V@28@04))))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               3668
;  :arith-add-rows          1329
;  :arith-assert-diseq      128
;  :arith-assert-lower      710
;  :arith-assert-upper      448
;  :arith-bound-prop        278
;  :arith-conflicts         100
;  :arith-eq-adapter        434
;  :arith-fixed-eqs         189
;  :arith-max-min           27
;  :arith-nonlinear-bounds  3
;  :arith-offset-eqs        231
;  :arith-pivots            612
;  :conflicts               384
;  :datatype-accessor-ax    39
;  :datatype-constructor-ax 277
;  :datatype-occurs-check   111
;  :datatype-splits         61
;  :decisions               574
;  :del-clause              3656
;  :final-checks            73
;  :interface-eqs           1
;  :max-generation          4
;  :max-memory              5.66
;  :memory                  5.63
;  :minimized-lits          14
;  :mk-bool-var             6418
;  :mk-clause               3656
;  :num-allocs              249711
;  :num-checks              154
;  :propagations            1467
;  :quant-instantiations    1640
;  :rlimit-count            393706)
; [then-branch: 101 | 0 < V@28@04 | live]
; [else-branch: 101 | !(0 < V@28@04) | dead]
(push) ; 4
; [then-branch: 101 | 0 < V@28@04]
(declare-const i1@101@04 Int)
(push) ; 5
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 6
; [then-branch: 102 | 0 <= i1@101@04 | live]
; [else-branch: 102 | !(0 <= i1@101@04) | live]
(push) ; 7
; [then-branch: 102 | 0 <= i1@101@04]
(assert (<= 0 i1@101@04))
; [eval] i1 < V
(pop) ; 7
(push) ; 7
; [else-branch: 102 | !(0 <= i1@101@04)]
(assert (not (<= 0 i1@101@04)))
(pop) ; 7
(pop) ; 6
; Joined path conditions
; Joined path conditions
(assert (and (< i1@101@04 V@28@04) (<= 0 i1@101@04)))
; [eval] scale(V * V * write) * wildcard
; [eval] scale(V * V * write)
; [eval] V * V * write
; [eval] V * V
(push) ; 6
; [eval] amount >= 0 * write
; [eval] 0 * write
(set-option :timeout 0)
(push) ; 7
(assert (not (>= (* (to_real (* V@28@04 V@28@04)) $Perm.Write) $Perm.No)))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               3679
;  :arith-add-rows          1329
;  :arith-assert-diseq      128
;  :arith-assert-lower      714
;  :arith-assert-upper      449
;  :arith-bound-prop        278
;  :arith-conflicts         101
;  :arith-eq-adapter        434
;  :arith-fixed-eqs         189
;  :arith-max-min           30
;  :arith-nonlinear-bounds  3
;  :arith-offset-eqs        231
;  :arith-pivots            613
;  :conflicts               385
;  :datatype-accessor-ax    39
;  :datatype-constructor-ax 281
;  :datatype-occurs-check   111
;  :datatype-splits         61
;  :decisions               578
;  :del-clause              3656
;  :final-checks            74
;  :interface-eqs           1
;  :max-generation          4
;  :max-memory              5.66
;  :memory                  5.62
;  :minimized-lits          14
;  :mk-bool-var             6421
;  :mk-clause               3656
;  :num-allocs              249897
;  :num-checks              155
;  :propagations            1467
;  :quant-instantiations    1640
;  :rlimit-count            394033)
(assert (>= (* (to_real (* V@28@04 V@28@04)) $Perm.Write) $Perm.No))
(pop) ; 6
; Joined path conditions
(assert (>= (* (to_real (* V@28@04 V@28@04)) $Perm.Write) $Perm.No))
(declare-const $k@102@04 $Perm)
(assert ($Perm.isReadVar $k@102@04 $Perm.Write))
; [eval] aloc(opt_get1(target), i1)
; [eval] opt_get1(target)
(push) ; 6
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 6
; Joined path conditions
(push) ; 6
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 7
(assert (not (< i1@101@04 (alen<Int> (opt_get1 $Snap.unit target@27@04)))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               3679
;  :arith-add-rows          1329
;  :arith-assert-diseq      129
;  :arith-assert-lower      717
;  :arith-assert-upper      450
;  :arith-bound-prop        278
;  :arith-conflicts         101
;  :arith-eq-adapter        435
;  :arith-fixed-eqs         189
;  :arith-max-min           30
;  :arith-nonlinear-bounds  3
;  :arith-offset-eqs        231
;  :arith-pivots            613
;  :conflicts               385
;  :datatype-accessor-ax    39
;  :datatype-constructor-ax 281
;  :datatype-occurs-check   111
;  :datatype-splits         61
;  :decisions               578
;  :del-clause              3656
;  :final-checks            74
;  :interface-eqs           1
;  :max-generation          4
;  :max-memory              5.66
;  :memory                  5.62
;  :minimized-lits          14
;  :mk-bool-var             6426
;  :mk-clause               3658
;  :num-allocs              250098
;  :num-checks              156
;  :propagations            1468
;  :quant-instantiations    1640
;  :rlimit-count            394280)
(assert (< i1@101@04 (alen<Int> (opt_get1 $Snap.unit target@27@04))))
(pop) ; 6
; Joined path conditions
(assert (< i1@101@04 (alen<Int> (opt_get1 $Snap.unit target@27@04))))
(pop) ; 5
(declare-fun inv@103@04 ($Ref) Int)
; Nested auxiliary terms: globals
(assert ($Perm.isReadVar $k@102@04 $Perm.Write))
; Nested auxiliary terms: non-globals
(assert (forall ((i1@101@04 Int)) (!
  (and
    (>= (* (to_real (* V@28@04 V@28@04)) $Perm.Write) $Perm.No)
    (< i1@101@04 (alen<Int> (opt_get1 $Snap.unit target@27@04))))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@101@04))
  :qid |option$array$-aux|)))
(push) ; 5
(assert (not (forall ((i1@101@04 Int)) (!
  (implies
    (and (< i1@101@04 V@28@04) (<= 0 i1@101@04))
    (or
      (=
        (*
          (scale $Snap.unit (* (to_real (* V@28@04 V@28@04)) $Perm.Write))
          $k@102@04)
        $Perm.No)
      (<
        $Perm.No
        (*
          (scale $Snap.unit (* (to_real (* V@28@04 V@28@04)) $Perm.Write))
          $k@102@04))))
  
  ))))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               3693
;  :arith-add-rows          1329
;  :arith-assert-diseq      131
;  :arith-assert-lower      731
;  :arith-assert-upper      457
;  :arith-bound-prop        278
;  :arith-conflicts         103
;  :arith-eq-adapter        438
;  :arith-fixed-eqs         189
;  :arith-max-min           46
;  :arith-nonlinear-bounds  5
;  :arith-offset-eqs        232
;  :arith-pivots            616
;  :conflicts               391
;  :datatype-accessor-ax    39
;  :datatype-constructor-ax 285
;  :datatype-occurs-check   112
;  :datatype-splits         61
;  :decisions               583
;  :del-clause              3666
;  :final-checks            76
;  :interface-eqs           1
;  :max-generation          4
;  :max-memory              5.66
;  :memory                  5.62
;  :minimized-lits          14
;  :mk-bool-var             6442
;  :mk-clause               3668
;  :num-allocs              250693
;  :num-checks              157
;  :propagations            1473
;  :quant-instantiations    1643
;  :rlimit-count            395235)
(declare-const sm@104@04 $FVF<option<array>>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (ite
          (and (< (inv@34@04 r) V@28@04) (<= 0 (inv@34@04 r)))
          $k@33@04
          $Perm.No)
        (pTaken@96@04 r)))
    (=
      ($FVF.lookup_option$array$ (as sm@104@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@31@04))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@104@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@31@04))))) r))
  :qid |qp.fvfValDef26|)))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (ite
          (and (< (inv@42@04 r) V@28@04) (<= 0 (inv@42@04 r)))
          $k@41@04
          $Perm.No)
        (pTaken@95@04 r)))
    (=
      ($FVF.lookup_option$array$ (as sm@104@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@31@04))))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@104@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@31@04))))))))))) r))
  :qid |qp.fvfValDef27|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@31@04))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@31@04))))))))))) r) r))
  :pattern (($FVF.lookup_option$array$ (as sm@104@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef28|)))
; Check receiver injectivity
(push) ; 5
(assert (not (forall ((i11@101@04 Int) (i12@101@04 Int)) (!
  (implies
    (and
      (and
        (and
          (and (< i11@101@04 V@28@04) (<= 0 i11@101@04))
          ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@104@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@27@04) i11@101@04)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@27@04) i11@101@04)))
        (<
          $Perm.No
          (*
            (scale $Snap.unit (* (to_real (* V@28@04 V@28@04)) $Perm.Write))
            $k@102@04)))
      (and
        (and
          (and (< i12@101@04 V@28@04) (<= 0 i12@101@04))
          ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@104@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@27@04) i12@101@04)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@27@04) i12@101@04)))
        (<
          $Perm.No
          (*
            (scale $Snap.unit (* (to_real (* V@28@04 V@28@04)) $Perm.Write))
            $k@102@04)))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i11@101@04)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i12@101@04)))
    (= i11@101@04 i12@101@04))
  
  :qid |option$array$-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               3704
;  :arith-add-rows          1333
;  :arith-assert-diseq      132
;  :arith-assert-lower      736
;  :arith-assert-upper      457
;  :arith-bound-prop        278
;  :arith-conflicts         103
;  :arith-eq-adapter        440
;  :arith-fixed-eqs         189
;  :arith-max-min           46
;  :arith-nonlinear-bounds  5
;  :arith-offset-eqs        232
;  :arith-pivots            618
;  :conflicts               392
;  :datatype-accessor-ax    39
;  :datatype-constructor-ax 285
;  :datatype-occurs-check   112
;  :datatype-splits         61
;  :decisions               583
;  :del-clause              3707
;  :final-checks            76
;  :interface-eqs           1
;  :max-generation          4
;  :max-memory              5.66
;  :memory                  5.62
;  :minimized-lits          14
;  :mk-bool-var             6503
;  :mk-clause               3709
;  :num-allocs              251873
;  :num-checks              158
;  :propagations            1479
;  :quant-instantiations    1659
;  :rlimit-count            398716)
; Definitional axioms for inverse functions
(assert (forall ((i1@101@04 Int)) (!
  (implies
    (and
      (and (< i1@101@04 V@28@04) (<= 0 i1@101@04))
      (<
        $Perm.No
        (*
          (scale $Snap.unit (* (to_real (* V@28@04 V@28@04)) $Perm.Write))
          $k@102@04)))
    (=
      (inv@103@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@101@04))
      i1@101@04))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@101@04))
  :qid |option$array$-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and (< (inv@103@04 r) V@28@04) (<= 0 (inv@103@04 r)))
      (<
        $Perm.No
        (*
          (scale $Snap.unit (* (to_real (* V@28@04 V@28@04)) $Perm.Write))
          $k@102@04)))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) (inv@103@04 r))
      r))
  :pattern ((inv@103@04 r))
  :qid |option$array$-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@103@04 r) V@28@04) (<= 0 (inv@103@04 r)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@104@04  $FVF<option<array>>) r) r))
  :pattern ((inv@103@04 r))
  )))
; Precomputing data for removing quantified permissions
(define-fun pTaken@105@04 ((r $Ref)) $Perm
  (ite
    (and (< (inv@103@04 r) V@28@04) (<= 0 (inv@103@04 r)))
    ($Perm.min
      (-
        (ite
          (and (< (inv@34@04 r) V@28@04) (<= 0 (inv@34@04 r)))
          $k@33@04
          $Perm.No)
        (pTaken@96@04 r))
      (*
        (scale $Snap.unit (* (to_real (* V@28@04 V@28@04)) $Perm.Write))
        $k@102@04))
    $Perm.No))
(define-fun pTaken@106@04 ((r $Ref)) $Perm
  (ite
    (and (< (inv@103@04 r) V@28@04) (<= 0 (inv@103@04 r)))
    ($Perm.min
      (-
        (ite
          (and (< (inv@42@04 r) V@28@04) (<= 0 (inv@42@04 r)))
          $k@41@04
          $Perm.No)
        (pTaken@95@04 r))
      (-
        (*
          (scale $Snap.unit (* (to_real (* V@28@04 V@28@04)) $Perm.Write))
          $k@102@04)
        (pTaken@105@04 r)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Constrain original permissions scale(_, V@28@04 * V@28@04 * W) * $k@102@04
(assert (forall ((r $Ref)) (!
  (implies
    (not
      (=
        (-
          (ite
            (and (< (inv@34@04 r) V@28@04) (<= 0 (inv@34@04 r)))
            $k@33@04
            $Perm.No)
          (pTaken@96@04 r))
        $Perm.No))
    (<
      (ite
        (and (< (inv@103@04 r) V@28@04) (<= 0 (inv@103@04 r)))
        (*
          (scale $Snap.unit (* (to_real (* V@28@04 V@28@04)) $Perm.Write))
          $k@102@04)
        $Perm.No)
      (-
        (ite
          (and (< (inv@34@04 r) V@28@04) (<= 0 (inv@34@04 r)))
          $k@33@04
          $Perm.No)
        (pTaken@96@04 r))))
  :pattern ((inv@34@04 r))
  :pattern ((inv@103@04 r))
  :qid |qp.srp29|)))
; Intermediate check if already taken enough permissions
(set-option :timeout 500)
(push) ; 5
(assert (not (forall ((r $Ref)) (!
  (implies
    (and (< (inv@103@04 r) V@28@04) (<= 0 (inv@103@04 r)))
    (=
      (-
        (*
          (scale $Snap.unit (* (to_real (* V@28@04 V@28@04)) $Perm.Write))
          $k@102@04)
        (pTaken@105@04 r))
      $Perm.No))
  
  ))))
(check-sat)
; unknown
(pop) ; 5
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               3941
;  :arith-add-rows          1480
;  :arith-assert-diseq      150
;  :arith-assert-lower      819
;  :arith-assert-upper      505
;  :arith-bound-prop        305
;  :arith-conflicts         111
;  :arith-eq-adapter        486
;  :arith-fixed-eqs         212
;  :arith-max-min           71
;  :arith-nonlinear-bounds  9
;  :arith-offset-eqs        256
;  :arith-pivots            670
;  :conflicts               404
;  :datatype-accessor-ax    39
;  :datatype-constructor-ax 293
;  :datatype-occurs-check   116
;  :datatype-splits         61
;  :decisions               614
;  :del-clause              3934
;  :final-checks            81
;  :interface-eqs           2
;  :max-generation          4
;  :max-memory              5.69
;  :memory                  5.66
;  :minimized-lits          18
;  :mk-bool-var             6819
;  :mk-clause               3936
;  :num-allocs              256142
;  :num-checks              160
;  :propagations            1625
;  :quant-instantiations    1748
;  :rlimit-count            410859
;  :time                    0.01)
; Constrain original permissions scale(_, V@28@04 * V@28@04 * W) * $k@102@04
(assert (forall ((r $Ref)) (!
  (implies
    (not
      (=
        (-
          (ite
            (and (< (inv@42@04 r) V@28@04) (<= 0 (inv@42@04 r)))
            $k@41@04
            $Perm.No)
          (pTaken@95@04 r))
        $Perm.No))
    (<
      (ite
        (and (< (inv@103@04 r) V@28@04) (<= 0 (inv@103@04 r)))
        (*
          (scale $Snap.unit (* (to_real (* V@28@04 V@28@04)) $Perm.Write))
          $k@102@04)
        $Perm.No)
      (-
        (ite
          (and (< (inv@42@04 r) V@28@04) (<= 0 (inv@42@04 r)))
          $k@41@04
          $Perm.No)
        (pTaken@95@04 r))))
  :pattern ((inv@42@04 r))
  :pattern ((inv@103@04 r))
  :qid |qp.srp30|)))
; Intermediate check if already taken enough permissions
(push) ; 5
(assert (not (forall ((r $Ref)) (!
  (implies
    (and (< (inv@103@04 r) V@28@04) (<= 0 (inv@103@04 r)))
    (=
      (-
        (-
          (*
            (scale $Snap.unit (* (to_real (* V@28@04 V@28@04)) $Perm.Write))
            $k@102@04)
          (pTaken@105@04 r))
        (pTaken@106@04 r))
      $Perm.No))
  
  ))))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               4095
;  :arith-add-rows          1731
;  :arith-assert-diseq      164
;  :arith-assert-lower      873
;  :arith-assert-upper      544
;  :arith-bound-prop        325
;  :arith-conflicts         119
;  :arith-eq-adapter        538
;  :arith-fixed-eqs         231
;  :arith-max-min           71
;  :arith-nonlinear-bounds  9
;  :arith-offset-eqs        270
;  :arith-pivots            717
;  :conflicts               423
;  :datatype-accessor-ax    39
;  :datatype-constructor-ax 297
;  :datatype-occurs-check   116
;  :datatype-splits         61
;  :decisions               634
;  :del-clause              4175
;  :final-checks            81
;  :interface-eqs           2
;  :max-generation          4
;  :max-memory              5.69
;  :memory                  5.66
;  :minimized-lits          22
;  :mk-bool-var             7126
;  :mk-clause               4177
;  :num-allocs              258066
;  :num-checks              161
;  :propagations            1727
;  :quant-instantiations    1792
;  :rlimit-count            419021
;  :time                    0.00)
; Final check if taken enough permissions
; Done removing quantified permissions
; Definitional axioms for snapshot map values
; [eval] 0 < V ==> (forall i1: Int :: { aloc(opt_get1(target), i1) } 0 <= i1 && i1 < V ==> aloc(opt_get1(target), i1).option$array$ != (None(): option[array]))
; [eval] 0 < V
(push) ; 5
(set-option :timeout 10)
(push) ; 6
(assert (not (not (< 0 V@28@04))))
(check-sat)
; unknown
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               4106
;  :arith-add-rows          1731
;  :arith-assert-diseq      164
;  :arith-assert-lower      873
;  :arith-assert-upper      544
;  :arith-bound-prop        325
;  :arith-conflicts         119
;  :arith-eq-adapter        538
;  :arith-fixed-eqs         231
;  :arith-max-min           71
;  :arith-nonlinear-bounds  9
;  :arith-offset-eqs        270
;  :arith-pivots            717
;  :conflicts               423
;  :datatype-accessor-ax    39
;  :datatype-constructor-ax 301
;  :datatype-occurs-check   117
;  :datatype-splits         61
;  :decisions               638
;  :del-clause              4175
;  :final-checks            82
;  :interface-eqs           2
;  :max-generation          4
;  :max-memory              5.69
;  :memory                  5.66
;  :minimized-lits          22
;  :mk-bool-var             7126
;  :mk-clause               4177
;  :num-allocs              258620
;  :num-checks              162
;  :propagations            1727
;  :quant-instantiations    1792
;  :rlimit-count            419623)
; [then-branch: 103 | 0 < V@28@04 | live]
; [else-branch: 103 | !(0 < V@28@04) | dead]
(push) ; 6
; [then-branch: 103 | 0 < V@28@04]
; [eval] (forall i1: Int :: { aloc(opt_get1(target), i1) } 0 <= i1 && i1 < V ==> aloc(opt_get1(target), i1).option$array$ != (None(): option[array]))
(declare-const i1@107@04 Int)
(push) ; 7
; [eval] 0 <= i1 && i1 < V ==> aloc(opt_get1(target), i1).option$array$ != (None(): option[array])
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 8
; [then-branch: 104 | 0 <= i1@107@04 | live]
; [else-branch: 104 | !(0 <= i1@107@04) | live]
(push) ; 9
; [then-branch: 104 | 0 <= i1@107@04]
(assert (<= 0 i1@107@04))
; [eval] i1 < V
(pop) ; 9
(push) ; 9
; [else-branch: 104 | !(0 <= i1@107@04)]
(assert (not (<= 0 i1@107@04)))
(pop) ; 9
(pop) ; 8
; Joined path conditions
; Joined path conditions
(push) ; 8
; [then-branch: 105 | i1@107@04 < V@28@04 && 0 <= i1@107@04 | live]
; [else-branch: 105 | !(i1@107@04 < V@28@04 && 0 <= i1@107@04) | live]
(push) ; 9
; [then-branch: 105 | i1@107@04 < V@28@04 && 0 <= i1@107@04]
(assert (and (< i1@107@04 V@28@04) (<= 0 i1@107@04)))
; [eval] aloc(opt_get1(target), i1).option$array$ != (None(): option[array])
; [eval] aloc(opt_get1(target), i1)
; [eval] opt_get1(target)
(push) ; 10
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 10
; Joined path conditions
(push) ; 10
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 11
(assert (not (< i1@107@04 (alen<Int> (opt_get1 $Snap.unit target@27@04)))))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               4106
;  :arith-add-rows          1731
;  :arith-assert-diseq      164
;  :arith-assert-lower      875
;  :arith-assert-upper      544
;  :arith-bound-prop        325
;  :arith-conflicts         119
;  :arith-eq-adapter        538
;  :arith-fixed-eqs         231
;  :arith-max-min           71
;  :arith-nonlinear-bounds  9
;  :arith-offset-eqs        270
;  :arith-pivots            717
;  :conflicts               423
;  :datatype-accessor-ax    39
;  :datatype-constructor-ax 301
;  :datatype-occurs-check   117
;  :datatype-splits         61
;  :decisions               638
;  :del-clause              4175
;  :final-checks            82
;  :interface-eqs           2
;  :max-generation          4
;  :max-memory              5.69
;  :memory                  5.66
;  :minimized-lits          22
;  :mk-bool-var             7128
;  :mk-clause               4177
;  :num-allocs              258724
;  :num-checks              163
;  :propagations            1727
;  :quant-instantiations    1792
;  :rlimit-count            419818)
(assert (< i1@107@04 (alen<Int> (opt_get1 $Snap.unit target@27@04))))
(pop) ; 10
; Joined path conditions
(assert (< i1@107@04 (alen<Int> (opt_get1 $Snap.unit target@27@04))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@107@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@107@04)))
(push) ; 10
(assert (not (<
  $Perm.No
  (+
    (ite
      (and
        (<
          (inv@42@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@107@04))
          V@28@04)
        (<=
          0
          (inv@42@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@107@04))))
      $k@41@04
      $Perm.No)
    (ite
      (and
        (<
          (inv@34@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@107@04))
          V@28@04)
        (<=
          0
          (inv@34@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@107@04))))
      $k@33@04
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               4209
;  :arith-add-rows          1793
;  :arith-assert-diseq      168
;  :arith-assert-lower      909
;  :arith-assert-upper      564
;  :arith-bound-prop        336
;  :arith-conflicts         122
;  :arith-eq-adapter        559
;  :arith-fixed-eqs         241
;  :arith-max-min           71
;  :arith-nonlinear-bounds  9
;  :arith-offset-eqs        278
;  :arith-pivots            736
;  :conflicts               433
;  :datatype-accessor-ax    39
;  :datatype-constructor-ax 305
;  :datatype-occurs-check   117
;  :datatype-splits         61
;  :decisions               651
;  :del-clause              4244
;  :final-checks            82
;  :interface-eqs           2
;  :max-generation          4
;  :max-memory              5.69
;  :memory                  5.66
;  :minimized-lits          22
;  :mk-bool-var             7324
;  :mk-clause               4309
;  :num-allocs              259750
;  :num-checks              164
;  :propagations            1794
;  :quant-instantiations    1835
;  :rlimit-count            423292
;  :time                    0.00)
; [eval] (None(): option[array])
(pop) ; 9
(push) ; 9
; [else-branch: 105 | !(i1@107@04 < V@28@04 && 0 <= i1@107@04)]
(assert (not (and (< i1@107@04 V@28@04) (<= 0 i1@107@04))))
(pop) ; 9
(pop) ; 8
; Joined path conditions
(assert (implies
  (and (< i1@107@04 V@28@04) (<= 0 i1@107@04))
  (and
    (< i1@107@04 V@28@04)
    (<= 0 i1@107@04)
    (< i1@107@04 (alen<Int> (opt_get1 $Snap.unit target@27@04)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@107@04)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@107@04)))))
; Joined path conditions
(pop) ; 7
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@107@04 Int)) (!
  (implies
    (and (< i1@107@04 V@28@04) (<= 0 i1@107@04))
    (and
      (< i1@107@04 V@28@04)
      (<= 0 i1@107@04)
      (< i1@107@04 (alen<Int> (opt_get1 $Snap.unit target@27@04)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@107@04)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@107@04))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@107@04))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 6
(pop) ; 5
; Joined path conditions
(assert (implies
  (< 0 V@28@04)
  (forall ((i1@107@04 Int)) (!
    (implies
      (and (< i1@107@04 V@28@04) (<= 0 i1@107@04))
      (and
        (< i1@107@04 V@28@04)
        (<= 0 i1@107@04)
        (< i1@107@04 (alen<Int> (opt_get1 $Snap.unit target@27@04)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@107@04)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@107@04))))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@107@04))
    :qid |prog.l<no position>-aux|))))
(push) ; 5
(assert (not (implies
  (< 0 V@28@04)
  (forall ((i1@107@04 Int)) (!
    (implies
      (and (< i1@107@04 V@28@04) (<= 0 i1@107@04))
      (not
        (=
          ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@107@04))
          (as None<option<array>>  option<array>))))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@107@04))
    :qid |prog.l<no position>|)))))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               4212
;  :arith-add-rows          1803
;  :arith-assert-diseq      168
;  :arith-assert-lower      913
;  :arith-assert-upper      565
;  :arith-bound-prop        338
;  :arith-conflicts         122
;  :arith-eq-adapter        561
;  :arith-fixed-eqs         242
;  :arith-max-min           71
;  :arith-nonlinear-bounds  9
;  :arith-offset-eqs        281
;  :arith-pivots            747
;  :conflicts               434
;  :datatype-accessor-ax    39
;  :datatype-constructor-ax 305
;  :datatype-occurs-check   117
;  :datatype-splits         61
;  :decisions               651
;  :del-clause              4368
;  :final-checks            82
;  :interface-eqs           2
;  :max-generation          4
;  :max-memory              5.69
;  :memory                  5.65
;  :minimized-lits          22
;  :mk-bool-var             7395
;  :mk-clause               4370
;  :num-allocs              260517
;  :num-checks              165
;  :propagations            1799
;  :quant-instantiations    1860
;  :rlimit-count            425238)
(assert (implies
  (< 0 V@28@04)
  (forall ((i1@107@04 Int)) (!
    (implies
      (and (< i1@107@04 V@28@04) (<= 0 i1@107@04))
      (not
        (=
          ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@107@04))
          (as None<option<array>>  option<array>))))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@107@04))
    :qid |prog.l<no position>|))))
; [eval] 0 < V ==> (forall i1: Int :: { alen(opt_get1(aloc(opt_get1(target), i1).option$array$)) } 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(target), i1).option$array$)) == V)
; [eval] 0 < V
(push) ; 5
(set-option :timeout 10)
(push) ; 6
(assert (not (not (< 0 V@28@04))))
(check-sat)
; unknown
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               4223
;  :arith-add-rows          1803
;  :arith-assert-diseq      168
;  :arith-assert-lower      913
;  :arith-assert-upper      565
;  :arith-bound-prop        338
;  :arith-conflicts         122
;  :arith-eq-adapter        561
;  :arith-fixed-eqs         242
;  :arith-max-min           71
;  :arith-nonlinear-bounds  9
;  :arith-offset-eqs        281
;  :arith-pivots            747
;  :conflicts               434
;  :datatype-accessor-ax    39
;  :datatype-constructor-ax 309
;  :datatype-occurs-check   118
;  :datatype-splits         61
;  :decisions               655
;  :del-clause              4368
;  :final-checks            83
;  :interface-eqs           2
;  :max-generation          4
;  :max-memory              5.69
;  :memory                  5.66
;  :minimized-lits          22
;  :mk-bool-var             7396
;  :mk-clause               4370
;  :num-allocs              261266
;  :num-checks              166
;  :propagations            1799
;  :quant-instantiations    1860
;  :rlimit-count            426157)
; [then-branch: 106 | 0 < V@28@04 | live]
; [else-branch: 106 | !(0 < V@28@04) | dead]
(push) ; 6
; [then-branch: 106 | 0 < V@28@04]
; [eval] (forall i1: Int :: { alen(opt_get1(aloc(opt_get1(target), i1).option$array$)) } 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(target), i1).option$array$)) == V)
(declare-const i1@108@04 Int)
(push) ; 7
; [eval] 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(target), i1).option$array$)) == V
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 8
; [then-branch: 107 | 0 <= i1@108@04 | live]
; [else-branch: 107 | !(0 <= i1@108@04) | live]
(push) ; 9
; [then-branch: 107 | 0 <= i1@108@04]
(assert (<= 0 i1@108@04))
; [eval] i1 < V
(pop) ; 9
(push) ; 9
; [else-branch: 107 | !(0 <= i1@108@04)]
(assert (not (<= 0 i1@108@04)))
(pop) ; 9
(pop) ; 8
; Joined path conditions
; Joined path conditions
(push) ; 8
; [then-branch: 108 | i1@108@04 < V@28@04 && 0 <= i1@108@04 | live]
; [else-branch: 108 | !(i1@108@04 < V@28@04 && 0 <= i1@108@04) | live]
(push) ; 9
; [then-branch: 108 | i1@108@04 < V@28@04 && 0 <= i1@108@04]
(assert (and (< i1@108@04 V@28@04) (<= 0 i1@108@04)))
; [eval] alen(opt_get1(aloc(opt_get1(target), i1).option$array$)) == V
; [eval] alen(opt_get1(aloc(opt_get1(target), i1).option$array$))
; [eval] opt_get1(aloc(opt_get1(target), i1).option$array$)
; [eval] aloc(opt_get1(target), i1)
; [eval] opt_get1(target)
(push) ; 10
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 10
; Joined path conditions
(push) ; 10
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 11
(assert (not (< i1@108@04 (alen<Int> (opt_get1 $Snap.unit target@27@04)))))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               4223
;  :arith-add-rows          1803
;  :arith-assert-diseq      168
;  :arith-assert-lower      915
;  :arith-assert-upper      565
;  :arith-bound-prop        338
;  :arith-conflicts         122
;  :arith-eq-adapter        561
;  :arith-fixed-eqs         242
;  :arith-max-min           71
;  :arith-nonlinear-bounds  9
;  :arith-offset-eqs        281
;  :arith-pivots            747
;  :conflicts               434
;  :datatype-accessor-ax    39
;  :datatype-constructor-ax 309
;  :datatype-occurs-check   118
;  :datatype-splits         61
;  :decisions               655
;  :del-clause              4368
;  :final-checks            83
;  :interface-eqs           2
;  :max-generation          4
;  :max-memory              5.69
;  :memory                  5.66
;  :minimized-lits          22
;  :mk-bool-var             7398
;  :mk-clause               4370
;  :num-allocs              261371
;  :num-checks              167
;  :propagations            1799
;  :quant-instantiations    1860
;  :rlimit-count            426352)
(assert (< i1@108@04 (alen<Int> (opt_get1 $Snap.unit target@27@04))))
(pop) ; 10
; Joined path conditions
(assert (< i1@108@04 (alen<Int> (opt_get1 $Snap.unit target@27@04))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@108@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@108@04)))
(push) ; 10
(assert (not (<
  $Perm.No
  (+
    (ite
      (and
        (<
          (inv@42@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@108@04))
          V@28@04)
        (<=
          0
          (inv@42@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@108@04))))
      $k@41@04
      $Perm.No)
    (ite
      (and
        (<
          (inv@34@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@108@04))
          V@28@04)
        (<=
          0
          (inv@34@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@108@04))))
      $k@33@04
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               4307
;  :arith-add-rows          1842
;  :arith-assert-diseq      172
;  :arith-assert-lower      939
;  :arith-assert-upper      581
;  :arith-bound-prop        345
;  :arith-conflicts         125
;  :arith-eq-adapter        579
;  :arith-fixed-eqs         249
;  :arith-max-min           71
;  :arith-nonlinear-bounds  9
;  :arith-offset-eqs        288
;  :arith-pivots            765
;  :conflicts               449
;  :datatype-accessor-ax    39
;  :datatype-constructor-ax 313
;  :datatype-occurs-check   118
;  :datatype-splits         61
;  :decisions               671
;  :del-clause              4420
;  :final-checks            83
;  :interface-eqs           2
;  :max-generation          4
;  :max-memory              5.69
;  :memory                  5.66
;  :minimized-lits          22
;  :mk-bool-var             7590
;  :mk-clause               4485
;  :num-allocs              262327
;  :num-checks              168
;  :propagations            1841
;  :quant-instantiations    1898
;  :rlimit-count            429531
;  :time                    0.00)
(push) ; 10
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 11
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@108@04))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               4307
;  :arith-add-rows          1842
;  :arith-assert-diseq      172
;  :arith-assert-lower      939
;  :arith-assert-upper      581
;  :arith-bound-prop        345
;  :arith-conflicts         125
;  :arith-eq-adapter        579
;  :arith-fixed-eqs         249
;  :arith-max-min           71
;  :arith-nonlinear-bounds  9
;  :arith-offset-eqs        288
;  :arith-pivots            765
;  :conflicts               450
;  :datatype-accessor-ax    39
;  :datatype-constructor-ax 313
;  :datatype-occurs-check   118
;  :datatype-splits         61
;  :decisions               671
;  :del-clause              4420
;  :final-checks            83
;  :interface-eqs           2
;  :max-generation          4
;  :max-memory              5.69
;  :memory                  5.66
;  :minimized-lits          22
;  :mk-bool-var             7590
;  :mk-clause               4485
;  :num-allocs              262422
;  :num-checks              169
;  :propagations            1841
;  :quant-instantiations    1898
;  :rlimit-count            429626)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@108@04))
    (as None<option<array>>  option<array>))))
(pop) ; 10
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@108@04))
    (as None<option<array>>  option<array>))))
(pop) ; 9
(push) ; 9
; [else-branch: 108 | !(i1@108@04 < V@28@04 && 0 <= i1@108@04)]
(assert (not (and (< i1@108@04 V@28@04) (<= 0 i1@108@04))))
(pop) ; 9
(pop) ; 8
; Joined path conditions
(assert (implies
  (and (< i1@108@04 V@28@04) (<= 0 i1@108@04))
  (and
    (< i1@108@04 V@28@04)
    (<= 0 i1@108@04)
    (< i1@108@04 (alen<Int> (opt_get1 $Snap.unit target@27@04)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@108@04)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@108@04))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@108@04))
        (as None<option<array>>  option<array>))))))
; Joined path conditions
(pop) ; 7
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@108@04 Int)) (!
  (implies
    (and (< i1@108@04 V@28@04) (<= 0 i1@108@04))
    (and
      (< i1@108@04 V@28@04)
      (<= 0 i1@108@04)
      (< i1@108@04 (alen<Int> (opt_get1 $Snap.unit target@27@04)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@108@04)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@108@04))
      (not
        (=
          ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@108@04))
          (as None<option<array>>  option<array>)))))
  :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@108@04)))))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 6
(pop) ; 5
; Joined path conditions
(assert (implies
  (< 0 V@28@04)
  (forall ((i1@108@04 Int)) (!
    (implies
      (and (< i1@108@04 V@28@04) (<= 0 i1@108@04))
      (and
        (< i1@108@04 V@28@04)
        (<= 0 i1@108@04)
        (< i1@108@04 (alen<Int> (opt_get1 $Snap.unit target@27@04)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@108@04)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@108@04))
        (not
          (=
            ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@108@04))
            (as None<option<array>>  option<array>)))))
    :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@108@04)))))
    :qid |prog.l<no position>-aux|))))
(push) ; 5
(assert (not (implies
  (< 0 V@28@04)
  (forall ((i1@108@04 Int)) (!
    (implies
      (and (< i1@108@04 V@28@04) (<= 0 i1@108@04))
      (=
        (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@108@04))))
        V@28@04))
    :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@108@04)))))
    :qid |prog.l<no position>|)))))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               4307
;  :arith-add-rows          1847
;  :arith-assert-diseq      172
;  :arith-assert-lower      941
;  :arith-assert-upper      581
;  :arith-bound-prop        345
;  :arith-conflicts         125
;  :arith-eq-adapter        580
;  :arith-fixed-eqs         249
;  :arith-max-min           71
;  :arith-nonlinear-bounds  9
;  :arith-offset-eqs        288
;  :arith-pivots            771
;  :conflicts               451
;  :datatype-accessor-ax    39
;  :datatype-constructor-ax 313
;  :datatype-occurs-check   118
;  :datatype-splits         61
;  :decisions               671
;  :del-clause              4500
;  :final-checks            83
;  :interface-eqs           2
;  :max-generation          4
;  :max-memory              5.69
;  :memory                  5.65
;  :minimized-lits          22
;  :mk-bool-var             7621
;  :mk-clause               4502
;  :num-allocs              263006
;  :num-checks              170
;  :propagations            1841
;  :quant-instantiations    1914
;  :rlimit-count            430916)
(assert (implies
  (< 0 V@28@04)
  (forall ((i1@108@04 Int)) (!
    (implies
      (and (< i1@108@04 V@28@04) (<= 0 i1@108@04))
      (=
        (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@108@04))))
        V@28@04))
    :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@108@04)))))
    :qid |prog.l<no position>|))))
; [eval] 0 < V ==> (forall i1: Int :: { aloc(opt_get1(target), i1) } (forall i2: Int :: { aloc(opt_get1(target), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(target), i1).option$array$ == aloc(opt_get1(target), i2).option$array$ ==> i1 == i2))
; [eval] 0 < V
(push) ; 5
(set-option :timeout 10)
(push) ; 6
(assert (not (not (< 0 V@28@04))))
(check-sat)
; unknown
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               4318
;  :arith-add-rows          1847
;  :arith-assert-diseq      172
;  :arith-assert-lower      941
;  :arith-assert-upper      581
;  :arith-bound-prop        345
;  :arith-conflicts         125
;  :arith-eq-adapter        580
;  :arith-fixed-eqs         249
;  :arith-max-min           71
;  :arith-nonlinear-bounds  9
;  :arith-offset-eqs        288
;  :arith-pivots            771
;  :conflicts               451
;  :datatype-accessor-ax    39
;  :datatype-constructor-ax 317
;  :datatype-occurs-check   119
;  :datatype-splits         61
;  :decisions               675
;  :del-clause              4500
;  :final-checks            84
;  :interface-eqs           2
;  :max-generation          4
;  :max-memory              5.69
;  :memory                  5.66
;  :minimized-lits          22
;  :mk-bool-var             7622
;  :mk-clause               4502
;  :num-allocs              263748
;  :num-checks              171
;  :propagations            1841
;  :quant-instantiations    1914
;  :rlimit-count            431837)
; [then-branch: 109 | 0 < V@28@04 | live]
; [else-branch: 109 | !(0 < V@28@04) | dead]
(push) ; 6
; [then-branch: 109 | 0 < V@28@04]
; [eval] (forall i1: Int :: { aloc(opt_get1(target), i1) } (forall i2: Int :: { aloc(opt_get1(target), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(target), i1).option$array$ == aloc(opt_get1(target), i2).option$array$ ==> i1 == i2))
(declare-const i1@109@04 Int)
(push) ; 7
; [eval] (forall i2: Int :: { aloc(opt_get1(target), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(target), i1).option$array$ == aloc(opt_get1(target), i2).option$array$ ==> i1 == i2)
(declare-const i2@110@04 Int)
(push) ; 8
; [eval] 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(target), i1).option$array$ == aloc(opt_get1(target), i2).option$array$ ==> i1 == i2
; [eval] 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(target), i1).option$array$ == aloc(opt_get1(target), i2).option$array$
; [eval] 0 <= i1
(push) ; 9
; [then-branch: 110 | 0 <= i1@109@04 | live]
; [else-branch: 110 | !(0 <= i1@109@04) | live]
(push) ; 10
; [then-branch: 110 | 0 <= i1@109@04]
(assert (<= 0 i1@109@04))
; [eval] i1 < V
(push) ; 11
; [then-branch: 111 | i1@109@04 < V@28@04 | live]
; [else-branch: 111 | !(i1@109@04 < V@28@04) | live]
(push) ; 12
; [then-branch: 111 | i1@109@04 < V@28@04]
(assert (< i1@109@04 V@28@04))
; [eval] 0 <= i2
(push) ; 13
; [then-branch: 112 | 0 <= i2@110@04 | live]
; [else-branch: 112 | !(0 <= i2@110@04) | live]
(push) ; 14
; [then-branch: 112 | 0 <= i2@110@04]
(assert (<= 0 i2@110@04))
; [eval] i2 < V
(push) ; 15
; [then-branch: 113 | i2@110@04 < V@28@04 | live]
; [else-branch: 113 | !(i2@110@04 < V@28@04) | live]
(push) ; 16
; [then-branch: 113 | i2@110@04 < V@28@04]
(assert (< i2@110@04 V@28@04))
; [eval] aloc(opt_get1(target), i1).option$array$ == aloc(opt_get1(target), i2).option$array$
; [eval] aloc(opt_get1(target), i1)
; [eval] opt_get1(target)
(push) ; 17
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 17
; Joined path conditions
(push) ; 17
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 18
(assert (not (< i1@109@04 (alen<Int> (opt_get1 $Snap.unit target@27@04)))))
(check-sat)
; unsat
(pop) ; 18
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               4318
;  :arith-add-rows          1847
;  :arith-assert-diseq      172
;  :arith-assert-lower      945
;  :arith-assert-upper      581
;  :arith-bound-prop        345
;  :arith-conflicts         125
;  :arith-eq-adapter        580
;  :arith-fixed-eqs         249
;  :arith-max-min           71
;  :arith-nonlinear-bounds  9
;  :arith-offset-eqs        288
;  :arith-pivots            773
;  :conflicts               451
;  :datatype-accessor-ax    39
;  :datatype-constructor-ax 317
;  :datatype-occurs-check   119
;  :datatype-splits         61
;  :decisions               675
;  :del-clause              4500
;  :final-checks            84
;  :interface-eqs           2
;  :max-generation          4
;  :max-memory              5.69
;  :memory                  5.66
;  :minimized-lits          22
;  :mk-bool-var             7626
;  :mk-clause               4502
;  :num-allocs              264029
;  :num-checks              172
;  :propagations            1841
;  :quant-instantiations    1914
;  :rlimit-count            432186)
(assert (< i1@109@04 (alen<Int> (opt_get1 $Snap.unit target@27@04))))
(pop) ; 17
; Joined path conditions
(assert (< i1@109@04 (alen<Int> (opt_get1 $Snap.unit target@27@04))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@109@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@109@04)))
(push) ; 17
(assert (not (<
  $Perm.No
  (+
    (ite
      (and
        (<
          (inv@42@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@109@04))
          V@28@04)
        (<=
          0
          (inv@42@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@109@04))))
      $k@41@04
      $Perm.No)
    (ite
      (and
        (<
          (inv@34@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@109@04))
          V@28@04)
        (<=
          0
          (inv@34@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@109@04))))
      $k@33@04
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               4413
;  :arith-add-rows          1895
;  :arith-assert-diseq      175
;  :arith-assert-lower      979
;  :arith-assert-upper      599
;  :arith-bound-prop        352
;  :arith-conflicts         128
;  :arith-eq-adapter        601
;  :arith-fixed-eqs         260
;  :arith-max-min           71
;  :arith-nonlinear-bounds  9
;  :arith-offset-eqs        296
;  :arith-pivots            790
;  :conflicts               460
;  :datatype-accessor-ax    39
;  :datatype-constructor-ax 321
;  :datatype-occurs-check   119
;  :datatype-splits         61
;  :decisions               691
;  :del-clause              4560
;  :final-checks            84
;  :interface-eqs           2
;  :max-generation          4
;  :max-memory              5.69
;  :memory                  5.67
;  :minimized-lits          22
;  :mk-bool-var             7802
;  :mk-clause               4625
;  :num-allocs              264998
;  :num-checks              173
;  :propagations            1890
;  :quant-instantiations    1957
;  :rlimit-count            435498
;  :time                    0.00)
; [eval] aloc(opt_get1(target), i2)
; [eval] opt_get1(target)
(push) ; 17
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 17
; Joined path conditions
(push) ; 17
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 18
(assert (not (< i2@110@04 (alen<Int> (opt_get1 $Snap.unit target@27@04)))))
(check-sat)
; unsat
(pop) ; 18
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               4413
;  :arith-add-rows          1895
;  :arith-assert-diseq      175
;  :arith-assert-lower      979
;  :arith-assert-upper      599
;  :arith-bound-prop        352
;  :arith-conflicts         128
;  :arith-eq-adapter        601
;  :arith-fixed-eqs         260
;  :arith-max-min           71
;  :arith-nonlinear-bounds  9
;  :arith-offset-eqs        296
;  :arith-pivots            790
;  :conflicts               460
;  :datatype-accessor-ax    39
;  :datatype-constructor-ax 321
;  :datatype-occurs-check   119
;  :datatype-splits         61
;  :decisions               691
;  :del-clause              4560
;  :final-checks            84
;  :interface-eqs           2
;  :max-generation          4
;  :max-memory              5.69
;  :memory                  5.67
;  :minimized-lits          22
;  :mk-bool-var             7802
;  :mk-clause               4625
;  :num-allocs              265025
;  :num-checks              174
;  :propagations            1890
;  :quant-instantiations    1957
;  :rlimit-count            435528)
(assert (< i2@110@04 (alen<Int> (opt_get1 $Snap.unit target@27@04))))
(pop) ; 17
; Joined path conditions
(assert (< i2@110@04 (alen<Int> (opt_get1 $Snap.unit target@27@04))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@110@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@110@04)))
(push) ; 17
(assert (not (<
  $Perm.No
  (+
    (ite
      (and
        (<
          (inv@42@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@110@04))
          V@28@04)
        (<=
          0
          (inv@42@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@110@04))))
      $k@41@04
      $Perm.No)
    (ite
      (and
        (<
          (inv@34@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@110@04))
          V@28@04)
        (<=
          0
          (inv@34@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@110@04))))
      $k@33@04
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               4523
;  :arith-add-rows          1999
;  :arith-assert-diseq      185
;  :arith-assert-lower      1025
;  :arith-assert-upper      623
;  :arith-bound-prop        367
;  :arith-conflicts         132
;  :arith-eq-adapter        630
;  :arith-fixed-eqs         272
;  :arith-max-min           71
;  :arith-nonlinear-bounds  9
;  :arith-offset-eqs        303
;  :arith-pivots            808
;  :conflicts               480
;  :datatype-accessor-ax    39
;  :datatype-constructor-ax 325
;  :datatype-occurs-check   119
;  :datatype-splits         61
;  :decisions               716
;  :del-clause              4656
;  :final-checks            84
;  :interface-eqs           2
;  :max-generation          4
;  :max-memory              5.71
;  :memory                  5.70
;  :minimized-lits          22
;  :mk-bool-var             8094
;  :mk-clause               4780
;  :num-allocs              266356
;  :num-checks              175
;  :propagations            1954
;  :quant-instantiations    2000
;  :rlimit-count            440068
;  :time                    0.00)
(pop) ; 16
(push) ; 16
; [else-branch: 113 | !(i2@110@04 < V@28@04)]
(assert (not (< i2@110@04 V@28@04)))
(pop) ; 16
(pop) ; 15
; Joined path conditions
(assert (implies
  (< i2@110@04 V@28@04)
  (and
    (< i2@110@04 V@28@04)
    (< i1@109@04 (alen<Int> (opt_get1 $Snap.unit target@27@04)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@109@04)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@109@04))
    (< i2@110@04 (alen<Int> (opt_get1 $Snap.unit target@27@04)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@110@04)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@110@04)))))
; Joined path conditions
(pop) ; 14
(push) ; 14
; [else-branch: 112 | !(0 <= i2@110@04)]
(assert (not (<= 0 i2@110@04)))
(pop) ; 14
(pop) ; 13
; Joined path conditions
(assert (implies
  (<= 0 i2@110@04)
  (and
    (<= 0 i2@110@04)
    (implies
      (< i2@110@04 V@28@04)
      (and
        (< i2@110@04 V@28@04)
        (< i1@109@04 (alen<Int> (opt_get1 $Snap.unit target@27@04)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@109@04)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@109@04))
        (< i2@110@04 (alen<Int> (opt_get1 $Snap.unit target@27@04)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@110@04)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@110@04)))))))
; Joined path conditions
(pop) ; 12
(push) ; 12
; [else-branch: 111 | !(i1@109@04 < V@28@04)]
(assert (not (< i1@109@04 V@28@04)))
(pop) ; 12
(pop) ; 11
; Joined path conditions
(assert (implies
  (< i1@109@04 V@28@04)
  (and
    (< i1@109@04 V@28@04)
    (implies
      (<= 0 i2@110@04)
      (and
        (<= 0 i2@110@04)
        (implies
          (< i2@110@04 V@28@04)
          (and
            (< i2@110@04 V@28@04)
            (< i1@109@04 (alen<Int> (opt_get1 $Snap.unit target@27@04)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@109@04)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@109@04))
            (< i2@110@04 (alen<Int> (opt_get1 $Snap.unit target@27@04)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@110@04)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@110@04)))))))))
; Joined path conditions
(pop) ; 10
(push) ; 10
; [else-branch: 110 | !(0 <= i1@109@04)]
(assert (not (<= 0 i1@109@04)))
(pop) ; 10
(pop) ; 9
; Joined path conditions
(assert (implies
  (<= 0 i1@109@04)
  (and
    (<= 0 i1@109@04)
    (implies
      (< i1@109@04 V@28@04)
      (and
        (< i1@109@04 V@28@04)
        (implies
          (<= 0 i2@110@04)
          (and
            (<= 0 i2@110@04)
            (implies
              (< i2@110@04 V@28@04)
              (and
                (< i2@110@04 V@28@04)
                (< i1@109@04 (alen<Int> (opt_get1 $Snap.unit target@27@04)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@109@04)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@109@04))
                (< i2@110@04 (alen<Int> (opt_get1 $Snap.unit target@27@04)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@110@04)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@110@04)))))))))))
; Joined path conditions
(push) ; 9
; [then-branch: 114 | Lookup(option$array$,sm@43@04,aloc((_, _), opt_get1(_, target@27@04), i1@109@04)) == Lookup(option$array$,sm@43@04,aloc((_, _), opt_get1(_, target@27@04), i2@110@04)) && i2@110@04 < V@28@04 && 0 <= i2@110@04 && i1@109@04 < V@28@04 && 0 <= i1@109@04 | live]
; [else-branch: 114 | !(Lookup(option$array$,sm@43@04,aloc((_, _), opt_get1(_, target@27@04), i1@109@04)) == Lookup(option$array$,sm@43@04,aloc((_, _), opt_get1(_, target@27@04), i2@110@04)) && i2@110@04 < V@28@04 && 0 <= i2@110@04 && i1@109@04 < V@28@04 && 0 <= i1@109@04) | live]
(push) ; 10
; [then-branch: 114 | Lookup(option$array$,sm@43@04,aloc((_, _), opt_get1(_, target@27@04), i1@109@04)) == Lookup(option$array$,sm@43@04,aloc((_, _), opt_get1(_, target@27@04), i2@110@04)) && i2@110@04 < V@28@04 && 0 <= i2@110@04 && i1@109@04 < V@28@04 && 0 <= i1@109@04]
(assert (and
  (and
    (and
      (and
        (=
          ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@109@04))
          ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@110@04)))
        (< i2@110@04 V@28@04))
      (<= 0 i2@110@04))
    (< i1@109@04 V@28@04))
  (<= 0 i1@109@04)))
; [eval] i1 == i2
(pop) ; 10
(push) ; 10
; [else-branch: 114 | !(Lookup(option$array$,sm@43@04,aloc((_, _), opt_get1(_, target@27@04), i1@109@04)) == Lookup(option$array$,sm@43@04,aloc((_, _), opt_get1(_, target@27@04), i2@110@04)) && i2@110@04 < V@28@04 && 0 <= i2@110@04 && i1@109@04 < V@28@04 && 0 <= i1@109@04)]
(assert (not
  (and
    (and
      (and
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@109@04))
            ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@110@04)))
          (< i2@110@04 V@28@04))
        (<= 0 i2@110@04))
      (< i1@109@04 V@28@04))
    (<= 0 i1@109@04))))
(pop) ; 10
(pop) ; 9
; Joined path conditions
(assert (implies
  (and
    (and
      (and
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@109@04))
            ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@110@04)))
          (< i2@110@04 V@28@04))
        (<= 0 i2@110@04))
      (< i1@109@04 V@28@04))
    (<= 0 i1@109@04))
  (and
    (=
      ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@109@04))
      ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@110@04)))
    (< i2@110@04 V@28@04)
    (<= 0 i2@110@04)
    (< i1@109@04 V@28@04)
    (<= 0 i1@109@04))))
; Joined path conditions
(pop) ; 8
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i2@110@04 Int)) (!
  (and
    (implies
      (<= 0 i1@109@04)
      (and
        (<= 0 i1@109@04)
        (implies
          (< i1@109@04 V@28@04)
          (and
            (< i1@109@04 V@28@04)
            (implies
              (<= 0 i2@110@04)
              (and
                (<= 0 i2@110@04)
                (implies
                  (< i2@110@04 V@28@04)
                  (and
                    (< i2@110@04 V@28@04)
                    (< i1@109@04 (alen<Int> (opt_get1 $Snap.unit target@27@04)))
                    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@109@04)) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@109@04))
                    (< i2@110@04 (alen<Int> (opt_get1 $Snap.unit target@27@04)))
                    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@110@04)) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@110@04))))))))))
    (implies
      (and
        (and
          (and
            (and
              (=
                ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@109@04))
                ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@110@04)))
              (< i2@110@04 V@28@04))
            (<= 0 i2@110@04))
          (< i1@109@04 V@28@04))
        (<= 0 i1@109@04))
      (and
        (=
          ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@109@04))
          ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@110@04)))
        (< i2@110@04 V@28@04)
        (<= 0 i2@110@04)
        (< i1@109@04 V@28@04)
        (<= 0 i1@109@04))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@110@04))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 7
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@109@04 Int)) (!
  (forall ((i2@110@04 Int)) (!
    (and
      (implies
        (<= 0 i1@109@04)
        (and
          (<= 0 i1@109@04)
          (implies
            (< i1@109@04 V@28@04)
            (and
              (< i1@109@04 V@28@04)
              (implies
                (<= 0 i2@110@04)
                (and
                  (<= 0 i2@110@04)
                  (implies
                    (< i2@110@04 V@28@04)
                    (and
                      (< i2@110@04 V@28@04)
                      (<
                        i1@109@04
                        (alen<Int> (opt_get1 $Snap.unit target@27@04)))
                      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@109@04)) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@109@04))
                      (<
                        i2@110@04
                        (alen<Int> (opt_get1 $Snap.unit target@27@04)))
                      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@110@04)) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@110@04))))))))))
      (implies
        (and
          (and
            (and
              (and
                (=
                  ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@109@04))
                  ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@110@04)))
                (< i2@110@04 V@28@04))
              (<= 0 i2@110@04))
            (< i1@109@04 V@28@04))
          (<= 0 i1@109@04))
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@109@04))
            ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@110@04)))
          (< i2@110@04 V@28@04)
          (<= 0 i2@110@04)
          (< i1@109@04 V@28@04)
          (<= 0 i1@109@04))))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@110@04))
    :qid |prog.l<no position>-aux|))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@109@04))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 6
(pop) ; 5
; Joined path conditions
(assert (implies
  (< 0 V@28@04)
  (forall ((i1@109@04 Int)) (!
    (forall ((i2@110@04 Int)) (!
      (and
        (implies
          (<= 0 i1@109@04)
          (and
            (<= 0 i1@109@04)
            (implies
              (< i1@109@04 V@28@04)
              (and
                (< i1@109@04 V@28@04)
                (implies
                  (<= 0 i2@110@04)
                  (and
                    (<= 0 i2@110@04)
                    (implies
                      (< i2@110@04 V@28@04)
                      (and
                        (< i2@110@04 V@28@04)
                        (<
                          i1@109@04
                          (alen<Int> (opt_get1 $Snap.unit target@27@04)))
                        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
                          $Snap.unit
                          $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@109@04)) (aloc ($Snap.combine
                          $Snap.unit
                          $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@109@04))
                        (<
                          i2@110@04
                          (alen<Int> (opt_get1 $Snap.unit target@27@04)))
                        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
                          $Snap.unit
                          $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@110@04)) (aloc ($Snap.combine
                          $Snap.unit
                          $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@110@04))))))))))
        (implies
          (and
            (and
              (and
                (and
                  (=
                    ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@109@04))
                    ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@110@04)))
                  (< i2@110@04 V@28@04))
                (<= 0 i2@110@04))
              (< i1@109@04 V@28@04))
            (<= 0 i1@109@04))
          (and
            (=
              ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@109@04))
              ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@110@04)))
            (< i2@110@04 V@28@04)
            (<= 0 i2@110@04)
            (< i1@109@04 V@28@04)
            (<= 0 i1@109@04))))
      :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@110@04))
      :qid |prog.l<no position>-aux|))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@109@04))
    :qid |prog.l<no position>-aux|))))
(push) ; 5
(assert (not (implies
  (< 0 V@28@04)
  (forall ((i1@109@04 Int)) (!
    (forall ((i2@110@04 Int)) (!
      (implies
        (and
          (and
            (and
              (and
                (=
                  ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@109@04))
                  ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@110@04)))
                (< i2@110@04 V@28@04))
              (<= 0 i2@110@04))
            (< i1@109@04 V@28@04))
          (<= 0 i1@109@04))
        (= i1@109@04 i2@110@04))
      :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@110@04))
      :qid |prog.l<no position>|))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@109@04))
    :qid |prog.l<no position>|)))))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               4539
;  :arith-add-rows          2042
;  :arith-assert-diseq      187
;  :arith-assert-lower      1032
;  :arith-assert-upper      625
;  :arith-bound-prop        370
;  :arith-conflicts         132
;  :arith-eq-adapter        635
;  :arith-fixed-eqs         274
;  :arith-max-min           71
;  :arith-nonlinear-bounds  9
;  :arith-offset-eqs        306
;  :arith-pivots            823
;  :conflicts               481
;  :datatype-accessor-ax    39
;  :datatype-constructor-ax 325
;  :datatype-occurs-check   119
;  :datatype-splits         61
;  :decisions               716
;  :del-clause              4938
;  :final-checks            84
;  :interface-eqs           2
;  :max-generation          4
;  :max-memory              5.71
;  :memory                  5.70
;  :minimized-lits          22
;  :mk-bool-var             8290
;  :mk-clause               4940
;  :num-allocs              268185
;  :num-checks              176
;  :propagations            1968
;  :quant-instantiations    2061
;  :rlimit-count            446281
;  :time                    0.00)
(assert (implies
  (< 0 V@28@04)
  (forall ((i1@109@04 Int)) (!
    (forall ((i2@110@04 Int)) (!
      (implies
        (and
          (and
            (and
              (and
                (=
                  ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@109@04))
                  ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@110@04)))
                (< i2@110@04 V@28@04))
              (<= 0 i2@110@04))
            (< i1@109@04 V@28@04))
          (<= 0 i1@109@04))
        (= i1@109@04 i2@110@04))
      :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@110@04))
      :qid |prog.l<no position>|))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@109@04))
    :qid |prog.l<no position>|))))
(declare-const unknown@111@04 Int)
(declare-const unknown1@112@04 Int)
(push) ; 5
; [eval] 0 <= unknown && unknown < V && (0 <= unknown1 && unknown1 < V)
; [eval] 0 <= unknown
(push) ; 6
; [then-branch: 115 | 0 <= unknown@111@04 | live]
; [else-branch: 115 | !(0 <= unknown@111@04) | live]
(push) ; 7
; [then-branch: 115 | 0 <= unknown@111@04]
(assert (<= 0 unknown@111@04))
; [eval] unknown < V
(push) ; 8
; [then-branch: 116 | unknown@111@04 < V@28@04 | live]
; [else-branch: 116 | !(unknown@111@04 < V@28@04) | live]
(push) ; 9
; [then-branch: 116 | unknown@111@04 < V@28@04]
(assert (< unknown@111@04 V@28@04))
; [eval] 0 <= unknown1
(push) ; 10
; [then-branch: 117 | 0 <= unknown1@112@04 | live]
; [else-branch: 117 | !(0 <= unknown1@112@04) | live]
(push) ; 11
; [then-branch: 117 | 0 <= unknown1@112@04]
(assert (<= 0 unknown1@112@04))
; [eval] unknown1 < V
(pop) ; 11
(push) ; 11
; [else-branch: 117 | !(0 <= unknown1@112@04)]
(assert (not (<= 0 unknown1@112@04)))
(pop) ; 11
(pop) ; 10
; Joined path conditions
; Joined path conditions
(pop) ; 9
(push) ; 9
; [else-branch: 116 | !(unknown@111@04 < V@28@04)]
(assert (not (< unknown@111@04 V@28@04)))
(pop) ; 9
(pop) ; 8
; Joined path conditions
; Joined path conditions
(pop) ; 7
(push) ; 7
; [else-branch: 115 | !(0 <= unknown@111@04)]
(assert (not (<= 0 unknown@111@04)))
(pop) ; 7
(pop) ; 6
; Joined path conditions
; Joined path conditions
(assert (and
  (and
    (and (< unknown1@112@04 V@28@04) (<= 0 unknown1@112@04))
    (< unknown@111@04 V@28@04))
  (<= 0 unknown@111@04)))
; [eval] aloc(opt_get1(aloc(opt_get1(target), unknown1).option$array$), unknown)
; [eval] opt_get1(aloc(opt_get1(target), unknown1).option$array$)
; [eval] aloc(opt_get1(target), unknown1)
; [eval] opt_get1(target)
(push) ; 6
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 6
; Joined path conditions
(push) ; 6
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 7
(assert (not (< unknown1@112@04 (alen<Int> (opt_get1 $Snap.unit target@27@04)))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               4539
;  :arith-add-rows          2042
;  :arith-assert-diseq      187
;  :arith-assert-lower      1038
;  :arith-assert-upper      625
;  :arith-bound-prop        370
;  :arith-conflicts         132
;  :arith-eq-adapter        635
;  :arith-fixed-eqs         274
;  :arith-max-min           71
;  :arith-nonlinear-bounds  9
;  :arith-offset-eqs        306
;  :arith-pivots            824
;  :conflicts               481
;  :datatype-accessor-ax    39
;  :datatype-constructor-ax 325
;  :datatype-occurs-check   119
;  :datatype-splits         61
;  :decisions               716
;  :del-clause              4938
;  :final-checks            84
;  :interface-eqs           2
;  :max-generation          4
;  :max-memory              5.71
;  :memory                  5.70
;  :minimized-lits          22
;  :mk-bool-var             8297
;  :mk-clause               4940
;  :num-allocs              268789
;  :num-checks              177
;  :propagations            1968
;  :quant-instantiations    2061
;  :rlimit-count            447287)
(assert (< unknown1@112@04 (alen<Int> (opt_get1 $Snap.unit target@27@04))))
(pop) ; 6
; Joined path conditions
(assert (< unknown1@112@04 (alen<Int> (opt_get1 $Snap.unit target@27@04))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@112@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@112@04)))
(push) ; 6
(assert (not (<
  $Perm.No
  (+
    (ite
      (and
        (<
          (inv@42@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@112@04))
          V@28@04)
        (<=
          0
          (inv@42@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@112@04))))
      $k@41@04
      $Perm.No)
    (ite
      (and
        (<
          (inv@34@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@112@04))
          V@28@04)
        (<=
          0
          (inv@34@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@112@04))))
      $k@33@04
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               4616
;  :arith-add-rows          2157
;  :arith-assert-diseq      191
;  :arith-assert-lower      1062
;  :arith-assert-upper      641
;  :arith-bound-prop        379
;  :arith-conflicts         135
;  :arith-eq-adapter        653
;  :arith-fixed-eqs         281
;  :arith-max-min           71
;  :arith-nonlinear-bounds  9
;  :arith-offset-eqs        312
;  :arith-pivots            849
;  :conflicts               495
;  :datatype-accessor-ax    39
;  :datatype-constructor-ax 329
;  :datatype-occurs-check   119
;  :datatype-splits         61
;  :decisions               729
;  :del-clause              4987
;  :final-checks            84
;  :interface-eqs           2
;  :max-generation          4
;  :max-memory              5.72
;  :memory                  5.72
;  :minimized-lits          22
;  :mk-bool-var             8484
;  :mk-clause               5052
;  :num-allocs              269846
;  :num-checks              178
;  :propagations            2010
;  :quant-instantiations    2101
;  :rlimit-count            451783
;  :time                    0.00)
(push) ; 6
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 7
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@112@04))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               4616
;  :arith-add-rows          2157
;  :arith-assert-diseq      191
;  :arith-assert-lower      1062
;  :arith-assert-upper      641
;  :arith-bound-prop        379
;  :arith-conflicts         135
;  :arith-eq-adapter        653
;  :arith-fixed-eqs         281
;  :arith-max-min           71
;  :arith-nonlinear-bounds  9
;  :arith-offset-eqs        312
;  :arith-pivots            849
;  :conflicts               496
;  :datatype-accessor-ax    39
;  :datatype-constructor-ax 329
;  :datatype-occurs-check   119
;  :datatype-splits         61
;  :decisions               729
;  :del-clause              4987
;  :final-checks            84
;  :interface-eqs           2
;  :max-generation          4
;  :max-memory              5.72
;  :memory                  5.72
;  :minimized-lits          22
;  :mk-bool-var             8484
;  :mk-clause               5052
;  :num-allocs              269937
;  :num-checks              179
;  :propagations            2010
;  :quant-instantiations    2101
;  :rlimit-count            451878)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@112@04))
    (as None<option<array>>  option<array>))))
(pop) ; 6
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@112@04))
    (as None<option<array>>  option<array>))))
(push) ; 6
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 7
(assert (not (<
  unknown@111@04
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@112@04)))))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               4622
;  :arith-add-rows          2162
;  :arith-assert-diseq      191
;  :arith-assert-lower      1065
;  :arith-assert-upper      642
;  :arith-bound-prop        379
;  :arith-conflicts         136
;  :arith-eq-adapter        654
;  :arith-fixed-eqs         282
;  :arith-max-min           71
;  :arith-nonlinear-bounds  9
;  :arith-offset-eqs        312
;  :arith-pivots            853
;  :conflicts               497
;  :datatype-accessor-ax    39
;  :datatype-constructor-ax 329
;  :datatype-occurs-check   119
;  :datatype-splits         61
;  :decisions               729
;  :del-clause              4991
;  :final-checks            84
;  :interface-eqs           2
;  :max-generation          4
;  :max-memory              5.72
;  :memory                  5.72
;  :minimized-lits          22
;  :mk-bool-var             8495
;  :mk-clause               5056
;  :num-allocs              270141
;  :num-checks              180
;  :propagations            2012
;  :quant-instantiations    2110
;  :rlimit-count            452435)
(assert (<
  unknown@111@04
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@112@04))))))
(pop) ; 6
; Joined path conditions
(assert (<
  unknown@111@04
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@112@04))))))
(pop) ; 5
(declare-fun inv@113@04 ($Ref) Int)
(declare-fun inv@114@04 ($Ref) Int)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(assert (forall ((unknown@111@04 Int) (unknown1@112@04 Int)) (!
  (and
    (< unknown1@112@04 (alen<Int> (opt_get1 $Snap.unit target@27@04)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@112@04)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@112@04))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@112@04))
        (as None<option<array>>  option<array>)))
    (<
      unknown@111@04
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@112@04))))))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@112@04))) unknown@111@04))
  :qid |int-aux|)))
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 5
(assert (not (forall ((unknown1@111@04 Int) (unknown11@112@04 Int) (unknown2@111@04 Int) (unknown12@112@04 Int)) (!
  (implies
    (and
      (and
        (and
          (and
            (and (< unknown11@112@04 V@28@04) (<= 0 unknown11@112@04))
            (< unknown1@111@04 V@28@04))
          (<= 0 unknown1@111@04))
        ($FVF.loc_int ($FVF.lookup_int (as sm@58@04  $FVF<Int>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown11@112@04))) unknown1@111@04)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown11@112@04))) unknown1@111@04)))
      (and
        (and
          (and
            (and (< unknown12@112@04 V@28@04) (<= 0 unknown12@112@04))
            (< unknown2@111@04 V@28@04))
          (<= 0 unknown2@111@04))
        ($FVF.loc_int ($FVF.lookup_int (as sm@58@04  $FVF<Int>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown12@112@04))) unknown2@111@04)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown12@112@04))) unknown2@111@04)))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown11@112@04))) unknown1@111@04)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown12@112@04))) unknown2@111@04)))
    (and
      (= unknown1@111@04 unknown2@111@04)
      (= unknown11@112@04 unknown12@112@04)))
  
  :qid |int-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               4666
;  :arith-add-rows          2179
;  :arith-assert-diseq      191
;  :arith-assert-lower      1076
;  :arith-assert-upper      642
;  :arith-bound-prop        380
;  :arith-conflicts         136
;  :arith-eq-adapter        666
;  :arith-fixed-eqs         282
;  :arith-max-min           71
;  :arith-nonlinear-bounds  9
;  :arith-offset-eqs        313
;  :arith-pivots            868
;  :conflicts               498
;  :datatype-accessor-ax    39
;  :datatype-constructor-ax 329
;  :datatype-occurs-check   119
;  :datatype-splits         61
;  :decisions               729
;  :del-clause              5169
;  :final-checks            84
;  :interface-eqs           2
;  :max-generation          4
;  :max-memory              5.75
;  :memory                  5.73
;  :minimized-lits          22
;  :mk-bool-var             8673
;  :mk-clause               5171
;  :num-allocs              271561
;  :num-checks              181
;  :propagations            2033
;  :quant-instantiations    2176
;  :rlimit-count            456630
;  :time                    0.00)
; Definitional axioms for inverse functions
(assert (forall ((unknown@111@04 Int) (unknown1@112@04 Int)) (!
  (implies
    (and
      (and
        (and (< unknown1@112@04 V@28@04) (<= 0 unknown1@112@04))
        (< unknown@111@04 V@28@04))
      (<= 0 unknown@111@04))
    (and
      (=
        (inv@113@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@112@04))) unknown@111@04))
        unknown@111@04)
      (=
        (inv@114@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@112@04))) unknown@111@04))
        unknown1@112@04)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@112@04))) unknown@111@04))
  :qid |int-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@114@04 r) V@28@04) (<= 0 (inv@114@04 r)))
        (< (inv@113@04 r) V@28@04))
      (<= 0 (inv@113@04 r)))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@27@04) (inv@114@04 r)))) (inv@113@04 r))
      r))
  :pattern ((inv@113@04 r))
  :pattern ((inv@114@04 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@114@04 r) V@28@04) (<= 0 (inv@114@04 r)))
        (< (inv@113@04 r) V@28@04))
      (<= 0 (inv@113@04 r)))
    ($FVF.loc_int ($FVF.lookup_int (as sm@58@04  $FVF<Int>) r) r))
  :pattern ((inv@113@04 r) (inv@114@04 r))
  )))
; Precomputing data for removing quantified permissions
(define-fun pTaken@115@04 ((r $Ref)) $Perm
  (ite
    (and
      (and
        (and (< (inv@114@04 r) V@28@04) (<= 0 (inv@114@04 r)))
        (< (inv@113@04 r) V@28@04))
      (<= 0 (inv@113@04 r)))
    ($Perm.min
      (ite
        (and
          (and
            (and (< (inv@57@04 r) V@28@04) (<= 0 (inv@57@04 r)))
            (< (inv@56@04 r) V@28@04))
          (<= 0 (inv@56@04 r)))
        $Perm.Write
        $Perm.No)
      $Perm.Write)
    $Perm.No))
(define-fun pTaken@116@04 ((r $Ref)) $Perm
  (ite
    (and
      (and
        (and (< (inv@114@04 r) V@28@04) (<= 0 (inv@114@04 r)))
        (< (inv@113@04 r) V@28@04))
      (<= 0 (inv@113@04 r)))
    ($Perm.min
      (ite
        (and
          (and
            (and (< (inv@52@04 r) V@28@04) (<= 0 (inv@52@04 r)))
            (< (inv@51@04 r) V@28@04))
          (<= 0 (inv@51@04 r)))
        $k@50@04
        $Perm.No)
      (- $Perm.Write (pTaken@115@04 r)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 500)
(push) ; 5
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and
          (and
            (and (< (inv@57@04 r) V@28@04) (<= 0 (inv@57@04 r)))
            (< (inv@56@04 r) V@28@04))
          (<= 0 (inv@56@04 r)))
        $Perm.Write
        $Perm.No)
      (pTaken@115@04 r))
    $Perm.No)
  
  ))))
(check-sat)
; unsat
(pop) ; 5
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               4855
;  :arith-add-rows          2241
;  :arith-assert-diseq      199
;  :arith-assert-lower      1125
;  :arith-assert-upper      664
;  :arith-bound-prop        389
;  :arith-conflicts         141
;  :arith-eq-adapter        705
;  :arith-fixed-eqs         295
;  :arith-max-min           71
;  :arith-nonlinear-bounds  9
;  :arith-offset-eqs        316
;  :arith-pivots            903
;  :conflicts               510
;  :datatype-accessor-ax    39
;  :datatype-constructor-ax 337
;  :datatype-occurs-check   120
;  :datatype-splits         61
;  :decisions               744
;  :del-clause              5435
;  :final-checks            85
;  :interface-eqs           2
;  :max-generation          4
;  :max-memory              5.76
;  :memory                  5.74
;  :minimized-lits          22
;  :mk-bool-var             9113
;  :mk-clause               5435
;  :num-allocs              274988
;  :num-checks              183
;  :propagations            2130
;  :quant-instantiations    2303
;  :rlimit-count            465612
;  :time                    0.01)
; Intermediate check if already taken enough permissions
(push) ; 5
(assert (not (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@114@04 r) V@28@04) (<= 0 (inv@114@04 r)))
        (< (inv@113@04 r) V@28@04))
      (<= 0 (inv@113@04 r)))
    (= (- $Perm.Write (pTaken@115@04 r)) $Perm.No))
  
  ))))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               4932
;  :arith-add-rows          2264
;  :arith-assert-diseq      201
;  :arith-assert-lower      1137
;  :arith-assert-upper      674
;  :arith-bound-prop        392
;  :arith-conflicts         143
;  :arith-eq-adapter        712
;  :arith-fixed-eqs         299
;  :arith-max-min           71
;  :arith-nonlinear-bounds  9
;  :arith-offset-eqs        316
;  :arith-pivots            918
;  :conflicts               516
;  :datatype-accessor-ax    39
;  :datatype-constructor-ax 341
;  :datatype-occurs-check   120
;  :datatype-splits         61
;  :decisions               749
;  :del-clause              5546
;  :final-checks            85
;  :interface-eqs           2
;  :max-generation          4
;  :max-memory              6.06
;  :memory                  5.90
;  :minimized-lits          22
;  :mk-bool-var             9277
;  :mk-clause               5546
;  :num-allocs              276023
;  :num-checks              184
;  :propagations            2157
;  :quant-instantiations    2360
;  :rlimit-count            469632
;  :time                    0.00)
; Final check if taken enough permissions
; Done removing quantified permissions
; Definitional axioms for snapshot map values
(declare-const unknown@117@04 Int)
(declare-const unknown1@118@04 Int)
(push) ; 5
; [eval] 0 <= unknown && unknown < V && (0 <= unknown1 && unknown1 < V)
; [eval] 0 <= unknown
(push) ; 6
; [then-branch: 118 | 0 <= unknown@117@04 | live]
; [else-branch: 118 | !(0 <= unknown@117@04) | live]
(push) ; 7
; [then-branch: 118 | 0 <= unknown@117@04]
(assert (<= 0 unknown@117@04))
; [eval] unknown < V
(push) ; 8
; [then-branch: 119 | unknown@117@04 < V@28@04 | live]
; [else-branch: 119 | !(unknown@117@04 < V@28@04) | live]
(push) ; 9
; [then-branch: 119 | unknown@117@04 < V@28@04]
(assert (< unknown@117@04 V@28@04))
; [eval] 0 <= unknown1
(push) ; 10
; [then-branch: 120 | 0 <= unknown1@118@04 | live]
; [else-branch: 120 | !(0 <= unknown1@118@04) | live]
(push) ; 11
; [then-branch: 120 | 0 <= unknown1@118@04]
(assert (<= 0 unknown1@118@04))
; [eval] unknown1 < V
(pop) ; 11
(push) ; 11
; [else-branch: 120 | !(0 <= unknown1@118@04)]
(assert (not (<= 0 unknown1@118@04)))
(pop) ; 11
(pop) ; 10
; Joined path conditions
; Joined path conditions
(pop) ; 9
(push) ; 9
; [else-branch: 119 | !(unknown@117@04 < V@28@04)]
(assert (not (< unknown@117@04 V@28@04)))
(pop) ; 9
(pop) ; 8
; Joined path conditions
; Joined path conditions
(pop) ; 7
(push) ; 7
; [else-branch: 118 | !(0 <= unknown@117@04)]
(assert (not (<= 0 unknown@117@04)))
(pop) ; 7
(pop) ; 6
; Joined path conditions
; Joined path conditions
(assert (and
  (and
    (and (< unknown1@118@04 V@28@04) (<= 0 unknown1@118@04))
    (< unknown@117@04 V@28@04))
  (<= 0 unknown@117@04)))
(declare-const $k@119@04 $Perm)
(assert ($Perm.isReadVar $k@119@04 $Perm.Write))
; [eval] aloc(opt_get1(aloc(opt_get1(source), unknown1).option$array$), unknown)
; [eval] opt_get1(aloc(opt_get1(source), unknown1).option$array$)
; [eval] aloc(opt_get1(source), unknown1)
; [eval] opt_get1(source)
(push) ; 6
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 6
; Joined path conditions
(push) ; 6
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 7
(assert (not (< unknown1@118@04 (alen<Int> (opt_get1 $Snap.unit source@26@04)))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               4932
;  :arith-add-rows          2264
;  :arith-assert-diseq      202
;  :arith-assert-lower      1145
;  :arith-assert-upper      675
;  :arith-bound-prop        392
;  :arith-conflicts         143
;  :arith-eq-adapter        713
;  :arith-fixed-eqs         299
;  :arith-max-min           71
;  :arith-nonlinear-bounds  9
;  :arith-offset-eqs        316
;  :arith-pivots            921
;  :conflicts               516
;  :datatype-accessor-ax    39
;  :datatype-constructor-ax 341
;  :datatype-occurs-check   120
;  :datatype-splits         61
;  :decisions               749
;  :del-clause              5546
;  :final-checks            85
;  :interface-eqs           2
;  :max-generation          4
;  :max-memory              6.06
;  :memory                  5.91
;  :minimized-lits          22
;  :mk-bool-var             9287
;  :mk-clause               5548
;  :num-allocs              276363
;  :num-checks              185
;  :propagations            2158
;  :quant-instantiations    2360
;  :rlimit-count            470253)
(assert (< unknown1@118@04 (alen<Int> (opt_get1 $Snap.unit source@26@04))))
(pop) ; 6
; Joined path conditions
(assert (< unknown1@118@04 (alen<Int> (opt_get1 $Snap.unit source@26@04))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@118@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@118@04)))
(push) ; 6
(assert (not (<
  $Perm.No
  (+
    (ite
      (and
        (<
          (inv@42@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@118@04))
          V@28@04)
        (<=
          0
          (inv@42@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@118@04))))
      $k@41@04
      $Perm.No)
    (ite
      (and
        (<
          (inv@34@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@118@04))
          V@28@04)
        (<=
          0
          (inv@34@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@118@04))))
      $k@33@04
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               5059
;  :arith-add-rows          2380
;  :arith-assert-diseq      209
;  :arith-assert-lower      1185
;  :arith-assert-upper      701
;  :arith-bound-prop        403
;  :arith-conflicts         147
;  :arith-eq-adapter        749
;  :arith-fixed-eqs         310
;  :arith-max-min           71
;  :arith-nonlinear-bounds  9
;  :arith-offset-eqs        327
;  :arith-pivots            948
;  :conflicts               529
;  :datatype-accessor-ax    39
;  :datatype-constructor-ax 345
;  :datatype-occurs-check   120
;  :datatype-splits         61
;  :decisions               770
;  :del-clause              5648
;  :final-checks            85
;  :interface-eqs           2
;  :max-generation          4
;  :max-memory              6.06
;  :memory                  5.92
;  :minimized-lits          22
;  :mk-bool-var             9536
;  :mk-clause               5716
;  :num-allocs              277655
;  :num-checks              186
;  :propagations            2234
;  :quant-instantiations    2404
;  :rlimit-count            474456
;  :time                    0.00)
(push) ; 6
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 7
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@118@04))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               5059
;  :arith-add-rows          2380
;  :arith-assert-diseq      209
;  :arith-assert-lower      1185
;  :arith-assert-upper      701
;  :arith-bound-prop        403
;  :arith-conflicts         147
;  :arith-eq-adapter        749
;  :arith-fixed-eqs         310
;  :arith-max-min           71
;  :arith-nonlinear-bounds  9
;  :arith-offset-eqs        327
;  :arith-pivots            948
;  :conflicts               530
;  :datatype-accessor-ax    39
;  :datatype-constructor-ax 345
;  :datatype-occurs-check   120
;  :datatype-splits         61
;  :decisions               770
;  :del-clause              5648
;  :final-checks            85
;  :interface-eqs           2
;  :max-generation          4
;  :max-memory              6.06
;  :memory                  5.92
;  :minimized-lits          22
;  :mk-bool-var             9536
;  :mk-clause               5716
;  :num-allocs              277746
;  :num-checks              187
;  :propagations            2234
;  :quant-instantiations    2404
;  :rlimit-count            474551)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@118@04))
    (as None<option<array>>  option<array>))))
(pop) ; 6
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@118@04))
    (as None<option<array>>  option<array>))))
(push) ; 6
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 7
(assert (not (<
  unknown@117@04
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@118@04)))))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               5065
;  :arith-add-rows          2385
;  :arith-assert-diseq      209
;  :arith-assert-lower      1188
;  :arith-assert-upper      702
;  :arith-bound-prop        403
;  :arith-conflicts         148
;  :arith-eq-adapter        750
;  :arith-fixed-eqs         311
;  :arith-max-min           71
;  :arith-nonlinear-bounds  9
;  :arith-offset-eqs        327
;  :arith-pivots            952
;  :conflicts               531
;  :datatype-accessor-ax    39
;  :datatype-constructor-ax 345
;  :datatype-occurs-check   120
;  :datatype-splits         61
;  :decisions               770
;  :del-clause              5652
;  :final-checks            85
;  :interface-eqs           2
;  :max-generation          4
;  :max-memory              6.06
;  :memory                  5.92
;  :minimized-lits          22
;  :mk-bool-var             9547
;  :mk-clause               5720
;  :num-allocs              277951
;  :num-checks              188
;  :propagations            2236
;  :quant-instantiations    2411
;  :rlimit-count            475054)
(assert (<
  unknown@117@04
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@118@04))))))
(pop) ; 6
; Joined path conditions
(assert (<
  unknown@117@04
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@118@04))))))
(pop) ; 5
(declare-fun inv@120@04 ($Ref) Int)
(declare-fun inv@121@04 ($Ref) Int)
; Nested auxiliary terms: globals
(assert ($Perm.isReadVar $k@119@04 $Perm.Write))
; Nested auxiliary terms: non-globals
(assert (forall ((unknown@117@04 Int) (unknown1@118@04 Int)) (!
  (and
    (< unknown1@118@04 (alen<Int> (opt_get1 $Snap.unit source@26@04)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@118@04)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@118@04))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@118@04))
        (as None<option<array>>  option<array>)))
    (<
      unknown@117@04
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@118@04))))))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@118@04))) unknown@117@04))
  :qid |int-aux|)))
(push) ; 5
(assert (not (forall ((unknown@117@04 Int) (unknown1@118@04 Int)) (!
  (implies
    (and
      (and
        (and (< unknown1@118@04 V@28@04) (<= 0 unknown1@118@04))
        (< unknown@117@04 V@28@04))
      (<= 0 unknown@117@04))
    (or (= $k@119@04 $Perm.No) (< $Perm.No $k@119@04)))
  
  ))))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               5065
;  :arith-add-rows          2388
;  :arith-assert-diseq      210
;  :arith-assert-lower      1190
;  :arith-assert-upper      703
;  :arith-bound-prop        403
;  :arith-conflicts         148
;  :arith-eq-adapter        751
;  :arith-fixed-eqs         311
;  :arith-max-min           71
;  :arith-nonlinear-bounds  9
;  :arith-offset-eqs        327
;  :arith-pivots            960
;  :conflicts               532
;  :datatype-accessor-ax    39
;  :datatype-constructor-ax 345
;  :datatype-occurs-check   120
;  :datatype-splits         61
;  :decisions               770
;  :del-clause              5720
;  :final-checks            85
;  :interface-eqs           2
;  :max-generation          4
;  :max-memory              6.06
;  :memory                  5.91
;  :minimized-lits          22
;  :mk-bool-var             9556
;  :mk-clause               5722
;  :num-allocs              278479
;  :num-checks              189
;  :propagations            2237
;  :quant-instantiations    2411
;  :rlimit-count            476011)
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 5
(assert (not (forall ((unknown1@117@04 Int) (unknown11@118@04 Int) (unknown2@117@04 Int) (unknown12@118@04 Int)) (!
  (implies
    (and
      (and
        (and
          (and
            (and
              (and (< unknown11@118@04 V@28@04) (<= 0 unknown11@118@04))
              (< unknown1@117@04 V@28@04))
            (<= 0 unknown1@117@04))
          ($FVF.loc_int ($FVF.lookup_int (as sm@53@04  $FVF<Int>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown11@118@04))) unknown1@117@04)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown11@118@04))) unknown1@117@04)))
        (< $Perm.No $k@119@04))
      (and
        (and
          (and
            (and
              (and (< unknown12@118@04 V@28@04) (<= 0 unknown12@118@04))
              (< unknown2@117@04 V@28@04))
            (<= 0 unknown2@117@04))
          ($FVF.loc_int ($FVF.lookup_int (as sm@53@04  $FVF<Int>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown12@118@04))) unknown2@117@04)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown12@118@04))) unknown2@117@04)))
        (< $Perm.No $k@119@04))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown11@118@04))) unknown1@117@04)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown12@118@04))) unknown2@117@04)))
    (and
      (= unknown1@117@04 unknown2@117@04)
      (= unknown11@118@04 unknown12@118@04)))
  
  :qid |int-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               5109
;  :arith-add-rows          2400
;  :arith-assert-diseq      210
;  :arith-assert-lower      1199
;  :arith-assert-upper      705
;  :arith-bound-prop        405
;  :arith-conflicts         148
;  :arith-eq-adapter        763
;  :arith-fixed-eqs         311
;  :arith-max-min           71
;  :arith-nonlinear-bounds  9
;  :arith-offset-eqs        329
;  :arith-pivots            966
;  :conflicts               533
;  :datatype-accessor-ax    39
;  :datatype-constructor-ax 345
;  :datatype-occurs-check   120
;  :datatype-splits         61
;  :decisions               770
;  :del-clause              5834
;  :final-checks            85
;  :interface-eqs           2
;  :max-generation          4
;  :max-memory              6.06
;  :memory                  5.92
;  :minimized-lits          22
;  :mk-bool-var             9730
;  :mk-clause               5836
;  :num-allocs              279663
;  :num-checks              190
;  :propagations            2256
;  :quant-instantiations    2475
;  :rlimit-count            479578
;  :time                    0.00)
; Definitional axioms for inverse functions
(assert (forall ((unknown@117@04 Int) (unknown1@118@04 Int)) (!
  (implies
    (and
      (and
        (and
          (and (< unknown1@118@04 V@28@04) (<= 0 unknown1@118@04))
          (< unknown@117@04 V@28@04))
        (<= 0 unknown@117@04))
      (< $Perm.No $k@119@04))
    (and
      (=
        (inv@120@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@118@04))) unknown@117@04))
        unknown@117@04)
      (=
        (inv@121@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@118@04))) unknown@117@04))
        unknown1@118@04)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@118@04))) unknown@117@04))
  :qid |int-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and
          (and (< (inv@121@04 r) V@28@04) (<= 0 (inv@121@04 r)))
          (< (inv@120@04 r) V@28@04))
        (<= 0 (inv@120@04 r)))
      (< $Perm.No $k@119@04))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@26@04) (inv@121@04 r)))) (inv@120@04 r))
      r))
  :pattern ((inv@120@04 r))
  :pattern ((inv@121@04 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@121@04 r) V@28@04) (<= 0 (inv@121@04 r)))
        (< (inv@120@04 r) V@28@04))
      (<= 0 (inv@120@04 r)))
    ($FVF.loc_int ($FVF.lookup_int (as sm@53@04  $FVF<Int>) r) r))
  :pattern ((inv@120@04 r) (inv@121@04 r))
  )))
; Precomputing data for removing quantified permissions
(define-fun pTaken@122@04 ((r $Ref)) $Perm
  (ite
    (and
      (and
        (and (< (inv@121@04 r) V@28@04) (<= 0 (inv@121@04 r)))
        (< (inv@120@04 r) V@28@04))
      (<= 0 (inv@120@04 r)))
    ($Perm.min
      (ite
        (and
          (and
            (and (< (inv@52@04 r) V@28@04) (<= 0 (inv@52@04 r)))
            (< (inv@51@04 r) V@28@04))
          (<= 0 (inv@51@04 r)))
        $k@50@04
        $Perm.No)
      $k@119@04)
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Constrain original permissions $k@119@04
(assert (forall ((r $Ref)) (!
  (implies
    (not
      (=
        (ite
          (and
            (and
              (and (< (inv@52@04 r) V@28@04) (<= 0 (inv@52@04 r)))
              (< (inv@51@04 r) V@28@04))
            (<= 0 (inv@51@04 r)))
          $k@50@04
          $Perm.No)
        $Perm.No))
    (ite
      (and
        (and
          (and (< (inv@52@04 r) V@28@04) (<= 0 (inv@52@04 r)))
          (< (inv@51@04 r) V@28@04))
        (<= 0 (inv@51@04 r)))
      (<
        (ite
          (and
            (and
              (and (< (inv@121@04 r) V@28@04) (<= 0 (inv@121@04 r)))
              (< (inv@120@04 r) V@28@04))
            (<= 0 (inv@120@04 r)))
          $k@119@04
          $Perm.No)
        $k@50@04)
      (<
        (ite
          (and
            (and
              (and (< (inv@121@04 r) V@28@04) (<= 0 (inv@121@04 r)))
              (< (inv@120@04 r) V@28@04))
            (<= 0 (inv@120@04 r)))
          $k@119@04
          $Perm.No)
        $Perm.No)))
  :pattern ((inv@52@04 r))
  :pattern ((inv@51@04 r))
  :pattern ((inv@121@04 r))
  :pattern ((inv@120@04 r))
  :qid |qp.srp31|)))
; Intermediate check if already taken enough permissions
(set-option :timeout 500)
(push) ; 5
(assert (not (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@121@04 r) V@28@04) (<= 0 (inv@121@04 r)))
        (< (inv@120@04 r) V@28@04))
      (<= 0 (inv@120@04 r)))
    (= (- $k@119@04 (pTaken@122@04 r)) $Perm.No))
  
  ))))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               5212
;  :arith-add-rows          2442
;  :arith-assert-diseq      219
;  :arith-assert-lower      1225
;  :arith-assert-upper      720
;  :arith-bound-prop        411
;  :arith-conflicts         152
;  :arith-eq-adapter        785
;  :arith-fixed-eqs         319
;  :arith-max-min           71
;  :arith-nonlinear-bounds  9
;  :arith-offset-eqs        336
;  :arith-pivots            993
;  :conflicts               542
;  :datatype-accessor-ax    39
;  :datatype-constructor-ax 353
;  :datatype-occurs-check   121
;  :datatype-splits         61
;  :decisions               782
;  :del-clause              5983
;  :final-checks            86
;  :interface-eqs           2
;  :max-generation          4
;  :max-memory              6.06
;  :memory                  5.94
;  :minimized-lits          24
;  :mk-bool-var             9936
;  :mk-clause               5983
;  :num-allocs              282204
;  :num-checks              192
;  :propagations            2297
;  :quant-instantiations    2530
;  :rlimit-count            486758
;  :time                    0.00)
; Final check if taken enough permissions
; Done removing quantified permissions
; Definitional axioms for snapshot map values
(declare-const exc@123@04 $Ref)
(declare-const res@124@04 void)
(declare-const $t@125@04 $Snap)
(assert (= $t@125@04 ($Snap.combine ($Snap.first $t@125@04) ($Snap.second $t@125@04))))
(assert (= ($Snap.first $t@125@04) $Snap.unit))
; [eval] exc == null
(assert (= exc@123@04 $Ref.null))
(assert (=
  ($Snap.second $t@125@04)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@125@04))
    ($Snap.second ($Snap.second $t@125@04)))))
(assert (= ($Snap.first ($Snap.second $t@125@04)) $Snap.unit))
; [eval] exc == null && 0 < V ==> source != (None(): option[array])
; [eval] exc == null && 0 < V
; [eval] exc == null
(push) ; 5
; [then-branch: 121 | exc@123@04 == Null | live]
; [else-branch: 121 | exc@123@04 != Null | live]
(push) ; 6
; [then-branch: 121 | exc@123@04 == Null]
; [eval] 0 < V
(pop) ; 6
(push) ; 6
; [else-branch: 121 | exc@123@04 != Null]
(assert (not (= exc@123@04 $Ref.null)))
(pop) ; 6
(pop) ; 5
; Joined path conditions
; Joined path conditions
(push) ; 5
(set-option :timeout 10)
(push) ; 6
(assert (not (not (and (< 0 V@28@04) (= exc@123@04 $Ref.null)))))
(check-sat)
; unknown
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               5240
;  :arith-add-rows          2442
;  :arith-assert-diseq      219
;  :arith-assert-lower      1225
;  :arith-assert-upper      720
;  :arith-bound-prop        411
;  :arith-conflicts         152
;  :arith-eq-adapter        785
;  :arith-fixed-eqs         319
;  :arith-max-min           71
;  :arith-nonlinear-bounds  9
;  :arith-offset-eqs        336
;  :arith-pivots            993
;  :conflicts               542
;  :datatype-accessor-ax    41
;  :datatype-constructor-ax 358
;  :datatype-occurs-check   124
;  :datatype-splits         62
;  :decisions               787
;  :del-clause              5983
;  :final-checks            88
;  :interface-eqs           2
;  :max-generation          4
;  :max-memory              6.06
;  :memory                  5.95
;  :minimized-lits          24
;  :mk-bool-var             9942
;  :mk-clause               5983
;  :num-allocs              282931
;  :num-checks              193
;  :propagations            2297
;  :quant-instantiations    2530
;  :rlimit-count            487716)
(push) ; 6
(assert (not (and (< 0 V@28@04) (= exc@123@04 $Ref.null))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               5240
;  :arith-add-rows          2442
;  :arith-assert-diseq      219
;  :arith-assert-lower      1225
;  :arith-assert-upper      720
;  :arith-bound-prop        411
;  :arith-conflicts         152
;  :arith-eq-adapter        785
;  :arith-fixed-eqs         319
;  :arith-max-min           71
;  :arith-nonlinear-bounds  9
;  :arith-offset-eqs        336
;  :arith-pivots            993
;  :conflicts               542
;  :datatype-accessor-ax    41
;  :datatype-constructor-ax 358
;  :datatype-occurs-check   124
;  :datatype-splits         62
;  :decisions               787
;  :del-clause              5983
;  :final-checks            88
;  :interface-eqs           2
;  :max-generation          4
;  :max-memory              6.06
;  :memory                  5.95
;  :minimized-lits          24
;  :mk-bool-var             9942
;  :mk-clause               5983
;  :num-allocs              282949
;  :num-checks              194
;  :propagations            2297
;  :quant-instantiations    2530
;  :rlimit-count            487733)
; [then-branch: 122 | 0 < V@28@04 && exc@123@04 == Null | live]
; [else-branch: 122 | !(0 < V@28@04 && exc@123@04 == Null) | dead]
(push) ; 6
; [then-branch: 122 | 0 < V@28@04 && exc@123@04 == Null]
(assert (and (< 0 V@28@04) (= exc@123@04 $Ref.null)))
; [eval] source != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 6
(pop) ; 5
; Joined path conditions
(assert (implies
  (and (< 0 V@28@04) (= exc@123@04 $Ref.null))
  (not (= source@26@04 (as None<option<array>>  option<array>)))))
(assert (=
  ($Snap.second ($Snap.second $t@125@04))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second $t@125@04)))
    ($Snap.second ($Snap.second ($Snap.second $t@125@04))))))
(assert (= ($Snap.first ($Snap.second ($Snap.second $t@125@04))) $Snap.unit))
; [eval] exc == null && 0 < V ==> alen(opt_get1(source)) == V
; [eval] exc == null && 0 < V
; [eval] exc == null
(push) ; 5
; [then-branch: 123 | exc@123@04 == Null | live]
; [else-branch: 123 | exc@123@04 != Null | live]
(push) ; 6
; [then-branch: 123 | exc@123@04 == Null]
(assert (= exc@123@04 $Ref.null))
; [eval] 0 < V
(pop) ; 6
(push) ; 6
; [else-branch: 123 | exc@123@04 != Null]
(assert (not (= exc@123@04 $Ref.null)))
(pop) ; 6
(pop) ; 5
; Joined path conditions
; Joined path conditions
(push) ; 5
(push) ; 6
(assert (not (not (and (< 0 V@28@04) (= exc@123@04 $Ref.null)))))
(check-sat)
; unknown
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               5262
;  :arith-add-rows          2442
;  :arith-assert-diseq      219
;  :arith-assert-lower      1225
;  :arith-assert-upper      720
;  :arith-bound-prop        411
;  :arith-conflicts         152
;  :arith-eq-adapter        785
;  :arith-fixed-eqs         319
;  :arith-max-min           71
;  :arith-nonlinear-bounds  9
;  :arith-offset-eqs        336
;  :arith-pivots            993
;  :conflicts               542
;  :datatype-accessor-ax    42
;  :datatype-constructor-ax 363
;  :datatype-occurs-check   127
;  :datatype-splits         63
;  :decisions               792
;  :del-clause              5983
;  :final-checks            90
;  :interface-eqs           2
;  :max-generation          4
;  :max-memory              6.06
;  :memory                  6.02
;  :minimized-lits          24
;  :mk-bool-var             9945
;  :mk-clause               5983
;  :num-allocs              283605
;  :num-checks              195
;  :propagations            2297
;  :quant-instantiations    2530
;  :rlimit-count            488589)
(push) ; 6
(assert (not (and (< 0 V@28@04) (= exc@123@04 $Ref.null))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               5262
;  :arith-add-rows          2442
;  :arith-assert-diseq      219
;  :arith-assert-lower      1225
;  :arith-assert-upper      720
;  :arith-bound-prop        411
;  :arith-conflicts         152
;  :arith-eq-adapter        785
;  :arith-fixed-eqs         319
;  :arith-max-min           71
;  :arith-nonlinear-bounds  9
;  :arith-offset-eqs        336
;  :arith-pivots            993
;  :conflicts               542
;  :datatype-accessor-ax    42
;  :datatype-constructor-ax 363
;  :datatype-occurs-check   127
;  :datatype-splits         63
;  :decisions               792
;  :del-clause              5983
;  :final-checks            90
;  :interface-eqs           2
;  :max-generation          4
;  :max-memory              6.06
;  :memory                  6.02
;  :minimized-lits          24
;  :mk-bool-var             9945
;  :mk-clause               5983
;  :num-allocs              283623
;  :num-checks              196
;  :propagations            2297
;  :quant-instantiations    2530
;  :rlimit-count            488606)
; [then-branch: 124 | 0 < V@28@04 && exc@123@04 == Null | live]
; [else-branch: 124 | !(0 < V@28@04 && exc@123@04 == Null) | dead]
(push) ; 6
; [then-branch: 124 | 0 < V@28@04 && exc@123@04 == Null]
(assert (and (< 0 V@28@04) (= exc@123@04 $Ref.null)))
; [eval] alen(opt_get1(source)) == V
; [eval] alen(opt_get1(source))
; [eval] opt_get1(source)
(push) ; 7
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 7
; Joined path conditions
(pop) ; 6
(pop) ; 5
; Joined path conditions
(assert (implies
  (and (< 0 V@28@04) (= exc@123@04 $Ref.null))
  (= (alen<Int> (opt_get1 $Snap.unit source@26@04)) V@28@04)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second $t@125@04)))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@125@04))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@04)))))))
; [eval] exc == null && 0 < V
; [eval] exc == null
(push) ; 5
; [then-branch: 125 | exc@123@04 == Null | live]
; [else-branch: 125 | exc@123@04 != Null | live]
(push) ; 6
; [then-branch: 125 | exc@123@04 == Null]
(assert (= exc@123@04 $Ref.null))
; [eval] 0 < V
(pop) ; 6
(push) ; 6
; [else-branch: 125 | exc@123@04 != Null]
(assert (not (= exc@123@04 $Ref.null)))
(pop) ; 6
(pop) ; 5
; Joined path conditions
; Joined path conditions
(push) ; 5
(assert (not (not (and (< 0 V@28@04) (= exc@123@04 $Ref.null)))))
(check-sat)
; unknown
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               5286
;  :arith-add-rows          2442
;  :arith-assert-diseq      219
;  :arith-assert-lower      1225
;  :arith-assert-upper      720
;  :arith-bound-prop        411
;  :arith-conflicts         152
;  :arith-eq-adapter        785
;  :arith-fixed-eqs         319
;  :arith-max-min           71
;  :arith-nonlinear-bounds  9
;  :arith-offset-eqs        336
;  :arith-pivots            993
;  :conflicts               542
;  :datatype-accessor-ax    43
;  :datatype-constructor-ax 369
;  :datatype-occurs-check   130
;  :datatype-splits         65
;  :decisions               798
;  :del-clause              5983
;  :final-checks            92
;  :interface-eqs           2
;  :max-generation          4
;  :max-memory              6.06
;  :memory                  6.02
;  :minimized-lits          24
;  :mk-bool-var             9948
;  :mk-clause               5983
;  :num-allocs              284282
;  :num-checks              197
;  :propagations            2297
;  :quant-instantiations    2530
;  :rlimit-count            489454)
(push) ; 5
(assert (not (and (< 0 V@28@04) (= exc@123@04 $Ref.null))))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               5286
;  :arith-add-rows          2442
;  :arith-assert-diseq      219
;  :arith-assert-lower      1225
;  :arith-assert-upper      720
;  :arith-bound-prop        411
;  :arith-conflicts         152
;  :arith-eq-adapter        785
;  :arith-fixed-eqs         319
;  :arith-max-min           71
;  :arith-nonlinear-bounds  9
;  :arith-offset-eqs        336
;  :arith-pivots            993
;  :conflicts               542
;  :datatype-accessor-ax    43
;  :datatype-constructor-ax 369
;  :datatype-occurs-check   130
;  :datatype-splits         65
;  :decisions               798
;  :del-clause              5983
;  :final-checks            92
;  :interface-eqs           2
;  :max-generation          4
;  :max-memory              6.06
;  :memory                  6.02
;  :minimized-lits          24
;  :mk-bool-var             9948
;  :mk-clause               5983
;  :num-allocs              284300
;  :num-checks              198
;  :propagations            2297
;  :quant-instantiations    2530
;  :rlimit-count            489471)
; [then-branch: 126 | 0 < V@28@04 && exc@123@04 == Null | live]
; [else-branch: 126 | !(0 < V@28@04 && exc@123@04 == Null) | dead]
(push) ; 5
; [then-branch: 126 | 0 < V@28@04 && exc@123@04 == Null]
(assert (and (< 0 V@28@04) (= exc@123@04 $Ref.null)))
(declare-const i1@126@04 Int)
(push) ; 6
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 7
; [then-branch: 127 | 0 <= i1@126@04 | live]
; [else-branch: 127 | !(0 <= i1@126@04) | live]
(push) ; 8
; [then-branch: 127 | 0 <= i1@126@04]
(assert (<= 0 i1@126@04))
; [eval] i1 < V
(pop) ; 8
(push) ; 8
; [else-branch: 127 | !(0 <= i1@126@04)]
(assert (not (<= 0 i1@126@04)))
(pop) ; 8
(pop) ; 7
; Joined path conditions
; Joined path conditions
(assert (and (< i1@126@04 V@28@04) (<= 0 i1@126@04)))
; [eval] aloc(opt_get1(source), i1)
; [eval] opt_get1(source)
(push) ; 7
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 7
; Joined path conditions
(push) ; 7
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 8
(assert (not (< i1@126@04 (alen<Int> (opt_get1 $Snap.unit source@26@04)))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               5286
;  :arith-add-rows          2442
;  :arith-assert-diseq      219
;  :arith-assert-lower      1227
;  :arith-assert-upper      720
;  :arith-bound-prop        411
;  :arith-conflicts         152
;  :arith-eq-adapter        785
;  :arith-fixed-eqs         319
;  :arith-max-min           71
;  :arith-nonlinear-bounds  9
;  :arith-offset-eqs        336
;  :arith-pivots            993
;  :conflicts               542
;  :datatype-accessor-ax    43
;  :datatype-constructor-ax 369
;  :datatype-occurs-check   130
;  :datatype-splits         65
;  :decisions               798
;  :del-clause              5983
;  :final-checks            92
;  :interface-eqs           2
;  :max-generation          4
;  :max-memory              6.06
;  :memory                  6.02
;  :minimized-lits          24
;  :mk-bool-var             9950
;  :mk-clause               5983
;  :num-allocs              284405
;  :num-checks              199
;  :propagations            2297
;  :quant-instantiations    2530
;  :rlimit-count            489665)
(assert (< i1@126@04 (alen<Int> (opt_get1 $Snap.unit source@26@04))))
(pop) ; 7
; Joined path conditions
(assert (< i1@126@04 (alen<Int> (opt_get1 $Snap.unit source@26@04))))
; [eval] scale(V * V * write) * wildcard
; [eval] scale(V * V * write)
; [eval] V * V * write
; [eval] V * V
(push) ; 7
; [eval] amount >= 0 * write
; [eval] 0 * write
(push) ; 8
(assert (not (>= (* (to_real (* V@28@04 V@28@04)) $Perm.Write) $Perm.No)))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               5297
;  :arith-add-rows          2442
;  :arith-assert-diseq      219
;  :arith-assert-lower      1229
;  :arith-assert-upper      721
;  :arith-bound-prop        411
;  :arith-conflicts         153
;  :arith-eq-adapter        785
;  :arith-fixed-eqs         319
;  :arith-max-min           74
;  :arith-nonlinear-bounds  9
;  :arith-offset-eqs        336
;  :arith-pivots            993
;  :conflicts               543
;  :datatype-accessor-ax    43
;  :datatype-constructor-ax 373
;  :datatype-occurs-check   130
;  :datatype-splits         65
;  :decisions               802
;  :del-clause              5983
;  :final-checks            93
;  :interface-eqs           2
;  :max-generation          4
;  :max-memory              6.06
;  :memory                  6.02
;  :minimized-lits          24
;  :mk-bool-var             9951
;  :mk-clause               5983
;  :num-allocs              284569
;  :num-checks              200
;  :propagations            2297
;  :quant-instantiations    2530
;  :rlimit-count            489859)
(assert (>= (* (to_real (* V@28@04 V@28@04)) $Perm.Write) $Perm.No))
(pop) ; 7
; Joined path conditions
(assert (>= (* (to_real (* V@28@04 V@28@04)) $Perm.Write) $Perm.No))
(declare-const $k@127@04 $Perm)
(assert ($Perm.isReadVar $k@127@04 $Perm.Write))
(pop) ; 6
(declare-fun inv@128@04 ($Ref) Int)
; Nested auxiliary terms: globals
(assert ($Perm.isReadVar $k@127@04 $Perm.Write))
; Nested auxiliary terms: non-globals
(assert (forall ((i1@126@04 Int)) (!
  (and
    (< i1@126@04 (alen<Int> (opt_get1 $Snap.unit source@26@04)))
    (>= (* (to_real (* V@28@04 V@28@04)) $Perm.Write) $Perm.No))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@126@04))
  :qid |option$array$-aux|)))
(push) ; 6
(assert (not (forall ((i1@126@04 Int)) (!
  (implies
    (and (< i1@126@04 V@28@04) (<= 0 i1@126@04))
    (or
      (=
        (*
          (scale $Snap.unit (* (to_real (* V@28@04 V@28@04)) $Perm.Write))
          $k@127@04)
        $Perm.No)
      (<
        $Perm.No
        (*
          (scale $Snap.unit (* (to_real (* V@28@04 V@28@04)) $Perm.Write))
          $k@127@04))))
  
  ))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               5319
;  :arith-add-rows          2442
;  :arith-assert-diseq      221
;  :arith-assert-lower      1243
;  :arith-assert-upper      727
;  :arith-bound-prop        411
;  :arith-conflicts         155
;  :arith-eq-adapter        788
;  :arith-fixed-eqs         319
;  :arith-max-min           89
;  :arith-nonlinear-bounds  11
;  :arith-offset-eqs        337
;  :arith-pivots            997
;  :conflicts               549
;  :datatype-accessor-ax    43
;  :datatype-constructor-ax 379
;  :datatype-occurs-check   132
;  :datatype-splits         67
;  :decisions               809
;  :del-clause              5991
;  :final-checks            96
;  :interface-eqs           2
;  :max-generation          4
;  :max-memory              6.06
;  :memory                  6.02
;  :minimized-lits          24
;  :mk-bool-var             9969
;  :mk-clause               5993
;  :num-allocs              285240
;  :num-checks              201
;  :propagations            2302
;  :quant-instantiations    2533
;  :rlimit-count            490883)
; Check receiver injectivity
(push) ; 6
(assert (not (forall ((i11@126@04 Int) (i12@126@04 Int)) (!
  (implies
    (and
      (and
        (and (< i11@126@04 V@28@04) (<= 0 i11@126@04))
        (<
          $Perm.No
          (*
            (scale $Snap.unit (* (to_real (* V@28@04 V@28@04)) $Perm.Write))
            $k@127@04)))
      (and
        (and (< i12@126@04 V@28@04) (<= 0 i12@126@04))
        (<
          $Perm.No
          (*
            (scale $Snap.unit (* (to_real (* V@28@04 V@28@04)) $Perm.Write))
            $k@127@04)))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i11@126@04)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i12@126@04)))
    (= i11@126@04 i12@126@04))
  
  :qid |option$array$-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               5328
;  :arith-add-rows          2448
;  :arith-assert-diseq      222
;  :arith-assert-lower      1248
;  :arith-assert-upper      727
;  :arith-bound-prop        411
;  :arith-conflicts         155
;  :arith-eq-adapter        790
;  :arith-fixed-eqs         319
;  :arith-max-min           89
;  :arith-nonlinear-bounds  11
;  :arith-offset-eqs        337
;  :arith-pivots            1001
;  :conflicts               550
;  :datatype-accessor-ax    43
;  :datatype-constructor-ax 379
;  :datatype-occurs-check   132
;  :datatype-splits         67
;  :decisions               809
;  :del-clause              6008
;  :final-checks            96
;  :interface-eqs           2
;  :max-generation          4
;  :max-memory              6.06
;  :memory                  6.02
;  :minimized-lits          24
;  :mk-bool-var             9997
;  :mk-clause               6010
;  :num-allocs              285676
;  :num-checks              202
;  :propagations            2306
;  :quant-instantiations    2550
;  :rlimit-count            491794)
; Definitional axioms for inverse functions
(assert (forall ((i1@126@04 Int)) (!
  (implies
    (and
      (and (< i1@126@04 V@28@04) (<= 0 i1@126@04))
      (<
        $Perm.No
        (*
          (scale $Snap.unit (* (to_real (* V@28@04 V@28@04)) $Perm.Write))
          $k@127@04)))
    (=
      (inv@128@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@126@04))
      i1@126@04))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@126@04))
  )))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and (< (inv@128@04 r) V@28@04) (<= 0 (inv@128@04 r)))
      (<
        $Perm.No
        (*
          (scale $Snap.unit (* (to_real (* V@28@04 V@28@04)) $Perm.Write))
          $k@127@04)))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) (inv@128@04 r))
      r))
  :pattern ((inv@128@04 r))
  :qid |option$array$-fctOfInv|)))
; Permissions are non-negative
(assert (forall ((i1@126@04 Int)) (!
  (<=
    $Perm.No
    (*
      (scale $Snap.unit (* (to_real (* V@28@04 V@28@04)) $Perm.Write))
      $k@127@04))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@126@04))
  :qid |option$array$-permAtLeastZero|)))
; Field permissions are at most one
(assert (forall ((i1@126@04 Int)) (!
  (<=
    (*
      (scale $Snap.unit (* (to_real (* V@28@04 V@28@04)) $Perm.Write))
      $k@127@04)
    $Perm.Write)
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@126@04))
  :qid |option$array$-permAtMostOne|)))
; Permission implies non-null receiver
(assert (forall ((i1@126@04 Int)) (!
  (implies
    (and
      (and (< i1@126@04 V@28@04) (<= 0 i1@126@04))
      (<
        $Perm.No
        (*
          (scale $Snap.unit (* (to_real (* V@28@04 V@28@04)) $Perm.Write))
          $k@127@04)))
    (not
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@126@04)
        $Ref.null)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@126@04))
  :qid |option$array$-permImpliesNonNull|)))
(declare-const sm@129@04 $FVF<option<array>>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@128@04 r) V@28@04) (<= 0 (inv@128@04 r)))
      (<
        $Perm.No
        (*
          (scale $Snap.unit (* (to_real (* V@28@04 V@28@04)) $Perm.Write))
          $k@127@04))
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@129@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@125@04))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@129@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@125@04))))) r))
  :qid |qp.fvfValDef32|)))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (-
          (ite
            (and (< (inv@42@04 r) V@28@04) (<= 0 (inv@42@04 r)))
            $k@41@04
            $Perm.No)
          (pTaken@95@04 r))
        (pTaken@106@04 r)))
    (=
      ($FVF.lookup_option$array$ (as sm@129@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@31@04))))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@129@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@31@04))))))))))) r))
  :qid |qp.fvfValDef33|)))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (-
          (ite
            (and (< (inv@34@04 r) V@28@04) (<= 0 (inv@34@04 r)))
            $k@33@04
            $Perm.No)
          (pTaken@96@04 r))
        (pTaken@105@04 r)))
    (=
      ($FVF.lookup_option$array$ (as sm@129@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@31@04))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@129@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@31@04))))) r))
  :qid |qp.fvfValDef34|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@125@04))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@31@04))))))))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@31@04))))) r) r))
  :pattern (($FVF.lookup_option$array$ (as sm@129@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef35|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@128@04 r) V@28@04) (<= 0 (inv@128@04 r)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@129@04  $FVF<option<array>>) r) r))
  :pattern ((inv@128@04 r))
  )))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@04))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@04)))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@04))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@04)))))
  $Snap.unit))
; [eval] exc == null && 0 < V ==> (forall i1: Int :: { aloc(opt_get1(source), i1) } 0 <= i1 && i1 < V ==> aloc(opt_get1(source), i1).option$array$ != (None(): option[array]))
; [eval] exc == null && 0 < V
; [eval] exc == null
(push) ; 6
; [then-branch: 128 | exc@123@04 == Null | live]
; [else-branch: 128 | exc@123@04 != Null | live]
(push) ; 7
; [then-branch: 128 | exc@123@04 == Null]
; [eval] 0 < V
(pop) ; 7
(push) ; 7
; [else-branch: 128 | exc@123@04 != Null]
(assert (not (= exc@123@04 $Ref.null)))
(pop) ; 7
(pop) ; 6
; Joined path conditions
; Joined path conditions
(push) ; 6
(set-option :timeout 10)
(push) ; 7
(assert (not (not (and (< 0 V@28@04) (= exc@123@04 $Ref.null)))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               5358
;  :arith-add-rows          2448
;  :arith-assert-diseq      222
;  :arith-assert-lower      1264
;  :arith-assert-upper      736
;  :arith-bound-prop        411
;  :arith-conflicts         156
;  :arith-eq-adapter        791
;  :arith-fixed-eqs         319
;  :arith-grobner           5
;  :arith-max-min           115
;  :arith-nonlinear-bounds  12
;  :arith-nonlinear-horner  4
;  :arith-offset-eqs        338
;  :arith-pivots            1002
;  :conflicts               551
;  :datatype-accessor-ax    44
;  :datatype-constructor-ax 385
;  :datatype-occurs-check   136
;  :datatype-splits         69
;  :decisions               816
;  :del-clause              6008
;  :final-checks            101
;  :interface-eqs           2
;  :max-generation          4
;  :max-memory              6.06
;  :memory                  6.03
;  :minimized-lits          24
;  :mk-bool-var             10017
;  :mk-clause               6015
;  :num-allocs              288451
;  :num-checks              203
;  :propagations            2309
;  :quant-instantiations    2553
;  :rlimit-count            499327)
(push) ; 7
(assert (not (and (< 0 V@28@04) (= exc@123@04 $Ref.null))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               5358
;  :arith-add-rows          2448
;  :arith-assert-diseq      222
;  :arith-assert-lower      1264
;  :arith-assert-upper      736
;  :arith-bound-prop        411
;  :arith-conflicts         156
;  :arith-eq-adapter        791
;  :arith-fixed-eqs         319
;  :arith-grobner           5
;  :arith-max-min           115
;  :arith-nonlinear-bounds  12
;  :arith-nonlinear-horner  4
;  :arith-offset-eqs        338
;  :arith-pivots            1002
;  :conflicts               551
;  :datatype-accessor-ax    44
;  :datatype-constructor-ax 385
;  :datatype-occurs-check   136
;  :datatype-splits         69
;  :decisions               816
;  :del-clause              6008
;  :final-checks            101
;  :interface-eqs           2
;  :max-generation          4
;  :max-memory              6.06
;  :memory                  6.03
;  :minimized-lits          24
;  :mk-bool-var             10017
;  :mk-clause               6015
;  :num-allocs              288469
;  :num-checks              204
;  :propagations            2309
;  :quant-instantiations    2553
;  :rlimit-count            499344)
; [then-branch: 129 | 0 < V@28@04 && exc@123@04 == Null | live]
; [else-branch: 129 | !(0 < V@28@04 && exc@123@04 == Null) | dead]
(push) ; 7
; [then-branch: 129 | 0 < V@28@04 && exc@123@04 == Null]
(assert (and (< 0 V@28@04) (= exc@123@04 $Ref.null)))
; [eval] (forall i1: Int :: { aloc(opt_get1(source), i1) } 0 <= i1 && i1 < V ==> aloc(opt_get1(source), i1).option$array$ != (None(): option[array]))
(declare-const i1@130@04 Int)
(push) ; 8
; [eval] 0 <= i1 && i1 < V ==> aloc(opt_get1(source), i1).option$array$ != (None(): option[array])
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 9
; [then-branch: 130 | 0 <= i1@130@04 | live]
; [else-branch: 130 | !(0 <= i1@130@04) | live]
(push) ; 10
; [then-branch: 130 | 0 <= i1@130@04]
(assert (<= 0 i1@130@04))
; [eval] i1 < V
(pop) ; 10
(push) ; 10
; [else-branch: 130 | !(0 <= i1@130@04)]
(assert (not (<= 0 i1@130@04)))
(pop) ; 10
(pop) ; 9
; Joined path conditions
; Joined path conditions
(push) ; 9
; [then-branch: 131 | i1@130@04 < V@28@04 && 0 <= i1@130@04 | live]
; [else-branch: 131 | !(i1@130@04 < V@28@04 && 0 <= i1@130@04) | live]
(push) ; 10
; [then-branch: 131 | i1@130@04 < V@28@04 && 0 <= i1@130@04]
(assert (and (< i1@130@04 V@28@04) (<= 0 i1@130@04)))
; [eval] aloc(opt_get1(source), i1).option$array$ != (None(): option[array])
; [eval] aloc(opt_get1(source), i1)
; [eval] opt_get1(source)
(push) ; 11
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 11
; Joined path conditions
(push) ; 11
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 12
(assert (not (< i1@130@04 (alen<Int> (opt_get1 $Snap.unit source@26@04)))))
(check-sat)
; unsat
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               5358
;  :arith-add-rows          2448
;  :arith-assert-diseq      222
;  :arith-assert-lower      1266
;  :arith-assert-upper      736
;  :arith-bound-prop        411
;  :arith-conflicts         156
;  :arith-eq-adapter        791
;  :arith-fixed-eqs         319
;  :arith-grobner           5
;  :arith-max-min           115
;  :arith-nonlinear-bounds  12
;  :arith-nonlinear-horner  4
;  :arith-offset-eqs        338
;  :arith-pivots            1002
;  :conflicts               551
;  :datatype-accessor-ax    44
;  :datatype-constructor-ax 385
;  :datatype-occurs-check   136
;  :datatype-splits         69
;  :decisions               816
;  :del-clause              6008
;  :final-checks            101
;  :interface-eqs           2
;  :max-generation          4
;  :max-memory              6.06
;  :memory                  6.03
;  :minimized-lits          24
;  :mk-bool-var             10019
;  :mk-clause               6015
;  :num-allocs              288569
;  :num-checks              205
;  :propagations            2309
;  :quant-instantiations    2553
;  :rlimit-count            499548)
(assert (< i1@130@04 (alen<Int> (opt_get1 $Snap.unit source@26@04))))
(pop) ; 11
; Joined path conditions
(assert (< i1@130@04 (alen<Int> (opt_get1 $Snap.unit source@26@04))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@129@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@130@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@130@04)))
(push) ; 11
(assert (not (<
  $Perm.No
  (+
    (+
      (ite
        (and
          (<
            (inv@128@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@130@04))
            V@28@04)
          (<=
            0
            (inv@128@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@130@04))))
        (*
          (scale $Snap.unit (* (to_real (* V@28@04 V@28@04)) $Perm.Write))
          $k@127@04)
        $Perm.No)
      (-
        (-
          (ite
            (and
              (<
                (inv@42@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@130@04))
                V@28@04)
              (<=
                0
                (inv@42@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@130@04))))
            $k@41@04
            $Perm.No)
          (pTaken@95@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@130@04)))
        (pTaken@106@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@130@04))))
    (-
      (-
        (ite
          (and
            (<
              (inv@34@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@130@04))
              V@28@04)
            (<=
              0
              (inv@34@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@130@04))))
          $k@33@04
          $Perm.No)
        (pTaken@96@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@130@04)))
      (pTaken@105@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@130@04)))))))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               5741
;  :arith-add-rows          2930
;  :arith-assert-diseq      247
;  :arith-assert-lower      1392
;  :arith-assert-upper      823
;  :arith-bound-prop        459
;  :arith-conflicts         168
;  :arith-eq-adapter        893
;  :arith-fixed-eqs         359
;  :arith-grobner           5
;  :arith-max-min           115
;  :arith-nonlinear-bounds  12
;  :arith-nonlinear-horner  4
;  :arith-offset-eqs        396
;  :arith-pivots            1072
;  :conflicts               580
;  :datatype-accessor-ax    44
;  :datatype-constructor-ax 389
;  :datatype-occurs-check   136
;  :datatype-splits         69
;  :decisions               885
;  :del-clause              6396
;  :final-checks            101
;  :interface-eqs           2
;  :max-generation          4
;  :max-memory              6.66
;  :memory                  6.39
;  :minimized-lits          32
;  :mk-bool-var             10637
;  :mk-clause               6503
;  :num-allocs              291236
;  :num-checks              206
;  :propagations            2612
;  :quant-instantiations    2632
;  :rlimit-count            515314
;  :time                    0.00)
; [eval] (None(): option[array])
(pop) ; 10
(push) ; 10
; [else-branch: 131 | !(i1@130@04 < V@28@04 && 0 <= i1@130@04)]
(assert (not (and (< i1@130@04 V@28@04) (<= 0 i1@130@04))))
(pop) ; 10
(pop) ; 9
; Joined path conditions
(assert (implies
  (and (< i1@130@04 V@28@04) (<= 0 i1@130@04))
  (and
    (< i1@130@04 V@28@04)
    (<= 0 i1@130@04)
    (< i1@130@04 (alen<Int> (opt_get1 $Snap.unit source@26@04)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@129@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@130@04)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@130@04)))))
; Joined path conditions
(pop) ; 8
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@130@04 Int)) (!
  (implies
    (and (< i1@130@04 V@28@04) (<= 0 i1@130@04))
    (and
      (< i1@130@04 V@28@04)
      (<= 0 i1@130@04)
      (< i1@130@04 (alen<Int> (opt_get1 $Snap.unit source@26@04)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@129@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@130@04)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@130@04))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@130@04))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 7
(pop) ; 6
; Joined path conditions
(assert (implies
  (and (< 0 V@28@04) (= exc@123@04 $Ref.null))
  (and
    (< 0 V@28@04)
    (= exc@123@04 $Ref.null)
    (forall ((i1@130@04 Int)) (!
      (implies
        (and (< i1@130@04 V@28@04) (<= 0 i1@130@04))
        (and
          (< i1@130@04 V@28@04)
          (<= 0 i1@130@04)
          (< i1@130@04 (alen<Int> (opt_get1 $Snap.unit source@26@04)))
          ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@129@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@130@04)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@130@04))))
      :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@130@04))
      :qid |prog.l<no position>-aux|)))))
(assert (implies
  (and (< 0 V@28@04) (= exc@123@04 $Ref.null))
  (forall ((i1@130@04 Int)) (!
    (implies
      (and (< i1@130@04 V@28@04) (<= 0 i1@130@04))
      (not
        (=
          ($FVF.lookup_option$array$ (as sm@129@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@130@04))
          (as None<option<array>>  option<array>))))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@130@04))
    :qid |prog.l<no position>|))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@04)))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@04))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@04)))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@04))))))
  $Snap.unit))
; [eval] exc == null && 0 < V ==> (forall i1: Int :: { alen(opt_get1(aloc(opt_get1(source), i1).option$array$)) } 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(source), i1).option$array$)) == V)
; [eval] exc == null && 0 < V
; [eval] exc == null
(push) ; 6
; [then-branch: 132 | exc@123@04 == Null | live]
; [else-branch: 132 | exc@123@04 != Null | live]
(push) ; 7
; [then-branch: 132 | exc@123@04 == Null]
(assert (= exc@123@04 $Ref.null))
; [eval] 0 < V
(pop) ; 7
(push) ; 7
; [else-branch: 132 | exc@123@04 != Null]
(assert (not (= exc@123@04 $Ref.null)))
(pop) ; 7
(pop) ; 6
; Joined path conditions
; Joined path conditions
(push) ; 6
(set-option :timeout 10)
(push) ; 7
(assert (not (not (and (< 0 V@28@04) (= exc@123@04 $Ref.null)))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               5771
;  :arith-add-rows          2936
;  :arith-assert-diseq      247
;  :arith-assert-lower      1407
;  :arith-assert-upper      831
;  :arith-bound-prop        459
;  :arith-conflicts         169
;  :arith-eq-adapter        893
;  :arith-fixed-eqs         359
;  :arith-grobner           10
;  :arith-max-min           141
;  :arith-nonlinear-bounds  13
;  :arith-nonlinear-horner  8
;  :arith-offset-eqs        397
;  :arith-pivots            1085
;  :conflicts               581
;  :datatype-accessor-ax    45
;  :datatype-constructor-ax 395
;  :datatype-occurs-check   140
;  :datatype-splits         71
;  :decisions               892
;  :del-clause              6496
;  :final-checks            106
;  :interface-eqs           2
;  :max-generation          4
;  :max-memory              6.66
;  :memory                  6.38
;  :minimized-lits          32
;  :mk-bool-var             10643
;  :mk-clause               6503
;  :num-allocs              292528
;  :num-checks              207
;  :propagations            2615
;  :quant-instantiations    2632
;  :rlimit-count            517749
;  :time                    0.00)
(push) ; 7
(assert (not (and (< 0 V@28@04) (= exc@123@04 $Ref.null))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               5771
;  :arith-add-rows          2936
;  :arith-assert-diseq      247
;  :arith-assert-lower      1407
;  :arith-assert-upper      831
;  :arith-bound-prop        459
;  :arith-conflicts         169
;  :arith-eq-adapter        893
;  :arith-fixed-eqs         359
;  :arith-grobner           10
;  :arith-max-min           141
;  :arith-nonlinear-bounds  13
;  :arith-nonlinear-horner  8
;  :arith-offset-eqs        397
;  :arith-pivots            1085
;  :conflicts               581
;  :datatype-accessor-ax    45
;  :datatype-constructor-ax 395
;  :datatype-occurs-check   140
;  :datatype-splits         71
;  :decisions               892
;  :del-clause              6496
;  :final-checks            106
;  :interface-eqs           2
;  :max-generation          4
;  :max-memory              6.66
;  :memory                  6.38
;  :minimized-lits          32
;  :mk-bool-var             10643
;  :mk-clause               6503
;  :num-allocs              292546
;  :num-checks              208
;  :propagations            2615
;  :quant-instantiations    2632
;  :rlimit-count            517766)
; [then-branch: 133 | 0 < V@28@04 && exc@123@04 == Null | live]
; [else-branch: 133 | !(0 < V@28@04 && exc@123@04 == Null) | dead]
(push) ; 7
; [then-branch: 133 | 0 < V@28@04 && exc@123@04 == Null]
(assert (and (< 0 V@28@04) (= exc@123@04 $Ref.null)))
; [eval] (forall i1: Int :: { alen(opt_get1(aloc(opt_get1(source), i1).option$array$)) } 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(source), i1).option$array$)) == V)
(declare-const i1@131@04 Int)
(push) ; 8
; [eval] 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(source), i1).option$array$)) == V
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 9
; [then-branch: 134 | 0 <= i1@131@04 | live]
; [else-branch: 134 | !(0 <= i1@131@04) | live]
(push) ; 10
; [then-branch: 134 | 0 <= i1@131@04]
(assert (<= 0 i1@131@04))
; [eval] i1 < V
(pop) ; 10
(push) ; 10
; [else-branch: 134 | !(0 <= i1@131@04)]
(assert (not (<= 0 i1@131@04)))
(pop) ; 10
(pop) ; 9
; Joined path conditions
; Joined path conditions
(push) ; 9
; [then-branch: 135 | i1@131@04 < V@28@04 && 0 <= i1@131@04 | live]
; [else-branch: 135 | !(i1@131@04 < V@28@04 && 0 <= i1@131@04) | live]
(push) ; 10
; [then-branch: 135 | i1@131@04 < V@28@04 && 0 <= i1@131@04]
(assert (and (< i1@131@04 V@28@04) (<= 0 i1@131@04)))
; [eval] alen(opt_get1(aloc(opt_get1(source), i1).option$array$)) == V
; [eval] alen(opt_get1(aloc(opt_get1(source), i1).option$array$))
; [eval] opt_get1(aloc(opt_get1(source), i1).option$array$)
; [eval] aloc(opt_get1(source), i1)
; [eval] opt_get1(source)
(push) ; 11
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 11
; Joined path conditions
(push) ; 11
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 12
(assert (not (< i1@131@04 (alen<Int> (opt_get1 $Snap.unit source@26@04)))))
(check-sat)
; unsat
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               5771
;  :arith-add-rows          2936
;  :arith-assert-diseq      247
;  :arith-assert-lower      1409
;  :arith-assert-upper      831
;  :arith-bound-prop        459
;  :arith-conflicts         169
;  :arith-eq-adapter        893
;  :arith-fixed-eqs         359
;  :arith-grobner           10
;  :arith-max-min           141
;  :arith-nonlinear-bounds  13
;  :arith-nonlinear-horner  8
;  :arith-offset-eqs        397
;  :arith-pivots            1086
;  :conflicts               581
;  :datatype-accessor-ax    45
;  :datatype-constructor-ax 395
;  :datatype-occurs-check   140
;  :datatype-splits         71
;  :decisions               892
;  :del-clause              6496
;  :final-checks            106
;  :interface-eqs           2
;  :max-generation          4
;  :max-memory              6.66
;  :memory                  6.38
;  :minimized-lits          32
;  :mk-bool-var             10645
;  :mk-clause               6503
;  :num-allocs              292645
;  :num-checks              209
;  :propagations            2615
;  :quant-instantiations    2632
;  :rlimit-count            517974)
(assert (< i1@131@04 (alen<Int> (opt_get1 $Snap.unit source@26@04))))
(pop) ; 11
; Joined path conditions
(assert (< i1@131@04 (alen<Int> (opt_get1 $Snap.unit source@26@04))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@129@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@131@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@131@04)))
(push) ; 11
(assert (not (<
  $Perm.No
  (+
    (+
      (ite
        (and
          (<
            (inv@128@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@131@04))
            V@28@04)
          (<=
            0
            (inv@128@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@131@04))))
        (*
          (scale $Snap.unit (* (to_real (* V@28@04 V@28@04)) $Perm.Write))
          $k@127@04)
        $Perm.No)
      (-
        (-
          (ite
            (and
              (<
                (inv@42@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@131@04))
                V@28@04)
              (<=
                0
                (inv@42@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@131@04))))
            $k@41@04
            $Perm.No)
          (pTaken@95@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@131@04)))
        (pTaken@106@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@131@04))))
    (-
      (-
        (ite
          (and
            (<
              (inv@34@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@131@04))
              V@28@04)
            (<=
              0
              (inv@34@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@131@04))))
          $k@33@04
          $Perm.No)
        (pTaken@96@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@131@04)))
      (pTaken@105@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@131@04)))))))
(check-sat)
; unsat
(pop) ; 11
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               6261
;  :arith-add-rows          3402
;  :arith-assert-diseq      279
;  :arith-assert-lower      1571
;  :arith-assert-upper      945
;  :arith-bound-prop        515
;  :arith-conflicts         180
;  :arith-eq-adapter        1011
;  :arith-fixed-eqs         428
;  :arith-grobner           10
;  :arith-max-min           141
;  :arith-nonlinear-bounds  13
;  :arith-nonlinear-horner  8
;  :arith-offset-eqs        459
;  :arith-pivots            1156
;  :conflicts               611
;  :datatype-accessor-ax    45
;  :datatype-constructor-ax 399
;  :datatype-occurs-check   140
;  :datatype-splits         71
;  :decisions               978
;  :del-clause              7023
;  :final-checks            106
;  :interface-eqs           2
;  :max-generation          5
;  :max-memory              6.66
;  :memory                  6.48
;  :minimized-lits          41
;  :mk-bool-var             11414
;  :mk-clause               7128
;  :num-allocs              295728
;  :num-checks              210
;  :propagations            3010
;  :quant-instantiations    2775
;  :rlimit-count            536029
;  :time                    0.01)
(push) ; 11
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 12
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@129@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@131@04))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               6261
;  :arith-add-rows          3402
;  :arith-assert-diseq      279
;  :arith-assert-lower      1571
;  :arith-assert-upper      945
;  :arith-bound-prop        515
;  :arith-conflicts         180
;  :arith-eq-adapter        1011
;  :arith-fixed-eqs         428
;  :arith-grobner           10
;  :arith-max-min           141
;  :arith-nonlinear-bounds  13
;  :arith-nonlinear-horner  8
;  :arith-offset-eqs        459
;  :arith-pivots            1156
;  :conflicts               612
;  :datatype-accessor-ax    45
;  :datatype-constructor-ax 399
;  :datatype-occurs-check   140
;  :datatype-splits         71
;  :decisions               978
;  :del-clause              7023
;  :final-checks            106
;  :interface-eqs           2
;  :max-generation          5
;  :max-memory              6.66
;  :memory                  6.48
;  :minimized-lits          41
;  :mk-bool-var             11414
;  :mk-clause               7128
;  :num-allocs              295819
;  :num-checks              211
;  :propagations            3010
;  :quant-instantiations    2775
;  :rlimit-count            536124)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@129@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@131@04))
    (as None<option<array>>  option<array>))))
(pop) ; 11
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@129@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@131@04))
    (as None<option<array>>  option<array>))))
(pop) ; 10
(push) ; 10
; [else-branch: 135 | !(i1@131@04 < V@28@04 && 0 <= i1@131@04)]
(assert (not (and (< i1@131@04 V@28@04) (<= 0 i1@131@04))))
(pop) ; 10
(pop) ; 9
; Joined path conditions
(assert (implies
  (and (< i1@131@04 V@28@04) (<= 0 i1@131@04))
  (and
    (< i1@131@04 V@28@04)
    (<= 0 i1@131@04)
    (< i1@131@04 (alen<Int> (opt_get1 $Snap.unit source@26@04)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@129@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@131@04)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@131@04))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@129@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@131@04))
        (as None<option<array>>  option<array>))))))
; Joined path conditions
(pop) ; 8
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@131@04 Int)) (!
  (implies
    (and (< i1@131@04 V@28@04) (<= 0 i1@131@04))
    (and
      (< i1@131@04 V@28@04)
      (<= 0 i1@131@04)
      (< i1@131@04 (alen<Int> (opt_get1 $Snap.unit source@26@04)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@129@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@131@04)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@131@04))
      (not
        (=
          ($FVF.lookup_option$array$ (as sm@129@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@131@04))
          (as None<option<array>>  option<array>)))))
  :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@129@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@131@04)))))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 7
(pop) ; 6
; Joined path conditions
(assert (implies
  (and (< 0 V@28@04) (= exc@123@04 $Ref.null))
  (and
    (< 0 V@28@04)
    (= exc@123@04 $Ref.null)
    (forall ((i1@131@04 Int)) (!
      (implies
        (and (< i1@131@04 V@28@04) (<= 0 i1@131@04))
        (and
          (< i1@131@04 V@28@04)
          (<= 0 i1@131@04)
          (< i1@131@04 (alen<Int> (opt_get1 $Snap.unit source@26@04)))
          ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@129@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@131@04)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@131@04))
          (not
            (=
              ($FVF.lookup_option$array$ (as sm@129@04  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@131@04))
              (as None<option<array>>  option<array>)))))
      :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@129@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@131@04)))))
      :qid |prog.l<no position>-aux|)))))
(assert (implies
  (and (< 0 V@28@04) (= exc@123@04 $Ref.null))
  (forall ((i1@131@04 Int)) (!
    (implies
      (and (< i1@131@04 V@28@04) (<= 0 i1@131@04))
      (=
        (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@129@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@131@04))))
        V@28@04))
    :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@129@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@131@04)))))
    :qid |prog.l<no position>|))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@04))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@04)))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@04))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@04)))))))
  $Snap.unit))
; [eval] exc == null && 0 < V ==> (forall i1: Int :: { aloc(opt_get1(source), i1) } (forall i2: Int :: { aloc(opt_get1(source), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(source), i1).option$array$ == aloc(opt_get1(source), i2).option$array$ ==> i1 == i2))
; [eval] exc == null && 0 < V
; [eval] exc == null
(push) ; 6
; [then-branch: 136 | exc@123@04 == Null | live]
; [else-branch: 136 | exc@123@04 != Null | live]
(push) ; 7
; [then-branch: 136 | exc@123@04 == Null]
(assert (= exc@123@04 $Ref.null))
; [eval] 0 < V
(pop) ; 7
(push) ; 7
; [else-branch: 136 | exc@123@04 != Null]
(assert (not (= exc@123@04 $Ref.null)))
(pop) ; 7
(pop) ; 6
; Joined path conditions
; Joined path conditions
(push) ; 6
(set-option :timeout 10)
(push) ; 7
(assert (not (not (and (< 0 V@28@04) (= exc@123@04 $Ref.null)))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               6292
;  :arith-add-rows          3421
;  :arith-assert-diseq      279
;  :arith-assert-lower      1586
;  :arith-assert-upper      953
;  :arith-bound-prop        515
;  :arith-conflicts         181
;  :arith-eq-adapter        1011
;  :arith-fixed-eqs         428
;  :arith-grobner           15
;  :arith-max-min           167
;  :arith-nonlinear-bounds  14
;  :arith-nonlinear-horner  12
;  :arith-offset-eqs        460
;  :arith-pivots            1166
;  :conflicts               613
;  :datatype-accessor-ax    46
;  :datatype-constructor-ax 405
;  :datatype-occurs-check   144
;  :datatype-splits         73
;  :decisions               985
;  :del-clause              7121
;  :final-checks            111
;  :interface-eqs           2
;  :max-generation          5
;  :max-memory              6.66
;  :memory                  6.47
;  :minimized-lits          41
;  :mk-bool-var             11420
;  :mk-clause               7128
;  :num-allocs              297133
;  :num-checks              212
;  :propagations            3013
;  :quant-instantiations    2775
;  :rlimit-count            538824)
(push) ; 7
(assert (not (and (< 0 V@28@04) (= exc@123@04 $Ref.null))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               6292
;  :arith-add-rows          3421
;  :arith-assert-diseq      279
;  :arith-assert-lower      1586
;  :arith-assert-upper      953
;  :arith-bound-prop        515
;  :arith-conflicts         181
;  :arith-eq-adapter        1011
;  :arith-fixed-eqs         428
;  :arith-grobner           15
;  :arith-max-min           167
;  :arith-nonlinear-bounds  14
;  :arith-nonlinear-horner  12
;  :arith-offset-eqs        460
;  :arith-pivots            1166
;  :conflicts               613
;  :datatype-accessor-ax    46
;  :datatype-constructor-ax 405
;  :datatype-occurs-check   144
;  :datatype-splits         73
;  :decisions               985
;  :del-clause              7121
;  :final-checks            111
;  :interface-eqs           2
;  :max-generation          5
;  :max-memory              6.66
;  :memory                  6.47
;  :minimized-lits          41
;  :mk-bool-var             11420
;  :mk-clause               7128
;  :num-allocs              297151
;  :num-checks              213
;  :propagations            3013
;  :quant-instantiations    2775
;  :rlimit-count            538841)
; [then-branch: 137 | 0 < V@28@04 && exc@123@04 == Null | live]
; [else-branch: 137 | !(0 < V@28@04 && exc@123@04 == Null) | dead]
(push) ; 7
; [then-branch: 137 | 0 < V@28@04 && exc@123@04 == Null]
(assert (and (< 0 V@28@04) (= exc@123@04 $Ref.null)))
; [eval] (forall i1: Int :: { aloc(opt_get1(source), i1) } (forall i2: Int :: { aloc(opt_get1(source), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(source), i1).option$array$ == aloc(opt_get1(source), i2).option$array$ ==> i1 == i2))
(declare-const i1@132@04 Int)
(push) ; 8
; [eval] (forall i2: Int :: { aloc(opt_get1(source), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(source), i1).option$array$ == aloc(opt_get1(source), i2).option$array$ ==> i1 == i2)
(declare-const i2@133@04 Int)
(push) ; 9
; [eval] 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(source), i1).option$array$ == aloc(opt_get1(source), i2).option$array$ ==> i1 == i2
; [eval] 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(source), i1).option$array$ == aloc(opt_get1(source), i2).option$array$
; [eval] 0 <= i1
(push) ; 10
; [then-branch: 138 | 0 <= i1@132@04 | live]
; [else-branch: 138 | !(0 <= i1@132@04) | live]
(push) ; 11
; [then-branch: 138 | 0 <= i1@132@04]
(assert (<= 0 i1@132@04))
; [eval] i1 < V
(push) ; 12
; [then-branch: 139 | i1@132@04 < V@28@04 | live]
; [else-branch: 139 | !(i1@132@04 < V@28@04) | live]
(push) ; 13
; [then-branch: 139 | i1@132@04 < V@28@04]
(assert (< i1@132@04 V@28@04))
; [eval] 0 <= i2
(push) ; 14
; [then-branch: 140 | 0 <= i2@133@04 | live]
; [else-branch: 140 | !(0 <= i2@133@04) | live]
(push) ; 15
; [then-branch: 140 | 0 <= i2@133@04]
(assert (<= 0 i2@133@04))
; [eval] i2 < V
(push) ; 16
; [then-branch: 141 | i2@133@04 < V@28@04 | live]
; [else-branch: 141 | !(i2@133@04 < V@28@04) | live]
(push) ; 17
; [then-branch: 141 | i2@133@04 < V@28@04]
(assert (< i2@133@04 V@28@04))
; [eval] aloc(opt_get1(source), i1).option$array$ == aloc(opt_get1(source), i2).option$array$
; [eval] aloc(opt_get1(source), i1)
; [eval] opt_get1(source)
(push) ; 18
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 18
; Joined path conditions
(push) ; 18
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 19
(assert (not (< i1@132@04 (alen<Int> (opt_get1 $Snap.unit source@26@04)))))
(check-sat)
; unsat
(pop) ; 19
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               6292
;  :arith-add-rows          3421
;  :arith-assert-diseq      279
;  :arith-assert-lower      1590
;  :arith-assert-upper      953
;  :arith-bound-prop        515
;  :arith-conflicts         181
;  :arith-eq-adapter        1011
;  :arith-fixed-eqs         428
;  :arith-grobner           15
;  :arith-max-min           167
;  :arith-nonlinear-bounds  14
;  :arith-nonlinear-horner  12
;  :arith-offset-eqs        460
;  :arith-pivots            1167
;  :conflicts               613
;  :datatype-accessor-ax    46
;  :datatype-constructor-ax 405
;  :datatype-occurs-check   144
;  :datatype-splits         73
;  :decisions               985
;  :del-clause              7121
;  :final-checks            111
;  :interface-eqs           2
;  :max-generation          5
;  :max-memory              6.66
;  :memory                  6.47
;  :minimized-lits          41
;  :mk-bool-var             11424
;  :mk-clause               7128
;  :num-allocs              297432
;  :num-checks              214
;  :propagations            3013
;  :quant-instantiations    2775
;  :rlimit-count            539194)
(assert (< i1@132@04 (alen<Int> (opt_get1 $Snap.unit source@26@04))))
(pop) ; 18
; Joined path conditions
(assert (< i1@132@04 (alen<Int> (opt_get1 $Snap.unit source@26@04))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@129@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@132@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@132@04)))
(push) ; 18
(assert (not (<
  $Perm.No
  (+
    (+
      (ite
        (and
          (<
            (inv@128@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@132@04))
            V@28@04)
          (<=
            0
            (inv@128@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@132@04))))
        (*
          (scale $Snap.unit (* (to_real (* V@28@04 V@28@04)) $Perm.Write))
          $k@127@04)
        $Perm.No)
      (-
        (-
          (ite
            (and
              (<
                (inv@42@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@132@04))
                V@28@04)
              (<=
                0
                (inv@42@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@132@04))))
            $k@41@04
            $Perm.No)
          (pTaken@95@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@132@04)))
        (pTaken@106@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@132@04))))
    (-
      (-
        (ite
          (and
            (<
              (inv@34@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@132@04))
              V@28@04)
            (<=
              0
              (inv@34@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@132@04))))
          $k@33@04
          $Perm.No)
        (pTaken@96@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@132@04)))
      (pTaken@105@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@132@04)))))))
(check-sat)
; unsat
(pop) ; 18
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               6727
;  :arith-add-rows          3892
;  :arith-assert-diseq      310
;  :arith-assert-lower      1737
;  :arith-assert-upper      1051
;  :arith-bound-prop        552
;  :arith-conflicts         194
;  :arith-eq-adapter        1126
;  :arith-fixed-eqs         476
;  :arith-grobner           15
;  :arith-max-min           167
;  :arith-nonlinear-bounds  14
;  :arith-nonlinear-horner  12
;  :arith-offset-eqs        518
;  :arith-pivots            1235
;  :conflicts               643
;  :datatype-accessor-ax    46
;  :datatype-constructor-ax 409
;  :datatype-occurs-check   144
;  :datatype-splits         73
;  :decisions               1043
;  :del-clause              7465
;  :final-checks            111
;  :interface-eqs           2
;  :max-generation          5
;  :max-memory              6.66
;  :memory                  6.48
;  :minimized-lits          44
;  :mk-bool-var             12002
;  :mk-clause               7570
;  :num-allocs              299988
;  :num-checks              215
;  :propagations            3390
;  :quant-instantiations    2860
;  :rlimit-count            555217
;  :time                    0.00)
; [eval] aloc(opt_get1(source), i2)
; [eval] opt_get1(source)
(push) ; 18
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 18
; Joined path conditions
(push) ; 18
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 19
(assert (not (< i2@133@04 (alen<Int> (opt_get1 $Snap.unit source@26@04)))))
(check-sat)
; unsat
(pop) ; 19
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               6727
;  :arith-add-rows          3892
;  :arith-assert-diseq      310
;  :arith-assert-lower      1737
;  :arith-assert-upper      1051
;  :arith-bound-prop        552
;  :arith-conflicts         194
;  :arith-eq-adapter        1126
;  :arith-fixed-eqs         476
;  :arith-grobner           15
;  :arith-max-min           167
;  :arith-nonlinear-bounds  14
;  :arith-nonlinear-horner  12
;  :arith-offset-eqs        518
;  :arith-pivots            1235
;  :conflicts               643
;  :datatype-accessor-ax    46
;  :datatype-constructor-ax 409
;  :datatype-occurs-check   144
;  :datatype-splits         73
;  :decisions               1043
;  :del-clause              7465
;  :final-checks            111
;  :interface-eqs           2
;  :max-generation          5
;  :max-memory              6.66
;  :memory                  6.48
;  :minimized-lits          44
;  :mk-bool-var             12002
;  :mk-clause               7570
;  :num-allocs              300015
;  :num-checks              216
;  :propagations            3390
;  :quant-instantiations    2860
;  :rlimit-count            555247)
(assert (< i2@133@04 (alen<Int> (opt_get1 $Snap.unit source@26@04))))
(pop) ; 18
; Joined path conditions
(assert (< i2@133@04 (alen<Int> (opt_get1 $Snap.unit source@26@04))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@129@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@133@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@133@04)))
(push) ; 18
(assert (not (<
  $Perm.No
  (+
    (+
      (ite
        (and
          (<
            (inv@128@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@133@04))
            V@28@04)
          (<=
            0
            (inv@128@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@133@04))))
        (*
          (scale $Snap.unit (* (to_real (* V@28@04 V@28@04)) $Perm.Write))
          $k@127@04)
        $Perm.No)
      (-
        (-
          (ite
            (and
              (<
                (inv@42@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@133@04))
                V@28@04)
              (<=
                0
                (inv@42@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@133@04))))
            $k@41@04
            $Perm.No)
          (pTaken@95@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@133@04)))
        (pTaken@106@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@133@04))))
    (-
      (-
        (ite
          (and
            (<
              (inv@34@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@133@04))
              V@28@04)
            (<=
              0
              (inv@34@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@133@04))))
          $k@33@04
          $Perm.No)
        (pTaken@96@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@133@04)))
      (pTaken@105@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@133@04)))))))
(check-sat)
; unsat
(pop) ; 18
; 0.02s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               7712
;  :arith-add-rows          4838
;  :arith-assert-diseq      398
;  :arith-assert-lower      2105
;  :arith-assert-upper      1218
;  :arith-bound-prop        613
;  :arith-conflicts         208
;  :arith-eq-adapter        1341
;  :arith-fixed-eqs         573
;  :arith-grobner           15
;  :arith-max-min           167
;  :arith-nonlinear-bounds  14
;  :arith-nonlinear-horner  12
;  :arith-offset-eqs        639
;  :arith-pivots            1329
;  :conflicts               680
;  :datatype-accessor-ax    46
;  :datatype-constructor-ax 413
;  :datatype-occurs-check   144
;  :datatype-splits         73
;  :decisions               1189
;  :del-clause              8398
;  :final-checks            111
;  :interface-eqs           2
;  :max-generation          5
;  :max-memory              6.66
;  :memory                  6.64
;  :minimized-lits          48
;  :mk-bool-var             13376
;  :mk-clause               8611
;  :num-allocs              306469
;  :num-checks              217
;  :propagations            4238
;  :quant-instantiations    3226
;  :rlimit-count            591622
;  :time                    0.01)
(pop) ; 17
(push) ; 17
; [else-branch: 141 | !(i2@133@04 < V@28@04)]
(assert (not (< i2@133@04 V@28@04)))
(pop) ; 17
(pop) ; 16
; Joined path conditions
(assert (implies
  (< i2@133@04 V@28@04)
  (and
    (< i2@133@04 V@28@04)
    (< i1@132@04 (alen<Int> (opt_get1 $Snap.unit source@26@04)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@129@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@132@04)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@132@04))
    (< i2@133@04 (alen<Int> (opt_get1 $Snap.unit source@26@04)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@129@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@133@04)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@133@04)))))
; Joined path conditions
(pop) ; 15
(push) ; 15
; [else-branch: 140 | !(0 <= i2@133@04)]
(assert (not (<= 0 i2@133@04)))
(pop) ; 15
(pop) ; 14
; Joined path conditions
(assert (implies
  (<= 0 i2@133@04)
  (and
    (<= 0 i2@133@04)
    (implies
      (< i2@133@04 V@28@04)
      (and
        (< i2@133@04 V@28@04)
        (< i1@132@04 (alen<Int> (opt_get1 $Snap.unit source@26@04)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@129@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@132@04)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@132@04))
        (< i2@133@04 (alen<Int> (opt_get1 $Snap.unit source@26@04)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@129@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@133@04)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@133@04)))))))
; Joined path conditions
(pop) ; 13
(push) ; 13
; [else-branch: 139 | !(i1@132@04 < V@28@04)]
(assert (not (< i1@132@04 V@28@04)))
(pop) ; 13
(pop) ; 12
; Joined path conditions
(assert (implies
  (< i1@132@04 V@28@04)
  (and
    (< i1@132@04 V@28@04)
    (implies
      (<= 0 i2@133@04)
      (and
        (<= 0 i2@133@04)
        (implies
          (< i2@133@04 V@28@04)
          (and
            (< i2@133@04 V@28@04)
            (< i1@132@04 (alen<Int> (opt_get1 $Snap.unit source@26@04)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@129@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@132@04)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@132@04))
            (< i2@133@04 (alen<Int> (opt_get1 $Snap.unit source@26@04)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@129@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@133@04)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@133@04)))))))))
; Joined path conditions
(pop) ; 11
(push) ; 11
; [else-branch: 138 | !(0 <= i1@132@04)]
(assert (not (<= 0 i1@132@04)))
(pop) ; 11
(pop) ; 10
; Joined path conditions
(assert (implies
  (<= 0 i1@132@04)
  (and
    (<= 0 i1@132@04)
    (implies
      (< i1@132@04 V@28@04)
      (and
        (< i1@132@04 V@28@04)
        (implies
          (<= 0 i2@133@04)
          (and
            (<= 0 i2@133@04)
            (implies
              (< i2@133@04 V@28@04)
              (and
                (< i2@133@04 V@28@04)
                (< i1@132@04 (alen<Int> (opt_get1 $Snap.unit source@26@04)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@129@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@132@04)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@132@04))
                (< i2@133@04 (alen<Int> (opt_get1 $Snap.unit source@26@04)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@129@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@133@04)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@133@04)))))))))))
; Joined path conditions
(push) ; 10
; [then-branch: 142 | Lookup(option$array$,sm@129@04,aloc((_, _), opt_get1(_, source@26@04), i1@132@04)) == Lookup(option$array$,sm@129@04,aloc((_, _), opt_get1(_, source@26@04), i2@133@04)) && i2@133@04 < V@28@04 && 0 <= i2@133@04 && i1@132@04 < V@28@04 && 0 <= i1@132@04 | live]
; [else-branch: 142 | !(Lookup(option$array$,sm@129@04,aloc((_, _), opt_get1(_, source@26@04), i1@132@04)) == Lookup(option$array$,sm@129@04,aloc((_, _), opt_get1(_, source@26@04), i2@133@04)) && i2@133@04 < V@28@04 && 0 <= i2@133@04 && i1@132@04 < V@28@04 && 0 <= i1@132@04) | live]
(push) ; 11
; [then-branch: 142 | Lookup(option$array$,sm@129@04,aloc((_, _), opt_get1(_, source@26@04), i1@132@04)) == Lookup(option$array$,sm@129@04,aloc((_, _), opt_get1(_, source@26@04), i2@133@04)) && i2@133@04 < V@28@04 && 0 <= i2@133@04 && i1@132@04 < V@28@04 && 0 <= i1@132@04]
(assert (and
  (and
    (and
      (and
        (=
          ($FVF.lookup_option$array$ (as sm@129@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@132@04))
          ($FVF.lookup_option$array$ (as sm@129@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@133@04)))
        (< i2@133@04 V@28@04))
      (<= 0 i2@133@04))
    (< i1@132@04 V@28@04))
  (<= 0 i1@132@04)))
; [eval] i1 == i2
(pop) ; 11
(push) ; 11
; [else-branch: 142 | !(Lookup(option$array$,sm@129@04,aloc((_, _), opt_get1(_, source@26@04), i1@132@04)) == Lookup(option$array$,sm@129@04,aloc((_, _), opt_get1(_, source@26@04), i2@133@04)) && i2@133@04 < V@28@04 && 0 <= i2@133@04 && i1@132@04 < V@28@04 && 0 <= i1@132@04)]
(assert (not
  (and
    (and
      (and
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@129@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@132@04))
            ($FVF.lookup_option$array$ (as sm@129@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@133@04)))
          (< i2@133@04 V@28@04))
        (<= 0 i2@133@04))
      (< i1@132@04 V@28@04))
    (<= 0 i1@132@04))))
(pop) ; 11
(pop) ; 10
; Joined path conditions
(assert (implies
  (and
    (and
      (and
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@129@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@132@04))
            ($FVF.lookup_option$array$ (as sm@129@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@133@04)))
          (< i2@133@04 V@28@04))
        (<= 0 i2@133@04))
      (< i1@132@04 V@28@04))
    (<= 0 i1@132@04))
  (and
    (=
      ($FVF.lookup_option$array$ (as sm@129@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@132@04))
      ($FVF.lookup_option$array$ (as sm@129@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@133@04)))
    (< i2@133@04 V@28@04)
    (<= 0 i2@133@04)
    (< i1@132@04 V@28@04)
    (<= 0 i1@132@04))))
; Joined path conditions
(pop) ; 9
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i2@133@04 Int)) (!
  (and
    (implies
      (<= 0 i1@132@04)
      (and
        (<= 0 i1@132@04)
        (implies
          (< i1@132@04 V@28@04)
          (and
            (< i1@132@04 V@28@04)
            (implies
              (<= 0 i2@133@04)
              (and
                (<= 0 i2@133@04)
                (implies
                  (< i2@133@04 V@28@04)
                  (and
                    (< i2@133@04 V@28@04)
                    (< i1@132@04 (alen<Int> (opt_get1 $Snap.unit source@26@04)))
                    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@129@04  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@132@04)) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@132@04))
                    (< i2@133@04 (alen<Int> (opt_get1 $Snap.unit source@26@04)))
                    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@129@04  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@133@04)) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@133@04))))))))))
    (implies
      (and
        (and
          (and
            (and
              (=
                ($FVF.lookup_option$array$ (as sm@129@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@132@04))
                ($FVF.lookup_option$array$ (as sm@129@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@133@04)))
              (< i2@133@04 V@28@04))
            (<= 0 i2@133@04))
          (< i1@132@04 V@28@04))
        (<= 0 i1@132@04))
      (and
        (=
          ($FVF.lookup_option$array$ (as sm@129@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@132@04))
          ($FVF.lookup_option$array$ (as sm@129@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@133@04)))
        (< i2@133@04 V@28@04)
        (<= 0 i2@133@04)
        (< i1@132@04 V@28@04)
        (<= 0 i1@132@04))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@133@04))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 8
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@132@04 Int)) (!
  (forall ((i2@133@04 Int)) (!
    (and
      (implies
        (<= 0 i1@132@04)
        (and
          (<= 0 i1@132@04)
          (implies
            (< i1@132@04 V@28@04)
            (and
              (< i1@132@04 V@28@04)
              (implies
                (<= 0 i2@133@04)
                (and
                  (<= 0 i2@133@04)
                  (implies
                    (< i2@133@04 V@28@04)
                    (and
                      (< i2@133@04 V@28@04)
                      (<
                        i1@132@04
                        (alen<Int> (opt_get1 $Snap.unit source@26@04)))
                      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@129@04  $FVF<option<array>>) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@132@04)) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@132@04))
                      (<
                        i2@133@04
                        (alen<Int> (opt_get1 $Snap.unit source@26@04)))
                      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@129@04  $FVF<option<array>>) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@133@04)) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@133@04))))))))))
      (implies
        (and
          (and
            (and
              (and
                (=
                  ($FVF.lookup_option$array$ (as sm@129@04  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@132@04))
                  ($FVF.lookup_option$array$ (as sm@129@04  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@133@04)))
                (< i2@133@04 V@28@04))
              (<= 0 i2@133@04))
            (< i1@132@04 V@28@04))
          (<= 0 i1@132@04))
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@129@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@132@04))
            ($FVF.lookup_option$array$ (as sm@129@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@133@04)))
          (< i2@133@04 V@28@04)
          (<= 0 i2@133@04)
          (< i1@132@04 V@28@04)
          (<= 0 i1@132@04))))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@133@04))
    :qid |prog.l<no position>-aux|))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@132@04))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 7
(pop) ; 6
; Joined path conditions
(assert (implies
  (and (< 0 V@28@04) (= exc@123@04 $Ref.null))
  (and
    (< 0 V@28@04)
    (= exc@123@04 $Ref.null)
    (forall ((i1@132@04 Int)) (!
      (forall ((i2@133@04 Int)) (!
        (and
          (implies
            (<= 0 i1@132@04)
            (and
              (<= 0 i1@132@04)
              (implies
                (< i1@132@04 V@28@04)
                (and
                  (< i1@132@04 V@28@04)
                  (implies
                    (<= 0 i2@133@04)
                    (and
                      (<= 0 i2@133@04)
                      (implies
                        (< i2@133@04 V@28@04)
                        (and
                          (< i2@133@04 V@28@04)
                          (<
                            i1@132@04
                            (alen<Int> (opt_get1 $Snap.unit source@26@04)))
                          ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@129@04  $FVF<option<array>>) (aloc ($Snap.combine
                            $Snap.unit
                            $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@132@04)) (aloc ($Snap.combine
                            $Snap.unit
                            $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@132@04))
                          (<
                            i2@133@04
                            (alen<Int> (opt_get1 $Snap.unit source@26@04)))
                          ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@129@04  $FVF<option<array>>) (aloc ($Snap.combine
                            $Snap.unit
                            $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@133@04)) (aloc ($Snap.combine
                            $Snap.unit
                            $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@133@04))))))))))
          (implies
            (and
              (and
                (and
                  (and
                    (=
                      ($FVF.lookup_option$array$ (as sm@129@04  $FVF<option<array>>) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@132@04))
                      ($FVF.lookup_option$array$ (as sm@129@04  $FVF<option<array>>) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@133@04)))
                    (< i2@133@04 V@28@04))
                  (<= 0 i2@133@04))
                (< i1@132@04 V@28@04))
              (<= 0 i1@132@04))
            (and
              (=
                ($FVF.lookup_option$array$ (as sm@129@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@132@04))
                ($FVF.lookup_option$array$ (as sm@129@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@133@04)))
              (< i2@133@04 V@28@04)
              (<= 0 i2@133@04)
              (< i1@132@04 V@28@04)
              (<= 0 i1@132@04))))
        :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@133@04))
        :qid |prog.l<no position>-aux|))
      :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@132@04))
      :qid |prog.l<no position>-aux|)))))
(assert (implies
  (and (< 0 V@28@04) (= exc@123@04 $Ref.null))
  (forall ((i1@132@04 Int)) (!
    (forall ((i2@133@04 Int)) (!
      (implies
        (and
          (and
            (and
              (and
                (=
                  ($FVF.lookup_option$array$ (as sm@129@04  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@132@04))
                  ($FVF.lookup_option$array$ (as sm@129@04  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@133@04)))
                (< i2@133@04 V@28@04))
              (<= 0 i2@133@04))
            (< i1@132@04 V@28@04))
          (<= 0 i1@132@04))
        (= i1@132@04 i2@133@04))
      :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@133@04))
      :qid |prog.l<no position>|))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@132@04))
    :qid |prog.l<no position>|))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@04)))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@04))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@04)))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@04))))))))
  $Snap.unit))
; [eval] exc == null && 0 < V ==> target != (None(): option[array])
; [eval] exc == null && 0 < V
; [eval] exc == null
(push) ; 6
; [then-branch: 143 | exc@123@04 == Null | live]
; [else-branch: 143 | exc@123@04 != Null | live]
(push) ; 7
; [then-branch: 143 | exc@123@04 == Null]
(assert (= exc@123@04 $Ref.null))
; [eval] 0 < V
(pop) ; 7
(push) ; 7
; [else-branch: 143 | exc@123@04 != Null]
(assert (not (= exc@123@04 $Ref.null)))
(pop) ; 7
(pop) ; 6
; Joined path conditions
; Joined path conditions
(push) ; 6
(set-option :timeout 10)
(push) ; 7
(assert (not (not (and (< 0 V@28@04) (= exc@123@04 $Ref.null)))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               7744
;  :arith-add-rows          4868
;  :arith-assert-diseq      398
;  :arith-assert-lower      2120
;  :arith-assert-upper      1226
;  :arith-bound-prop        613
;  :arith-conflicts         209
;  :arith-eq-adapter        1341
;  :arith-fixed-eqs         573
;  :arith-grobner           20
;  :arith-max-min           193
;  :arith-nonlinear-bounds  15
;  :arith-nonlinear-horner  16
;  :arith-offset-eqs        640
;  :arith-pivots            1351
;  :conflicts               681
;  :datatype-accessor-ax    47
;  :datatype-constructor-ax 419
;  :datatype-occurs-check   148
;  :datatype-splits         75
;  :decisions               1196
;  :del-clause              8628
;  :final-checks            116
;  :interface-eqs           2
;  :max-generation          5
;  :max-memory              6.66
;  :memory                  6.62
;  :minimized-lits          48
;  :mk-bool-var             13395
;  :mk-clause               8635
;  :num-allocs              308334
;  :num-checks              218
;  :propagations            4241
;  :quant-instantiations    3226
;  :rlimit-count            596191
;  :time                    0.00)
(push) ; 7
(assert (not (and (< 0 V@28@04) (= exc@123@04 $Ref.null))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               7744
;  :arith-add-rows          4868
;  :arith-assert-diseq      398
;  :arith-assert-lower      2120
;  :arith-assert-upper      1226
;  :arith-bound-prop        613
;  :arith-conflicts         209
;  :arith-eq-adapter        1341
;  :arith-fixed-eqs         573
;  :arith-grobner           20
;  :arith-max-min           193
;  :arith-nonlinear-bounds  15
;  :arith-nonlinear-horner  16
;  :arith-offset-eqs        640
;  :arith-pivots            1351
;  :conflicts               681
;  :datatype-accessor-ax    47
;  :datatype-constructor-ax 419
;  :datatype-occurs-check   148
;  :datatype-splits         75
;  :decisions               1196
;  :del-clause              8628
;  :final-checks            116
;  :interface-eqs           2
;  :max-generation          5
;  :max-memory              6.66
;  :memory                  6.62
;  :minimized-lits          48
;  :mk-bool-var             13395
;  :mk-clause               8635
;  :num-allocs              308352
;  :num-checks              219
;  :propagations            4241
;  :quant-instantiations    3226
;  :rlimit-count            596208)
; [then-branch: 144 | 0 < V@28@04 && exc@123@04 == Null | live]
; [else-branch: 144 | !(0 < V@28@04 && exc@123@04 == Null) | dead]
(push) ; 7
; [then-branch: 144 | 0 < V@28@04 && exc@123@04 == Null]
(assert (and (< 0 V@28@04) (= exc@123@04 $Ref.null)))
; [eval] target != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 7
(pop) ; 6
; Joined path conditions
(assert (implies
  (and (< 0 V@28@04) (= exc@123@04 $Ref.null))
  (not (= target@27@04 (as None<option<array>>  option<array>)))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@04))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@04)))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@04))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@04)))))))))
  $Snap.unit))
; [eval] exc == null && 0 < V ==> alen(opt_get1(target)) == V
; [eval] exc == null && 0 < V
; [eval] exc == null
(push) ; 6
; [then-branch: 145 | exc@123@04 == Null | live]
; [else-branch: 145 | exc@123@04 != Null | live]
(push) ; 7
; [then-branch: 145 | exc@123@04 == Null]
(assert (= exc@123@04 $Ref.null))
; [eval] 0 < V
(pop) ; 7
(push) ; 7
; [else-branch: 145 | exc@123@04 != Null]
(assert (not (= exc@123@04 $Ref.null)))
(pop) ; 7
(pop) ; 6
; Joined path conditions
; Joined path conditions
(push) ; 6
(push) ; 7
(assert (not (not (and (< 0 V@28@04) (= exc@123@04 $Ref.null)))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               7777
;  :arith-add-rows          4868
;  :arith-assert-diseq      398
;  :arith-assert-lower      2135
;  :arith-assert-upper      1234
;  :arith-bound-prop        613
;  :arith-conflicts         210
;  :arith-eq-adapter        1341
;  :arith-fixed-eqs         573
;  :arith-grobner           25
;  :arith-max-min           219
;  :arith-nonlinear-bounds  16
;  :arith-nonlinear-horner  20
;  :arith-offset-eqs        641
;  :arith-pivots            1351
;  :conflicts               682
;  :datatype-accessor-ax    48
;  :datatype-constructor-ax 425
;  :datatype-occurs-check   152
;  :datatype-splits         77
;  :decisions               1203
;  :del-clause              8628
;  :final-checks            121
;  :interface-eqs           2
;  :max-generation          5
;  :max-memory              6.66
;  :memory                  6.62
;  :minimized-lits          48
;  :mk-bool-var             13399
;  :mk-clause               8635
;  :num-allocs              309265
;  :num-checks              220
;  :propagations            4244
;  :quant-instantiations    3226
;  :rlimit-count            597769)
(push) ; 7
(assert (not (and (< 0 V@28@04) (= exc@123@04 $Ref.null))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               7777
;  :arith-add-rows          4868
;  :arith-assert-diseq      398
;  :arith-assert-lower      2135
;  :arith-assert-upper      1234
;  :arith-bound-prop        613
;  :arith-conflicts         210
;  :arith-eq-adapter        1341
;  :arith-fixed-eqs         573
;  :arith-grobner           25
;  :arith-max-min           219
;  :arith-nonlinear-bounds  16
;  :arith-nonlinear-horner  20
;  :arith-offset-eqs        641
;  :arith-pivots            1351
;  :conflicts               682
;  :datatype-accessor-ax    48
;  :datatype-constructor-ax 425
;  :datatype-occurs-check   152
;  :datatype-splits         77
;  :decisions               1203
;  :del-clause              8628
;  :final-checks            121
;  :interface-eqs           2
;  :max-generation          5
;  :max-memory              6.66
;  :memory                  6.62
;  :minimized-lits          48
;  :mk-bool-var             13399
;  :mk-clause               8635
;  :num-allocs              309283
;  :num-checks              221
;  :propagations            4244
;  :quant-instantiations    3226
;  :rlimit-count            597786)
; [then-branch: 146 | 0 < V@28@04 && exc@123@04 == Null | live]
; [else-branch: 146 | !(0 < V@28@04 && exc@123@04 == Null) | dead]
(push) ; 7
; [then-branch: 146 | 0 < V@28@04 && exc@123@04 == Null]
(assert (and (< 0 V@28@04) (= exc@123@04 $Ref.null)))
; [eval] alen(opt_get1(target)) == V
; [eval] alen(opt_get1(target))
; [eval] opt_get1(target)
(push) ; 8
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 8
; Joined path conditions
(pop) ; 7
(pop) ; 6
; Joined path conditions
(assert (implies
  (and (< 0 V@28@04) (= exc@123@04 $Ref.null))
  (= (alen<Int> (opt_get1 $Snap.unit target@27@04)) V@28@04)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@04)))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@04))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@04)))))))))))))
; [eval] exc == null && 0 < V
; [eval] exc == null
(push) ; 6
; [then-branch: 147 | exc@123@04 == Null | live]
; [else-branch: 147 | exc@123@04 != Null | live]
(push) ; 7
; [then-branch: 147 | exc@123@04 == Null]
(assert (= exc@123@04 $Ref.null))
; [eval] 0 < V
(pop) ; 7
(push) ; 7
; [else-branch: 147 | exc@123@04 != Null]
(assert (not (= exc@123@04 $Ref.null)))
(pop) ; 7
(pop) ; 6
; Joined path conditions
; Joined path conditions
(push) ; 6
(assert (not (not (and (< 0 V@28@04) (= exc@123@04 $Ref.null)))))
(check-sat)
; unknown
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               7812
;  :arith-add-rows          4868
;  :arith-assert-diseq      398
;  :arith-assert-lower      2150
;  :arith-assert-upper      1242
;  :arith-bound-prop        613
;  :arith-conflicts         211
;  :arith-eq-adapter        1341
;  :arith-fixed-eqs         573
;  :arith-grobner           30
;  :arith-max-min           245
;  :arith-nonlinear-bounds  17
;  :arith-nonlinear-horner  24
;  :arith-offset-eqs        642
;  :arith-pivots            1351
;  :conflicts               683
;  :datatype-accessor-ax    49
;  :datatype-constructor-ax 432
;  :datatype-occurs-check   156
;  :datatype-splits         80
;  :decisions               1211
;  :del-clause              8628
;  :final-checks            126
;  :interface-eqs           2
;  :max-generation          5
;  :max-memory              6.66
;  :memory                  6.62
;  :minimized-lits          48
;  :mk-bool-var             13403
;  :mk-clause               8635
;  :num-allocs              310203
;  :num-checks              222
;  :propagations            4247
;  :quant-instantiations    3226
;  :rlimit-count            599339
;  :time                    0.00)
(push) ; 6
(assert (not (and (< 0 V@28@04) (= exc@123@04 $Ref.null))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               7812
;  :arith-add-rows          4868
;  :arith-assert-diseq      398
;  :arith-assert-lower      2150
;  :arith-assert-upper      1242
;  :arith-bound-prop        613
;  :arith-conflicts         211
;  :arith-eq-adapter        1341
;  :arith-fixed-eqs         573
;  :arith-grobner           30
;  :arith-max-min           245
;  :arith-nonlinear-bounds  17
;  :arith-nonlinear-horner  24
;  :arith-offset-eqs        642
;  :arith-pivots            1351
;  :conflicts               683
;  :datatype-accessor-ax    49
;  :datatype-constructor-ax 432
;  :datatype-occurs-check   156
;  :datatype-splits         80
;  :decisions               1211
;  :del-clause              8628
;  :final-checks            126
;  :interface-eqs           2
;  :max-generation          5
;  :max-memory              6.66
;  :memory                  6.62
;  :minimized-lits          48
;  :mk-bool-var             13403
;  :mk-clause               8635
;  :num-allocs              310221
;  :num-checks              223
;  :propagations            4247
;  :quant-instantiations    3226
;  :rlimit-count            599356)
; [then-branch: 148 | 0 < V@28@04 && exc@123@04 == Null | live]
; [else-branch: 148 | !(0 < V@28@04 && exc@123@04 == Null) | dead]
(push) ; 6
; [then-branch: 148 | 0 < V@28@04 && exc@123@04 == Null]
(assert (and (< 0 V@28@04) (= exc@123@04 $Ref.null)))
(declare-const i1@134@04 Int)
(push) ; 7
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 8
; [then-branch: 149 | 0 <= i1@134@04 | live]
; [else-branch: 149 | !(0 <= i1@134@04) | live]
(push) ; 9
; [then-branch: 149 | 0 <= i1@134@04]
(assert (<= 0 i1@134@04))
; [eval] i1 < V
(pop) ; 9
(push) ; 9
; [else-branch: 149 | !(0 <= i1@134@04)]
(assert (not (<= 0 i1@134@04)))
(pop) ; 9
(pop) ; 8
; Joined path conditions
; Joined path conditions
(assert (and (< i1@134@04 V@28@04) (<= 0 i1@134@04)))
; [eval] aloc(opt_get1(target), i1)
; [eval] opt_get1(target)
(push) ; 8
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 8
; Joined path conditions
(push) ; 8
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 9
(assert (not (< i1@134@04 (alen<Int> (opt_get1 $Snap.unit target@27@04)))))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               7812
;  :arith-add-rows          4868
;  :arith-assert-diseq      398
;  :arith-assert-lower      2152
;  :arith-assert-upper      1242
;  :arith-bound-prop        613
;  :arith-conflicts         211
;  :arith-eq-adapter        1341
;  :arith-fixed-eqs         573
;  :arith-grobner           30
;  :arith-max-min           245
;  :arith-nonlinear-bounds  17
;  :arith-nonlinear-horner  24
;  :arith-offset-eqs        642
;  :arith-pivots            1351
;  :conflicts               683
;  :datatype-accessor-ax    49
;  :datatype-constructor-ax 432
;  :datatype-occurs-check   156
;  :datatype-splits         80
;  :decisions               1211
;  :del-clause              8628
;  :final-checks            126
;  :interface-eqs           2
;  :max-generation          5
;  :max-memory              6.66
;  :memory                  6.62
;  :minimized-lits          48
;  :mk-bool-var             13405
;  :mk-clause               8635
;  :num-allocs              310326
;  :num-checks              224
;  :propagations            4247
;  :quant-instantiations    3226
;  :rlimit-count            599550)
(assert (< i1@134@04 (alen<Int> (opt_get1 $Snap.unit target@27@04))))
(pop) ; 8
; Joined path conditions
(assert (< i1@134@04 (alen<Int> (opt_get1 $Snap.unit target@27@04))))
; [eval] scale(V * V * write) * wildcard
; [eval] scale(V * V * write)
; [eval] V * V * write
; [eval] V * V
(push) ; 8
; [eval] amount >= 0 * write
; [eval] 0 * write
(push) ; 9
(assert (not (>= (* (to_real (* V@28@04 V@28@04)) $Perm.Write) $Perm.No)))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               7823
;  :arith-add-rows          4868
;  :arith-assert-diseq      398
;  :arith-assert-lower      2156
;  :arith-assert-upper      1245
;  :arith-bound-prop        613
;  :arith-conflicts         212
;  :arith-eq-adapter        1341
;  :arith-fixed-eqs         573
;  :arith-grobner           30
;  :arith-max-min           254
;  :arith-nonlinear-bounds  18
;  :arith-nonlinear-horner  24
;  :arith-offset-eqs        642
;  :arith-pivots            1351
;  :conflicts               684
;  :datatype-accessor-ax    49
;  :datatype-constructor-ax 436
;  :datatype-occurs-check   156
;  :datatype-splits         80
;  :decisions               1215
;  :del-clause              8628
;  :final-checks            127
;  :interface-eqs           2
;  :max-generation          5
;  :max-memory              6.66
;  :memory                  6.61
;  :minimized-lits          48
;  :mk-bool-var             13405
;  :mk-clause               8635
;  :num-allocs              310500
;  :num-checks              225
;  :propagations            4247
;  :quant-instantiations    3226
;  :rlimit-count            599762)
(assert (>= (* (to_real (* V@28@04 V@28@04)) $Perm.Write) $Perm.No))
(pop) ; 8
; Joined path conditions
(assert (>= (* (to_real (* V@28@04 V@28@04)) $Perm.Write) $Perm.No))
(declare-const $k@135@04 $Perm)
(assert ($Perm.isReadVar $k@135@04 $Perm.Write))
(pop) ; 7
(declare-fun inv@136@04 ($Ref) Int)
; Nested auxiliary terms: globals
(assert ($Perm.isReadVar $k@135@04 $Perm.Write))
; Nested auxiliary terms: non-globals
(assert (forall ((i1@134@04 Int)) (!
  (and
    (< i1@134@04 (alen<Int> (opt_get1 $Snap.unit target@27@04)))
    (>= (* (to_real (* V@28@04 V@28@04)) $Perm.Write) $Perm.No))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@134@04))
  :qid |option$array$-aux|)))
(push) ; 7
(assert (not (forall ((i1@134@04 Int)) (!
  (implies
    (and (< i1@134@04 V@28@04) (<= 0 i1@134@04))
    (or
      (=
        (*
          (scale $Snap.unit (* (to_real (* V@28@04 V@28@04)) $Perm.Write))
          $k@135@04)
        $Perm.No)
      (<
        $Perm.No
        (*
          (scale $Snap.unit (* (to_real (* V@28@04 V@28@04)) $Perm.Write))
          $k@135@04))))
  
  ))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               7853
;  :arith-add-rows          4868
;  :arith-assert-diseq      400
;  :arith-assert-lower      2174
;  :arith-assert-upper      1256
;  :arith-bound-prop        613
;  :arith-conflicts         214
;  :arith-eq-adapter        1343
;  :arith-fixed-eqs         573
;  :arith-grobner           30
;  :arith-max-min           278
;  :arith-nonlinear-bounds  21
;  :arith-nonlinear-horner  24
;  :arith-offset-eqs        643
;  :arith-pivots            1351
;  :conflicts               690
;  :datatype-accessor-ax    49
;  :datatype-constructor-ax 443
;  :datatype-occurs-check   158
;  :datatype-splits         83
;  :decisions               1223
;  :del-clause              8631
;  :final-checks            130
;  :interface-eqs           2
;  :max-generation          5
;  :max-memory              6.66
;  :memory                  6.61
;  :minimized-lits          48
;  :mk-bool-var             13418
;  :mk-clause               8640
;  :num-allocs              311169
;  :num-checks              226
;  :propagations            4252
;  :quant-instantiations    3226
;  :rlimit-count            600792)
; Check receiver injectivity
(push) ; 7
(assert (not (forall ((i11@134@04 Int) (i12@134@04 Int)) (!
  (implies
    (and
      (and
        (and (< i11@134@04 V@28@04) (<= 0 i11@134@04))
        (<
          $Perm.No
          (*
            (scale $Snap.unit (* (to_real (* V@28@04 V@28@04)) $Perm.Write))
            $k@135@04)))
      (and
        (and (< i12@134@04 V@28@04) (<= 0 i12@134@04))
        (<
          $Perm.No
          (*
            (scale $Snap.unit (* (to_real (* V@28@04 V@28@04)) $Perm.Write))
            $k@135@04)))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i11@134@04)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i12@134@04)))
    (= i11@134@04 i12@134@04))
  
  :qid |option$array$-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               7861
;  :arith-add-rows          4872
;  :arith-assert-diseq      401
;  :arith-assert-lower      2179
;  :arith-assert-upper      1256
;  :arith-bound-prop        613
;  :arith-conflicts         214
;  :arith-eq-adapter        1344
;  :arith-fixed-eqs         573
;  :arith-grobner           30
;  :arith-max-min           278
;  :arith-nonlinear-bounds  21
;  :arith-nonlinear-horner  24
;  :arith-offset-eqs        643
;  :arith-pivots            1353
;  :conflicts               691
;  :datatype-accessor-ax    49
;  :datatype-constructor-ax 443
;  :datatype-occurs-check   158
;  :datatype-splits         83
;  :decisions               1223
;  :del-clause              8643
;  :final-checks            130
;  :interface-eqs           2
;  :max-generation          5
;  :max-memory              6.66
;  :memory                  6.61
;  :minimized-lits          48
;  :mk-bool-var             13441
;  :mk-clause               8652
;  :num-allocs              311578
;  :num-checks              227
;  :propagations            4256
;  :quant-instantiations    3241
;  :rlimit-count            601657)
; Definitional axioms for inverse functions
(assert (forall ((i1@134@04 Int)) (!
  (implies
    (and
      (and (< i1@134@04 V@28@04) (<= 0 i1@134@04))
      (<
        $Perm.No
        (*
          (scale $Snap.unit (* (to_real (* V@28@04 V@28@04)) $Perm.Write))
          $k@135@04)))
    (=
      (inv@136@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@134@04))
      i1@134@04))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@134@04))
  )))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and (< (inv@136@04 r) V@28@04) (<= 0 (inv@136@04 r)))
      (<
        $Perm.No
        (*
          (scale $Snap.unit (* (to_real (* V@28@04 V@28@04)) $Perm.Write))
          $k@135@04)))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) (inv@136@04 r))
      r))
  :pattern ((inv@136@04 r))
  :qid |option$array$-fctOfInv|)))
; Permissions are non-negative
(assert (forall ((i1@134@04 Int)) (!
  (<=
    $Perm.No
    (*
      (scale $Snap.unit (* (to_real (* V@28@04 V@28@04)) $Perm.Write))
      $k@135@04))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@134@04))
  :qid |option$array$-permAtLeastZero|)))
; Field permissions are at most one
(assert (forall ((i1@134@04 Int)) (!
  (<=
    (*
      (scale $Snap.unit (* (to_real (* V@28@04 V@28@04)) $Perm.Write))
      $k@135@04)
    $Perm.Write)
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@134@04))
  :qid |option$array$-permAtMostOne|)))
; Permission implies non-null receiver
(assert (forall ((i1@134@04 Int)) (!
  (implies
    (and
      (and (< i1@134@04 V@28@04) (<= 0 i1@134@04))
      (<
        $Perm.No
        (*
          (scale $Snap.unit (* (to_real (* V@28@04 V@28@04)) $Perm.Write))
          $k@135@04)))
    (not
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@134@04)
        $Ref.null)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@134@04))
  :qid |option$array$-permImpliesNonNull|)))
(declare-const sm@137@04 $FVF<option<array>>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@136@04 r) V@28@04) (<= 0 (inv@136@04 r)))
      (<
        $Perm.No
        (*
          (scale $Snap.unit (* (to_real (* V@28@04 V@28@04)) $Perm.Write))
          $k@135@04))
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@04))))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@04))))))))))) r))
  :qid |qp.fvfValDef36|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@128@04 r) V@28@04) (<= 0 (inv@128@04 r)))
      (<
        $Perm.No
        (*
          (scale $Snap.unit (* (to_real (* V@28@04 V@28@04)) $Perm.Write))
          $k@127@04))
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@125@04))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@125@04))))) r))
  :qid |qp.fvfValDef37|)))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (-
          (ite
            (and (< (inv@42@04 r) V@28@04) (<= 0 (inv@42@04 r)))
            $k@41@04
            $Perm.No)
          (pTaken@95@04 r))
        (pTaken@106@04 r)))
    (=
      ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@31@04))))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@31@04))))))))))) r))
  :qid |qp.fvfValDef38|)))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (-
          (ite
            (and (< (inv@34@04 r) V@28@04) (<= 0 (inv@34@04 r)))
            $k@33@04
            $Perm.No)
          (pTaken@96@04 r))
        (pTaken@105@04 r)))
    (=
      ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@31@04))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@31@04))))) r))
  :qid |qp.fvfValDef39|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@04))))))))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@125@04))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@31@04))))))))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@31@04))))) r) r))
  :pattern (($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef40|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@136@04 r) V@28@04) (<= 0 (inv@136@04 r)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) r) r))
  :pattern ((inv@136@04 r))
  )))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@04))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@04)))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@04))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@04)))))))))))
  $Snap.unit))
; [eval] exc == null && 0 < V ==> (forall i1: Int :: { aloc(opt_get1(target), i1) } 0 <= i1 && i1 < V ==> aloc(opt_get1(target), i1).option$array$ != (None(): option[array]))
; [eval] exc == null && 0 < V
; [eval] exc == null
(push) ; 7
; [then-branch: 150 | exc@123@04 == Null | live]
; [else-branch: 150 | exc@123@04 != Null | live]
(push) ; 8
; [then-branch: 150 | exc@123@04 == Null]
; [eval] 0 < V
(pop) ; 8
(push) ; 8
; [else-branch: 150 | exc@123@04 != Null]
(assert (not (= exc@123@04 $Ref.null)))
(pop) ; 8
(pop) ; 7
; Joined path conditions
; Joined path conditions
(push) ; 7
(set-option :timeout 10)
(push) ; 8
(assert (not (not (and (< 0 V@28@04) (= exc@123@04 $Ref.null)))))
(check-sat)
; unknown
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               7899
;  :arith-add-rows          4872
;  :arith-assert-diseq      401
;  :arith-assert-lower      2202
;  :arith-assert-upper      1271
;  :arith-bound-prop        613
;  :arith-conflicts         215
;  :arith-eq-adapter        1344
;  :arith-fixed-eqs         573
;  :arith-grobner           35
;  :arith-max-min           316
;  :arith-nonlinear-bounds  23
;  :arith-nonlinear-horner  28
;  :arith-offset-eqs        644
;  :arith-pivots            1353
;  :conflicts               692
;  :datatype-accessor-ax    50
;  :datatype-constructor-ax 450
;  :datatype-occurs-check   162
;  :datatype-splits         86
;  :decisions               1231
;  :del-clause              8643
;  :final-checks            135
;  :interface-eqs           2
;  :max-generation          5
;  :max-memory              6.66
;  :memory                  6.62
;  :minimized-lits          48
;  :mk-bool-var             13457
;  :mk-clause               8652
;  :num-allocs              314628
;  :num-checks              228
;  :propagations            4259
;  :quant-instantiations    3241
;  :rlimit-count            610169
;  :time                    0.00)
(push) ; 8
(assert (not (and (< 0 V@28@04) (= exc@123@04 $Ref.null))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               7899
;  :arith-add-rows          4872
;  :arith-assert-diseq      401
;  :arith-assert-lower      2202
;  :arith-assert-upper      1271
;  :arith-bound-prop        613
;  :arith-conflicts         215
;  :arith-eq-adapter        1344
;  :arith-fixed-eqs         573
;  :arith-grobner           35
;  :arith-max-min           316
;  :arith-nonlinear-bounds  23
;  :arith-nonlinear-horner  28
;  :arith-offset-eqs        644
;  :arith-pivots            1353
;  :conflicts               692
;  :datatype-accessor-ax    50
;  :datatype-constructor-ax 450
;  :datatype-occurs-check   162
;  :datatype-splits         86
;  :decisions               1231
;  :del-clause              8643
;  :final-checks            135
;  :interface-eqs           2
;  :max-generation          5
;  :max-memory              6.66
;  :memory                  6.62
;  :minimized-lits          48
;  :mk-bool-var             13457
;  :mk-clause               8652
;  :num-allocs              314646
;  :num-checks              229
;  :propagations            4259
;  :quant-instantiations    3241
;  :rlimit-count            610186)
; [then-branch: 151 | 0 < V@28@04 && exc@123@04 == Null | live]
; [else-branch: 151 | !(0 < V@28@04 && exc@123@04 == Null) | dead]
(push) ; 8
; [then-branch: 151 | 0 < V@28@04 && exc@123@04 == Null]
(assert (and (< 0 V@28@04) (= exc@123@04 $Ref.null)))
; [eval] (forall i1: Int :: { aloc(opt_get1(target), i1) } 0 <= i1 && i1 < V ==> aloc(opt_get1(target), i1).option$array$ != (None(): option[array]))
(declare-const i1@138@04 Int)
(push) ; 9
; [eval] 0 <= i1 && i1 < V ==> aloc(opt_get1(target), i1).option$array$ != (None(): option[array])
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 10
; [then-branch: 152 | 0 <= i1@138@04 | live]
; [else-branch: 152 | !(0 <= i1@138@04) | live]
(push) ; 11
; [then-branch: 152 | 0 <= i1@138@04]
(assert (<= 0 i1@138@04))
; [eval] i1 < V
(pop) ; 11
(push) ; 11
; [else-branch: 152 | !(0 <= i1@138@04)]
(assert (not (<= 0 i1@138@04)))
(pop) ; 11
(pop) ; 10
; Joined path conditions
; Joined path conditions
(push) ; 10
; [then-branch: 153 | i1@138@04 < V@28@04 && 0 <= i1@138@04 | live]
; [else-branch: 153 | !(i1@138@04 < V@28@04 && 0 <= i1@138@04) | live]
(push) ; 11
; [then-branch: 153 | i1@138@04 < V@28@04 && 0 <= i1@138@04]
(assert (and (< i1@138@04 V@28@04) (<= 0 i1@138@04)))
; [eval] aloc(opt_get1(target), i1).option$array$ != (None(): option[array])
; [eval] aloc(opt_get1(target), i1)
; [eval] opt_get1(target)
(push) ; 12
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 12
; Joined path conditions
(push) ; 12
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 13
(assert (not (< i1@138@04 (alen<Int> (opt_get1 $Snap.unit target@27@04)))))
(check-sat)
; unsat
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               7899
;  :arith-add-rows          4872
;  :arith-assert-diseq      401
;  :arith-assert-lower      2204
;  :arith-assert-upper      1271
;  :arith-bound-prop        613
;  :arith-conflicts         215
;  :arith-eq-adapter        1344
;  :arith-fixed-eqs         573
;  :arith-grobner           35
;  :arith-max-min           316
;  :arith-nonlinear-bounds  23
;  :arith-nonlinear-horner  28
;  :arith-offset-eqs        644
;  :arith-pivots            1354
;  :conflicts               692
;  :datatype-accessor-ax    50
;  :datatype-constructor-ax 450
;  :datatype-occurs-check   162
;  :datatype-splits         86
;  :decisions               1231
;  :del-clause              8643
;  :final-checks            135
;  :interface-eqs           2
;  :max-generation          5
;  :max-memory              6.66
;  :memory                  6.62
;  :minimized-lits          48
;  :mk-bool-var             13459
;  :mk-clause               8652
;  :num-allocs              314745
;  :num-checks              230
;  :propagations            4259
;  :quant-instantiations    3241
;  :rlimit-count            610394)
(assert (< i1@138@04 (alen<Int> (opt_get1 $Snap.unit target@27@04))))
(pop) ; 12
; Joined path conditions
(assert (< i1@138@04 (alen<Int> (opt_get1 $Snap.unit target@27@04))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@138@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@138@04)))
(push) ; 12
(assert (not (<
  $Perm.No
  (+
    (+
      (+
        (ite
          (and
            (<
              (inv@136@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@138@04))
              V@28@04)
            (<=
              0
              (inv@136@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@138@04))))
          (*
            (scale $Snap.unit (* (to_real (* V@28@04 V@28@04)) $Perm.Write))
            $k@135@04)
          $Perm.No)
        (ite
          (and
            (<
              (inv@128@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@138@04))
              V@28@04)
            (<=
              0
              (inv@128@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@138@04))))
          (*
            (scale $Snap.unit (* (to_real (* V@28@04 V@28@04)) $Perm.Write))
            $k@127@04)
          $Perm.No))
      (-
        (-
          (ite
            (and
              (<
                (inv@42@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@138@04))
                V@28@04)
              (<=
                0
                (inv@42@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@138@04))))
            $k@41@04
            $Perm.No)
          (pTaken@95@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@138@04)))
        (pTaken@106@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@138@04))))
    (-
      (-
        (ite
          (and
            (<
              (inv@34@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@138@04))
              V@28@04)
            (<=
              0
              (inv@34@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@138@04))))
          $k@33@04
          $Perm.No)
        (pTaken@96@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@138@04)))
      (pTaken@105@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@138@04)))))))
(check-sat)
; unsat
(pop) ; 12
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               8375
;  :arith-add-rows          5521
;  :arith-assert-diseq      423
;  :arith-assert-lower      2339
;  :arith-assert-upper      1408
;  :arith-bound-prop        645
;  :arith-conflicts         231
;  :arith-eq-adapter        1469
;  :arith-fixed-eqs         631
;  :arith-grobner           35
;  :arith-max-min           316
;  :arith-nonlinear-bounds  23
;  :arith-nonlinear-horner  28
;  :arith-offset-eqs        686
;  :arith-pivots            1443
;  :conflicts               727
;  :datatype-accessor-ax    50
;  :datatype-constructor-ax 454
;  :datatype-occurs-check   162
;  :datatype-splits         86
;  :decisions               1320
;  :del-clause              9015
;  :final-checks            135
;  :interface-eqs           2
;  :max-generation          5
;  :max-memory              6.67
;  :memory                  6.66
;  :minimized-lits          51
;  :mk-bool-var             14191
;  :mk-clause               9149
;  :num-allocs              318268
;  :num-checks              231
;  :propagations            4600
;  :quant-instantiations    3369
;  :rlimit-count            636626
;  :time                    0.01)
; [eval] (None(): option[array])
(pop) ; 11
(push) ; 11
; [else-branch: 153 | !(i1@138@04 < V@28@04 && 0 <= i1@138@04)]
(assert (not (and (< i1@138@04 V@28@04) (<= 0 i1@138@04))))
(pop) ; 11
(pop) ; 10
; Joined path conditions
(assert (implies
  (and (< i1@138@04 V@28@04) (<= 0 i1@138@04))
  (and
    (< i1@138@04 V@28@04)
    (<= 0 i1@138@04)
    (< i1@138@04 (alen<Int> (opt_get1 $Snap.unit target@27@04)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@138@04)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@138@04)))))
; Joined path conditions
(pop) ; 9
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@138@04 Int)) (!
  (implies
    (and (< i1@138@04 V@28@04) (<= 0 i1@138@04))
    (and
      (< i1@138@04 V@28@04)
      (<= 0 i1@138@04)
      (< i1@138@04 (alen<Int> (opt_get1 $Snap.unit target@27@04)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@138@04)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@138@04))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@138@04))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 8
(pop) ; 7
; Joined path conditions
(assert (implies
  (and (< 0 V@28@04) (= exc@123@04 $Ref.null))
  (and
    (< 0 V@28@04)
    (= exc@123@04 $Ref.null)
    (forall ((i1@138@04 Int)) (!
      (implies
        (and (< i1@138@04 V@28@04) (<= 0 i1@138@04))
        (and
          (< i1@138@04 V@28@04)
          (<= 0 i1@138@04)
          (< i1@138@04 (alen<Int> (opt_get1 $Snap.unit target@27@04)))
          ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@138@04)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@138@04))))
      :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@138@04))
      :qid |prog.l<no position>-aux|)))))
(assert (implies
  (and (< 0 V@28@04) (= exc@123@04 $Ref.null))
  (forall ((i1@138@04 Int)) (!
    (implies
      (and (< i1@138@04 V@28@04) (<= 0 i1@138@04))
      (not
        (=
          ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@138@04))
          (as None<option<array>>  option<array>))))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@138@04))
    :qid |prog.l<no position>|))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@04)))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@04))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@04)))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@04))))))))))))
  $Snap.unit))
; [eval] exc == null && 0 < V ==> (forall i1: Int :: { alen(opt_get1(aloc(opt_get1(target), i1).option$array$)) } 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(target), i1).option$array$)) == V)
; [eval] exc == null && 0 < V
; [eval] exc == null
(push) ; 7
; [then-branch: 154 | exc@123@04 == Null | live]
; [else-branch: 154 | exc@123@04 != Null | live]
(push) ; 8
; [then-branch: 154 | exc@123@04 == Null]
(assert (= exc@123@04 $Ref.null))
; [eval] 0 < V
(pop) ; 8
(push) ; 8
; [else-branch: 154 | exc@123@04 != Null]
(assert (not (= exc@123@04 $Ref.null)))
(pop) ; 8
(pop) ; 7
; Joined path conditions
; Joined path conditions
(push) ; 7
(set-option :timeout 10)
(push) ; 8
(assert (not (not (and (< 0 V@28@04) (= exc@123@04 $Ref.null)))))
(check-sat)
; unknown
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               8414
;  :arith-add-rows          5526
;  :arith-assert-diseq      423
;  :arith-assert-lower      2361
;  :arith-assert-upper      1422
;  :arith-bound-prop        645
;  :arith-conflicts         232
;  :arith-eq-adapter        1469
;  :arith-fixed-eqs         631
;  :arith-grobner           40
;  :arith-max-min           354
;  :arith-nonlinear-bounds  25
;  :arith-nonlinear-horner  32
;  :arith-offset-eqs        687
;  :arith-pivots            1450
;  :conflicts               728
;  :datatype-accessor-ax    51
;  :datatype-constructor-ax 461
;  :datatype-occurs-check   166
;  :datatype-splits         89
;  :decisions               1328
;  :del-clause              9140
;  :final-checks            140
;  :interface-eqs           2
;  :max-generation          5
;  :max-memory              6.68
;  :memory                  6.67
;  :minimized-lits          51
;  :mk-bool-var             14198
;  :mk-clause               9149
;  :num-allocs              319613
;  :num-checks              232
;  :propagations            4603
;  :quant-instantiations    3369
;  :rlimit-count            639179)
(push) ; 8
(assert (not (and (< 0 V@28@04) (= exc@123@04 $Ref.null))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               8414
;  :arith-add-rows          5526
;  :arith-assert-diseq      423
;  :arith-assert-lower      2361
;  :arith-assert-upper      1422
;  :arith-bound-prop        645
;  :arith-conflicts         232
;  :arith-eq-adapter        1469
;  :arith-fixed-eqs         631
;  :arith-grobner           40
;  :arith-max-min           354
;  :arith-nonlinear-bounds  25
;  :arith-nonlinear-horner  32
;  :arith-offset-eqs        687
;  :arith-pivots            1450
;  :conflicts               728
;  :datatype-accessor-ax    51
;  :datatype-constructor-ax 461
;  :datatype-occurs-check   166
;  :datatype-splits         89
;  :decisions               1328
;  :del-clause              9140
;  :final-checks            140
;  :interface-eqs           2
;  :max-generation          5
;  :max-memory              6.68
;  :memory                  6.67
;  :minimized-lits          51
;  :mk-bool-var             14198
;  :mk-clause               9149
;  :num-allocs              319631
;  :num-checks              233
;  :propagations            4603
;  :quant-instantiations    3369
;  :rlimit-count            639196)
; [then-branch: 155 | 0 < V@28@04 && exc@123@04 == Null | live]
; [else-branch: 155 | !(0 < V@28@04 && exc@123@04 == Null) | dead]
(push) ; 8
; [then-branch: 155 | 0 < V@28@04 && exc@123@04 == Null]
(assert (and (< 0 V@28@04) (= exc@123@04 $Ref.null)))
; [eval] (forall i1: Int :: { alen(opt_get1(aloc(opt_get1(target), i1).option$array$)) } 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(target), i1).option$array$)) == V)
(declare-const i1@139@04 Int)
(push) ; 9
; [eval] 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(target), i1).option$array$)) == V
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 10
; [then-branch: 156 | 0 <= i1@139@04 | live]
; [else-branch: 156 | !(0 <= i1@139@04) | live]
(push) ; 11
; [then-branch: 156 | 0 <= i1@139@04]
(assert (<= 0 i1@139@04))
; [eval] i1 < V
(pop) ; 11
(push) ; 11
; [else-branch: 156 | !(0 <= i1@139@04)]
(assert (not (<= 0 i1@139@04)))
(pop) ; 11
(pop) ; 10
; Joined path conditions
; Joined path conditions
(push) ; 10
; [then-branch: 157 | i1@139@04 < V@28@04 && 0 <= i1@139@04 | live]
; [else-branch: 157 | !(i1@139@04 < V@28@04 && 0 <= i1@139@04) | live]
(push) ; 11
; [then-branch: 157 | i1@139@04 < V@28@04 && 0 <= i1@139@04]
(assert (and (< i1@139@04 V@28@04) (<= 0 i1@139@04)))
; [eval] alen(opt_get1(aloc(opt_get1(target), i1).option$array$)) == V
; [eval] alen(opt_get1(aloc(opt_get1(target), i1).option$array$))
; [eval] opt_get1(aloc(opt_get1(target), i1).option$array$)
; [eval] aloc(opt_get1(target), i1)
; [eval] opt_get1(target)
(push) ; 12
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 12
; Joined path conditions
(push) ; 12
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 13
(assert (not (< i1@139@04 (alen<Int> (opt_get1 $Snap.unit target@27@04)))))
(check-sat)
; unsat
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               8414
;  :arith-add-rows          5526
;  :arith-assert-diseq      423
;  :arith-assert-lower      2363
;  :arith-assert-upper      1422
;  :arith-bound-prop        645
;  :arith-conflicts         232
;  :arith-eq-adapter        1469
;  :arith-fixed-eqs         631
;  :arith-grobner           40
;  :arith-max-min           354
;  :arith-nonlinear-bounds  25
;  :arith-nonlinear-horner  32
;  :arith-offset-eqs        687
;  :arith-pivots            1450
;  :conflicts               728
;  :datatype-accessor-ax    51
;  :datatype-constructor-ax 461
;  :datatype-occurs-check   166
;  :datatype-splits         89
;  :decisions               1328
;  :del-clause              9140
;  :final-checks            140
;  :interface-eqs           2
;  :max-generation          5
;  :max-memory              6.68
;  :memory                  6.67
;  :minimized-lits          51
;  :mk-bool-var             14200
;  :mk-clause               9149
;  :num-allocs              319730
;  :num-checks              234
;  :propagations            4603
;  :quant-instantiations    3369
;  :rlimit-count            639400)
(assert (< i1@139@04 (alen<Int> (opt_get1 $Snap.unit target@27@04))))
(pop) ; 12
; Joined path conditions
(assert (< i1@139@04 (alen<Int> (opt_get1 $Snap.unit target@27@04))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@139@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@139@04)))
(push) ; 12
(assert (not (<
  $Perm.No
  (+
    (+
      (+
        (ite
          (and
            (<
              (inv@136@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@139@04))
              V@28@04)
            (<=
              0
              (inv@136@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@139@04))))
          (*
            (scale $Snap.unit (* (to_real (* V@28@04 V@28@04)) $Perm.Write))
            $k@135@04)
          $Perm.No)
        (ite
          (and
            (<
              (inv@128@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@139@04))
              V@28@04)
            (<=
              0
              (inv@128@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@139@04))))
          (*
            (scale $Snap.unit (* (to_real (* V@28@04 V@28@04)) $Perm.Write))
            $k@127@04)
          $Perm.No))
      (-
        (-
          (ite
            (and
              (<
                (inv@42@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@139@04))
                V@28@04)
              (<=
                0
                (inv@42@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@139@04))))
            $k@41@04
            $Perm.No)
          (pTaken@95@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@139@04)))
        (pTaken@106@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@139@04))))
    (-
      (-
        (ite
          (and
            (<
              (inv@34@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@139@04))
              V@28@04)
            (<=
              0
              (inv@34@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@139@04))))
          $k@33@04
          $Perm.No)
        (pTaken@96@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@139@04)))
      (pTaken@105@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@139@04)))))))
(check-sat)
; unsat
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               8800
;  :arith-add-rows          5813
;  :arith-assert-diseq      454
;  :arith-assert-lower      2501
;  :arith-assert-upper      1504
;  :arith-bound-prop        699
;  :arith-conflicts         246
;  :arith-eq-adapter        1556
;  :arith-fixed-eqs         666
;  :arith-grobner           40
;  :arith-max-min           354
;  :arith-nonlinear-bounds  25
;  :arith-nonlinear-horner  32
;  :arith-offset-eqs        756
;  :arith-pivots            1512
;  :conflicts               754
;  :datatype-accessor-ax    51
;  :datatype-constructor-ax 465
;  :datatype-occurs-check   166
;  :datatype-splits         89
;  :decisions               1396
;  :del-clause              9612
;  :final-checks            140
;  :interface-eqs           2
;  :max-generation          5
;  :max-memory              6.69
;  :memory                  6.67
;  :minimized-lits          51
;  :mk-bool-var             14880
;  :mk-clause               9746
;  :num-allocs              322312
;  :num-checks              235
;  :propagations            4927
;  :quant-instantiations    3478
;  :rlimit-count            654038
;  :time                    0.00)
(push) ; 12
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 13
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@139@04))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               8800
;  :arith-add-rows          5813
;  :arith-assert-diseq      454
;  :arith-assert-lower      2501
;  :arith-assert-upper      1504
;  :arith-bound-prop        699
;  :arith-conflicts         246
;  :arith-eq-adapter        1556
;  :arith-fixed-eqs         666
;  :arith-grobner           40
;  :arith-max-min           354
;  :arith-nonlinear-bounds  25
;  :arith-nonlinear-horner  32
;  :arith-offset-eqs        756
;  :arith-pivots            1512
;  :conflicts               755
;  :datatype-accessor-ax    51
;  :datatype-constructor-ax 465
;  :datatype-occurs-check   166
;  :datatype-splits         89
;  :decisions               1396
;  :del-clause              9612
;  :final-checks            140
;  :interface-eqs           2
;  :max-generation          5
;  :max-memory              6.69
;  :memory                  6.67
;  :minimized-lits          51
;  :mk-bool-var             14880
;  :mk-clause               9746
;  :num-allocs              322403
;  :num-checks              236
;  :propagations            4927
;  :quant-instantiations    3478
;  :rlimit-count            654133)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@139@04))
    (as None<option<array>>  option<array>))))
(pop) ; 12
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@139@04))
    (as None<option<array>>  option<array>))))
(pop) ; 11
(push) ; 11
; [else-branch: 157 | !(i1@139@04 < V@28@04 && 0 <= i1@139@04)]
(assert (not (and (< i1@139@04 V@28@04) (<= 0 i1@139@04))))
(pop) ; 11
(pop) ; 10
; Joined path conditions
(assert (implies
  (and (< i1@139@04 V@28@04) (<= 0 i1@139@04))
  (and
    (< i1@139@04 V@28@04)
    (<= 0 i1@139@04)
    (< i1@139@04 (alen<Int> (opt_get1 $Snap.unit target@27@04)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@139@04)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@139@04))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@139@04))
        (as None<option<array>>  option<array>))))))
; Joined path conditions
(pop) ; 9
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@139@04 Int)) (!
  (implies
    (and (< i1@139@04 V@28@04) (<= 0 i1@139@04))
    (and
      (< i1@139@04 V@28@04)
      (<= 0 i1@139@04)
      (< i1@139@04 (alen<Int> (opt_get1 $Snap.unit target@27@04)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@139@04)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@139@04))
      (not
        (=
          ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@139@04))
          (as None<option<array>>  option<array>)))))
  :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@139@04)))))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 8
(pop) ; 7
; Joined path conditions
(assert (implies
  (and (< 0 V@28@04) (= exc@123@04 $Ref.null))
  (and
    (< 0 V@28@04)
    (= exc@123@04 $Ref.null)
    (forall ((i1@139@04 Int)) (!
      (implies
        (and (< i1@139@04 V@28@04) (<= 0 i1@139@04))
        (and
          (< i1@139@04 V@28@04)
          (<= 0 i1@139@04)
          (< i1@139@04 (alen<Int> (opt_get1 $Snap.unit target@27@04)))
          ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@139@04)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@139@04))
          (not
            (=
              ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@139@04))
              (as None<option<array>>  option<array>)))))
      :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@139@04)))))
      :qid |prog.l<no position>-aux|)))))
(assert (implies
  (and (< 0 V@28@04) (= exc@123@04 $Ref.null))
  (forall ((i1@139@04 Int)) (!
    (implies
      (and (< i1@139@04 V@28@04) (<= 0 i1@139@04))
      (=
        (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@139@04))))
        V@28@04))
    :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@139@04)))))
    :qid |prog.l<no position>|))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@04))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@04)))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@04))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@04)))))))))))))
  $Snap.unit))
; [eval] exc == null && 0 < V ==> (forall i1: Int :: { aloc(opt_get1(target), i1) } (forall i2: Int :: { aloc(opt_get1(target), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(target), i1).option$array$ == aloc(opt_get1(target), i2).option$array$ ==> i1 == i2))
; [eval] exc == null && 0 < V
; [eval] exc == null
(push) ; 7
; [then-branch: 158 | exc@123@04 == Null | live]
; [else-branch: 158 | exc@123@04 != Null | live]
(push) ; 8
; [then-branch: 158 | exc@123@04 == Null]
(assert (= exc@123@04 $Ref.null))
; [eval] 0 < V
(pop) ; 8
(push) ; 8
; [else-branch: 158 | exc@123@04 != Null]
(assert (not (= exc@123@04 $Ref.null)))
(pop) ; 8
(pop) ; 7
; Joined path conditions
; Joined path conditions
(push) ; 7
(set-option :timeout 10)
(push) ; 8
(assert (not (not (and (< 0 V@28@04) (= exc@123@04 $Ref.null)))))
(check-sat)
; unknown
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               8840
;  :arith-add-rows          5818
;  :arith-assert-diseq      454
;  :arith-assert-lower      2523
;  :arith-assert-upper      1518
;  :arith-bound-prop        699
;  :arith-conflicts         247
;  :arith-eq-adapter        1556
;  :arith-fixed-eqs         666
;  :arith-grobner           45
;  :arith-max-min           392
;  :arith-nonlinear-bounds  27
;  :arith-nonlinear-horner  36
;  :arith-offset-eqs        757
;  :arith-pivots            1518
;  :conflicts               756
;  :datatype-accessor-ax    52
;  :datatype-constructor-ax 472
;  :datatype-occurs-check   170
;  :datatype-splits         92
;  :decisions               1404
;  :del-clause              9737
;  :final-checks            145
;  :interface-eqs           2
;  :max-generation          5
;  :max-memory              6.69
;  :memory                  6.67
;  :minimized-lits          51
;  :mk-bool-var             14887
;  :mk-clause               9746
;  :num-allocs              323774
;  :num-checks              237
;  :propagations            4930
;  :quant-instantiations    3478
;  :rlimit-count            656789
;  :time                    0.00)
(push) ; 8
(assert (not (and (< 0 V@28@04) (= exc@123@04 $Ref.null))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               8840
;  :arith-add-rows          5818
;  :arith-assert-diseq      454
;  :arith-assert-lower      2523
;  :arith-assert-upper      1518
;  :arith-bound-prop        699
;  :arith-conflicts         247
;  :arith-eq-adapter        1556
;  :arith-fixed-eqs         666
;  :arith-grobner           45
;  :arith-max-min           392
;  :arith-nonlinear-bounds  27
;  :arith-nonlinear-horner  36
;  :arith-offset-eqs        757
;  :arith-pivots            1518
;  :conflicts               756
;  :datatype-accessor-ax    52
;  :datatype-constructor-ax 472
;  :datatype-occurs-check   170
;  :datatype-splits         92
;  :decisions               1404
;  :del-clause              9737
;  :final-checks            145
;  :interface-eqs           2
;  :max-generation          5
;  :max-memory              6.69
;  :memory                  6.67
;  :minimized-lits          51
;  :mk-bool-var             14887
;  :mk-clause               9746
;  :num-allocs              323792
;  :num-checks              238
;  :propagations            4930
;  :quant-instantiations    3478
;  :rlimit-count            656806)
; [then-branch: 159 | 0 < V@28@04 && exc@123@04 == Null | live]
; [else-branch: 159 | !(0 < V@28@04 && exc@123@04 == Null) | dead]
(push) ; 8
; [then-branch: 159 | 0 < V@28@04 && exc@123@04 == Null]
(assert (and (< 0 V@28@04) (= exc@123@04 $Ref.null)))
; [eval] (forall i1: Int :: { aloc(opt_get1(target), i1) } (forall i2: Int :: { aloc(opt_get1(target), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(target), i1).option$array$ == aloc(opt_get1(target), i2).option$array$ ==> i1 == i2))
(declare-const i1@140@04 Int)
(push) ; 9
; [eval] (forall i2: Int :: { aloc(opt_get1(target), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(target), i1).option$array$ == aloc(opt_get1(target), i2).option$array$ ==> i1 == i2)
(declare-const i2@141@04 Int)
(push) ; 10
; [eval] 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(target), i1).option$array$ == aloc(opt_get1(target), i2).option$array$ ==> i1 == i2
; [eval] 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(target), i1).option$array$ == aloc(opt_get1(target), i2).option$array$
; [eval] 0 <= i1
(push) ; 11
; [then-branch: 160 | 0 <= i1@140@04 | live]
; [else-branch: 160 | !(0 <= i1@140@04) | live]
(push) ; 12
; [then-branch: 160 | 0 <= i1@140@04]
(assert (<= 0 i1@140@04))
; [eval] i1 < V
(push) ; 13
; [then-branch: 161 | i1@140@04 < V@28@04 | live]
; [else-branch: 161 | !(i1@140@04 < V@28@04) | live]
(push) ; 14
; [then-branch: 161 | i1@140@04 < V@28@04]
(assert (< i1@140@04 V@28@04))
; [eval] 0 <= i2
(push) ; 15
; [then-branch: 162 | 0 <= i2@141@04 | live]
; [else-branch: 162 | !(0 <= i2@141@04) | live]
(push) ; 16
; [then-branch: 162 | 0 <= i2@141@04]
(assert (<= 0 i2@141@04))
; [eval] i2 < V
(push) ; 17
; [then-branch: 163 | i2@141@04 < V@28@04 | live]
; [else-branch: 163 | !(i2@141@04 < V@28@04) | live]
(push) ; 18
; [then-branch: 163 | i2@141@04 < V@28@04]
(assert (< i2@141@04 V@28@04))
; [eval] aloc(opt_get1(target), i1).option$array$ == aloc(opt_get1(target), i2).option$array$
; [eval] aloc(opt_get1(target), i1)
; [eval] opt_get1(target)
(push) ; 19
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 19
; Joined path conditions
(push) ; 19
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 20
(assert (not (< i1@140@04 (alen<Int> (opt_get1 $Snap.unit target@27@04)))))
(check-sat)
; unsat
(pop) ; 20
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               8840
;  :arith-add-rows          5818
;  :arith-assert-diseq      454
;  :arith-assert-lower      2527
;  :arith-assert-upper      1518
;  :arith-bound-prop        699
;  :arith-conflicts         247
;  :arith-eq-adapter        1556
;  :arith-fixed-eqs         666
;  :arith-grobner           45
;  :arith-max-min           392
;  :arith-nonlinear-bounds  27
;  :arith-nonlinear-horner  36
;  :arith-offset-eqs        757
;  :arith-pivots            1519
;  :conflicts               756
;  :datatype-accessor-ax    52
;  :datatype-constructor-ax 472
;  :datatype-occurs-check   170
;  :datatype-splits         92
;  :decisions               1404
;  :del-clause              9737
;  :final-checks            145
;  :interface-eqs           2
;  :max-generation          5
;  :max-memory              6.69
;  :memory                  6.67
;  :minimized-lits          51
;  :mk-bool-var             14891
;  :mk-clause               9746
;  :num-allocs              324068
;  :num-checks              239
;  :propagations            4930
;  :quant-instantiations    3478
;  :rlimit-count            657159)
(assert (< i1@140@04 (alen<Int> (opt_get1 $Snap.unit target@27@04))))
(pop) ; 19
; Joined path conditions
(assert (< i1@140@04 (alen<Int> (opt_get1 $Snap.unit target@27@04))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@140@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@140@04)))
(push) ; 19
(assert (not (<
  $Perm.No
  (+
    (+
      (+
        (ite
          (and
            (<
              (inv@136@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@140@04))
              V@28@04)
            (<=
              0
              (inv@136@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@140@04))))
          (*
            (scale $Snap.unit (* (to_real (* V@28@04 V@28@04)) $Perm.Write))
            $k@135@04)
          $Perm.No)
        (ite
          (and
            (<
              (inv@128@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@140@04))
              V@28@04)
            (<=
              0
              (inv@128@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@140@04))))
          (*
            (scale $Snap.unit (* (to_real (* V@28@04 V@28@04)) $Perm.Write))
            $k@127@04)
          $Perm.No))
      (-
        (-
          (ite
            (and
              (<
                (inv@42@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@140@04))
                V@28@04)
              (<=
                0
                (inv@42@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@140@04))))
            $k@41@04
            $Perm.No)
          (pTaken@95@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@140@04)))
        (pTaken@106@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@140@04))))
    (-
      (-
        (ite
          (and
            (<
              (inv@34@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@140@04))
              V@28@04)
            (<=
              0
              (inv@34@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@140@04))))
          $k@33@04
          $Perm.No)
        (pTaken@96@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@140@04)))
      (pTaken@105@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@140@04)))))))
(check-sat)
; unsat
(pop) ; 19
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               9533
;  :arith-add-rows          6867
;  :arith-assert-diseq      505
;  :arith-assert-lower      2785
;  :arith-assert-upper      1698
;  :arith-bound-prop        750
;  :arith-conflicts         269
;  :arith-eq-adapter        1744
;  :arith-fixed-eqs         752
;  :arith-grobner           45
;  :arith-max-min           392
;  :arith-nonlinear-bounds  27
;  :arith-nonlinear-horner  36
;  :arith-offset-eqs        844
;  :arith-pivots            1663
;  :conflicts               798
;  :datatype-accessor-ax    52
;  :datatype-constructor-ax 476
;  :datatype-occurs-check   170
;  :datatype-splits         92
;  :decisions               1526
;  :del-clause              10568
;  :final-checks            145
;  :interface-eqs           2
;  :max-generation          5
;  :max-memory              6.72
;  :memory                  6.71
;  :minimized-lits          58
;  :mk-bool-var             16084
;  :mk-clause               10702
;  :num-allocs              328423
;  :num-checks              240
;  :propagations            5567
;  :quant-instantiations    3663
;  :rlimit-count            696729
;  :time                    0.01)
; [eval] aloc(opt_get1(target), i2)
; [eval] opt_get1(target)
(push) ; 19
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 19
; Joined path conditions
(push) ; 19
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 20
(assert (not (< i2@141@04 (alen<Int> (opt_get1 $Snap.unit target@27@04)))))
(check-sat)
; unsat
(pop) ; 20
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               9533
;  :arith-add-rows          6867
;  :arith-assert-diseq      505
;  :arith-assert-lower      2785
;  :arith-assert-upper      1698
;  :arith-bound-prop        750
;  :arith-conflicts         269
;  :arith-eq-adapter        1744
;  :arith-fixed-eqs         752
;  :arith-grobner           45
;  :arith-max-min           392
;  :arith-nonlinear-bounds  27
;  :arith-nonlinear-horner  36
;  :arith-offset-eqs        844
;  :arith-pivots            1663
;  :conflicts               798
;  :datatype-accessor-ax    52
;  :datatype-constructor-ax 476
;  :datatype-occurs-check   170
;  :datatype-splits         92
;  :decisions               1526
;  :del-clause              10568
;  :final-checks            145
;  :interface-eqs           2
;  :max-generation          5
;  :max-memory              6.72
;  :memory                  6.71
;  :minimized-lits          58
;  :mk-bool-var             16084
;  :mk-clause               10702
;  :num-allocs              328450
;  :num-checks              241
;  :propagations            5567
;  :quant-instantiations    3663
;  :rlimit-count            696759)
(assert (< i2@141@04 (alen<Int> (opt_get1 $Snap.unit target@27@04))))
(pop) ; 19
; Joined path conditions
(assert (< i2@141@04 (alen<Int> (opt_get1 $Snap.unit target@27@04))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@141@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@141@04)))
(push) ; 19
(assert (not (<
  $Perm.No
  (+
    (+
      (+
        (ite
          (and
            (<
              (inv@136@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@141@04))
              V@28@04)
            (<=
              0
              (inv@136@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@141@04))))
          (*
            (scale $Snap.unit (* (to_real (* V@28@04 V@28@04)) $Perm.Write))
            $k@135@04)
          $Perm.No)
        (ite
          (and
            (<
              (inv@128@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@141@04))
              V@28@04)
            (<=
              0
              (inv@128@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@141@04))))
          (*
            (scale $Snap.unit (* (to_real (* V@28@04 V@28@04)) $Perm.Write))
            $k@127@04)
          $Perm.No))
      (-
        (-
          (ite
            (and
              (<
                (inv@42@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@141@04))
                V@28@04)
              (<=
                0
                (inv@42@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@141@04))))
            $k@41@04
            $Perm.No)
          (pTaken@95@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@141@04)))
        (pTaken@106@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@141@04))))
    (-
      (-
        (ite
          (and
            (<
              (inv@34@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@141@04))
              V@28@04)
            (<=
              0
              (inv@34@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@141@04))))
          $k@33@04
          $Perm.No)
        (pTaken@96@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@141@04)))
      (pTaken@105@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@141@04)))))))
(check-sat)
; unsat
(pop) ; 19
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               10257
;  :arith-add-rows          7959
;  :arith-assert-diseq      563
;  :arith-assert-lower      3022
;  :arith-assert-upper      1872
;  :arith-bound-prop        823
;  :arith-conflicts         288
;  :arith-eq-adapter        1935
;  :arith-fixed-eqs         840
;  :arith-grobner           45
;  :arith-max-min           392
;  :arith-nonlinear-bounds  27
;  :arith-nonlinear-horner  36
;  :arith-offset-eqs        982
;  :arith-pivots            1771
;  :conflicts               846
;  :datatype-accessor-ax    52
;  :datatype-constructor-ax 480
;  :datatype-occurs-check   170
;  :datatype-splits         92
;  :decisions               1658
;  :del-clause              11442
;  :final-checks            145
;  :interface-eqs           2
;  :max-generation          5
;  :max-memory              6.79
;  :memory                  6.77
;  :minimized-lits          69
;  :mk-bool-var             17335
;  :mk-clause               11673
;  :num-allocs              333149
;  :num-checks              242
;  :propagations            6222
;  :quant-instantiations    3776
;  :rlimit-count            730140
;  :time                    0.01)
(pop) ; 18
(push) ; 18
; [else-branch: 163 | !(i2@141@04 < V@28@04)]
(assert (not (< i2@141@04 V@28@04)))
(pop) ; 18
(pop) ; 17
; Joined path conditions
(assert (implies
  (< i2@141@04 V@28@04)
  (and
    (< i2@141@04 V@28@04)
    (< i1@140@04 (alen<Int> (opt_get1 $Snap.unit target@27@04)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@140@04)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@140@04))
    (< i2@141@04 (alen<Int> (opt_get1 $Snap.unit target@27@04)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@141@04)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@141@04)))))
; Joined path conditions
(pop) ; 16
(push) ; 16
; [else-branch: 162 | !(0 <= i2@141@04)]
(assert (not (<= 0 i2@141@04)))
(pop) ; 16
(pop) ; 15
; Joined path conditions
(assert (implies
  (<= 0 i2@141@04)
  (and
    (<= 0 i2@141@04)
    (implies
      (< i2@141@04 V@28@04)
      (and
        (< i2@141@04 V@28@04)
        (< i1@140@04 (alen<Int> (opt_get1 $Snap.unit target@27@04)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@140@04)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@140@04))
        (< i2@141@04 (alen<Int> (opt_get1 $Snap.unit target@27@04)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@141@04)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@141@04)))))))
; Joined path conditions
(pop) ; 14
(push) ; 14
; [else-branch: 161 | !(i1@140@04 < V@28@04)]
(assert (not (< i1@140@04 V@28@04)))
(pop) ; 14
(pop) ; 13
; Joined path conditions
(assert (implies
  (< i1@140@04 V@28@04)
  (and
    (< i1@140@04 V@28@04)
    (implies
      (<= 0 i2@141@04)
      (and
        (<= 0 i2@141@04)
        (implies
          (< i2@141@04 V@28@04)
          (and
            (< i2@141@04 V@28@04)
            (< i1@140@04 (alen<Int> (opt_get1 $Snap.unit target@27@04)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@140@04)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@140@04))
            (< i2@141@04 (alen<Int> (opt_get1 $Snap.unit target@27@04)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@141@04)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@141@04)))))))))
; Joined path conditions
(pop) ; 12
(push) ; 12
; [else-branch: 160 | !(0 <= i1@140@04)]
(assert (not (<= 0 i1@140@04)))
(pop) ; 12
(pop) ; 11
; Joined path conditions
(assert (implies
  (<= 0 i1@140@04)
  (and
    (<= 0 i1@140@04)
    (implies
      (< i1@140@04 V@28@04)
      (and
        (< i1@140@04 V@28@04)
        (implies
          (<= 0 i2@141@04)
          (and
            (<= 0 i2@141@04)
            (implies
              (< i2@141@04 V@28@04)
              (and
                (< i2@141@04 V@28@04)
                (< i1@140@04 (alen<Int> (opt_get1 $Snap.unit target@27@04)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@140@04)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@140@04))
                (< i2@141@04 (alen<Int> (opt_get1 $Snap.unit target@27@04)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@141@04)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@141@04)))))))))))
; Joined path conditions
(push) ; 11
; [then-branch: 164 | Lookup(option$array$,sm@137@04,aloc((_, _), opt_get1(_, target@27@04), i1@140@04)) == Lookup(option$array$,sm@137@04,aloc((_, _), opt_get1(_, target@27@04), i2@141@04)) && i2@141@04 < V@28@04 && 0 <= i2@141@04 && i1@140@04 < V@28@04 && 0 <= i1@140@04 | live]
; [else-branch: 164 | !(Lookup(option$array$,sm@137@04,aloc((_, _), opt_get1(_, target@27@04), i1@140@04)) == Lookup(option$array$,sm@137@04,aloc((_, _), opt_get1(_, target@27@04), i2@141@04)) && i2@141@04 < V@28@04 && 0 <= i2@141@04 && i1@140@04 < V@28@04 && 0 <= i1@140@04) | live]
(push) ; 12
; [then-branch: 164 | Lookup(option$array$,sm@137@04,aloc((_, _), opt_get1(_, target@27@04), i1@140@04)) == Lookup(option$array$,sm@137@04,aloc((_, _), opt_get1(_, target@27@04), i2@141@04)) && i2@141@04 < V@28@04 && 0 <= i2@141@04 && i1@140@04 < V@28@04 && 0 <= i1@140@04]
(assert (and
  (and
    (and
      (and
        (=
          ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@140@04))
          ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@141@04)))
        (< i2@141@04 V@28@04))
      (<= 0 i2@141@04))
    (< i1@140@04 V@28@04))
  (<= 0 i1@140@04)))
; [eval] i1 == i2
(pop) ; 12
(push) ; 12
; [else-branch: 164 | !(Lookup(option$array$,sm@137@04,aloc((_, _), opt_get1(_, target@27@04), i1@140@04)) == Lookup(option$array$,sm@137@04,aloc((_, _), opt_get1(_, target@27@04), i2@141@04)) && i2@141@04 < V@28@04 && 0 <= i2@141@04 && i1@140@04 < V@28@04 && 0 <= i1@140@04)]
(assert (not
  (and
    (and
      (and
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@140@04))
            ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@141@04)))
          (< i2@141@04 V@28@04))
        (<= 0 i2@141@04))
      (< i1@140@04 V@28@04))
    (<= 0 i1@140@04))))
(pop) ; 12
(pop) ; 11
; Joined path conditions
(assert (implies
  (and
    (and
      (and
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@140@04))
            ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@141@04)))
          (< i2@141@04 V@28@04))
        (<= 0 i2@141@04))
      (< i1@140@04 V@28@04))
    (<= 0 i1@140@04))
  (and
    (=
      ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@140@04))
      ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@141@04)))
    (< i2@141@04 V@28@04)
    (<= 0 i2@141@04)
    (< i1@140@04 V@28@04)
    (<= 0 i1@140@04))))
; Joined path conditions
(pop) ; 10
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i2@141@04 Int)) (!
  (and
    (implies
      (<= 0 i1@140@04)
      (and
        (<= 0 i1@140@04)
        (implies
          (< i1@140@04 V@28@04)
          (and
            (< i1@140@04 V@28@04)
            (implies
              (<= 0 i2@141@04)
              (and
                (<= 0 i2@141@04)
                (implies
                  (< i2@141@04 V@28@04)
                  (and
                    (< i2@141@04 V@28@04)
                    (< i1@140@04 (alen<Int> (opt_get1 $Snap.unit target@27@04)))
                    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@140@04)) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@140@04))
                    (< i2@141@04 (alen<Int> (opt_get1 $Snap.unit target@27@04)))
                    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@141@04)) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@141@04))))))))))
    (implies
      (and
        (and
          (and
            (and
              (=
                ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@140@04))
                ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@141@04)))
              (< i2@141@04 V@28@04))
            (<= 0 i2@141@04))
          (< i1@140@04 V@28@04))
        (<= 0 i1@140@04))
      (and
        (=
          ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@140@04))
          ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@141@04)))
        (< i2@141@04 V@28@04)
        (<= 0 i2@141@04)
        (< i1@140@04 V@28@04)
        (<= 0 i1@140@04))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@141@04))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 9
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@140@04 Int)) (!
  (forall ((i2@141@04 Int)) (!
    (and
      (implies
        (<= 0 i1@140@04)
        (and
          (<= 0 i1@140@04)
          (implies
            (< i1@140@04 V@28@04)
            (and
              (< i1@140@04 V@28@04)
              (implies
                (<= 0 i2@141@04)
                (and
                  (<= 0 i2@141@04)
                  (implies
                    (< i2@141@04 V@28@04)
                    (and
                      (< i2@141@04 V@28@04)
                      (<
                        i1@140@04
                        (alen<Int> (opt_get1 $Snap.unit target@27@04)))
                      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@140@04)) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@140@04))
                      (<
                        i2@141@04
                        (alen<Int> (opt_get1 $Snap.unit target@27@04)))
                      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@141@04)) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@141@04))))))))))
      (implies
        (and
          (and
            (and
              (and
                (=
                  ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@140@04))
                  ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@141@04)))
                (< i2@141@04 V@28@04))
              (<= 0 i2@141@04))
            (< i1@140@04 V@28@04))
          (<= 0 i1@140@04))
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@140@04))
            ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@141@04)))
          (< i2@141@04 V@28@04)
          (<= 0 i2@141@04)
          (< i1@140@04 V@28@04)
          (<= 0 i1@140@04))))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@141@04))
    :qid |prog.l<no position>-aux|))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@140@04))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 8
(pop) ; 7
; Joined path conditions
(assert (implies
  (and (< 0 V@28@04) (= exc@123@04 $Ref.null))
  (and
    (< 0 V@28@04)
    (= exc@123@04 $Ref.null)
    (forall ((i1@140@04 Int)) (!
      (forall ((i2@141@04 Int)) (!
        (and
          (implies
            (<= 0 i1@140@04)
            (and
              (<= 0 i1@140@04)
              (implies
                (< i1@140@04 V@28@04)
                (and
                  (< i1@140@04 V@28@04)
                  (implies
                    (<= 0 i2@141@04)
                    (and
                      (<= 0 i2@141@04)
                      (implies
                        (< i2@141@04 V@28@04)
                        (and
                          (< i2@141@04 V@28@04)
                          (<
                            i1@140@04
                            (alen<Int> (opt_get1 $Snap.unit target@27@04)))
                          ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
                            $Snap.unit
                            $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@140@04)) (aloc ($Snap.combine
                            $Snap.unit
                            $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@140@04))
                          (<
                            i2@141@04
                            (alen<Int> (opt_get1 $Snap.unit target@27@04)))
                          ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
                            $Snap.unit
                            $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@141@04)) (aloc ($Snap.combine
                            $Snap.unit
                            $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@141@04))))))))))
          (implies
            (and
              (and
                (and
                  (and
                    (=
                      ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@140@04))
                      ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@141@04)))
                    (< i2@141@04 V@28@04))
                  (<= 0 i2@141@04))
                (< i1@140@04 V@28@04))
              (<= 0 i1@140@04))
            (and
              (=
                ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@140@04))
                ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@141@04)))
              (< i2@141@04 V@28@04)
              (<= 0 i2@141@04)
              (< i1@140@04 V@28@04)
              (<= 0 i1@140@04))))
        :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@141@04))
        :qid |prog.l<no position>-aux|))
      :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@140@04))
      :qid |prog.l<no position>-aux|)))))
(assert (implies
  (and (< 0 V@28@04) (= exc@123@04 $Ref.null))
  (forall ((i1@140@04 Int)) (!
    (forall ((i2@141@04 Int)) (!
      (implies
        (and
          (and
            (and
              (and
                (=
                  ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@140@04))
                  ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@141@04)))
                (< i2@141@04 V@28@04))
              (<= 0 i2@141@04))
            (< i1@140@04 V@28@04))
          (<= 0 i1@140@04))
        (= i1@140@04 i2@141@04))
      :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@141@04))
      :qid |prog.l<no position>|))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@140@04))
    :qid |prog.l<no position>|))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@04)))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@04))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@04)))))))))))))))))
; [eval] exc == null
(set-option :timeout 10)
(push) ; 7
(assert (not (not (= exc@123@04 $Ref.null))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               10299
;  :arith-add-rows          8004
;  :arith-assert-diseq      563
;  :arith-assert-lower      3044
;  :arith-assert-upper      1886
;  :arith-bound-prop        823
;  :arith-conflicts         289
;  :arith-eq-adapter        1935
;  :arith-fixed-eqs         840
;  :arith-grobner           50
;  :arith-max-min           430
;  :arith-nonlinear-bounds  29
;  :arith-nonlinear-horner  40
;  :arith-offset-eqs        983
;  :arith-pivots            1788
;  :conflicts               847
;  :datatype-accessor-ax    53
;  :datatype-constructor-ax 488
;  :datatype-occurs-check   178
;  :datatype-splits         96
;  :decisions               1667
;  :del-clause              11688
;  :final-checks            150
;  :interface-eqs           2
;  :max-generation          5
;  :max-memory              6.79
;  :memory                  6.75
;  :minimized-lits          69
;  :mk-bool-var             17355
;  :mk-clause               11697
;  :num-allocs              335007
;  :num-checks              243
;  :propagations            6225
;  :quant-instantiations    3776
;  :rlimit-count            734794
;  :time                    0.00)
(push) ; 7
(assert (not (= exc@123@04 $Ref.null)))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               10299
;  :arith-add-rows          8004
;  :arith-assert-diseq      563
;  :arith-assert-lower      3044
;  :arith-assert-upper      1886
;  :arith-bound-prop        823
;  :arith-conflicts         289
;  :arith-eq-adapter        1935
;  :arith-fixed-eqs         840
;  :arith-grobner           50
;  :arith-max-min           430
;  :arith-nonlinear-bounds  29
;  :arith-nonlinear-horner  40
;  :arith-offset-eqs        983
;  :arith-pivots            1788
;  :conflicts               847
;  :datatype-accessor-ax    53
;  :datatype-constructor-ax 488
;  :datatype-occurs-check   178
;  :datatype-splits         96
;  :decisions               1667
;  :del-clause              11688
;  :final-checks            150
;  :interface-eqs           2
;  :max-generation          5
;  :max-memory              6.79
;  :memory                  6.75
;  :minimized-lits          69
;  :mk-bool-var             17355
;  :mk-clause               11697
;  :num-allocs              335025
;  :num-checks              244
;  :propagations            6225
;  :quant-instantiations    3776
;  :rlimit-count            734805)
; [then-branch: 165 | exc@123@04 == Null | live]
; [else-branch: 165 | exc@123@04 != Null | dead]
(push) ; 7
; [then-branch: 165 | exc@123@04 == Null]
(assert (= exc@123@04 $Ref.null))
(declare-const unknown@142@04 Int)
(declare-const unknown1@143@04 Int)
(push) ; 8
; [eval] 0 <= unknown && unknown < V && (0 <= unknown1 && unknown1 < V)
; [eval] 0 <= unknown
(push) ; 9
; [then-branch: 166 | 0 <= unknown@142@04 | live]
; [else-branch: 166 | !(0 <= unknown@142@04) | live]
(push) ; 10
; [then-branch: 166 | 0 <= unknown@142@04]
(assert (<= 0 unknown@142@04))
; [eval] unknown < V
(push) ; 11
; [then-branch: 167 | unknown@142@04 < V@28@04 | live]
; [else-branch: 167 | !(unknown@142@04 < V@28@04) | live]
(push) ; 12
; [then-branch: 167 | unknown@142@04 < V@28@04]
(assert (< unknown@142@04 V@28@04))
; [eval] 0 <= unknown1
(push) ; 13
; [then-branch: 168 | 0 <= unknown1@143@04 | live]
; [else-branch: 168 | !(0 <= unknown1@143@04) | live]
(push) ; 14
; [then-branch: 168 | 0 <= unknown1@143@04]
(assert (<= 0 unknown1@143@04))
; [eval] unknown1 < V
(pop) ; 14
(push) ; 14
; [else-branch: 168 | !(0 <= unknown1@143@04)]
(assert (not (<= 0 unknown1@143@04)))
(pop) ; 14
(pop) ; 13
; Joined path conditions
; Joined path conditions
(pop) ; 12
(push) ; 12
; [else-branch: 167 | !(unknown@142@04 < V@28@04)]
(assert (not (< unknown@142@04 V@28@04)))
(pop) ; 12
(pop) ; 11
; Joined path conditions
; Joined path conditions
(pop) ; 10
(push) ; 10
; [else-branch: 166 | !(0 <= unknown@142@04)]
(assert (not (<= 0 unknown@142@04)))
(pop) ; 10
(pop) ; 9
; Joined path conditions
; Joined path conditions
(assert (and
  (and
    (and (< unknown1@143@04 V@28@04) (<= 0 unknown1@143@04))
    (< unknown@142@04 V@28@04))
  (<= 0 unknown@142@04)))
; [eval] aloc(opt_get1(aloc(opt_get1(target), unknown1).option$array$), unknown)
; [eval] opt_get1(aloc(opt_get1(target), unknown1).option$array$)
; [eval] aloc(opt_get1(target), unknown1)
; [eval] opt_get1(target)
(push) ; 9
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 9
; Joined path conditions
(push) ; 9
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 10
(assert (not (< unknown1@143@04 (alen<Int> (opt_get1 $Snap.unit target@27@04)))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               10299
;  :arith-add-rows          8004
;  :arith-assert-diseq      563
;  :arith-assert-lower      3050
;  :arith-assert-upper      1886
;  :arith-bound-prop        823
;  :arith-conflicts         289
;  :arith-eq-adapter        1935
;  :arith-fixed-eqs         840
;  :arith-grobner           50
;  :arith-max-min           430
;  :arith-nonlinear-bounds  29
;  :arith-nonlinear-horner  40
;  :arith-offset-eqs        983
;  :arith-pivots            1791
;  :conflicts               847
;  :datatype-accessor-ax    53
;  :datatype-constructor-ax 488
;  :datatype-occurs-check   178
;  :datatype-splits         96
;  :decisions               1667
;  :del-clause              11688
;  :final-checks            150
;  :interface-eqs           2
;  :max-generation          5
;  :max-memory              6.79
;  :memory                  6.75
;  :minimized-lits          69
;  :mk-bool-var             17361
;  :mk-clause               11697
;  :num-allocs              335299
;  :num-checks              245
;  :propagations            6225
;  :quant-instantiations    3776
;  :rlimit-count            735292)
(assert (< unknown1@143@04 (alen<Int> (opt_get1 $Snap.unit target@27@04))))
(pop) ; 9
; Joined path conditions
(assert (< unknown1@143@04 (alen<Int> (opt_get1 $Snap.unit target@27@04))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@143@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@143@04)))
(push) ; 9
(assert (not (<
  $Perm.No
  (+
    (+
      (+
        (ite
          (and
            (<
              (inv@136@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@143@04))
              V@28@04)
            (<=
              0
              (inv@136@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@143@04))))
          (*
            (scale $Snap.unit (* (to_real (* V@28@04 V@28@04)) $Perm.Write))
            $k@135@04)
          $Perm.No)
        (ite
          (and
            (<
              (inv@128@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@143@04))
              V@28@04)
            (<=
              0
              (inv@128@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@143@04))))
          (*
            (scale $Snap.unit (* (to_real (* V@28@04 V@28@04)) $Perm.Write))
            $k@127@04)
          $Perm.No))
      (-
        (-
          (ite
            (and
              (<
                (inv@42@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@143@04))
                V@28@04)
              (<=
                0
                (inv@42@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@143@04))))
            $k@41@04
            $Perm.No)
          (pTaken@95@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@143@04)))
        (pTaken@106@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@143@04))))
    (-
      (-
        (ite
          (and
            (<
              (inv@34@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@143@04))
              V@28@04)
            (<=
              0
              (inv@34@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@143@04))))
          $k@33@04
          $Perm.No)
        (pTaken@96@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@143@04)))
      (pTaken@105@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@143@04)))))))
(check-sat)
; unsat
(pop) ; 9
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               10864
;  :arith-add-rows          8649
;  :arith-assert-diseq      607
;  :arith-assert-lower      3233
;  :arith-assert-upper      2024
;  :arith-bound-prop        869
;  :arith-conflicts         308
;  :arith-eq-adapter        2082
;  :arith-fixed-eqs         894
;  :arith-grobner           50
;  :arith-max-min           430
;  :arith-nonlinear-bounds  29
;  :arith-nonlinear-horner  40
;  :arith-offset-eqs        1054
;  :arith-pivots            1886
;  :conflicts               890
;  :datatype-accessor-ax    53
;  :datatype-constructor-ax 492
;  :datatype-occurs-check   178
;  :datatype-splits         96
;  :decisions               1763
;  :del-clause              12237
;  :final-checks            150
;  :interface-eqs           2
;  :max-generation          5
;  :max-memory              6.81
;  :memory                  6.79
;  :minimized-lits          69
;  :mk-bool-var             18317
;  :mk-clause               12371
;  :num-allocs              339440
;  :num-checks              246
;  :propagations            6728
;  :quant-instantiations    3961
;  :rlimit-count            763358
;  :time                    0.01)
(push) ; 9
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 10
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@143@04))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               10864
;  :arith-add-rows          8649
;  :arith-assert-diseq      607
;  :arith-assert-lower      3233
;  :arith-assert-upper      2024
;  :arith-bound-prop        869
;  :arith-conflicts         308
;  :arith-eq-adapter        2082
;  :arith-fixed-eqs         894
;  :arith-grobner           50
;  :arith-max-min           430
;  :arith-nonlinear-bounds  29
;  :arith-nonlinear-horner  40
;  :arith-offset-eqs        1054
;  :arith-pivots            1886
;  :conflicts               891
;  :datatype-accessor-ax    53
;  :datatype-constructor-ax 492
;  :datatype-occurs-check   178
;  :datatype-splits         96
;  :decisions               1763
;  :del-clause              12237
;  :final-checks            150
;  :interface-eqs           2
;  :max-generation          5
;  :max-memory              6.81
;  :memory                  6.79
;  :minimized-lits          69
;  :mk-bool-var             18317
;  :mk-clause               12371
;  :num-allocs              339535
;  :num-checks              247
;  :propagations            6728
;  :quant-instantiations    3961
;  :rlimit-count            763453)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@143@04))
    (as None<option<array>>  option<array>))))
(pop) ; 9
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@143@04))
    (as None<option<array>>  option<array>))))
(push) ; 9
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 10
(assert (not (<
  unknown@142@04
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@143@04)))))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               10868
;  :arith-add-rows          8651
;  :arith-assert-diseq      607
;  :arith-assert-lower      3234
;  :arith-assert-upper      2025
;  :arith-bound-prop        871
;  :arith-conflicts         308
;  :arith-eq-adapter        2083
;  :arith-fixed-eqs         894
;  :arith-grobner           50
;  :arith-max-min           430
;  :arith-nonlinear-bounds  29
;  :arith-nonlinear-horner  40
;  :arith-offset-eqs        1054
;  :arith-pivots            1888
;  :conflicts               892
;  :datatype-accessor-ax    53
;  :datatype-constructor-ax 492
;  :datatype-occurs-check   178
;  :datatype-splits         96
;  :decisions               1763
;  :del-clause              12243
;  :final-checks            150
;  :interface-eqs           2
;  :max-generation          5
;  :max-memory              6.81
;  :memory                  6.79
;  :minimized-lits          69
;  :mk-bool-var             18328
;  :mk-clause               12377
;  :num-allocs              339732
;  :num-checks              248
;  :propagations            6728
;  :quant-instantiations    3968
;  :rlimit-count            763864)
(assert (<
  unknown@142@04
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@143@04))))))
(pop) ; 9
; Joined path conditions
(assert (<
  unknown@142@04
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@143@04))))))
(pop) ; 8
(declare-fun inv@144@04 ($Ref) Int)
(declare-fun inv@145@04 ($Ref) Int)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(assert (forall ((unknown@142@04 Int) (unknown1@143@04 Int)) (!
  (and
    (< unknown1@143@04 (alen<Int> (opt_get1 $Snap.unit target@27@04)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@143@04)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@143@04))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@143@04))
        (as None<option<array>>  option<array>)))
    (<
      unknown@142@04
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@143@04))))))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@143@04))) unknown@142@04))
  :qid |int-aux|)))
; Check receiver injectivity
(push) ; 8
(assert (not (forall ((unknown1@142@04 Int) (unknown11@143@04 Int) (unknown2@142@04 Int) (unknown12@143@04 Int)) (!
  (implies
    (and
      (and
        (and
          (and (< unknown11@143@04 V@28@04) (<= 0 unknown11@143@04))
          (< unknown1@142@04 V@28@04))
        (<= 0 unknown1@142@04))
      (and
        (and
          (and (< unknown12@143@04 V@28@04) (<= 0 unknown12@143@04))
          (< unknown2@142@04 V@28@04))
        (<= 0 unknown2@142@04))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown11@143@04))) unknown1@142@04)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown12@143@04))) unknown2@142@04)))
    (and
      (= unknown1@142@04 unknown2@142@04)
      (= unknown11@143@04 unknown12@143@04)))
  
  :qid |int-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               10918
;  :arith-add-rows          8673
;  :arith-assert-diseq      607
;  :arith-assert-lower      3248
;  :arith-assert-upper      2030
;  :arith-bound-prop        874
;  :arith-conflicts         308
;  :arith-eq-adapter        2091
;  :arith-fixed-eqs         896
;  :arith-grobner           50
;  :arith-max-min           430
;  :arith-nonlinear-bounds  29
;  :arith-nonlinear-horner  40
;  :arith-offset-eqs        1058
;  :arith-pivots            1907
;  :conflicts               893
;  :datatype-accessor-ax    53
;  :datatype-constructor-ax 492
;  :datatype-occurs-check   178
;  :datatype-splits         96
;  :decisions               1763
;  :del-clause              12619
;  :final-checks            150
;  :interface-eqs           2
;  :max-generation          5
;  :max-memory              6.83
;  :memory                  6.80
;  :minimized-lits          69
;  :mk-bool-var             18710
;  :mk-clause               12628
;  :num-allocs              341906
;  :num-checks              249
;  :propagations            6767
;  :quant-instantiations    4105
;  :rlimit-count            772559
;  :time                    0.00)
; Definitional axioms for inverse functions
(assert (forall ((unknown@142@04 Int) (unknown1@143@04 Int)) (!
  (implies
    (and
      (and
        (and (< unknown1@143@04 V@28@04) (<= 0 unknown1@143@04))
        (< unknown@142@04 V@28@04))
      (<= 0 unknown@142@04))
    (and
      (=
        (inv@144@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@143@04))) unknown@142@04))
        unknown@142@04)
      (=
        (inv@145@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@143@04))) unknown@142@04))
        unknown1@143@04)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@143@04))) unknown@142@04))
  )))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@145@04 r) V@28@04) (<= 0 (inv@145@04 r)))
        (< (inv@144@04 r) V@28@04))
      (<= 0 (inv@144@04 r)))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@27@04) (inv@145@04 r)))) (inv@144@04 r))
      r))
  :pattern ((inv@144@04 r))
  :pattern ((inv@145@04 r))
  :qid |int-fctOfInv|)))
; Permissions are non-negative
; Field permissions are at most one
; Permission implies non-null receiver
(assert (forall ((unknown@142@04 Int) (unknown1@143@04 Int)) (!
  (implies
    (and
      (and
        (and (< unknown1@143@04 V@28@04) (<= 0 unknown1@143@04))
        (< unknown@142@04 V@28@04))
      (<= 0 unknown@142@04))
    (not
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@143@04))) unknown@142@04)
        $Ref.null)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@143@04))) unknown@142@04))
  :qid |int-permImpliesNonNull|)))
(declare-const sm@146@04 $FVF<Int>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@145@04 r) V@28@04) (<= 0 (inv@145@04 r)))
        (< (inv@144@04 r) V@28@04))
      (<= 0 (inv@144@04 r)))
    (=
      ($FVF.lookup_int (as sm@146@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@04))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@146@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@04))))))))))))))) r))
  :qid |qp.fvfValDef41|)))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (ite
          (and
            (and
              (and (< (inv@52@04 r) V@28@04) (<= 0 (inv@52@04 r)))
              (< (inv@51@04 r) V@28@04))
            (<= 0 (inv@51@04 r)))
          $k@50@04
          $Perm.No)
        (pTaken@122@04 r)))
    (=
      ($FVF.lookup_int (as sm@146@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@31@04))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@146@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@31@04))))))))))))))) r))
  :qid |qp.fvfValDef42|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@04))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@31@04))))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@146@04  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef43|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@145@04 r) V@28@04) (<= 0 (inv@145@04 r)))
        (< (inv@144@04 r) V@28@04))
      (<= 0 (inv@144@04 r)))
    ($FVF.loc_int ($FVF.lookup_int (as sm@146@04  $FVF<Int>) r) r))
  :pattern ((inv@144@04 r) (inv@145@04 r))
  )))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@04))))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@04)))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@04))))))))))))))))))
; [eval] exc == null
(set-option :timeout 10)
(push) ; 8
(assert (not (not (= exc@123@04 $Ref.null))))
(check-sat)
; unknown
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               10963
;  :arith-add-rows          8673
;  :arith-assert-diseq      607
;  :arith-assert-lower      3270
;  :arith-assert-upper      2044
;  :arith-bound-prop        874
;  :arith-conflicts         309
;  :arith-eq-adapter        2091
;  :arith-fixed-eqs         896
;  :arith-grobner           55
;  :arith-max-min           468
;  :arith-nonlinear-bounds  31
;  :arith-nonlinear-horner  44
;  :arith-offset-eqs        1059
;  :arith-pivots            1907
;  :conflicts               894
;  :datatype-accessor-ax    54
;  :datatype-constructor-ax 501
;  :datatype-occurs-check   186
;  :datatype-splits         101
;  :decisions               1773
;  :del-clause              12619
;  :final-checks            155
;  :interface-eqs           2
;  :max-generation          5
;  :max-memory              6.83
;  :memory                  6.81
;  :minimized-lits          69
;  :mk-bool-var             18723
;  :mk-clause               12628
;  :num-allocs              344058
;  :num-checks              250
;  :propagations            6770
;  :quant-instantiations    4105
;  :rlimit-count            778377
;  :time                    0.00)
; [then-branch: 169 | exc@123@04 == Null | live]
; [else-branch: 169 | exc@123@04 != Null | dead]
(push) ; 8
; [then-branch: 169 | exc@123@04 == Null]
(declare-const unknown@147@04 Int)
(declare-const unknown1@148@04 Int)
(push) ; 9
; [eval] 0 <= unknown && unknown < V && (0 <= unknown1 && unknown1 < V)
; [eval] 0 <= unknown
(push) ; 10
; [then-branch: 170 | 0 <= unknown@147@04 | live]
; [else-branch: 170 | !(0 <= unknown@147@04) | live]
(push) ; 11
; [then-branch: 170 | 0 <= unknown@147@04]
(assert (<= 0 unknown@147@04))
; [eval] unknown < V
(push) ; 12
; [then-branch: 171 | unknown@147@04 < V@28@04 | live]
; [else-branch: 171 | !(unknown@147@04 < V@28@04) | live]
(push) ; 13
; [then-branch: 171 | unknown@147@04 < V@28@04]
(assert (< unknown@147@04 V@28@04))
; [eval] 0 <= unknown1
(push) ; 14
; [then-branch: 172 | 0 <= unknown1@148@04 | live]
; [else-branch: 172 | !(0 <= unknown1@148@04) | live]
(push) ; 15
; [then-branch: 172 | 0 <= unknown1@148@04]
(assert (<= 0 unknown1@148@04))
; [eval] unknown1 < V
(pop) ; 15
(push) ; 15
; [else-branch: 172 | !(0 <= unknown1@148@04)]
(assert (not (<= 0 unknown1@148@04)))
(pop) ; 15
(pop) ; 14
; Joined path conditions
; Joined path conditions
(pop) ; 13
(push) ; 13
; [else-branch: 171 | !(unknown@147@04 < V@28@04)]
(assert (not (< unknown@147@04 V@28@04)))
(pop) ; 13
(pop) ; 12
; Joined path conditions
; Joined path conditions
(pop) ; 11
(push) ; 11
; [else-branch: 170 | !(0 <= unknown@147@04)]
(assert (not (<= 0 unknown@147@04)))
(pop) ; 11
(pop) ; 10
; Joined path conditions
; Joined path conditions
(assert (and
  (and
    (and (< unknown1@148@04 V@28@04) (<= 0 unknown1@148@04))
    (< unknown@147@04 V@28@04))
  (<= 0 unknown@147@04)))
; [eval] aloc(opt_get1(aloc(opt_get1(source), unknown1).option$array$), unknown)
; [eval] opt_get1(aloc(opt_get1(source), unknown1).option$array$)
; [eval] aloc(opt_get1(source), unknown1)
; [eval] opt_get1(source)
(push) ; 10
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 10
; Joined path conditions
(push) ; 10
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 11
(assert (not (< unknown1@148@04 (alen<Int> (opt_get1 $Snap.unit source@26@04)))))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               10963
;  :arith-add-rows          8673
;  :arith-assert-diseq      607
;  :arith-assert-lower      3276
;  :arith-assert-upper      2044
;  :arith-bound-prop        874
;  :arith-conflicts         309
;  :arith-eq-adapter        2091
;  :arith-fixed-eqs         896
;  :arith-grobner           55
;  :arith-max-min           468
;  :arith-nonlinear-bounds  31
;  :arith-nonlinear-horner  44
;  :arith-offset-eqs        1059
;  :arith-pivots            1910
;  :conflicts               894
;  :datatype-accessor-ax    54
;  :datatype-constructor-ax 501
;  :datatype-occurs-check   186
;  :datatype-splits         101
;  :decisions               1773
;  :del-clause              12619
;  :final-checks            155
;  :interface-eqs           2
;  :max-generation          5
;  :max-memory              6.83
;  :memory                  6.81
;  :minimized-lits          69
;  :mk-bool-var             18729
;  :mk-clause               12628
;  :num-allocs              344332
;  :num-checks              251
;  :propagations            6770
;  :quant-instantiations    4105
;  :rlimit-count            778861)
(assert (< unknown1@148@04 (alen<Int> (opt_get1 $Snap.unit source@26@04))))
(pop) ; 10
; Joined path conditions
(assert (< unknown1@148@04 (alen<Int> (opt_get1 $Snap.unit source@26@04))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@148@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@148@04)))
(push) ; 10
(assert (not (<
  $Perm.No
  (+
    (+
      (+
        (ite
          (and
            (<
              (inv@136@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@148@04))
              V@28@04)
            (<=
              0
              (inv@136@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@148@04))))
          (*
            (scale $Snap.unit (* (to_real (* V@28@04 V@28@04)) $Perm.Write))
            $k@135@04)
          $Perm.No)
        (ite
          (and
            (<
              (inv@128@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@148@04))
              V@28@04)
            (<=
              0
              (inv@128@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@148@04))))
          (*
            (scale $Snap.unit (* (to_real (* V@28@04 V@28@04)) $Perm.Write))
            $k@127@04)
          $Perm.No))
      (-
        (-
          (ite
            (and
              (<
                (inv@42@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@148@04))
                V@28@04)
              (<=
                0
                (inv@42@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@148@04))))
            $k@41@04
            $Perm.No)
          (pTaken@95@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@148@04)))
        (pTaken@106@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@148@04))))
    (-
      (-
        (ite
          (and
            (<
              (inv@34@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@148@04))
              V@28@04)
            (<=
              0
              (inv@34@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@148@04))))
          $k@33@04
          $Perm.No)
        (pTaken@96@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@148@04)))
      (pTaken@105@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@148@04)))))))
(check-sat)
; unsat
(pop) ; 10
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               11692
;  :arith-add-rows          9406
;  :arith-assert-diseq      669
;  :arith-assert-lower      3496
;  :arith-assert-upper      2199
;  :arith-bound-prop        941
;  :arith-conflicts         328
;  :arith-eq-adapter        2259
;  :arith-fixed-eqs         979
;  :arith-grobner           55
;  :arith-max-min           468
;  :arith-nonlinear-bounds  31
;  :arith-nonlinear-horner  44
;  :arith-offset-eqs        1176
;  :arith-pivots            2011
;  :conflicts               934
;  :datatype-accessor-ax    54
;  :datatype-constructor-ax 505
;  :datatype-occurs-check   186
;  :datatype-splits         101
;  :decisions               1918
;  :del-clause              13698
;  :final-checks            155
;  :interface-eqs           2
;  :max-generation          6
;  :max-memory              6.87
;  :memory                  6.85
;  :minimized-lits          71
;  :mk-bool-var             20220
;  :mk-clause               13836
;  :num-allocs              349453
;  :num-checks              252
;  :propagations            7354
;  :quant-instantiations    4390
;  :rlimit-count            811812
;  :time                    0.01)
(push) ; 10
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 11
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@148@04))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               11990
;  :arith-add-rows          9572
;  :arith-assert-diseq      689
;  :arith-assert-lower      3594
;  :arith-assert-upper      2254
;  :arith-bound-prop        971
;  :arith-conflicts         333
;  :arith-eq-adapter        2322
;  :arith-fixed-eqs         994
;  :arith-grobner           55
;  :arith-max-min           468
;  :arith-nonlinear-bounds  31
;  :arith-nonlinear-horner  44
;  :arith-offset-eqs        1223
;  :arith-pivots            2041
;  :conflicts               950
;  :datatype-accessor-ax    55
;  :datatype-constructor-ax 510
;  :datatype-occurs-check   186
;  :datatype-splits         101
;  :decisions               1941
;  :del-clause              13857
;  :final-checks            155
;  :interface-eqs           2
;  :max-generation          6
;  :max-memory              6.87
;  :memory                  6.85
;  :minimized-lits          72
;  :mk-bool-var             20448
;  :mk-clause               13995
;  :num-allocs              350476
;  :num-checks              253
;  :propagations            7587
;  :quant-instantiations    4425
;  :rlimit-count            817098
;  :time                    0.00)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@148@04))
    (as None<option<array>>  option<array>))))
(pop) ; 10
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@148@04))
    (as None<option<array>>  option<array>))))
(push) ; 10
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 11
(assert (not (<
  unknown@147@04
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@148@04)))))))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               12292
;  :arith-add-rows          9816
;  :arith-assert-diseq      708
;  :arith-assert-lower      3706
;  :arith-assert-upper      2312
;  :arith-bound-prop        996
;  :arith-conflicts         342
;  :arith-eq-adapter        2401
;  :arith-fixed-eqs         1016
;  :arith-grobner           55
;  :arith-max-min           468
;  :arith-nonlinear-bounds  31
;  :arith-nonlinear-horner  44
;  :arith-offset-eqs        1252
;  :arith-pivots            2074
;  :conflicts               975
;  :datatype-accessor-ax    55
;  :datatype-constructor-ax 514
;  :datatype-occurs-check   186
;  :datatype-splits         101
;  :decisions               1972
;  :del-clause              14101
;  :final-checks            155
;  :interface-eqs           2
;  :max-generation          6
;  :max-memory              6.87
;  :memory                  6.85
;  :minimized-lits          72
;  :mk-bool-var             20791
;  :mk-clause               14239
;  :num-allocs              351709
;  :num-checks              254
;  :propagations            7796
;  :quant-instantiations    4466
;  :rlimit-count            822961
;  :time                    0.00)
(assert (<
  unknown@147@04
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@148@04))))))
(pop) ; 10
; Joined path conditions
(assert (<
  unknown@147@04
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@148@04))))))
(declare-const $k@149@04 $Perm)
(assert ($Perm.isReadVar $k@149@04 $Perm.Write))
(pop) ; 9
(declare-fun inv@150@04 ($Ref) Int)
(declare-fun inv@151@04 ($Ref) Int)
; Nested auxiliary terms: globals
(assert ($Perm.isReadVar $k@149@04 $Perm.Write))
; Nested auxiliary terms: non-globals
(assert (forall ((unknown@147@04 Int) (unknown1@148@04 Int)) (!
  (and
    (< unknown1@148@04 (alen<Int> (opt_get1 $Snap.unit source@26@04)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@148@04)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@148@04))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@148@04))
        (as None<option<array>>  option<array>)))
    (<
      unknown@147@04
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@148@04))))))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@148@04))) unknown@147@04))
  :qid |int-aux|)))
(push) ; 9
(assert (not (forall ((unknown@147@04 Int) (unknown1@148@04 Int)) (!
  (implies
    (and
      (and
        (and (< unknown1@148@04 V@28@04) (<= 0 unknown1@148@04))
        (< unknown@147@04 V@28@04))
      (<= 0 unknown@147@04))
    (or (= $k@149@04 $Perm.No) (< $Perm.No $k@149@04)))
  
  ))))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               12292
;  :arith-add-rows          9821
;  :arith-assert-diseq      709
;  :arith-assert-lower      3708
;  :arith-assert-upper      2313
;  :arith-bound-prop        996
;  :arith-conflicts         342
;  :arith-eq-adapter        2402
;  :arith-fixed-eqs         1016
;  :arith-grobner           55
;  :arith-max-min           468
;  :arith-nonlinear-bounds  31
;  :arith-nonlinear-horner  44
;  :arith-offset-eqs        1252
;  :arith-pivots            2085
;  :conflicts               976
;  :datatype-accessor-ax    55
;  :datatype-constructor-ax 514
;  :datatype-occurs-check   186
;  :datatype-splits         101
;  :decisions               1972
;  :del-clause              14230
;  :final-checks            155
;  :interface-eqs           2
;  :max-generation          6
;  :max-memory              6.87
;  :memory                  6.84
;  :minimized-lits          72
;  :mk-bool-var             20800
;  :mk-clause               14241
;  :num-allocs              352268
;  :num-checks              255
;  :propagations            7797
;  :quant-instantiations    4466
;  :rlimit-count            823989)
; Check receiver injectivity
(push) ; 9
(assert (not (forall ((unknown1@147@04 Int) (unknown11@148@04 Int) (unknown2@147@04 Int) (unknown12@148@04 Int)) (!
  (implies
    (and
      (and
        (and
          (and
            (and (< unknown11@148@04 V@28@04) (<= 0 unknown11@148@04))
            (< unknown1@147@04 V@28@04))
          (<= 0 unknown1@147@04))
        (< $Perm.No $k@149@04))
      (and
        (and
          (and
            (and (< unknown12@148@04 V@28@04) (<= 0 unknown12@148@04))
            (< unknown2@147@04 V@28@04))
          (<= 0 unknown2@147@04))
        (< $Perm.No $k@149@04))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown11@148@04))) unknown1@147@04)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown12@148@04))) unknown2@147@04)))
    (and
      (= unknown1@147@04 unknown2@147@04)
      (= unknown11@148@04 unknown12@148@04)))
  
  :qid |int-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 9
; 0.04s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               14405
;  :arith-add-rows          11471
;  :arith-assert-diseq      833
;  :arith-assert-lower      4527
;  :arith-assert-upper      2786
;  :arith-bound-prop        1129
;  :arith-conflicts         361
;  :arith-eq-adapter        2870
;  :arith-fixed-eqs         1265
;  :arith-grobner           55
;  :arith-max-min           468
;  :arith-nonlinear-bounds  31
;  :arith-nonlinear-horner  44
;  :arith-offset-eqs        1492
;  :arith-pivots            2381
;  :conflicts               1019
;  :datatype-accessor-ax    57
;  :datatype-constructor-ax 522
;  :datatype-occurs-check   186
;  :datatype-splits         101
;  :decisions               2320
;  :del-clause              16928
;  :final-checks            155
;  :interface-eqs           2
;  :max-generation          9
;  :max-memory              7.21
;  :memory                  7.15
;  :minimized-lits          102
;  :mk-bool-var             23958
;  :mk-clause               16939
;  :num-allocs              363773
;  :num-checks              256
;  :propagations            9675
;  :quant-instantiations    5296
;  :rlimit-count            891073
;  :time                    0.04)
; Definitional axioms for inverse functions
(assert (forall ((unknown@147@04 Int) (unknown1@148@04 Int)) (!
  (implies
    (and
      (and
        (and
          (and (< unknown1@148@04 V@28@04) (<= 0 unknown1@148@04))
          (< unknown@147@04 V@28@04))
        (<= 0 unknown@147@04))
      (< $Perm.No $k@149@04))
    (and
      (=
        (inv@150@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@148@04))) unknown@147@04))
        unknown@147@04)
      (=
        (inv@151@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@148@04))) unknown@147@04))
        unknown1@148@04)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@148@04))) unknown@147@04))
  )))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and
          (and (< (inv@151@04 r) V@28@04) (<= 0 (inv@151@04 r)))
          (< (inv@150@04 r) V@28@04))
        (<= 0 (inv@150@04 r)))
      (< $Perm.No $k@149@04))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@26@04) (inv@151@04 r)))) (inv@150@04 r))
      r))
  :pattern ((inv@150@04 r))
  :pattern ((inv@151@04 r))
  :qid |int-fctOfInv|)))
; Permissions are non-negative
(assert (forall ((unknown@147@04 Int) (unknown1@148@04 Int)) (!
  (<= $Perm.No $k@149@04)
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@148@04))) unknown@147@04))
  :qid |int-permAtLeastZero|)))
; Field permissions are at most one
(assert (forall ((unknown@147@04 Int) (unknown1@148@04 Int)) (!
  (<= $k@149@04 $Perm.Write)
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@148@04))) unknown@147@04))
  :qid |int-permAtMostOne|)))
; Permission implies non-null receiver
(assert (forall ((unknown@147@04 Int) (unknown1@148@04 Int)) (!
  (implies
    (and
      (and
        (and
          (and (< unknown1@148@04 V@28@04) (<= 0 unknown1@148@04))
          (< unknown@147@04 V@28@04))
        (<= 0 unknown@147@04))
      (< $Perm.No $k@149@04))
    (not
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@148@04))) unknown@147@04)
        $Ref.null)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@148@04))) unknown@147@04))
  :qid |int-permImpliesNonNull|)))
(declare-const sm@152@04 $FVF<Int>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and
        (and
          (and (< (inv@151@04 r) V@28@04) (<= 0 (inv@151@04 r)))
          (< (inv@150@04 r) V@28@04))
        (<= 0 (inv@150@04 r)))
      (< $Perm.No $k@149@04)
      false)
    (=
      ($FVF.lookup_int (as sm@152@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@04)))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@152@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@04)))))))))))))))) r))
  :qid |qp.fvfValDef44|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@145@04 r) V@28@04) (<= 0 (inv@145@04 r)))
        (< (inv@144@04 r) V@28@04))
      (<= 0 (inv@144@04 r)))
    (=
      ($FVF.lookup_int (as sm@152@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@04))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@152@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@04))))))))))))))) r))
  :qid |qp.fvfValDef45|)))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (ite
          (and
            (and
              (and (< (inv@52@04 r) V@28@04) (<= 0 (inv@52@04 r)))
              (< (inv@51@04 r) V@28@04))
            (<= 0 (inv@51@04 r)))
          $k@50@04
          $Perm.No)
        (pTaken@122@04 r)))
    (=
      ($FVF.lookup_int (as sm@152@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@31@04))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@152@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@31@04))))))))))))))) r))
  :qid |qp.fvfValDef46|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@04)))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@04))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@31@04))))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@152@04  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef47|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@151@04 r) V@28@04) (<= 0 (inv@151@04 r)))
        (< (inv@150@04 r) V@28@04))
      (<= 0 (inv@150@04 r)))
    ($FVF.loc_int ($FVF.lookup_int (as sm@152@04  $FVF<Int>) r) r))
  :pattern ((inv@150@04 r) (inv@151@04 r))
  )))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@04)))))))))))))))
  $Snap.unit))
; [eval] exc == null ==> (forall unknown: Int :: 0 <= unknown && unknown < V ==> (forall unknown1: Int :: { aloc(opt_get1(aloc(opt_get1(target), unknown1).option$array$), unknown) } { aloc(opt_get1(aloc(opt_get1(source), unknown1).option$array$), unknown) } 0 <= unknown1 && unknown1 < V ==> aloc(opt_get1(aloc(opt_get1(target), unknown1).option$array$), unknown).int == aloc(opt_get1(aloc(opt_get1(source), unknown1).option$array$), unknown).int))
; [eval] exc == null
(push) ; 9
(set-option :timeout 10)
(push) ; 10
(assert (not (not (= exc@123@04 $Ref.null))))
(check-sat)
; unknown
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               14445
;  :arith-add-rows          11473
;  :arith-assert-diseq      833
;  :arith-assert-lower      4549
;  :arith-assert-upper      2801
;  :arith-bound-prop        1129
;  :arith-conflicts         362
;  :arith-eq-adapter        2870
;  :arith-fixed-eqs         1265
;  :arith-grobner           60
;  :arith-max-min           506
;  :arith-nonlinear-bounds  33
;  :arith-nonlinear-horner  48
;  :arith-offset-eqs        1493
;  :arith-pivots            2382
;  :conflicts               1020
;  :datatype-accessor-ax    57
;  :datatype-constructor-ax 530
;  :datatype-occurs-check   194
;  :datatype-splits         105
;  :decisions               2329
;  :del-clause              16928
;  :final-checks            160
;  :interface-eqs           2
;  :max-generation          9
;  :max-memory              7.21
;  :memory                  7.16
;  :minimized-lits          102
;  :mk-bool-var             23972
;  :mk-clause               16939
;  :num-allocs              366332
;  :num-checks              257
;  :propagations            9678
;  :quant-instantiations    5296
;  :rlimit-count            898423)
; [then-branch: 173 | exc@123@04 == Null | live]
; [else-branch: 173 | exc@123@04 != Null | dead]
(push) ; 10
; [then-branch: 173 | exc@123@04 == Null]
; [eval] (forall unknown: Int :: 0 <= unknown && unknown < V ==> (forall unknown1: Int :: { aloc(opt_get1(aloc(opt_get1(target), unknown1).option$array$), unknown) } { aloc(opt_get1(aloc(opt_get1(source), unknown1).option$array$), unknown) } 0 <= unknown1 && unknown1 < V ==> aloc(opt_get1(aloc(opt_get1(target), unknown1).option$array$), unknown).int == aloc(opt_get1(aloc(opt_get1(source), unknown1).option$array$), unknown).int))
(declare-const unknown@153@04 Int)
(push) ; 11
; [eval] 0 <= unknown && unknown < V ==> (forall unknown1: Int :: { aloc(opt_get1(aloc(opt_get1(target), unknown1).option$array$), unknown) } { aloc(opt_get1(aloc(opt_get1(source), unknown1).option$array$), unknown) } 0 <= unknown1 && unknown1 < V ==> aloc(opt_get1(aloc(opt_get1(target), unknown1).option$array$), unknown).int == aloc(opt_get1(aloc(opt_get1(source), unknown1).option$array$), unknown).int)
; [eval] 0 <= unknown && unknown < V
; [eval] 0 <= unknown
(push) ; 12
; [then-branch: 174 | 0 <= unknown@153@04 | live]
; [else-branch: 174 | !(0 <= unknown@153@04) | live]
(push) ; 13
; [then-branch: 174 | 0 <= unknown@153@04]
(assert (<= 0 unknown@153@04))
; [eval] unknown < V
(pop) ; 13
(push) ; 13
; [else-branch: 174 | !(0 <= unknown@153@04)]
(assert (not (<= 0 unknown@153@04)))
(pop) ; 13
(pop) ; 12
; Joined path conditions
; Joined path conditions
(push) ; 12
; [then-branch: 175 | unknown@153@04 < V@28@04 && 0 <= unknown@153@04 | live]
; [else-branch: 175 | !(unknown@153@04 < V@28@04 && 0 <= unknown@153@04) | live]
(push) ; 13
; [then-branch: 175 | unknown@153@04 < V@28@04 && 0 <= unknown@153@04]
(assert (and (< unknown@153@04 V@28@04) (<= 0 unknown@153@04)))
; [eval] (forall unknown1: Int :: { aloc(opt_get1(aloc(opt_get1(target), unknown1).option$array$), unknown) } { aloc(opt_get1(aloc(opt_get1(source), unknown1).option$array$), unknown) } 0 <= unknown1 && unknown1 < V ==> aloc(opt_get1(aloc(opt_get1(target), unknown1).option$array$), unknown).int == aloc(opt_get1(aloc(opt_get1(source), unknown1).option$array$), unknown).int)
(declare-const unknown1@154@04 Int)
(push) ; 14
; [eval] 0 <= unknown1 && unknown1 < V ==> aloc(opt_get1(aloc(opt_get1(target), unknown1).option$array$), unknown).int == aloc(opt_get1(aloc(opt_get1(source), unknown1).option$array$), unknown).int
; [eval] 0 <= unknown1 && unknown1 < V
; [eval] 0 <= unknown1
(push) ; 15
; [then-branch: 176 | 0 <= unknown1@154@04 | live]
; [else-branch: 176 | !(0 <= unknown1@154@04) | live]
(push) ; 16
; [then-branch: 176 | 0 <= unknown1@154@04]
(assert (<= 0 unknown1@154@04))
; [eval] unknown1 < V
(pop) ; 16
(push) ; 16
; [else-branch: 176 | !(0 <= unknown1@154@04)]
(assert (not (<= 0 unknown1@154@04)))
(pop) ; 16
(pop) ; 15
; Joined path conditions
; Joined path conditions
(push) ; 15
; [then-branch: 177 | unknown1@154@04 < V@28@04 && 0 <= unknown1@154@04 | live]
; [else-branch: 177 | !(unknown1@154@04 < V@28@04 && 0 <= unknown1@154@04) | live]
(push) ; 16
; [then-branch: 177 | unknown1@154@04 < V@28@04 && 0 <= unknown1@154@04]
(assert (and (< unknown1@154@04 V@28@04) (<= 0 unknown1@154@04)))
; [eval] aloc(opt_get1(aloc(opt_get1(target), unknown1).option$array$), unknown).int == aloc(opt_get1(aloc(opt_get1(source), unknown1).option$array$), unknown).int
; [eval] aloc(opt_get1(aloc(opt_get1(target), unknown1).option$array$), unknown)
; [eval] opt_get1(aloc(opt_get1(target), unknown1).option$array$)
; [eval] aloc(opt_get1(target), unknown1)
; [eval] opt_get1(target)
(push) ; 17
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 17
; Joined path conditions
(push) ; 17
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 18
(assert (not (< unknown1@154@04 (alen<Int> (opt_get1 $Snap.unit target@27@04)))))
(check-sat)
; unsat
(pop) ; 18
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               14445
;  :arith-add-rows          11473
;  :arith-assert-diseq      833
;  :arith-assert-lower      4553
;  :arith-assert-upper      2801
;  :arith-bound-prop        1129
;  :arith-conflicts         362
;  :arith-eq-adapter        2870
;  :arith-fixed-eqs         1265
;  :arith-grobner           60
;  :arith-max-min           506
;  :arith-nonlinear-bounds  33
;  :arith-nonlinear-horner  48
;  :arith-offset-eqs        1493
;  :arith-pivots            2382
;  :conflicts               1020
;  :datatype-accessor-ax    57
;  :datatype-constructor-ax 530
;  :datatype-occurs-check   194
;  :datatype-splits         105
;  :decisions               2329
;  :del-clause              16928
;  :final-checks            160
;  :interface-eqs           2
;  :max-generation          9
;  :max-memory              7.21
;  :memory                  7.16
;  :minimized-lits          102
;  :mk-bool-var             23976
;  :mk-clause               16939
;  :num-allocs              366517
;  :num-checks              258
;  :propagations            9678
;  :quant-instantiations    5296
;  :rlimit-count            898778)
(assert (< unknown1@154@04 (alen<Int> (opt_get1 $Snap.unit target@27@04))))
(pop) ; 17
; Joined path conditions
(assert (< unknown1@154@04 (alen<Int> (opt_get1 $Snap.unit target@27@04))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@154@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@154@04)))
(push) ; 17
(assert (not (<
  $Perm.No
  (+
    (+
      (+
        (ite
          (and
            (<
              (inv@136@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@154@04))
              V@28@04)
            (<=
              0
              (inv@136@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@154@04))))
          (*
            (scale $Snap.unit (* (to_real (* V@28@04 V@28@04)) $Perm.Write))
            $k@135@04)
          $Perm.No)
        (ite
          (and
            (<
              (inv@128@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@154@04))
              V@28@04)
            (<=
              0
              (inv@128@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@154@04))))
          (*
            (scale $Snap.unit (* (to_real (* V@28@04 V@28@04)) $Perm.Write))
            $k@127@04)
          $Perm.No))
      (-
        (-
          (ite
            (and
              (<
                (inv@42@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@154@04))
                V@28@04)
              (<=
                0
                (inv@42@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@154@04))))
            $k@41@04
            $Perm.No)
          (pTaken@95@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@154@04)))
        (pTaken@106@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@154@04))))
    (-
      (-
        (ite
          (and
            (<
              (inv@34@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@154@04))
              V@28@04)
            (<=
              0
              (inv@34@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@154@04))))
          $k@33@04
          $Perm.No)
        (pTaken@96@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@154@04)))
      (pTaken@105@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@154@04)))))))
(check-sat)
; unsat
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               14834
;  :arith-add-rows          11756
;  :arith-assert-diseq      854
;  :arith-assert-lower      4689
;  :arith-assert-upper      2880
;  :arith-bound-prop        1181
;  :arith-conflicts         374
;  :arith-eq-adapter        2957
;  :arith-fixed-eqs         1306
;  :arith-grobner           60
;  :arith-max-min           506
;  :arith-nonlinear-bounds  33
;  :arith-nonlinear-horner  48
;  :arith-offset-eqs        1560
;  :arith-pivots            2442
;  :conflicts               1047
;  :datatype-accessor-ax    57
;  :datatype-constructor-ax 534
;  :datatype-occurs-check   194
;  :datatype-splits         105
;  :decisions               2387
;  :del-clause              17338
;  :final-checks            160
;  :interface-eqs           2
;  :max-generation          9
;  :max-memory              7.21
;  :memory                  7.16
;  :minimized-lits          102
;  :mk-bool-var             24620
;  :mk-clause               17474
;  :num-allocs              369158
;  :num-checks              259
;  :propagations            10006
;  :quant-instantiations    5396
;  :rlimit-count            912660
;  :time                    0.00)
(push) ; 17
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 18
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@154@04))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 18
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               14834
;  :arith-add-rows          11756
;  :arith-assert-diseq      854
;  :arith-assert-lower      4689
;  :arith-assert-upper      2880
;  :arith-bound-prop        1181
;  :arith-conflicts         374
;  :arith-eq-adapter        2957
;  :arith-fixed-eqs         1306
;  :arith-grobner           60
;  :arith-max-min           506
;  :arith-nonlinear-bounds  33
;  :arith-nonlinear-horner  48
;  :arith-offset-eqs        1560
;  :arith-pivots            2442
;  :conflicts               1048
;  :datatype-accessor-ax    57
;  :datatype-constructor-ax 534
;  :datatype-occurs-check   194
;  :datatype-splits         105
;  :decisions               2387
;  :del-clause              17338
;  :final-checks            160
;  :interface-eqs           2
;  :max-generation          9
;  :max-memory              7.21
;  :memory                  7.16
;  :minimized-lits          102
;  :mk-bool-var             24620
;  :mk-clause               17474
;  :num-allocs              369249
;  :num-checks              260
;  :propagations            10006
;  :quant-instantiations    5396
;  :rlimit-count            912755)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@154@04))
    (as None<option<array>>  option<array>))))
(pop) ; 17
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@154@04))
    (as None<option<array>>  option<array>))))
(push) ; 17
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 18
(assert (not (<
  unknown@153@04
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@154@04)))))))
(check-sat)
; unsat
(pop) ; 18
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               14840
;  :arith-add-rows          11761
;  :arith-assert-diseq      854
;  :arith-assert-lower      4692
;  :arith-assert-upper      2881
;  :arith-bound-prop        1181
;  :arith-conflicts         375
;  :arith-eq-adapter        2958
;  :arith-fixed-eqs         1307
;  :arith-grobner           60
;  :arith-max-min           506
;  :arith-nonlinear-bounds  33
;  :arith-nonlinear-horner  48
;  :arith-offset-eqs        1560
;  :arith-pivots            2446
;  :conflicts               1049
;  :datatype-accessor-ax    57
;  :datatype-constructor-ax 534
;  :datatype-occurs-check   194
;  :datatype-splits         105
;  :decisions               2387
;  :del-clause              17342
;  :final-checks            160
;  :interface-eqs           2
;  :max-generation          9
;  :max-memory              7.21
;  :memory                  7.16
;  :minimized-lits          102
;  :mk-bool-var             24631
;  :mk-clause               17478
;  :num-allocs              369443
;  :num-checks              261
;  :propagations            10008
;  :quant-instantiations    5403
;  :rlimit-count            913247)
(assert (<
  unknown@153@04
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@154@04))))))
(pop) ; 17
; Joined path conditions
(assert (<
  unknown@153@04
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@154@04))))))
(assert ($FVF.loc_int ($FVF.lookup_int (as sm@152@04  $FVF<Int>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@154@04))) unknown@153@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@154@04))) unknown@153@04)))
(push) ; 17
(assert (not (<
  $Perm.No
  (+
    (+
      (ite
        (and
          (and
            (and
              (<
                (inv@151@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@154@04))) unknown@153@04))
                V@28@04)
              (<=
                0
                (inv@151@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@154@04))) unknown@153@04))))
            (<
              (inv@150@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@154@04))) unknown@153@04))
              V@28@04))
          (<=
            0
            (inv@150@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@154@04))) unknown@153@04))))
        $k@149@04
        $Perm.No)
      (ite
        (and
          (and
            (and
              (<
                (inv@145@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@154@04))) unknown@153@04))
                V@28@04)
              (<=
                0
                (inv@145@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@154@04))) unknown@153@04))))
            (<
              (inv@144@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@154@04))) unknown@153@04))
              V@28@04))
          (<=
            0
            (inv@144@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@154@04))) unknown@153@04))))
        $Perm.Write
        $Perm.No))
    (-
      (ite
        (and
          (and
            (and
              (<
                (inv@52@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@154@04))) unknown@153@04))
                V@28@04)
              (<=
                0
                (inv@52@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@154@04))) unknown@153@04))))
            (<
              (inv@51@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@154@04))) unknown@153@04))
              V@28@04))
          (<=
            0
            (inv@51@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@154@04))) unknown@153@04))))
        $k@50@04
        $Perm.No)
      (pTaken@122@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@154@04))) unknown@153@04)))))))
(check-sat)
; unsat
(pop) ; 17
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               15232
;  :arith-add-rows          11938
;  :arith-assert-diseq      869
;  :arith-assert-lower      4791
;  :arith-assert-upper      2949
;  :arith-bound-prop        1206
;  :arith-conflicts         381
;  :arith-eq-adapter        3041
;  :arith-fixed-eqs         1343
;  :arith-grobner           60
;  :arith-max-min           506
;  :arith-nonlinear-bounds  33
;  :arith-nonlinear-horner  48
;  :arith-offset-eqs        1586
;  :arith-pivots            2490
;  :conflicts               1070
;  :datatype-accessor-ax    57
;  :datatype-constructor-ax 538
;  :datatype-occurs-check   194
;  :datatype-splits         105
;  :decisions               2451
;  :del-clause              18132
;  :final-checks            160
;  :interface-eqs           2
;  :max-generation          9
;  :max-memory              7.22
;  :memory                  7.19
;  :minimized-lits          103
;  :mk-bool-var             25786
;  :mk-clause               18334
;  :num-allocs              373668
;  :num-checks              262
;  :propagations            10331
;  :quant-instantiations    5610
;  :rlimit-count            928626
;  :time                    0.01)
; [eval] aloc(opt_get1(aloc(opt_get1(source), unknown1).option$array$), unknown)
; [eval] opt_get1(aloc(opt_get1(source), unknown1).option$array$)
; [eval] aloc(opt_get1(source), unknown1)
; [eval] opt_get1(source)
(push) ; 17
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 17
; Joined path conditions
(push) ; 17
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 18
(assert (not (< unknown1@154@04 (alen<Int> (opt_get1 $Snap.unit source@26@04)))))
(check-sat)
; unsat
(pop) ; 18
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               15232
;  :arith-add-rows          11938
;  :arith-assert-diseq      869
;  :arith-assert-lower      4791
;  :arith-assert-upper      2949
;  :arith-bound-prop        1206
;  :arith-conflicts         381
;  :arith-eq-adapter        3041
;  :arith-fixed-eqs         1343
;  :arith-grobner           60
;  :arith-max-min           506
;  :arith-nonlinear-bounds  33
;  :arith-nonlinear-horner  48
;  :arith-offset-eqs        1586
;  :arith-pivots            2490
;  :conflicts               1070
;  :datatype-accessor-ax    57
;  :datatype-constructor-ax 538
;  :datatype-occurs-check   194
;  :datatype-splits         105
;  :decisions               2451
;  :del-clause              18132
;  :final-checks            160
;  :interface-eqs           2
;  :max-generation          9
;  :max-memory              7.22
;  :memory                  7.19
;  :minimized-lits          103
;  :mk-bool-var             25786
;  :mk-clause               18334
;  :num-allocs              373695
;  :num-checks              263
;  :propagations            10331
;  :quant-instantiations    5610
;  :rlimit-count            928656)
(assert (< unknown1@154@04 (alen<Int> (opt_get1 $Snap.unit source@26@04))))
(pop) ; 17
; Joined path conditions
(assert (< unknown1@154@04 (alen<Int> (opt_get1 $Snap.unit source@26@04))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@154@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@154@04)))
(push) ; 17
(assert (not (<
  $Perm.No
  (+
    (+
      (+
        (ite
          (and
            (<
              (inv@136@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@154@04))
              V@28@04)
            (<=
              0
              (inv@136@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@154@04))))
          (*
            (scale $Snap.unit (* (to_real (* V@28@04 V@28@04)) $Perm.Write))
            $k@135@04)
          $Perm.No)
        (ite
          (and
            (<
              (inv@128@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@154@04))
              V@28@04)
            (<=
              0
              (inv@128@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@154@04))))
          (*
            (scale $Snap.unit (* (to_real (* V@28@04 V@28@04)) $Perm.Write))
            $k@127@04)
          $Perm.No))
      (-
        (-
          (ite
            (and
              (<
                (inv@42@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@154@04))
                V@28@04)
              (<=
                0
                (inv@42@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@154@04))))
            $k@41@04
            $Perm.No)
          (pTaken@95@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@154@04)))
        (pTaken@106@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@154@04))))
    (-
      (-
        (ite
          (and
            (<
              (inv@34@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@154@04))
              V@28@04)
            (<=
              0
              (inv@34@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@154@04))))
          $k@33@04
          $Perm.No)
        (pTaken@96@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@154@04)))
      (pTaken@105@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@154@04)))))))
(check-sat)
; unsat
(pop) ; 17
; 0.03s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               16815
;  :arith-add-rows          13047
;  :arith-assert-diseq      967
;  :arith-assert-lower      5317
;  :arith-assert-upper      3330
;  :arith-bound-prop        1283
;  :arith-conflicts         407
;  :arith-eq-adapter        3416
;  :arith-fixed-eqs         1552
;  :arith-grobner           60
;  :arith-max-min           506
;  :arith-nonlinear-bounds  33
;  :arith-nonlinear-horner  48
;  :arith-offset-eqs        1738
;  :arith-pivots            2670
;  :conflicts               1118
;  :datatype-accessor-ax    57
;  :datatype-constructor-ax 542
;  :datatype-occurs-check   194
;  :datatype-splits         105
;  :decisions               2808
;  :del-clause              20385
;  :final-checks            160
;  :interface-eqs           2
;  :max-generation          9
;  :max-memory              7.36
;  :memory                  7.34
;  :minimized-lits          108
;  :mk-bool-var             28642
;  :mk-clause               20665
;  :num-allocs              382341
;  :num-checks              264
;  :propagations            11703
;  :quant-instantiations    6192
;  :rlimit-count            981443
;  :time                    0.03)
(push) ; 17
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 18
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@154@04))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 18
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               17352
;  :arith-add-rows          13557
;  :arith-assert-diseq      987
;  :arith-assert-lower      5486
;  :arith-assert-upper      3423
;  :arith-bound-prop        1339
;  :arith-conflicts         421
;  :arith-eq-adapter        3527
;  :arith-fixed-eqs         1602
;  :arith-grobner           60
;  :arith-max-min           506
;  :arith-nonlinear-bounds  33
;  :arith-nonlinear-horner  48
;  :arith-offset-eqs        1786
;  :arith-pivots            2743
;  :conflicts               1140
;  :datatype-accessor-ax    58
;  :datatype-constructor-ax 547
;  :datatype-occurs-check   194
;  :datatype-splits         105
;  :decisions               2863
;  :del-clause              21094
;  :final-checks            160
;  :interface-eqs           2
;  :max-generation          9
;  :max-memory              7.36
;  :memory                  7.34
;  :minimized-lits          108
;  :mk-bool-var             29632
;  :mk-clause               21374
;  :num-allocs              386290
;  :num-checks              265
;  :propagations            12055
;  :quant-instantiations    6427
;  :rlimit-count            1004204
;  :time                    0.01)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@154@04))
    (as None<option<array>>  option<array>))))
(pop) ; 17
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@154@04))
    (as None<option<array>>  option<array>))))
(push) ; 17
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 18
(assert (not (<
  unknown@153@04
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@154@04)))))))
(check-sat)
; unsat
(pop) ; 18
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               17963
;  :arith-add-rows          14281
;  :arith-assert-diseq      1017
;  :arith-assert-lower      5663
;  :arith-assert-upper      3538
;  :arith-bound-prop        1389
;  :arith-conflicts         439
;  :arith-eq-adapter        3662
;  :arith-fixed-eqs         1663
;  :arith-grobner           60
;  :arith-max-min           506
;  :arith-nonlinear-bounds  33
;  :arith-nonlinear-horner  48
;  :arith-offset-eqs        1829
;  :arith-pivots            2828
;  :conflicts               1166
;  :datatype-accessor-ax    59
;  :datatype-constructor-ax 552
;  :datatype-occurs-check   194
;  :datatype-splits         105
;  :decisions               2944
;  :del-clause              21966
;  :final-checks            160
;  :interface-eqs           2
;  :max-generation          9
;  :max-memory              7.37
;  :memory                  7.35
;  :minimized-lits          108
;  :mk-bool-var             30790
;  :mk-clause               22246
;  :num-allocs              390361
;  :num-checks              266
;  :propagations            12457
;  :quant-instantiations    6687
;  :rlimit-count            1034908
;  :time                    0.01)
(assert (<
  unknown@153@04
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@154@04))))))
(pop) ; 17
; Joined path conditions
(assert (<
  unknown@153@04
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@154@04))))))
(assert ($FVF.loc_int ($FVF.lookup_int (as sm@152@04  $FVF<Int>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@154@04))) unknown@153@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@154@04))) unknown@153@04)))
(push) ; 17
(assert (not (<
  $Perm.No
  (+
    (+
      (ite
        (and
          (and
            (and
              (<
                (inv@151@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@154@04))) unknown@153@04))
                V@28@04)
              (<=
                0
                (inv@151@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@154@04))) unknown@153@04))))
            (<
              (inv@150@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@154@04))) unknown@153@04))
              V@28@04))
          (<=
            0
            (inv@150@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@154@04))) unknown@153@04))))
        $k@149@04
        $Perm.No)
      (ite
        (and
          (and
            (and
              (<
                (inv@145@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@154@04))) unknown@153@04))
                V@28@04)
              (<=
                0
                (inv@145@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@154@04))) unknown@153@04))))
            (<
              (inv@144@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@154@04))) unknown@153@04))
              V@28@04))
          (<=
            0
            (inv@144@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@154@04))) unknown@153@04))))
        $Perm.Write
        $Perm.No))
    (-
      (ite
        (and
          (and
            (and
              (<
                (inv@52@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@154@04))) unknown@153@04))
                V@28@04)
              (<=
                0
                (inv@52@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@154@04))) unknown@153@04))))
            (<
              (inv@51@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@154@04))) unknown@153@04))
              V@28@04))
          (<=
            0
            (inv@51@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@154@04))) unknown@153@04))))
        $k@50@04
        $Perm.No)
      (pTaken@122@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@154@04))) unknown@153@04)))))))
(check-sat)
; unsat
(pop) ; 17
; 0.02s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               19427
;  :arith-add-rows          15291
;  :arith-assert-diseq      1097
;  :arith-assert-lower      6100
;  :arith-assert-upper      3830
;  :arith-bound-prop        1479
;  :arith-conflicts         460
;  :arith-eq-adapter        3966
;  :arith-fixed-eqs         1832
;  :arith-grobner           60
;  :arith-max-min           506
;  :arith-nonlinear-bounds  33
;  :arith-nonlinear-horner  48
;  :arith-offset-eqs        1957
;  :arith-pivots            2977
;  :conflicts               1205
;  :datatype-accessor-ax    60
;  :datatype-constructor-ax 557
;  :datatype-occurs-check   194
;  :datatype-splits         105
;  :decisions               3091
;  :del-clause              23453
;  :final-checks            160
;  :interface-eqs           2
;  :max-generation          9
;  :max-memory              7.64
;  :memory                  7.61
;  :minimized-lits          114
;  :mk-bool-var             32841
;  :mk-clause               23769
;  :num-allocs              398242
;  :num-checks              267
;  :propagations            13437
;  :quant-instantiations    7141
;  :rlimit-count            1077198
;  :time                    0.02)
(pop) ; 16
(push) ; 16
; [else-branch: 177 | !(unknown1@154@04 < V@28@04 && 0 <= unknown1@154@04)]
(assert (not (and (< unknown1@154@04 V@28@04) (<= 0 unknown1@154@04))))
(pop) ; 16
(pop) ; 15
; Joined path conditions
(assert (implies
  (and (< unknown1@154@04 V@28@04) (<= 0 unknown1@154@04))
  (and
    (< unknown1@154@04 V@28@04)
    (<= 0 unknown1@154@04)
    (< unknown1@154@04 (alen<Int> (opt_get1 $Snap.unit target@27@04)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@154@04)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@154@04))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@154@04))
        (as None<option<array>>  option<array>)))
    (<
      unknown@153@04
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@154@04)))))
    ($FVF.loc_int ($FVF.lookup_int (as sm@152@04  $FVF<Int>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@154@04))) unknown@153@04)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@154@04))) unknown@153@04))
    (< unknown1@154@04 (alen<Int> (opt_get1 $Snap.unit source@26@04)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@154@04)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@154@04))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@154@04))
        (as None<option<array>>  option<array>)))
    (<
      unknown@153@04
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@154@04)))))
    ($FVF.loc_int ($FVF.lookup_int (as sm@152@04  $FVF<Int>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@154@04))) unknown@153@04)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@154@04))) unknown@153@04)))))
; Joined path conditions
(pop) ; 14
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((unknown1@154@04 Int)) (!
  (implies
    (and (< unknown1@154@04 V@28@04) (<= 0 unknown1@154@04))
    (and
      (< unknown1@154@04 V@28@04)
      (<= 0 unknown1@154@04)
      (< unknown1@154@04 (alen<Int> (opt_get1 $Snap.unit target@27@04)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@154@04)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@154@04))
      (not
        (=
          ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@154@04))
          (as None<option<array>>  option<array>)))
      (<
        unknown@153@04
        (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@154@04)))))
      ($FVF.loc_int ($FVF.lookup_int (as sm@152@04  $FVF<Int>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@154@04))) unknown@153@04)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@154@04))) unknown@153@04))
      (< unknown1@154@04 (alen<Int> (opt_get1 $Snap.unit source@26@04)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@154@04)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@154@04))
      (not
        (=
          ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@154@04))
          (as None<option<array>>  option<array>)))
      (<
        unknown@153@04
        (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@154@04)))))
      ($FVF.loc_int ($FVF.lookup_int (as sm@152@04  $FVF<Int>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@154@04))) unknown@153@04)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@154@04))) unknown@153@04))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@154@04))) unknown@153@04))
  :qid |prog.l<no position>-aux|)))
(assert (forall ((unknown1@154@04 Int)) (!
  (implies
    (and (< unknown1@154@04 V@28@04) (<= 0 unknown1@154@04))
    (and
      (< unknown1@154@04 V@28@04)
      (<= 0 unknown1@154@04)
      (< unknown1@154@04 (alen<Int> (opt_get1 $Snap.unit target@27@04)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@154@04)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@154@04))
      (not
        (=
          ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@154@04))
          (as None<option<array>>  option<array>)))
      (<
        unknown@153@04
        (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@154@04)))))
      ($FVF.loc_int ($FVF.lookup_int (as sm@152@04  $FVF<Int>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@154@04))) unknown@153@04)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@154@04))) unknown@153@04))
      (< unknown1@154@04 (alen<Int> (opt_get1 $Snap.unit source@26@04)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@154@04)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@154@04))
      (not
        (=
          ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@154@04))
          (as None<option<array>>  option<array>)))
      (<
        unknown@153@04
        (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@154@04)))))
      ($FVF.loc_int ($FVF.lookup_int (as sm@152@04  $FVF<Int>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@154@04))) unknown@153@04)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@154@04))) unknown@153@04))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@154@04))) unknown@153@04))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 13
(push) ; 13
; [else-branch: 175 | !(unknown@153@04 < V@28@04 && 0 <= unknown@153@04)]
(assert (not (and (< unknown@153@04 V@28@04) (<= 0 unknown@153@04))))
(pop) ; 13
(pop) ; 12
; Joined path conditions
(assert (implies
  (and (< unknown@153@04 V@28@04) (<= 0 unknown@153@04))
  (and
    (< unknown@153@04 V@28@04)
    (<= 0 unknown@153@04)
    (forall ((unknown1@154@04 Int)) (!
      (implies
        (and (< unknown1@154@04 V@28@04) (<= 0 unknown1@154@04))
        (and
          (< unknown1@154@04 V@28@04)
          (<= 0 unknown1@154@04)
          (< unknown1@154@04 (alen<Int> (opt_get1 $Snap.unit target@27@04)))
          ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@154@04)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@154@04))
          (not
            (=
              ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@154@04))
              (as None<option<array>>  option<array>)))
          (<
            unknown@153@04
            (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@154@04)))))
          ($FVF.loc_int ($FVF.lookup_int (as sm@152@04  $FVF<Int>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@154@04))) unknown@153@04)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@154@04))) unknown@153@04))
          (< unknown1@154@04 (alen<Int> (opt_get1 $Snap.unit source@26@04)))
          ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@154@04)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@154@04))
          (not
            (=
              ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@154@04))
              (as None<option<array>>  option<array>)))
          (<
            unknown@153@04
            (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@154@04)))))
          ($FVF.loc_int ($FVF.lookup_int (as sm@152@04  $FVF<Int>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@154@04))) unknown@153@04)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@154@04))) unknown@153@04))))
      :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@154@04))) unknown@153@04))
      :qid |prog.l<no position>-aux|))
    (forall ((unknown1@154@04 Int)) (!
      (implies
        (and (< unknown1@154@04 V@28@04) (<= 0 unknown1@154@04))
        (and
          (< unknown1@154@04 V@28@04)
          (<= 0 unknown1@154@04)
          (< unknown1@154@04 (alen<Int> (opt_get1 $Snap.unit target@27@04)))
          ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@154@04)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@154@04))
          (not
            (=
              ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@154@04))
              (as None<option<array>>  option<array>)))
          (<
            unknown@153@04
            (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@154@04)))))
          ($FVF.loc_int ($FVF.lookup_int (as sm@152@04  $FVF<Int>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@154@04))) unknown@153@04)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@154@04))) unknown@153@04))
          (< unknown1@154@04 (alen<Int> (opt_get1 $Snap.unit source@26@04)))
          ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@154@04)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@154@04))
          (not
            (=
              ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@154@04))
              (as None<option<array>>  option<array>)))
          (<
            unknown@153@04
            (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@154@04)))))
          ($FVF.loc_int ($FVF.lookup_int (as sm@152@04  $FVF<Int>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@154@04))) unknown@153@04)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@154@04))) unknown@153@04))))
      :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@154@04))) unknown@153@04))
      :qid |prog.l<no position>-aux|)))))
; Joined path conditions
(pop) ; 11
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 10
(pop) ; 9
; Joined path conditions
(assert (implies
  (= exc@123@04 $Ref.null)
  (forall ((unknown@153@04 Int)) (!
    (implies
      (and (< unknown@153@04 V@28@04) (<= 0 unknown@153@04))
      (forall ((unknown1@154@04 Int)) (!
        (implies
          (and (< unknown1@154@04 V@28@04) (<= 0 unknown1@154@04))
          (=
            ($FVF.lookup_int (as sm@152@04  $FVF<Int>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@154@04))) unknown@153@04))
            ($FVF.lookup_int (as sm@152@04  $FVF<Int>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@154@04))) unknown@153@04))))
        :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@154@04))) unknown@153@04))
        :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@154@04))) unknown@153@04))
        :qid |prog.l<no position>|)))
    
    :qid |prog.l<no position>|))))
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
; [eval] exc != null
; [then-branch: 178 | exc@123@04 != Null | dead]
; [else-branch: 178 | exc@123@04 == Null | live]
(push) ; 9
; [else-branch: 178 | exc@123@04 == Null]
(pop) ; 9
; [eval] !(exc != null)
; [eval] exc != null
(set-option :timeout 10)
(push) ; 9
(assert (not (not (= exc@123@04 $Ref.null))))
(check-sat)
; unknown
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               19505
;  :arith-add-rows          15327
;  :arith-assert-diseq      1097
;  :arith-assert-lower      6123
;  :arith-assert-upper      3845
;  :arith-bound-prop        1479
;  :arith-conflicts         461
;  :arith-eq-adapter        3966
;  :arith-fixed-eqs         1832
;  :arith-grobner           65
;  :arith-max-min           544
;  :arith-nonlinear-bounds  35
;  :arith-nonlinear-horner  52
;  :arith-offset-eqs        1959
;  :arith-pivots            3013
;  :conflicts               1206
;  :datatype-accessor-ax    60
;  :datatype-constructor-ax 573
;  :datatype-occurs-check   207
;  :datatype-splits         113
;  :decisions               3108
;  :del-clause              23760
;  :final-checks            167
;  :interface-eqs           2
;  :max-generation          9
;  :max-memory              7.64
;  :memory                  7.62
;  :minimized-lits          114
;  :mk-bool-var             32850
;  :mk-clause               23769
;  :num-allocs              400660
;  :num-checks              269
;  :propagations            13443
;  :quant-instantiations    7141
;  :rlimit-count            1081345)
; [then-branch: 179 | exc@123@04 == Null | live]
; [else-branch: 179 | exc@123@04 != Null | dead]
(push) ; 9
; [then-branch: 179 | exc@123@04 == Null]
; [exec]
; evaluationDummy := res1
; [exec]
; label end
; [exec]
; res := return
; [exec]
; label bubble
; [eval] exc == null
; [eval] exc == null ==> source != (None(): option[array])
; [eval] exc == null
(push) ; 10
(push) ; 11
(assert (not (not (= exc@123@04 $Ref.null))))
(check-sat)
; unknown
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               19542
;  :arith-add-rows          15327
;  :arith-assert-diseq      1097
;  :arith-assert-lower      6123
;  :arith-assert-upper      3845
;  :arith-bound-prop        1479
;  :arith-conflicts         461
;  :arith-eq-adapter        3966
;  :arith-fixed-eqs         1832
;  :arith-grobner           65
;  :arith-max-min           544
;  :arith-nonlinear-bounds  35
;  :arith-nonlinear-horner  52
;  :arith-offset-eqs        1959
;  :arith-pivots            3013
;  :conflicts               1206
;  :datatype-accessor-ax    60
;  :datatype-constructor-ax 581
;  :datatype-occurs-check   212
;  :datatype-splits         117
;  :decisions               3116
;  :del-clause              23760
;  :final-checks            169
;  :interface-eqs           2
;  :max-generation          9
;  :max-memory              7.64
;  :memory                  7.62
;  :minimized-lits          114
;  :mk-bool-var             32854
;  :mk-clause               23769
;  :num-allocs              401304
;  :num-checks              270
;  :propagations            13443
;  :quant-instantiations    7141
;  :rlimit-count            1082138)
; [then-branch: 180 | exc@123@04 == Null | live]
; [else-branch: 180 | exc@123@04 != Null | dead]
(push) ; 11
; [then-branch: 180 | exc@123@04 == Null]
; [eval] source != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 11
(pop) ; 10
; Joined path conditions
(set-option :timeout 0)
(push) ; 10
(assert (not (implies
  (= exc@123@04 $Ref.null)
  (not (= source@26@04 (as None<option<array>>  option<array>))))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               19542
;  :arith-add-rows          15327
;  :arith-assert-diseq      1097
;  :arith-assert-lower      6123
;  :arith-assert-upper      3845
;  :arith-bound-prop        1479
;  :arith-conflicts         461
;  :arith-eq-adapter        3966
;  :arith-fixed-eqs         1832
;  :arith-grobner           65
;  :arith-max-min           544
;  :arith-nonlinear-bounds  35
;  :arith-nonlinear-horner  52
;  :arith-offset-eqs        1959
;  :arith-pivots            3013
;  :conflicts               1206
;  :datatype-accessor-ax    60
;  :datatype-constructor-ax 581
;  :datatype-occurs-check   212
;  :datatype-splits         117
;  :decisions               3116
;  :del-clause              23760
;  :final-checks            169
;  :interface-eqs           2
;  :max-generation          9
;  :max-memory              7.64
;  :memory                  7.62
;  :minimized-lits          114
;  :mk-bool-var             32854
;  :mk-clause               23769
;  :num-allocs              401329
;  :num-checks              271
;  :propagations            13443
;  :quant-instantiations    7141
;  :rlimit-count            1082158)
(assert (implies
  (= exc@123@04 $Ref.null)
  (not (= source@26@04 (as None<option<array>>  option<array>)))))
; [eval] exc == null ==> alen(opt_get1(source)) == V
; [eval] exc == null
(push) ; 10
(set-option :timeout 10)
(push) ; 11
(assert (not (not (= exc@123@04 $Ref.null))))
(check-sat)
; unknown
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               19579
;  :arith-add-rows          15327
;  :arith-assert-diseq      1097
;  :arith-assert-lower      6123
;  :arith-assert-upper      3845
;  :arith-bound-prop        1479
;  :arith-conflicts         461
;  :arith-eq-adapter        3966
;  :arith-fixed-eqs         1832
;  :arith-grobner           65
;  :arith-max-min           544
;  :arith-nonlinear-bounds  35
;  :arith-nonlinear-horner  52
;  :arith-offset-eqs        1959
;  :arith-pivots            3013
;  :conflicts               1206
;  :datatype-accessor-ax    60
;  :datatype-constructor-ax 589
;  :datatype-occurs-check   217
;  :datatype-splits         121
;  :decisions               3124
;  :del-clause              23760
;  :final-checks            171
;  :interface-eqs           2
;  :max-generation          9
;  :max-memory              7.64
;  :memory                  7.62
;  :minimized-lits          114
;  :mk-bool-var             32858
;  :mk-clause               23769
;  :num-allocs              401975
;  :num-checks              272
;  :propagations            13443
;  :quant-instantiations    7141
;  :rlimit-count            1082951)
; [then-branch: 181 | exc@123@04 == Null | live]
; [else-branch: 181 | exc@123@04 != Null | dead]
(push) ; 11
; [then-branch: 181 | exc@123@04 == Null]
; [eval] alen(opt_get1(source)) == V
; [eval] alen(opt_get1(source))
; [eval] opt_get1(source)
(push) ; 12
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 12
; Joined path conditions
(pop) ; 11
(pop) ; 10
; Joined path conditions
(set-option :timeout 0)
(push) ; 10
(assert (not (implies
  (= exc@123@04 $Ref.null)
  (= (alen<Int> (opt_get1 $Snap.unit source@26@04)) V@28@04))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               19579
;  :arith-add-rows          15327
;  :arith-assert-diseq      1097
;  :arith-assert-lower      6123
;  :arith-assert-upper      3845
;  :arith-bound-prop        1479
;  :arith-conflicts         461
;  :arith-eq-adapter        3966
;  :arith-fixed-eqs         1832
;  :arith-grobner           65
;  :arith-max-min           544
;  :arith-nonlinear-bounds  35
;  :arith-nonlinear-horner  52
;  :arith-offset-eqs        1959
;  :arith-pivots            3013
;  :conflicts               1206
;  :datatype-accessor-ax    60
;  :datatype-constructor-ax 589
;  :datatype-occurs-check   217
;  :datatype-splits         121
;  :decisions               3124
;  :del-clause              23760
;  :final-checks            171
;  :interface-eqs           2
;  :max-generation          9
;  :max-memory              7.64
;  :memory                  7.62
;  :minimized-lits          114
;  :mk-bool-var             32858
;  :mk-clause               23769
;  :num-allocs              401994
;  :num-checks              273
;  :propagations            13443
;  :quant-instantiations    7141
;  :rlimit-count            1082976)
(assert (implies
  (= exc@123@04 $Ref.null)
  (= (alen<Int> (opt_get1 $Snap.unit source@26@04)) V@28@04)))
; [eval] exc == null
(set-option :timeout 10)
(push) ; 10
(assert (not (not (= exc@123@04 $Ref.null))))
(check-sat)
; unknown
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               19616
;  :arith-add-rows          15327
;  :arith-assert-diseq      1097
;  :arith-assert-lower      6123
;  :arith-assert-upper      3845
;  :arith-bound-prop        1479
;  :arith-conflicts         461
;  :arith-eq-adapter        3966
;  :arith-fixed-eqs         1832
;  :arith-grobner           65
;  :arith-max-min           544
;  :arith-nonlinear-bounds  35
;  :arith-nonlinear-horner  52
;  :arith-offset-eqs        1959
;  :arith-pivots            3013
;  :conflicts               1206
;  :datatype-accessor-ax    60
;  :datatype-constructor-ax 597
;  :datatype-occurs-check   222
;  :datatype-splits         125
;  :decisions               3132
;  :del-clause              23760
;  :final-checks            173
;  :interface-eqs           2
;  :max-generation          9
;  :max-memory              7.64
;  :memory                  7.62
;  :minimized-lits          114
;  :mk-bool-var             32862
;  :mk-clause               23769
;  :num-allocs              402640
;  :num-checks              274
;  :propagations            13443
;  :quant-instantiations    7141
;  :rlimit-count            1083764)
; [then-branch: 182 | exc@123@04 == Null | live]
; [else-branch: 182 | exc@123@04 != Null | dead]
(push) ; 10
; [then-branch: 182 | exc@123@04 == Null]
(declare-const i1@155@04 Int)
(push) ; 11
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 12
; [then-branch: 183 | 0 <= i1@155@04 | live]
; [else-branch: 183 | !(0 <= i1@155@04) | live]
(push) ; 13
; [then-branch: 183 | 0 <= i1@155@04]
(assert (<= 0 i1@155@04))
; [eval] i1 < V
(pop) ; 13
(push) ; 13
; [else-branch: 183 | !(0 <= i1@155@04)]
(assert (not (<= 0 i1@155@04)))
(pop) ; 13
(pop) ; 12
; Joined path conditions
; Joined path conditions
(assert (and (< i1@155@04 V@28@04) (<= 0 i1@155@04)))
(declare-const $k@156@04 $Perm)
(assert ($Perm.isReadVar $k@156@04 $Perm.Write))
; [eval] aloc(opt_get1(source), i1)
; [eval] opt_get1(source)
(push) ; 12
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 12
; Joined path conditions
(push) ; 12
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 13
(assert (not (< i1@155@04 (alen<Int> (opt_get1 $Snap.unit source@26@04)))))
(check-sat)
; unsat
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               19616
;  :arith-add-rows          15327
;  :arith-assert-diseq      1098
;  :arith-assert-lower      6127
;  :arith-assert-upper      3846
;  :arith-bound-prop        1479
;  :arith-conflicts         461
;  :arith-eq-adapter        3967
;  :arith-fixed-eqs         1832
;  :arith-grobner           65
;  :arith-max-min           544
;  :arith-nonlinear-bounds  35
;  :arith-nonlinear-horner  52
;  :arith-offset-eqs        1959
;  :arith-pivots            3013
;  :conflicts               1206
;  :datatype-accessor-ax    60
;  :datatype-constructor-ax 597
;  :datatype-occurs-check   222
;  :datatype-splits         125
;  :decisions               3132
;  :del-clause              23760
;  :final-checks            173
;  :interface-eqs           2
;  :max-generation          9
;  :max-memory              7.64
;  :memory                  7.62
;  :minimized-lits          114
;  :mk-bool-var             32868
;  :mk-clause               23771
;  :num-allocs              402805
;  :num-checks              275
;  :propagations            13444
;  :quant-instantiations    7141
;  :rlimit-count            1084090)
(assert (< i1@155@04 (alen<Int> (opt_get1 $Snap.unit source@26@04))))
(pop) ; 12
; Joined path conditions
(assert (< i1@155@04 (alen<Int> (opt_get1 $Snap.unit source@26@04))))
(pop) ; 11
(declare-fun inv@157@04 ($Ref) Int)
; Nested auxiliary terms: globals
(assert ($Perm.isReadVar $k@156@04 $Perm.Write))
; Nested auxiliary terms: non-globals
(assert (forall ((i1@155@04 Int)) (!
  (< i1@155@04 (alen<Int> (opt_get1 $Snap.unit source@26@04)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@155@04))
  :qid |option$array$-aux|)))
(push) ; 11
(assert (not (forall ((i1@155@04 Int)) (!
  (implies
    (and (< i1@155@04 V@28@04) (<= 0 i1@155@04))
    (or (= $k@156@04 $Perm.No) (< $Perm.No $k@156@04)))
  
  ))))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               19616
;  :arith-add-rows          15327
;  :arith-assert-diseq      1099
;  :arith-assert-lower      6129
;  :arith-assert-upper      3847
;  :arith-bound-prop        1479
;  :arith-conflicts         461
;  :arith-eq-adapter        3968
;  :arith-fixed-eqs         1832
;  :arith-grobner           65
;  :arith-max-min           544
;  :arith-nonlinear-bounds  35
;  :arith-nonlinear-horner  52
;  :arith-offset-eqs        1959
;  :arith-pivots            3013
;  :conflicts               1207
;  :datatype-accessor-ax    60
;  :datatype-constructor-ax 597
;  :datatype-occurs-check   222
;  :datatype-splits         125
;  :decisions               3132
;  :del-clause              23762
;  :final-checks            173
;  :interface-eqs           2
;  :max-generation          9
;  :max-memory              7.64
;  :memory                  7.62
;  :minimized-lits          114
;  :mk-bool-var             32875
;  :mk-clause               23773
;  :num-allocs              403233
;  :num-checks              276
;  :propagations            13445
;  :quant-instantiations    7141
;  :rlimit-count            1084635)
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 11
(assert (not (forall ((i11@155@04 Int) (i12@155@04 Int)) (!
  (implies
    (and
      (and
        (and
          (and (< i11@155@04 V@28@04) (<= 0 i11@155@04))
          ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@26@04) i11@155@04)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@26@04) i11@155@04)))
        (< $Perm.No $k@156@04))
      (and
        (and
          (and (< i12@155@04 V@28@04) (<= 0 i12@155@04))
          ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@26@04) i12@155@04)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@26@04) i12@155@04)))
        (< $Perm.No $k@156@04))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i11@155@04)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i12@155@04)))
    (= i11@155@04 i12@155@04))
  
  :qid |option$array$-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               19627
;  :arith-add-rows          15331
;  :arith-assert-diseq      1100
;  :arith-assert-lower      6133
;  :arith-assert-upper      3847
;  :arith-bound-prop        1479
;  :arith-conflicts         461
;  :arith-eq-adapter        3969
;  :arith-fixed-eqs         1832
;  :arith-grobner           65
;  :arith-max-min           544
;  :arith-nonlinear-bounds  35
;  :arith-nonlinear-horner  52
;  :arith-offset-eqs        1959
;  :arith-pivots            3015
;  :conflicts               1208
;  :datatype-accessor-ax    60
;  :datatype-constructor-ax 597
;  :datatype-occurs-check   222
;  :datatype-splits         125
;  :decisions               3132
;  :del-clause              23814
;  :final-checks            173
;  :interface-eqs           2
;  :max-generation          9
;  :max-memory              7.64
;  :memory                  7.61
;  :minimized-lits          114
;  :mk-bool-var             32955
;  :mk-clause               23825
;  :num-allocs              403863
;  :num-checks              277
;  :propagations            13449
;  :quant-instantiations    7166
;  :rlimit-count            1086121)
; Definitional axioms for inverse functions
(assert (forall ((i1@155@04 Int)) (!
  (implies
    (and (and (< i1@155@04 V@28@04) (<= 0 i1@155@04)) (< $Perm.No $k@156@04))
    (=
      (inv@157@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@155@04))
      i1@155@04))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@155@04))
  :qid |option$array$-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and (< (inv@157@04 r) V@28@04) (<= 0 (inv@157@04 r)))
      (< $Perm.No $k@156@04))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) (inv@157@04 r))
      r))
  :pattern ((inv@157@04 r))
  :qid |option$array$-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@157@04 r) V@28@04) (<= 0 (inv@157@04 r)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) r) r))
  :pattern ((inv@157@04 r))
  )))
; Precomputing data for removing quantified permissions
(define-fun pTaken@158@04 ((r $Ref)) $Perm
  (ite
    (and (< (inv@157@04 r) V@28@04) (<= 0 (inv@157@04 r)))
    ($Perm.min
      (ite
        (and (< (inv@136@04 r) V@28@04) (<= 0 (inv@136@04 r)))
        (*
          (scale $Snap.unit (* (to_real (* V@28@04 V@28@04)) $Perm.Write))
          $k@135@04)
        $Perm.No)
      $k@156@04)
    $Perm.No))
(define-fun pTaken@159@04 ((r $Ref)) $Perm
  (ite
    (and (< (inv@157@04 r) V@28@04) (<= 0 (inv@157@04 r)))
    ($Perm.min
      (ite
        (and (< (inv@128@04 r) V@28@04) (<= 0 (inv@128@04 r)))
        (*
          (scale $Snap.unit (* (to_real (* V@28@04 V@28@04)) $Perm.Write))
          $k@127@04)
        $Perm.No)
      (- $k@156@04 (pTaken@158@04 r)))
    $Perm.No))
(define-fun pTaken@160@04 ((r $Ref)) $Perm
  (ite
    (and (< (inv@157@04 r) V@28@04) (<= 0 (inv@157@04 r)))
    ($Perm.min
      (-
        (-
          (ite
            (and (< (inv@42@04 r) V@28@04) (<= 0 (inv@42@04 r)))
            $k@41@04
            $Perm.No)
          (pTaken@95@04 r))
        (pTaken@106@04 r))
      (- (- $k@156@04 (pTaken@158@04 r)) (pTaken@159@04 r)))
    $Perm.No))
(define-fun pTaken@161@04 ((r $Ref)) $Perm
  (ite
    (and (< (inv@157@04 r) V@28@04) (<= 0 (inv@157@04 r)))
    ($Perm.min
      (-
        (-
          (ite
            (and (< (inv@34@04 r) V@28@04) (<= 0 (inv@34@04 r)))
            $k@33@04
            $Perm.No)
          (pTaken@96@04 r))
        (pTaken@105@04 r))
      (- (- (- $k@156@04 (pTaken@158@04 r)) (pTaken@159@04 r)) (pTaken@160@04 r)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Constrain original permissions $k@156@04
(assert (forall ((r $Ref)) (!
  (implies
    (not
      (=
        (ite
          (and (< (inv@136@04 r) V@28@04) (<= 0 (inv@136@04 r)))
          (*
            (scale $Snap.unit (* (to_real (* V@28@04 V@28@04)) $Perm.Write))
            $k@135@04)
          $Perm.No)
        $Perm.No))
    (ite
      (and (< (inv@136@04 r) V@28@04) (<= 0 (inv@136@04 r)))
      (<
        (ite
          (and (< (inv@157@04 r) V@28@04) (<= 0 (inv@157@04 r)))
          $k@156@04
          $Perm.No)
        (*
          (scale $Snap.unit (* (to_real (* V@28@04 V@28@04)) $Perm.Write))
          $k@135@04))
      (<
        (ite
          (and (< (inv@157@04 r) V@28@04) (<= 0 (inv@157@04 r)))
          $k@156@04
          $Perm.No)
        $Perm.No)))
  :pattern ((inv@136@04 r))
  :pattern ((inv@157@04 r))
  :qid |qp.srp48|)))
; Intermediate check if already taken enough permissions
(set-option :timeout 500)
(push) ; 11
(assert (not (forall ((r $Ref)) (!
  (implies
    (and (< (inv@157@04 r) V@28@04) (<= 0 (inv@157@04 r)))
    (= (- $k@156@04 (pTaken@158@04 r)) $Perm.No))
  
  ))))
(check-sat)
; unknown
(pop) ; 11
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               20580
;  :arith-add-rows          15739
;  :arith-assert-diseq      1149
;  :arith-assert-lower      6438
;  :arith-assert-upper      4020
;  :arith-bound-prop        1519
;  :arith-conflicts         472
;  :arith-eq-adapter        4091
;  :arith-fixed-eqs         1909
;  :arith-grobner           83
;  :arith-max-min           692
;  :arith-nonlinear-bounds  55
;  :arith-nonlinear-horner  68
;  :arith-offset-eqs        2034
;  :arith-pivots            3115
;  :conflicts               1226
;  :datatype-accessor-ax    76
;  :datatype-constructor-ax 658
;  :datatype-occurs-check   267
;  :datatype-splits         180
;  :decisions               3362
;  :del-clause              24743
;  :final-checks            201
;  :interface-eqs           9
;  :max-generation          9
;  :max-memory              7.75
;  :memory                  7.70
;  :minimized-lits          117
;  :mk-bool-var             34140
;  :mk-clause               24752
;  :num-allocs              413109
;  :num-checks              279
;  :propagations            14035
;  :quant-instantiations    7482
;  :rlimit-count            1126098
;  :time                    0.01)
; Constrain original permissions $k@156@04
(assert (forall ((r $Ref)) (!
  (implies
    (not
      (=
        (ite
          (and (< (inv@128@04 r) V@28@04) (<= 0 (inv@128@04 r)))
          (*
            (scale $Snap.unit (* (to_real (* V@28@04 V@28@04)) $Perm.Write))
            $k@127@04)
          $Perm.No)
        $Perm.No))
    (ite
      (and (< (inv@128@04 r) V@28@04) (<= 0 (inv@128@04 r)))
      (<
        (ite
          (and (< (inv@157@04 r) V@28@04) (<= 0 (inv@157@04 r)))
          $k@156@04
          $Perm.No)
        (*
          (scale $Snap.unit (* (to_real (* V@28@04 V@28@04)) $Perm.Write))
          $k@127@04))
      (<
        (ite
          (and (< (inv@157@04 r) V@28@04) (<= 0 (inv@157@04 r)))
          $k@156@04
          $Perm.No)
        $Perm.No)))
  :pattern ((inv@128@04 r))
  :pattern ((inv@157@04 r))
  :qid |qp.srp49|)))
; Intermediate check if already taken enough permissions
(push) ; 11
(assert (not (forall ((r $Ref)) (!
  (implies
    (and (< (inv@157@04 r) V@28@04) (<= 0 (inv@157@04 r)))
    (= (- (- $k@156@04 (pTaken@158@04 r)) (pTaken@159@04 r)) $Perm.No))
  
  ))))
(check-sat)
; unsat
(pop) ; 11
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               21160
;  :arith-add-rows          16232
;  :arith-assert-diseq      1202
;  :arith-assert-lower      6588
;  :arith-assert-upper      4134
;  :arith-bound-prop        1561
;  :arith-conflicts         488
;  :arith-eq-adapter        4221
;  :arith-fixed-eqs         1953
;  :arith-grobner           83
;  :arith-max-min           707
;  :arith-nonlinear-bounds  59
;  :arith-nonlinear-horner  68
;  :arith-offset-eqs        2075
;  :arith-pivots            3220
;  :conflicts               1259
;  :datatype-accessor-ax    80
;  :datatype-constructor-ax 676
;  :datatype-occurs-check   279
;  :datatype-splits         198
;  :decisions               3507
;  :del-clause              25537
;  :final-checks            213
;  :interface-eqs           15
;  :max-generation          9
;  :max-memory              7.75
;  :memory                  7.68
;  :minimized-lits          126
;  :mk-bool-var             35378
;  :mk-clause               25546
;  :num-allocs              418203
;  :num-checks              280
;  :propagations            14417
;  :quant-instantiations    7737
;  :rlimit-count            1150647
;  :time                    0.01)
; Final check if taken enough permissions
; Done removing quantified permissions
; Definitional axioms for snapshot map values
; [eval] exc == null ==> (forall i1: Int :: { aloc(opt_get1(source), i1) } 0 <= i1 && i1 < V ==> aloc(opt_get1(source), i1).option$array$ != (None(): option[array]))
; [eval] exc == null
(push) ; 11
(set-option :timeout 10)
(push) ; 12
(assert (not (not (= exc@123@04 $Ref.null))))
(check-sat)
; unknown
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               21197
;  :arith-add-rows          16232
;  :arith-assert-diseq      1202
;  :arith-assert-lower      6603
;  :arith-assert-upper      4142
;  :arith-bound-prop        1561
;  :arith-conflicts         488
;  :arith-eq-adapter        4221
;  :arith-fixed-eqs         1953
;  :arith-grobner           88
;  :arith-max-min           733
;  :arith-nonlinear-bounds  62
;  :arith-nonlinear-horner  72
;  :arith-offset-eqs        2075
;  :arith-pivots            3220
;  :conflicts               1259
;  :datatype-accessor-ax    80
;  :datatype-constructor-ax 684
;  :datatype-occurs-check   284
;  :datatype-splits         202
;  :decisions               3515
;  :del-clause              25537
;  :final-checks            217
;  :interface-eqs           15
;  :max-generation          9
;  :max-memory              7.75
;  :memory                  7.69
;  :minimized-lits          126
;  :mk-bool-var             35382
;  :mk-clause               25546
;  :num-allocs              419056
;  :num-checks              281
;  :propagations            14417
;  :quant-instantiations    7737
;  :rlimit-count            1152005
;  :time                    0.00)
; [then-branch: 184 | exc@123@04 == Null | live]
; [else-branch: 184 | exc@123@04 != Null | dead]
(push) ; 12
; [then-branch: 184 | exc@123@04 == Null]
; [eval] (forall i1: Int :: { aloc(opt_get1(source), i1) } 0 <= i1 && i1 < V ==> aloc(opt_get1(source), i1).option$array$ != (None(): option[array]))
(declare-const i1@162@04 Int)
(push) ; 13
; [eval] 0 <= i1 && i1 < V ==> aloc(opt_get1(source), i1).option$array$ != (None(): option[array])
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 14
; [then-branch: 185 | 0 <= i1@162@04 | live]
; [else-branch: 185 | !(0 <= i1@162@04) | live]
(push) ; 15
; [then-branch: 185 | 0 <= i1@162@04]
(assert (<= 0 i1@162@04))
; [eval] i1 < V
(pop) ; 15
(push) ; 15
; [else-branch: 185 | !(0 <= i1@162@04)]
(assert (not (<= 0 i1@162@04)))
(pop) ; 15
(pop) ; 14
; Joined path conditions
; Joined path conditions
(push) ; 14
; [then-branch: 186 | i1@162@04 < V@28@04 && 0 <= i1@162@04 | live]
; [else-branch: 186 | !(i1@162@04 < V@28@04 && 0 <= i1@162@04) | live]
(push) ; 15
; [then-branch: 186 | i1@162@04 < V@28@04 && 0 <= i1@162@04]
(assert (and (< i1@162@04 V@28@04) (<= 0 i1@162@04)))
; [eval] aloc(opt_get1(source), i1).option$array$ != (None(): option[array])
; [eval] aloc(opt_get1(source), i1)
; [eval] opt_get1(source)
(push) ; 16
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 16
; Joined path conditions
(push) ; 16
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 17
(assert (not (< i1@162@04 (alen<Int> (opt_get1 $Snap.unit source@26@04)))))
(check-sat)
; unsat
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               21197
;  :arith-add-rows          16232
;  :arith-assert-diseq      1202
;  :arith-assert-lower      6605
;  :arith-assert-upper      4142
;  :arith-bound-prop        1561
;  :arith-conflicts         488
;  :arith-eq-adapter        4221
;  :arith-fixed-eqs         1953
;  :arith-grobner           88
;  :arith-max-min           733
;  :arith-nonlinear-bounds  62
;  :arith-nonlinear-horner  72
;  :arith-offset-eqs        2075
;  :arith-pivots            3220
;  :conflicts               1259
;  :datatype-accessor-ax    80
;  :datatype-constructor-ax 684
;  :datatype-occurs-check   284
;  :datatype-splits         202
;  :decisions               3515
;  :del-clause              25537
;  :final-checks            217
;  :interface-eqs           15
;  :max-generation          9
;  :max-memory              7.75
;  :memory                  7.69
;  :minimized-lits          126
;  :mk-bool-var             35384
;  :mk-clause               25546
;  :num-allocs              419160
;  :num-checks              282
;  :propagations            14417
;  :quant-instantiations    7737
;  :rlimit-count            1152200)
(assert (< i1@162@04 (alen<Int> (opt_get1 $Snap.unit source@26@04))))
(pop) ; 16
; Joined path conditions
(assert (< i1@162@04 (alen<Int> (opt_get1 $Snap.unit source@26@04))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@162@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@162@04)))
(push) ; 16
(assert (not (<
  $Perm.No
  (+
    (+
      (+
        (ite
          (and
            (<
              (inv@136@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@162@04))
              V@28@04)
            (<=
              0
              (inv@136@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@162@04))))
          (*
            (scale $Snap.unit (* (to_real (* V@28@04 V@28@04)) $Perm.Write))
            $k@135@04)
          $Perm.No)
        (ite
          (and
            (<
              (inv@128@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@162@04))
              V@28@04)
            (<=
              0
              (inv@128@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@162@04))))
          (*
            (scale $Snap.unit (* (to_real (* V@28@04 V@28@04)) $Perm.Write))
            $k@127@04)
          $Perm.No))
      (-
        (-
          (ite
            (and
              (<
                (inv@42@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@162@04))
                V@28@04)
              (<=
                0
                (inv@42@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@162@04))))
            $k@41@04
            $Perm.No)
          (pTaken@95@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@162@04)))
        (pTaken@106@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@162@04))))
    (-
      (-
        (ite
          (and
            (<
              (inv@34@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@162@04))
              V@28@04)
            (<=
              0
              (inv@34@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@162@04))))
          $k@33@04
          $Perm.No)
        (pTaken@96@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@162@04)))
      (pTaken@105@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@162@04)))))))
(check-sat)
; unsat
(pop) ; 16
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               22074
;  :arith-add-rows          17353
;  :arith-assert-diseq      1294
;  :arith-assert-lower      6898
;  :arith-assert-upper      4309
;  :arith-bound-prop        1645
;  :arith-conflicts         508
;  :arith-eq-adapter        4447
;  :arith-fixed-eqs         2059
;  :arith-grobner           88
;  :arith-max-min           733
;  :arith-nonlinear-bounds  62
;  :arith-nonlinear-horner  72
;  :arith-offset-eqs        2257
;  :arith-pivots            3361
;  :conflicts               1306
;  :datatype-accessor-ax    80
;  :datatype-constructor-ax 688
;  :datatype-occurs-check   284
;  :datatype-splits         202
;  :decisions               3616
;  :del-clause              26450
;  :final-checks            217
;  :interface-eqs           15
;  :max-generation          9
;  :max-memory              7.94
;  :memory                  7.87
;  :minimized-lits          134
;  :mk-bool-var             36726
;  :mk-clause               26612
;  :num-allocs              424266
;  :num-checks              283
;  :propagations            15136
;  :quant-instantiations    7927
;  :rlimit-count            1189663
;  :time                    0.01)
; [eval] (None(): option[array])
(pop) ; 15
(push) ; 15
; [else-branch: 186 | !(i1@162@04 < V@28@04 && 0 <= i1@162@04)]
(assert (not (and (< i1@162@04 V@28@04) (<= 0 i1@162@04))))
(pop) ; 15
(pop) ; 14
; Joined path conditions
(assert (implies
  (and (< i1@162@04 V@28@04) (<= 0 i1@162@04))
  (and
    (< i1@162@04 V@28@04)
    (<= 0 i1@162@04)
    (< i1@162@04 (alen<Int> (opt_get1 $Snap.unit source@26@04)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@162@04)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@162@04)))))
; Joined path conditions
(pop) ; 13
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@162@04 Int)) (!
  (implies
    (and (< i1@162@04 V@28@04) (<= 0 i1@162@04))
    (and
      (< i1@162@04 V@28@04)
      (<= 0 i1@162@04)
      (< i1@162@04 (alen<Int> (opt_get1 $Snap.unit source@26@04)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@162@04)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@162@04))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@162@04))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 12
(pop) ; 11
; Joined path conditions
(assert (implies
  (= exc@123@04 $Ref.null)
  (forall ((i1@162@04 Int)) (!
    (implies
      (and (< i1@162@04 V@28@04) (<= 0 i1@162@04))
      (and
        (< i1@162@04 V@28@04)
        (<= 0 i1@162@04)
        (< i1@162@04 (alen<Int> (opt_get1 $Snap.unit source@26@04)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@162@04)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@162@04))))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@162@04))
    :qid |prog.l<no position>-aux|))))
(push) ; 11
(assert (not (implies
  (= exc@123@04 $Ref.null)
  (forall ((i1@162@04 Int)) (!
    (implies
      (and (< i1@162@04 V@28@04) (<= 0 i1@162@04))
      (not
        (=
          ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@162@04))
          (as None<option<array>>  option<array>))))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@162@04))
    :qid |prog.l<no position>|)))))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               22432
;  :arith-add-rows          17595
;  :arith-assert-diseq      1306
;  :arith-assert-lower      7013
;  :arith-assert-upper      4374
;  :arith-bound-prop        1661
;  :arith-conflicts         517
;  :arith-eq-adapter        4508
;  :arith-fixed-eqs         2097
;  :arith-grobner           88
;  :arith-max-min           733
;  :arith-nonlinear-bounds  62
;  :arith-nonlinear-horner  72
;  :arith-offset-eqs        2298
;  :arith-pivots            3432
;  :conflicts               1320
;  :datatype-accessor-ax    81
;  :datatype-constructor-ax 695
;  :datatype-occurs-check   284
;  :datatype-splits         202
;  :decisions               3701
;  :del-clause              27079
;  :final-checks            217
;  :interface-eqs           15
;  :max-generation          9
;  :max-memory              7.94
;  :memory                  7.85
;  :minimized-lits          136
;  :mk-bool-var             37305
;  :mk-clause               27088
;  :num-allocs              426579
;  :num-checks              284
;  :propagations            15404
;  :quant-instantiations    8051
;  :rlimit-count            1202919
;  :time                    0.00)
(assert (implies
  (= exc@123@04 $Ref.null)
  (forall ((i1@162@04 Int)) (!
    (implies
      (and (< i1@162@04 V@28@04) (<= 0 i1@162@04))
      (not
        (=
          ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@162@04))
          (as None<option<array>>  option<array>))))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@162@04))
    :qid |prog.l<no position>|))))
; [eval] exc == null ==> (forall i1: Int :: { alen(opt_get1(aloc(opt_get1(source), i1).option$array$)) } 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(source), i1).option$array$)) == V)
; [eval] exc == null
(push) ; 11
(set-option :timeout 10)
(push) ; 12
(assert (not (not (= exc@123@04 $Ref.null))))
(check-sat)
; unknown
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               22469
;  :arith-add-rows          17595
;  :arith-assert-diseq      1306
;  :arith-assert-lower      7028
;  :arith-assert-upper      4382
;  :arith-bound-prop        1661
;  :arith-conflicts         517
;  :arith-eq-adapter        4508
;  :arith-fixed-eqs         2097
;  :arith-grobner           93
;  :arith-max-min           759
;  :arith-nonlinear-bounds  65
;  :arith-nonlinear-horner  76
;  :arith-offset-eqs        2298
;  :arith-pivots            3432
;  :conflicts               1320
;  :datatype-accessor-ax    81
;  :datatype-constructor-ax 703
;  :datatype-occurs-check   289
;  :datatype-splits         206
;  :decisions               3709
;  :del-clause              27079
;  :final-checks            221
;  :interface-eqs           15
;  :max-generation          9
;  :max-memory              7.94
;  :memory                  7.86
;  :minimized-lits          136
;  :mk-bool-var             37310
;  :mk-clause               27088
;  :num-allocs              427619
;  :num-checks              285
;  :propagations            15404
;  :quant-instantiations    8051
;  :rlimit-count            1204588)
; [then-branch: 187 | exc@123@04 == Null | live]
; [else-branch: 187 | exc@123@04 != Null | dead]
(push) ; 12
; [then-branch: 187 | exc@123@04 == Null]
; [eval] (forall i1: Int :: { alen(opt_get1(aloc(opt_get1(source), i1).option$array$)) } 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(source), i1).option$array$)) == V)
(declare-const i1@163@04 Int)
(push) ; 13
; [eval] 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(source), i1).option$array$)) == V
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 14
; [then-branch: 188 | 0 <= i1@163@04 | live]
; [else-branch: 188 | !(0 <= i1@163@04) | live]
(push) ; 15
; [then-branch: 188 | 0 <= i1@163@04]
(assert (<= 0 i1@163@04))
; [eval] i1 < V
(pop) ; 15
(push) ; 15
; [else-branch: 188 | !(0 <= i1@163@04)]
(assert (not (<= 0 i1@163@04)))
(pop) ; 15
(pop) ; 14
; Joined path conditions
; Joined path conditions
(push) ; 14
; [then-branch: 189 | i1@163@04 < V@28@04 && 0 <= i1@163@04 | live]
; [else-branch: 189 | !(i1@163@04 < V@28@04 && 0 <= i1@163@04) | live]
(push) ; 15
; [then-branch: 189 | i1@163@04 < V@28@04 && 0 <= i1@163@04]
(assert (and (< i1@163@04 V@28@04) (<= 0 i1@163@04)))
; [eval] alen(opt_get1(aloc(opt_get1(source), i1).option$array$)) == V
; [eval] alen(opt_get1(aloc(opt_get1(source), i1).option$array$))
; [eval] opt_get1(aloc(opt_get1(source), i1).option$array$)
; [eval] aloc(opt_get1(source), i1)
; [eval] opt_get1(source)
(push) ; 16
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 16
; Joined path conditions
(push) ; 16
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 17
(assert (not (< i1@163@04 (alen<Int> (opt_get1 $Snap.unit source@26@04)))))
(check-sat)
; unsat
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               22469
;  :arith-add-rows          17595
;  :arith-assert-diseq      1306
;  :arith-assert-lower      7030
;  :arith-assert-upper      4382
;  :arith-bound-prop        1661
;  :arith-conflicts         517
;  :arith-eq-adapter        4508
;  :arith-fixed-eqs         2097
;  :arith-grobner           93
;  :arith-max-min           759
;  :arith-nonlinear-bounds  65
;  :arith-nonlinear-horner  76
;  :arith-offset-eqs        2298
;  :arith-pivots            3433
;  :conflicts               1320
;  :datatype-accessor-ax    81
;  :datatype-constructor-ax 703
;  :datatype-occurs-check   289
;  :datatype-splits         206
;  :decisions               3709
;  :del-clause              27079
;  :final-checks            221
;  :interface-eqs           15
;  :max-generation          9
;  :max-memory              7.94
;  :memory                  7.86
;  :minimized-lits          136
;  :mk-bool-var             37312
;  :mk-clause               27088
;  :num-allocs              427723
;  :num-checks              286
;  :propagations            15404
;  :quant-instantiations    8051
;  :rlimit-count            1204787)
(assert (< i1@163@04 (alen<Int> (opt_get1 $Snap.unit source@26@04))))
(pop) ; 16
; Joined path conditions
(assert (< i1@163@04 (alen<Int> (opt_get1 $Snap.unit source@26@04))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@163@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@163@04)))
(push) ; 16
(assert (not (<
  $Perm.No
  (+
    (+
      (+
        (ite
          (and
            (<
              (inv@136@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@163@04))
              V@28@04)
            (<=
              0
              (inv@136@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@163@04))))
          (*
            (scale $Snap.unit (* (to_real (* V@28@04 V@28@04)) $Perm.Write))
            $k@135@04)
          $Perm.No)
        (ite
          (and
            (<
              (inv@128@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@163@04))
              V@28@04)
            (<=
              0
              (inv@128@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@163@04))))
          (*
            (scale $Snap.unit (* (to_real (* V@28@04 V@28@04)) $Perm.Write))
            $k@127@04)
          $Perm.No))
      (-
        (-
          (ite
            (and
              (<
                (inv@42@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@163@04))
                V@28@04)
              (<=
                0
                (inv@42@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@163@04))))
            $k@41@04
            $Perm.No)
          (pTaken@95@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@163@04)))
        (pTaken@106@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@163@04))))
    (-
      (-
        (ite
          (and
            (<
              (inv@34@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@163@04))
              V@28@04)
            (<=
              0
              (inv@34@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@163@04))))
          $k@33@04
          $Perm.No)
        (pTaken@96@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@163@04)))
      (pTaken@105@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@163@04)))))))
(check-sat)
; unsat
(pop) ; 16
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               22864
;  :arith-add-rows          18035
;  :arith-assert-diseq      1329
;  :arith-assert-lower      7194
;  :arith-assert-upper      4471
;  :arith-bound-prop        1699
;  :arith-conflicts         532
;  :arith-eq-adapter        4605
;  :arith-fixed-eqs         2140
;  :arith-grobner           93
;  :arith-max-min           759
;  :arith-nonlinear-bounds  65
;  :arith-nonlinear-horner  76
;  :arith-offset-eqs        2337
;  :arith-pivots            3503
;  :conflicts               1353
;  :datatype-accessor-ax    81
;  :datatype-constructor-ax 707
;  :datatype-occurs-check   289
;  :datatype-splits         206
;  :decisions               3762
;  :del-clause              27455
;  :final-checks            221
;  :interface-eqs           15
;  :max-generation          9
;  :max-memory              7.94
;  :memory                  7.87
;  :minimized-lits          146
;  :mk-bool-var             38042
;  :mk-clause               27617
;  :num-allocs              430821
;  :num-checks              287
;  :propagations            15762
;  :quant-instantiations    8157
;  :rlimit-count            1222771
;  :time                    0.01)
(push) ; 16
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 17
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@163@04))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               22864
;  :arith-add-rows          18035
;  :arith-assert-diseq      1329
;  :arith-assert-lower      7194
;  :arith-assert-upper      4471
;  :arith-bound-prop        1699
;  :arith-conflicts         532
;  :arith-eq-adapter        4605
;  :arith-fixed-eqs         2140
;  :arith-grobner           93
;  :arith-max-min           759
;  :arith-nonlinear-bounds  65
;  :arith-nonlinear-horner  76
;  :arith-offset-eqs        2337
;  :arith-pivots            3503
;  :conflicts               1354
;  :datatype-accessor-ax    81
;  :datatype-constructor-ax 707
;  :datatype-occurs-check   289
;  :datatype-splits         206
;  :decisions               3762
;  :del-clause              27455
;  :final-checks            221
;  :interface-eqs           15
;  :max-generation          9
;  :max-memory              7.94
;  :memory                  7.87
;  :minimized-lits          146
;  :mk-bool-var             38042
;  :mk-clause               27617
;  :num-allocs              430912
;  :num-checks              288
;  :propagations            15762
;  :quant-instantiations    8157
;  :rlimit-count            1222866)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@163@04))
    (as None<option<array>>  option<array>))))
(pop) ; 16
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@163@04))
    (as None<option<array>>  option<array>))))
(pop) ; 15
(push) ; 15
; [else-branch: 189 | !(i1@163@04 < V@28@04 && 0 <= i1@163@04)]
(assert (not (and (< i1@163@04 V@28@04) (<= 0 i1@163@04))))
(pop) ; 15
(pop) ; 14
; Joined path conditions
(assert (implies
  (and (< i1@163@04 V@28@04) (<= 0 i1@163@04))
  (and
    (< i1@163@04 V@28@04)
    (<= 0 i1@163@04)
    (< i1@163@04 (alen<Int> (opt_get1 $Snap.unit source@26@04)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@163@04)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@163@04))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@163@04))
        (as None<option<array>>  option<array>))))))
; Joined path conditions
(pop) ; 13
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@163@04 Int)) (!
  (implies
    (and (< i1@163@04 V@28@04) (<= 0 i1@163@04))
    (and
      (< i1@163@04 V@28@04)
      (<= 0 i1@163@04)
      (< i1@163@04 (alen<Int> (opt_get1 $Snap.unit source@26@04)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@163@04)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@163@04))
      (not
        (=
          ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@163@04))
          (as None<option<array>>  option<array>)))))
  :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@163@04)))))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 12
(pop) ; 11
; Joined path conditions
(assert (implies
  (= exc@123@04 $Ref.null)
  (forall ((i1@163@04 Int)) (!
    (implies
      (and (< i1@163@04 V@28@04) (<= 0 i1@163@04))
      (and
        (< i1@163@04 V@28@04)
        (<= 0 i1@163@04)
        (< i1@163@04 (alen<Int> (opt_get1 $Snap.unit source@26@04)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@163@04)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@163@04))
        (not
          (=
            ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@163@04))
            (as None<option<array>>  option<array>)))))
    :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@163@04)))))
    :qid |prog.l<no position>-aux|))))
(push) ; 11
(assert (not (implies
  (= exc@123@04 $Ref.null)
  (forall ((i1@163@04 Int)) (!
    (implies
      (and (< i1@163@04 V@28@04) (<= 0 i1@163@04))
      (=
        (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@163@04))))
        V@28@04))
    :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@163@04)))))
    :qid |prog.l<no position>|)))))
(check-sat)
; unsat
(pop) ; 11
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               23159
;  :arith-add-rows          18173
;  :arith-assert-diseq      1344
;  :arith-assert-lower      7285
;  :arith-assert-upper      4524
;  :arith-bound-prop        1716
;  :arith-conflicts         540
;  :arith-eq-adapter        4663
;  :arith-fixed-eqs         2160
;  :arith-grobner           93
;  :arith-max-min           759
;  :arith-nonlinear-bounds  65
;  :arith-nonlinear-horner  76
;  :arith-offset-eqs        2365
;  :arith-pivots            3557
;  :conflicts               1371
;  :datatype-accessor-ax    81
;  :datatype-constructor-ax 711
;  :datatype-occurs-check   289
;  :datatype-splits         206
;  :decisions               3847
;  :del-clause              28164
;  :final-checks            221
;  :interface-eqs           15
;  :max-generation          9
;  :max-memory              7.94
;  :memory                  7.86
;  :minimized-lits          149
;  :mk-bool-var             38693
;  :mk-clause               28173
;  :num-allocs              433101
;  :num-checks              289
;  :propagations            15966
;  :quant-instantiations    8287
;  :rlimit-count            1233455
;  :time                    0.01)
(assert (implies
  (= exc@123@04 $Ref.null)
  (forall ((i1@163@04 Int)) (!
    (implies
      (and (< i1@163@04 V@28@04) (<= 0 i1@163@04))
      (=
        (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@163@04))))
        V@28@04))
    :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@163@04)))))
    :qid |prog.l<no position>|))))
; [eval] exc == null ==> (forall i1: Int :: { aloc(opt_get1(source), i1) } (forall i2: Int :: { aloc(opt_get1(source), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(source), i1).option$array$ == aloc(opt_get1(source), i2).option$array$ ==> i1 == i2))
; [eval] exc == null
(push) ; 11
(set-option :timeout 10)
(push) ; 12
(assert (not (not (= exc@123@04 $Ref.null))))
(check-sat)
; unknown
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               23196
;  :arith-add-rows          18173
;  :arith-assert-diseq      1344
;  :arith-assert-lower      7300
;  :arith-assert-upper      4532
;  :arith-bound-prop        1716
;  :arith-conflicts         540
;  :arith-eq-adapter        4663
;  :arith-fixed-eqs         2160
;  :arith-grobner           98
;  :arith-max-min           785
;  :arith-nonlinear-bounds  68
;  :arith-nonlinear-horner  80
;  :arith-offset-eqs        2365
;  :arith-pivots            3557
;  :conflicts               1371
;  :datatype-accessor-ax    81
;  :datatype-constructor-ax 719
;  :datatype-occurs-check   294
;  :datatype-splits         210
;  :decisions               3855
;  :del-clause              28164
;  :final-checks            225
;  :interface-eqs           15
;  :max-generation          9
;  :max-memory              7.94
;  :memory                  7.87
;  :minimized-lits          149
;  :mk-bool-var             38698
;  :mk-clause               28173
;  :num-allocs              434149
;  :num-checks              290
;  :propagations            15966
;  :quant-instantiations    8287
;  :rlimit-count            1235126
;  :time                    0.00)
; [then-branch: 190 | exc@123@04 == Null | live]
; [else-branch: 190 | exc@123@04 != Null | dead]
(push) ; 12
; [then-branch: 190 | exc@123@04 == Null]
; [eval] (forall i1: Int :: { aloc(opt_get1(source), i1) } (forall i2: Int :: { aloc(opt_get1(source), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(source), i1).option$array$ == aloc(opt_get1(source), i2).option$array$ ==> i1 == i2))
(declare-const i1@164@04 Int)
(push) ; 13
; [eval] (forall i2: Int :: { aloc(opt_get1(source), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(source), i1).option$array$ == aloc(opt_get1(source), i2).option$array$ ==> i1 == i2)
(declare-const i2@165@04 Int)
(push) ; 14
; [eval] 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(source), i1).option$array$ == aloc(opt_get1(source), i2).option$array$ ==> i1 == i2
; [eval] 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(source), i1).option$array$ == aloc(opt_get1(source), i2).option$array$
; [eval] 0 <= i1
(push) ; 15
; [then-branch: 191 | 0 <= i1@164@04 | live]
; [else-branch: 191 | !(0 <= i1@164@04) | live]
(push) ; 16
; [then-branch: 191 | 0 <= i1@164@04]
(assert (<= 0 i1@164@04))
; [eval] i1 < V
(push) ; 17
; [then-branch: 192 | i1@164@04 < V@28@04 | live]
; [else-branch: 192 | !(i1@164@04 < V@28@04) | live]
(push) ; 18
; [then-branch: 192 | i1@164@04 < V@28@04]
(assert (< i1@164@04 V@28@04))
; [eval] 0 <= i2
(push) ; 19
; [then-branch: 193 | 0 <= i2@165@04 | live]
; [else-branch: 193 | !(0 <= i2@165@04) | live]
(push) ; 20
; [then-branch: 193 | 0 <= i2@165@04]
(assert (<= 0 i2@165@04))
; [eval] i2 < V
(push) ; 21
; [then-branch: 194 | i2@165@04 < V@28@04 | live]
; [else-branch: 194 | !(i2@165@04 < V@28@04) | live]
(push) ; 22
; [then-branch: 194 | i2@165@04 < V@28@04]
(assert (< i2@165@04 V@28@04))
; [eval] aloc(opt_get1(source), i1).option$array$ == aloc(opt_get1(source), i2).option$array$
; [eval] aloc(opt_get1(source), i1)
; [eval] opt_get1(source)
(push) ; 23
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 23
; Joined path conditions
(push) ; 23
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 24
(assert (not (< i1@164@04 (alen<Int> (opt_get1 $Snap.unit source@26@04)))))
(check-sat)
; unsat
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               23196
;  :arith-add-rows          18173
;  :arith-assert-diseq      1344
;  :arith-assert-lower      7304
;  :arith-assert-upper      4532
;  :arith-bound-prop        1716
;  :arith-conflicts         540
;  :arith-eq-adapter        4663
;  :arith-fixed-eqs         2160
;  :arith-grobner           98
;  :arith-max-min           785
;  :arith-nonlinear-bounds  68
;  :arith-nonlinear-horner  80
;  :arith-offset-eqs        2365
;  :arith-pivots            3557
;  :conflicts               1371
;  :datatype-accessor-ax    81
;  :datatype-constructor-ax 719
;  :datatype-occurs-check   294
;  :datatype-splits         210
;  :decisions               3855
;  :del-clause              28164
;  :final-checks            225
;  :interface-eqs           15
;  :max-generation          9
;  :max-memory              7.94
;  :memory                  7.87
;  :minimized-lits          149
;  :mk-bool-var             38702
;  :mk-clause               28173
;  :num-allocs              434430
;  :num-checks              291
;  :propagations            15966
;  :quant-instantiations    8287
;  :rlimit-count            1235465)
(assert (< i1@164@04 (alen<Int> (opt_get1 $Snap.unit source@26@04))))
(pop) ; 23
; Joined path conditions
(assert (< i1@164@04 (alen<Int> (opt_get1 $Snap.unit source@26@04))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@164@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@164@04)))
(push) ; 23
(assert (not (<
  $Perm.No
  (+
    (+
      (+
        (ite
          (and
            (<
              (inv@136@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@164@04))
              V@28@04)
            (<=
              0
              (inv@136@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@164@04))))
          (*
            (scale $Snap.unit (* (to_real (* V@28@04 V@28@04)) $Perm.Write))
            $k@135@04)
          $Perm.No)
        (ite
          (and
            (<
              (inv@128@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@164@04))
              V@28@04)
            (<=
              0
              (inv@128@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@164@04))))
          (*
            (scale $Snap.unit (* (to_real (* V@28@04 V@28@04)) $Perm.Write))
            $k@127@04)
          $Perm.No))
      (-
        (-
          (ite
            (and
              (<
                (inv@42@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@164@04))
                V@28@04)
              (<=
                0
                (inv@42@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@164@04))))
            $k@41@04
            $Perm.No)
          (pTaken@95@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@164@04)))
        (pTaken@106@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@164@04))))
    (-
      (-
        (ite
          (and
            (<
              (inv@34@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@164@04))
              V@28@04)
            (<=
              0
              (inv@34@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@164@04))))
          $k@33@04
          $Perm.No)
        (pTaken@96@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@164@04)))
      (pTaken@105@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@164@04)))))))
(check-sat)
; unsat
(pop) ; 23
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               23842
;  :arith-add-rows          19191
;  :arith-assert-diseq      1409
;  :arith-assert-lower      7540
;  :arith-assert-upper      4683
;  :arith-bound-prop        1772
;  :arith-conflicts         559
;  :arith-eq-adapter        4840
;  :arith-fixed-eqs         2251
;  :arith-grobner           98
;  :arith-max-min           785
;  :arith-nonlinear-bounds  68
;  :arith-nonlinear-horner  80
;  :arith-offset-eqs        2445
;  :arith-pivots            3684
;  :conflicts               1409
;  :datatype-accessor-ax    81
;  :datatype-constructor-ax 723
;  :datatype-occurs-check   294
;  :datatype-splits         210
;  :decisions               3945
;  :del-clause              28841
;  :final-checks            225
;  :interface-eqs           15
;  :max-generation          9
;  :max-memory              7.94
;  :memory                  7.90
;  :minimized-lits          158
;  :mk-bool-var             39723
;  :mk-clause               29003
;  :num-allocs              438361
;  :num-checks              292
;  :propagations            16486
;  :quant-instantiations    8406
;  :rlimit-count            1269207
;  :time                    0.01)
; [eval] aloc(opt_get1(source), i2)
; [eval] opt_get1(source)
(push) ; 23
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 23
; Joined path conditions
(push) ; 23
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 24
(assert (not (< i2@165@04 (alen<Int> (opt_get1 $Snap.unit source@26@04)))))
(check-sat)
; unsat
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               23842
;  :arith-add-rows          19191
;  :arith-assert-diseq      1409
;  :arith-assert-lower      7540
;  :arith-assert-upper      4683
;  :arith-bound-prop        1772
;  :arith-conflicts         559
;  :arith-eq-adapter        4840
;  :arith-fixed-eqs         2251
;  :arith-grobner           98
;  :arith-max-min           785
;  :arith-nonlinear-bounds  68
;  :arith-nonlinear-horner  80
;  :arith-offset-eqs        2445
;  :arith-pivots            3684
;  :conflicts               1409
;  :datatype-accessor-ax    81
;  :datatype-constructor-ax 723
;  :datatype-occurs-check   294
;  :datatype-splits         210
;  :decisions               3945
;  :del-clause              28841
;  :final-checks            225
;  :interface-eqs           15
;  :max-generation          9
;  :max-memory              7.94
;  :memory                  7.90
;  :minimized-lits          158
;  :mk-bool-var             39723
;  :mk-clause               29003
;  :num-allocs              438388
;  :num-checks              293
;  :propagations            16486
;  :quant-instantiations    8406
;  :rlimit-count            1269237)
(assert (< i2@165@04 (alen<Int> (opt_get1 $Snap.unit source@26@04))))
(pop) ; 23
; Joined path conditions
(assert (< i2@165@04 (alen<Int> (opt_get1 $Snap.unit source@26@04))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@165@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@165@04)))
(push) ; 23
(assert (not (<
  $Perm.No
  (+
    (+
      (+
        (ite
          (and
            (<
              (inv@136@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@165@04))
              V@28@04)
            (<=
              0
              (inv@136@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@165@04))))
          (*
            (scale $Snap.unit (* (to_real (* V@28@04 V@28@04)) $Perm.Write))
            $k@135@04)
          $Perm.No)
        (ite
          (and
            (<
              (inv@128@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@165@04))
              V@28@04)
            (<=
              0
              (inv@128@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@165@04))))
          (*
            (scale $Snap.unit (* (to_real (* V@28@04 V@28@04)) $Perm.Write))
            $k@127@04)
          $Perm.No))
      (-
        (-
          (ite
            (and
              (<
                (inv@42@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@165@04))
                V@28@04)
              (<=
                0
                (inv@42@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@165@04))))
            $k@41@04
            $Perm.No)
          (pTaken@95@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@165@04)))
        (pTaken@106@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@165@04))))
    (-
      (-
        (ite
          (and
            (<
              (inv@34@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@165@04))
              V@28@04)
            (<=
              0
              (inv@34@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@165@04))))
          $k@33@04
          $Perm.No)
        (pTaken@96@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@165@04)))
      (pTaken@105@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@165@04)))))))
(check-sat)
; unsat
(pop) ; 23
; 0.02s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               24865
;  :arith-add-rows          20175
;  :arith-assert-diseq      1475
;  :arith-assert-lower      7911
;  :arith-assert-upper      4870
;  :arith-bound-prop        1839
;  :arith-conflicts         573
;  :arith-eq-adapter        5047
;  :arith-fixed-eqs         2354
;  :arith-grobner           98
;  :arith-max-min           785
;  :arith-nonlinear-bounds  68
;  :arith-nonlinear-horner  80
;  :arith-offset-eqs        2530
;  :arith-pivots            3794
;  :conflicts               1447
;  :datatype-accessor-ax    81
;  :datatype-constructor-ax 727
;  :datatype-occurs-check   294
;  :datatype-splits         210
;  :decisions               4099
;  :del-clause              29946
;  :final-checks            225
;  :interface-eqs           15
;  :max-generation          9
;  :max-memory              7.99
;  :memory                  7.98
;  :minimized-lits          169
;  :mk-bool-var             41390
;  :mk-clause               30265
;  :num-allocs              445034
;  :num-checks              294
;  :propagations            17445
;  :quant-instantiations    8820
;  :rlimit-count            1313532
;  :time                    0.02)
(pop) ; 22
(push) ; 22
; [else-branch: 194 | !(i2@165@04 < V@28@04)]
(assert (not (< i2@165@04 V@28@04)))
(pop) ; 22
(pop) ; 21
; Joined path conditions
(assert (implies
  (< i2@165@04 V@28@04)
  (and
    (< i2@165@04 V@28@04)
    (< i1@164@04 (alen<Int> (opt_get1 $Snap.unit source@26@04)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@164@04)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@164@04))
    (< i2@165@04 (alen<Int> (opt_get1 $Snap.unit source@26@04)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@165@04)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@165@04)))))
; Joined path conditions
(pop) ; 20
(push) ; 20
; [else-branch: 193 | !(0 <= i2@165@04)]
(assert (not (<= 0 i2@165@04)))
(pop) ; 20
(pop) ; 19
; Joined path conditions
(assert (implies
  (<= 0 i2@165@04)
  (and
    (<= 0 i2@165@04)
    (implies
      (< i2@165@04 V@28@04)
      (and
        (< i2@165@04 V@28@04)
        (< i1@164@04 (alen<Int> (opt_get1 $Snap.unit source@26@04)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@164@04)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@164@04))
        (< i2@165@04 (alen<Int> (opt_get1 $Snap.unit source@26@04)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@165@04)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@165@04)))))))
; Joined path conditions
(pop) ; 18
(push) ; 18
; [else-branch: 192 | !(i1@164@04 < V@28@04)]
(assert (not (< i1@164@04 V@28@04)))
(pop) ; 18
(pop) ; 17
; Joined path conditions
(assert (implies
  (< i1@164@04 V@28@04)
  (and
    (< i1@164@04 V@28@04)
    (implies
      (<= 0 i2@165@04)
      (and
        (<= 0 i2@165@04)
        (implies
          (< i2@165@04 V@28@04)
          (and
            (< i2@165@04 V@28@04)
            (< i1@164@04 (alen<Int> (opt_get1 $Snap.unit source@26@04)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@164@04)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@164@04))
            (< i2@165@04 (alen<Int> (opt_get1 $Snap.unit source@26@04)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@165@04)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@165@04)))))))))
; Joined path conditions
(pop) ; 16
(push) ; 16
; [else-branch: 191 | !(0 <= i1@164@04)]
(assert (not (<= 0 i1@164@04)))
(pop) ; 16
(pop) ; 15
; Joined path conditions
(assert (implies
  (<= 0 i1@164@04)
  (and
    (<= 0 i1@164@04)
    (implies
      (< i1@164@04 V@28@04)
      (and
        (< i1@164@04 V@28@04)
        (implies
          (<= 0 i2@165@04)
          (and
            (<= 0 i2@165@04)
            (implies
              (< i2@165@04 V@28@04)
              (and
                (< i2@165@04 V@28@04)
                (< i1@164@04 (alen<Int> (opt_get1 $Snap.unit source@26@04)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@164@04)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@164@04))
                (< i2@165@04 (alen<Int> (opt_get1 $Snap.unit source@26@04)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@165@04)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@165@04)))))))))))
; Joined path conditions
(push) ; 15
; [then-branch: 195 | Lookup(option$array$,sm@137@04,aloc((_, _), opt_get1(_, source@26@04), i1@164@04)) == Lookup(option$array$,sm@137@04,aloc((_, _), opt_get1(_, source@26@04), i2@165@04)) && i2@165@04 < V@28@04 && 0 <= i2@165@04 && i1@164@04 < V@28@04 && 0 <= i1@164@04 | live]
; [else-branch: 195 | !(Lookup(option$array$,sm@137@04,aloc((_, _), opt_get1(_, source@26@04), i1@164@04)) == Lookup(option$array$,sm@137@04,aloc((_, _), opt_get1(_, source@26@04), i2@165@04)) && i2@165@04 < V@28@04 && 0 <= i2@165@04 && i1@164@04 < V@28@04 && 0 <= i1@164@04) | live]
(push) ; 16
; [then-branch: 195 | Lookup(option$array$,sm@137@04,aloc((_, _), opt_get1(_, source@26@04), i1@164@04)) == Lookup(option$array$,sm@137@04,aloc((_, _), opt_get1(_, source@26@04), i2@165@04)) && i2@165@04 < V@28@04 && 0 <= i2@165@04 && i1@164@04 < V@28@04 && 0 <= i1@164@04]
(assert (and
  (and
    (and
      (and
        (=
          ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@164@04))
          ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@165@04)))
        (< i2@165@04 V@28@04))
      (<= 0 i2@165@04))
    (< i1@164@04 V@28@04))
  (<= 0 i1@164@04)))
; [eval] i1 == i2
(pop) ; 16
(push) ; 16
; [else-branch: 195 | !(Lookup(option$array$,sm@137@04,aloc((_, _), opt_get1(_, source@26@04), i1@164@04)) == Lookup(option$array$,sm@137@04,aloc((_, _), opt_get1(_, source@26@04), i2@165@04)) && i2@165@04 < V@28@04 && 0 <= i2@165@04 && i1@164@04 < V@28@04 && 0 <= i1@164@04)]
(assert (not
  (and
    (and
      (and
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@164@04))
            ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@165@04)))
          (< i2@165@04 V@28@04))
        (<= 0 i2@165@04))
      (< i1@164@04 V@28@04))
    (<= 0 i1@164@04))))
(pop) ; 16
(pop) ; 15
; Joined path conditions
(assert (implies
  (and
    (and
      (and
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@164@04))
            ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@165@04)))
          (< i2@165@04 V@28@04))
        (<= 0 i2@165@04))
      (< i1@164@04 V@28@04))
    (<= 0 i1@164@04))
  (and
    (=
      ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@164@04))
      ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@165@04)))
    (< i2@165@04 V@28@04)
    (<= 0 i2@165@04)
    (< i1@164@04 V@28@04)
    (<= 0 i1@164@04))))
; Joined path conditions
(pop) ; 14
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i2@165@04 Int)) (!
  (and
    (implies
      (<= 0 i1@164@04)
      (and
        (<= 0 i1@164@04)
        (implies
          (< i1@164@04 V@28@04)
          (and
            (< i1@164@04 V@28@04)
            (implies
              (<= 0 i2@165@04)
              (and
                (<= 0 i2@165@04)
                (implies
                  (< i2@165@04 V@28@04)
                  (and
                    (< i2@165@04 V@28@04)
                    (< i1@164@04 (alen<Int> (opt_get1 $Snap.unit source@26@04)))
                    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@164@04)) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@164@04))
                    (< i2@165@04 (alen<Int> (opt_get1 $Snap.unit source@26@04)))
                    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@165@04)) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@165@04))))))))))
    (implies
      (and
        (and
          (and
            (and
              (=
                ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@164@04))
                ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@165@04)))
              (< i2@165@04 V@28@04))
            (<= 0 i2@165@04))
          (< i1@164@04 V@28@04))
        (<= 0 i1@164@04))
      (and
        (=
          ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@164@04))
          ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@165@04)))
        (< i2@165@04 V@28@04)
        (<= 0 i2@165@04)
        (< i1@164@04 V@28@04)
        (<= 0 i1@164@04))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@165@04))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 13
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@164@04 Int)) (!
  (forall ((i2@165@04 Int)) (!
    (and
      (implies
        (<= 0 i1@164@04)
        (and
          (<= 0 i1@164@04)
          (implies
            (< i1@164@04 V@28@04)
            (and
              (< i1@164@04 V@28@04)
              (implies
                (<= 0 i2@165@04)
                (and
                  (<= 0 i2@165@04)
                  (implies
                    (< i2@165@04 V@28@04)
                    (and
                      (< i2@165@04 V@28@04)
                      (<
                        i1@164@04
                        (alen<Int> (opt_get1 $Snap.unit source@26@04)))
                      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@164@04)) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@164@04))
                      (<
                        i2@165@04
                        (alen<Int> (opt_get1 $Snap.unit source@26@04)))
                      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@165@04)) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@165@04))))))))))
      (implies
        (and
          (and
            (and
              (and
                (=
                  ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@164@04))
                  ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@165@04)))
                (< i2@165@04 V@28@04))
              (<= 0 i2@165@04))
            (< i1@164@04 V@28@04))
          (<= 0 i1@164@04))
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@164@04))
            ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@165@04)))
          (< i2@165@04 V@28@04)
          (<= 0 i2@165@04)
          (< i1@164@04 V@28@04)
          (<= 0 i1@164@04))))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@165@04))
    :qid |prog.l<no position>-aux|))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@164@04))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 12
(pop) ; 11
; Joined path conditions
(assert (implies
  (= exc@123@04 $Ref.null)
  (forall ((i1@164@04 Int)) (!
    (forall ((i2@165@04 Int)) (!
      (and
        (implies
          (<= 0 i1@164@04)
          (and
            (<= 0 i1@164@04)
            (implies
              (< i1@164@04 V@28@04)
              (and
                (< i1@164@04 V@28@04)
                (implies
                  (<= 0 i2@165@04)
                  (and
                    (<= 0 i2@165@04)
                    (implies
                      (< i2@165@04 V@28@04)
                      (and
                        (< i2@165@04 V@28@04)
                        (<
                          i1@164@04
                          (alen<Int> (opt_get1 $Snap.unit source@26@04)))
                        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
                          $Snap.unit
                          $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@164@04)) (aloc ($Snap.combine
                          $Snap.unit
                          $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@164@04))
                        (<
                          i2@165@04
                          (alen<Int> (opt_get1 $Snap.unit source@26@04)))
                        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
                          $Snap.unit
                          $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@165@04)) (aloc ($Snap.combine
                          $Snap.unit
                          $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@165@04))))))))))
        (implies
          (and
            (and
              (and
                (and
                  (=
                    ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@164@04))
                    ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@165@04)))
                  (< i2@165@04 V@28@04))
                (<= 0 i2@165@04))
              (< i1@164@04 V@28@04))
            (<= 0 i1@164@04))
          (and
            (=
              ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@164@04))
              ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@165@04)))
            (< i2@165@04 V@28@04)
            (<= 0 i2@165@04)
            (< i1@164@04 V@28@04)
            (<= 0 i1@164@04))))
      :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@165@04))
      :qid |prog.l<no position>-aux|))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@164@04))
    :qid |prog.l<no position>-aux|))))
(push) ; 11
(assert (not (implies
  (= exc@123@04 $Ref.null)
  (forall ((i1@164@04 Int)) (!
    (forall ((i2@165@04 Int)) (!
      (implies
        (and
          (and
            (and
              (and
                (=
                  ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@164@04))
                  ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@165@04)))
                (< i2@165@04 V@28@04))
              (<= 0 i2@165@04))
            (< i1@164@04 V@28@04))
          (<= 0 i1@164@04))
        (= i1@164@04 i2@165@04))
      :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@165@04))
      :qid |prog.l<no position>|))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@164@04))
    :qid |prog.l<no position>|)))))
(check-sat)
; unsat
(pop) ; 11
; 0.02s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               25965
;  :arith-add-rows          21051
;  :arith-assert-diseq      1539
;  :arith-assert-lower      8277
;  :arith-assert-upper      5072
;  :arith-bound-prop        1897
;  :arith-conflicts         594
;  :arith-eq-adapter        5256
;  :arith-fixed-eqs         2468
;  :arith-grobner           98
;  :arith-max-min           785
;  :arith-nonlinear-bounds  68
;  :arith-nonlinear-horner  80
;  :arith-offset-eqs        2608
;  :arith-pivots            3982
;  :conflicts               1485
;  :datatype-accessor-ax    82
;  :datatype-constructor-ax 738
;  :datatype-occurs-check   294
;  :datatype-splits         210
;  :decisions               4446
;  :del-clause              31888
;  :final-checks            225
;  :interface-eqs           15
;  :max-generation          9
;  :max-memory              8.06
;  :memory                  8.00
;  :minimized-lits          177
;  :mk-bool-var             43208
;  :mk-clause               31897
;  :num-allocs              450584
;  :num-checks              295
;  :propagations            18342
;  :quant-instantiations    9160
;  :rlimit-count            1356684
;  :time                    0.02)
(assert (implies
  (= exc@123@04 $Ref.null)
  (forall ((i1@164@04 Int)) (!
    (forall ((i2@165@04 Int)) (!
      (implies
        (and
          (and
            (and
              (and
                (=
                  ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@164@04))
                  ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@165@04)))
                (< i2@165@04 V@28@04))
              (<= 0 i2@165@04))
            (< i1@164@04 V@28@04))
          (<= 0 i1@164@04))
        (= i1@164@04 i2@165@04))
      :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@165@04))
      :qid |prog.l<no position>|))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@164@04))
    :qid |prog.l<no position>|))))
; [eval] exc == null ==> target != (None(): option[array])
; [eval] exc == null
(push) ; 11
(set-option :timeout 10)
(push) ; 12
(assert (not (not (= exc@123@04 $Ref.null))))
(check-sat)
; unknown
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               26002
;  :arith-add-rows          21051
;  :arith-assert-diseq      1539
;  :arith-assert-lower      8292
;  :arith-assert-upper      5080
;  :arith-bound-prop        1897
;  :arith-conflicts         594
;  :arith-eq-adapter        5256
;  :arith-fixed-eqs         2468
;  :arith-grobner           103
;  :arith-max-min           811
;  :arith-nonlinear-bounds  71
;  :arith-nonlinear-horner  84
;  :arith-offset-eqs        2608
;  :arith-pivots            3982
;  :conflicts               1485
;  :datatype-accessor-ax    82
;  :datatype-constructor-ax 746
;  :datatype-occurs-check   299
;  :datatype-splits         214
;  :decisions               4454
;  :del-clause              31888
;  :final-checks            229
;  :interface-eqs           15
;  :max-generation          9
;  :max-memory              8.06
;  :memory                  8.01
;  :minimized-lits          177
;  :mk-bool-var             43213
;  :mk-clause               31897
;  :num-allocs              451764
;  :num-checks              296
;  :propagations            18342
;  :quant-instantiations    9160
;  :rlimit-count            1358581
;  :time                    0.00)
; [then-branch: 196 | exc@123@04 == Null | live]
; [else-branch: 196 | exc@123@04 != Null | dead]
(push) ; 12
; [then-branch: 196 | exc@123@04 == Null]
; [eval] target != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 12
(pop) ; 11
; Joined path conditions
(set-option :timeout 0)
(push) ; 11
(assert (not (implies
  (= exc@123@04 $Ref.null)
  (not (= target@27@04 (as None<option<array>>  option<array>))))))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               26002
;  :arith-add-rows          21051
;  :arith-assert-diseq      1539
;  :arith-assert-lower      8292
;  :arith-assert-upper      5080
;  :arith-bound-prop        1897
;  :arith-conflicts         594
;  :arith-eq-adapter        5256
;  :arith-fixed-eqs         2468
;  :arith-grobner           103
;  :arith-max-min           811
;  :arith-nonlinear-bounds  71
;  :arith-nonlinear-horner  84
;  :arith-offset-eqs        2608
;  :arith-pivots            3982
;  :conflicts               1485
;  :datatype-accessor-ax    82
;  :datatype-constructor-ax 746
;  :datatype-occurs-check   299
;  :datatype-splits         214
;  :decisions               4454
;  :del-clause              31888
;  :final-checks            229
;  :interface-eqs           15
;  :max-generation          9
;  :max-memory              8.06
;  :memory                  8.01
;  :minimized-lits          177
;  :mk-bool-var             43213
;  :mk-clause               31897
;  :num-allocs              451789
;  :num-checks              297
;  :propagations            18342
;  :quant-instantiations    9160
;  :rlimit-count            1358601)
(assert (implies
  (= exc@123@04 $Ref.null)
  (not (= target@27@04 (as None<option<array>>  option<array>)))))
; [eval] exc == null ==> alen(opt_get1(target)) == V
; [eval] exc == null
(push) ; 11
(set-option :timeout 10)
(push) ; 12
(assert (not (not (= exc@123@04 $Ref.null))))
(check-sat)
; unknown
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               26039
;  :arith-add-rows          21051
;  :arith-assert-diseq      1539
;  :arith-assert-lower      8292
;  :arith-assert-upper      5080
;  :arith-bound-prop        1897
;  :arith-conflicts         594
;  :arith-eq-adapter        5256
;  :arith-fixed-eqs         2468
;  :arith-grobner           103
;  :arith-max-min           811
;  :arith-nonlinear-bounds  71
;  :arith-nonlinear-horner  84
;  :arith-offset-eqs        2608
;  :arith-pivots            3982
;  :conflicts               1485
;  :datatype-accessor-ax    82
;  :datatype-constructor-ax 754
;  :datatype-occurs-check   304
;  :datatype-splits         218
;  :decisions               4462
;  :del-clause              31888
;  :final-checks            231
;  :interface-eqs           15
;  :max-generation          9
;  :max-memory              8.06
;  :memory                  8.01
;  :minimized-lits          177
;  :mk-bool-var             43217
;  :mk-clause               31897
;  :num-allocs              452440
;  :num-checks              298
;  :propagations            18342
;  :quant-instantiations    9160
;  :rlimit-count            1359409)
; [then-branch: 197 | exc@123@04 == Null | live]
; [else-branch: 197 | exc@123@04 != Null | dead]
(push) ; 12
; [then-branch: 197 | exc@123@04 == Null]
; [eval] alen(opt_get1(target)) == V
; [eval] alen(opt_get1(target))
; [eval] opt_get1(target)
(push) ; 13
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 13
; Joined path conditions
(pop) ; 12
(pop) ; 11
; Joined path conditions
(set-option :timeout 0)
(push) ; 11
(assert (not (implies
  (= exc@123@04 $Ref.null)
  (= (alen<Int> (opt_get1 $Snap.unit target@27@04)) V@28@04))))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               26039
;  :arith-add-rows          21051
;  :arith-assert-diseq      1539
;  :arith-assert-lower      8292
;  :arith-assert-upper      5080
;  :arith-bound-prop        1897
;  :arith-conflicts         594
;  :arith-eq-adapter        5256
;  :arith-fixed-eqs         2468
;  :arith-grobner           103
;  :arith-max-min           811
;  :arith-nonlinear-bounds  71
;  :arith-nonlinear-horner  84
;  :arith-offset-eqs        2608
;  :arith-pivots            3982
;  :conflicts               1485
;  :datatype-accessor-ax    82
;  :datatype-constructor-ax 754
;  :datatype-occurs-check   304
;  :datatype-splits         218
;  :decisions               4462
;  :del-clause              31888
;  :final-checks            231
;  :interface-eqs           15
;  :max-generation          9
;  :max-memory              8.06
;  :memory                  8.01
;  :minimized-lits          177
;  :mk-bool-var             43217
;  :mk-clause               31897
;  :num-allocs              452459
;  :num-checks              299
;  :propagations            18342
;  :quant-instantiations    9160
;  :rlimit-count            1359434)
(assert (implies
  (= exc@123@04 $Ref.null)
  (= (alen<Int> (opt_get1 $Snap.unit target@27@04)) V@28@04)))
; [eval] exc == null
(set-option :timeout 10)
(push) ; 11
(assert (not (not (= exc@123@04 $Ref.null))))
(check-sat)
; unknown
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               26076
;  :arith-add-rows          21051
;  :arith-assert-diseq      1539
;  :arith-assert-lower      8292
;  :arith-assert-upper      5080
;  :arith-bound-prop        1897
;  :arith-conflicts         594
;  :arith-eq-adapter        5256
;  :arith-fixed-eqs         2468
;  :arith-grobner           103
;  :arith-max-min           811
;  :arith-nonlinear-bounds  71
;  :arith-nonlinear-horner  84
;  :arith-offset-eqs        2608
;  :arith-pivots            3982
;  :conflicts               1485
;  :datatype-accessor-ax    82
;  :datatype-constructor-ax 762
;  :datatype-occurs-check   309
;  :datatype-splits         222
;  :decisions               4470
;  :del-clause              31888
;  :final-checks            233
;  :interface-eqs           15
;  :max-generation          9
;  :max-memory              8.06
;  :memory                  8.01
;  :minimized-lits          177
;  :mk-bool-var             43221
;  :mk-clause               31897
;  :num-allocs              453110
;  :num-checks              300
;  :propagations            18342
;  :quant-instantiations    9160
;  :rlimit-count            1360237)
; [then-branch: 198 | exc@123@04 == Null | live]
; [else-branch: 198 | exc@123@04 != Null | dead]
(push) ; 11
; [then-branch: 198 | exc@123@04 == Null]
(declare-const i1@166@04 Int)
(push) ; 12
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 13
; [then-branch: 199 | 0 <= i1@166@04 | live]
; [else-branch: 199 | !(0 <= i1@166@04) | live]
(push) ; 14
; [then-branch: 199 | 0 <= i1@166@04]
(assert (<= 0 i1@166@04))
; [eval] i1 < V
(pop) ; 14
(push) ; 14
; [else-branch: 199 | !(0 <= i1@166@04)]
(assert (not (<= 0 i1@166@04)))
(pop) ; 14
(pop) ; 13
; Joined path conditions
; Joined path conditions
(assert (and (< i1@166@04 V@28@04) (<= 0 i1@166@04)))
(declare-const $k@167@04 $Perm)
(assert ($Perm.isReadVar $k@167@04 $Perm.Write))
; [eval] aloc(opt_get1(target), i1)
; [eval] opt_get1(target)
(push) ; 13
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 13
; Joined path conditions
(push) ; 13
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 14
(assert (not (< i1@166@04 (alen<Int> (opt_get1 $Snap.unit target@27@04)))))
(check-sat)
; unsat
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               26076
;  :arith-add-rows          21051
;  :arith-assert-diseq      1540
;  :arith-assert-lower      8296
;  :arith-assert-upper      5081
;  :arith-bound-prop        1897
;  :arith-conflicts         594
;  :arith-eq-adapter        5257
;  :arith-fixed-eqs         2468
;  :arith-grobner           103
;  :arith-max-min           811
;  :arith-nonlinear-bounds  71
;  :arith-nonlinear-horner  84
;  :arith-offset-eqs        2608
;  :arith-pivots            3983
;  :conflicts               1485
;  :datatype-accessor-ax    82
;  :datatype-constructor-ax 762
;  :datatype-occurs-check   309
;  :datatype-splits         222
;  :decisions               4470
;  :del-clause              31888
;  :final-checks            233
;  :interface-eqs           15
;  :max-generation          9
;  :max-memory              8.06
;  :memory                  8.01
;  :minimized-lits          177
;  :mk-bool-var             43227
;  :mk-clause               31899
;  :num-allocs              453275
;  :num-checks              301
;  :propagations            18343
;  :quant-instantiations    9160
;  :rlimit-count            1360568)
(assert (< i1@166@04 (alen<Int> (opt_get1 $Snap.unit target@27@04))))
(pop) ; 13
; Joined path conditions
(assert (< i1@166@04 (alen<Int> (opt_get1 $Snap.unit target@27@04))))
(pop) ; 12
(declare-fun inv@168@04 ($Ref) Int)
; Nested auxiliary terms: globals
(assert ($Perm.isReadVar $k@167@04 $Perm.Write))
; Nested auxiliary terms: non-globals
(assert (forall ((i1@166@04 Int)) (!
  (< i1@166@04 (alen<Int> (opt_get1 $Snap.unit target@27@04)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@166@04))
  :qid |option$array$-aux|)))
(push) ; 12
(assert (not (forall ((i1@166@04 Int)) (!
  (implies
    (and (< i1@166@04 V@28@04) (<= 0 i1@166@04))
    (or (= $k@167@04 $Perm.No) (< $Perm.No $k@167@04)))
  
  ))))
(check-sat)
; unsat
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               26076
;  :arith-add-rows          21051
;  :arith-assert-diseq      1541
;  :arith-assert-lower      8298
;  :arith-assert-upper      5082
;  :arith-bound-prop        1897
;  :arith-conflicts         594
;  :arith-eq-adapter        5258
;  :arith-fixed-eqs         2468
;  :arith-grobner           103
;  :arith-max-min           811
;  :arith-nonlinear-bounds  71
;  :arith-nonlinear-horner  84
;  :arith-offset-eqs        2608
;  :arith-pivots            3984
;  :conflicts               1486
;  :datatype-accessor-ax    82
;  :datatype-constructor-ax 762
;  :datatype-occurs-check   309
;  :datatype-splits         222
;  :decisions               4470
;  :del-clause              31890
;  :final-checks            233
;  :interface-eqs           15
;  :max-generation          9
;  :max-memory              8.06
;  :memory                  8.01
;  :minimized-lits          177
;  :mk-bool-var             43234
;  :mk-clause               31901
;  :num-allocs              453698
;  :num-checks              302
;  :propagations            18344
;  :quant-instantiations    9160
;  :rlimit-count            1361116)
(declare-const sm@169@04 $FVF<option<array>>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (-
          (ite
            (and (< (inv@34@04 r) V@28@04) (<= 0 (inv@34@04 r)))
            $k@33@04
            $Perm.No)
          (pTaken@96@04 r))
        (pTaken@105@04 r)))
    (=
      ($FVF.lookup_option$array$ (as sm@169@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@31@04))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@169@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@31@04))))) r))
  :qid |qp.fvfValDef50|)))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (-
          (ite
            (and (< (inv@42@04 r) V@28@04) (<= 0 (inv@42@04 r)))
            $k@41@04
            $Perm.No)
          (pTaken@95@04 r))
        (pTaken@106@04 r)))
    (=
      ($FVF.lookup_option$array$ (as sm@169@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@31@04))))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@169@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@31@04))))))))))) r))
  :qid |qp.fvfValDef51|)))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (ite
          (and (< (inv@128@04 r) V@28@04) (<= 0 (inv@128@04 r)))
          (*
            (scale $Snap.unit (* (to_real (* V@28@04 V@28@04)) $Perm.Write))
            $k@127@04)
          $Perm.No)
        (pTaken@159@04 r)))
    (=
      ($FVF.lookup_option$array$ (as sm@169@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@125@04))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@169@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@125@04))))) r))
  :qid |qp.fvfValDef52|)))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (ite
          (and (< (inv@136@04 r) V@28@04) (<= 0 (inv@136@04 r)))
          (*
            (scale $Snap.unit (* (to_real (* V@28@04 V@28@04)) $Perm.Write))
            $k@135@04)
          $Perm.No)
        (pTaken@158@04 r)))
    (=
      ($FVF.lookup_option$array$ (as sm@169@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@04))))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@169@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@04))))))))))) r))
  :qid |qp.fvfValDef53|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@31@04))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@31@04))))))))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@125@04))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@04))))))))))) r) r))
  :pattern (($FVF.lookup_option$array$ (as sm@169@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef54|)))
; Check receiver injectivity
(push) ; 12
(assert (not (forall ((i11@166@04 Int) (i12@166@04 Int)) (!
  (implies
    (and
      (and
        (and
          (and (< i11@166@04 V@28@04) (<= 0 i11@166@04))
          ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@169@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@27@04) i11@166@04)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@27@04) i11@166@04)))
        (< $Perm.No $k@167@04))
      (and
        (and
          (and (< i12@166@04 V@28@04) (<= 0 i12@166@04))
          ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@169@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@27@04) i12@166@04)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@27@04) i12@166@04)))
        (< $Perm.No $k@167@04))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i11@166@04)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i12@166@04)))
    (= i11@166@04 i12@166@04))
  
  :qid |option$array$-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               26087
;  :arith-add-rows          21055
;  :arith-assert-diseq      1542
;  :arith-assert-lower      8302
;  :arith-assert-upper      5082
;  :arith-bound-prop        1897
;  :arith-conflicts         594
;  :arith-eq-adapter        5259
;  :arith-fixed-eqs         2468
;  :arith-grobner           103
;  :arith-max-min           811
;  :arith-nonlinear-bounds  71
;  :arith-nonlinear-horner  84
;  :arith-offset-eqs        2608
;  :arith-pivots            3986
;  :conflicts               1487
;  :datatype-accessor-ax    82
;  :datatype-constructor-ax 762
;  :datatype-occurs-check   309
;  :datatype-splits         222
;  :decisions               4470
;  :del-clause              31963
;  :final-checks            233
;  :interface-eqs           15
;  :max-generation          9
;  :max-memory              8.06
;  :memory                  8.00
;  :minimized-lits          177
;  :mk-bool-var             43339
;  :mk-clause               31974
;  :num-allocs              455868
;  :num-checks              303
;  :propagations            18348
;  :quant-instantiations    9185
;  :rlimit-count            1368313
;  :time                    0.00)
; Definitional axioms for inverse functions
(assert (forall ((i1@166@04 Int)) (!
  (implies
    (and (and (< i1@166@04 V@28@04) (<= 0 i1@166@04)) (< $Perm.No $k@167@04))
    (=
      (inv@168@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@166@04))
      i1@166@04))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@166@04))
  :qid |option$array$-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and (< (inv@168@04 r) V@28@04) (<= 0 (inv@168@04 r)))
      (< $Perm.No $k@167@04))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) (inv@168@04 r))
      r))
  :pattern ((inv@168@04 r))
  :qid |option$array$-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@168@04 r) V@28@04) (<= 0 (inv@168@04 r)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@169@04  $FVF<option<array>>) r) r))
  :pattern ((inv@168@04 r))
  )))
; Precomputing data for removing quantified permissions
(define-fun pTaken@170@04 ((r $Ref)) $Perm
  (ite
    (and (< (inv@168@04 r) V@28@04) (<= 0 (inv@168@04 r)))
    ($Perm.min
      (-
        (-
          (ite
            (and (< (inv@34@04 r) V@28@04) (<= 0 (inv@34@04 r)))
            $k@33@04
            $Perm.No)
          (pTaken@96@04 r))
        (pTaken@105@04 r))
      $k@167@04)
    $Perm.No))
(define-fun pTaken@171@04 ((r $Ref)) $Perm
  (ite
    (and (< (inv@168@04 r) V@28@04) (<= 0 (inv@168@04 r)))
    ($Perm.min
      (-
        (-
          (ite
            (and (< (inv@42@04 r) V@28@04) (<= 0 (inv@42@04 r)))
            $k@41@04
            $Perm.No)
          (pTaken@95@04 r))
        (pTaken@106@04 r))
      (- $k@167@04 (pTaken@170@04 r)))
    $Perm.No))
(define-fun pTaken@172@04 ((r $Ref)) $Perm
  (ite
    (and (< (inv@168@04 r) V@28@04) (<= 0 (inv@168@04 r)))
    ($Perm.min
      (-
        (ite
          (and (< (inv@128@04 r) V@28@04) (<= 0 (inv@128@04 r)))
          (*
            (scale $Snap.unit (* (to_real (* V@28@04 V@28@04)) $Perm.Write))
            $k@127@04)
          $Perm.No)
        (pTaken@159@04 r))
      (- (- $k@167@04 (pTaken@170@04 r)) (pTaken@171@04 r)))
    $Perm.No))
(define-fun pTaken@173@04 ((r $Ref)) $Perm
  (ite
    (and (< (inv@168@04 r) V@28@04) (<= 0 (inv@168@04 r)))
    ($Perm.min
      (-
        (ite
          (and (< (inv@136@04 r) V@28@04) (<= 0 (inv@136@04 r)))
          (*
            (scale $Snap.unit (* (to_real (* V@28@04 V@28@04)) $Perm.Write))
            $k@135@04)
          $Perm.No)
        (pTaken@158@04 r))
      (- (- (- $k@167@04 (pTaken@170@04 r)) (pTaken@171@04 r)) (pTaken@172@04 r)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Constrain original permissions $k@167@04
(assert (forall ((r $Ref)) (!
  (implies
    (not
      (=
        (-
          (-
            (ite
              (and (< (inv@34@04 r) V@28@04) (<= 0 (inv@34@04 r)))
              $k@33@04
              $Perm.No)
            (pTaken@96@04 r))
          (pTaken@105@04 r))
        $Perm.No))
    (<
      (ite
        (and (< (inv@168@04 r) V@28@04) (<= 0 (inv@168@04 r)))
        $k@167@04
        $Perm.No)
      (-
        (-
          (ite
            (and (< (inv@34@04 r) V@28@04) (<= 0 (inv@34@04 r)))
            $k@33@04
            $Perm.No)
          (pTaken@96@04 r))
        (pTaken@105@04 r))))
  :pattern ((inv@34@04 r))
  :pattern ((inv@168@04 r))
  :qid |qp.srp55|)))
; Intermediate check if already taken enough permissions
(set-option :timeout 500)
(push) ; 12
(assert (not (forall ((r $Ref)) (!
  (implies
    (and (< (inv@168@04 r) V@28@04) (<= 0 (inv@168@04 r)))
    (= (- $k@167@04 (pTaken@170@04 r)) $Perm.No))
  
  ))))
(check-sat)
; unknown
(pop) ; 12
; 0.02s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               27201
;  :arith-add-rows          21581
;  :arith-assert-diseq      1574
;  :arith-assert-lower      8582
;  :arith-assert-upper      5291
;  :arith-bound-prop        1941
;  :arith-conflicts         611
;  :arith-eq-adapter        5404
;  :arith-fixed-eqs         2556
;  :arith-gcd-tests         1
;  :arith-grobner           103
;  :arith-ineq-splits       1
;  :arith-max-min           966
;  :arith-nonlinear-bounds  86
;  :arith-nonlinear-horner  84
;  :arith-offset-eqs        2693
;  :arith-patches           1
;  :arith-pivots            4133
;  :conflicts               1516
;  :datatype-accessor-ax    102
;  :datatype-constructor-ax 833
;  :datatype-occurs-check   370
;  :datatype-splits         287
;  :decisions               4773
;  :del-clause              33013
;  :final-checks            266
;  :interface-eqs           25
;  :max-generation          9
;  :max-memory              8.66
;  :memory                  8.37
;  :minimized-lits          178
;  :mk-bool-var             44753
;  :mk-clause               33022
;  :num-allocs              464822
;  :num-checks              305
;  :propagations            18925
;  :quant-instantiations    9531
;  :rlimit-count            1406172
;  :time                    0.02)
; Constrain original permissions $k@167@04
(assert (forall ((r $Ref)) (!
  (implies
    (not
      (=
        (-
          (-
            (ite
              (and (< (inv@42@04 r) V@28@04) (<= 0 (inv@42@04 r)))
              $k@41@04
              $Perm.No)
            (pTaken@95@04 r))
          (pTaken@106@04 r))
        $Perm.No))
    (<
      (ite
        (and (< (inv@168@04 r) V@28@04) (<= 0 (inv@168@04 r)))
        $k@167@04
        $Perm.No)
      (-
        (-
          (ite
            (and (< (inv@42@04 r) V@28@04) (<= 0 (inv@42@04 r)))
            $k@41@04
            $Perm.No)
          (pTaken@95@04 r))
        (pTaken@106@04 r))))
  :pattern ((inv@42@04 r))
  :pattern ((inv@168@04 r))
  :qid |qp.srp56|)))
; Intermediate check if already taken enough permissions
(push) ; 12
(assert (not (forall ((r $Ref)) (!
  (implies
    (and (< (inv@168@04 r) V@28@04) (<= 0 (inv@168@04 r)))
    (= (- (- $k@167@04 (pTaken@170@04 r)) (pTaken@171@04 r)) $Perm.No))
  
  ))))
(check-sat)
; unsat
(pop) ; 12
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               28019
;  :arith-add-rows          22599
;  :arith-assert-diseq      1648
;  :arith-assert-lower      8817
;  :arith-assert-upper      5513
;  :arith-bound-prop        2002
;  :arith-conflicts         633
;  :arith-eq-adapter        5615
;  :arith-fixed-eqs         2648
;  :arith-gcd-tests         1
;  :arith-grobner           103
;  :arith-ineq-splits       1
;  :arith-max-min           966
;  :arith-nonlinear-bounds  86
;  :arith-nonlinear-horner  84
;  :arith-offset-eqs        2793
;  :arith-patches           1
;  :arith-pivots            4274
;  :conflicts               1565
;  :datatype-accessor-ax    102
;  :datatype-constructor-ax 837
;  :datatype-occurs-check   370
;  :datatype-splits         287
;  :decisions               4876
;  :del-clause              33867
;  :final-checks            266
;  :interface-eqs           25
;  :max-generation          9
;  :max-memory              8.66
;  :memory                  8.36
;  :minimized-lits          208
;  :mk-bool-var             45951
;  :mk-clause               33876
;  :num-allocs              470452
;  :num-checks              306
;  :propagations            19551
;  :quant-instantiations    9762
;  :rlimit-count            1445981
;  :time                    0.01)
; Final check if taken enough permissions
; Done removing quantified permissions
; Definitional axioms for snapshot map values
; [eval] exc == null ==> (forall i1: Int :: { aloc(opt_get1(target), i1) } 0 <= i1 && i1 < V ==> aloc(opt_get1(target), i1).option$array$ != (None(): option[array]))
; [eval] exc == null
(push) ; 12
(set-option :timeout 10)
(push) ; 13
(assert (not (not (= exc@123@04 $Ref.null))))
(check-sat)
; unknown
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               28056
;  :arith-add-rows          22599
;  :arith-assert-diseq      1648
;  :arith-assert-lower      8832
;  :arith-assert-upper      5521
;  :arith-bound-prop        2002
;  :arith-conflicts         633
;  :arith-eq-adapter        5615
;  :arith-fixed-eqs         2648
;  :arith-gcd-tests         1
;  :arith-grobner           108
;  :arith-ineq-splits       1
;  :arith-max-min           992
;  :arith-nonlinear-bounds  89
;  :arith-nonlinear-horner  88
;  :arith-offset-eqs        2793
;  :arith-patches           1
;  :arith-pivots            4274
;  :conflicts               1565
;  :datatype-accessor-ax    102
;  :datatype-constructor-ax 845
;  :datatype-occurs-check   375
;  :datatype-splits         291
;  :decisions               4884
;  :del-clause              33867
;  :final-checks            270
;  :interface-eqs           25
;  :max-generation          9
;  :max-memory              8.66
;  :memory                  8.36
;  :minimized-lits          208
;  :mk-bool-var             45955
;  :mk-clause               33876
;  :num-allocs              471310
;  :num-checks              307
;  :propagations            19551
;  :quant-instantiations    9762
;  :rlimit-count            1447356
;  :time                    0.00)
; [then-branch: 200 | exc@123@04 == Null | live]
; [else-branch: 200 | exc@123@04 != Null | dead]
(push) ; 13
; [then-branch: 200 | exc@123@04 == Null]
; [eval] (forall i1: Int :: { aloc(opt_get1(target), i1) } 0 <= i1 && i1 < V ==> aloc(opt_get1(target), i1).option$array$ != (None(): option[array]))
(declare-const i1@174@04 Int)
(push) ; 14
; [eval] 0 <= i1 && i1 < V ==> aloc(opt_get1(target), i1).option$array$ != (None(): option[array])
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 15
; [then-branch: 201 | 0 <= i1@174@04 | live]
; [else-branch: 201 | !(0 <= i1@174@04) | live]
(push) ; 16
; [then-branch: 201 | 0 <= i1@174@04]
(assert (<= 0 i1@174@04))
; [eval] i1 < V
(pop) ; 16
(push) ; 16
; [else-branch: 201 | !(0 <= i1@174@04)]
(assert (not (<= 0 i1@174@04)))
(pop) ; 16
(pop) ; 15
; Joined path conditions
; Joined path conditions
(push) ; 15
; [then-branch: 202 | i1@174@04 < V@28@04 && 0 <= i1@174@04 | live]
; [else-branch: 202 | !(i1@174@04 < V@28@04 && 0 <= i1@174@04) | live]
(push) ; 16
; [then-branch: 202 | i1@174@04 < V@28@04 && 0 <= i1@174@04]
(assert (and (< i1@174@04 V@28@04) (<= 0 i1@174@04)))
; [eval] aloc(opt_get1(target), i1).option$array$ != (None(): option[array])
; [eval] aloc(opt_get1(target), i1)
; [eval] opt_get1(target)
(push) ; 17
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 17
; Joined path conditions
(push) ; 17
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 18
(assert (not (< i1@174@04 (alen<Int> (opt_get1 $Snap.unit target@27@04)))))
(check-sat)
; unsat
(pop) ; 18
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               28056
;  :arith-add-rows          22599
;  :arith-assert-diseq      1648
;  :arith-assert-lower      8834
;  :arith-assert-upper      5521
;  :arith-bound-prop        2002
;  :arith-conflicts         633
;  :arith-eq-adapter        5615
;  :arith-fixed-eqs         2648
;  :arith-gcd-tests         1
;  :arith-grobner           108
;  :arith-ineq-splits       1
;  :arith-max-min           992
;  :arith-nonlinear-bounds  89
;  :arith-nonlinear-horner  88
;  :arith-offset-eqs        2793
;  :arith-patches           1
;  :arith-pivots            4274
;  :conflicts               1565
;  :datatype-accessor-ax    102
;  :datatype-constructor-ax 845
;  :datatype-occurs-check   375
;  :datatype-splits         291
;  :decisions               4884
;  :del-clause              33867
;  :final-checks            270
;  :interface-eqs           25
;  :max-generation          9
;  :max-memory              8.66
;  :memory                  8.36
;  :minimized-lits          208
;  :mk-bool-var             45957
;  :mk-clause               33876
;  :num-allocs              471414
;  :num-checks              308
;  :propagations            19551
;  :quant-instantiations    9762
;  :rlimit-count            1447551)
(assert (< i1@174@04 (alen<Int> (opt_get1 $Snap.unit target@27@04))))
(pop) ; 17
; Joined path conditions
(assert (< i1@174@04 (alen<Int> (opt_get1 $Snap.unit target@27@04))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@174@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@174@04)))
(push) ; 17
(assert (not (<
  $Perm.No
  (+
    (+
      (+
        (ite
          (and
            (<
              (inv@136@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@174@04))
              V@28@04)
            (<=
              0
              (inv@136@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@174@04))))
          (*
            (scale $Snap.unit (* (to_real (* V@28@04 V@28@04)) $Perm.Write))
            $k@135@04)
          $Perm.No)
        (ite
          (and
            (<
              (inv@128@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@174@04))
              V@28@04)
            (<=
              0
              (inv@128@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@174@04))))
          (*
            (scale $Snap.unit (* (to_real (* V@28@04 V@28@04)) $Perm.Write))
            $k@127@04)
          $Perm.No))
      (-
        (-
          (ite
            (and
              (<
                (inv@42@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@174@04))
                V@28@04)
              (<=
                0
                (inv@42@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@174@04))))
            $k@41@04
            $Perm.No)
          (pTaken@95@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@174@04)))
        (pTaken@106@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@174@04))))
    (-
      (-
        (ite
          (and
            (<
              (inv@34@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@174@04))
              V@28@04)
            (<=
              0
              (inv@34@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@174@04))))
          $k@33@04
          $Perm.No)
        (pTaken@96@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@174@04)))
      (pTaken@105@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@174@04)))))))
(check-sat)
; unsat
(pop) ; 17
; 0.02s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               29249
;  :arith-add-rows          23735
;  :arith-assert-diseq      1703
;  :arith-assert-lower      9194
;  :arith-assert-upper      5772
;  :arith-bound-prop        2102
;  :arith-conflicts         656
;  :arith-eq-adapter        5854
;  :arith-fixed-eqs         2795
;  :arith-gcd-tests         1
;  :arith-grobner           108
;  :arith-ineq-splits       1
;  :arith-max-min           992
;  :arith-nonlinear-bounds  89
;  :arith-nonlinear-horner  88
;  :arith-offset-eqs        2949
;  :arith-patches           1
;  :arith-pivots            4425
;  :conflicts               1611
;  :datatype-accessor-ax    102
;  :datatype-constructor-ax 849
;  :datatype-occurs-check   375
;  :datatype-splits         291
;  :decisions               5016
;  :del-clause              34831
;  :final-checks            270
;  :interface-eqs           25
;  :max-generation          9
;  :max-memory              8.66
;  :memory                  8.41
;  :minimized-lits          208
;  :mk-bool-var             47591
;  :mk-clause               35005
;  :num-allocs              478619
;  :num-checks              309
;  :propagations            20401
;  :quant-instantiations    10106
;  :rlimit-count            1499689
;  :time                    0.01)
; [eval] (None(): option[array])
(pop) ; 16
(push) ; 16
; [else-branch: 202 | !(i1@174@04 < V@28@04 && 0 <= i1@174@04)]
(assert (not (and (< i1@174@04 V@28@04) (<= 0 i1@174@04))))
(pop) ; 16
(pop) ; 15
; Joined path conditions
(assert (implies
  (and (< i1@174@04 V@28@04) (<= 0 i1@174@04))
  (and
    (< i1@174@04 V@28@04)
    (<= 0 i1@174@04)
    (< i1@174@04 (alen<Int> (opt_get1 $Snap.unit target@27@04)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@174@04)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@174@04)))))
; Joined path conditions
(pop) ; 14
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@174@04 Int)) (!
  (implies
    (and (< i1@174@04 V@28@04) (<= 0 i1@174@04))
    (and
      (< i1@174@04 V@28@04)
      (<= 0 i1@174@04)
      (< i1@174@04 (alen<Int> (opt_get1 $Snap.unit target@27@04)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@174@04)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@174@04))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@174@04))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 13
(pop) ; 12
; Joined path conditions
(assert (implies
  (= exc@123@04 $Ref.null)
  (forall ((i1@174@04 Int)) (!
    (implies
      (and (< i1@174@04 V@28@04) (<= 0 i1@174@04))
      (and
        (< i1@174@04 V@28@04)
        (<= 0 i1@174@04)
        (< i1@174@04 (alen<Int> (opt_get1 $Snap.unit target@27@04)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@174@04)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@174@04))))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@174@04))
    :qid |prog.l<no position>-aux|))))
(push) ; 12
(assert (not (implies
  (= exc@123@04 $Ref.null)
  (forall ((i1@174@04 Int)) (!
    (implies
      (and (< i1@174@04 V@28@04) (<= 0 i1@174@04))
      (not
        (=
          ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@174@04))
          (as None<option<array>>  option<array>))))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@174@04))
    :qid |prog.l<no position>|)))))
(check-sat)
; unsat
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               29256
;  :arith-add-rows          23781
;  :arith-assert-diseq      1703
;  :arith-assert-lower      9197
;  :arith-assert-upper      5772
;  :arith-bound-prop        2103
;  :arith-conflicts         656
;  :arith-eq-adapter        5860
;  :arith-fixed-eqs         2795
;  :arith-gcd-tests         1
;  :arith-grobner           108
;  :arith-ineq-splits       1
;  :arith-max-min           992
;  :arith-nonlinear-bounds  89
;  :arith-nonlinear-horner  88
;  :arith-offset-eqs        2950
;  :arith-patches           1
;  :arith-pivots            4444
;  :conflicts               1612
;  :datatype-accessor-ax    102
;  :datatype-constructor-ax 849
;  :datatype-occurs-check   375
;  :datatype-splits         291
;  :decisions               5016
;  :del-clause              35125
;  :final-checks            270
;  :interface-eqs           25
;  :max-generation          9
;  :max-memory              8.66
;  :memory                  8.39
;  :minimized-lits          208
;  :mk-bool-var             47743
;  :mk-clause               35134
;  :num-allocs              479863
;  :num-checks              310
;  :propagations            20405
;  :quant-instantiations    10159
;  :rlimit-count            1504354
;  :time                    0.00)
(assert (implies
  (= exc@123@04 $Ref.null)
  (forall ((i1@174@04 Int)) (!
    (implies
      (and (< i1@174@04 V@28@04) (<= 0 i1@174@04))
      (not
        (=
          ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@174@04))
          (as None<option<array>>  option<array>))))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@174@04))
    :qid |prog.l<no position>|))))
; [eval] exc == null ==> (forall i1: Int :: { alen(opt_get1(aloc(opt_get1(target), i1).option$array$)) } 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(target), i1).option$array$)) == V)
; [eval] exc == null
(push) ; 12
(set-option :timeout 10)
(push) ; 13
(assert (not (not (= exc@123@04 $Ref.null))))
(check-sat)
; unknown
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               29293
;  :arith-add-rows          23781
;  :arith-assert-diseq      1703
;  :arith-assert-lower      9212
;  :arith-assert-upper      5780
;  :arith-bound-prop        2103
;  :arith-conflicts         656
;  :arith-eq-adapter        5860
;  :arith-fixed-eqs         2795
;  :arith-gcd-tests         1
;  :arith-grobner           113
;  :arith-ineq-splits       1
;  :arith-max-min           1018
;  :arith-nonlinear-bounds  92
;  :arith-nonlinear-horner  92
;  :arith-offset-eqs        2950
;  :arith-patches           1
;  :arith-pivots            4444
;  :conflicts               1612
;  :datatype-accessor-ax    102
;  :datatype-constructor-ax 857
;  :datatype-occurs-check   380
;  :datatype-splits         295
;  :decisions               5024
;  :del-clause              35125
;  :final-checks            274
;  :interface-eqs           25
;  :max-generation          9
;  :max-memory              8.66
;  :memory                  8.40
;  :minimized-lits          208
;  :mk-bool-var             47748
;  :mk-clause               35134
;  :num-allocs              480910
;  :num-checks              311
;  :propagations            20405
;  :quant-instantiations    10159
;  :rlimit-count            1506044)
; [then-branch: 203 | exc@123@04 == Null | live]
; [else-branch: 203 | exc@123@04 != Null | dead]
(push) ; 13
; [then-branch: 203 | exc@123@04 == Null]
; [eval] (forall i1: Int :: { alen(opt_get1(aloc(opt_get1(target), i1).option$array$)) } 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(target), i1).option$array$)) == V)
(declare-const i1@175@04 Int)
(push) ; 14
; [eval] 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(target), i1).option$array$)) == V
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 15
; [then-branch: 204 | 0 <= i1@175@04 | live]
; [else-branch: 204 | !(0 <= i1@175@04) | live]
(push) ; 16
; [then-branch: 204 | 0 <= i1@175@04]
(assert (<= 0 i1@175@04))
; [eval] i1 < V
(pop) ; 16
(push) ; 16
; [else-branch: 204 | !(0 <= i1@175@04)]
(assert (not (<= 0 i1@175@04)))
(pop) ; 16
(pop) ; 15
; Joined path conditions
; Joined path conditions
(push) ; 15
; [then-branch: 205 | i1@175@04 < V@28@04 && 0 <= i1@175@04 | live]
; [else-branch: 205 | !(i1@175@04 < V@28@04 && 0 <= i1@175@04) | live]
(push) ; 16
; [then-branch: 205 | i1@175@04 < V@28@04 && 0 <= i1@175@04]
(assert (and (< i1@175@04 V@28@04) (<= 0 i1@175@04)))
; [eval] alen(opt_get1(aloc(opt_get1(target), i1).option$array$)) == V
; [eval] alen(opt_get1(aloc(opt_get1(target), i1).option$array$))
; [eval] opt_get1(aloc(opt_get1(target), i1).option$array$)
; [eval] aloc(opt_get1(target), i1)
; [eval] opt_get1(target)
(push) ; 17
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 17
; Joined path conditions
(push) ; 17
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 18
(assert (not (< i1@175@04 (alen<Int> (opt_get1 $Snap.unit target@27@04)))))
(check-sat)
; unsat
(pop) ; 18
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               29293
;  :arith-add-rows          23781
;  :arith-assert-diseq      1703
;  :arith-assert-lower      9214
;  :arith-assert-upper      5780
;  :arith-bound-prop        2103
;  :arith-conflicts         656
;  :arith-eq-adapter        5860
;  :arith-fixed-eqs         2795
;  :arith-gcd-tests         1
;  :arith-grobner           113
;  :arith-ineq-splits       1
;  :arith-max-min           1018
;  :arith-nonlinear-bounds  92
;  :arith-nonlinear-horner  92
;  :arith-offset-eqs        2950
;  :arith-patches           1
;  :arith-pivots            4444
;  :conflicts               1612
;  :datatype-accessor-ax    102
;  :datatype-constructor-ax 857
;  :datatype-occurs-check   380
;  :datatype-splits         295
;  :decisions               5024
;  :del-clause              35125
;  :final-checks            274
;  :interface-eqs           25
;  :max-generation          9
;  :max-memory              8.66
;  :memory                  8.40
;  :minimized-lits          208
;  :mk-bool-var             47750
;  :mk-clause               35134
;  :num-allocs              481014
;  :num-checks              312
;  :propagations            20405
;  :quant-instantiations    10159
;  :rlimit-count            1506239)
(assert (< i1@175@04 (alen<Int> (opt_get1 $Snap.unit target@27@04))))
(pop) ; 17
; Joined path conditions
(assert (< i1@175@04 (alen<Int> (opt_get1 $Snap.unit target@27@04))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@175@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@175@04)))
(push) ; 17
(assert (not (<
  $Perm.No
  (+
    (+
      (+
        (ite
          (and
            (<
              (inv@136@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@175@04))
              V@28@04)
            (<=
              0
              (inv@136@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@175@04))))
          (*
            (scale $Snap.unit (* (to_real (* V@28@04 V@28@04)) $Perm.Write))
            $k@135@04)
          $Perm.No)
        (ite
          (and
            (<
              (inv@128@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@175@04))
              V@28@04)
            (<=
              0
              (inv@128@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@175@04))))
          (*
            (scale $Snap.unit (* (to_real (* V@28@04 V@28@04)) $Perm.Write))
            $k@127@04)
          $Perm.No))
      (-
        (-
          (ite
            (and
              (<
                (inv@42@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@175@04))
                V@28@04)
              (<=
                0
                (inv@42@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@175@04))))
            $k@41@04
            $Perm.No)
          (pTaken@95@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@175@04)))
        (pTaken@106@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@175@04))))
    (-
      (-
        (ite
          (and
            (<
              (inv@34@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@175@04))
              V@28@04)
            (<=
              0
              (inv@34@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@175@04))))
          $k@33@04
          $Perm.No)
        (pTaken@96@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@175@04)))
      (pTaken@105@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@175@04)))))))
(check-sat)
; unsat
(pop) ; 17
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               30160
;  :arith-add-rows          24589
;  :arith-assert-diseq      1738
;  :arith-assert-lower      9491
;  :arith-assert-upper      5946
;  :arith-bound-prop        2179
;  :arith-conflicts         679
;  :arith-eq-adapter        6024
;  :arith-fixed-eqs         2895
;  :arith-gcd-tests         1
;  :arith-grobner           113
;  :arith-ineq-splits       1
;  :arith-max-min           1018
;  :arith-nonlinear-bounds  92
;  :arith-nonlinear-horner  92
;  :arith-offset-eqs        3054
;  :arith-patches           1
;  :arith-pivots            4553
;  :conflicts               1653
;  :datatype-accessor-ax    102
;  :datatype-constructor-ax 861
;  :datatype-occurs-check   380
;  :datatype-splits         295
;  :decisions               5118
;  :del-clause              35976
;  :final-checks            274
;  :interface-eqs           25
;  :max-generation          9
;  :max-memory              8.66
;  :memory                  8.43
;  :minimized-lits          210
;  :mk-bool-var             49023
;  :mk-clause               36150
;  :num-allocs              486694
;  :num-checks              313
;  :propagations            21094
;  :quant-instantiations    10450
;  :rlimit-count            1543371
;  :time                    0.01)
(push) ; 17
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 18
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@175@04))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 18
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               30160
;  :arith-add-rows          24589
;  :arith-assert-diseq      1738
;  :arith-assert-lower      9491
;  :arith-assert-upper      5946
;  :arith-bound-prop        2179
;  :arith-conflicts         679
;  :arith-eq-adapter        6024
;  :arith-fixed-eqs         2895
;  :arith-gcd-tests         1
;  :arith-grobner           113
;  :arith-ineq-splits       1
;  :arith-max-min           1018
;  :arith-nonlinear-bounds  92
;  :arith-nonlinear-horner  92
;  :arith-offset-eqs        3054
;  :arith-patches           1
;  :arith-pivots            4553
;  :conflicts               1654
;  :datatype-accessor-ax    102
;  :datatype-constructor-ax 861
;  :datatype-occurs-check   380
;  :datatype-splits         295
;  :decisions               5118
;  :del-clause              35976
;  :final-checks            274
;  :interface-eqs           25
;  :max-generation          9
;  :max-memory              8.66
;  :memory                  8.43
;  :minimized-lits          210
;  :mk-bool-var             49023
;  :mk-clause               36150
;  :num-allocs              486785
;  :num-checks              314
;  :propagations            21094
;  :quant-instantiations    10450
;  :rlimit-count            1543466)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@175@04))
    (as None<option<array>>  option<array>))))
(pop) ; 17
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@175@04))
    (as None<option<array>>  option<array>))))
(pop) ; 16
(push) ; 16
; [else-branch: 205 | !(i1@175@04 < V@28@04 && 0 <= i1@175@04)]
(assert (not (and (< i1@175@04 V@28@04) (<= 0 i1@175@04))))
(pop) ; 16
(pop) ; 15
; Joined path conditions
(assert (implies
  (and (< i1@175@04 V@28@04) (<= 0 i1@175@04))
  (and
    (< i1@175@04 V@28@04)
    (<= 0 i1@175@04)
    (< i1@175@04 (alen<Int> (opt_get1 $Snap.unit target@27@04)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@175@04)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@175@04))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@175@04))
        (as None<option<array>>  option<array>))))))
; Joined path conditions
(pop) ; 14
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@175@04 Int)) (!
  (implies
    (and (< i1@175@04 V@28@04) (<= 0 i1@175@04))
    (and
      (< i1@175@04 V@28@04)
      (<= 0 i1@175@04)
      (< i1@175@04 (alen<Int> (opt_get1 $Snap.unit target@27@04)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@175@04)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@175@04))
      (not
        (=
          ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@175@04))
          (as None<option<array>>  option<array>)))))
  :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@175@04)))))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 13
(pop) ; 12
; Joined path conditions
(assert (implies
  (= exc@123@04 $Ref.null)
  (forall ((i1@175@04 Int)) (!
    (implies
      (and (< i1@175@04 V@28@04) (<= 0 i1@175@04))
      (and
        (< i1@175@04 V@28@04)
        (<= 0 i1@175@04)
        (< i1@175@04 (alen<Int> (opt_get1 $Snap.unit target@27@04)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@175@04)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@175@04))
        (not
          (=
            ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@175@04))
            (as None<option<array>>  option<array>)))))
    :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@175@04)))))
    :qid |prog.l<no position>-aux|))))
(push) ; 12
(assert (not (implies
  (= exc@123@04 $Ref.null)
  (forall ((i1@175@04 Int)) (!
    (implies
      (and (< i1@175@04 V@28@04) (<= 0 i1@175@04))
      (=
        (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@175@04))))
        V@28@04))
    :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@175@04)))))
    :qid |prog.l<no position>|)))))
(check-sat)
; unsat
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               30160
;  :arith-add-rows          24607
;  :arith-assert-diseq      1738
;  :arith-assert-lower      9493
;  :arith-assert-upper      5946
;  :arith-bound-prop        2179
;  :arith-conflicts         679
;  :arith-eq-adapter        6027
;  :arith-fixed-eqs         2895
;  :arith-gcd-tests         1
;  :arith-grobner           113
;  :arith-ineq-splits       1
;  :arith-max-min           1018
;  :arith-nonlinear-bounds  92
;  :arith-nonlinear-horner  92
;  :arith-offset-eqs        3054
;  :arith-patches           1
;  :arith-pivots            4573
;  :conflicts               1655
;  :datatype-accessor-ax    102
;  :datatype-constructor-ax 861
;  :datatype-occurs-check   380
;  :datatype-splits         295
;  :decisions               5118
;  :del-clause              36202
;  :final-checks            274
;  :interface-eqs           25
;  :max-generation          9
;  :max-memory              8.66
;  :memory                  8.41
;  :minimized-lits          210
;  :mk-bool-var             49104
;  :mk-clause               36211
;  :num-allocs              487582
;  :num-checks              315
;  :propagations            21094
;  :quant-instantiations    10473
;  :rlimit-count            1545498)
(assert (implies
  (= exc@123@04 $Ref.null)
  (forall ((i1@175@04 Int)) (!
    (implies
      (and (< i1@175@04 V@28@04) (<= 0 i1@175@04))
      (=
        (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@175@04))))
        V@28@04))
    :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@175@04)))))
    :qid |prog.l<no position>|))))
; [eval] exc == null ==> (forall i1: Int :: { aloc(opt_get1(target), i1) } (forall i2: Int :: { aloc(opt_get1(target), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(target), i1).option$array$ == aloc(opt_get1(target), i2).option$array$ ==> i1 == i2))
; [eval] exc == null
(push) ; 12
(set-option :timeout 10)
(push) ; 13
(assert (not (not (= exc@123@04 $Ref.null))))
(check-sat)
; unknown
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               30197
;  :arith-add-rows          24607
;  :arith-assert-diseq      1738
;  :arith-assert-lower      9493
;  :arith-assert-upper      5946
;  :arith-bound-prop        2179
;  :arith-conflicts         679
;  :arith-eq-adapter        6027
;  :arith-fixed-eqs         2895
;  :arith-gcd-tests         1
;  :arith-grobner           113
;  :arith-ineq-splits       1
;  :arith-max-min           1018
;  :arith-nonlinear-bounds  92
;  :arith-nonlinear-horner  92
;  :arith-offset-eqs        3054
;  :arith-patches           1
;  :arith-pivots            4573
;  :conflicts               1655
;  :datatype-accessor-ax    102
;  :datatype-constructor-ax 869
;  :datatype-occurs-check   385
;  :datatype-splits         299
;  :decisions               5126
;  :del-clause              36202
;  :final-checks            276
;  :interface-eqs           25
;  :max-generation          9
;  :max-memory              8.66
;  :memory                  8.41
;  :minimized-lits          210
;  :mk-bool-var             49109
;  :mk-clause               36211
;  :num-allocs              488440
;  :num-checks              316
;  :propagations            21094
;  :quant-instantiations    10473
;  :rlimit-count            1546632)
; [then-branch: 206 | exc@123@04 == Null | live]
; [else-branch: 206 | exc@123@04 != Null | dead]
(push) ; 13
; [then-branch: 206 | exc@123@04 == Null]
; [eval] (forall i1: Int :: { aloc(opt_get1(target), i1) } (forall i2: Int :: { aloc(opt_get1(target), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(target), i1).option$array$ == aloc(opt_get1(target), i2).option$array$ ==> i1 == i2))
(declare-const i1@176@04 Int)
(push) ; 14
; [eval] (forall i2: Int :: { aloc(opt_get1(target), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(target), i1).option$array$ == aloc(opt_get1(target), i2).option$array$ ==> i1 == i2)
(declare-const i2@177@04 Int)
(push) ; 15
; [eval] 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(target), i1).option$array$ == aloc(opt_get1(target), i2).option$array$ ==> i1 == i2
; [eval] 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(target), i1).option$array$ == aloc(opt_get1(target), i2).option$array$
; [eval] 0 <= i1
(push) ; 16
; [then-branch: 207 | 0 <= i1@176@04 | live]
; [else-branch: 207 | !(0 <= i1@176@04) | live]
(push) ; 17
; [then-branch: 207 | 0 <= i1@176@04]
(assert (<= 0 i1@176@04))
; [eval] i1 < V
(push) ; 18
; [then-branch: 208 | i1@176@04 < V@28@04 | live]
; [else-branch: 208 | !(i1@176@04 < V@28@04) | live]
(push) ; 19
; [then-branch: 208 | i1@176@04 < V@28@04]
(assert (< i1@176@04 V@28@04))
; [eval] 0 <= i2
(push) ; 20
; [then-branch: 209 | 0 <= i2@177@04 | live]
; [else-branch: 209 | !(0 <= i2@177@04) | live]
(push) ; 21
; [then-branch: 209 | 0 <= i2@177@04]
(assert (<= 0 i2@177@04))
; [eval] i2 < V
(push) ; 22
; [then-branch: 210 | i2@177@04 < V@28@04 | live]
; [else-branch: 210 | !(i2@177@04 < V@28@04) | live]
(push) ; 23
; [then-branch: 210 | i2@177@04 < V@28@04]
(assert (< i2@177@04 V@28@04))
; [eval] aloc(opt_get1(target), i1).option$array$ == aloc(opt_get1(target), i2).option$array$
; [eval] aloc(opt_get1(target), i1)
; [eval] opt_get1(target)
(push) ; 24
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 24
; Joined path conditions
(push) ; 24
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 25
(assert (not (< i1@176@04 (alen<Int> (opt_get1 $Snap.unit target@27@04)))))
(check-sat)
; unsat
(pop) ; 25
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               30197
;  :arith-add-rows          24607
;  :arith-assert-diseq      1738
;  :arith-assert-lower      9497
;  :arith-assert-upper      5946
;  :arith-bound-prop        2179
;  :arith-conflicts         679
;  :arith-eq-adapter        6027
;  :arith-fixed-eqs         2895
;  :arith-gcd-tests         1
;  :arith-grobner           113
;  :arith-ineq-splits       1
;  :arith-max-min           1018
;  :arith-nonlinear-bounds  92
;  :arith-nonlinear-horner  92
;  :arith-offset-eqs        3054
;  :arith-patches           1
;  :arith-pivots            4573
;  :conflicts               1655
;  :datatype-accessor-ax    102
;  :datatype-constructor-ax 869
;  :datatype-occurs-check   385
;  :datatype-splits         299
;  :decisions               5126
;  :del-clause              36202
;  :final-checks            276
;  :interface-eqs           25
;  :max-generation          9
;  :max-memory              8.66
;  :memory                  8.41
;  :minimized-lits          210
;  :mk-bool-var             49113
;  :mk-clause               36211
;  :num-allocs              488721
;  :num-checks              317
;  :propagations            21094
;  :quant-instantiations    10473
;  :rlimit-count            1546971)
(assert (< i1@176@04 (alen<Int> (opt_get1 $Snap.unit target@27@04))))
(pop) ; 24
; Joined path conditions
(assert (< i1@176@04 (alen<Int> (opt_get1 $Snap.unit target@27@04))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@176@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@176@04)))
(push) ; 24
(assert (not (<
  $Perm.No
  (+
    (+
      (+
        (ite
          (and
            (<
              (inv@136@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@176@04))
              V@28@04)
            (<=
              0
              (inv@136@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@176@04))))
          (*
            (scale $Snap.unit (* (to_real (* V@28@04 V@28@04)) $Perm.Write))
            $k@135@04)
          $Perm.No)
        (ite
          (and
            (<
              (inv@128@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@176@04))
              V@28@04)
            (<=
              0
              (inv@128@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@176@04))))
          (*
            (scale $Snap.unit (* (to_real (* V@28@04 V@28@04)) $Perm.Write))
            $k@127@04)
          $Perm.No))
      (-
        (-
          (ite
            (and
              (<
                (inv@42@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@176@04))
                V@28@04)
              (<=
                0
                (inv@42@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@176@04))))
            $k@41@04
            $Perm.No)
          (pTaken@95@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@176@04)))
        (pTaken@106@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@176@04))))
    (-
      (-
        (ite
          (and
            (<
              (inv@34@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@176@04))
              V@28@04)
            (<=
              0
              (inv@34@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@176@04))))
          $k@33@04
          $Perm.No)
        (pTaken@96@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@176@04)))
      (pTaken@105@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@176@04)))))))
(check-sat)
; unsat
(pop) ; 24
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               31218
;  :arith-add-rows          25293
;  :arith-assert-diseq      1783
;  :arith-assert-lower      9813
;  :arith-assert-upper      6140
;  :arith-bound-prop        2261
;  :arith-conflicts         698
;  :arith-eq-adapter        6200
;  :arith-fixed-eqs         3008
;  :arith-gcd-tests         1
;  :arith-grobner           113
;  :arith-ineq-splits       1
;  :arith-max-min           1018
;  :arith-nonlinear-bounds  92
;  :arith-nonlinear-horner  92
;  :arith-offset-eqs        3205
;  :arith-patches           1
;  :arith-pivots            4693
;  :conflicts               1693
;  :datatype-accessor-ax    102
;  :datatype-constructor-ax 873
;  :datatype-occurs-check   385
;  :datatype-splits         299
;  :decisions               5215
;  :del-clause              37032
;  :final-checks            276
;  :interface-eqs           25
;  :max-generation          9
;  :max-memory              8.66
;  :memory                  8.44
;  :minimized-lits          219
;  :mk-bool-var             50396
;  :mk-clause               37206
;  :num-allocs              494854
;  :num-checks              318
;  :propagations            21940
;  :quant-instantiations    10828
;  :rlimit-count            1582071
;  :time                    0.01)
; [eval] aloc(opt_get1(target), i2)
; [eval] opt_get1(target)
(push) ; 24
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 24
; Joined path conditions
(push) ; 24
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 25
(assert (not (< i2@177@04 (alen<Int> (opt_get1 $Snap.unit target@27@04)))))
(check-sat)
; unsat
(pop) ; 25
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               31218
;  :arith-add-rows          25293
;  :arith-assert-diseq      1783
;  :arith-assert-lower      9813
;  :arith-assert-upper      6140
;  :arith-bound-prop        2261
;  :arith-conflicts         698
;  :arith-eq-adapter        6200
;  :arith-fixed-eqs         3008
;  :arith-gcd-tests         1
;  :arith-grobner           113
;  :arith-ineq-splits       1
;  :arith-max-min           1018
;  :arith-nonlinear-bounds  92
;  :arith-nonlinear-horner  92
;  :arith-offset-eqs        3205
;  :arith-patches           1
;  :arith-pivots            4693
;  :conflicts               1693
;  :datatype-accessor-ax    102
;  :datatype-constructor-ax 873
;  :datatype-occurs-check   385
;  :datatype-splits         299
;  :decisions               5215
;  :del-clause              37032
;  :final-checks            276
;  :interface-eqs           25
;  :max-generation          9
;  :max-memory              8.66
;  :memory                  8.44
;  :minimized-lits          219
;  :mk-bool-var             50396
;  :mk-clause               37206
;  :num-allocs              494881
;  :num-checks              319
;  :propagations            21940
;  :quant-instantiations    10828
;  :rlimit-count            1582101)
(assert (< i2@177@04 (alen<Int> (opt_get1 $Snap.unit target@27@04))))
(pop) ; 24
; Joined path conditions
(assert (< i2@177@04 (alen<Int> (opt_get1 $Snap.unit target@27@04))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@177@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@177@04)))
(push) ; 24
(assert (not (<
  $Perm.No
  (+
    (+
      (+
        (ite
          (and
            (<
              (inv@136@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@177@04))
              V@28@04)
            (<=
              0
              (inv@136@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@177@04))))
          (*
            (scale $Snap.unit (* (to_real (* V@28@04 V@28@04)) $Perm.Write))
            $k@135@04)
          $Perm.No)
        (ite
          (and
            (<
              (inv@128@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@177@04))
              V@28@04)
            (<=
              0
              (inv@128@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@177@04))))
          (*
            (scale $Snap.unit (* (to_real (* V@28@04 V@28@04)) $Perm.Write))
            $k@127@04)
          $Perm.No))
      (-
        (-
          (ite
            (and
              (<
                (inv@42@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@177@04))
                V@28@04)
              (<=
                0
                (inv@42@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@177@04))))
            $k@41@04
            $Perm.No)
          (pTaken@95@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@177@04)))
        (pTaken@106@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@177@04))))
    (-
      (-
        (ite
          (and
            (<
              (inv@34@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@177@04))
              V@28@04)
            (<=
              0
              (inv@34@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@177@04))))
          $k@33@04
          $Perm.No)
        (pTaken@96@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@177@04)))
      (pTaken@105@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@177@04)))))))
(check-sat)
; unsat
(pop) ; 24
; 0.12s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               35381
;  :arith-add-rows          29437
;  :arith-assert-diseq      2159
;  :arith-assert-lower      11284
;  :arith-assert-upper      7069
;  :arith-bound-prop        2543
;  :arith-conflicts         755
;  :arith-eq-adapter        7070
;  :arith-fixed-eqs         3493
;  :arith-gcd-tests         1
;  :arith-grobner           113
;  :arith-ineq-splits       1
;  :arith-max-min           1018
;  :arith-nonlinear-bounds  92
;  :arith-nonlinear-horner  92
;  :arith-offset-eqs        3762
;  :arith-patches           1
;  :arith-pivots            5087
;  :conflicts               1809
;  :datatype-accessor-ax    102
;  :datatype-constructor-ax 877
;  :datatype-occurs-check   385
;  :datatype-splits         299
;  :decisions               5700
;  :del-clause              41123
;  :final-checks            276
;  :interface-eqs           25
;  :max-generation          9
;  :max-memory              10.04
;  :memory                  9.38
;  :minimized-lits          273
;  :mk-bool-var             55122
;  :mk-clause               41438
;  :num-allocs              511415
;  :num-checks              320
;  :propagations            26295
;  :quant-instantiations    12106
;  :restarts                1
;  :rlimit-count            1787806
;  :time                    0.12)
(pop) ; 23
(push) ; 23
; [else-branch: 210 | !(i2@177@04 < V@28@04)]
(assert (not (< i2@177@04 V@28@04)))
(pop) ; 23
(pop) ; 22
; Joined path conditions
(assert (implies
  (< i2@177@04 V@28@04)
  (and
    (< i2@177@04 V@28@04)
    (< i1@176@04 (alen<Int> (opt_get1 $Snap.unit target@27@04)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@176@04)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@176@04))
    (< i2@177@04 (alen<Int> (opt_get1 $Snap.unit target@27@04)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@177@04)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@177@04)))))
; Joined path conditions
(pop) ; 21
(push) ; 21
; [else-branch: 209 | !(0 <= i2@177@04)]
(assert (not (<= 0 i2@177@04)))
(pop) ; 21
(pop) ; 20
; Joined path conditions
(assert (implies
  (<= 0 i2@177@04)
  (and
    (<= 0 i2@177@04)
    (implies
      (< i2@177@04 V@28@04)
      (and
        (< i2@177@04 V@28@04)
        (< i1@176@04 (alen<Int> (opt_get1 $Snap.unit target@27@04)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@176@04)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@176@04))
        (< i2@177@04 (alen<Int> (opt_get1 $Snap.unit target@27@04)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@177@04)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@177@04)))))))
; Joined path conditions
(pop) ; 19
(push) ; 19
; [else-branch: 208 | !(i1@176@04 < V@28@04)]
(assert (not (< i1@176@04 V@28@04)))
(pop) ; 19
(pop) ; 18
; Joined path conditions
(assert (implies
  (< i1@176@04 V@28@04)
  (and
    (< i1@176@04 V@28@04)
    (implies
      (<= 0 i2@177@04)
      (and
        (<= 0 i2@177@04)
        (implies
          (< i2@177@04 V@28@04)
          (and
            (< i2@177@04 V@28@04)
            (< i1@176@04 (alen<Int> (opt_get1 $Snap.unit target@27@04)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@176@04)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@176@04))
            (< i2@177@04 (alen<Int> (opt_get1 $Snap.unit target@27@04)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@177@04)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@177@04)))))))))
; Joined path conditions
(pop) ; 17
(push) ; 17
; [else-branch: 207 | !(0 <= i1@176@04)]
(assert (not (<= 0 i1@176@04)))
(pop) ; 17
(pop) ; 16
; Joined path conditions
(assert (implies
  (<= 0 i1@176@04)
  (and
    (<= 0 i1@176@04)
    (implies
      (< i1@176@04 V@28@04)
      (and
        (< i1@176@04 V@28@04)
        (implies
          (<= 0 i2@177@04)
          (and
            (<= 0 i2@177@04)
            (implies
              (< i2@177@04 V@28@04)
              (and
                (< i2@177@04 V@28@04)
                (< i1@176@04 (alen<Int> (opt_get1 $Snap.unit target@27@04)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@176@04)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@176@04))
                (< i2@177@04 (alen<Int> (opt_get1 $Snap.unit target@27@04)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@177@04)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@177@04)))))))))))
; Joined path conditions
(push) ; 16
; [then-branch: 211 | Lookup(option$array$,sm@137@04,aloc((_, _), opt_get1(_, target@27@04), i1@176@04)) == Lookup(option$array$,sm@137@04,aloc((_, _), opt_get1(_, target@27@04), i2@177@04)) && i2@177@04 < V@28@04 && 0 <= i2@177@04 && i1@176@04 < V@28@04 && 0 <= i1@176@04 | live]
; [else-branch: 211 | !(Lookup(option$array$,sm@137@04,aloc((_, _), opt_get1(_, target@27@04), i1@176@04)) == Lookup(option$array$,sm@137@04,aloc((_, _), opt_get1(_, target@27@04), i2@177@04)) && i2@177@04 < V@28@04 && 0 <= i2@177@04 && i1@176@04 < V@28@04 && 0 <= i1@176@04) | live]
(push) ; 17
; [then-branch: 211 | Lookup(option$array$,sm@137@04,aloc((_, _), opt_get1(_, target@27@04), i1@176@04)) == Lookup(option$array$,sm@137@04,aloc((_, _), opt_get1(_, target@27@04), i2@177@04)) && i2@177@04 < V@28@04 && 0 <= i2@177@04 && i1@176@04 < V@28@04 && 0 <= i1@176@04]
(assert (and
  (and
    (and
      (and
        (=
          ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@176@04))
          ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@177@04)))
        (< i2@177@04 V@28@04))
      (<= 0 i2@177@04))
    (< i1@176@04 V@28@04))
  (<= 0 i1@176@04)))
; [eval] i1 == i2
(pop) ; 17
(push) ; 17
; [else-branch: 211 | !(Lookup(option$array$,sm@137@04,aloc((_, _), opt_get1(_, target@27@04), i1@176@04)) == Lookup(option$array$,sm@137@04,aloc((_, _), opt_get1(_, target@27@04), i2@177@04)) && i2@177@04 < V@28@04 && 0 <= i2@177@04 && i1@176@04 < V@28@04 && 0 <= i1@176@04)]
(assert (not
  (and
    (and
      (and
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@176@04))
            ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@177@04)))
          (< i2@177@04 V@28@04))
        (<= 0 i2@177@04))
      (< i1@176@04 V@28@04))
    (<= 0 i1@176@04))))
(pop) ; 17
(pop) ; 16
; Joined path conditions
(assert (implies
  (and
    (and
      (and
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@176@04))
            ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@177@04)))
          (< i2@177@04 V@28@04))
        (<= 0 i2@177@04))
      (< i1@176@04 V@28@04))
    (<= 0 i1@176@04))
  (and
    (=
      ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@176@04))
      ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@177@04)))
    (< i2@177@04 V@28@04)
    (<= 0 i2@177@04)
    (< i1@176@04 V@28@04)
    (<= 0 i1@176@04))))
; Joined path conditions
(pop) ; 15
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i2@177@04 Int)) (!
  (and
    (implies
      (<= 0 i1@176@04)
      (and
        (<= 0 i1@176@04)
        (implies
          (< i1@176@04 V@28@04)
          (and
            (< i1@176@04 V@28@04)
            (implies
              (<= 0 i2@177@04)
              (and
                (<= 0 i2@177@04)
                (implies
                  (< i2@177@04 V@28@04)
                  (and
                    (< i2@177@04 V@28@04)
                    (< i1@176@04 (alen<Int> (opt_get1 $Snap.unit target@27@04)))
                    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@176@04)) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@176@04))
                    (< i2@177@04 (alen<Int> (opt_get1 $Snap.unit target@27@04)))
                    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@177@04)) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@177@04))))))))))
    (implies
      (and
        (and
          (and
            (and
              (=
                ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@176@04))
                ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@177@04)))
              (< i2@177@04 V@28@04))
            (<= 0 i2@177@04))
          (< i1@176@04 V@28@04))
        (<= 0 i1@176@04))
      (and
        (=
          ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@176@04))
          ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@177@04)))
        (< i2@177@04 V@28@04)
        (<= 0 i2@177@04)
        (< i1@176@04 V@28@04)
        (<= 0 i1@176@04))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@177@04))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 14
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@176@04 Int)) (!
  (forall ((i2@177@04 Int)) (!
    (and
      (implies
        (<= 0 i1@176@04)
        (and
          (<= 0 i1@176@04)
          (implies
            (< i1@176@04 V@28@04)
            (and
              (< i1@176@04 V@28@04)
              (implies
                (<= 0 i2@177@04)
                (and
                  (<= 0 i2@177@04)
                  (implies
                    (< i2@177@04 V@28@04)
                    (and
                      (< i2@177@04 V@28@04)
                      (<
                        i1@176@04
                        (alen<Int> (opt_get1 $Snap.unit target@27@04)))
                      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@176@04)) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@176@04))
                      (<
                        i2@177@04
                        (alen<Int> (opt_get1 $Snap.unit target@27@04)))
                      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@177@04)) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@177@04))))))))))
      (implies
        (and
          (and
            (and
              (and
                (=
                  ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@176@04))
                  ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@177@04)))
                (< i2@177@04 V@28@04))
              (<= 0 i2@177@04))
            (< i1@176@04 V@28@04))
          (<= 0 i1@176@04))
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@176@04))
            ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@177@04)))
          (< i2@177@04 V@28@04)
          (<= 0 i2@177@04)
          (< i1@176@04 V@28@04)
          (<= 0 i1@176@04))))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@177@04))
    :qid |prog.l<no position>-aux|))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@176@04))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 13
(pop) ; 12
; Joined path conditions
(assert (implies
  (= exc@123@04 $Ref.null)
  (forall ((i1@176@04 Int)) (!
    (forall ((i2@177@04 Int)) (!
      (and
        (implies
          (<= 0 i1@176@04)
          (and
            (<= 0 i1@176@04)
            (implies
              (< i1@176@04 V@28@04)
              (and
                (< i1@176@04 V@28@04)
                (implies
                  (<= 0 i2@177@04)
                  (and
                    (<= 0 i2@177@04)
                    (implies
                      (< i2@177@04 V@28@04)
                      (and
                        (< i2@177@04 V@28@04)
                        (<
                          i1@176@04
                          (alen<Int> (opt_get1 $Snap.unit target@27@04)))
                        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
                          $Snap.unit
                          $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@176@04)) (aloc ($Snap.combine
                          $Snap.unit
                          $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@176@04))
                        (<
                          i2@177@04
                          (alen<Int> (opt_get1 $Snap.unit target@27@04)))
                        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
                          $Snap.unit
                          $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@177@04)) (aloc ($Snap.combine
                          $Snap.unit
                          $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@177@04))))))))))
        (implies
          (and
            (and
              (and
                (and
                  (=
                    ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@176@04))
                    ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@177@04)))
                  (< i2@177@04 V@28@04))
                (<= 0 i2@177@04))
              (< i1@176@04 V@28@04))
            (<= 0 i1@176@04))
          (and
            (=
              ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@176@04))
              ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@177@04)))
            (< i2@177@04 V@28@04)
            (<= 0 i2@177@04)
            (< i1@176@04 V@28@04)
            (<= 0 i1@176@04))))
      :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@177@04))
      :qid |prog.l<no position>-aux|))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@176@04))
    :qid |prog.l<no position>-aux|))))
(push) ; 12
(assert (not (implies
  (= exc@123@04 $Ref.null)
  (forall ((i1@176@04 Int)) (!
    (forall ((i2@177@04 Int)) (!
      (implies
        (and
          (and
            (and
              (and
                (=
                  ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@176@04))
                  ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@177@04)))
                (< i2@177@04 V@28@04))
              (<= 0 i2@177@04))
            (< i1@176@04 V@28@04))
          (<= 0 i1@176@04))
        (= i1@176@04 i2@177@04))
      :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@177@04))
      :qid |prog.l<no position>|))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@176@04))
    :qid |prog.l<no position>|)))))
(check-sat)
; unsat
(pop) ; 12
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               35407
;  :arith-add-rows          29485
;  :arith-assert-diseq      2160
;  :arith-assert-lower      11291
;  :arith-assert-upper      7071
;  :arith-bound-prop        2547
;  :arith-conflicts         755
;  :arith-eq-adapter        7085
;  :arith-fixed-eqs         3495
;  :arith-gcd-tests         1
;  :arith-grobner           113
;  :arith-ineq-splits       1
;  :arith-max-min           1018
;  :arith-nonlinear-bounds  92
;  :arith-nonlinear-horner  92
;  :arith-offset-eqs        3768
;  :arith-patches           1
;  :arith-pivots            5124
;  :conflicts               1810
;  :datatype-accessor-ax    102
;  :datatype-constructor-ax 877
;  :datatype-occurs-check   385
;  :datatype-splits         299
;  :decisions               5700
;  :del-clause              41767
;  :final-checks            276
;  :interface-eqs           25
;  :max-generation          9
;  :max-memory              10.04
;  :memory                  9.34
;  :minimized-lits          273
;  :mk-bool-var             55558
;  :mk-clause               41776
;  :num-allocs              514318
;  :num-checks              321
;  :propagations            26317
;  :quant-instantiations    12240
;  :restarts                1
;  :rlimit-count            1799295
;  :time                    0.01)
(assert (implies
  (= exc@123@04 $Ref.null)
  (forall ((i1@176@04 Int)) (!
    (forall ((i2@177@04 Int)) (!
      (implies
        (and
          (and
            (and
              (and
                (=
                  ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@176@04))
                  ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@177@04)))
                (< i2@177@04 V@28@04))
              (<= 0 i2@177@04))
            (< i1@176@04 V@28@04))
          (<= 0 i1@176@04))
        (= i1@176@04 i2@177@04))
      :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@177@04))
      :qid |prog.l<no position>|))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@176@04))
    :qid |prog.l<no position>|))))
; [eval] exc == null
(set-option :timeout 10)
(push) ; 12
(assert (not (not (= exc@123@04 $Ref.null))))
(check-sat)
; unknown
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               35444
;  :arith-add-rows          29485
;  :arith-assert-diseq      2160
;  :arith-assert-lower      11306
;  :arith-assert-upper      7079
;  :arith-bound-prop        2547
;  :arith-conflicts         755
;  :arith-eq-adapter        7085
;  :arith-fixed-eqs         3495
;  :arith-gcd-tests         1
;  :arith-grobner           118
;  :arith-ineq-splits       1
;  :arith-max-min           1044
;  :arith-nonlinear-bounds  95
;  :arith-nonlinear-horner  96
;  :arith-offset-eqs        3768
;  :arith-patches           1
;  :arith-pivots            5124
;  :conflicts               1810
;  :datatype-accessor-ax    102
;  :datatype-constructor-ax 885
;  :datatype-occurs-check   390
;  :datatype-splits         303
;  :decisions               5708
;  :del-clause              41767
;  :final-checks            280
;  :interface-eqs           25
;  :max-generation          9
;  :max-memory              10.04
;  :memory                  9.35
;  :minimized-lits          273
;  :mk-bool-var             55563
;  :mk-clause               41776
;  :num-allocs              515508
;  :num-checks              322
;  :propagations            26317
;  :quant-instantiations    12240
;  :restarts                1
;  :rlimit-count            1801208
;  :time                    0.00)
; [then-branch: 212 | exc@123@04 == Null | live]
; [else-branch: 212 | exc@123@04 != Null | dead]
(push) ; 12
; [then-branch: 212 | exc@123@04 == Null]
(declare-const i1@178@04 Int)
(declare-const j1@179@04 Int)
(push) ; 13
; [eval] 0 <= i1 && i1 < V && (0 <= j1 && j1 < V)
; [eval] 0 <= i1
(push) ; 14
; [then-branch: 213 | 0 <= i1@178@04 | live]
; [else-branch: 213 | !(0 <= i1@178@04) | live]
(push) ; 15
; [then-branch: 213 | 0 <= i1@178@04]
(assert (<= 0 i1@178@04))
; [eval] i1 < V
(push) ; 16
; [then-branch: 214 | i1@178@04 < V@28@04 | live]
; [else-branch: 214 | !(i1@178@04 < V@28@04) | live]
(push) ; 17
; [then-branch: 214 | i1@178@04 < V@28@04]
(assert (< i1@178@04 V@28@04))
; [eval] 0 <= j1
(push) ; 18
; [then-branch: 215 | 0 <= j1@179@04 | live]
; [else-branch: 215 | !(0 <= j1@179@04) | live]
(push) ; 19
; [then-branch: 215 | 0 <= j1@179@04]
(assert (<= 0 j1@179@04))
; [eval] j1 < V
(pop) ; 19
(push) ; 19
; [else-branch: 215 | !(0 <= j1@179@04)]
(assert (not (<= 0 j1@179@04)))
(pop) ; 19
(pop) ; 18
; Joined path conditions
; Joined path conditions
(pop) ; 17
(push) ; 17
; [else-branch: 214 | !(i1@178@04 < V@28@04)]
(assert (not (< i1@178@04 V@28@04)))
(pop) ; 17
(pop) ; 16
; Joined path conditions
; Joined path conditions
(pop) ; 15
(push) ; 15
; [else-branch: 213 | !(0 <= i1@178@04)]
(assert (not (<= 0 i1@178@04)))
(pop) ; 15
(pop) ; 14
; Joined path conditions
; Joined path conditions
(assert (and
  (and (and (< j1@179@04 V@28@04) (<= 0 j1@179@04)) (< i1@178@04 V@28@04))
  (<= 0 i1@178@04)))
(declare-const $k@180@04 $Perm)
(assert ($Perm.isReadVar $k@180@04 $Perm.Write))
; [eval] aloc(opt_get1(aloc(opt_get1(source), i1).option$array$), j1)
; [eval] opt_get1(aloc(opt_get1(source), i1).option$array$)
; [eval] aloc(opt_get1(source), i1)
; [eval] opt_get1(source)
(push) ; 14
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 14
; Joined path conditions
(push) ; 14
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 15
(assert (not (< i1@178@04 (alen<Int> (opt_get1 $Snap.unit source@26@04)))))
(check-sat)
; unsat
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               35444
;  :arith-add-rows          29485
;  :arith-assert-diseq      2161
;  :arith-assert-lower      11314
;  :arith-assert-upper      7080
;  :arith-bound-prop        2547
;  :arith-conflicts         755
;  :arith-eq-adapter        7086
;  :arith-fixed-eqs         3495
;  :arith-gcd-tests         1
;  :arith-grobner           118
;  :arith-ineq-splits       1
;  :arith-max-min           1044
;  :arith-nonlinear-bounds  95
;  :arith-nonlinear-horner  96
;  :arith-offset-eqs        3768
;  :arith-patches           1
;  :arith-pivots            5125
;  :conflicts               1810
;  :datatype-accessor-ax    102
;  :datatype-constructor-ax 885
;  :datatype-occurs-check   390
;  :datatype-splits         303
;  :decisions               5708
;  :del-clause              41767
;  :final-checks            280
;  :interface-eqs           25
;  :max-generation          9
;  :max-memory              10.04
;  :memory                  9.35
;  :minimized-lits          273
;  :mk-bool-var             55573
;  :mk-clause               41778
;  :num-allocs              515842
;  :num-checks              323
;  :propagations            26318
;  :quant-instantiations    12240
;  :restarts                1
;  :rlimit-count            1801825)
(assert (< i1@178@04 (alen<Int> (opt_get1 $Snap.unit source@26@04))))
(pop) ; 14
; Joined path conditions
(assert (< i1@178@04 (alen<Int> (opt_get1 $Snap.unit source@26@04))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@178@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@178@04)))
(push) ; 14
(assert (not (<
  $Perm.No
  (+
    (+
      (+
        (ite
          (and
            (<
              (inv@136@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@178@04))
              V@28@04)
            (<=
              0
              (inv@136@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@178@04))))
          (*
            (scale $Snap.unit (* (to_real (* V@28@04 V@28@04)) $Perm.Write))
            $k@135@04)
          $Perm.No)
        (ite
          (and
            (<
              (inv@128@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@178@04))
              V@28@04)
            (<=
              0
              (inv@128@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@178@04))))
          (*
            (scale $Snap.unit (* (to_real (* V@28@04 V@28@04)) $Perm.Write))
            $k@127@04)
          $Perm.No))
      (-
        (-
          (ite
            (and
              (<
                (inv@42@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@178@04))
                V@28@04)
              (<=
                0
                (inv@42@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@178@04))))
            $k@41@04
            $Perm.No)
          (pTaken@95@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@178@04)))
        (pTaken@106@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@178@04))))
    (-
      (-
        (ite
          (and
            (<
              (inv@34@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@178@04))
              V@28@04)
            (<=
              0
              (inv@34@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@178@04))))
          $k@33@04
          $Perm.No)
        (pTaken@96@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@178@04)))
      (pTaken@105@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@178@04)))))))
(check-sat)
; unsat
(pop) ; 14
; 0.02s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               36997
;  :arith-add-rows          30876
;  :arith-assert-diseq      2258
;  :arith-assert-lower      11803
;  :arith-assert-upper      7382
;  :arith-bound-prop        2665
;  :arith-conflicts         779
;  :arith-eq-adapter        7427
;  :arith-fixed-eqs         3655
;  :arith-gcd-tests         1
;  :arith-grobner           118
;  :arith-ineq-splits       1
;  :arith-max-min           1044
;  :arith-nonlinear-bounds  95
;  :arith-nonlinear-horner  96
;  :arith-offset-eqs        4030
;  :arith-patches           1
;  :arith-pivots            5299
;  :conflicts               1879
;  :datatype-accessor-ax    102
;  :datatype-constructor-ax 889
;  :datatype-occurs-check   390
;  :datatype-splits         303
;  :decisions               5859
;  :del-clause              43300
;  :final-checks            280
;  :interface-eqs           25
;  :max-generation          9
;  :max-memory              10.04
;  :memory                  9.37
;  :minimized-lits          304
;  :mk-bool-var             57763
;  :mk-clause               43486
;  :num-allocs              525805
;  :num-checks              324
;  :propagations            27780
;  :quant-instantiations    12854
;  :restarts                1
;  :rlimit-count            1866210
;  :time                    0.02)
(push) ; 14
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 15
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@178@04))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               36997
;  :arith-add-rows          30876
;  :arith-assert-diseq      2258
;  :arith-assert-lower      11803
;  :arith-assert-upper      7382
;  :arith-bound-prop        2665
;  :arith-conflicts         779
;  :arith-eq-adapter        7427
;  :arith-fixed-eqs         3655
;  :arith-gcd-tests         1
;  :arith-grobner           118
;  :arith-ineq-splits       1
;  :arith-max-min           1044
;  :arith-nonlinear-bounds  95
;  :arith-nonlinear-horner  96
;  :arith-offset-eqs        4030
;  :arith-patches           1
;  :arith-pivots            5299
;  :conflicts               1880
;  :datatype-accessor-ax    102
;  :datatype-constructor-ax 889
;  :datatype-occurs-check   390
;  :datatype-splits         303
;  :decisions               5859
;  :del-clause              43300
;  :final-checks            280
;  :interface-eqs           25
;  :max-generation          9
;  :max-memory              10.04
;  :memory                  9.37
;  :minimized-lits          304
;  :mk-bool-var             57763
;  :mk-clause               43486
;  :num-allocs              525896
;  :num-checks              325
;  :propagations            27780
;  :quant-instantiations    12854
;  :restarts                1
;  :rlimit-count            1866305)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@178@04))
    (as None<option<array>>  option<array>))))
(pop) ; 14
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@178@04))
    (as None<option<array>>  option<array>))))
(push) ; 14
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 15
(assert (not (<
  j1@179@04
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@178@04)))))))
(check-sat)
; unsat
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               37003
;  :arith-add-rows          30881
;  :arith-assert-diseq      2258
;  :arith-assert-lower      11806
;  :arith-assert-upper      7383
;  :arith-bound-prop        2665
;  :arith-conflicts         780
;  :arith-eq-adapter        7428
;  :arith-fixed-eqs         3656
;  :arith-gcd-tests         1
;  :arith-grobner           118
;  :arith-ineq-splits       1
;  :arith-max-min           1044
;  :arith-nonlinear-bounds  95
;  :arith-nonlinear-horner  96
;  :arith-offset-eqs        4030
;  :arith-patches           1
;  :arith-pivots            5303
;  :conflicts               1881
;  :datatype-accessor-ax    102
;  :datatype-constructor-ax 889
;  :datatype-occurs-check   390
;  :datatype-splits         303
;  :decisions               5859
;  :del-clause              43304
;  :final-checks            280
;  :interface-eqs           25
;  :max-generation          9
;  :max-memory              10.04
;  :memory                  9.37
;  :minimized-lits          304
;  :mk-bool-var             57774
;  :mk-clause               43490
;  :num-allocs              526089
;  :num-checks              326
;  :propagations            27782
;  :quant-instantiations    12861
;  :restarts                1
;  :rlimit-count            1866797)
(assert (<
  j1@179@04
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@178@04))))))
(pop) ; 14
; Joined path conditions
(assert (<
  j1@179@04
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@178@04))))))
(pop) ; 13
(declare-fun inv@181@04 ($Ref) Int)
(declare-fun inv@182@04 ($Ref) Int)
; Nested auxiliary terms: globals
(assert ($Perm.isReadVar $k@180@04 $Perm.Write))
; Nested auxiliary terms: non-globals
(assert (forall ((i1@178@04 Int) (j1@179@04 Int)) (!
  (and
    (< i1@178@04 (alen<Int> (opt_get1 $Snap.unit source@26@04)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@178@04)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@178@04))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@178@04))
        (as None<option<array>>  option<array>)))
    (<
      j1@179@04
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@178@04))))))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@178@04))) j1@179@04))
  :qid |int-aux|)))
(push) ; 13
(assert (not (forall ((i1@178@04 Int) (j1@179@04 Int)) (!
  (implies
    (and
      (and (and (< j1@179@04 V@28@04) (<= 0 j1@179@04)) (< i1@178@04 V@28@04))
      (<= 0 i1@178@04))
    (or (= $k@180@04 $Perm.No) (< $Perm.No $k@180@04)))
  
  ))))
(check-sat)
; unsat
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               37003
;  :arith-add-rows          30895
;  :arith-assert-diseq      2259
;  :arith-assert-lower      11808
;  :arith-assert-upper      7384
;  :arith-bound-prop        2665
;  :arith-conflicts         780
;  :arith-eq-adapter        7429
;  :arith-fixed-eqs         3656
;  :arith-gcd-tests         1
;  :arith-grobner           118
;  :arith-ineq-splits       1
;  :arith-max-min           1044
;  :arith-nonlinear-bounds  95
;  :arith-nonlinear-horner  96
;  :arith-offset-eqs        4030
;  :arith-patches           1
;  :arith-pivots            5322
;  :conflicts               1882
;  :datatype-accessor-ax    102
;  :datatype-constructor-ax 889
;  :datatype-occurs-check   390
;  :datatype-splits         303
;  :decisions               5859
;  :del-clause              43481
;  :final-checks            280
;  :interface-eqs           25
;  :max-generation          9
;  :max-memory              10.04
;  :memory                  9.34
;  :minimized-lits          304
;  :mk-bool-var             57783
;  :mk-clause               43492
;  :num-allocs              526609
;  :num-checks              327
;  :propagations            27783
;  :quant-instantiations    12861
;  :restarts                1
;  :rlimit-count            1867969)
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 13
(assert (not (forall ((i11@178@04 Int) (j11@179@04 Int) (i12@178@04 Int) (j12@179@04 Int)) (!
  (implies
    (and
      (and
        (and
          (and
            (and
              (and (< j11@179@04 V@28@04) (<= 0 j11@179@04))
              (< i11@178@04 V@28@04))
            (<= 0 i11@178@04))
          ($FVF.loc_int ($FVF.lookup_int (as sm@152@04  $FVF<Int>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@26@04) i11@178@04))) j11@179@04)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@26@04) i11@178@04))) j11@179@04)))
        (< $Perm.No $k@180@04))
      (and
        (and
          (and
            (and
              (and (< j12@179@04 V@28@04) (<= 0 j12@179@04))
              (< i12@178@04 V@28@04))
            (<= 0 i12@178@04))
          ($FVF.loc_int ($FVF.lookup_int (as sm@152@04  $FVF<Int>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@26@04) i12@178@04))) j12@179@04)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@26@04) i12@178@04))) j12@179@04)))
        (< $Perm.No $k@180@04))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@26@04) i11@178@04))) j11@179@04)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@26@04) i12@178@04))) j12@179@04)))
    (and (= i11@178@04 i12@178@04) (= j11@179@04 j12@179@04)))
  
  :qid |int-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               37065
;  :arith-add-rows          30910
;  :arith-assert-diseq      2259
;  :arith-assert-lower      11818
;  :arith-assert-upper      7385
;  :arith-bound-prop        2666
;  :arith-conflicts         780
;  :arith-eq-adapter        7448
;  :arith-fixed-eqs         3656
;  :arith-gcd-tests         1
;  :arith-grobner           118
;  :arith-ineq-splits       1
;  :arith-max-min           1044
;  :arith-nonlinear-bounds  95
;  :arith-nonlinear-horner  96
;  :arith-offset-eqs        4031
;  :arith-patches           1
;  :arith-pivots            5330
;  :conflicts               1883
;  :datatype-accessor-ax    102
;  :datatype-constructor-ax 889
;  :datatype-occurs-check   390
;  :datatype-splits         303
;  :decisions               5859
;  :del-clause              43812
;  :final-checks            280
;  :interface-eqs           25
;  :max-generation          9
;  :max-memory              10.04
;  :memory                  9.35
;  :minimized-lits          304
;  :mk-bool-var             58233
;  :mk-clause               43823
;  :num-allocs              529072
;  :num-checks              328
;  :propagations            27808
;  :quant-instantiations    12998
;  :restarts                1
;  :rlimit-count            1875930
;  :time                    0.00)
; Definitional axioms for inverse functions
(assert (forall ((i1@178@04 Int) (j1@179@04 Int)) (!
  (implies
    (and
      (and
        (and (and (< j1@179@04 V@28@04) (<= 0 j1@179@04)) (< i1@178@04 V@28@04))
        (<= 0 i1@178@04))
      (< $Perm.No $k@180@04))
    (and
      (=
        (inv@181@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@178@04))) j1@179@04))
        i1@178@04)
      (=
        (inv@182@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@178@04))) j1@179@04))
        j1@179@04)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@178@04))) j1@179@04))
  :qid |int-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and
          (and (< (inv@182@04 r) V@28@04) (<= 0 (inv@182@04 r)))
          (< (inv@181@04 r) V@28@04))
        (<= 0 (inv@181@04 r)))
      (< $Perm.No $k@180@04))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@26@04) (inv@181@04 r)))) (inv@182@04 r))
      r))
  :pattern ((inv@181@04 r))
  :pattern ((inv@182@04 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@182@04 r) V@28@04) (<= 0 (inv@182@04 r)))
        (< (inv@181@04 r) V@28@04))
      (<= 0 (inv@181@04 r)))
    ($FVF.loc_int ($FVF.lookup_int (as sm@152@04  $FVF<Int>) r) r))
  :pattern ((inv@181@04 r) (inv@182@04 r))
  )))
; Precomputing data for removing quantified permissions
(define-fun pTaken@183@04 ((r $Ref)) $Perm
  (ite
    (and
      (and
        (and (< (inv@182@04 r) V@28@04) (<= 0 (inv@182@04 r)))
        (< (inv@181@04 r) V@28@04))
      (<= 0 (inv@181@04 r)))
    ($Perm.min
      (ite
        (and
          (and
            (and (< (inv@151@04 r) V@28@04) (<= 0 (inv@151@04 r)))
            (< (inv@150@04 r) V@28@04))
          (<= 0 (inv@150@04 r)))
        $k@149@04
        $Perm.No)
      $k@180@04)
    $Perm.No))
(define-fun pTaken@184@04 ((r $Ref)) $Perm
  (ite
    (and
      (and
        (and (< (inv@182@04 r) V@28@04) (<= 0 (inv@182@04 r)))
        (< (inv@181@04 r) V@28@04))
      (<= 0 (inv@181@04 r)))
    ($Perm.min
      (ite
        (and
          (and
            (and (< (inv@145@04 r) V@28@04) (<= 0 (inv@145@04 r)))
            (< (inv@144@04 r) V@28@04))
          (<= 0 (inv@144@04 r)))
        $Perm.Write
        $Perm.No)
      (- $k@180@04 (pTaken@183@04 r)))
    $Perm.No))
(define-fun pTaken@185@04 ((r $Ref)) $Perm
  (ite
    (and
      (and
        (and (< (inv@182@04 r) V@28@04) (<= 0 (inv@182@04 r)))
        (< (inv@181@04 r) V@28@04))
      (<= 0 (inv@181@04 r)))
    ($Perm.min
      (-
        (ite
          (and
            (and
              (and (< (inv@52@04 r) V@28@04) (<= 0 (inv@52@04 r)))
              (< (inv@51@04 r) V@28@04))
            (<= 0 (inv@51@04 r)))
          $k@50@04
          $Perm.No)
        (pTaken@122@04 r))
      (- (- $k@180@04 (pTaken@183@04 r)) (pTaken@184@04 r)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Constrain original permissions $k@180@04
(assert (forall ((r $Ref)) (!
  (implies
    (not
      (=
        (ite
          (and
            (and
              (and (< (inv@151@04 r) V@28@04) (<= 0 (inv@151@04 r)))
              (< (inv@150@04 r) V@28@04))
            (<= 0 (inv@150@04 r)))
          $k@149@04
          $Perm.No)
        $Perm.No))
    (ite
      (and
        (and
          (and (< (inv@151@04 r) V@28@04) (<= 0 (inv@151@04 r)))
          (< (inv@150@04 r) V@28@04))
        (<= 0 (inv@150@04 r)))
      (<
        (ite
          (and
            (and
              (and (< (inv@182@04 r) V@28@04) (<= 0 (inv@182@04 r)))
              (< (inv@181@04 r) V@28@04))
            (<= 0 (inv@181@04 r)))
          $k@180@04
          $Perm.No)
        $k@149@04)
      (<
        (ite
          (and
            (and
              (and (< (inv@182@04 r) V@28@04) (<= 0 (inv@182@04 r)))
              (< (inv@181@04 r) V@28@04))
            (<= 0 (inv@181@04 r)))
          $k@180@04
          $Perm.No)
        $Perm.No)))
  :pattern ((inv@151@04 r))
  :pattern ((inv@150@04 r))
  :pattern ((inv@182@04 r))
  :pattern ((inv@181@04 r))
  :qid |qp.srp57|)))
; Intermediate check if already taken enough permissions
(set-option :timeout 500)
(push) ; 13
(assert (not (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@182@04 r) V@28@04) (<= 0 (inv@182@04 r)))
        (< (inv@181@04 r) V@28@04))
      (<= 0 (inv@181@04 r)))
    (= (- $k@180@04 (pTaken@183@04 r)) $Perm.No))
  
  ))))
(check-sat)
; unsat
(pop) ; 13
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               37292
;  :arith-add-rows          31003
;  :arith-assert-diseq      2268
;  :arith-assert-lower      11870
;  :arith-assert-upper      7415
;  :arith-bound-prop        2682
;  :arith-conflicts         784
;  :arith-eq-adapter        7480
;  :arith-fixed-eqs         3670
;  :arith-gcd-tests         1
;  :arith-grobner           123
;  :arith-ineq-splits       1
;  :arith-max-min           1070
;  :arith-nonlinear-bounds  98
;  :arith-nonlinear-horner  100
;  :arith-offset-eqs        4053
;  :arith-patches           1
;  :arith-pivots            5373
;  :conflicts               1892
;  :datatype-accessor-ax    102
;  :datatype-constructor-ax 901
;  :datatype-occurs-check   395
;  :datatype-splits         307
;  :decisions               5875
;  :del-clause              44308
;  :final-checks            284
;  :interface-eqs           25
;  :max-generation          9
;  :max-memory              10.04
;  :memory                  9.39
;  :minimized-lits          305
;  :mk-bool-var             58895
;  :mk-clause               44317
;  :num-allocs              534124
;  :num-checks              330
;  :propagations            27888
;  :quant-instantiations    13189
;  :restarts                1
;  :rlimit-count            1893318
;  :time                    0.01)
; Final check if taken enough permissions
; Done removing quantified permissions
; Definitional axioms for snapshot map values
; [eval] exc == null
(set-option :timeout 10)
(push) ; 13
(assert (not (not (= exc@123@04 $Ref.null))))
(check-sat)
; unknown
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               37329
;  :arith-add-rows          31003
;  :arith-assert-diseq      2268
;  :arith-assert-lower      11870
;  :arith-assert-upper      7415
;  :arith-bound-prop        2682
;  :arith-conflicts         784
;  :arith-eq-adapter        7480
;  :arith-fixed-eqs         3670
;  :arith-gcd-tests         1
;  :arith-grobner           123
;  :arith-ineq-splits       1
;  :arith-max-min           1070
;  :arith-nonlinear-bounds  98
;  :arith-nonlinear-horner  100
;  :arith-offset-eqs        4053
;  :arith-patches           1
;  :arith-pivots            5373
;  :conflicts               1892
;  :datatype-accessor-ax    102
;  :datatype-constructor-ax 909
;  :datatype-occurs-check   400
;  :datatype-splits         311
;  :decisions               5883
;  :del-clause              44308
;  :final-checks            286
;  :interface-eqs           25
;  :max-generation          9
;  :max-memory              10.04
;  :memory                  9.39
;  :minimized-lits          305
;  :mk-bool-var             58899
;  :mk-clause               44317
;  :num-allocs              534792
;  :num-checks              331
;  :propagations            27888
;  :quant-instantiations    13189
;  :restarts                1
;  :rlimit-count            1894144)
; [then-branch: 216 | exc@123@04 == Null | live]
; [else-branch: 216 | exc@123@04 != Null | dead]
(push) ; 13
; [then-branch: 216 | exc@123@04 == Null]
(declare-const i1@186@04 Int)
(declare-const j1@187@04 Int)
(push) ; 14
; [eval] 0 <= i1 && i1 < V && (0 <= j1 && j1 < V)
; [eval] 0 <= i1
(push) ; 15
; [then-branch: 217 | 0 <= i1@186@04 | live]
; [else-branch: 217 | !(0 <= i1@186@04) | live]
(push) ; 16
; [then-branch: 217 | 0 <= i1@186@04]
(assert (<= 0 i1@186@04))
; [eval] i1 < V
(push) ; 17
; [then-branch: 218 | i1@186@04 < V@28@04 | live]
; [else-branch: 218 | !(i1@186@04 < V@28@04) | live]
(push) ; 18
; [then-branch: 218 | i1@186@04 < V@28@04]
(assert (< i1@186@04 V@28@04))
; [eval] 0 <= j1
(push) ; 19
; [then-branch: 219 | 0 <= j1@187@04 | live]
; [else-branch: 219 | !(0 <= j1@187@04) | live]
(push) ; 20
; [then-branch: 219 | 0 <= j1@187@04]
(assert (<= 0 j1@187@04))
; [eval] j1 < V
(pop) ; 20
(push) ; 20
; [else-branch: 219 | !(0 <= j1@187@04)]
(assert (not (<= 0 j1@187@04)))
(pop) ; 20
(pop) ; 19
; Joined path conditions
; Joined path conditions
(pop) ; 18
(push) ; 18
; [else-branch: 218 | !(i1@186@04 < V@28@04)]
(assert (not (< i1@186@04 V@28@04)))
(pop) ; 18
(pop) ; 17
; Joined path conditions
; Joined path conditions
(pop) ; 16
(push) ; 16
; [else-branch: 217 | !(0 <= i1@186@04)]
(assert (not (<= 0 i1@186@04)))
(pop) ; 16
(pop) ; 15
; Joined path conditions
; Joined path conditions
(assert (and
  (and (and (< j1@187@04 V@28@04) (<= 0 j1@187@04)) (< i1@186@04 V@28@04))
  (<= 0 i1@186@04)))
; [eval] aloc(opt_get1(aloc(opt_get1(target), i1).option$array$), j1)
; [eval] opt_get1(aloc(opt_get1(target), i1).option$array$)
; [eval] aloc(opt_get1(target), i1)
; [eval] opt_get1(target)
(push) ; 15
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 15
; Joined path conditions
(push) ; 15
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 16
(assert (not (< i1@186@04 (alen<Int> (opt_get1 $Snap.unit target@27@04)))))
(check-sat)
; unsat
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               37329
;  :arith-add-rows          31003
;  :arith-assert-diseq      2268
;  :arith-assert-lower      11876
;  :arith-assert-upper      7415
;  :arith-bound-prop        2682
;  :arith-conflicts         784
;  :arith-eq-adapter        7480
;  :arith-fixed-eqs         3670
;  :arith-gcd-tests         1
;  :arith-grobner           123
;  :arith-ineq-splits       1
;  :arith-max-min           1070
;  :arith-nonlinear-bounds  98
;  :arith-nonlinear-horner  100
;  :arith-offset-eqs        4053
;  :arith-patches           1
;  :arith-pivots            5376
;  :conflicts               1892
;  :datatype-accessor-ax    102
;  :datatype-constructor-ax 909
;  :datatype-occurs-check   400
;  :datatype-splits         311
;  :decisions               5883
;  :del-clause              44308
;  :final-checks            286
;  :interface-eqs           25
;  :max-generation          9
;  :max-memory              10.04
;  :memory                  9.39
;  :minimized-lits          305
;  :mk-bool-var             58905
;  :mk-clause               44317
;  :num-allocs              535066
;  :num-checks              332
;  :propagations            27888
;  :quant-instantiations    13189
;  :restarts                1
;  :rlimit-count            1894628)
(assert (< i1@186@04 (alen<Int> (opt_get1 $Snap.unit target@27@04))))
(pop) ; 15
; Joined path conditions
(assert (< i1@186@04 (alen<Int> (opt_get1 $Snap.unit target@27@04))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@186@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@186@04)))
(push) ; 15
(assert (not (<
  $Perm.No
  (+
    (+
      (+
        (ite
          (and
            (<
              (inv@136@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@186@04))
              V@28@04)
            (<=
              0
              (inv@136@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@186@04))))
          (*
            (scale $Snap.unit (* (to_real (* V@28@04 V@28@04)) $Perm.Write))
            $k@135@04)
          $Perm.No)
        (ite
          (and
            (<
              (inv@128@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@186@04))
              V@28@04)
            (<=
              0
              (inv@128@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@186@04))))
          (*
            (scale $Snap.unit (* (to_real (* V@28@04 V@28@04)) $Perm.Write))
            $k@127@04)
          $Perm.No))
      (-
        (-
          (ite
            (and
              (<
                (inv@42@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@186@04))
                V@28@04)
              (<=
                0
                (inv@42@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@186@04))))
            $k@41@04
            $Perm.No)
          (pTaken@95@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@186@04)))
        (pTaken@106@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@186@04))))
    (-
      (-
        (ite
          (and
            (<
              (inv@34@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@186@04))
              V@28@04)
            (<=
              0
              (inv@34@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@186@04))))
          $k@33@04
          $Perm.No)
        (pTaken@96@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@186@04)))
      (pTaken@105@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@186@04)))))))
(check-sat)
; unsat
(pop) ; 15
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               37961
;  :arith-add-rows          31684
;  :arith-assert-diseq      2294
;  :arith-assert-lower      12114
;  :arith-assert-upper      7576
;  :arith-bound-prop        2739
;  :arith-conflicts         803
;  :arith-eq-adapter        7628
;  :arith-fixed-eqs         3751
;  :arith-gcd-tests         1
;  :arith-grobner           123
;  :arith-ineq-splits       1
;  :arith-max-min           1070
;  :arith-nonlinear-bounds  98
;  :arith-nonlinear-horner  100
;  :arith-offset-eqs        4132
;  :arith-patches           1
;  :arith-pivots            5475
;  :conflicts               1928
;  :datatype-accessor-ax    102
;  :datatype-constructor-ax 913
;  :datatype-occurs-check   400
;  :datatype-splits         311
;  :decisions               5993
;  :del-clause              44844
;  :final-checks            286
;  :interface-eqs           25
;  :max-generation          9
;  :max-memory              10.04
;  :memory                  9.45
;  :minimized-lits          306
;  :mk-bool-var             59860
;  :mk-clause               45018
;  :num-allocs              539212
;  :num-checks              333
;  :propagations            28371
;  :quant-instantiations    13358
;  :restarts                1
;  :rlimit-count            1922400
;  :time                    0.01)
(push) ; 15
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 16
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@186@04))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               37961
;  :arith-add-rows          31684
;  :arith-assert-diseq      2294
;  :arith-assert-lower      12114
;  :arith-assert-upper      7576
;  :arith-bound-prop        2739
;  :arith-conflicts         803
;  :arith-eq-adapter        7628
;  :arith-fixed-eqs         3751
;  :arith-gcd-tests         1
;  :arith-grobner           123
;  :arith-ineq-splits       1
;  :arith-max-min           1070
;  :arith-nonlinear-bounds  98
;  :arith-nonlinear-horner  100
;  :arith-offset-eqs        4132
;  :arith-patches           1
;  :arith-pivots            5475
;  :conflicts               1929
;  :datatype-accessor-ax    102
;  :datatype-constructor-ax 913
;  :datatype-occurs-check   400
;  :datatype-splits         311
;  :decisions               5993
;  :del-clause              44844
;  :final-checks            286
;  :interface-eqs           25
;  :max-generation          9
;  :max-memory              10.04
;  :memory                  9.45
;  :minimized-lits          306
;  :mk-bool-var             59860
;  :mk-clause               45018
;  :num-allocs              539307
;  :num-checks              334
;  :propagations            28371
;  :quant-instantiations    13358
;  :restarts                1
;  :rlimit-count            1922495)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@186@04))
    (as None<option<array>>  option<array>))))
(pop) ; 15
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@186@04))
    (as None<option<array>>  option<array>))))
(push) ; 15
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 16
(assert (not (<
  j1@187@04
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@186@04)))))))
(check-sat)
; unsat
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               37967
;  :arith-add-rows          31689
;  :arith-assert-diseq      2294
;  :arith-assert-lower      12116
;  :arith-assert-upper      7578
;  :arith-bound-prop        2739
;  :arith-conflicts         804
;  :arith-eq-adapter        7629
;  :arith-fixed-eqs         3752
;  :arith-gcd-tests         1
;  :arith-grobner           123
;  :arith-ineq-splits       1
;  :arith-max-min           1070
;  :arith-nonlinear-bounds  98
;  :arith-nonlinear-horner  100
;  :arith-offset-eqs        4132
;  :arith-patches           1
;  :arith-pivots            5479
;  :conflicts               1930
;  :datatype-accessor-ax    102
;  :datatype-constructor-ax 913
;  :datatype-occurs-check   400
;  :datatype-splits         311
;  :decisions               5993
;  :del-clause              44848
;  :final-checks            286
;  :interface-eqs           25
;  :max-generation          9
;  :max-memory              10.04
;  :memory                  9.44
;  :minimized-lits          306
;  :mk-bool-var             59871
;  :mk-clause               45022
;  :num-allocs              539516
;  :num-checks              335
;  :propagations            28373
;  :quant-instantiations    13367
;  :restarts                1
;  :rlimit-count            1923048)
(assert (<
  j1@187@04
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@186@04))))))
(pop) ; 15
; Joined path conditions
(assert (<
  j1@187@04
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@186@04))))))
(pop) ; 14
(declare-fun inv@188@04 ($Ref) Int)
(declare-fun inv@189@04 ($Ref) Int)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(assert (forall ((i1@186@04 Int) (j1@187@04 Int)) (!
  (and
    (< i1@186@04 (alen<Int> (opt_get1 $Snap.unit target@27@04)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@186@04)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@186@04))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@186@04))
        (as None<option<array>>  option<array>)))
    (<
      j1@187@04
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@186@04))))))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@186@04))) j1@187@04))
  :qid |int-aux|)))
(declare-const sm@190@04 $FVF<Int>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (ite
          (and
            (and
              (and (< (inv@52@04 r) V@28@04) (<= 0 (inv@52@04 r)))
              (< (inv@51@04 r) V@28@04))
            (<= 0 (inv@51@04 r)))
          $k@50@04
          $Perm.No)
        (pTaken@122@04 r)))
    (=
      ($FVF.lookup_int (as sm@190@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@31@04))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@190@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@31@04))))))))))))))) r))
  :qid |qp.fvfValDef58|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@145@04 r) V@28@04) (<= 0 (inv@145@04 r)))
        (< (inv@144@04 r) V@28@04))
      (<= 0 (inv@144@04 r)))
    (=
      ($FVF.lookup_int (as sm@190@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@04))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@190@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@04))))))))))))))) r))
  :qid |qp.fvfValDef59|)))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (ite
          (and
            (and
              (and (< (inv@151@04 r) V@28@04) (<= 0 (inv@151@04 r)))
              (< (inv@150@04 r) V@28@04))
            (<= 0 (inv@150@04 r)))
          $k@149@04
          $Perm.No)
        (pTaken@183@04 r)))
    (=
      ($FVF.lookup_int (as sm@190@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@04)))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@190@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@04)))))))))))))))) r))
  :qid |qp.fvfValDef60|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@31@04))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@04))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@04)))))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@190@04  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef61|)))
; Check receiver injectivity
(push) ; 14
(assert (not (forall ((i11@186@04 Int) (j11@187@04 Int) (i12@186@04 Int) (j12@187@04 Int)) (!
  (implies
    (and
      (and
        (and
          (and
            (and (< j11@187@04 V@28@04) (<= 0 j11@187@04))
            (< i11@186@04 V@28@04))
          (<= 0 i11@186@04))
        ($FVF.loc_int ($FVF.lookup_int (as sm@190@04  $FVF<Int>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@27@04) i11@186@04))) j11@187@04)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@27@04) i11@186@04))) j11@187@04)))
      (and
        (and
          (and
            (and (< j12@187@04 V@28@04) (<= 0 j12@187@04))
            (< i12@186@04 V@28@04))
          (<= 0 i12@186@04))
        ($FVF.loc_int ($FVF.lookup_int (as sm@190@04  $FVF<Int>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@27@04) i12@186@04))) j12@187@04)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@27@04) i12@186@04))) j12@187@04)))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@27@04) i11@186@04))) j11@187@04)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@27@04) i12@186@04))) j12@187@04)))
    (and (= i11@186@04 i12@186@04) (= j11@187@04 j12@187@04)))
  
  :qid |int-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               38028
;  :arith-add-rows          31710
;  :arith-assert-diseq      2294
;  :arith-assert-lower      12126
;  :arith-assert-upper      7579
;  :arith-bound-prop        2740
;  :arith-conflicts         804
;  :arith-eq-adapter        7649
;  :arith-fixed-eqs         3752
;  :arith-gcd-tests         1
;  :arith-grobner           123
;  :arith-ineq-splits       1
;  :arith-max-min           1070
;  :arith-nonlinear-bounds  98
;  :arith-nonlinear-horner  100
;  :arith-offset-eqs        4133
;  :arith-patches           1
;  :arith-pivots            5496
;  :conflicts               1931
;  :datatype-accessor-ax    102
;  :datatype-constructor-ax 913
;  :datatype-occurs-check   400
;  :datatype-splits         311
;  :decisions               5993
;  :del-clause              45357
;  :final-checks            286
;  :interface-eqs           25
;  :max-generation          9
;  :max-memory              10.04
;  :memory                  9.45
;  :minimized-lits          306
;  :mk-bool-var             60337
;  :mk-clause               45366
;  :num-allocs              543023
;  :num-checks              336
;  :propagations            28400
;  :quant-instantiations    13510
;  :restarts                1
;  :rlimit-count            1935600
;  :time                    0.00)
; Definitional axioms for inverse functions
(assert (forall ((i1@186@04 Int) (j1@187@04 Int)) (!
  (implies
    (and
      (and (and (< j1@187@04 V@28@04) (<= 0 j1@187@04)) (< i1@186@04 V@28@04))
      (<= 0 i1@186@04))
    (and
      (=
        (inv@188@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@186@04))) j1@187@04))
        i1@186@04)
      (=
        (inv@189@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@186@04))) j1@187@04))
        j1@187@04)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@186@04))) j1@187@04))
  :qid |int-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@189@04 r) V@28@04) (<= 0 (inv@189@04 r)))
        (< (inv@188@04 r) V@28@04))
      (<= 0 (inv@188@04 r)))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@27@04) (inv@188@04 r)))) (inv@189@04 r))
      r))
  :pattern ((inv@188@04 r))
  :pattern ((inv@189@04 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@189@04 r) V@28@04) (<= 0 (inv@189@04 r)))
        (< (inv@188@04 r) V@28@04))
      (<= 0 (inv@188@04 r)))
    ($FVF.loc_int ($FVF.lookup_int (as sm@190@04  $FVF<Int>) r) r))
  :pattern ((inv@188@04 r) (inv@189@04 r))
  )))
; Precomputing data for removing quantified permissions
(define-fun pTaken@191@04 ((r $Ref)) $Perm
  (ite
    (and
      (and
        (and (< (inv@189@04 r) V@28@04) (<= 0 (inv@189@04 r)))
        (< (inv@188@04 r) V@28@04))
      (<= 0 (inv@188@04 r)))
    ($Perm.min
      (-
        (ite
          (and
            (and
              (and (< (inv@52@04 r) V@28@04) (<= 0 (inv@52@04 r)))
              (< (inv@51@04 r) V@28@04))
            (<= 0 (inv@51@04 r)))
          $k@50@04
          $Perm.No)
        (pTaken@122@04 r))
      $Perm.Write)
    $Perm.No))
(define-fun pTaken@192@04 ((r $Ref)) $Perm
  (ite
    (and
      (and
        (and (< (inv@189@04 r) V@28@04) (<= 0 (inv@189@04 r)))
        (< (inv@188@04 r) V@28@04))
      (<= 0 (inv@188@04 r)))
    ($Perm.min
      (ite
        (and
          (and
            (and (< (inv@145@04 r) V@28@04) (<= 0 (inv@145@04 r)))
            (< (inv@144@04 r) V@28@04))
          (<= 0 (inv@144@04 r)))
        $Perm.Write
        $Perm.No)
      (- $Perm.Write (pTaken@191@04 r)))
    $Perm.No))
(define-fun pTaken@193@04 ((r $Ref)) $Perm
  (ite
    (and
      (and
        (and (< (inv@189@04 r) V@28@04) (<= 0 (inv@189@04 r)))
        (< (inv@188@04 r) V@28@04))
      (<= 0 (inv@188@04 r)))
    ($Perm.min
      (-
        (ite
          (and
            (and
              (and (< (inv@151@04 r) V@28@04) (<= 0 (inv@151@04 r)))
              (< (inv@150@04 r) V@28@04))
            (<= 0 (inv@150@04 r)))
          $k@149@04
          $Perm.No)
        (pTaken@183@04 r))
      (- (- $Perm.Write (pTaken@191@04 r)) (pTaken@192@04 r)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 500)
(push) ; 14
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (-
        (ite
          (and
            (and
              (and (< (inv@52@04 r) V@28@04) (<= 0 (inv@52@04 r)))
              (< (inv@51@04 r) V@28@04))
            (<= 0 (inv@51@04 r)))
          $k@50@04
          $Perm.No)
        (pTaken@122@04 r))
      (pTaken@191@04 r))
    $Perm.No)
  
  ))))
(check-sat)
; unknown
(pop) ; 14
; 0.22s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               44686
;  :arith-add-rows          35337
;  :arith-assert-diseq      2643
;  :arith-assert-lower      14163
;  :arith-assert-upper      8798
;  :arith-bound-prop        3007
;  :arith-conflicts         834
;  :arith-eq-adapter        8853
;  :arith-fixed-eqs         4467
;  :arith-gcd-tests         1
;  :arith-grobner           288
;  :arith-ineq-splits       1
;  :arith-max-min           1243
;  :arith-nonlinear-bounds  121
;  :arith-nonlinear-horner  250
;  :arith-offset-eqs        5253
;  :arith-patches           1
;  :arith-pivots            6188
;  :conflicts               1998
;  :datatype-accessor-ax    141
;  :datatype-constructor-ax 1026
;  :datatype-occurs-check   487
;  :datatype-splits         424
;  :decisions               7072
;  :del-clause              53428
;  :final-checks            328
;  :interface-eqs           39
;  :max-generation          10
;  :max-memory              11.74
;  :memory                  11.56
;  :minimized-lits          311
;  :mk-bool-var             70549
;  :mk-clause               53437
;  :num-allocs              629616
;  :num-checks              338
;  :propagations            32988
;  :quant-instantiations    16304
;  :restarts                1
;  :rlimit-count            2786726
;  :time                    0.22)
; Intermediate check if already taken enough permissions
(push) ; 14
(assert (not (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@189@04 r) V@28@04) (<= 0 (inv@189@04 r)))
        (< (inv@188@04 r) V@28@04))
      (<= 0 (inv@188@04 r)))
    (= (- $Perm.Write (pTaken@191@04 r)) $Perm.No))
  
  ))))
(check-sat)
; unknown
(pop) ; 14
; 0.52s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               84065
;  :arith-add-rows          61393
;  :arith-assert-diseq      5161
;  :arith-assert-lower      27312
;  :arith-assert-upper      17707
;  :arith-bound-prop        4469
;  :arith-conflicts         933
;  :arith-eq-adapter        14256
;  :arith-fixed-eqs         9683
;  :arith-gcd-tests         3
;  :arith-grobner           289
;  :arith-ineq-splits       2
;  :arith-max-min           1655
;  :arith-nonlinear-bounds  170
;  :arith-nonlinear-horner  349
;  :arith-offset-eqs        11994
;  :arith-patches           3
;  :arith-pivots            8703
;  :arith-pseudo-nonlinear  60
;  :conflicts               2214
;  :datatype-accessor-ax    315
;  :datatype-constructor-ax 1459
;  :datatype-occurs-check   817
;  :datatype-splits         857
;  :decisions               13001
;  :del-clause              83652
;  :final-checks            434
;  :interface-eqs           64
;  :max-generation          14
;  :max-memory              15.34
;  :memory                  14.77
;  :minimized-lits          507
;  :mk-bool-var             103898
;  :mk-clause               83661
;  :num-allocs              752999
;  :num-checks              339
;  :propagations            64674
;  :quant-instantiations    24766
;  :restarts                2
;  :rlimit-count            4019567
;  :time                    0.52)
; Chunk depleted?
(push) ; 14
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and
          (and
            (and (< (inv@145@04 r) V@28@04) (<= 0 (inv@145@04 r)))
            (< (inv@144@04 r) V@28@04))
          (<= 0 (inv@144@04 r)))
        $Perm.Write
        $Perm.No)
      (pTaken@192@04 r))
    $Perm.No)
  
  ))))
(check-sat)
; unknown
(pop) ; 14
; 0.50s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               114634
;  :arith-add-rows          79595
;  :arith-assert-diseq      7077
;  :arith-assert-lower      38175
;  :arith-assert-upper      25061
;  :arith-bound-prop        5455
;  :arith-conflicts         1035
;  :arith-eq-adapter        19454
;  :arith-fixed-eqs         13825
;  :arith-gcd-tests         3
;  :arith-grobner           289
;  :arith-ineq-splits       2
;  :arith-max-min           1896
;  :arith-nonlinear-bounds  230
;  :arith-nonlinear-horner  349
;  :arith-offset-eqs        17288
;  :arith-patches           4
;  :arith-patches_succ      1
;  :arith-pivots            10917
;  :arith-pseudo-nonlinear  60
;  :conflicts               2417
;  :datatype-accessor-ax    401
;  :datatype-constructor-ax 1698
;  :datatype-occurs-check   999
;  :datatype-splits         1090
;  :decisions               18335
;  :del-clause              111783
;  :final-checks            507
;  :interface-eqs           91
;  :max-generation          14
;  :max-memory              18.34
;  :memory                  17.03
;  :minimized-lits          647
;  :mk-bool-var             135264
;  :mk-clause               111792
;  :num-allocs              850018
;  :num-checks              340
;  :propagations            87673
;  :quant-instantiations    32339
;  :restarts                3
;  :rlimit-count            5010094
;  :time                    0.51)
; Intermediate check if already taken enough permissions
(push) ; 14
(assert (not (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@189@04 r) V@28@04) (<= 0 (inv@189@04 r)))
        (< (inv@188@04 r) V@28@04))
      (<= 0 (inv@188@04 r)))
    (= (- (- $Perm.Write (pTaken@191@04 r)) (pTaken@192@04 r)) $Perm.No))
  
  ))))
(check-sat)
; unsat
(pop) ; 14
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               114966
;  :arith-add-rows          79741
;  :arith-assert-diseq      7092
;  :arith-assert-lower      38243
;  :arith-assert-upper      25112
;  :arith-bound-prop        5479
;  :arith-conflicts         1043
;  :arith-eq-adapter        19524
;  :arith-fixed-eqs         13852
;  :arith-gcd-tests         3
;  :arith-grobner           289
;  :arith-ineq-splits       2
;  :arith-max-min           1896
;  :arith-nonlinear-bounds  230
;  :arith-nonlinear-horner  349
;  :arith-offset-eqs        17312
;  :arith-patches           4
;  :arith-patches_succ      1
;  :arith-pivots            10980
;  :arith-pseudo-nonlinear  60
;  :conflicts               2434
;  :datatype-accessor-ax    401
;  :datatype-constructor-ax 1702
;  :datatype-occurs-check   999
;  :datatype-splits         1090
;  :decisions               18351
;  :del-clause              112618
;  :final-checks            507
;  :interface-eqs           91
;  :max-generation          14
;  :max-memory              18.34
;  :memory                  17.01
;  :minimized-lits          658
;  :mk-bool-var             136397
;  :mk-clause               112627
;  :num-allocs              855108
;  :num-checks              341
;  :propagations            87858
;  :quant-instantiations    32637
;  :restarts                3
;  :rlimit-count            5032053
;  :time                    0.01)
; Final check if taken enough permissions
; Done removing quantified permissions
; Definitional axioms for snapshot map values
; [eval] exc == null ==> (forall unknown: Int :: { opt_get1(aloc(opt_get1(target), unknown).option$array$) } { opt_get1(aloc(opt_get1(source), unknown).option$array$) } 0 <= unknown && unknown < V ==> (forall unknown1: Int :: { aloc(opt_get1(aloc(opt_get1(target), unknown).option$array$), unknown1) } { aloc(opt_get1(aloc(opt_get1(source), unknown).option$array$), unknown1) } 0 <= unknown1 && unknown1 < V ==> aloc(opt_get1(aloc(opt_get1(target), unknown).option$array$), unknown1).int == aloc(opt_get1(aloc(opt_get1(source), unknown).option$array$), unknown1).int))
; [eval] exc == null
(push) ; 14
(set-option :timeout 10)
(push) ; 15
(assert (not (not (= exc@123@04 $Ref.null))))
(check-sat)
; unknown
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               115003
;  :arith-add-rows          79741
;  :arith-assert-diseq      7092
;  :arith-assert-lower      38258
;  :arith-assert-upper      25120
;  :arith-bound-prop        5479
;  :arith-conflicts         1043
;  :arith-eq-adapter        19524
;  :arith-fixed-eqs         13852
;  :arith-gcd-tests         3
;  :arith-grobner           294
;  :arith-ineq-splits       2
;  :arith-max-min           1922
;  :arith-nonlinear-bounds  233
;  :arith-nonlinear-horner  353
;  :arith-offset-eqs        17312
;  :arith-patches           4
;  :arith-patches_succ      1
;  :arith-pivots            10980
;  :arith-pseudo-nonlinear  60
;  :conflicts               2434
;  :datatype-accessor-ax    401
;  :datatype-constructor-ax 1710
;  :datatype-occurs-check   1004
;  :datatype-splits         1094
;  :decisions               18359
;  :del-clause              112618
;  :final-checks            511
;  :interface-eqs           91
;  :max-generation          14
;  :max-memory              18.34
;  :memory                  16.93
;  :minimized-lits          658
;  :mk-bool-var             136401
;  :mk-clause               112627
;  :num-allocs              855968
;  :num-checks              342
;  :propagations            87858
;  :quant-instantiations    32637
;  :restarts                3
;  :rlimit-count            5033441
;  :time                    0.00)
; [then-branch: 220 | exc@123@04 == Null | live]
; [else-branch: 220 | exc@123@04 != Null | dead]
(push) ; 15
; [then-branch: 220 | exc@123@04 == Null]
; [eval] (forall unknown: Int :: { opt_get1(aloc(opt_get1(target), unknown).option$array$) } { opt_get1(aloc(opt_get1(source), unknown).option$array$) } 0 <= unknown && unknown < V ==> (forall unknown1: Int :: { aloc(opt_get1(aloc(opt_get1(target), unknown).option$array$), unknown1) } { aloc(opt_get1(aloc(opt_get1(source), unknown).option$array$), unknown1) } 0 <= unknown1 && unknown1 < V ==> aloc(opt_get1(aloc(opt_get1(target), unknown).option$array$), unknown1).int == aloc(opt_get1(aloc(opt_get1(source), unknown).option$array$), unknown1).int))
(declare-const unknown@194@04 Int)
(push) ; 16
; [eval] 0 <= unknown && unknown < V ==> (forall unknown1: Int :: { aloc(opt_get1(aloc(opt_get1(target), unknown).option$array$), unknown1) } { aloc(opt_get1(aloc(opt_get1(source), unknown).option$array$), unknown1) } 0 <= unknown1 && unknown1 < V ==> aloc(opt_get1(aloc(opt_get1(target), unknown).option$array$), unknown1).int == aloc(opt_get1(aloc(opt_get1(source), unknown).option$array$), unknown1).int)
; [eval] 0 <= unknown && unknown < V
; [eval] 0 <= unknown
(push) ; 17
; [then-branch: 221 | 0 <= unknown@194@04 | live]
; [else-branch: 221 | !(0 <= unknown@194@04) | live]
(push) ; 18
; [then-branch: 221 | 0 <= unknown@194@04]
(assert (<= 0 unknown@194@04))
; [eval] unknown < V
(pop) ; 18
(push) ; 18
; [else-branch: 221 | !(0 <= unknown@194@04)]
(assert (not (<= 0 unknown@194@04)))
(pop) ; 18
(pop) ; 17
; Joined path conditions
; Joined path conditions
(push) ; 17
; [then-branch: 222 | unknown@194@04 < V@28@04 && 0 <= unknown@194@04 | live]
; [else-branch: 222 | !(unknown@194@04 < V@28@04 && 0 <= unknown@194@04) | live]
(push) ; 18
; [then-branch: 222 | unknown@194@04 < V@28@04 && 0 <= unknown@194@04]
(assert (and (< unknown@194@04 V@28@04) (<= 0 unknown@194@04)))
; [eval] (forall unknown1: Int :: { aloc(opt_get1(aloc(opt_get1(target), unknown).option$array$), unknown1) } { aloc(opt_get1(aloc(opt_get1(source), unknown).option$array$), unknown1) } 0 <= unknown1 && unknown1 < V ==> aloc(opt_get1(aloc(opt_get1(target), unknown).option$array$), unknown1).int == aloc(opt_get1(aloc(opt_get1(source), unknown).option$array$), unknown1).int)
(declare-const unknown1@195@04 Int)
(push) ; 19
; [eval] 0 <= unknown1 && unknown1 < V ==> aloc(opt_get1(aloc(opt_get1(target), unknown).option$array$), unknown1).int == aloc(opt_get1(aloc(opt_get1(source), unknown).option$array$), unknown1).int
; [eval] 0 <= unknown1 && unknown1 < V
; [eval] 0 <= unknown1
(push) ; 20
; [then-branch: 223 | 0 <= unknown1@195@04 | live]
; [else-branch: 223 | !(0 <= unknown1@195@04) | live]
(push) ; 21
; [then-branch: 223 | 0 <= unknown1@195@04]
(assert (<= 0 unknown1@195@04))
; [eval] unknown1 < V
(pop) ; 21
(push) ; 21
; [else-branch: 223 | !(0 <= unknown1@195@04)]
(assert (not (<= 0 unknown1@195@04)))
(pop) ; 21
(pop) ; 20
; Joined path conditions
; Joined path conditions
(push) ; 20
; [then-branch: 224 | unknown1@195@04 < V@28@04 && 0 <= unknown1@195@04 | live]
; [else-branch: 224 | !(unknown1@195@04 < V@28@04 && 0 <= unknown1@195@04) | live]
(push) ; 21
; [then-branch: 224 | unknown1@195@04 < V@28@04 && 0 <= unknown1@195@04]
(assert (and (< unknown1@195@04 V@28@04) (<= 0 unknown1@195@04)))
; [eval] aloc(opt_get1(aloc(opt_get1(target), unknown).option$array$), unknown1).int == aloc(opt_get1(aloc(opt_get1(source), unknown).option$array$), unknown1).int
; [eval] aloc(opt_get1(aloc(opt_get1(target), unknown).option$array$), unknown1)
; [eval] opt_get1(aloc(opt_get1(target), unknown).option$array$)
; [eval] aloc(opt_get1(target), unknown)
; [eval] opt_get1(target)
(push) ; 22
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 22
; Joined path conditions
(push) ; 22
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 23
(assert (not (< unknown@194@04 (alen<Int> (opt_get1 $Snap.unit target@27@04)))))
(check-sat)
; unsat
(pop) ; 23
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               115003
;  :arith-add-rows          79741
;  :arith-assert-diseq      7092
;  :arith-assert-lower      38262
;  :arith-assert-upper      25120
;  :arith-bound-prop        5479
;  :arith-conflicts         1043
;  :arith-eq-adapter        19524
;  :arith-fixed-eqs         13852
;  :arith-gcd-tests         3
;  :arith-grobner           294
;  :arith-ineq-splits       2
;  :arith-max-min           1922
;  :arith-nonlinear-bounds  233
;  :arith-nonlinear-horner  353
;  :arith-offset-eqs        17312
;  :arith-patches           4
;  :arith-patches_succ      1
;  :arith-pivots            10980
;  :arith-pseudo-nonlinear  60
;  :conflicts               2434
;  :datatype-accessor-ax    401
;  :datatype-constructor-ax 1710
;  :datatype-occurs-check   1004
;  :datatype-splits         1094
;  :decisions               18359
;  :del-clause              112618
;  :final-checks            511
;  :interface-eqs           91
;  :max-generation          14
;  :max-memory              18.34
;  :memory                  16.93
;  :minimized-lits          658
;  :mk-bool-var             136405
;  :mk-clause               112627
;  :num-allocs              856153
;  :num-checks              343
;  :propagations            87858
;  :quant-instantiations    32637
;  :restarts                3
;  :rlimit-count            5033796)
(assert (< unknown@194@04 (alen<Int> (opt_get1 $Snap.unit target@27@04))))
(pop) ; 22
; Joined path conditions
(assert (< unknown@194@04 (alen<Int> (opt_get1 $Snap.unit target@27@04))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@194@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@194@04)))
(push) ; 22
(assert (not (<
  $Perm.No
  (+
    (+
      (+
        (ite
          (and
            (<
              (inv@136@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@194@04))
              V@28@04)
            (<=
              0
              (inv@136@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@194@04))))
          (*
            (scale $Snap.unit (* (to_real (* V@28@04 V@28@04)) $Perm.Write))
            $k@135@04)
          $Perm.No)
        (ite
          (and
            (<
              (inv@128@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@194@04))
              V@28@04)
            (<=
              0
              (inv@128@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@194@04))))
          (*
            (scale $Snap.unit (* (to_real (* V@28@04 V@28@04)) $Perm.Write))
            $k@127@04)
          $Perm.No))
      (-
        (-
          (ite
            (and
              (<
                (inv@42@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@194@04))
                V@28@04)
              (<=
                0
                (inv@42@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@194@04))))
            $k@41@04
            $Perm.No)
          (pTaken@95@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@194@04)))
        (pTaken@106@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@194@04))))
    (-
      (-
        (ite
          (and
            (<
              (inv@34@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@194@04))
              V@28@04)
            (<=
              0
              (inv@34@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@194@04))))
          $k@33@04
          $Perm.No)
        (pTaken@96@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@194@04)))
      (pTaken@105@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@194@04)))))))
(check-sat)
; unsat
(pop) ; 22
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               115743
;  :arith-add-rows          80582
;  :arith-assert-diseq      7130
;  :arith-assert-lower      38460
;  :arith-assert-upper      25311
;  :arith-bound-prop        5568
;  :arith-conflicts         1060
;  :arith-eq-adapter        19681
;  :arith-fixed-eqs         13946
;  :arith-gcd-tests         3
;  :arith-grobner           294
;  :arith-ineq-splits       2
;  :arith-max-min           1922
;  :arith-nonlinear-bounds  233
;  :arith-nonlinear-horner  353
;  :arith-offset-eqs        17423
;  :arith-patches           4
;  :arith-patches_succ      1
;  :arith-pivots            11081
;  :arith-pseudo-nonlinear  60
;  :conflicts               2475
;  :datatype-accessor-ax    401
;  :datatype-constructor-ax 1714
;  :datatype-occurs-check   1004
;  :datatype-splits         1094
;  :decisions               18463
;  :del-clause              113250
;  :final-checks            511
;  :interface-eqs           91
;  :max-generation          14
;  :max-memory              18.34
;  :memory                  16.93
;  :minimized-lits          663
;  :mk-bool-var             137312
;  :mk-clause               113424
;  :num-allocs              859962
;  :num-checks              344
;  :propagations            88429
;  :quant-instantiations    32752
;  :restarts                3
;  :rlimit-count            5064046
;  :time                    0.01)
(push) ; 22
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 23
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@194@04))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 23
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               115743
;  :arith-add-rows          80582
;  :arith-assert-diseq      7130
;  :arith-assert-lower      38460
;  :arith-assert-upper      25311
;  :arith-bound-prop        5568
;  :arith-conflicts         1060
;  :arith-eq-adapter        19681
;  :arith-fixed-eqs         13946
;  :arith-gcd-tests         3
;  :arith-grobner           294
;  :arith-ineq-splits       2
;  :arith-max-min           1922
;  :arith-nonlinear-bounds  233
;  :arith-nonlinear-horner  353
;  :arith-offset-eqs        17423
;  :arith-patches           4
;  :arith-patches_succ      1
;  :arith-pivots            11081
;  :arith-pseudo-nonlinear  60
;  :conflicts               2476
;  :datatype-accessor-ax    401
;  :datatype-constructor-ax 1714
;  :datatype-occurs-check   1004
;  :datatype-splits         1094
;  :decisions               18463
;  :del-clause              113250
;  :final-checks            511
;  :interface-eqs           91
;  :max-generation          14
;  :max-memory              18.34
;  :memory                  16.93
;  :minimized-lits          663
;  :mk-bool-var             137312
;  :mk-clause               113424
;  :num-allocs              860054
;  :num-checks              345
;  :propagations            88429
;  :quant-instantiations    32752
;  :restarts                3
;  :rlimit-count            5064141)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@194@04))
    (as None<option<array>>  option<array>))))
(pop) ; 22
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@194@04))
    (as None<option<array>>  option<array>))))
(push) ; 22
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 23
(assert (not (<
  unknown1@195@04
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@194@04)))))))
(check-sat)
; unsat
(pop) ; 23
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               115749
;  :arith-add-rows          80587
;  :arith-assert-diseq      7130
;  :arith-assert-lower      38463
;  :arith-assert-upper      25312
;  :arith-bound-prop        5568
;  :arith-conflicts         1061
;  :arith-eq-adapter        19682
;  :arith-fixed-eqs         13947
;  :arith-gcd-tests         3
;  :arith-grobner           294
;  :arith-ineq-splits       2
;  :arith-max-min           1922
;  :arith-nonlinear-bounds  233
;  :arith-nonlinear-horner  353
;  :arith-offset-eqs        17423
;  :arith-patches           4
;  :arith-patches_succ      1
;  :arith-pivots            11085
;  :arith-pseudo-nonlinear  60
;  :conflicts               2477
;  :datatype-accessor-ax    401
;  :datatype-constructor-ax 1714
;  :datatype-occurs-check   1004
;  :datatype-splits         1094
;  :decisions               18463
;  :del-clause              113254
;  :final-checks            511
;  :interface-eqs           91
;  :max-generation          14
;  :max-memory              18.34
;  :memory                  16.91
;  :minimized-lits          663
;  :mk-bool-var             137323
;  :mk-clause               113428
;  :num-allocs              860258
;  :num-checks              346
;  :propagations            88431
;  :quant-instantiations    32761
;  :restarts                3
;  :rlimit-count            5064687)
(assert (<
  unknown1@195@04
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@194@04))))))
(pop) ; 22
; Joined path conditions
(assert (<
  unknown1@195@04
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@194@04))))))
(assert ($FVF.loc_int ($FVF.lookup_int (as sm@152@04  $FVF<Int>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@194@04))) unknown1@195@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@194@04))) unknown1@195@04)))
(push) ; 22
(assert (not (<
  $Perm.No
  (+
    (+
      (ite
        (and
          (and
            (and
              (<
                (inv@151@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@194@04))) unknown1@195@04))
                V@28@04)
              (<=
                0
                (inv@151@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@194@04))) unknown1@195@04))))
            (<
              (inv@150@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@194@04))) unknown1@195@04))
              V@28@04))
          (<=
            0
            (inv@150@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@194@04))) unknown1@195@04))))
        $k@149@04
        $Perm.No)
      (ite
        (and
          (and
            (and
              (<
                (inv@145@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@194@04))) unknown1@195@04))
                V@28@04)
              (<=
                0
                (inv@145@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@194@04))) unknown1@195@04))))
            (<
              (inv@144@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@194@04))) unknown1@195@04))
              V@28@04))
          (<=
            0
            (inv@144@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@194@04))) unknown1@195@04))))
        $Perm.Write
        $Perm.No))
    (-
      (ite
        (and
          (and
            (and
              (<
                (inv@52@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@194@04))) unknown1@195@04))
                V@28@04)
              (<=
                0
                (inv@52@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@194@04))) unknown1@195@04))))
            (<
              (inv@51@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@194@04))) unknown1@195@04))
              V@28@04))
          (<=
            0
            (inv@51@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@194@04))) unknown1@195@04))))
        $k@50@04
        $Perm.No)
      (pTaken@122@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@194@04))) unknown1@195@04)))))))
(check-sat)
; unsat
(pop) ; 22
; 0.09s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               119679
;  :arith-add-rows          82973
;  :arith-assert-diseq      7331
;  :arith-assert-lower      39365
;  :arith-assert-upper      26053
;  :arith-bound-prop        5832
;  :arith-conflicts         1082
;  :arith-eq-adapter        20506
;  :arith-fixed-eqs         14428
;  :arith-gcd-tests         3
;  :arith-grobner           294
;  :arith-ineq-splits       2
;  :arith-max-min           1922
;  :arith-nonlinear-bounds  233
;  :arith-nonlinear-horner  353
;  :arith-offset-eqs        17869
;  :arith-patches           4
;  :arith-patches_succ      1
;  :arith-pivots            11488
;  :arith-pseudo-nonlinear  60
;  :conflicts               2527
;  :datatype-accessor-ax    401
;  :datatype-constructor-ax 1718
;  :datatype-occurs-check   1004
;  :datatype-splits         1094
;  :decisions               18693
;  :del-clause              120886
;  :final-checks            511
;  :interface-eqs           91
;  :max-generation          14
;  :max-memory              18.34
;  :memory                  17.06
;  :minimized-lits          666
;  :mk-bool-var             150170
;  :mk-clause               121360
;  :num-allocs              903943
;  :num-checks              347
;  :propagations            90906
;  :quant-instantiations    35290
;  :restarts                3
;  :rlimit-count            5201425
;  :time                    0.09)
; [eval] aloc(opt_get1(aloc(opt_get1(source), unknown).option$array$), unknown1)
; [eval] opt_get1(aloc(opt_get1(source), unknown).option$array$)
; [eval] aloc(opt_get1(source), unknown)
; [eval] opt_get1(source)
(push) ; 22
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 22
; Joined path conditions
(push) ; 22
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 23
(assert (not (< unknown@194@04 (alen<Int> (opt_get1 $Snap.unit source@26@04)))))
(check-sat)
; unsat
(pop) ; 23
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               119679
;  :arith-add-rows          82973
;  :arith-assert-diseq      7331
;  :arith-assert-lower      39365
;  :arith-assert-upper      26053
;  :arith-bound-prop        5832
;  :arith-conflicts         1082
;  :arith-eq-adapter        20506
;  :arith-fixed-eqs         14428
;  :arith-gcd-tests         3
;  :arith-grobner           294
;  :arith-ineq-splits       2
;  :arith-max-min           1922
;  :arith-nonlinear-bounds  233
;  :arith-nonlinear-horner  353
;  :arith-offset-eqs        17869
;  :arith-patches           4
;  :arith-patches_succ      1
;  :arith-pivots            11488
;  :arith-pseudo-nonlinear  60
;  :conflicts               2527
;  :datatype-accessor-ax    401
;  :datatype-constructor-ax 1718
;  :datatype-occurs-check   1004
;  :datatype-splits         1094
;  :decisions               18693
;  :del-clause              120886
;  :final-checks            511
;  :interface-eqs           91
;  :max-generation          14
;  :max-memory              18.34
;  :memory                  17.06
;  :minimized-lits          666
;  :mk-bool-var             150170
;  :mk-clause               121360
;  :num-allocs              903970
;  :num-checks              348
;  :propagations            90906
;  :quant-instantiations    35290
;  :restarts                3
;  :rlimit-count            5201455)
(assert (< unknown@194@04 (alen<Int> (opt_get1 $Snap.unit source@26@04))))
(pop) ; 22
; Joined path conditions
(assert (< unknown@194@04 (alen<Int> (opt_get1 $Snap.unit source@26@04))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@194@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@194@04)))
(push) ; 22
(assert (not (<
  $Perm.No
  (+
    (+
      (+
        (ite
          (and
            (<
              (inv@136@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@194@04))
              V@28@04)
            (<=
              0
              (inv@136@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@194@04))))
          (*
            (scale $Snap.unit (* (to_real (* V@28@04 V@28@04)) $Perm.Write))
            $k@135@04)
          $Perm.No)
        (ite
          (and
            (<
              (inv@128@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@194@04))
              V@28@04)
            (<=
              0
              (inv@128@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@194@04))))
          (*
            (scale $Snap.unit (* (to_real (* V@28@04 V@28@04)) $Perm.Write))
            $k@127@04)
          $Perm.No))
      (-
        (-
          (ite
            (and
              (<
                (inv@42@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@194@04))
                V@28@04)
              (<=
                0
                (inv@42@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@194@04))))
            $k@41@04
            $Perm.No)
          (pTaken@95@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@194@04)))
        (pTaken@106@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@194@04))))
    (-
      (-
        (ite
          (and
            (<
              (inv@34@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@194@04))
              V@28@04)
            (<=
              0
              (inv@34@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@194@04))))
          $k@33@04
          $Perm.No)
        (pTaken@96@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@194@04)))
      (pTaken@105@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@194@04)))))))
(check-sat)
; unsat
(pop) ; 22
; 0.10s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               126950
;  :arith-add-rows          87757
;  :arith-assert-diseq      7630
;  :arith-assert-lower      41146
;  :arith-assert-upper      27348
;  :arith-bound-prop        6111
;  :arith-conflicts         1143
;  :arith-eq-adapter        21888
;  :arith-fixed-eqs         15138
;  :arith-gcd-tests         3
;  :arith-grobner           294
;  :arith-ineq-splits       2
;  :arith-max-min           1922
;  :arith-nonlinear-bounds  233
;  :arith-nonlinear-horner  353
;  :arith-offset-eqs        18689
;  :arith-patches           4
;  :arith-patches_succ      1
;  :arith-pivots            12102
;  :arith-pseudo-nonlinear  60
;  :conflicts               2636
;  :datatype-accessor-ax    401
;  :datatype-constructor-ax 1722
;  :datatype-occurs-check   1004
;  :datatype-splits         1094
;  :decisions               19353
;  :del-clause              128437
;  :final-checks            511
;  :interface-eqs           91
;  :max-generation          14
;  :max-memory              18.34
;  :memory                  17.10
;  :minimized-lits          687
;  :mk-bool-var             159132
;  :mk-clause               128911
;  :num-allocs              932324
;  :num-checks              349
;  :propagations            96347
;  :quant-instantiations    37366
;  :restarts                4
;  :rlimit-count            5407933
;  :time                    0.10)
(push) ; 22
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 23
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@194@04))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 23
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               126950
;  :arith-add-rows          87757
;  :arith-assert-diseq      7630
;  :arith-assert-lower      41146
;  :arith-assert-upper      27348
;  :arith-bound-prop        6111
;  :arith-conflicts         1143
;  :arith-eq-adapter        21888
;  :arith-fixed-eqs         15138
;  :arith-gcd-tests         3
;  :arith-grobner           294
;  :arith-ineq-splits       2
;  :arith-max-min           1922
;  :arith-nonlinear-bounds  233
;  :arith-nonlinear-horner  353
;  :arith-offset-eqs        18689
;  :arith-patches           4
;  :arith-patches_succ      1
;  :arith-pivots            12102
;  :arith-pseudo-nonlinear  60
;  :conflicts               2637
;  :datatype-accessor-ax    401
;  :datatype-constructor-ax 1722
;  :datatype-occurs-check   1004
;  :datatype-splits         1094
;  :decisions               19353
;  :del-clause              128437
;  :final-checks            511
;  :interface-eqs           91
;  :max-generation          14
;  :max-memory              18.34
;  :memory                  17.10
;  :minimized-lits          687
;  :mk-bool-var             159132
;  :mk-clause               128911
;  :num-allocs              932414
;  :num-checks              350
;  :propagations            96347
;  :quant-instantiations    37366
;  :restarts                4
;  :rlimit-count            5408024)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@194@04))
    (as None<option<array>>  option<array>))))
(pop) ; 22
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@194@04))
    (as None<option<array>>  option<array>))))
(push) ; 22
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 23
(assert (not (<
  unknown1@195@04
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@194@04)))))))
(check-sat)
; unsat
(pop) ; 23
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               126950
;  :arith-add-rows          87757
;  :arith-assert-diseq      7630
;  :arith-assert-lower      41146
;  :arith-assert-upper      27348
;  :arith-bound-prop        6111
;  :arith-conflicts         1143
;  :arith-eq-adapter        21888
;  :arith-fixed-eqs         15138
;  :arith-gcd-tests         3
;  :arith-grobner           294
;  :arith-ineq-splits       2
;  :arith-max-min           1922
;  :arith-nonlinear-bounds  233
;  :arith-nonlinear-horner  353
;  :arith-offset-eqs        18689
;  :arith-patches           4
;  :arith-patches_succ      1
;  :arith-pivots            12102
;  :arith-pseudo-nonlinear  60
;  :conflicts               2638
;  :datatype-accessor-ax    401
;  :datatype-constructor-ax 1722
;  :datatype-occurs-check   1004
;  :datatype-splits         1094
;  :decisions               19353
;  :del-clause              128437
;  :final-checks            511
;  :interface-eqs           91
;  :max-generation          14
;  :max-memory              18.34
;  :memory                  17.10
;  :minimized-lits          687
;  :mk-bool-var             159132
;  :mk-clause               128911
;  :num-allocs              932557
;  :num-checks              351
;  :propagations            96347
;  :quant-instantiations    37366
;  :restarts                4
;  :rlimit-count            5408271)
(assert (<
  unknown1@195@04
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@194@04))))))
(pop) ; 22
; Joined path conditions
(assert (<
  unknown1@195@04
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@194@04))))))
(assert ($FVF.loc_int ($FVF.lookup_int (as sm@152@04  $FVF<Int>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@194@04))) unknown1@195@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@194@04))) unknown1@195@04)))
(push) ; 22
(assert (not (<
  $Perm.No
  (+
    (+
      (ite
        (and
          (and
            (and
              (<
                (inv@151@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@194@04))) unknown1@195@04))
                V@28@04)
              (<=
                0
                (inv@151@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@194@04))) unknown1@195@04))))
            (<
              (inv@150@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@194@04))) unknown1@195@04))
              V@28@04))
          (<=
            0
            (inv@150@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@194@04))) unknown1@195@04))))
        $k@149@04
        $Perm.No)
      (ite
        (and
          (and
            (and
              (<
                (inv@145@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@194@04))) unknown1@195@04))
                V@28@04)
              (<=
                0
                (inv@145@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@194@04))) unknown1@195@04))))
            (<
              (inv@144@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@194@04))) unknown1@195@04))
              V@28@04))
          (<=
            0
            (inv@144@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@194@04))) unknown1@195@04))))
        $Perm.Write
        $Perm.No))
    (-
      (ite
        (and
          (and
            (and
              (<
                (inv@52@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@194@04))) unknown1@195@04))
                V@28@04)
              (<=
                0
                (inv@52@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@194@04))) unknown1@195@04))))
            (<
              (inv@51@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@194@04))) unknown1@195@04))
              V@28@04))
          (<=
            0
            (inv@51@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@194@04))) unknown1@195@04))))
        $k@50@04
        $Perm.No)
      (pTaken@122@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@194@04))) unknown1@195@04)))))))
(check-sat)
; unsat
(pop) ; 22
; 0.03s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               128904
;  :arith-add-rows          89249
;  :arith-assert-diseq      7732
;  :arith-assert-lower      41683
;  :arith-assert-upper      27714
;  :arith-bound-prop        6257
;  :arith-conflicts         1164
;  :arith-eq-adapter        22250
;  :arith-fixed-eqs         15326
;  :arith-gcd-tests         3
;  :arith-grobner           294
;  :arith-ineq-splits       2
;  :arith-max-min           1922
;  :arith-nonlinear-bounds  233
;  :arith-nonlinear-horner  353
;  :arith-offset-eqs        18910
;  :arith-patches           4
;  :arith-patches_succ      1
;  :arith-pivots            12268
;  :arith-pseudo-nonlinear  60
;  :conflicts               2679
;  :datatype-accessor-ax    401
;  :datatype-constructor-ax 1726
;  :datatype-occurs-check   1004
;  :datatype-splits         1094
;  :decisions               19687
;  :del-clause              130618
;  :final-checks            511
;  :interface-eqs           91
;  :max-generation          14
;  :max-memory              18.34
;  :memory                  17.10
;  :minimized-lits          689
;  :mk-bool-var             162355
;  :mk-clause               131092
;  :num-allocs              942319
;  :num-checks              352
;  :propagations            97422
;  :quant-instantiations    37771
;  :restarts                4
;  :rlimit-count            5457121
;  :time                    0.03)
(pop) ; 21
(push) ; 21
; [else-branch: 224 | !(unknown1@195@04 < V@28@04 && 0 <= unknown1@195@04)]
(assert (not (and (< unknown1@195@04 V@28@04) (<= 0 unknown1@195@04))))
(pop) ; 21
(pop) ; 20
; Joined path conditions
(assert (implies
  (and (< unknown1@195@04 V@28@04) (<= 0 unknown1@195@04))
  (and
    (< unknown1@195@04 V@28@04)
    (<= 0 unknown1@195@04)
    (< unknown@194@04 (alen<Int> (opt_get1 $Snap.unit target@27@04)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@194@04)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@194@04))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@194@04))
        (as None<option<array>>  option<array>)))
    (<
      unknown1@195@04
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@194@04)))))
    ($FVF.loc_int ($FVF.lookup_int (as sm@152@04  $FVF<Int>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@194@04))) unknown1@195@04)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@194@04))) unknown1@195@04))
    (< unknown@194@04 (alen<Int> (opt_get1 $Snap.unit source@26@04)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@194@04)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@194@04))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@194@04))
        (as None<option<array>>  option<array>)))
    (<
      unknown1@195@04
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@194@04)))))
    ($FVF.loc_int ($FVF.lookup_int (as sm@152@04  $FVF<Int>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@194@04))) unknown1@195@04)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@194@04))) unknown1@195@04)))))
; Joined path conditions
(pop) ; 19
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((unknown1@195@04 Int)) (!
  (implies
    (and (< unknown1@195@04 V@28@04) (<= 0 unknown1@195@04))
    (and
      (< unknown1@195@04 V@28@04)
      (<= 0 unknown1@195@04)
      (< unknown@194@04 (alen<Int> (opt_get1 $Snap.unit target@27@04)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@194@04)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@194@04))
      (not
        (=
          ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@194@04))
          (as None<option<array>>  option<array>)))
      (<
        unknown1@195@04
        (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@194@04)))))
      ($FVF.loc_int ($FVF.lookup_int (as sm@152@04  $FVF<Int>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@194@04))) unknown1@195@04)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@194@04))) unknown1@195@04))
      (< unknown@194@04 (alen<Int> (opt_get1 $Snap.unit source@26@04)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@194@04)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@194@04))
      (not
        (=
          ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@194@04))
          (as None<option<array>>  option<array>)))
      (<
        unknown1@195@04
        (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@194@04)))))
      ($FVF.loc_int ($FVF.lookup_int (as sm@152@04  $FVF<Int>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@194@04))) unknown1@195@04)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@194@04))) unknown1@195@04))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@194@04))) unknown1@195@04))
  :qid |prog.l<no position>-aux|)))
(assert (forall ((unknown1@195@04 Int)) (!
  (implies
    (and (< unknown1@195@04 V@28@04) (<= 0 unknown1@195@04))
    (and
      (< unknown1@195@04 V@28@04)
      (<= 0 unknown1@195@04)
      (< unknown@194@04 (alen<Int> (opt_get1 $Snap.unit target@27@04)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@194@04)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@194@04))
      (not
        (=
          ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@194@04))
          (as None<option<array>>  option<array>)))
      (<
        unknown1@195@04
        (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@194@04)))))
      ($FVF.loc_int ($FVF.lookup_int (as sm@152@04  $FVF<Int>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@194@04))) unknown1@195@04)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@194@04))) unknown1@195@04))
      (< unknown@194@04 (alen<Int> (opt_get1 $Snap.unit source@26@04)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@194@04)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@194@04))
      (not
        (=
          ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@194@04))
          (as None<option<array>>  option<array>)))
      (<
        unknown1@195@04
        (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@194@04)))))
      ($FVF.loc_int ($FVF.lookup_int (as sm@152@04  $FVF<Int>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@194@04))) unknown1@195@04)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@194@04))) unknown1@195@04))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@194@04))) unknown1@195@04))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 18
(push) ; 18
; [else-branch: 222 | !(unknown@194@04 < V@28@04 && 0 <= unknown@194@04)]
(assert (not (and (< unknown@194@04 V@28@04) (<= 0 unknown@194@04))))
(pop) ; 18
(pop) ; 17
; Joined path conditions
(assert (implies
  (and (< unknown@194@04 V@28@04) (<= 0 unknown@194@04))
  (and
    (< unknown@194@04 V@28@04)
    (<= 0 unknown@194@04)
    (forall ((unknown1@195@04 Int)) (!
      (implies
        (and (< unknown1@195@04 V@28@04) (<= 0 unknown1@195@04))
        (and
          (< unknown1@195@04 V@28@04)
          (<= 0 unknown1@195@04)
          (< unknown@194@04 (alen<Int> (opt_get1 $Snap.unit target@27@04)))
          ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@194@04)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@194@04))
          (not
            (=
              ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@194@04))
              (as None<option<array>>  option<array>)))
          (<
            unknown1@195@04
            (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@194@04)))))
          ($FVF.loc_int ($FVF.lookup_int (as sm@152@04  $FVF<Int>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@194@04))) unknown1@195@04)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@194@04))) unknown1@195@04))
          (< unknown@194@04 (alen<Int> (opt_get1 $Snap.unit source@26@04)))
          ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@194@04)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@194@04))
          (not
            (=
              ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@194@04))
              (as None<option<array>>  option<array>)))
          (<
            unknown1@195@04
            (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@194@04)))))
          ($FVF.loc_int ($FVF.lookup_int (as sm@152@04  $FVF<Int>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@194@04))) unknown1@195@04)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@194@04))) unknown1@195@04))))
      :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@194@04))) unknown1@195@04))
      :qid |prog.l<no position>-aux|))
    (forall ((unknown1@195@04 Int)) (!
      (implies
        (and (< unknown1@195@04 V@28@04) (<= 0 unknown1@195@04))
        (and
          (< unknown1@195@04 V@28@04)
          (<= 0 unknown1@195@04)
          (< unknown@194@04 (alen<Int> (opt_get1 $Snap.unit target@27@04)))
          ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@194@04)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@194@04))
          (not
            (=
              ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@194@04))
              (as None<option<array>>  option<array>)))
          (<
            unknown1@195@04
            (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@194@04)))))
          ($FVF.loc_int ($FVF.lookup_int (as sm@152@04  $FVF<Int>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@194@04))) unknown1@195@04)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@194@04))) unknown1@195@04))
          (< unknown@194@04 (alen<Int> (opt_get1 $Snap.unit source@26@04)))
          ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@194@04)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@194@04))
          (not
            (=
              ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@194@04))
              (as None<option<array>>  option<array>)))
          (<
            unknown1@195@04
            (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@194@04)))))
          ($FVF.loc_int ($FVF.lookup_int (as sm@152@04  $FVF<Int>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@194@04))) unknown1@195@04)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@194@04))) unknown1@195@04))))
      :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@194@04))) unknown1@195@04))
      :qid |prog.l<no position>-aux|)))))
; Joined path conditions
(pop) ; 16
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((unknown@194@04 Int)) (!
  (implies
    (and (< unknown@194@04 V@28@04) (<= 0 unknown@194@04))
    (and
      (< unknown@194@04 V@28@04)
      (<= 0 unknown@194@04)
      (forall ((unknown1@195@04 Int)) (!
        (implies
          (and (< unknown1@195@04 V@28@04) (<= 0 unknown1@195@04))
          (and
            (< unknown1@195@04 V@28@04)
            (<= 0 unknown1@195@04)
            (< unknown@194@04 (alen<Int> (opt_get1 $Snap.unit target@27@04)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@194@04)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@194@04))
            (not
              (=
                ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@194@04))
                (as None<option<array>>  option<array>)))
            (<
              unknown1@195@04
              (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@194@04)))))
            ($FVF.loc_int ($FVF.lookup_int (as sm@152@04  $FVF<Int>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@194@04))) unknown1@195@04)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@194@04))) unknown1@195@04))
            (< unknown@194@04 (alen<Int> (opt_get1 $Snap.unit source@26@04)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@194@04)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@194@04))
            (not
              (=
                ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@194@04))
                (as None<option<array>>  option<array>)))
            (<
              unknown1@195@04
              (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@194@04)))))
            ($FVF.loc_int ($FVF.lookup_int (as sm@152@04  $FVF<Int>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@194@04))) unknown1@195@04)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@194@04))) unknown1@195@04))))
        :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@194@04))) unknown1@195@04))
        :qid |prog.l<no position>-aux|))
      (forall ((unknown1@195@04 Int)) (!
        (implies
          (and (< unknown1@195@04 V@28@04) (<= 0 unknown1@195@04))
          (and
            (< unknown1@195@04 V@28@04)
            (<= 0 unknown1@195@04)
            (< unknown@194@04 (alen<Int> (opt_get1 $Snap.unit target@27@04)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@194@04)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@194@04))
            (not
              (=
                ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@194@04))
                (as None<option<array>>  option<array>)))
            (<
              unknown1@195@04
              (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@194@04)))))
            ($FVF.loc_int ($FVF.lookup_int (as sm@152@04  $FVF<Int>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@194@04))) unknown1@195@04)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@194@04))) unknown1@195@04))
            (< unknown@194@04 (alen<Int> (opt_get1 $Snap.unit source@26@04)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@194@04)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@194@04))
            (not
              (=
                ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@194@04))
                (as None<option<array>>  option<array>)))
            (<
              unknown1@195@04
              (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@194@04)))))
            ($FVF.loc_int ($FVF.lookup_int (as sm@152@04  $FVF<Int>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@194@04))) unknown1@195@04)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@194@04))) unknown1@195@04))))
        :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@194@04))) unknown1@195@04))
        :qid |prog.l<no position>-aux|))))
  :pattern ((opt_get1%limited $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@194@04))))
  :qid |prog.l<no position>-aux|)))
(assert (forall ((unknown@194@04 Int)) (!
  (implies
    (and (< unknown@194@04 V@28@04) (<= 0 unknown@194@04))
    (and
      (< unknown@194@04 V@28@04)
      (<= 0 unknown@194@04)
      (forall ((unknown1@195@04 Int)) (!
        (implies
          (and (< unknown1@195@04 V@28@04) (<= 0 unknown1@195@04))
          (and
            (< unknown1@195@04 V@28@04)
            (<= 0 unknown1@195@04)
            (< unknown@194@04 (alen<Int> (opt_get1 $Snap.unit target@27@04)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@194@04)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@194@04))
            (not
              (=
                ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@194@04))
                (as None<option<array>>  option<array>)))
            (<
              unknown1@195@04
              (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@194@04)))))
            ($FVF.loc_int ($FVF.lookup_int (as sm@152@04  $FVF<Int>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@194@04))) unknown1@195@04)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@194@04))) unknown1@195@04))
            (< unknown@194@04 (alen<Int> (opt_get1 $Snap.unit source@26@04)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@194@04)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@194@04))
            (not
              (=
                ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@194@04))
                (as None<option<array>>  option<array>)))
            (<
              unknown1@195@04
              (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@194@04)))))
            ($FVF.loc_int ($FVF.lookup_int (as sm@152@04  $FVF<Int>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@194@04))) unknown1@195@04)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@194@04))) unknown1@195@04))))
        :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@194@04))) unknown1@195@04))
        :qid |prog.l<no position>-aux|))
      (forall ((unknown1@195@04 Int)) (!
        (implies
          (and (< unknown1@195@04 V@28@04) (<= 0 unknown1@195@04))
          (and
            (< unknown1@195@04 V@28@04)
            (<= 0 unknown1@195@04)
            (< unknown@194@04 (alen<Int> (opt_get1 $Snap.unit target@27@04)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@194@04)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@194@04))
            (not
              (=
                ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@194@04))
                (as None<option<array>>  option<array>)))
            (<
              unknown1@195@04
              (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@194@04)))))
            ($FVF.loc_int ($FVF.lookup_int (as sm@152@04  $FVF<Int>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@194@04))) unknown1@195@04)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@194@04))) unknown1@195@04))
            (< unknown@194@04 (alen<Int> (opt_get1 $Snap.unit source@26@04)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@194@04)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@194@04))
            (not
              (=
                ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@194@04))
                (as None<option<array>>  option<array>)))
            (<
              unknown1@195@04
              (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@194@04)))))
            ($FVF.loc_int ($FVF.lookup_int (as sm@152@04  $FVF<Int>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@194@04))) unknown1@195@04)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@194@04))) unknown1@195@04))))
        :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@194@04))) unknown1@195@04))
        :qid |prog.l<no position>-aux|))))
  :pattern ((opt_get1%limited $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@194@04))))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 15
(pop) ; 14
; Joined path conditions
(assert (implies
  (= exc@123@04 $Ref.null)
  (and
    (forall ((unknown@194@04 Int)) (!
      (implies
        (and (< unknown@194@04 V@28@04) (<= 0 unknown@194@04))
        (and
          (< unknown@194@04 V@28@04)
          (<= 0 unknown@194@04)
          (forall ((unknown1@195@04 Int)) (!
            (implies
              (and (< unknown1@195@04 V@28@04) (<= 0 unknown1@195@04))
              (and
                (< unknown1@195@04 V@28@04)
                (<= 0 unknown1@195@04)
                (< unknown@194@04 (alen<Int> (opt_get1 $Snap.unit target@27@04)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@194@04)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@194@04))
                (not
                  (=
                    ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@194@04))
                    (as None<option<array>>  option<array>)))
                (<
                  unknown1@195@04
                  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@194@04)))))
                ($FVF.loc_int ($FVF.lookup_int (as sm@152@04  $FVF<Int>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@194@04))) unknown1@195@04)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@194@04))) unknown1@195@04))
                (< unknown@194@04 (alen<Int> (opt_get1 $Snap.unit source@26@04)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@194@04)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@194@04))
                (not
                  (=
                    ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@194@04))
                    (as None<option<array>>  option<array>)))
                (<
                  unknown1@195@04
                  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@194@04)))))
                ($FVF.loc_int ($FVF.lookup_int (as sm@152@04  $FVF<Int>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@194@04))) unknown1@195@04)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@194@04))) unknown1@195@04))))
            :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@194@04))) unknown1@195@04))
            :qid |prog.l<no position>-aux|))
          (forall ((unknown1@195@04 Int)) (!
            (implies
              (and (< unknown1@195@04 V@28@04) (<= 0 unknown1@195@04))
              (and
                (< unknown1@195@04 V@28@04)
                (<= 0 unknown1@195@04)
                (< unknown@194@04 (alen<Int> (opt_get1 $Snap.unit target@27@04)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@194@04)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@194@04))
                (not
                  (=
                    ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@194@04))
                    (as None<option<array>>  option<array>)))
                (<
                  unknown1@195@04
                  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@194@04)))))
                ($FVF.loc_int ($FVF.lookup_int (as sm@152@04  $FVF<Int>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@194@04))) unknown1@195@04)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@194@04))) unknown1@195@04))
                (< unknown@194@04 (alen<Int> (opt_get1 $Snap.unit source@26@04)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@194@04)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@194@04))
                (not
                  (=
                    ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@194@04))
                    (as None<option<array>>  option<array>)))
                (<
                  unknown1@195@04
                  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@194@04)))))
                ($FVF.loc_int ($FVF.lookup_int (as sm@152@04  $FVF<Int>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@194@04))) unknown1@195@04)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@194@04))) unknown1@195@04))))
            :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@194@04))) unknown1@195@04))
            :qid |prog.l<no position>-aux|))))
      :pattern ((opt_get1%limited $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@194@04))))
      :qid |prog.l<no position>-aux|))
    (forall ((unknown@194@04 Int)) (!
      (implies
        (and (< unknown@194@04 V@28@04) (<= 0 unknown@194@04))
        (and
          (< unknown@194@04 V@28@04)
          (<= 0 unknown@194@04)
          (forall ((unknown1@195@04 Int)) (!
            (implies
              (and (< unknown1@195@04 V@28@04) (<= 0 unknown1@195@04))
              (and
                (< unknown1@195@04 V@28@04)
                (<= 0 unknown1@195@04)
                (< unknown@194@04 (alen<Int> (opt_get1 $Snap.unit target@27@04)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@194@04)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@194@04))
                (not
                  (=
                    ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@194@04))
                    (as None<option<array>>  option<array>)))
                (<
                  unknown1@195@04
                  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@194@04)))))
                ($FVF.loc_int ($FVF.lookup_int (as sm@152@04  $FVF<Int>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@194@04))) unknown1@195@04)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@194@04))) unknown1@195@04))
                (< unknown@194@04 (alen<Int> (opt_get1 $Snap.unit source@26@04)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@194@04)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@194@04))
                (not
                  (=
                    ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@194@04))
                    (as None<option<array>>  option<array>)))
                (<
                  unknown1@195@04
                  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@194@04)))))
                ($FVF.loc_int ($FVF.lookup_int (as sm@152@04  $FVF<Int>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@194@04))) unknown1@195@04)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@194@04))) unknown1@195@04))))
            :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@194@04))) unknown1@195@04))
            :qid |prog.l<no position>-aux|))
          (forall ((unknown1@195@04 Int)) (!
            (implies
              (and (< unknown1@195@04 V@28@04) (<= 0 unknown1@195@04))
              (and
                (< unknown1@195@04 V@28@04)
                (<= 0 unknown1@195@04)
                (< unknown@194@04 (alen<Int> (opt_get1 $Snap.unit target@27@04)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@194@04)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@194@04))
                (not
                  (=
                    ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@194@04))
                    (as None<option<array>>  option<array>)))
                (<
                  unknown1@195@04
                  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@194@04)))))
                ($FVF.loc_int ($FVF.lookup_int (as sm@152@04  $FVF<Int>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@194@04))) unknown1@195@04)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@194@04))) unknown1@195@04))
                (< unknown@194@04 (alen<Int> (opt_get1 $Snap.unit source@26@04)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@194@04)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@194@04))
                (not
                  (=
                    ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@194@04))
                    (as None<option<array>>  option<array>)))
                (<
                  unknown1@195@04
                  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@194@04)))))
                ($FVF.loc_int ($FVF.lookup_int (as sm@152@04  $FVF<Int>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@194@04))) unknown1@195@04)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@194@04))) unknown1@195@04))))
            :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@194@04))) unknown1@195@04))
            :qid |prog.l<no position>-aux|))))
      :pattern ((opt_get1%limited $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@194@04))))
      :qid |prog.l<no position>-aux|)))))
(push) ; 14
(assert (not (implies
  (= exc@123@04 $Ref.null)
  (forall ((unknown@194@04 Int)) (!
    (implies
      (and (< unknown@194@04 V@28@04) (<= 0 unknown@194@04))
      (forall ((unknown1@195@04 Int)) (!
        (implies
          (and (< unknown1@195@04 V@28@04) (<= 0 unknown1@195@04))
          (=
            ($FVF.lookup_int (as sm@152@04  $FVF<Int>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@194@04))) unknown1@195@04))
            ($FVF.lookup_int (as sm@152@04  $FVF<Int>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@194@04))) unknown1@195@04))))
        :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@194@04))) unknown1@195@04))
        :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@194@04))) unknown1@195@04))
        :qid |prog.l<no position>|)))
    :pattern ((opt_get1%limited $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@194@04))))
    :pattern ((opt_get1%limited $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@194@04))))
    :qid |prog.l<no position>|)))))
(check-sat)
; unsat
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               128904
;  :arith-add-rows          89326
;  :arith-assert-diseq      7732
;  :arith-assert-lower      41687
;  :arith-assert-upper      27714
;  :arith-bound-prop        6257
;  :arith-conflicts         1164
;  :arith-eq-adapter        22254
;  :arith-fixed-eqs         15326
;  :arith-gcd-tests         3
;  :arith-grobner           294
;  :arith-ineq-splits       2
;  :arith-max-min           1922
;  :arith-nonlinear-bounds  233
;  :arith-nonlinear-horner  353
;  :arith-offset-eqs        18910
;  :arith-patches           4
;  :arith-patches_succ      1
;  :arith-pivots            12325
;  :arith-pseudo-nonlinear  60
;  :conflicts               2680
;  :datatype-accessor-ax    401
;  :datatype-constructor-ax 1726
;  :datatype-occurs-check   1004
;  :datatype-splits         1094
;  :decisions               19687
;  :del-clause              131259
;  :final-checks            511
;  :interface-eqs           91
;  :max-generation          14
;  :max-memory              18.34
;  :memory                  16.98
;  :minimized-lits          689
;  :mk-bool-var             162589
;  :mk-clause               131268
;  :num-allocs              945323
;  :num-checks              353
;  :propagations            97422
;  :quant-instantiations    37832
;  :restarts                4
;  :rlimit-count            5466730
;  :time                    0.00)
(assert (implies
  (= exc@123@04 $Ref.null)
  (forall ((unknown@194@04 Int)) (!
    (implies
      (and (< unknown@194@04 V@28@04) (<= 0 unknown@194@04))
      (forall ((unknown1@195@04 Int)) (!
        (implies
          (and (< unknown1@195@04 V@28@04) (<= 0 unknown1@195@04))
          (=
            ($FVF.lookup_int (as sm@152@04  $FVF<Int>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@194@04))) unknown1@195@04))
            ($FVF.lookup_int (as sm@152@04  $FVF<Int>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@194@04))) unknown1@195@04))))
        :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@194@04))) unknown1@195@04))
        :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@194@04))) unknown1@195@04))
        :qid |prog.l<no position>|)))
    :pattern ((opt_get1%limited $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@194@04))))
    :pattern ((opt_get1%limited $Snap.unit ($FVF.lookup_option$array$ (as sm@137@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@194@04))))
    :qid |prog.l<no position>|))))
(pop) ; 13
(pop) ; 12
(pop) ; 11
(pop) ; 10
(pop) ; 9
(pop) ; 8
(pop) ; 7
(pop) ; 6
(pop) ; 5
(pop) ; 4
(pop) ; 3
(push) ; 3
; [else-branch: 85 | !(0 < V@28@04)]
(assert (not (< 0 V@28@04)))
; [eval] 0 < V ==> (forall i1: Int :: { aloc(opt_get1(source), i1) } 0 <= i1 && i1 < V ==> aloc(opt_get1(source), i1).option$array$ != (None(): option[array]))
; [eval] 0 < V
(push) ; 4
; [then-branch: 225 | 0 < V@28@04 | dead]
; [else-branch: 225 | !(0 < V@28@04) | live]
(push) ; 5
; [else-branch: 225 | !(0 < V@28@04)]
(pop) ; 5
(pop) ; 4
; Joined path conditions
; [eval] 0 < V ==> (forall i1: Int :: { alen(opt_get1(aloc(opt_get1(source), i1).option$array$)) } 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(source), i1).option$array$)) == V)
; [eval] 0 < V
(push) ; 4
; [then-branch: 226 | 0 < V@28@04 | dead]
; [else-branch: 226 | !(0 < V@28@04) | live]
(push) ; 5
; [else-branch: 226 | !(0 < V@28@04)]
(pop) ; 5
(pop) ; 4
; Joined path conditions
; [eval] 0 < V ==> (forall i1: Int :: { aloc(opt_get1(source), i1) } (forall i2: Int :: { aloc(opt_get1(source), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(source), i1).option$array$ == aloc(opt_get1(source), i2).option$array$ ==> i1 == i2))
; [eval] 0 < V
(push) ; 4
; [then-branch: 227 | 0 < V@28@04 | dead]
; [else-branch: 227 | !(0 < V@28@04) | live]
(push) ; 5
; [else-branch: 227 | !(0 < V@28@04)]
(pop) ; 5
(pop) ; 4
; Joined path conditions
; [eval] 0 < V ==> target != (None(): option[array])
; [eval] 0 < V
(push) ; 4
; [then-branch: 228 | 0 < V@28@04 | dead]
; [else-branch: 228 | !(0 < V@28@04) | live]
(push) ; 5
; [else-branch: 228 | !(0 < V@28@04)]
(pop) ; 5
(pop) ; 4
; Joined path conditions
; [eval] 0 < V ==> alen(opt_get1(target)) == V
; [eval] 0 < V
(push) ; 4
; [then-branch: 229 | 0 < V@28@04 | dead]
; [else-branch: 229 | !(0 < V@28@04) | live]
(push) ; 5
; [else-branch: 229 | !(0 < V@28@04)]
(pop) ; 5
(pop) ; 4
; Joined path conditions
; [eval] 0 < V
; [then-branch: 230 | 0 < V@28@04 | dead]
; [else-branch: 230 | !(0 < V@28@04) | live]
(push) ; 4
; [else-branch: 230 | !(0 < V@28@04)]
; [eval] 0 < V ==> (forall i1: Int :: { aloc(opt_get1(target), i1) } 0 <= i1 && i1 < V ==> aloc(opt_get1(target), i1).option$array$ != (None(): option[array]))
; [eval] 0 < V
(push) ; 5
; [then-branch: 231 | 0 < V@28@04 | dead]
; [else-branch: 231 | !(0 < V@28@04) | live]
(push) ; 6
; [else-branch: 231 | !(0 < V@28@04)]
(pop) ; 6
(pop) ; 5
; Joined path conditions
; [eval] 0 < V ==> (forall i1: Int :: { alen(opt_get1(aloc(opt_get1(target), i1).option$array$)) } 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(target), i1).option$array$)) == V)
; [eval] 0 < V
(push) ; 5
; [then-branch: 232 | 0 < V@28@04 | dead]
; [else-branch: 232 | !(0 < V@28@04) | live]
(push) ; 6
; [else-branch: 232 | !(0 < V@28@04)]
(pop) ; 6
(pop) ; 5
; Joined path conditions
; [eval] 0 < V ==> (forall i1: Int :: { aloc(opt_get1(target), i1) } (forall i2: Int :: { aloc(opt_get1(target), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(target), i1).option$array$ == aloc(opt_get1(target), i2).option$array$ ==> i1 == i2))
; [eval] 0 < V
(push) ; 5
; [then-branch: 233 | 0 < V@28@04 | dead]
; [else-branch: 233 | !(0 < V@28@04) | live]
(push) ; 6
; [else-branch: 233 | !(0 < V@28@04)]
(pop) ; 6
(pop) ; 5
; Joined path conditions
(declare-const unknown@196@04 Int)
(declare-const unknown1@197@04 Int)
(push) ; 5
; [eval] 0 <= unknown && unknown < V && (0 <= unknown1 && unknown1 < V)
; [eval] 0 <= unknown
(push) ; 6
; [then-branch: 234 | 0 <= unknown@196@04 | live]
; [else-branch: 234 | !(0 <= unknown@196@04) | live]
(push) ; 7
; [then-branch: 234 | 0 <= unknown@196@04]
(assert (<= 0 unknown@196@04))
; [eval] unknown < V
(push) ; 8
; [then-branch: 235 | unknown@196@04 < V@28@04 | live]
; [else-branch: 235 | !(unknown@196@04 < V@28@04) | live]
(push) ; 9
; [then-branch: 235 | unknown@196@04 < V@28@04]
(assert (< unknown@196@04 V@28@04))
; [eval] 0 <= unknown1
(push) ; 10
; [then-branch: 236 | 0 <= unknown1@197@04 | live]
; [else-branch: 236 | !(0 <= unknown1@197@04) | live]
(push) ; 11
; [then-branch: 236 | 0 <= unknown1@197@04]
(assert (<= 0 unknown1@197@04))
; [eval] unknown1 < V
(pop) ; 11
(push) ; 11
; [else-branch: 236 | !(0 <= unknown1@197@04)]
(assert (not (<= 0 unknown1@197@04)))
(pop) ; 11
(pop) ; 10
; Joined path conditions
; Joined path conditions
(pop) ; 9
(push) ; 9
; [else-branch: 235 | !(unknown@196@04 < V@28@04)]
(assert (not (< unknown@196@04 V@28@04)))
(pop) ; 9
(pop) ; 8
; Joined path conditions
; Joined path conditions
(pop) ; 7
(push) ; 7
; [else-branch: 234 | !(0 <= unknown@196@04)]
(assert (not (<= 0 unknown@196@04)))
(pop) ; 7
(pop) ; 6
; Joined path conditions
; Joined path conditions
(assert (and
  (and
    (and (< unknown1@197@04 V@28@04) (<= 0 unknown1@197@04))
    (< unknown@196@04 V@28@04))
  (<= 0 unknown@196@04)))
; [eval] aloc(opt_get1(aloc(opt_get1(target), unknown1).option$array$), unknown)
; [eval] opt_get1(aloc(opt_get1(target), unknown1).option$array$)
; [eval] aloc(opt_get1(target), unknown1)
; [eval] opt_get1(target)
(push) ; 6
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 6
; Joined path conditions
(push) ; 6
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 7
(assert (not (< unknown1@197@04 (alen<Int> (opt_get1 $Snap.unit target@27@04)))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               128905
;  :arith-add-rows          89329
;  :arith-assert-diseq      7732
;  :arith-assert-lower      41694
;  :arith-assert-upper      27716
;  :arith-bound-prop        6257
;  :arith-conflicts         1166
;  :arith-eq-adapter        22255
;  :arith-fixed-eqs         15327
;  :arith-gcd-tests         3
;  :arith-grobner           294
;  :arith-ineq-splits       2
;  :arith-max-min           1922
;  :arith-nonlinear-bounds  233
;  :arith-nonlinear-horner  353
;  :arith-offset-eqs        18910
;  :arith-patches           4
;  :arith-patches_succ      1
;  :arith-pivots            12332
;  :arith-pseudo-nonlinear  60
;  :conflicts               2682
;  :datatype-accessor-ax    401
;  :datatype-constructor-ax 1726
;  :datatype-occurs-check   1004
;  :datatype-splits         1094
;  :decisions               19687
;  :del-clause              131268
;  :final-checks            511
;  :interface-eqs           91
;  :max-generation          14
;  :max-memory              18.34
;  :memory                  16.95
;  :minimized-lits          689
;  :mk-bool-var             162598
;  :mk-clause               131268
;  :num-allocs              945760
;  :num-checks              354
;  :propagations            97422
;  :quant-instantiations    37832
;  :restarts                4
;  :rlimit-count            5467477)
(assert (< unknown1@197@04 (alen<Int> (opt_get1 $Snap.unit target@27@04))))
(pop) ; 6
; Joined path conditions
(assert (< unknown1@197@04 (alen<Int> (opt_get1 $Snap.unit target@27@04))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@197@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@197@04)))
(push) ; 6
(assert (not (<
  $Perm.No
  (+
    (ite
      (and
        (<
          (inv@42@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@197@04))
          V@28@04)
        (<=
          0
          (inv@42@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@197@04))))
      $k@41@04
      $Perm.No)
    (ite
      (and
        (<
          (inv@34@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@197@04))
          V@28@04)
        (<=
          0
          (inv@34@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@197@04))))
      $k@33@04
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               128905
;  :arith-add-rows          89329
;  :arith-assert-diseq      7732
;  :arith-assert-lower      41694
;  :arith-assert-upper      27716
;  :arith-bound-prop        6257
;  :arith-conflicts         1166
;  :arith-eq-adapter        22255
;  :arith-fixed-eqs         15327
;  :arith-gcd-tests         3
;  :arith-grobner           294
;  :arith-ineq-splits       2
;  :arith-max-min           1922
;  :arith-nonlinear-bounds  233
;  :arith-nonlinear-horner  353
;  :arith-offset-eqs        18910
;  :arith-patches           4
;  :arith-patches_succ      1
;  :arith-pivots            12332
;  :arith-pseudo-nonlinear  60
;  :conflicts               2683
;  :datatype-accessor-ax    401
;  :datatype-constructor-ax 1726
;  :datatype-occurs-check   1004
;  :datatype-splits         1094
;  :decisions               19687
;  :del-clause              131278
;  :final-checks            511
;  :interface-eqs           91
;  :max-generation          14
;  :max-memory              18.34
;  :memory                  16.95
;  :minimized-lits          689
;  :mk-bool-var             162610
;  :mk-clause               131278
;  :num-allocs              945974
;  :num-checks              355
;  :propagations            97422
;  :quant-instantiations    37832
;  :restarts                4
;  :rlimit-count            5467960)
(push) ; 6
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 7
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@197@04))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               128905
;  :arith-add-rows          89329
;  :arith-assert-diseq      7732
;  :arith-assert-lower      41694
;  :arith-assert-upper      27716
;  :arith-bound-prop        6257
;  :arith-conflicts         1166
;  :arith-eq-adapter        22255
;  :arith-fixed-eqs         15327
;  :arith-gcd-tests         3
;  :arith-grobner           294
;  :arith-ineq-splits       2
;  :arith-max-min           1922
;  :arith-nonlinear-bounds  233
;  :arith-nonlinear-horner  353
;  :arith-offset-eqs        18910
;  :arith-patches           4
;  :arith-patches_succ      1
;  :arith-pivots            12332
;  :arith-pseudo-nonlinear  60
;  :conflicts               2684
;  :datatype-accessor-ax    401
;  :datatype-constructor-ax 1726
;  :datatype-occurs-check   1004
;  :datatype-splits         1094
;  :decisions               19687
;  :del-clause              131278
;  :final-checks            511
;  :interface-eqs           91
;  :max-generation          14
;  :max-memory              18.34
;  :memory                  16.95
;  :minimized-lits          689
;  :mk-bool-var             162611
;  :mk-clause               131278
;  :num-allocs              946069
;  :num-checks              356
;  :propagations            97422
;  :quant-instantiations    37832
;  :restarts                4
;  :rlimit-count            5468049)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@197@04))
    (as None<option<array>>  option<array>))))
(pop) ; 6
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@197@04))
    (as None<option<array>>  option<array>))))
(push) ; 6
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 7
(assert (not (<
  unknown@196@04
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@197@04)))))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               128905
;  :arith-add-rows          89329
;  :arith-assert-diseq      7732
;  :arith-assert-lower      41694
;  :arith-assert-upper      27716
;  :arith-bound-prop        6257
;  :arith-conflicts         1166
;  :arith-eq-adapter        22255
;  :arith-fixed-eqs         15327
;  :arith-gcd-tests         3
;  :arith-grobner           294
;  :arith-ineq-splits       2
;  :arith-max-min           1922
;  :arith-nonlinear-bounds  233
;  :arith-nonlinear-horner  353
;  :arith-offset-eqs        18910
;  :arith-patches           4
;  :arith-patches_succ      1
;  :arith-pivots            12332
;  :arith-pseudo-nonlinear  60
;  :conflicts               2685
;  :datatype-accessor-ax    401
;  :datatype-constructor-ax 1726
;  :datatype-occurs-check   1004
;  :datatype-splits         1094
;  :decisions               19687
;  :del-clause              131278
;  :final-checks            511
;  :interface-eqs           91
;  :max-generation          14
;  :max-memory              18.34
;  :memory                  16.95
;  :minimized-lits          689
;  :mk-bool-var             162613
;  :mk-clause               131278
;  :num-allocs              946226
;  :num-checks              357
;  :propagations            97422
;  :quant-instantiations    37832
;  :restarts                4
;  :rlimit-count            5468298)
(assert (<
  unknown@196@04
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@197@04))))))
(pop) ; 6
; Joined path conditions
(assert (<
  unknown@196@04
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@197@04))))))
(pop) ; 5
(declare-fun inv@198@04 ($Ref) Int)
(declare-fun inv@199@04 ($Ref) Int)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(assert (forall ((unknown@196@04 Int) (unknown1@197@04 Int)) (!
  (and
    (< unknown1@197@04 (alen<Int> (opt_get1 $Snap.unit target@27@04)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@197@04)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@197@04))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@197@04))
        (as None<option<array>>  option<array>)))
    (<
      unknown@196@04
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@197@04))))))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@197@04))) unknown@196@04))
  :qid |int-aux|)))
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 5
(assert (not (forall ((unknown1@196@04 Int) (unknown11@197@04 Int) (unknown2@196@04 Int) (unknown12@197@04 Int)) (!
  (implies
    (and
      (and
        (and
          (and
            (and (< unknown11@197@04 V@28@04) (<= 0 unknown11@197@04))
            (< unknown1@196@04 V@28@04))
          (<= 0 unknown1@196@04))
        ($FVF.loc_int ($FVF.lookup_int (as sm@58@04  $FVF<Int>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown11@197@04))) unknown1@196@04)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown11@197@04))) unknown1@196@04)))
      (and
        (and
          (and
            (and (< unknown12@197@04 V@28@04) (<= 0 unknown12@197@04))
            (< unknown2@196@04 V@28@04))
          (<= 0 unknown2@196@04))
        ($FVF.loc_int ($FVF.lookup_int (as sm@58@04  $FVF<Int>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown12@197@04))) unknown2@196@04)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown12@197@04))) unknown2@196@04)))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown11@197@04))) unknown1@196@04)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown12@197@04))) unknown2@196@04)))
    (and
      (= unknown1@196@04 unknown2@196@04)
      (= unknown11@197@04 unknown12@197@04)))
  
  :qid |int-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               128908
;  :arith-add-rows          89329
;  :arith-assert-diseq      7732
;  :arith-assert-lower      41702
;  :arith-assert-upper      27716
;  :arith-bound-prop        6257
;  :arith-conflicts         1167
;  :arith-eq-adapter        22257
;  :arith-fixed-eqs         15327
;  :arith-gcd-tests         3
;  :arith-grobner           294
;  :arith-ineq-splits       2
;  :arith-max-min           1922
;  :arith-nonlinear-bounds  233
;  :arith-nonlinear-horner  353
;  :arith-offset-eqs        18910
;  :arith-patches           4
;  :arith-patches_succ      1
;  :arith-pivots            12333
;  :arith-pseudo-nonlinear  60
;  :conflicts               2686
;  :datatype-accessor-ax    401
;  :datatype-constructor-ax 1726
;  :datatype-occurs-check   1004
;  :datatype-splits         1094
;  :decisions               19687
;  :del-clause              131287
;  :final-checks            511
;  :interface-eqs           91
;  :max-generation          14
;  :max-memory              18.34
;  :memory                  16.94
;  :minimized-lits          689
;  :mk-bool-var             162631
;  :mk-clause               131287
;  :num-allocs              946824
;  :num-checks              358
;  :propagations            97422
;  :quant-instantiations    37832
;  :restarts                4
;  :rlimit-count            5469620)
; Definitional axioms for inverse functions
(assert (forall ((unknown@196@04 Int) (unknown1@197@04 Int)) (!
  (implies
    (and
      (and
        (and (< unknown1@197@04 V@28@04) (<= 0 unknown1@197@04))
        (< unknown@196@04 V@28@04))
      (<= 0 unknown@196@04))
    (and
      (=
        (inv@198@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@197@04))) unknown@196@04))
        unknown@196@04)
      (=
        (inv@199@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@197@04))) unknown@196@04))
        unknown1@197@04)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@197@04))) unknown@196@04))
  :qid |int-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@199@04 r) V@28@04) (<= 0 (inv@199@04 r)))
        (< (inv@198@04 r) V@28@04))
      (<= 0 (inv@198@04 r)))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@27@04) (inv@199@04 r)))) (inv@198@04 r))
      r))
  :pattern ((inv@198@04 r))
  :pattern ((inv@199@04 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@199@04 r) V@28@04) (<= 0 (inv@199@04 r)))
        (< (inv@198@04 r) V@28@04))
      (<= 0 (inv@198@04 r)))
    ($FVF.loc_int ($FVF.lookup_int (as sm@58@04  $FVF<Int>) r) r))
  :pattern ((inv@198@04 r) (inv@199@04 r))
  )))
; Precomputing data for removing quantified permissions
(define-fun pTaken@200@04 ((r $Ref)) $Perm
  (ite
    (and
      (and
        (and (< (inv@199@04 r) V@28@04) (<= 0 (inv@199@04 r)))
        (< (inv@198@04 r) V@28@04))
      (<= 0 (inv@198@04 r)))
    ($Perm.min
      (ite
        (and
          (and
            (and (< (inv@57@04 r) V@28@04) (<= 0 (inv@57@04 r)))
            (< (inv@56@04 r) V@28@04))
          (<= 0 (inv@56@04 r)))
        $Perm.Write
        $Perm.No)
      $Perm.Write)
    $Perm.No))
(define-fun pTaken@201@04 ((r $Ref)) $Perm
  (ite
    (and
      (and
        (and (< (inv@199@04 r) V@28@04) (<= 0 (inv@199@04 r)))
        (< (inv@198@04 r) V@28@04))
      (<= 0 (inv@198@04 r)))
    ($Perm.min
      (ite
        (and
          (and
            (and (< (inv@52@04 r) V@28@04) (<= 0 (inv@52@04 r)))
            (< (inv@51@04 r) V@28@04))
          (<= 0 (inv@51@04 r)))
        $k@50@04
        $Perm.No)
      (- $Perm.Write (pTaken@200@04 r)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 500)
(push) ; 5
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and
          (and
            (and (< (inv@57@04 r) V@28@04) (<= 0 (inv@57@04 r)))
            (< (inv@56@04 r) V@28@04))
          (<= 0 (inv@56@04 r)))
        $Perm.Write
        $Perm.No)
      (pTaken@200@04 r))
    $Perm.No)
  
  ))))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               128941
;  :arith-add-rows          89329
;  :arith-assert-diseq      7733
;  :arith-assert-lower      41716
;  :arith-assert-upper      27723
;  :arith-bound-prop        6258
;  :arith-conflicts         1171
;  :arith-eq-adapter        22264
;  :arith-fixed-eqs         15327
;  :arith-gcd-tests         3
;  :arith-grobner           294
;  :arith-ineq-splits       2
;  :arith-max-min           1922
;  :arith-nonlinear-bounds  233
;  :arith-nonlinear-horner  353
;  :arith-offset-eqs        18910
;  :arith-patches           4
;  :arith-patches_succ      1
;  :arith-pivots            12339
;  :arith-pseudo-nonlinear  60
;  :conflicts               2695
;  :datatype-accessor-ax    401
;  :datatype-constructor-ax 1734
;  :datatype-occurs-check   1005
;  :datatype-splits         1094
;  :decisions               19699
;  :del-clause              131319
;  :final-checks            512
;  :interface-eqs           91
;  :max-generation          14
;  :max-memory              18.34
;  :memory                  16.92
;  :minimized-lits          689
;  :mk-bool-var             162674
;  :mk-clause               131319
;  :num-allocs              948401
;  :num-checks              360
;  :propagations            97442
;  :quant-instantiations    37833
;  :restarts                4
;  :rlimit-count            5472524)
; Intermediate check if already taken enough permissions
(push) ; 5
(assert (not (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@199@04 r) V@28@04) (<= 0 (inv@199@04 r)))
        (< (inv@198@04 r) V@28@04))
      (<= 0 (inv@198@04 r)))
    (= (- $Perm.Write (pTaken@200@04 r)) $Perm.No))
  
  ))))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               128943
;  :arith-add-rows          89329
;  :arith-assert-diseq      7733
;  :arith-assert-lower      41720
;  :arith-assert-upper      27723
;  :arith-bound-prop        6258
;  :arith-conflicts         1172
;  :arith-eq-adapter        22264
;  :arith-fixed-eqs         15327
;  :arith-gcd-tests         3
;  :arith-grobner           294
;  :arith-ineq-splits       2
;  :arith-max-min           1922
;  :arith-nonlinear-bounds  233
;  :arith-nonlinear-horner  353
;  :arith-offset-eqs        18910
;  :arith-patches           4
;  :arith-patches_succ      1
;  :arith-pivots            12341
;  :arith-pseudo-nonlinear  60
;  :conflicts               2696
;  :datatype-accessor-ax    401
;  :datatype-constructor-ax 1734
;  :datatype-occurs-check   1005
;  :datatype-splits         1094
;  :decisions               19699
;  :del-clause              131328
;  :final-checks            512
;  :interface-eqs           91
;  :max-generation          14
;  :max-memory              18.34
;  :memory                  16.92
;  :minimized-lits          689
;  :mk-bool-var             162692
;  :mk-clause               131328
;  :num-allocs              948734
;  :num-checks              361
;  :propagations            97442
;  :quant-instantiations    37833
;  :restarts                4
;  :rlimit-count            5473316)
; Final check if taken enough permissions
; Done removing quantified permissions
; Definitional axioms for snapshot map values
(declare-const unknown@202@04 Int)
(declare-const unknown1@203@04 Int)
(push) ; 5
; [eval] 0 <= unknown && unknown < V && (0 <= unknown1 && unknown1 < V)
; [eval] 0 <= unknown
(push) ; 6
; [then-branch: 237 | 0 <= unknown@202@04 | live]
; [else-branch: 237 | !(0 <= unknown@202@04) | live]
(push) ; 7
; [then-branch: 237 | 0 <= unknown@202@04]
(assert (<= 0 unknown@202@04))
; [eval] unknown < V
(push) ; 8
; [then-branch: 238 | unknown@202@04 < V@28@04 | live]
; [else-branch: 238 | !(unknown@202@04 < V@28@04) | live]
(push) ; 9
; [then-branch: 238 | unknown@202@04 < V@28@04]
(assert (< unknown@202@04 V@28@04))
; [eval] 0 <= unknown1
(push) ; 10
; [then-branch: 239 | 0 <= unknown1@203@04 | live]
; [else-branch: 239 | !(0 <= unknown1@203@04) | live]
(push) ; 11
; [then-branch: 239 | 0 <= unknown1@203@04]
(assert (<= 0 unknown1@203@04))
; [eval] unknown1 < V
(pop) ; 11
(push) ; 11
; [else-branch: 239 | !(0 <= unknown1@203@04)]
(assert (not (<= 0 unknown1@203@04)))
(pop) ; 11
(pop) ; 10
; Joined path conditions
; Joined path conditions
(pop) ; 9
(push) ; 9
; [else-branch: 238 | !(unknown@202@04 < V@28@04)]
(assert (not (< unknown@202@04 V@28@04)))
(pop) ; 9
(pop) ; 8
; Joined path conditions
; Joined path conditions
(pop) ; 7
(push) ; 7
; [else-branch: 237 | !(0 <= unknown@202@04)]
(assert (not (<= 0 unknown@202@04)))
(pop) ; 7
(pop) ; 6
; Joined path conditions
; Joined path conditions
(assert (and
  (and
    (and (< unknown1@203@04 V@28@04) (<= 0 unknown1@203@04))
    (< unknown@202@04 V@28@04))
  (<= 0 unknown@202@04)))
(declare-const $k@204@04 $Perm)
(assert ($Perm.isReadVar $k@204@04 $Perm.Write))
; [eval] aloc(opt_get1(aloc(opt_get1(source), unknown1).option$array$), unknown)
; [eval] opt_get1(aloc(opt_get1(source), unknown1).option$array$)
; [eval] aloc(opt_get1(source), unknown1)
; [eval] opt_get1(source)
(push) ; 6
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 6
; Joined path conditions
(push) ; 6
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 7
(assert (not (< unknown1@203@04 (alen<Int> (opt_get1 $Snap.unit source@26@04)))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               128943
;  :arith-add-rows          89329
;  :arith-assert-diseq      7734
;  :arith-assert-lower      41727
;  :arith-assert-upper      27725
;  :arith-bound-prop        6258
;  :arith-conflicts         1174
;  :arith-eq-adapter        22265
;  :arith-fixed-eqs         15327
;  :arith-gcd-tests         3
;  :arith-grobner           294
;  :arith-ineq-splits       2
;  :arith-max-min           1922
;  :arith-nonlinear-bounds  233
;  :arith-nonlinear-horner  353
;  :arith-offset-eqs        18910
;  :arith-patches           4
;  :arith-patches_succ      1
;  :arith-pivots            12343
;  :arith-pseudo-nonlinear  60
;  :conflicts               2698
;  :datatype-accessor-ax    401
;  :datatype-constructor-ax 1734
;  :datatype-occurs-check   1005
;  :datatype-splits         1094
;  :decisions               19699
;  :del-clause              131328
;  :final-checks            512
;  :interface-eqs           91
;  :max-generation          14
;  :max-memory              18.34
;  :memory                  16.92
;  :minimized-lits          689
;  :mk-bool-var             162702
;  :mk-clause               131330
;  :num-allocs              949083
;  :num-checks              362
;  :propagations            97443
;  :quant-instantiations    37833
;  :restarts                4
;  :rlimit-count            5473904)
(assert (< unknown1@203@04 (alen<Int> (opt_get1 $Snap.unit source@26@04))))
(pop) ; 6
; Joined path conditions
(assert (< unknown1@203@04 (alen<Int> (opt_get1 $Snap.unit source@26@04))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@203@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@203@04)))
(push) ; 6
(assert (not (<
  $Perm.No
  (+
    (ite
      (and
        (<
          (inv@42@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@203@04))
          V@28@04)
        (<=
          0
          (inv@42@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@203@04))))
      $k@41@04
      $Perm.No)
    (ite
      (and
        (<
          (inv@34@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@203@04))
          V@28@04)
        (<=
          0
          (inv@34@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@203@04))))
      $k@33@04
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               128943
;  :arith-add-rows          89329
;  :arith-assert-diseq      7734
;  :arith-assert-lower      41727
;  :arith-assert-upper      27725
;  :arith-bound-prop        6258
;  :arith-conflicts         1174
;  :arith-eq-adapter        22265
;  :arith-fixed-eqs         15327
;  :arith-gcd-tests         3
;  :arith-grobner           294
;  :arith-ineq-splits       2
;  :arith-max-min           1922
;  :arith-nonlinear-bounds  233
;  :arith-nonlinear-horner  353
;  :arith-offset-eqs        18910
;  :arith-patches           4
;  :arith-patches_succ      1
;  :arith-pivots            12343
;  :arith-pseudo-nonlinear  60
;  :conflicts               2699
;  :datatype-accessor-ax    401
;  :datatype-constructor-ax 1734
;  :datatype-occurs-check   1005
;  :datatype-splits         1094
;  :decisions               19699
;  :del-clause              131338
;  :final-checks            512
;  :interface-eqs           91
;  :max-generation          14
;  :max-memory              18.34
;  :memory                  16.92
;  :minimized-lits          689
;  :mk-bool-var             162714
;  :mk-clause               131340
;  :num-allocs              949296
;  :num-checks              363
;  :propagations            97443
;  :quant-instantiations    37833
;  :restarts                4
;  :rlimit-count            5474387)
(push) ; 6
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 7
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@203@04))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               128943
;  :arith-add-rows          89329
;  :arith-assert-diseq      7734
;  :arith-assert-lower      41727
;  :arith-assert-upper      27725
;  :arith-bound-prop        6258
;  :arith-conflicts         1174
;  :arith-eq-adapter        22265
;  :arith-fixed-eqs         15327
;  :arith-gcd-tests         3
;  :arith-grobner           294
;  :arith-ineq-splits       2
;  :arith-max-min           1922
;  :arith-nonlinear-bounds  233
;  :arith-nonlinear-horner  353
;  :arith-offset-eqs        18910
;  :arith-patches           4
;  :arith-patches_succ      1
;  :arith-pivots            12343
;  :arith-pseudo-nonlinear  60
;  :conflicts               2700
;  :datatype-accessor-ax    401
;  :datatype-constructor-ax 1734
;  :datatype-occurs-check   1005
;  :datatype-splits         1094
;  :decisions               19699
;  :del-clause              131338
;  :final-checks            512
;  :interface-eqs           91
;  :max-generation          14
;  :max-memory              18.34
;  :memory                  16.92
;  :minimized-lits          689
;  :mk-bool-var             162715
;  :mk-clause               131340
;  :num-allocs              949386
;  :num-checks              364
;  :propagations            97443
;  :quant-instantiations    37833
;  :restarts                4
;  :rlimit-count            5474476)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@203@04))
    (as None<option<array>>  option<array>))))
(pop) ; 6
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@203@04))
    (as None<option<array>>  option<array>))))
(push) ; 6
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 7
(assert (not (<
  unknown@202@04
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@203@04)))))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               128943
;  :arith-add-rows          89329
;  :arith-assert-diseq      7734
;  :arith-assert-lower      41727
;  :arith-assert-upper      27725
;  :arith-bound-prop        6258
;  :arith-conflicts         1174
;  :arith-eq-adapter        22265
;  :arith-fixed-eqs         15327
;  :arith-gcd-tests         3
;  :arith-grobner           294
;  :arith-ineq-splits       2
;  :arith-max-min           1922
;  :arith-nonlinear-bounds  233
;  :arith-nonlinear-horner  353
;  :arith-offset-eqs        18910
;  :arith-patches           4
;  :arith-patches_succ      1
;  :arith-pivots            12343
;  :arith-pseudo-nonlinear  60
;  :conflicts               2701
;  :datatype-accessor-ax    401
;  :datatype-constructor-ax 1734
;  :datatype-occurs-check   1005
;  :datatype-splits         1094
;  :decisions               19699
;  :del-clause              131338
;  :final-checks            512
;  :interface-eqs           91
;  :max-generation          14
;  :max-memory              18.34
;  :memory                  16.92
;  :minimized-lits          689
;  :mk-bool-var             162717
;  :mk-clause               131340
;  :num-allocs              949539
;  :num-checks              365
;  :propagations            97443
;  :quant-instantiations    37833
;  :restarts                4
;  :rlimit-count            5474729)
(assert (<
  unknown@202@04
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@203@04))))))
(pop) ; 6
; Joined path conditions
(assert (<
  unknown@202@04
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@203@04))))))
(pop) ; 5
(declare-fun inv@205@04 ($Ref) Int)
(declare-fun inv@206@04 ($Ref) Int)
; Nested auxiliary terms: globals
(assert ($Perm.isReadVar $k@204@04 $Perm.Write))
; Nested auxiliary terms: non-globals
(assert (forall ((unknown@202@04 Int) (unknown1@203@04 Int)) (!
  (and
    (< unknown1@203@04 (alen<Int> (opt_get1 $Snap.unit source@26@04)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@203@04)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@203@04))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@203@04))
        (as None<option<array>>  option<array>)))
    (<
      unknown@202@04
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@203@04))))))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@203@04))) unknown@202@04))
  :qid |int-aux|)))
(push) ; 5
(assert (not (forall ((unknown@202@04 Int) (unknown1@203@04 Int)) (!
  (implies
    (and
      (and
        (and (< unknown1@203@04 V@28@04) (<= 0 unknown1@203@04))
        (< unknown@202@04 V@28@04))
      (<= 0 unknown@202@04))
    (or (= $k@204@04 $Perm.No) (< $Perm.No $k@204@04)))
  
  ))))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               128943
;  :arith-add-rows          89329
;  :arith-assert-diseq      7735
;  :arith-assert-lower      41729
;  :arith-assert-upper      27726
;  :arith-bound-prop        6258
;  :arith-conflicts         1174
;  :arith-eq-adapter        22266
;  :arith-fixed-eqs         15327
;  :arith-gcd-tests         3
;  :arith-grobner           294
;  :arith-ineq-splits       2
;  :arith-max-min           1922
;  :arith-nonlinear-bounds  233
;  :arith-nonlinear-horner  353
;  :arith-offset-eqs        18910
;  :arith-patches           4
;  :arith-patches_succ      1
;  :arith-pivots            12343
;  :arith-pseudo-nonlinear  60
;  :conflicts               2702
;  :datatype-accessor-ax    401
;  :datatype-constructor-ax 1734
;  :datatype-occurs-check   1005
;  :datatype-splits         1094
;  :decisions               19699
;  :del-clause              131340
;  :final-checks            512
;  :interface-eqs           91
;  :max-generation          14
;  :max-memory              18.34
;  :memory                  16.92
;  :minimized-lits          689
;  :mk-bool-var             162726
;  :mk-clause               131342
;  :num-allocs              950069
;  :num-checks              366
;  :propagations            97444
;  :quant-instantiations    37833
;  :restarts                4
;  :rlimit-count            5475616)
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 5
(assert (not (forall ((unknown1@202@04 Int) (unknown11@203@04 Int) (unknown2@202@04 Int) (unknown12@203@04 Int)) (!
  (implies
    (and
      (and
        (and
          (and
            (and
              (and (< unknown11@203@04 V@28@04) (<= 0 unknown11@203@04))
              (< unknown1@202@04 V@28@04))
            (<= 0 unknown1@202@04))
          ($FVF.loc_int ($FVF.lookup_int (as sm@53@04  $FVF<Int>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown11@203@04))) unknown1@202@04)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown11@203@04))) unknown1@202@04)))
        (< $Perm.No $k@204@04))
      (and
        (and
          (and
            (and
              (and (< unknown12@203@04 V@28@04) (<= 0 unknown12@203@04))
              (< unknown2@202@04 V@28@04))
            (<= 0 unknown2@202@04))
          ($FVF.loc_int ($FVF.lookup_int (as sm@53@04  $FVF<Int>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown12@203@04))) unknown2@202@04)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown12@203@04))) unknown2@202@04)))
        (< $Perm.No $k@204@04))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown11@203@04))) unknown1@202@04)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown12@203@04))) unknown2@202@04)))
    (and
      (= unknown1@202@04 unknown2@202@04)
      (= unknown11@203@04 unknown12@203@04)))
  
  :qid |int-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               128946
;  :arith-add-rows          89329
;  :arith-assert-diseq      7735
;  :arith-assert-lower      41737
;  :arith-assert-upper      27726
;  :arith-bound-prop        6258
;  :arith-conflicts         1175
;  :arith-eq-adapter        22268
;  :arith-fixed-eqs         15327
;  :arith-gcd-tests         3
;  :arith-grobner           294
;  :arith-ineq-splits       2
;  :arith-max-min           1922
;  :arith-nonlinear-bounds  233
;  :arith-nonlinear-horner  353
;  :arith-offset-eqs        18910
;  :arith-patches           4
;  :arith-patches_succ      1
;  :arith-pivots            12343
;  :arith-pseudo-nonlinear  60
;  :conflicts               2703
;  :datatype-accessor-ax    401
;  :datatype-constructor-ax 1734
;  :datatype-occurs-check   1005
;  :datatype-splits         1094
;  :decisions               19699
;  :del-clause              131349
;  :final-checks            512
;  :interface-eqs           91
;  :max-generation          14
;  :max-memory              18.34
;  :memory                  16.92
;  :minimized-lits          689
;  :mk-bool-var             162743
;  :mk-clause               131351
;  :num-allocs              950485
;  :num-checks              367
;  :propagations            97444
;  :quant-instantiations    37833
;  :restarts                4
;  :rlimit-count            5476551)
; Definitional axioms for inverse functions
(assert (forall ((unknown@202@04 Int) (unknown1@203@04 Int)) (!
  (implies
    (and
      (and
        (and
          (and (< unknown1@203@04 V@28@04) (<= 0 unknown1@203@04))
          (< unknown@202@04 V@28@04))
        (<= 0 unknown@202@04))
      (< $Perm.No $k@204@04))
    (and
      (=
        (inv@205@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@203@04))) unknown@202@04))
        unknown@202@04)
      (=
        (inv@206@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@203@04))) unknown@202@04))
        unknown1@203@04)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@203@04))) unknown@202@04))
  :qid |int-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and
          (and (< (inv@206@04 r) V@28@04) (<= 0 (inv@206@04 r)))
          (< (inv@205@04 r) V@28@04))
        (<= 0 (inv@205@04 r)))
      (< $Perm.No $k@204@04))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@26@04) (inv@206@04 r)))) (inv@205@04 r))
      r))
  :pattern ((inv@205@04 r))
  :pattern ((inv@206@04 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@206@04 r) V@28@04) (<= 0 (inv@206@04 r)))
        (< (inv@205@04 r) V@28@04))
      (<= 0 (inv@205@04 r)))
    ($FVF.loc_int ($FVF.lookup_int (as sm@53@04  $FVF<Int>) r) r))
  :pattern ((inv@205@04 r) (inv@206@04 r))
  )))
; Precomputing data for removing quantified permissions
(define-fun pTaken@207@04 ((r $Ref)) $Perm
  (ite
    (and
      (and
        (and (< (inv@206@04 r) V@28@04) (<= 0 (inv@206@04 r)))
        (< (inv@205@04 r) V@28@04))
      (<= 0 (inv@205@04 r)))
    ($Perm.min
      (ite
        (and
          (and
            (and (< (inv@52@04 r) V@28@04) (<= 0 (inv@52@04 r)))
            (< (inv@51@04 r) V@28@04))
          (<= 0 (inv@51@04 r)))
        $k@50@04
        $Perm.No)
      $k@204@04)
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Constrain original permissions $k@204@04
(assert (forall ((r $Ref)) (!
  (implies
    (not
      (=
        (ite
          (and
            (and
              (and (< (inv@52@04 r) V@28@04) (<= 0 (inv@52@04 r)))
              (< (inv@51@04 r) V@28@04))
            (<= 0 (inv@51@04 r)))
          $k@50@04
          $Perm.No)
        $Perm.No))
    (ite
      (and
        (and
          (and (< (inv@52@04 r) V@28@04) (<= 0 (inv@52@04 r)))
          (< (inv@51@04 r) V@28@04))
        (<= 0 (inv@51@04 r)))
      (<
        (ite
          (and
            (and
              (and (< (inv@206@04 r) V@28@04) (<= 0 (inv@206@04 r)))
              (< (inv@205@04 r) V@28@04))
            (<= 0 (inv@205@04 r)))
          $k@204@04
          $Perm.No)
        $k@50@04)
      (<
        (ite
          (and
            (and
              (and (< (inv@206@04 r) V@28@04) (<= 0 (inv@206@04 r)))
              (< (inv@205@04 r) V@28@04))
            (<= 0 (inv@205@04 r)))
          $k@204@04
          $Perm.No)
        $Perm.No)))
  :pattern ((inv@52@04 r))
  :pattern ((inv@51@04 r))
  :pattern ((inv@206@04 r))
  :pattern ((inv@205@04 r))
  :qid |qp.srp62|)))
; Intermediate check if already taken enough permissions
(set-option :timeout 500)
(push) ; 5
(assert (not (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@206@04 r) V@28@04) (<= 0 (inv@206@04 r)))
        (< (inv@205@04 r) V@28@04))
      (<= 0 (inv@205@04 r)))
    (= (- $k@204@04 (pTaken@207@04 r)) $Perm.No))
  
  ))))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               128958
;  :arith-add-rows          89329
;  :arith-assert-diseq      7736
;  :arith-assert-lower      41741
;  :arith-assert-upper      27726
;  :arith-bound-prop        6258
;  :arith-conflicts         1176
;  :arith-eq-adapter        22269
;  :arith-fixed-eqs         15327
;  :arith-gcd-tests         3
;  :arith-grobner           294
;  :arith-ineq-splits       2
;  :arith-max-min           1922
;  :arith-nonlinear-bounds  233
;  :arith-nonlinear-horner  353
;  :arith-offset-eqs        18910
;  :arith-patches           4
;  :arith-patches_succ      1
;  :arith-pivots            12343
;  :arith-pseudo-nonlinear  60
;  :conflicts               2704
;  :datatype-accessor-ax    401
;  :datatype-constructor-ax 1738
;  :datatype-occurs-check   1006
;  :datatype-splits         1094
;  :decisions               19703
;  :del-clause              131364
;  :final-checks            513
;  :interface-eqs           91
;  :max-generation          14
;  :max-memory              18.34
;  :memory                  16.92
;  :minimized-lits          689
;  :mk-bool-var             162767
;  :mk-clause               131364
;  :num-allocs              952253
;  :num-checks              369
;  :propagations            97444
;  :quant-instantiations    37833
;  :restarts                4
;  :rlimit-count            5480118)
; Final check if taken enough permissions
; Done removing quantified permissions
; Definitional axioms for snapshot map values
(declare-const exc@208@04 $Ref)
(declare-const res@209@04 void)
(declare-const $t@210@04 $Snap)
(assert (= $t@210@04 ($Snap.combine ($Snap.first $t@210@04) ($Snap.second $t@210@04))))
(assert (= ($Snap.first $t@210@04) $Snap.unit))
; [eval] exc == null
(assert (= exc@208@04 $Ref.null))
(assert (=
  ($Snap.second $t@210@04)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@210@04))
    ($Snap.second ($Snap.second $t@210@04)))))
(assert (= ($Snap.first ($Snap.second $t@210@04)) $Snap.unit))
; [eval] exc == null && 0 < V ==> source != (None(): option[array])
; [eval] exc == null && 0 < V
; [eval] exc == null
(push) ; 5
; [then-branch: 240 | exc@208@04 == Null | live]
; [else-branch: 240 | exc@208@04 != Null | live]
(push) ; 6
; [then-branch: 240 | exc@208@04 == Null]
; [eval] 0 < V
(pop) ; 6
(push) ; 6
; [else-branch: 240 | exc@208@04 != Null]
(assert (not (= exc@208@04 $Ref.null)))
(pop) ; 6
(pop) ; 5
; Joined path conditions
; Joined path conditions
(push) ; 5
(set-option :timeout 10)
(push) ; 6
(assert (not (not (and (< 0 V@28@04) (= exc@208@04 $Ref.null)))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               128971
;  :arith-add-rows          89329
;  :arith-assert-diseq      7736
;  :arith-assert-lower      41741
;  :arith-assert-upper      27726
;  :arith-bound-prop        6258
;  :arith-conflicts         1176
;  :arith-eq-adapter        22269
;  :arith-fixed-eqs         15327
;  :arith-gcd-tests         3
;  :arith-grobner           294
;  :arith-ineq-splits       2
;  :arith-max-min           1922
;  :arith-nonlinear-bounds  233
;  :arith-nonlinear-horner  353
;  :arith-offset-eqs        18910
;  :arith-patches           4
;  :arith-patches_succ      1
;  :arith-pivots            12343
;  :arith-pseudo-nonlinear  60
;  :conflicts               2704
;  :datatype-accessor-ax    403
;  :datatype-constructor-ax 1738
;  :datatype-occurs-check   1006
;  :datatype-splits         1094
;  :decisions               19703
;  :del-clause              131364
;  :final-checks            513
;  :interface-eqs           91
;  :max-generation          14
;  :max-memory              18.34
;  :memory                  16.93
;  :minimized-lits          689
;  :mk-bool-var             162772
;  :mk-clause               131364
;  :num-allocs              952443
;  :num-checks              370
;  :propagations            97444
;  :quant-instantiations    37833
;  :restarts                4
;  :rlimit-count            5480444)
; [then-branch: 241 | 0 < V@28@04 && exc@208@04 == Null | dead]
; [else-branch: 241 | !(0 < V@28@04 && exc@208@04 == Null) | live]
(push) ; 6
; [else-branch: 241 | !(0 < V@28@04 && exc@208@04 == Null)]
(assert (not (and (< 0 V@28@04) (= exc@208@04 $Ref.null))))
(pop) ; 6
(pop) ; 5
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second $t@210@04))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second $t@210@04)))
    ($Snap.second ($Snap.second ($Snap.second $t@210@04))))))
(assert (= ($Snap.first ($Snap.second ($Snap.second $t@210@04))) $Snap.unit))
; [eval] exc == null && 0 < V ==> alen(opt_get1(source)) == V
; [eval] exc == null && 0 < V
; [eval] exc == null
(push) ; 5
; [then-branch: 242 | exc@208@04 == Null | live]
; [else-branch: 242 | exc@208@04 != Null | live]
(push) ; 6
; [then-branch: 242 | exc@208@04 == Null]
; [eval] 0 < V
(pop) ; 6
(push) ; 6
; [else-branch: 242 | exc@208@04 != Null]
(assert (not (= exc@208@04 $Ref.null)))
(pop) ; 6
(pop) ; 5
; Joined path conditions
; Joined path conditions
(push) ; 5
(push) ; 6
(assert (not (not (and (< 0 V@28@04) (= exc@208@04 $Ref.null)))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               128977
;  :arith-add-rows          89329
;  :arith-assert-diseq      7736
;  :arith-assert-lower      41741
;  :arith-assert-upper      27726
;  :arith-bound-prop        6258
;  :arith-conflicts         1176
;  :arith-eq-adapter        22269
;  :arith-fixed-eqs         15327
;  :arith-gcd-tests         3
;  :arith-grobner           294
;  :arith-ineq-splits       2
;  :arith-max-min           1922
;  :arith-nonlinear-bounds  233
;  :arith-nonlinear-horner  353
;  :arith-offset-eqs        18910
;  :arith-patches           4
;  :arith-patches_succ      1
;  :arith-pivots            12343
;  :arith-pseudo-nonlinear  60
;  :conflicts               2704
;  :datatype-accessor-ax    404
;  :datatype-constructor-ax 1738
;  :datatype-occurs-check   1006
;  :datatype-splits         1094
;  :decisions               19703
;  :del-clause              131364
;  :final-checks            513
;  :interface-eqs           91
;  :max-generation          14
;  :max-memory              18.34
;  :memory                  16.93
;  :minimized-lits          689
;  :mk-bool-var             162774
;  :mk-clause               131364
;  :num-allocs              952551
;  :num-checks              371
;  :propagations            97444
;  :quant-instantiations    37833
;  :restarts                4
;  :rlimit-count            5480651)
; [then-branch: 243 | 0 < V@28@04 && exc@208@04 == Null | dead]
; [else-branch: 243 | !(0 < V@28@04 && exc@208@04 == Null) | live]
(push) ; 6
; [else-branch: 243 | !(0 < V@28@04 && exc@208@04 == Null)]
(assert (not (and (< 0 V@28@04) (= exc@208@04 $Ref.null))))
(pop) ; 6
(pop) ; 5
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second ($Snap.second $t@210@04)))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@210@04))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@210@04)))))))
; [eval] exc == null && 0 < V
; [eval] exc == null
(push) ; 5
; [then-branch: 244 | exc@208@04 == Null | live]
; [else-branch: 244 | exc@208@04 != Null | live]
(push) ; 6
; [then-branch: 244 | exc@208@04 == Null]
; [eval] 0 < V
(pop) ; 6
(push) ; 6
; [else-branch: 244 | exc@208@04 != Null]
(assert (not (= exc@208@04 $Ref.null)))
(pop) ; 6
(pop) ; 5
; Joined path conditions
; Joined path conditions
(push) ; 5
(assert (not (not (and (< 0 V@28@04) (= exc@208@04 $Ref.null)))))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               128982
;  :arith-add-rows          89329
;  :arith-assert-diseq      7736
;  :arith-assert-lower      41741
;  :arith-assert-upper      27726
;  :arith-bound-prop        6258
;  :arith-conflicts         1176
;  :arith-eq-adapter        22269
;  :arith-fixed-eqs         15327
;  :arith-gcd-tests         3
;  :arith-grobner           294
;  :arith-ineq-splits       2
;  :arith-max-min           1922
;  :arith-nonlinear-bounds  233
;  :arith-nonlinear-horner  353
;  :arith-offset-eqs        18910
;  :arith-patches           4
;  :arith-patches_succ      1
;  :arith-pivots            12343
;  :arith-pseudo-nonlinear  60
;  :conflicts               2704
;  :datatype-accessor-ax    405
;  :datatype-constructor-ax 1738
;  :datatype-occurs-check   1006
;  :datatype-splits         1094
;  :decisions               19703
;  :del-clause              131364
;  :final-checks            513
;  :interface-eqs           91
;  :max-generation          14
;  :max-memory              18.34
;  :memory                  16.93
;  :minimized-lits          689
;  :mk-bool-var             162775
;  :mk-clause               131364
;  :num-allocs              952661
;  :num-checks              372
;  :propagations            97444
;  :quant-instantiations    37833
;  :restarts                4
;  :rlimit-count            5480831)
; [then-branch: 245 | 0 < V@28@04 && exc@208@04 == Null | dead]
; [else-branch: 245 | !(0 < V@28@04 && exc@208@04 == Null) | live]
(push) ; 5
; [else-branch: 245 | !(0 < V@28@04 && exc@208@04 == Null)]
(assert (not (and (< 0 V@28@04) (= exc@208@04 $Ref.null))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@210@04))))
  $Snap.unit))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@210@04))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@210@04)))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@210@04))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@210@04)))))
  $Snap.unit))
; [eval] exc == null && 0 < V ==> (forall i1: Int :: { aloc(opt_get1(source), i1) } 0 <= i1 && i1 < V ==> aloc(opt_get1(source), i1).option$array$ != (None(): option[array]))
; [eval] exc == null && 0 < V
; [eval] exc == null
(push) ; 6
; [then-branch: 246 | exc@208@04 == Null | live]
; [else-branch: 246 | exc@208@04 != Null | live]
(push) ; 7
; [then-branch: 246 | exc@208@04 == Null]
; [eval] 0 < V
(pop) ; 7
(push) ; 7
; [else-branch: 246 | exc@208@04 != Null]
(assert (not (= exc@208@04 $Ref.null)))
(pop) ; 7
(pop) ; 6
; Joined path conditions
; Joined path conditions
(push) ; 6
; [then-branch: 247 | 0 < V@28@04 && exc@208@04 == Null | dead]
; [else-branch: 247 | !(0 < V@28@04 && exc@208@04 == Null) | live]
(push) ; 7
; [else-branch: 247 | !(0 < V@28@04 && exc@208@04 == Null)]
(pop) ; 7
(pop) ; 6
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@210@04)))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@210@04))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@210@04)))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@210@04))))))
  $Snap.unit))
; [eval] exc == null && 0 < V ==> (forall i1: Int :: { alen(opt_get1(aloc(opt_get1(source), i1).option$array$)) } 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(source), i1).option$array$)) == V)
; [eval] exc == null && 0 < V
; [eval] exc == null
(push) ; 6
; [then-branch: 248 | exc@208@04 == Null | live]
; [else-branch: 248 | exc@208@04 != Null | live]
(push) ; 7
; [then-branch: 248 | exc@208@04 == Null]
; [eval] 0 < V
(pop) ; 7
(push) ; 7
; [else-branch: 248 | exc@208@04 != Null]
(assert (not (= exc@208@04 $Ref.null)))
(pop) ; 7
(pop) ; 6
; Joined path conditions
; Joined path conditions
(push) ; 6
; [then-branch: 249 | 0 < V@28@04 && exc@208@04 == Null | dead]
; [else-branch: 249 | !(0 < V@28@04 && exc@208@04 == Null) | live]
(push) ; 7
; [else-branch: 249 | !(0 < V@28@04 && exc@208@04 == Null)]
(pop) ; 7
(pop) ; 6
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@210@04))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@210@04)))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@210@04))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@210@04)))))))
  $Snap.unit))
; [eval] exc == null && 0 < V ==> (forall i1: Int :: { aloc(opt_get1(source), i1) } (forall i2: Int :: { aloc(opt_get1(source), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(source), i1).option$array$ == aloc(opt_get1(source), i2).option$array$ ==> i1 == i2))
; [eval] exc == null && 0 < V
; [eval] exc == null
(push) ; 6
; [then-branch: 250 | exc@208@04 == Null | live]
; [else-branch: 250 | exc@208@04 != Null | live]
(push) ; 7
; [then-branch: 250 | exc@208@04 == Null]
; [eval] 0 < V
(pop) ; 7
(push) ; 7
; [else-branch: 250 | exc@208@04 != Null]
(assert (not (= exc@208@04 $Ref.null)))
(pop) ; 7
(pop) ; 6
; Joined path conditions
; Joined path conditions
(push) ; 6
; [then-branch: 251 | 0 < V@28@04 && exc@208@04 == Null | dead]
; [else-branch: 251 | !(0 < V@28@04 && exc@208@04 == Null) | live]
(push) ; 7
; [else-branch: 251 | !(0 < V@28@04 && exc@208@04 == Null)]
(pop) ; 7
(pop) ; 6
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@210@04)))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@210@04))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@210@04)))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@210@04))))))))
  $Snap.unit))
; [eval] exc == null && 0 < V ==> target != (None(): option[array])
; [eval] exc == null && 0 < V
; [eval] exc == null
(push) ; 6
; [then-branch: 252 | exc@208@04 == Null | live]
; [else-branch: 252 | exc@208@04 != Null | live]
(push) ; 7
; [then-branch: 252 | exc@208@04 == Null]
; [eval] 0 < V
(pop) ; 7
(push) ; 7
; [else-branch: 252 | exc@208@04 != Null]
(assert (not (= exc@208@04 $Ref.null)))
(pop) ; 7
(pop) ; 6
; Joined path conditions
; Joined path conditions
(push) ; 6
; [then-branch: 253 | 0 < V@28@04 && exc@208@04 == Null | dead]
; [else-branch: 253 | !(0 < V@28@04 && exc@208@04 == Null) | live]
(push) ; 7
; [else-branch: 253 | !(0 < V@28@04 && exc@208@04 == Null)]
(pop) ; 7
(pop) ; 6
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@210@04))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@210@04)))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@210@04))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@210@04)))))))))
  $Snap.unit))
; [eval] exc == null && 0 < V ==> alen(opt_get1(target)) == V
; [eval] exc == null && 0 < V
; [eval] exc == null
(push) ; 6
; [then-branch: 254 | exc@208@04 == Null | live]
; [else-branch: 254 | exc@208@04 != Null | live]
(push) ; 7
; [then-branch: 254 | exc@208@04 == Null]
; [eval] 0 < V
(pop) ; 7
(push) ; 7
; [else-branch: 254 | exc@208@04 != Null]
(assert (not (= exc@208@04 $Ref.null)))
(pop) ; 7
(pop) ; 6
; Joined path conditions
; Joined path conditions
(push) ; 6
; [then-branch: 255 | 0 < V@28@04 && exc@208@04 == Null | dead]
; [else-branch: 255 | !(0 < V@28@04 && exc@208@04 == Null) | live]
(push) ; 7
; [else-branch: 255 | !(0 < V@28@04 && exc@208@04 == Null)]
(pop) ; 7
(pop) ; 6
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@210@04)))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@210@04))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@210@04)))))))))))))
; [eval] exc == null && 0 < V
; [eval] exc == null
(push) ; 6
; [then-branch: 256 | exc@208@04 == Null | live]
; [else-branch: 256 | exc@208@04 != Null | live]
(push) ; 7
; [then-branch: 256 | exc@208@04 == Null]
; [eval] 0 < V
(pop) ; 7
(push) ; 7
; [else-branch: 256 | exc@208@04 != Null]
(assert (not (= exc@208@04 $Ref.null)))
(pop) ; 7
(pop) ; 6
; Joined path conditions
; Joined path conditions
; [then-branch: 257 | 0 < V@28@04 && exc@208@04 == Null | dead]
; [else-branch: 257 | !(0 < V@28@04 && exc@208@04 == Null) | live]
(push) ; 6
; [else-branch: 257 | !(0 < V@28@04 && exc@208@04 == Null)]
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@210@04))))))))))
  $Snap.unit))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@210@04))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@210@04)))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@210@04))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@210@04)))))))))))
  $Snap.unit))
; [eval] exc == null && 0 < V ==> (forall i1: Int :: { aloc(opt_get1(target), i1) } 0 <= i1 && i1 < V ==> aloc(opt_get1(target), i1).option$array$ != (None(): option[array]))
; [eval] exc == null && 0 < V
; [eval] exc == null
(push) ; 7
; [then-branch: 258 | exc@208@04 == Null | live]
; [else-branch: 258 | exc@208@04 != Null | live]
(push) ; 8
; [then-branch: 258 | exc@208@04 == Null]
; [eval] 0 < V
(pop) ; 8
(push) ; 8
; [else-branch: 258 | exc@208@04 != Null]
(assert (not (= exc@208@04 $Ref.null)))
(pop) ; 8
(pop) ; 7
; Joined path conditions
; Joined path conditions
(push) ; 7
; [then-branch: 259 | 0 < V@28@04 && exc@208@04 == Null | dead]
; [else-branch: 259 | !(0 < V@28@04 && exc@208@04 == Null) | live]
(push) ; 8
; [else-branch: 259 | !(0 < V@28@04 && exc@208@04 == Null)]
(pop) ; 8
(pop) ; 7
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@210@04)))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@210@04))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@210@04)))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@210@04))))))))))))
  $Snap.unit))
; [eval] exc == null && 0 < V ==> (forall i1: Int :: { alen(opt_get1(aloc(opt_get1(target), i1).option$array$)) } 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(target), i1).option$array$)) == V)
; [eval] exc == null && 0 < V
; [eval] exc == null
(push) ; 7
; [then-branch: 260 | exc@208@04 == Null | live]
; [else-branch: 260 | exc@208@04 != Null | live]
(push) ; 8
; [then-branch: 260 | exc@208@04 == Null]
; [eval] 0 < V
(pop) ; 8
(push) ; 8
; [else-branch: 260 | exc@208@04 != Null]
(assert (not (= exc@208@04 $Ref.null)))
(pop) ; 8
(pop) ; 7
; Joined path conditions
; Joined path conditions
(push) ; 7
; [then-branch: 261 | 0 < V@28@04 && exc@208@04 == Null | dead]
; [else-branch: 261 | !(0 < V@28@04 && exc@208@04 == Null) | live]
(push) ; 8
; [else-branch: 261 | !(0 < V@28@04 && exc@208@04 == Null)]
(pop) ; 8
(pop) ; 7
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@210@04))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@210@04)))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@210@04))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@210@04)))))))))))))
  $Snap.unit))
; [eval] exc == null && 0 < V ==> (forall i1: Int :: { aloc(opt_get1(target), i1) } (forall i2: Int :: { aloc(opt_get1(target), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(target), i1).option$array$ == aloc(opt_get1(target), i2).option$array$ ==> i1 == i2))
; [eval] exc == null && 0 < V
; [eval] exc == null
(push) ; 7
; [then-branch: 262 | exc@208@04 == Null | live]
; [else-branch: 262 | exc@208@04 != Null | live]
(push) ; 8
; [then-branch: 262 | exc@208@04 == Null]
; [eval] 0 < V
(pop) ; 8
(push) ; 8
; [else-branch: 262 | exc@208@04 != Null]
(assert (not (= exc@208@04 $Ref.null)))
(pop) ; 8
(pop) ; 7
; Joined path conditions
; Joined path conditions
(push) ; 7
; [then-branch: 263 | 0 < V@28@04 && exc@208@04 == Null | dead]
; [else-branch: 263 | !(0 < V@28@04 && exc@208@04 == Null) | live]
(push) ; 8
; [else-branch: 263 | !(0 < V@28@04 && exc@208@04 == Null)]
(pop) ; 8
(pop) ; 7
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@210@04)))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@210@04))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@210@04)))))))))))))))))
; [eval] exc == null
(push) ; 7
(assert (not (not (= exc@208@04 $Ref.null))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               129071
;  :arith-add-rows          89329
;  :arith-assert-diseq      7736
;  :arith-assert-lower      41741
;  :arith-assert-upper      27726
;  :arith-bound-prop        6258
;  :arith-conflicts         1176
;  :arith-eq-adapter        22269
;  :arith-fixed-eqs         15327
;  :arith-gcd-tests         3
;  :arith-grobner           294
;  :arith-ineq-splits       2
;  :arith-max-min           1922
;  :arith-nonlinear-bounds  233
;  :arith-nonlinear-horner  353
;  :arith-offset-eqs        18910
;  :arith-patches           4
;  :arith-patches_succ      1
;  :arith-pivots            12343
;  :arith-pseudo-nonlinear  60
;  :conflicts               2704
;  :datatype-accessor-ax    415
;  :datatype-constructor-ax 1744
;  :datatype-occurs-check   1011
;  :datatype-splits         1096
;  :decisions               19709
;  :del-clause              131364
;  :final-checks            515
;  :interface-eqs           91
;  :max-generation          14
;  :max-memory              18.34
;  :memory                  16.94
;  :minimized-lits          689
;  :mk-bool-var             162797
;  :mk-clause               131364
;  :num-allocs              954369
;  :num-checks              373
;  :propagations            97444
;  :quant-instantiations    37833
;  :restarts                4
;  :rlimit-count            5483929)
; [then-branch: 264 | exc@208@04 == Null | live]
; [else-branch: 264 | exc@208@04 != Null | dead]
(push) ; 7
; [then-branch: 264 | exc@208@04 == Null]
(declare-const unknown@211@04 Int)
(declare-const unknown1@212@04 Int)
(push) ; 8
; [eval] 0 <= unknown && unknown < V && (0 <= unknown1 && unknown1 < V)
; [eval] 0 <= unknown
(push) ; 9
; [then-branch: 265 | 0 <= unknown@211@04 | live]
; [else-branch: 265 | !(0 <= unknown@211@04) | live]
(push) ; 10
; [then-branch: 265 | 0 <= unknown@211@04]
(assert (<= 0 unknown@211@04))
; [eval] unknown < V
(push) ; 11
; [then-branch: 266 | unknown@211@04 < V@28@04 | live]
; [else-branch: 266 | !(unknown@211@04 < V@28@04) | live]
(push) ; 12
; [then-branch: 266 | unknown@211@04 < V@28@04]
(assert (< unknown@211@04 V@28@04))
; [eval] 0 <= unknown1
(push) ; 13
; [then-branch: 267 | 0 <= unknown1@212@04 | live]
; [else-branch: 267 | !(0 <= unknown1@212@04) | live]
(push) ; 14
; [then-branch: 267 | 0 <= unknown1@212@04]
(assert (<= 0 unknown1@212@04))
; [eval] unknown1 < V
(pop) ; 14
(push) ; 14
; [else-branch: 267 | !(0 <= unknown1@212@04)]
(assert (not (<= 0 unknown1@212@04)))
(pop) ; 14
(pop) ; 13
; Joined path conditions
; Joined path conditions
(pop) ; 12
(push) ; 12
; [else-branch: 266 | !(unknown@211@04 < V@28@04)]
(assert (not (< unknown@211@04 V@28@04)))
(pop) ; 12
(pop) ; 11
; Joined path conditions
; Joined path conditions
(pop) ; 10
(push) ; 10
; [else-branch: 265 | !(0 <= unknown@211@04)]
(assert (not (<= 0 unknown@211@04)))
(pop) ; 10
(pop) ; 9
; Joined path conditions
; Joined path conditions
(assert (and
  (and
    (and (< unknown1@212@04 V@28@04) (<= 0 unknown1@212@04))
    (< unknown@211@04 V@28@04))
  (<= 0 unknown@211@04)))
; [eval] aloc(opt_get1(aloc(opt_get1(target), unknown1).option$array$), unknown)
; [eval] opt_get1(aloc(opt_get1(target), unknown1).option$array$)
; [eval] aloc(opt_get1(target), unknown1)
; [eval] opt_get1(target)
(push) ; 9
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 9
; Joined path conditions
(push) ; 9
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 10
(assert (not (< unknown1@212@04 (alen<Int> (opt_get1 $Snap.unit target@27@04)))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               129071
;  :arith-add-rows          89329
;  :arith-assert-diseq      7736
;  :arith-assert-lower      41747
;  :arith-assert-upper      27726
;  :arith-bound-prop        6258
;  :arith-conflicts         1178
;  :arith-eq-adapter        22269
;  :arith-fixed-eqs         15327
;  :arith-gcd-tests         3
;  :arith-grobner           294
;  :arith-ineq-splits       2
;  :arith-max-min           1922
;  :arith-nonlinear-bounds  233
;  :arith-nonlinear-horner  353
;  :arith-offset-eqs        18910
;  :arith-patches           4
;  :arith-patches_succ      1
;  :arith-pivots            12346
;  :arith-pseudo-nonlinear  60
;  :conflicts               2706
;  :datatype-accessor-ax    415
;  :datatype-constructor-ax 1744
;  :datatype-occurs-check   1011
;  :datatype-splits         1096
;  :decisions               19709
;  :del-clause              131364
;  :final-checks            515
;  :interface-eqs           91
;  :max-generation          14
;  :max-memory              18.34
;  :memory                  16.94
;  :minimized-lits          689
;  :mk-bool-var             162803
;  :mk-clause               131364
;  :num-allocs              954645
;  :num-checks              374
;  :propagations            97444
;  :quant-instantiations    37833
;  :restarts                4
;  :rlimit-count            5484395)
(assert (< unknown1@212@04 (alen<Int> (opt_get1 $Snap.unit target@27@04))))
(pop) ; 9
; Joined path conditions
(assert (< unknown1@212@04 (alen<Int> (opt_get1 $Snap.unit target@27@04))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@212@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@212@04)))
(push) ; 9
(assert (not (<
  $Perm.No
  (+
    (ite
      (and
        (<
          (inv@42@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@212@04))
          V@28@04)
        (<=
          0
          (inv@42@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@212@04))))
      $k@41@04
      $Perm.No)
    (ite
      (and
        (<
          (inv@34@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@212@04))
          V@28@04)
        (<=
          0
          (inv@34@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@212@04))))
      $k@33@04
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               129071
;  :arith-add-rows          89329
;  :arith-assert-diseq      7736
;  :arith-assert-lower      41747
;  :arith-assert-upper      27726
;  :arith-bound-prop        6258
;  :arith-conflicts         1178
;  :arith-eq-adapter        22269
;  :arith-fixed-eqs         15327
;  :arith-gcd-tests         3
;  :arith-grobner           294
;  :arith-ineq-splits       2
;  :arith-max-min           1922
;  :arith-nonlinear-bounds  233
;  :arith-nonlinear-horner  353
;  :arith-offset-eqs        18910
;  :arith-patches           4
;  :arith-patches_succ      1
;  :arith-pivots            12346
;  :arith-pseudo-nonlinear  60
;  :conflicts               2707
;  :datatype-accessor-ax    415
;  :datatype-constructor-ax 1744
;  :datatype-occurs-check   1011
;  :datatype-splits         1096
;  :decisions               19709
;  :del-clause              131374
;  :final-checks            515
;  :interface-eqs           91
;  :max-generation          14
;  :max-memory              18.34
;  :memory                  16.94
;  :minimized-lits          689
;  :mk-bool-var             162815
;  :mk-clause               131374
;  :num-allocs              954857
;  :num-checks              375
;  :propagations            97444
;  :quant-instantiations    37833
;  :restarts                4
;  :rlimit-count            5484878)
(push) ; 9
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 10
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@212@04))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               129071
;  :arith-add-rows          89329
;  :arith-assert-diseq      7736
;  :arith-assert-lower      41747
;  :arith-assert-upper      27726
;  :arith-bound-prop        6258
;  :arith-conflicts         1178
;  :arith-eq-adapter        22269
;  :arith-fixed-eqs         15327
;  :arith-gcd-tests         3
;  :arith-grobner           294
;  :arith-ineq-splits       2
;  :arith-max-min           1922
;  :arith-nonlinear-bounds  233
;  :arith-nonlinear-horner  353
;  :arith-offset-eqs        18910
;  :arith-patches           4
;  :arith-patches_succ      1
;  :arith-pivots            12346
;  :arith-pseudo-nonlinear  60
;  :conflicts               2708
;  :datatype-accessor-ax    415
;  :datatype-constructor-ax 1744
;  :datatype-occurs-check   1011
;  :datatype-splits         1096
;  :decisions               19709
;  :del-clause              131374
;  :final-checks            515
;  :interface-eqs           91
;  :max-generation          14
;  :max-memory              18.34
;  :memory                  16.94
;  :minimized-lits          689
;  :mk-bool-var             162816
;  :mk-clause               131374
;  :num-allocs              954948
;  :num-checks              376
;  :propagations            97444
;  :quant-instantiations    37833
;  :restarts                4
;  :rlimit-count            5484967)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@212@04))
    (as None<option<array>>  option<array>))))
(pop) ; 9
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@212@04))
    (as None<option<array>>  option<array>))))
(push) ; 9
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 10
(assert (not (<
  unknown@211@04
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@212@04)))))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               129071
;  :arith-add-rows          89329
;  :arith-assert-diseq      7736
;  :arith-assert-lower      41747
;  :arith-assert-upper      27726
;  :arith-bound-prop        6258
;  :arith-conflicts         1178
;  :arith-eq-adapter        22269
;  :arith-fixed-eqs         15327
;  :arith-gcd-tests         3
;  :arith-grobner           294
;  :arith-ineq-splits       2
;  :arith-max-min           1922
;  :arith-nonlinear-bounds  233
;  :arith-nonlinear-horner  353
;  :arith-offset-eqs        18910
;  :arith-patches           4
;  :arith-patches_succ      1
;  :arith-pivots            12346
;  :arith-pseudo-nonlinear  60
;  :conflicts               2709
;  :datatype-accessor-ax    415
;  :datatype-constructor-ax 1744
;  :datatype-occurs-check   1011
;  :datatype-splits         1096
;  :decisions               19709
;  :del-clause              131374
;  :final-checks            515
;  :interface-eqs           91
;  :max-generation          14
;  :max-memory              18.34
;  :memory                  16.94
;  :minimized-lits          689
;  :mk-bool-var             162818
;  :mk-clause               131374
;  :num-allocs              955099
;  :num-checks              377
;  :propagations            97444
;  :quant-instantiations    37833
;  :restarts                4
;  :rlimit-count            5485216)
(assert (<
  unknown@211@04
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@212@04))))))
(pop) ; 9
; Joined path conditions
(assert (<
  unknown@211@04
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@212@04))))))
(pop) ; 8
(declare-fun inv@213@04 ($Ref) Int)
(declare-fun inv@214@04 ($Ref) Int)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(assert (forall ((unknown@211@04 Int) (unknown1@212@04 Int)) (!
  (and
    (< unknown1@212@04 (alen<Int> (opt_get1 $Snap.unit target@27@04)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@212@04)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@212@04))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@212@04))
        (as None<option<array>>  option<array>)))
    (<
      unknown@211@04
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@212@04))))))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@212@04))) unknown@211@04))
  :qid |int-aux|)))
; Check receiver injectivity
(push) ; 8
(assert (not (forall ((unknown1@211@04 Int) (unknown11@212@04 Int) (unknown2@211@04 Int) (unknown12@212@04 Int)) (!
  (implies
    (and
      (and
        (and
          (and (< unknown11@212@04 V@28@04) (<= 0 unknown11@212@04))
          (< unknown1@211@04 V@28@04))
        (<= 0 unknown1@211@04))
      (and
        (and
          (and (< unknown12@212@04 V@28@04) (<= 0 unknown12@212@04))
          (< unknown2@211@04 V@28@04))
        (<= 0 unknown2@211@04))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown11@212@04))) unknown1@211@04)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown12@212@04))) unknown2@211@04)))
    (and
      (= unknown1@211@04 unknown2@211@04)
      (= unknown11@212@04 unknown12@212@04)))
  
  :qid |int-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               129074
;  :arith-add-rows          89329
;  :arith-assert-diseq      7736
;  :arith-assert-lower      41755
;  :arith-assert-upper      27726
;  :arith-bound-prop        6258
;  :arith-conflicts         1179
;  :arith-eq-adapter        22271
;  :arith-fixed-eqs         15327
;  :arith-gcd-tests         3
;  :arith-grobner           294
;  :arith-ineq-splits       2
;  :arith-max-min           1922
;  :arith-nonlinear-bounds  233
;  :arith-nonlinear-horner  353
;  :arith-offset-eqs        18910
;  :arith-patches           4
;  :arith-patches_succ      1
;  :arith-pivots            12347
;  :arith-pseudo-nonlinear  60
;  :conflicts               2710
;  :datatype-accessor-ax    415
;  :datatype-constructor-ax 1744
;  :datatype-occurs-check   1011
;  :datatype-splits         1096
;  :decisions               19709
;  :del-clause              131383
;  :final-checks            515
;  :interface-eqs           91
;  :max-generation          14
;  :max-memory              18.34
;  :memory                  16.93
;  :minimized-lits          689
;  :mk-bool-var             162836
;  :mk-clause               131383
;  :num-allocs              955688
;  :num-checks              378
;  :propagations            97444
;  :quant-instantiations    37833
;  :restarts                4
;  :rlimit-count            5486465)
; Definitional axioms for inverse functions
(assert (forall ((unknown@211@04 Int) (unknown1@212@04 Int)) (!
  (implies
    (and
      (and
        (and (< unknown1@212@04 V@28@04) (<= 0 unknown1@212@04))
        (< unknown@211@04 V@28@04))
      (<= 0 unknown@211@04))
    (and
      (=
        (inv@213@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@212@04))) unknown@211@04))
        unknown@211@04)
      (=
        (inv@214@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@212@04))) unknown@211@04))
        unknown1@212@04)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@212@04))) unknown@211@04))
  )))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@214@04 r) V@28@04) (<= 0 (inv@214@04 r)))
        (< (inv@213@04 r) V@28@04))
      (<= 0 (inv@213@04 r)))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@27@04) (inv@214@04 r)))) (inv@213@04 r))
      r))
  :pattern ((inv@213@04 r))
  :pattern ((inv@214@04 r))
  :qid |int-fctOfInv|)))
; Permissions are non-negative
; Field permissions are at most one
; Permission implies non-null receiver
(assert (forall ((unknown@211@04 Int) (unknown1@212@04 Int)) (!
  (implies
    (and
      (and
        (and (< unknown1@212@04 V@28@04) (<= 0 unknown1@212@04))
        (< unknown@211@04 V@28@04))
      (<= 0 unknown@211@04))
    (not
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@212@04))) unknown@211@04)
        $Ref.null)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@212@04))) unknown@211@04))
  :qid |int-permImpliesNonNull|)))
(declare-const sm@215@04 $FVF<Int>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@214@04 r) V@28@04) (<= 0 (inv@214@04 r)))
        (< (inv@213@04 r) V@28@04))
      (<= 0 (inv@213@04 r)))
    (=
      ($FVF.lookup_int (as sm@215@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@210@04))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@215@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@210@04))))))))))))))) r))
  :qid |qp.fvfValDef63|)))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (ite
          (and
            (and
              (and (< (inv@52@04 r) V@28@04) (<= 0 (inv@52@04 r)))
              (< (inv@51@04 r) V@28@04))
            (<= 0 (inv@51@04 r)))
          $k@50@04
          $Perm.No)
        (pTaken@207@04 r)))
    (=
      ($FVF.lookup_int (as sm@215@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@31@04))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@215@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@31@04))))))))))))))) r))
  :qid |qp.fvfValDef64|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@210@04))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@31@04))))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@215@04  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef65|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@214@04 r) V@28@04) (<= 0 (inv@214@04 r)))
        (< (inv@213@04 r) V@28@04))
      (<= 0 (inv@213@04 r)))
    ($FVF.loc_int ($FVF.lookup_int (as sm@215@04  $FVF<Int>) r) r))
  :pattern ((inv@213@04 r) (inv@214@04 r))
  )))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@210@04))))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@210@04)))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@210@04))))))))))))))))))
; [eval] exc == null
(set-option :timeout 10)
(push) ; 8
(assert (not (not (= exc@208@04 $Ref.null))))
(check-sat)
; unknown
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               129111
;  :arith-add-rows          89329
;  :arith-assert-diseq      7736
;  :arith-assert-lower      41755
;  :arith-assert-upper      27726
;  :arith-bound-prop        6258
;  :arith-conflicts         1179
;  :arith-eq-adapter        22271
;  :arith-fixed-eqs         15327
;  :arith-gcd-tests         3
;  :arith-grobner           294
;  :arith-ineq-splits       2
;  :arith-max-min           1922
;  :arith-nonlinear-bounds  233
;  :arith-nonlinear-horner  353
;  :arith-offset-eqs        18910
;  :arith-patches           4
;  :arith-patches_succ      1
;  :arith-pivots            12347
;  :arith-pseudo-nonlinear  60
;  :conflicts               2710
;  :datatype-accessor-ax    416
;  :datatype-constructor-ax 1751
;  :datatype-occurs-check   1016
;  :datatype-splits         1099
;  :decisions               19716
;  :del-clause              131383
;  :final-checks            517
;  :interface-eqs           91
;  :max-generation          14
;  :max-memory              18.34
;  :memory                  16.94
;  :minimized-lits          689
;  :mk-bool-var             162847
;  :mk-clause               131383
;  :num-allocs              957548
;  :num-checks              379
;  :propagations            97444
;  :quant-instantiations    37833
;  :restarts                4
;  :rlimit-count            5491514)
; [then-branch: 268 | exc@208@04 == Null | live]
; [else-branch: 268 | exc@208@04 != Null | dead]
(push) ; 8
; [then-branch: 268 | exc@208@04 == Null]
(declare-const unknown@216@04 Int)
(declare-const unknown1@217@04 Int)
(push) ; 9
; [eval] 0 <= unknown && unknown < V && (0 <= unknown1 && unknown1 < V)
; [eval] 0 <= unknown
(push) ; 10
; [then-branch: 269 | 0 <= unknown@216@04 | live]
; [else-branch: 269 | !(0 <= unknown@216@04) | live]
(push) ; 11
; [then-branch: 269 | 0 <= unknown@216@04]
(assert (<= 0 unknown@216@04))
; [eval] unknown < V
(push) ; 12
; [then-branch: 270 | unknown@216@04 < V@28@04 | live]
; [else-branch: 270 | !(unknown@216@04 < V@28@04) | live]
(push) ; 13
; [then-branch: 270 | unknown@216@04 < V@28@04]
(assert (< unknown@216@04 V@28@04))
; [eval] 0 <= unknown1
(push) ; 14
; [then-branch: 271 | 0 <= unknown1@217@04 | live]
; [else-branch: 271 | !(0 <= unknown1@217@04) | live]
(push) ; 15
; [then-branch: 271 | 0 <= unknown1@217@04]
(assert (<= 0 unknown1@217@04))
; [eval] unknown1 < V
(pop) ; 15
(push) ; 15
; [else-branch: 271 | !(0 <= unknown1@217@04)]
(assert (not (<= 0 unknown1@217@04)))
(pop) ; 15
(pop) ; 14
; Joined path conditions
; Joined path conditions
(pop) ; 13
(push) ; 13
; [else-branch: 270 | !(unknown@216@04 < V@28@04)]
(assert (not (< unknown@216@04 V@28@04)))
(pop) ; 13
(pop) ; 12
; Joined path conditions
; Joined path conditions
(pop) ; 11
(push) ; 11
; [else-branch: 269 | !(0 <= unknown@216@04)]
(assert (not (<= 0 unknown@216@04)))
(pop) ; 11
(pop) ; 10
; Joined path conditions
; Joined path conditions
(assert (and
  (and
    (and (< unknown1@217@04 V@28@04) (<= 0 unknown1@217@04))
    (< unknown@216@04 V@28@04))
  (<= 0 unknown@216@04)))
; [eval] aloc(opt_get1(aloc(opt_get1(source), unknown1).option$array$), unknown)
; [eval] opt_get1(aloc(opt_get1(source), unknown1).option$array$)
; [eval] aloc(opt_get1(source), unknown1)
; [eval] opt_get1(source)
(push) ; 10
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 10
; Joined path conditions
(push) ; 10
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 11
(assert (not (< unknown1@217@04 (alen<Int> (opt_get1 $Snap.unit source@26@04)))))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               129111
;  :arith-add-rows          89329
;  :arith-assert-diseq      7736
;  :arith-assert-lower      41761
;  :arith-assert-upper      27726
;  :arith-bound-prop        6258
;  :arith-conflicts         1181
;  :arith-eq-adapter        22271
;  :arith-fixed-eqs         15327
;  :arith-gcd-tests         3
;  :arith-grobner           294
;  :arith-ineq-splits       2
;  :arith-max-min           1922
;  :arith-nonlinear-bounds  233
;  :arith-nonlinear-horner  353
;  :arith-offset-eqs        18910
;  :arith-patches           4
;  :arith-patches_succ      1
;  :arith-pivots            12347
;  :arith-pseudo-nonlinear  60
;  :conflicts               2712
;  :datatype-accessor-ax    416
;  :datatype-constructor-ax 1751
;  :datatype-occurs-check   1016
;  :datatype-splits         1099
;  :decisions               19716
;  :del-clause              131383
;  :final-checks            517
;  :interface-eqs           91
;  :max-generation          14
;  :max-memory              18.34
;  :memory                  16.94
;  :minimized-lits          689
;  :mk-bool-var             162853
;  :mk-clause               131383
;  :num-allocs              957824
;  :num-checks              380
;  :propagations            97444
;  :quant-instantiations    37833
;  :restarts                4
;  :rlimit-count            5491966)
(assert (< unknown1@217@04 (alen<Int> (opt_get1 $Snap.unit source@26@04))))
(pop) ; 10
; Joined path conditions
(assert (< unknown1@217@04 (alen<Int> (opt_get1 $Snap.unit source@26@04))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@217@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@217@04)))
(push) ; 10
(assert (not (<
  $Perm.No
  (+
    (ite
      (and
        (<
          (inv@42@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@217@04))
          V@28@04)
        (<=
          0
          (inv@42@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@217@04))))
      $k@41@04
      $Perm.No)
    (ite
      (and
        (<
          (inv@34@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@217@04))
          V@28@04)
        (<=
          0
          (inv@34@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@217@04))))
      $k@33@04
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               129111
;  :arith-add-rows          89329
;  :arith-assert-diseq      7736
;  :arith-assert-lower      41761
;  :arith-assert-upper      27726
;  :arith-bound-prop        6258
;  :arith-conflicts         1181
;  :arith-eq-adapter        22271
;  :arith-fixed-eqs         15327
;  :arith-gcd-tests         3
;  :arith-grobner           294
;  :arith-ineq-splits       2
;  :arith-max-min           1922
;  :arith-nonlinear-bounds  233
;  :arith-nonlinear-horner  353
;  :arith-offset-eqs        18910
;  :arith-patches           4
;  :arith-patches_succ      1
;  :arith-pivots            12347
;  :arith-pseudo-nonlinear  60
;  :conflicts               2713
;  :datatype-accessor-ax    416
;  :datatype-constructor-ax 1751
;  :datatype-occurs-check   1016
;  :datatype-splits         1099
;  :decisions               19716
;  :del-clause              131393
;  :final-checks            517
;  :interface-eqs           91
;  :max-generation          14
;  :max-memory              18.34
;  :memory                  16.94
;  :minimized-lits          689
;  :mk-bool-var             162865
;  :mk-clause               131393
;  :num-allocs              958037
;  :num-checks              381
;  :propagations            97444
;  :quant-instantiations    37833
;  :restarts                4
;  :rlimit-count            5492449)
(push) ; 10
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 11
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@217@04))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               129111
;  :arith-add-rows          89329
;  :arith-assert-diseq      7736
;  :arith-assert-lower      41761
;  :arith-assert-upper      27726
;  :arith-bound-prop        6258
;  :arith-conflicts         1181
;  :arith-eq-adapter        22271
;  :arith-fixed-eqs         15327
;  :arith-gcd-tests         3
;  :arith-grobner           294
;  :arith-ineq-splits       2
;  :arith-max-min           1922
;  :arith-nonlinear-bounds  233
;  :arith-nonlinear-horner  353
;  :arith-offset-eqs        18910
;  :arith-patches           4
;  :arith-patches_succ      1
;  :arith-pivots            12347
;  :arith-pseudo-nonlinear  60
;  :conflicts               2714
;  :datatype-accessor-ax    416
;  :datatype-constructor-ax 1751
;  :datatype-occurs-check   1016
;  :datatype-splits         1099
;  :decisions               19716
;  :del-clause              131393
;  :final-checks            517
;  :interface-eqs           91
;  :max-generation          14
;  :max-memory              18.34
;  :memory                  16.94
;  :minimized-lits          689
;  :mk-bool-var             162866
;  :mk-clause               131393
;  :num-allocs              958127
;  :num-checks              382
;  :propagations            97444
;  :quant-instantiations    37833
;  :restarts                4
;  :rlimit-count            5492538)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@217@04))
    (as None<option<array>>  option<array>))))
(pop) ; 10
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@217@04))
    (as None<option<array>>  option<array>))))
(push) ; 10
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 11
(assert (not (<
  unknown@216@04
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@217@04)))))))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               129111
;  :arith-add-rows          89329
;  :arith-assert-diseq      7736
;  :arith-assert-lower      41761
;  :arith-assert-upper      27726
;  :arith-bound-prop        6258
;  :arith-conflicts         1181
;  :arith-eq-adapter        22271
;  :arith-fixed-eqs         15327
;  :arith-gcd-tests         3
;  :arith-grobner           294
;  :arith-ineq-splits       2
;  :arith-max-min           1922
;  :arith-nonlinear-bounds  233
;  :arith-nonlinear-horner  353
;  :arith-offset-eqs        18910
;  :arith-patches           4
;  :arith-patches_succ      1
;  :arith-pivots            12347
;  :arith-pseudo-nonlinear  60
;  :conflicts               2715
;  :datatype-accessor-ax    416
;  :datatype-constructor-ax 1751
;  :datatype-occurs-check   1016
;  :datatype-splits         1099
;  :decisions               19716
;  :del-clause              131393
;  :final-checks            517
;  :interface-eqs           91
;  :max-generation          14
;  :max-memory              18.34
;  :memory                  16.94
;  :minimized-lits          689
;  :mk-bool-var             162868
;  :mk-clause               131393
;  :num-allocs              958280
;  :num-checks              383
;  :propagations            97444
;  :quant-instantiations    37833
;  :restarts                4
;  :rlimit-count            5492791)
(assert (<
  unknown@216@04
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@217@04))))))
(pop) ; 10
; Joined path conditions
(assert (<
  unknown@216@04
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@217@04))))))
(declare-const $k@218@04 $Perm)
(assert ($Perm.isReadVar $k@218@04 $Perm.Write))
(pop) ; 9
(declare-fun inv@219@04 ($Ref) Int)
(declare-fun inv@220@04 ($Ref) Int)
; Nested auxiliary terms: globals
(assert ($Perm.isReadVar $k@218@04 $Perm.Write))
; Nested auxiliary terms: non-globals
(assert (forall ((unknown@216@04 Int) (unknown1@217@04 Int)) (!
  (and
    (< unknown1@217@04 (alen<Int> (opt_get1 $Snap.unit source@26@04)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@217@04)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@217@04))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@217@04))
        (as None<option<array>>  option<array>)))
    (<
      unknown@216@04
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@217@04))))))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@217@04))) unknown@216@04))
  :qid |int-aux|)))
(push) ; 9
(assert (not (forall ((unknown@216@04 Int) (unknown1@217@04 Int)) (!
  (implies
    (and
      (and
        (and (< unknown1@217@04 V@28@04) (<= 0 unknown1@217@04))
        (< unknown@216@04 V@28@04))
      (<= 0 unknown@216@04))
    (or (= $k@218@04 $Perm.No) (< $Perm.No $k@218@04)))
  
  ))))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               129111
;  :arith-add-rows          89329
;  :arith-assert-diseq      7737
;  :arith-assert-lower      41763
;  :arith-assert-upper      27727
;  :arith-bound-prop        6258
;  :arith-conflicts         1181
;  :arith-eq-adapter        22272
;  :arith-fixed-eqs         15327
;  :arith-gcd-tests         3
;  :arith-grobner           294
;  :arith-ineq-splits       2
;  :arith-max-min           1922
;  :arith-nonlinear-bounds  233
;  :arith-nonlinear-horner  353
;  :arith-offset-eqs        18910
;  :arith-patches           4
;  :arith-patches_succ      1
;  :arith-pivots            12347
;  :arith-pseudo-nonlinear  60
;  :conflicts               2716
;  :datatype-accessor-ax    416
;  :datatype-constructor-ax 1751
;  :datatype-occurs-check   1016
;  :datatype-splits         1099
;  :decisions               19716
;  :del-clause              131393
;  :final-checks            517
;  :interface-eqs           91
;  :max-generation          14
;  :max-memory              18.34
;  :memory                  16.94
;  :minimized-lits          689
;  :mk-bool-var             162877
;  :mk-clause               131395
;  :num-allocs              958846
;  :num-checks              384
;  :propagations            97445
;  :quant-instantiations    37833
;  :restarts                4
;  :rlimit-count            5493704)
; Check receiver injectivity
(push) ; 9
(assert (not (forall ((unknown1@216@04 Int) (unknown11@217@04 Int) (unknown2@216@04 Int) (unknown12@217@04 Int)) (!
  (implies
    (and
      (and
        (and
          (and
            (and (< unknown11@217@04 V@28@04) (<= 0 unknown11@217@04))
            (< unknown1@216@04 V@28@04))
          (<= 0 unknown1@216@04))
        (< $Perm.No $k@218@04))
      (and
        (and
          (and
            (and (< unknown12@217@04 V@28@04) (<= 0 unknown12@217@04))
            (< unknown2@216@04 V@28@04))
          (<= 0 unknown2@216@04))
        (< $Perm.No $k@218@04))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown11@217@04))) unknown1@216@04)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown12@217@04))) unknown2@216@04)))
    (and
      (= unknown1@216@04 unknown2@216@04)
      (= unknown11@217@04 unknown12@217@04)))
  
  :qid |int-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               129113
;  :arith-add-rows          89329
;  :arith-assert-diseq      7737
;  :arith-assert-lower      41771
;  :arith-assert-upper      27727
;  :arith-bound-prop        6258
;  :arith-conflicts         1182
;  :arith-eq-adapter        22274
;  :arith-fixed-eqs         15327
;  :arith-gcd-tests         3
;  :arith-grobner           294
;  :arith-ineq-splits       2
;  :arith-max-min           1922
;  :arith-nonlinear-bounds  233
;  :arith-nonlinear-horner  353
;  :arith-offset-eqs        18910
;  :arith-patches           4
;  :arith-patches_succ      1
;  :arith-pivots            12347
;  :arith-pseudo-nonlinear  60
;  :conflicts               2717
;  :datatype-accessor-ax    416
;  :datatype-constructor-ax 1751
;  :datatype-occurs-check   1016
;  :datatype-splits         1099
;  :decisions               19716
;  :del-clause              131402
;  :final-checks            517
;  :interface-eqs           91
;  :max-generation          14
;  :max-memory              18.34
;  :memory                  16.93
;  :minimized-lits          689
;  :mk-bool-var             162893
;  :mk-clause               131404
;  :num-allocs              959245
;  :num-checks              385
;  :propagations            97445
;  :quant-instantiations    37833
;  :restarts                4
;  :rlimit-count            5494562)
; Definitional axioms for inverse functions
(assert (forall ((unknown@216@04 Int) (unknown1@217@04 Int)) (!
  (implies
    (and
      (and
        (and
          (and (< unknown1@217@04 V@28@04) (<= 0 unknown1@217@04))
          (< unknown@216@04 V@28@04))
        (<= 0 unknown@216@04))
      (< $Perm.No $k@218@04))
    (and
      (=
        (inv@219@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@217@04))) unknown@216@04))
        unknown@216@04)
      (=
        (inv@220@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@217@04))) unknown@216@04))
        unknown1@217@04)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@217@04))) unknown@216@04))
  )))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and
          (and (< (inv@220@04 r) V@28@04) (<= 0 (inv@220@04 r)))
          (< (inv@219@04 r) V@28@04))
        (<= 0 (inv@219@04 r)))
      (< $Perm.No $k@218@04))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@26@04) (inv@220@04 r)))) (inv@219@04 r))
      r))
  :pattern ((inv@219@04 r))
  :pattern ((inv@220@04 r))
  :qid |int-fctOfInv|)))
; Permissions are non-negative
(assert (forall ((unknown@216@04 Int) (unknown1@217@04 Int)) (!
  (<= $Perm.No $k@218@04)
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@217@04))) unknown@216@04))
  :qid |int-permAtLeastZero|)))
; Field permissions are at most one
(assert (forall ((unknown@216@04 Int) (unknown1@217@04 Int)) (!
  (<= $k@218@04 $Perm.Write)
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@217@04))) unknown@216@04))
  :qid |int-permAtMostOne|)))
; Permission implies non-null receiver
(assert (forall ((unknown@216@04 Int) (unknown1@217@04 Int)) (!
  (implies
    (and
      (and
        (and
          (and (< unknown1@217@04 V@28@04) (<= 0 unknown1@217@04))
          (< unknown@216@04 V@28@04))
        (<= 0 unknown@216@04))
      (< $Perm.No $k@218@04))
    (not
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@217@04))) unknown@216@04)
        $Ref.null)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@217@04))) unknown@216@04))
  :qid |int-permImpliesNonNull|)))
(declare-const sm@221@04 $FVF<Int>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and
        (and
          (and (< (inv@220@04 r) V@28@04) (<= 0 (inv@220@04 r)))
          (< (inv@219@04 r) V@28@04))
        (<= 0 (inv@219@04 r)))
      (< $Perm.No $k@218@04)
      false)
    (=
      ($FVF.lookup_int (as sm@221@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@210@04)))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@221@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@210@04)))))))))))))))) r))
  :qid |qp.fvfValDef66|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@214@04 r) V@28@04) (<= 0 (inv@214@04 r)))
        (< (inv@213@04 r) V@28@04))
      (<= 0 (inv@213@04 r)))
    (=
      ($FVF.lookup_int (as sm@221@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@210@04))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@221@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@210@04))))))))))))))) r))
  :qid |qp.fvfValDef67|)))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (ite
          (and
            (and
              (and (< (inv@52@04 r) V@28@04) (<= 0 (inv@52@04 r)))
              (< (inv@51@04 r) V@28@04))
            (<= 0 (inv@51@04 r)))
          $k@50@04
          $Perm.No)
        (pTaken@207@04 r)))
    (=
      ($FVF.lookup_int (as sm@221@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@31@04))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@221@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@31@04))))))))))))))) r))
  :qid |qp.fvfValDef68|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@210@04)))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@210@04))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@31@04))))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@221@04  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef69|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@220@04 r) V@28@04) (<= 0 (inv@220@04 r)))
        (< (inv@219@04 r) V@28@04))
      (<= 0 (inv@219@04 r)))
    ($FVF.loc_int ($FVF.lookup_int (as sm@221@04  $FVF<Int>) r) r))
  :pattern ((inv@219@04 r) (inv@220@04 r))
  )))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@210@04)))))))))))))))
  $Snap.unit))
; [eval] exc == null ==> (forall unknown: Int :: 0 <= unknown && unknown < V ==> (forall unknown1: Int :: { aloc(opt_get1(aloc(opt_get1(target), unknown1).option$array$), unknown) } { aloc(opt_get1(aloc(opt_get1(source), unknown1).option$array$), unknown) } 0 <= unknown1 && unknown1 < V ==> aloc(opt_get1(aloc(opt_get1(target), unknown1).option$array$), unknown).int == aloc(opt_get1(aloc(opt_get1(source), unknown1).option$array$), unknown).int))
; [eval] exc == null
(push) ; 9
(set-option :timeout 10)
(push) ; 10
(assert (not (not (= exc@208@04 $Ref.null))))
(check-sat)
; unknown
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               129145
;  :arith-add-rows          89329
;  :arith-assert-diseq      7737
;  :arith-assert-lower      41771
;  :arith-assert-upper      27728
;  :arith-bound-prop        6258
;  :arith-conflicts         1182
;  :arith-eq-adapter        22274
;  :arith-fixed-eqs         15327
;  :arith-gcd-tests         3
;  :arith-grobner           294
;  :arith-ineq-splits       2
;  :arith-max-min           1922
;  :arith-nonlinear-bounds  233
;  :arith-nonlinear-horner  353
;  :arith-offset-eqs        18910
;  :arith-patches           4
;  :arith-patches_succ      1
;  :arith-pivots            12347
;  :arith-pseudo-nonlinear  60
;  :conflicts               2717
;  :datatype-accessor-ax    416
;  :datatype-constructor-ax 1757
;  :datatype-occurs-check   1021
;  :datatype-splits         1101
;  :decisions               19722
;  :del-clause              131402
;  :final-checks            519
;  :interface-eqs           91
;  :max-generation          14
;  :max-memory              18.34
;  :memory                  16.94
;  :minimized-lits          689
;  :mk-bool-var             162905
;  :mk-clause               131404
;  :num-allocs              961510
;  :num-checks              386
;  :propagations            97445
;  :quant-instantiations    37833
;  :restarts                4
;  :rlimit-count            5501114)
; [then-branch: 272 | exc@208@04 == Null | live]
; [else-branch: 272 | exc@208@04 != Null | dead]
(push) ; 10
; [then-branch: 272 | exc@208@04 == Null]
; [eval] (forall unknown: Int :: 0 <= unknown && unknown < V ==> (forall unknown1: Int :: { aloc(opt_get1(aloc(opt_get1(target), unknown1).option$array$), unknown) } { aloc(opt_get1(aloc(opt_get1(source), unknown1).option$array$), unknown) } 0 <= unknown1 && unknown1 < V ==> aloc(opt_get1(aloc(opt_get1(target), unknown1).option$array$), unknown).int == aloc(opt_get1(aloc(opt_get1(source), unknown1).option$array$), unknown).int))
(declare-const unknown@222@04 Int)
(push) ; 11
; [eval] 0 <= unknown && unknown < V ==> (forall unknown1: Int :: { aloc(opt_get1(aloc(opt_get1(target), unknown1).option$array$), unknown) } { aloc(opt_get1(aloc(opt_get1(source), unknown1).option$array$), unknown) } 0 <= unknown1 && unknown1 < V ==> aloc(opt_get1(aloc(opt_get1(target), unknown1).option$array$), unknown).int == aloc(opt_get1(aloc(opt_get1(source), unknown1).option$array$), unknown).int)
; [eval] 0 <= unknown && unknown < V
; [eval] 0 <= unknown
(push) ; 12
; [then-branch: 273 | 0 <= unknown@222@04 | live]
; [else-branch: 273 | !(0 <= unknown@222@04) | live]
(push) ; 13
; [then-branch: 273 | 0 <= unknown@222@04]
(assert (<= 0 unknown@222@04))
; [eval] unknown < V
(pop) ; 13
(push) ; 13
; [else-branch: 273 | !(0 <= unknown@222@04)]
(assert (not (<= 0 unknown@222@04)))
(pop) ; 13
(pop) ; 12
; Joined path conditions
; Joined path conditions
(push) ; 12
; [then-branch: 274 | unknown@222@04 < V@28@04 && 0 <= unknown@222@04 | live]
; [else-branch: 274 | !(unknown@222@04 < V@28@04 && 0 <= unknown@222@04) | live]
(push) ; 13
; [then-branch: 274 | unknown@222@04 < V@28@04 && 0 <= unknown@222@04]
(assert (and (< unknown@222@04 V@28@04) (<= 0 unknown@222@04)))
; [eval] (forall unknown1: Int :: { aloc(opt_get1(aloc(opt_get1(target), unknown1).option$array$), unknown) } { aloc(opt_get1(aloc(opt_get1(source), unknown1).option$array$), unknown) } 0 <= unknown1 && unknown1 < V ==> aloc(opt_get1(aloc(opt_get1(target), unknown1).option$array$), unknown).int == aloc(opt_get1(aloc(opt_get1(source), unknown1).option$array$), unknown).int)
(declare-const unknown1@223@04 Int)
(push) ; 14
; [eval] 0 <= unknown1 && unknown1 < V ==> aloc(opt_get1(aloc(opt_get1(target), unknown1).option$array$), unknown).int == aloc(opt_get1(aloc(opt_get1(source), unknown1).option$array$), unknown).int
; [eval] 0 <= unknown1 && unknown1 < V
; [eval] 0 <= unknown1
(push) ; 15
; [then-branch: 275 | 0 <= unknown1@223@04 | live]
; [else-branch: 275 | !(0 <= unknown1@223@04) | live]
(push) ; 16
; [then-branch: 275 | 0 <= unknown1@223@04]
(assert (<= 0 unknown1@223@04))
; [eval] unknown1 < V
(pop) ; 16
(push) ; 16
; [else-branch: 275 | !(0 <= unknown1@223@04)]
(assert (not (<= 0 unknown1@223@04)))
(pop) ; 16
(pop) ; 15
; Joined path conditions
; Joined path conditions
(push) ; 15
; [then-branch: 276 | unknown1@223@04 < V@28@04 && 0 <= unknown1@223@04 | live]
; [else-branch: 276 | !(unknown1@223@04 < V@28@04 && 0 <= unknown1@223@04) | live]
(push) ; 16
; [then-branch: 276 | unknown1@223@04 < V@28@04 && 0 <= unknown1@223@04]
(assert (and (< unknown1@223@04 V@28@04) (<= 0 unknown1@223@04)))
; [eval] aloc(opt_get1(aloc(opt_get1(target), unknown1).option$array$), unknown).int == aloc(opt_get1(aloc(opt_get1(source), unknown1).option$array$), unknown).int
; [eval] aloc(opt_get1(aloc(opt_get1(target), unknown1).option$array$), unknown)
; [eval] opt_get1(aloc(opt_get1(target), unknown1).option$array$)
; [eval] aloc(opt_get1(target), unknown1)
; [eval] opt_get1(target)
(push) ; 17
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 17
; Joined path conditions
(push) ; 17
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 18
(assert (not (< unknown1@223@04 (alen<Int> (opt_get1 $Snap.unit target@27@04)))))
(check-sat)
; unsat
(pop) ; 18
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               129145
;  :arith-add-rows          89329
;  :arith-assert-diseq      7737
;  :arith-assert-lower      41773
;  :arith-assert-upper      27728
;  :arith-bound-prop        6258
;  :arith-conflicts         1183
;  :arith-eq-adapter        22274
;  :arith-fixed-eqs         15327
;  :arith-gcd-tests         3
;  :arith-grobner           294
;  :arith-ineq-splits       2
;  :arith-max-min           1922
;  :arith-nonlinear-bounds  233
;  :arith-nonlinear-horner  353
;  :arith-offset-eqs        18910
;  :arith-patches           4
;  :arith-patches_succ      1
;  :arith-pivots            12348
;  :arith-pseudo-nonlinear  60
;  :conflicts               2718
;  :datatype-accessor-ax    416
;  :datatype-constructor-ax 1757
;  :datatype-occurs-check   1021
;  :datatype-splits         1101
;  :decisions               19722
;  :del-clause              131402
;  :final-checks            519
;  :interface-eqs           91
;  :max-generation          14
;  :max-memory              18.34
;  :memory                  16.94
;  :minimized-lits          689
;  :mk-bool-var             162909
;  :mk-clause               131404
;  :num-allocs              961689
;  :num-checks              387
;  :propagations            97445
;  :quant-instantiations    37833
;  :restarts                4
;  :rlimit-count            5501440)
(assert (< unknown1@223@04 (alen<Int> (opt_get1 $Snap.unit target@27@04))))
(pop) ; 17
; Joined path conditions
(assert (< unknown1@223@04 (alen<Int> (opt_get1 $Snap.unit target@27@04))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@223@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@223@04)))
(push) ; 17
(assert (not (<
  $Perm.No
  (+
    (ite
      (and
        (<
          (inv@42@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@223@04))
          V@28@04)
        (<=
          0
          (inv@42@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@223@04))))
      $k@41@04
      $Perm.No)
    (ite
      (and
        (<
          (inv@34@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@223@04))
          V@28@04)
        (<=
          0
          (inv@34@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@223@04))))
      $k@33@04
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               129145
;  :arith-add-rows          89329
;  :arith-assert-diseq      7737
;  :arith-assert-lower      41773
;  :arith-assert-upper      27728
;  :arith-bound-prop        6258
;  :arith-conflicts         1183
;  :arith-eq-adapter        22274
;  :arith-fixed-eqs         15327
;  :arith-gcd-tests         3
;  :arith-grobner           294
;  :arith-ineq-splits       2
;  :arith-max-min           1922
;  :arith-nonlinear-bounds  233
;  :arith-nonlinear-horner  353
;  :arith-offset-eqs        18910
;  :arith-patches           4
;  :arith-patches_succ      1
;  :arith-pivots            12348
;  :arith-pseudo-nonlinear  60
;  :conflicts               2719
;  :datatype-accessor-ax    416
;  :datatype-constructor-ax 1757
;  :datatype-occurs-check   1021
;  :datatype-splits         1101
;  :decisions               19722
;  :del-clause              131412
;  :final-checks            519
;  :interface-eqs           91
;  :max-generation          14
;  :max-memory              18.34
;  :memory                  16.94
;  :minimized-lits          689
;  :mk-bool-var             162921
;  :mk-clause               131414
;  :num-allocs              961902
;  :num-checks              388
;  :propagations            97445
;  :quant-instantiations    37833
;  :restarts                4
;  :rlimit-count            5501923)
(push) ; 17
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 18
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@223@04))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 18
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               129145
;  :arith-add-rows          89329
;  :arith-assert-diseq      7737
;  :arith-assert-lower      41773
;  :arith-assert-upper      27728
;  :arith-bound-prop        6258
;  :arith-conflicts         1183
;  :arith-eq-adapter        22274
;  :arith-fixed-eqs         15327
;  :arith-gcd-tests         3
;  :arith-grobner           294
;  :arith-ineq-splits       2
;  :arith-max-min           1922
;  :arith-nonlinear-bounds  233
;  :arith-nonlinear-horner  353
;  :arith-offset-eqs        18910
;  :arith-patches           4
;  :arith-patches_succ      1
;  :arith-pivots            12348
;  :arith-pseudo-nonlinear  60
;  :conflicts               2720
;  :datatype-accessor-ax    416
;  :datatype-constructor-ax 1757
;  :datatype-occurs-check   1021
;  :datatype-splits         1101
;  :decisions               19722
;  :del-clause              131412
;  :final-checks            519
;  :interface-eqs           91
;  :max-generation          14
;  :max-memory              18.34
;  :memory                  16.94
;  :minimized-lits          689
;  :mk-bool-var             162922
;  :mk-clause               131414
;  :num-allocs              961992
;  :num-checks              389
;  :propagations            97445
;  :quant-instantiations    37833
;  :restarts                4
;  :rlimit-count            5502012)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@223@04))
    (as None<option<array>>  option<array>))))
(pop) ; 17
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@223@04))
    (as None<option<array>>  option<array>))))
(push) ; 17
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 18
(assert (not (<
  unknown@222@04
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@223@04)))))))
(check-sat)
; unsat
(pop) ; 18
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               129145
;  :arith-add-rows          89330
;  :arith-assert-diseq      7737
;  :arith-assert-lower      41773
;  :arith-assert-upper      27728
;  :arith-bound-prop        6258
;  :arith-conflicts         1183
;  :arith-eq-adapter        22274
;  :arith-fixed-eqs         15327
;  :arith-gcd-tests         3
;  :arith-grobner           294
;  :arith-ineq-splits       2
;  :arith-max-min           1922
;  :arith-nonlinear-bounds  233
;  :arith-nonlinear-horner  353
;  :arith-offset-eqs        18910
;  :arith-patches           4
;  :arith-patches_succ      1
;  :arith-pivots            12348
;  :arith-pseudo-nonlinear  60
;  :conflicts               2721
;  :datatype-accessor-ax    416
;  :datatype-constructor-ax 1757
;  :datatype-occurs-check   1021
;  :datatype-splits         1101
;  :decisions               19722
;  :del-clause              131412
;  :final-checks            519
;  :interface-eqs           91
;  :max-generation          14
;  :max-memory              18.34
;  :memory                  16.94
;  :minimized-lits          689
;  :mk-bool-var             162924
;  :mk-clause               131414
;  :num-allocs              962144
;  :num-checks              390
;  :propagations            97445
;  :quant-instantiations    37833
;  :restarts                4
;  :rlimit-count            5502266)
(assert (<
  unknown@222@04
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@223@04))))))
(pop) ; 17
; Joined path conditions
(assert (<
  unknown@222@04
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@223@04))))))
(assert ($FVF.loc_int ($FVF.lookup_int (as sm@221@04  $FVF<Int>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@223@04))) unknown@222@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@223@04))) unknown@222@04)))
(push) ; 17
(assert (not (<
  $Perm.No
  (+
    (+
      (ite
        (and
          (and
            (and
              (<
                (inv@220@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@223@04))) unknown@222@04))
                V@28@04)
              (<=
                0
                (inv@220@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@223@04))) unknown@222@04))))
            (<
              (inv@219@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@223@04))) unknown@222@04))
              V@28@04))
          (<=
            0
            (inv@219@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@223@04))) unknown@222@04))))
        $k@218@04
        $Perm.No)
      (ite
        (and
          (and
            (and
              (<
                (inv@214@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@223@04))) unknown@222@04))
                V@28@04)
              (<=
                0
                (inv@214@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@223@04))) unknown@222@04))))
            (<
              (inv@213@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@223@04))) unknown@222@04))
              V@28@04))
          (<=
            0
            (inv@213@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@223@04))) unknown@222@04))))
        $Perm.Write
        $Perm.No))
    (-
      (ite
        (and
          (and
            (and
              (<
                (inv@52@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@223@04))) unknown@222@04))
                V@28@04)
              (<=
                0
                (inv@52@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@223@04))) unknown@222@04))))
            (<
              (inv@51@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@223@04))) unknown@222@04))
              V@28@04))
          (<=
            0
            (inv@51@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@223@04))) unknown@222@04))))
        $k@50@04
        $Perm.No)
      (pTaken@207@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@223@04))) unknown@222@04)))))))
(check-sat)
; unsat
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               129145
;  :arith-add-rows          89331
;  :arith-assert-diseq      7737
;  :arith-assert-lower      41773
;  :arith-assert-upper      27728
;  :arith-bound-prop        6258
;  :arith-conflicts         1183
;  :arith-eq-adapter        22274
;  :arith-fixed-eqs         15327
;  :arith-gcd-tests         3
;  :arith-grobner           294
;  :arith-ineq-splits       2
;  :arith-max-min           1922
;  :arith-nonlinear-bounds  233
;  :arith-nonlinear-horner  353
;  :arith-offset-eqs        18910
;  :arith-patches           4
;  :arith-patches_succ      1
;  :arith-pivots            12348
;  :arith-pseudo-nonlinear  60
;  :conflicts               2722
;  :datatype-accessor-ax    416
;  :datatype-constructor-ax 1757
;  :datatype-occurs-check   1021
;  :datatype-splits         1101
;  :decisions               19722
;  :del-clause              131442
;  :final-checks            519
;  :interface-eqs           91
;  :max-generation          14
;  :max-memory              18.34
;  :memory                  16.95
;  :minimized-lits          689
;  :mk-bool-var             162958
;  :mk-clause               131444
;  :num-allocs              962580
;  :num-checks              391
;  :propagations            97445
;  :quant-instantiations    37833
;  :restarts                4
;  :rlimit-count            5503676)
; [eval] aloc(opt_get1(aloc(opt_get1(source), unknown1).option$array$), unknown)
; [eval] opt_get1(aloc(opt_get1(source), unknown1).option$array$)
; [eval] aloc(opt_get1(source), unknown1)
; [eval] opt_get1(source)
(push) ; 17
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 17
; Joined path conditions
(push) ; 17
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 18
(assert (not (< unknown1@223@04 (alen<Int> (opt_get1 $Snap.unit source@26@04)))))
(check-sat)
; unsat
(pop) ; 18
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               129145
;  :arith-add-rows          89331
;  :arith-assert-diseq      7737
;  :arith-assert-lower      41773
;  :arith-assert-upper      27728
;  :arith-bound-prop        6258
;  :arith-conflicts         1183
;  :arith-eq-adapter        22274
;  :arith-fixed-eqs         15327
;  :arith-gcd-tests         3
;  :arith-grobner           294
;  :arith-ineq-splits       2
;  :arith-max-min           1922
;  :arith-nonlinear-bounds  233
;  :arith-nonlinear-horner  353
;  :arith-offset-eqs        18910
;  :arith-patches           4
;  :arith-patches_succ      1
;  :arith-pivots            12348
;  :arith-pseudo-nonlinear  60
;  :conflicts               2722
;  :datatype-accessor-ax    416
;  :datatype-constructor-ax 1757
;  :datatype-occurs-check   1021
;  :datatype-splits         1101
;  :decisions               19722
;  :del-clause              131442
;  :final-checks            519
;  :interface-eqs           91
;  :max-generation          14
;  :max-memory              18.34
;  :memory                  16.95
;  :minimized-lits          689
;  :mk-bool-var             162958
;  :mk-clause               131444
;  :num-allocs              962607
;  :num-checks              392
;  :propagations            97445
;  :quant-instantiations    37833
;  :restarts                4
;  :rlimit-count            5503697)
(assert (< unknown1@223@04 (alen<Int> (opt_get1 $Snap.unit source@26@04))))
(pop) ; 17
; Joined path conditions
(assert (< unknown1@223@04 (alen<Int> (opt_get1 $Snap.unit source@26@04))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@223@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@223@04)))
(push) ; 17
(assert (not (<
  $Perm.No
  (+
    (ite
      (and
        (<
          (inv@42@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@223@04))
          V@28@04)
        (<=
          0
          (inv@42@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@223@04))))
      $k@41@04
      $Perm.No)
    (ite
      (and
        (<
          (inv@34@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@223@04))
          V@28@04)
        (<=
          0
          (inv@34@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@223@04))))
      $k@33@04
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               129145
;  :arith-add-rows          89331
;  :arith-assert-diseq      7737
;  :arith-assert-lower      41773
;  :arith-assert-upper      27728
;  :arith-bound-prop        6258
;  :arith-conflicts         1183
;  :arith-eq-adapter        22274
;  :arith-fixed-eqs         15327
;  :arith-gcd-tests         3
;  :arith-grobner           294
;  :arith-ineq-splits       2
;  :arith-max-min           1922
;  :arith-nonlinear-bounds  233
;  :arith-nonlinear-horner  353
;  :arith-offset-eqs        18910
;  :arith-patches           4
;  :arith-patches_succ      1
;  :arith-pivots            12348
;  :arith-pseudo-nonlinear  60
;  :conflicts               2723
;  :datatype-accessor-ax    416
;  :datatype-constructor-ax 1757
;  :datatype-occurs-check   1021
;  :datatype-splits         1101
;  :decisions               19722
;  :del-clause              131452
;  :final-checks            519
;  :interface-eqs           91
;  :max-generation          14
;  :max-memory              18.34
;  :memory                  16.95
;  :minimized-lits          689
;  :mk-bool-var             162970
;  :mk-clause               131454
;  :num-allocs              962821
;  :num-checks              393
;  :propagations            97445
;  :quant-instantiations    37833
;  :restarts                4
;  :rlimit-count            5504180)
(push) ; 17
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 18
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@223@04))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 18
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               129145
;  :arith-add-rows          89331
;  :arith-assert-diseq      7737
;  :arith-assert-lower      41773
;  :arith-assert-upper      27728
;  :arith-bound-prop        6258
;  :arith-conflicts         1183
;  :arith-eq-adapter        22274
;  :arith-fixed-eqs         15327
;  :arith-gcd-tests         3
;  :arith-grobner           294
;  :arith-ineq-splits       2
;  :arith-max-min           1922
;  :arith-nonlinear-bounds  233
;  :arith-nonlinear-horner  353
;  :arith-offset-eqs        18910
;  :arith-patches           4
;  :arith-patches_succ      1
;  :arith-pivots            12348
;  :arith-pseudo-nonlinear  60
;  :conflicts               2724
;  :datatype-accessor-ax    416
;  :datatype-constructor-ax 1757
;  :datatype-occurs-check   1021
;  :datatype-splits         1101
;  :decisions               19722
;  :del-clause              131452
;  :final-checks            519
;  :interface-eqs           91
;  :max-generation          14
;  :max-memory              18.34
;  :memory                  16.95
;  :minimized-lits          689
;  :mk-bool-var             162971
;  :mk-clause               131454
;  :num-allocs              962911
;  :num-checks              394
;  :propagations            97445
;  :quant-instantiations    37833
;  :restarts                4
;  :rlimit-count            5504269)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@223@04))
    (as None<option<array>>  option<array>))))
(pop) ; 17
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@223@04))
    (as None<option<array>>  option<array>))))
(push) ; 17
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 18
(assert (not (<
  unknown@222@04
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@223@04)))))))
(check-sat)
; unsat
(pop) ; 18
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               129145
;  :arith-add-rows          89332
;  :arith-assert-diseq      7737
;  :arith-assert-lower      41773
;  :arith-assert-upper      27728
;  :arith-bound-prop        6258
;  :arith-conflicts         1183
;  :arith-eq-adapter        22274
;  :arith-fixed-eqs         15327
;  :arith-gcd-tests         3
;  :arith-grobner           294
;  :arith-ineq-splits       2
;  :arith-max-min           1922
;  :arith-nonlinear-bounds  233
;  :arith-nonlinear-horner  353
;  :arith-offset-eqs        18910
;  :arith-patches           4
;  :arith-patches_succ      1
;  :arith-pivots            12348
;  :arith-pseudo-nonlinear  60
;  :conflicts               2725
;  :datatype-accessor-ax    416
;  :datatype-constructor-ax 1757
;  :datatype-occurs-check   1021
;  :datatype-splits         1101
;  :decisions               19722
;  :del-clause              131452
;  :final-checks            519
;  :interface-eqs           91
;  :max-generation          14
;  :max-memory              18.34
;  :memory                  16.95
;  :minimized-lits          689
;  :mk-bool-var             162973
;  :mk-clause               131454
;  :num-allocs              963061
;  :num-checks              395
;  :propagations            97445
;  :quant-instantiations    37833
;  :restarts                4
;  :rlimit-count            5504519)
(assert (<
  unknown@222@04
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@223@04))))))
(pop) ; 17
; Joined path conditions
(assert (<
  unknown@222@04
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@223@04))))))
(assert ($FVF.loc_int ($FVF.lookup_int (as sm@221@04  $FVF<Int>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@223@04))) unknown@222@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@223@04))) unknown@222@04)))
(push) ; 17
(assert (not (<
  $Perm.No
  (+
    (+
      (ite
        (and
          (and
            (and
              (<
                (inv@220@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@223@04))) unknown@222@04))
                V@28@04)
              (<=
                0
                (inv@220@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@223@04))) unknown@222@04))))
            (<
              (inv@219@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@223@04))) unknown@222@04))
              V@28@04))
          (<=
            0
            (inv@219@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@223@04))) unknown@222@04))))
        $k@218@04
        $Perm.No)
      (ite
        (and
          (and
            (and
              (<
                (inv@214@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@223@04))) unknown@222@04))
                V@28@04)
              (<=
                0
                (inv@214@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@223@04))) unknown@222@04))))
            (<
              (inv@213@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@223@04))) unknown@222@04))
              V@28@04))
          (<=
            0
            (inv@213@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@223@04))) unknown@222@04))))
        $Perm.Write
        $Perm.No))
    (-
      (ite
        (and
          (and
            (and
              (<
                (inv@52@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@223@04))) unknown@222@04))
                V@28@04)
              (<=
                0
                (inv@52@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@223@04))) unknown@222@04))))
            (<
              (inv@51@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@223@04))) unknown@222@04))
              V@28@04))
          (<=
            0
            (inv@51@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@223@04))) unknown@222@04))))
        $k@50@04
        $Perm.No)
      (pTaken@207@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@223@04))) unknown@222@04)))))))
(check-sat)
; unsat
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               129145
;  :arith-add-rows          89333
;  :arith-assert-diseq      7737
;  :arith-assert-lower      41773
;  :arith-assert-upper      27728
;  :arith-bound-prop        6258
;  :arith-conflicts         1183
;  :arith-eq-adapter        22274
;  :arith-fixed-eqs         15327
;  :arith-gcd-tests         3
;  :arith-grobner           294
;  :arith-ineq-splits       2
;  :arith-max-min           1922
;  :arith-nonlinear-bounds  233
;  :arith-nonlinear-horner  353
;  :arith-offset-eqs        18910
;  :arith-patches           4
;  :arith-patches_succ      1
;  :arith-pivots            12348
;  :arith-pseudo-nonlinear  60
;  :conflicts               2726
;  :datatype-accessor-ax    416
;  :datatype-constructor-ax 1757
;  :datatype-occurs-check   1021
;  :datatype-splits         1101
;  :decisions               19722
;  :del-clause              131482
;  :final-checks            519
;  :interface-eqs           91
;  :max-generation          14
;  :max-memory              18.34
;  :memory                  16.95
;  :minimized-lits          689
;  :mk-bool-var             163007
;  :mk-clause               131484
;  :num-allocs              963509
;  :num-checks              396
;  :propagations            97445
;  :quant-instantiations    37833
;  :restarts                4
;  :rlimit-count            5505935)
(pop) ; 16
(push) ; 16
; [else-branch: 276 | !(unknown1@223@04 < V@28@04 && 0 <= unknown1@223@04)]
(assert (not (and (< unknown1@223@04 V@28@04) (<= 0 unknown1@223@04))))
(pop) ; 16
(pop) ; 15
; Joined path conditions
(assert (implies
  (and (< unknown1@223@04 V@28@04) (<= 0 unknown1@223@04))
  (and
    (< unknown1@223@04 V@28@04)
    (<= 0 unknown1@223@04)
    (< unknown1@223@04 (alen<Int> (opt_get1 $Snap.unit target@27@04)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@223@04)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@223@04))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@223@04))
        (as None<option<array>>  option<array>)))
    (<
      unknown@222@04
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@223@04)))))
    ($FVF.loc_int ($FVF.lookup_int (as sm@221@04  $FVF<Int>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@223@04))) unknown@222@04)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@223@04))) unknown@222@04))
    (< unknown1@223@04 (alen<Int> (opt_get1 $Snap.unit source@26@04)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@223@04)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@223@04))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@223@04))
        (as None<option<array>>  option<array>)))
    (<
      unknown@222@04
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@223@04)))))
    ($FVF.loc_int ($FVF.lookup_int (as sm@221@04  $FVF<Int>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@223@04))) unknown@222@04)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@223@04))) unknown@222@04)))))
; Joined path conditions
(pop) ; 14
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((unknown1@223@04 Int)) (!
  (implies
    (and (< unknown1@223@04 V@28@04) (<= 0 unknown1@223@04))
    (and
      (< unknown1@223@04 V@28@04)
      (<= 0 unknown1@223@04)
      (< unknown1@223@04 (alen<Int> (opt_get1 $Snap.unit target@27@04)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@223@04)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@223@04))
      (not
        (=
          ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@223@04))
          (as None<option<array>>  option<array>)))
      (<
        unknown@222@04
        (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@223@04)))))
      ($FVF.loc_int ($FVF.lookup_int (as sm@221@04  $FVF<Int>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@223@04))) unknown@222@04)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@223@04))) unknown@222@04))
      (< unknown1@223@04 (alen<Int> (opt_get1 $Snap.unit source@26@04)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@223@04)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@223@04))
      (not
        (=
          ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@223@04))
          (as None<option<array>>  option<array>)))
      (<
        unknown@222@04
        (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@223@04)))))
      ($FVF.loc_int ($FVF.lookup_int (as sm@221@04  $FVF<Int>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@223@04))) unknown@222@04)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@223@04))) unknown@222@04))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@223@04))) unknown@222@04))
  :qid |prog.l<no position>-aux|)))
(assert (forall ((unknown1@223@04 Int)) (!
  (implies
    (and (< unknown1@223@04 V@28@04) (<= 0 unknown1@223@04))
    (and
      (< unknown1@223@04 V@28@04)
      (<= 0 unknown1@223@04)
      (< unknown1@223@04 (alen<Int> (opt_get1 $Snap.unit target@27@04)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@223@04)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@223@04))
      (not
        (=
          ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@223@04))
          (as None<option<array>>  option<array>)))
      (<
        unknown@222@04
        (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@223@04)))))
      ($FVF.loc_int ($FVF.lookup_int (as sm@221@04  $FVF<Int>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@223@04))) unknown@222@04)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@223@04))) unknown@222@04))
      (< unknown1@223@04 (alen<Int> (opt_get1 $Snap.unit source@26@04)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@223@04)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@223@04))
      (not
        (=
          ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@223@04))
          (as None<option<array>>  option<array>)))
      (<
        unknown@222@04
        (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@223@04)))))
      ($FVF.loc_int ($FVF.lookup_int (as sm@221@04  $FVF<Int>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@223@04))) unknown@222@04)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@223@04))) unknown@222@04))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@223@04))) unknown@222@04))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 13
(push) ; 13
; [else-branch: 274 | !(unknown@222@04 < V@28@04 && 0 <= unknown@222@04)]
(assert (not (and (< unknown@222@04 V@28@04) (<= 0 unknown@222@04))))
(pop) ; 13
(pop) ; 12
; Joined path conditions
(assert (implies
  (and (< unknown@222@04 V@28@04) (<= 0 unknown@222@04))
  (and
    (< unknown@222@04 V@28@04)
    (<= 0 unknown@222@04)
    (forall ((unknown1@223@04 Int)) (!
      (implies
        (and (< unknown1@223@04 V@28@04) (<= 0 unknown1@223@04))
        (and
          (< unknown1@223@04 V@28@04)
          (<= 0 unknown1@223@04)
          (< unknown1@223@04 (alen<Int> (opt_get1 $Snap.unit target@27@04)))
          ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@223@04)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@223@04))
          (not
            (=
              ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@223@04))
              (as None<option<array>>  option<array>)))
          (<
            unknown@222@04
            (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@223@04)))))
          ($FVF.loc_int ($FVF.lookup_int (as sm@221@04  $FVF<Int>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@223@04))) unknown@222@04)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@223@04))) unknown@222@04))
          (< unknown1@223@04 (alen<Int> (opt_get1 $Snap.unit source@26@04)))
          ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@223@04)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@223@04))
          (not
            (=
              ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@223@04))
              (as None<option<array>>  option<array>)))
          (<
            unknown@222@04
            (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@223@04)))))
          ($FVF.loc_int ($FVF.lookup_int (as sm@221@04  $FVF<Int>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@223@04))) unknown@222@04)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@223@04))) unknown@222@04))))
      :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@223@04))) unknown@222@04))
      :qid |prog.l<no position>-aux|))
    (forall ((unknown1@223@04 Int)) (!
      (implies
        (and (< unknown1@223@04 V@28@04) (<= 0 unknown1@223@04))
        (and
          (< unknown1@223@04 V@28@04)
          (<= 0 unknown1@223@04)
          (< unknown1@223@04 (alen<Int> (opt_get1 $Snap.unit target@27@04)))
          ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@223@04)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@223@04))
          (not
            (=
              ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@223@04))
              (as None<option<array>>  option<array>)))
          (<
            unknown@222@04
            (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@223@04)))))
          ($FVF.loc_int ($FVF.lookup_int (as sm@221@04  $FVF<Int>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@223@04))) unknown@222@04)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@223@04))) unknown@222@04))
          (< unknown1@223@04 (alen<Int> (opt_get1 $Snap.unit source@26@04)))
          ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@223@04)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@223@04))
          (not
            (=
              ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@223@04))
              (as None<option<array>>  option<array>)))
          (<
            unknown@222@04
            (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@223@04)))))
          ($FVF.loc_int ($FVF.lookup_int (as sm@221@04  $FVF<Int>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@223@04))) unknown@222@04)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@223@04))) unknown@222@04))))
      :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@223@04))) unknown@222@04))
      :qid |prog.l<no position>-aux|)))))
; Joined path conditions
(pop) ; 11
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 10
(pop) ; 9
; Joined path conditions
(assert (implies
  (= exc@208@04 $Ref.null)
  (forall ((unknown@222@04 Int)) (!
    (implies
      (and (< unknown@222@04 V@28@04) (<= 0 unknown@222@04))
      (forall ((unknown1@223@04 Int)) (!
        (implies
          (and (< unknown1@223@04 V@28@04) (<= 0 unknown1@223@04))
          (=
            ($FVF.lookup_int (as sm@221@04  $FVF<Int>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@223@04))) unknown@222@04))
            ($FVF.lookup_int (as sm@221@04  $FVF<Int>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@223@04))) unknown@222@04))))
        :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown1@223@04))) unknown@222@04))
        :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown1@223@04))) unknown@222@04))
        :qid |prog.l<no position>|)))
    
    :qid |prog.l<no position>|))))
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
; [eval] exc != null
; [then-branch: 277 | exc@208@04 != Null | dead]
; [else-branch: 277 | exc@208@04 == Null | live]
(push) ; 9
; [else-branch: 277 | exc@208@04 == Null]
(pop) ; 9
; [eval] !(exc != null)
; [eval] exc != null
(set-option :timeout 10)
(push) ; 9
(assert (not (not (= exc@208@04 $Ref.null))))
(check-sat)
; unknown
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               129207
;  :arith-add-rows          89333
;  :arith-assert-diseq      7737
;  :arith-assert-lower      41773
;  :arith-assert-upper      27728
;  :arith-bound-prop        6258
;  :arith-conflicts         1183
;  :arith-eq-adapter        22274
;  :arith-fixed-eqs         15327
;  :arith-gcd-tests         3
;  :arith-grobner           294
;  :arith-ineq-splits       2
;  :arith-max-min           1922
;  :arith-nonlinear-bounds  233
;  :arith-nonlinear-horner  353
;  :arith-offset-eqs        18910
;  :arith-patches           4
;  :arith-patches_succ      1
;  :arith-pivots            12349
;  :arith-pseudo-nonlinear  60
;  :conflicts               2726
;  :datatype-accessor-ax    416
;  :datatype-constructor-ax 1769
;  :datatype-occurs-check   1031
;  :datatype-splits         1105
;  :decisions               19734
;  :del-clause              131484
;  :final-checks            523
;  :interface-eqs           91
;  :max-generation          14
;  :max-memory              18.34
;  :memory                  17.03
;  :minimized-lits          689
;  :mk-bool-var             163012
;  :mk-clause               131484
;  :num-allocs              965531
;  :num-checks              398
;  :propagations            97445
;  :quant-instantiations    37833
;  :restarts                4
;  :rlimit-count            5508436)
; [then-branch: 278 | exc@208@04 == Null | live]
; [else-branch: 278 | exc@208@04 != Null | dead]
(push) ; 9
; [then-branch: 278 | exc@208@04 == Null]
; [exec]
; evaluationDummy := res1
; [exec]
; label end
; [exec]
; res := return
; [exec]
; label bubble
; [eval] exc == null
; [eval] exc == null ==> source != (None(): option[array])
; [eval] exc == null
(push) ; 10
(push) ; 11
(assert (not (not (= exc@208@04 $Ref.null))))
(check-sat)
; unknown
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               129238
;  :arith-add-rows          89333
;  :arith-assert-diseq      7737
;  :arith-assert-lower      41773
;  :arith-assert-upper      27728
;  :arith-bound-prop        6258
;  :arith-conflicts         1183
;  :arith-eq-adapter        22274
;  :arith-fixed-eqs         15327
;  :arith-gcd-tests         3
;  :arith-grobner           294
;  :arith-ineq-splits       2
;  :arith-max-min           1922
;  :arith-nonlinear-bounds  233
;  :arith-nonlinear-horner  353
;  :arith-offset-eqs        18910
;  :arith-patches           4
;  :arith-patches_succ      1
;  :arith-pivots            12349
;  :arith-pseudo-nonlinear  60
;  :conflicts               2726
;  :datatype-accessor-ax    416
;  :datatype-constructor-ax 1775
;  :datatype-occurs-check   1036
;  :datatype-splits         1107
;  :decisions               19740
;  :del-clause              131484
;  :final-checks            525
;  :interface-eqs           91
;  :max-generation          14
;  :max-memory              18.34
;  :memory                  17.03
;  :minimized-lits          689
;  :mk-bool-var             163014
;  :mk-clause               131484
;  :num-allocs              966121
;  :num-checks              399
;  :propagations            97445
;  :quant-instantiations    37833
;  :restarts                4
;  :rlimit-count            5509131)
; [then-branch: 279 | exc@208@04 == Null | live]
; [else-branch: 279 | exc@208@04 != Null | dead]
(push) ; 11
; [then-branch: 279 | exc@208@04 == Null]
; [eval] source != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 11
(pop) ; 10
; Joined path conditions
(set-option :timeout 0)
(push) ; 10
(assert (not (implies
  (= exc@208@04 $Ref.null)
  (not (= source@26@04 (as None<option<array>>  option<array>))))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               129238
;  :arith-add-rows          89333
;  :arith-assert-diseq      7737
;  :arith-assert-lower      41773
;  :arith-assert-upper      27728
;  :arith-bound-prop        6258
;  :arith-conflicts         1183
;  :arith-eq-adapter        22274
;  :arith-fixed-eqs         15327
;  :arith-gcd-tests         3
;  :arith-grobner           294
;  :arith-ineq-splits       2
;  :arith-max-min           1922
;  :arith-nonlinear-bounds  233
;  :arith-nonlinear-horner  353
;  :arith-offset-eqs        18910
;  :arith-patches           4
;  :arith-patches_succ      1
;  :arith-pivots            12349
;  :arith-pseudo-nonlinear  60
;  :conflicts               2726
;  :datatype-accessor-ax    416
;  :datatype-constructor-ax 1775
;  :datatype-occurs-check   1036
;  :datatype-splits         1107
;  :decisions               19740
;  :del-clause              131484
;  :final-checks            525
;  :interface-eqs           91
;  :max-generation          14
;  :max-memory              18.34
;  :memory                  17.03
;  :minimized-lits          689
;  :mk-bool-var             163014
;  :mk-clause               131484
;  :num-allocs              966146
;  :num-checks              400
;  :propagations            97445
;  :quant-instantiations    37833
;  :restarts                4
;  :rlimit-count            5509151)
(assert (implies
  (= exc@208@04 $Ref.null)
  (not (= source@26@04 (as None<option<array>>  option<array>)))))
; [eval] exc == null ==> alen(opt_get1(source)) == V
; [eval] exc == null
(push) ; 10
(set-option :timeout 10)
(push) ; 11
(assert (not (not (= exc@208@04 $Ref.null))))
(check-sat)
; unknown
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               129269
;  :arith-add-rows          89333
;  :arith-assert-diseq      7737
;  :arith-assert-lower      41773
;  :arith-assert-upper      27728
;  :arith-bound-prop        6258
;  :arith-conflicts         1183
;  :arith-eq-adapter        22274
;  :arith-fixed-eqs         15327
;  :arith-gcd-tests         3
;  :arith-grobner           294
;  :arith-ineq-splits       2
;  :arith-max-min           1922
;  :arith-nonlinear-bounds  233
;  :arith-nonlinear-horner  353
;  :arith-offset-eqs        18910
;  :arith-patches           4
;  :arith-patches_succ      1
;  :arith-pivots            12349
;  :arith-pseudo-nonlinear  60
;  :conflicts               2726
;  :datatype-accessor-ax    416
;  :datatype-constructor-ax 1781
;  :datatype-occurs-check   1041
;  :datatype-splits         1109
;  :decisions               19746
;  :del-clause              131484
;  :final-checks            527
;  :interface-eqs           91
;  :max-generation          14
;  :max-memory              18.34
;  :memory                  17.03
;  :minimized-lits          689
;  :mk-bool-var             163016
;  :mk-clause               131484
;  :num-allocs              966738
;  :num-checks              401
;  :propagations            97445
;  :quant-instantiations    37833
;  :restarts                4
;  :rlimit-count            5509846)
; [then-branch: 280 | exc@208@04 == Null | live]
; [else-branch: 280 | exc@208@04 != Null | dead]
(push) ; 11
; [then-branch: 280 | exc@208@04 == Null]
; [eval] alen(opt_get1(source)) == V
; [eval] alen(opt_get1(source))
; [eval] opt_get1(source)
(push) ; 12
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 12
; Joined path conditions
(pop) ; 11
(pop) ; 10
; Joined path conditions
(set-option :timeout 0)
(push) ; 10
(assert (not (implies
  (= exc@208@04 $Ref.null)
  (= (alen<Int> (opt_get1 $Snap.unit source@26@04)) V@28@04))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               129269
;  :arith-add-rows          89333
;  :arith-assert-diseq      7737
;  :arith-assert-lower      41773
;  :arith-assert-upper      27728
;  :arith-bound-prop        6258
;  :arith-conflicts         1183
;  :arith-eq-adapter        22274
;  :arith-fixed-eqs         15327
;  :arith-gcd-tests         3
;  :arith-grobner           294
;  :arith-ineq-splits       2
;  :arith-max-min           1922
;  :arith-nonlinear-bounds  233
;  :arith-nonlinear-horner  353
;  :arith-offset-eqs        18910
;  :arith-patches           4
;  :arith-patches_succ      1
;  :arith-pivots            12349
;  :arith-pseudo-nonlinear  60
;  :conflicts               2726
;  :datatype-accessor-ax    416
;  :datatype-constructor-ax 1781
;  :datatype-occurs-check   1041
;  :datatype-splits         1109
;  :decisions               19746
;  :del-clause              131484
;  :final-checks            527
;  :interface-eqs           91
;  :max-generation          14
;  :max-memory              18.34
;  :memory                  17.03
;  :minimized-lits          689
;  :mk-bool-var             163016
;  :mk-clause               131484
;  :num-allocs              966757
;  :num-checks              402
;  :propagations            97445
;  :quant-instantiations    37833
;  :restarts                4
;  :rlimit-count            5509871)
(assert (implies
  (= exc@208@04 $Ref.null)
  (= (alen<Int> (opt_get1 $Snap.unit source@26@04)) V@28@04)))
; [eval] exc == null
(set-option :timeout 10)
(push) ; 10
(assert (not (not (= exc@208@04 $Ref.null))))
(check-sat)
; unknown
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               129300
;  :arith-add-rows          89333
;  :arith-assert-diseq      7737
;  :arith-assert-lower      41773
;  :arith-assert-upper      27728
;  :arith-bound-prop        6258
;  :arith-conflicts         1183
;  :arith-eq-adapter        22274
;  :arith-fixed-eqs         15327
;  :arith-gcd-tests         3
;  :arith-grobner           294
;  :arith-ineq-splits       2
;  :arith-max-min           1922
;  :arith-nonlinear-bounds  233
;  :arith-nonlinear-horner  353
;  :arith-offset-eqs        18910
;  :arith-patches           4
;  :arith-patches_succ      1
;  :arith-pivots            12349
;  :arith-pseudo-nonlinear  60
;  :conflicts               2726
;  :datatype-accessor-ax    416
;  :datatype-constructor-ax 1787
;  :datatype-occurs-check   1046
;  :datatype-splits         1111
;  :decisions               19752
;  :del-clause              131484
;  :final-checks            529
;  :interface-eqs           91
;  :max-generation          14
;  :max-memory              18.34
;  :memory                  17.03
;  :minimized-lits          689
;  :mk-bool-var             163018
;  :mk-clause               131484
;  :num-allocs              967349
;  :num-checks              403
;  :propagations            97445
;  :quant-instantiations    37833
;  :restarts                4
;  :rlimit-count            5510561)
; [then-branch: 281 | exc@208@04 == Null | live]
; [else-branch: 281 | exc@208@04 != Null | dead]
(push) ; 10
; [then-branch: 281 | exc@208@04 == Null]
(declare-const i1@224@04 Int)
(push) ; 11
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 12
; [then-branch: 282 | 0 <= i1@224@04 | live]
; [else-branch: 282 | !(0 <= i1@224@04) | live]
(push) ; 13
; [then-branch: 282 | 0 <= i1@224@04]
(assert (<= 0 i1@224@04))
; [eval] i1 < V
(pop) ; 13
(push) ; 13
; [else-branch: 282 | !(0 <= i1@224@04)]
(assert (not (<= 0 i1@224@04)))
(pop) ; 13
(pop) ; 12
; Joined path conditions
; Joined path conditions
(assert (and (< i1@224@04 V@28@04) (<= 0 i1@224@04)))
(declare-const $k@225@04 $Perm)
(assert ($Perm.isReadVar $k@225@04 $Perm.Write))
; [eval] aloc(opt_get1(source), i1)
; [eval] opt_get1(source)
(push) ; 12
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 12
; Joined path conditions
(push) ; 12
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 13
(assert (not (< i1@224@04 (alen<Int> (opt_get1 $Snap.unit source@26@04)))))
(check-sat)
; unsat
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               129300
;  :arith-add-rows          89333
;  :arith-assert-diseq      7738
;  :arith-assert-lower      41777
;  :arith-assert-upper      27729
;  :arith-bound-prop        6258
;  :arith-conflicts         1184
;  :arith-eq-adapter        22275
;  :arith-fixed-eqs         15327
;  :arith-gcd-tests         3
;  :arith-grobner           294
;  :arith-ineq-splits       2
;  :arith-max-min           1922
;  :arith-nonlinear-bounds  233
;  :arith-nonlinear-horner  353
;  :arith-offset-eqs        18910
;  :arith-patches           4
;  :arith-patches_succ      1
;  :arith-pivots            12349
;  :arith-pseudo-nonlinear  60
;  :conflicts               2727
;  :datatype-accessor-ax    416
;  :datatype-constructor-ax 1787
;  :datatype-occurs-check   1046
;  :datatype-splits         1111
;  :decisions               19752
;  :del-clause              131484
;  :final-checks            529
;  :interface-eqs           91
;  :max-generation          14
;  :max-memory              18.34
;  :memory                  17.03
;  :minimized-lits          689
;  :mk-bool-var             163024
;  :mk-clause               131486
;  :num-allocs              967514
;  :num-checks              404
;  :propagations            97446
;  :quant-instantiations    37833
;  :restarts                4
;  :rlimit-count            5510878)
(assert (< i1@224@04 (alen<Int> (opt_get1 $Snap.unit source@26@04))))
(pop) ; 12
; Joined path conditions
(assert (< i1@224@04 (alen<Int> (opt_get1 $Snap.unit source@26@04))))
(pop) ; 11
(declare-fun inv@226@04 ($Ref) Int)
; Nested auxiliary terms: globals
(assert ($Perm.isReadVar $k@225@04 $Perm.Write))
; Nested auxiliary terms: non-globals
(assert (forall ((i1@224@04 Int)) (!
  (< i1@224@04 (alen<Int> (opt_get1 $Snap.unit source@26@04)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@224@04))
  :qid |option$array$-aux|)))
(push) ; 11
(assert (not (forall ((i1@224@04 Int)) (!
  (implies
    (and (< i1@224@04 V@28@04) (<= 0 i1@224@04))
    (or (= $k@225@04 $Perm.No) (< $Perm.No $k@225@04)))
  
  ))))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               129300
;  :arith-add-rows          89333
;  :arith-assert-diseq      7739
;  :arith-assert-lower      41779
;  :arith-assert-upper      27730
;  :arith-bound-prop        6258
;  :arith-conflicts         1184
;  :arith-eq-adapter        22276
;  :arith-fixed-eqs         15327
;  :arith-gcd-tests         3
;  :arith-grobner           294
;  :arith-ineq-splits       2
;  :arith-max-min           1922
;  :arith-nonlinear-bounds  233
;  :arith-nonlinear-horner  353
;  :arith-offset-eqs        18910
;  :arith-patches           4
;  :arith-patches_succ      1
;  :arith-pivots            12349
;  :arith-pseudo-nonlinear  60
;  :conflicts               2728
;  :datatype-accessor-ax    416
;  :datatype-constructor-ax 1787
;  :datatype-occurs-check   1046
;  :datatype-splits         1111
;  :decisions               19752
;  :del-clause              131486
;  :final-checks            529
;  :interface-eqs           91
;  :max-generation          14
;  :max-memory              18.34
;  :memory                  17.03
;  :minimized-lits          689
;  :mk-bool-var             163031
;  :mk-clause               131488
;  :num-allocs              967943
;  :num-checks              405
;  :propagations            97447
;  :quant-instantiations    37833
;  :restarts                4
;  :rlimit-count            5511424)
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 11
(assert (not (forall ((i11@224@04 Int) (i12@224@04 Int)) (!
  (implies
    (and
      (and
        (and
          (and (< i11@224@04 V@28@04) (<= 0 i11@224@04))
          ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@26@04) i11@224@04)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@26@04) i11@224@04)))
        (< $Perm.No $k@225@04))
      (and
        (and
          (and (< i12@224@04 V@28@04) (<= 0 i12@224@04))
          ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@26@04) i12@224@04)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@26@04) i12@224@04)))
        (< $Perm.No $k@225@04))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i11@224@04)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i12@224@04)))
    (= i11@224@04 i12@224@04))
  
  :qid |option$array$-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               129304
;  :arith-add-rows          89334
;  :arith-assert-diseq      7740
;  :arith-assert-lower      41783
;  :arith-assert-upper      27730
;  :arith-bound-prop        6258
;  :arith-conflicts         1185
;  :arith-eq-adapter        22277
;  :arith-fixed-eqs         15327
;  :arith-gcd-tests         3
;  :arith-grobner           294
;  :arith-ineq-splits       2
;  :arith-max-min           1922
;  :arith-nonlinear-bounds  233
;  :arith-nonlinear-horner  353
;  :arith-offset-eqs        18910
;  :arith-patches           4
;  :arith-patches_succ      1
;  :arith-pivots            12351
;  :arith-pseudo-nonlinear  60
;  :conflicts               2729
;  :datatype-accessor-ax    416
;  :datatype-constructor-ax 1787
;  :datatype-occurs-check   1046
;  :datatype-splits         1111
;  :decisions               19752
;  :del-clause              131490
;  :final-checks            529
;  :interface-eqs           91
;  :max-generation          14
;  :max-memory              18.34
;  :memory                  17.02
;  :minimized-lits          689
;  :mk-bool-var             163042
;  :mk-clause               131492
;  :num-allocs              968245
;  :num-checks              406
;  :propagations            97447
;  :quant-instantiations    37833
;  :restarts                4
;  :rlimit-count            5512009)
; Definitional axioms for inverse functions
(assert (forall ((i1@224@04 Int)) (!
  (implies
    (and (and (< i1@224@04 V@28@04) (<= 0 i1@224@04)) (< $Perm.No $k@225@04))
    (=
      (inv@226@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@224@04))
      i1@224@04))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@224@04))
  :qid |option$array$-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and (< (inv@226@04 r) V@28@04) (<= 0 (inv@226@04 r)))
      (< $Perm.No $k@225@04))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) (inv@226@04 r))
      r))
  :pattern ((inv@226@04 r))
  :qid |option$array$-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@226@04 r) V@28@04) (<= 0 (inv@226@04 r)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) r) r))
  :pattern ((inv@226@04 r))
  )))
; Precomputing data for removing quantified permissions
(define-fun pTaken@227@04 ((r $Ref)) $Perm
  (ite
    (and (< (inv@226@04 r) V@28@04) (<= 0 (inv@226@04 r)))
    ($Perm.min
      (ite
        (and (< (inv@42@04 r) V@28@04) (<= 0 (inv@42@04 r)))
        $k@41@04
        $Perm.No)
      $k@225@04)
    $Perm.No))
(define-fun pTaken@228@04 ((r $Ref)) $Perm
  (ite
    (and (< (inv@226@04 r) V@28@04) (<= 0 (inv@226@04 r)))
    ($Perm.min
      (ite
        (and (< (inv@34@04 r) V@28@04) (<= 0 (inv@34@04 r)))
        $k@33@04
        $Perm.No)
      (- $k@225@04 (pTaken@227@04 r)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Constrain original permissions $k@225@04
(assert (forall ((r $Ref)) (!
  (implies
    (not
      (=
        (ite
          (and (< (inv@42@04 r) V@28@04) (<= 0 (inv@42@04 r)))
          $k@41@04
          $Perm.No)
        $Perm.No))
    (ite
      (and (< (inv@42@04 r) V@28@04) (<= 0 (inv@42@04 r)))
      (<
        (ite
          (and (< (inv@226@04 r) V@28@04) (<= 0 (inv@226@04 r)))
          $k@225@04
          $Perm.No)
        $k@41@04)
      (<
        (ite
          (and (< (inv@226@04 r) V@28@04) (<= 0 (inv@226@04 r)))
          $k@225@04
          $Perm.No)
        $Perm.No)))
  :pattern ((inv@42@04 r))
  :pattern ((inv@226@04 r))
  :qid |qp.srp70|)))
; Intermediate check if already taken enough permissions
(set-option :timeout 500)
(push) ; 11
(assert (not (forall ((r $Ref)) (!
  (implies
    (and (< (inv@226@04 r) V@28@04) (<= 0 (inv@226@04 r)))
    (= (- $k@225@04 (pTaken@227@04 r)) $Perm.No))
  
  ))))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               129336
;  :arith-add-rows          89334
;  :arith-assert-diseq      7741
;  :arith-assert-lower      41785
;  :arith-assert-upper      27730
;  :arith-bound-prop        6258
;  :arith-conflicts         1186
;  :arith-eq-adapter        22278
;  :arith-fixed-eqs         15327
;  :arith-gcd-tests         3
;  :arith-grobner           294
;  :arith-ineq-splits       2
;  :arith-max-min           1922
;  :arith-nonlinear-bounds  233
;  :arith-nonlinear-horner  353
;  :arith-offset-eqs        18910
;  :arith-patches           4
;  :arith-patches_succ      1
;  :arith-pivots            12353
;  :arith-pseudo-nonlinear  60
;  :conflicts               2730
;  :datatype-accessor-ax    416
;  :datatype-constructor-ax 1793
;  :datatype-occurs-check   1051
;  :datatype-splits         1113
;  :decisions               19758
;  :del-clause              131503
;  :final-checks            531
;  :interface-eqs           91
;  :max-generation          14
;  :max-memory              18.34
;  :memory                  17.02
;  :minimized-lits          689
;  :mk-bool-var             163064
;  :mk-clause               131503
;  :num-allocs              969911
;  :num-checks              408
;  :propagations            97447
;  :quant-instantiations    37833
;  :restarts                4
;  :rlimit-count            5514653)
; Final check if taken enough permissions
; Done removing quantified permissions
; Definitional axioms for snapshot map values
; [eval] exc == null ==> (forall i1: Int :: { aloc(opt_get1(source), i1) } 0 <= i1 && i1 < V ==> aloc(opt_get1(source), i1).option$array$ != (None(): option[array]))
; [eval] exc == null
(push) ; 11
(set-option :timeout 10)
(push) ; 12
(assert (not (not (= exc@208@04 $Ref.null))))
(check-sat)
; unknown
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               129367
;  :arith-add-rows          89334
;  :arith-assert-diseq      7741
;  :arith-assert-lower      41785
;  :arith-assert-upper      27730
;  :arith-bound-prop        6258
;  :arith-conflicts         1186
;  :arith-eq-adapter        22278
;  :arith-fixed-eqs         15327
;  :arith-gcd-tests         3
;  :arith-grobner           294
;  :arith-ineq-splits       2
;  :arith-max-min           1922
;  :arith-nonlinear-bounds  233
;  :arith-nonlinear-horner  353
;  :arith-offset-eqs        18910
;  :arith-patches           4
;  :arith-patches_succ      1
;  :arith-pivots            12353
;  :arith-pseudo-nonlinear  60
;  :conflicts               2730
;  :datatype-accessor-ax    416
;  :datatype-constructor-ax 1799
;  :datatype-occurs-check   1056
;  :datatype-splits         1115
;  :decisions               19764
;  :del-clause              131503
;  :final-checks            533
;  :interface-eqs           91
;  :max-generation          14
;  :max-memory              18.34
;  :memory                  17.03
;  :minimized-lits          689
;  :mk-bool-var             163066
;  :mk-clause               131503
;  :num-allocs              970514
;  :num-checks              409
;  :propagations            97447
;  :quant-instantiations    37833
;  :restarts                4
;  :rlimit-count            5515351)
; [then-branch: 283 | exc@208@04 == Null | live]
; [else-branch: 283 | exc@208@04 != Null | dead]
(push) ; 12
; [then-branch: 283 | exc@208@04 == Null]
; [eval] (forall i1: Int :: { aloc(opt_get1(source), i1) } 0 <= i1 && i1 < V ==> aloc(opt_get1(source), i1).option$array$ != (None(): option[array]))
(declare-const i1@229@04 Int)
(push) ; 13
; [eval] 0 <= i1 && i1 < V ==> aloc(opt_get1(source), i1).option$array$ != (None(): option[array])
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 14
; [then-branch: 284 | 0 <= i1@229@04 | live]
; [else-branch: 284 | !(0 <= i1@229@04) | live]
(push) ; 15
; [then-branch: 284 | 0 <= i1@229@04]
(assert (<= 0 i1@229@04))
; [eval] i1 < V
(pop) ; 15
(push) ; 15
; [else-branch: 284 | !(0 <= i1@229@04)]
(assert (not (<= 0 i1@229@04)))
(pop) ; 15
(pop) ; 14
; Joined path conditions
; Joined path conditions
(push) ; 14
; [then-branch: 285 | i1@229@04 < V@28@04 && 0 <= i1@229@04 | live]
; [else-branch: 285 | !(i1@229@04 < V@28@04 && 0 <= i1@229@04) | live]
(push) ; 15
; [then-branch: 285 | i1@229@04 < V@28@04 && 0 <= i1@229@04]
(assert (and (< i1@229@04 V@28@04) (<= 0 i1@229@04)))
; [eval] aloc(opt_get1(source), i1).option$array$ != (None(): option[array])
; [eval] aloc(opt_get1(source), i1)
; [eval] opt_get1(source)
(push) ; 16
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 16
; Joined path conditions
(push) ; 16
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 17
(assert (not (< i1@229@04 (alen<Int> (opt_get1 $Snap.unit source@26@04)))))
(check-sat)
; unsat
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               129367
;  :arith-add-rows          89334
;  :arith-assert-diseq      7741
;  :arith-assert-lower      41787
;  :arith-assert-upper      27730
;  :arith-bound-prop        6258
;  :arith-conflicts         1187
;  :arith-eq-adapter        22278
;  :arith-fixed-eqs         15327
;  :arith-gcd-tests         3
;  :arith-grobner           294
;  :arith-ineq-splits       2
;  :arith-max-min           1922
;  :arith-nonlinear-bounds  233
;  :arith-nonlinear-horner  353
;  :arith-offset-eqs        18910
;  :arith-patches           4
;  :arith-patches_succ      1
;  :arith-pivots            12353
;  :arith-pseudo-nonlinear  60
;  :conflicts               2731
;  :datatype-accessor-ax    416
;  :datatype-constructor-ax 1799
;  :datatype-occurs-check   1056
;  :datatype-splits         1115
;  :decisions               19764
;  :del-clause              131503
;  :final-checks            533
;  :interface-eqs           91
;  :max-generation          14
;  :max-memory              18.34
;  :memory                  17.03
;  :minimized-lits          689
;  :mk-bool-var             163068
;  :mk-clause               131503
;  :num-allocs              970618
;  :num-checks              410
;  :propagations            97447
;  :quant-instantiations    37833
;  :restarts                4
;  :rlimit-count            5515537)
(assert (< i1@229@04 (alen<Int> (opt_get1 $Snap.unit source@26@04))))
(pop) ; 16
; Joined path conditions
(assert (< i1@229@04 (alen<Int> (opt_get1 $Snap.unit source@26@04))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@229@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@229@04)))
(push) ; 16
(assert (not (<
  $Perm.No
  (+
    (ite
      (and
        (<
          (inv@42@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@229@04))
          V@28@04)
        (<=
          0
          (inv@42@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@229@04))))
      $k@41@04
      $Perm.No)
    (ite
      (and
        (<
          (inv@34@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@229@04))
          V@28@04)
        (<=
          0
          (inv@34@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@229@04))))
      $k@33@04
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               129367
;  :arith-add-rows          89334
;  :arith-assert-diseq      7741
;  :arith-assert-lower      41787
;  :arith-assert-upper      27730
;  :arith-bound-prop        6258
;  :arith-conflicts         1187
;  :arith-eq-adapter        22278
;  :arith-fixed-eqs         15327
;  :arith-gcd-tests         3
;  :arith-grobner           294
;  :arith-ineq-splits       2
;  :arith-max-min           1922
;  :arith-nonlinear-bounds  233
;  :arith-nonlinear-horner  353
;  :arith-offset-eqs        18910
;  :arith-patches           4
;  :arith-patches_succ      1
;  :arith-pivots            12353
;  :arith-pseudo-nonlinear  60
;  :conflicts               2732
;  :datatype-accessor-ax    416
;  :datatype-constructor-ax 1799
;  :datatype-occurs-check   1056
;  :datatype-splits         1115
;  :decisions               19764
;  :del-clause              131513
;  :final-checks            533
;  :interface-eqs           91
;  :max-generation          14
;  :max-memory              18.34
;  :memory                  17.03
;  :minimized-lits          689
;  :mk-bool-var             163080
;  :mk-clause               131513
;  :num-allocs              970831
;  :num-checks              411
;  :propagations            97447
;  :quant-instantiations    37833
;  :restarts                4
;  :rlimit-count            5516020)
; [eval] (None(): option[array])
(pop) ; 15
(push) ; 15
; [else-branch: 285 | !(i1@229@04 < V@28@04 && 0 <= i1@229@04)]
(assert (not (and (< i1@229@04 V@28@04) (<= 0 i1@229@04))))
(pop) ; 15
(pop) ; 14
; Joined path conditions
(assert (implies
  (and (< i1@229@04 V@28@04) (<= 0 i1@229@04))
  (and
    (< i1@229@04 V@28@04)
    (<= 0 i1@229@04)
    (< i1@229@04 (alen<Int> (opt_get1 $Snap.unit source@26@04)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@229@04)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@229@04)))))
; Joined path conditions
(pop) ; 13
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@229@04 Int)) (!
  (implies
    (and (< i1@229@04 V@28@04) (<= 0 i1@229@04))
    (and
      (< i1@229@04 V@28@04)
      (<= 0 i1@229@04)
      (< i1@229@04 (alen<Int> (opt_get1 $Snap.unit source@26@04)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@229@04)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@229@04))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@229@04))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 12
(pop) ; 11
; Joined path conditions
(assert (implies
  (= exc@208@04 $Ref.null)
  (forall ((i1@229@04 Int)) (!
    (implies
      (and (< i1@229@04 V@28@04) (<= 0 i1@229@04))
      (and
        (< i1@229@04 V@28@04)
        (<= 0 i1@229@04)
        (< i1@229@04 (alen<Int> (opt_get1 $Snap.unit source@26@04)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@229@04)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@229@04))))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@229@04))
    :qid |prog.l<no position>-aux|))))
(push) ; 11
(assert (not (implies
  (= exc@208@04 $Ref.null)
  (forall ((i1@229@04 Int)) (!
    (implies
      (and (< i1@229@04 V@28@04) (<= 0 i1@229@04))
      (not
        (=
          ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@229@04))
          (as None<option<array>>  option<array>))))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@229@04))
    :qid |prog.l<no position>|)))))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               129368
;  :arith-add-rows          89334
;  :arith-assert-diseq      7741
;  :arith-assert-lower      41789
;  :arith-assert-upper      27730
;  :arith-bound-prop        6258
;  :arith-conflicts         1188
;  :arith-eq-adapter        22278
;  :arith-fixed-eqs         15327
;  :arith-gcd-tests         3
;  :arith-grobner           294
;  :arith-ineq-splits       2
;  :arith-max-min           1922
;  :arith-nonlinear-bounds  233
;  :arith-nonlinear-horner  353
;  :arith-offset-eqs        18910
;  :arith-patches           4
;  :arith-patches_succ      1
;  :arith-pivots            12355
;  :arith-pseudo-nonlinear  60
;  :conflicts               2733
;  :datatype-accessor-ax    416
;  :datatype-constructor-ax 1799
;  :datatype-occurs-check   1056
;  :datatype-splits         1115
;  :decisions               19764
;  :del-clause              131513
;  :final-checks            533
;  :interface-eqs           91
;  :max-generation          14
;  :max-memory              18.34
;  :memory                  17.02
;  :minimized-lits          689
;  :mk-bool-var             163084
;  :mk-clause               131513
;  :num-allocs              971280
;  :num-checks              412
;  :propagations            97447
;  :quant-instantiations    37833
;  :restarts                4
;  :rlimit-count            5516729)
(assert (implies
  (= exc@208@04 $Ref.null)
  (forall ((i1@229@04 Int)) (!
    (implies
      (and (< i1@229@04 V@28@04) (<= 0 i1@229@04))
      (not
        (=
          ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@229@04))
          (as None<option<array>>  option<array>))))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@229@04))
    :qid |prog.l<no position>|))))
; [eval] exc == null ==> (forall i1: Int :: { alen(opt_get1(aloc(opt_get1(source), i1).option$array$)) } 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(source), i1).option$array$)) == V)
; [eval] exc == null
(push) ; 11
(set-option :timeout 10)
(push) ; 12
(assert (not (not (= exc@208@04 $Ref.null))))
(check-sat)
; unknown
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               129399
;  :arith-add-rows          89334
;  :arith-assert-diseq      7741
;  :arith-assert-lower      41789
;  :arith-assert-upper      27730
;  :arith-bound-prop        6258
;  :arith-conflicts         1188
;  :arith-eq-adapter        22278
;  :arith-fixed-eqs         15327
;  :arith-gcd-tests         3
;  :arith-grobner           294
;  :arith-ineq-splits       2
;  :arith-max-min           1922
;  :arith-nonlinear-bounds  233
;  :arith-nonlinear-horner  353
;  :arith-offset-eqs        18910
;  :arith-patches           4
;  :arith-patches_succ      1
;  :arith-pivots            12355
;  :arith-pseudo-nonlinear  60
;  :conflicts               2733
;  :datatype-accessor-ax    416
;  :datatype-constructor-ax 1805
;  :datatype-occurs-check   1061
;  :datatype-splits         1117
;  :decisions               19770
;  :del-clause              131513
;  :final-checks            535
;  :interface-eqs           91
;  :max-generation          14
;  :max-memory              18.34
;  :memory                  17.03
;  :minimized-lits          689
;  :mk-bool-var             163087
;  :mk-clause               131513
;  :num-allocs              972079
;  :num-checks              413
;  :propagations            97447
;  :quant-instantiations    37833
;  :restarts                4
;  :rlimit-count            5517742)
; [then-branch: 286 | exc@208@04 == Null | live]
; [else-branch: 286 | exc@208@04 != Null | dead]
(push) ; 12
; [then-branch: 286 | exc@208@04 == Null]
; [eval] (forall i1: Int :: { alen(opt_get1(aloc(opt_get1(source), i1).option$array$)) } 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(source), i1).option$array$)) == V)
(declare-const i1@230@04 Int)
(push) ; 13
; [eval] 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(source), i1).option$array$)) == V
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 14
; [then-branch: 287 | 0 <= i1@230@04 | live]
; [else-branch: 287 | !(0 <= i1@230@04) | live]
(push) ; 15
; [then-branch: 287 | 0 <= i1@230@04]
(assert (<= 0 i1@230@04))
; [eval] i1 < V
(pop) ; 15
(push) ; 15
; [else-branch: 287 | !(0 <= i1@230@04)]
(assert (not (<= 0 i1@230@04)))
(pop) ; 15
(pop) ; 14
; Joined path conditions
; Joined path conditions
(push) ; 14
; [then-branch: 288 | i1@230@04 < V@28@04 && 0 <= i1@230@04 | live]
; [else-branch: 288 | !(i1@230@04 < V@28@04 && 0 <= i1@230@04) | live]
(push) ; 15
; [then-branch: 288 | i1@230@04 < V@28@04 && 0 <= i1@230@04]
(assert (and (< i1@230@04 V@28@04) (<= 0 i1@230@04)))
; [eval] alen(opt_get1(aloc(opt_get1(source), i1).option$array$)) == V
; [eval] alen(opt_get1(aloc(opt_get1(source), i1).option$array$))
; [eval] opt_get1(aloc(opt_get1(source), i1).option$array$)
; [eval] aloc(opt_get1(source), i1)
; [eval] opt_get1(source)
(push) ; 16
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 16
; Joined path conditions
(push) ; 16
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 17
(assert (not (< i1@230@04 (alen<Int> (opt_get1 $Snap.unit source@26@04)))))
(check-sat)
; unsat
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               129399
;  :arith-add-rows          89334
;  :arith-assert-diseq      7741
;  :arith-assert-lower      41790
;  :arith-assert-upper      27731
;  :arith-bound-prop        6258
;  :arith-conflicts         1189
;  :arith-eq-adapter        22278
;  :arith-fixed-eqs         15327
;  :arith-gcd-tests         3
;  :arith-grobner           294
;  :arith-ineq-splits       2
;  :arith-max-min           1922
;  :arith-nonlinear-bounds  233
;  :arith-nonlinear-horner  353
;  :arith-offset-eqs        18910
;  :arith-patches           4
;  :arith-patches_succ      1
;  :arith-pivots            12356
;  :arith-pseudo-nonlinear  60
;  :conflicts               2734
;  :datatype-accessor-ax    416
;  :datatype-constructor-ax 1805
;  :datatype-occurs-check   1061
;  :datatype-splits         1117
;  :decisions               19770
;  :del-clause              131513
;  :final-checks            535
;  :interface-eqs           91
;  :max-generation          14
;  :max-memory              18.34
;  :memory                  17.03
;  :minimized-lits          689
;  :mk-bool-var             163089
;  :mk-clause               131513
;  :num-allocs              972198
;  :num-checks              414
;  :propagations            97447
;  :quant-instantiations    37833
;  :restarts                4
;  :rlimit-count            5517924)
(assert (< i1@230@04 (alen<Int> (opt_get1 $Snap.unit source@26@04))))
(pop) ; 16
; Joined path conditions
(assert (< i1@230@04 (alen<Int> (opt_get1 $Snap.unit source@26@04))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@230@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@230@04)))
(push) ; 16
(assert (not (<
  $Perm.No
  (+
    (ite
      (and
        (<
          (inv@42@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@230@04))
          V@28@04)
        (<=
          0
          (inv@42@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@230@04))))
      $k@41@04
      $Perm.No)
    (ite
      (and
        (<
          (inv@34@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@230@04))
          V@28@04)
        (<=
          0
          (inv@34@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@230@04))))
      $k@33@04
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               129399
;  :arith-add-rows          89334
;  :arith-assert-diseq      7741
;  :arith-assert-lower      41790
;  :arith-assert-upper      27731
;  :arith-bound-prop        6258
;  :arith-conflicts         1189
;  :arith-eq-adapter        22278
;  :arith-fixed-eqs         15327
;  :arith-gcd-tests         3
;  :arith-grobner           294
;  :arith-ineq-splits       2
;  :arith-max-min           1922
;  :arith-nonlinear-bounds  233
;  :arith-nonlinear-horner  353
;  :arith-offset-eqs        18910
;  :arith-patches           4
;  :arith-patches_succ      1
;  :arith-pivots            12356
;  :arith-pseudo-nonlinear  60
;  :conflicts               2735
;  :datatype-accessor-ax    416
;  :datatype-constructor-ax 1805
;  :datatype-occurs-check   1061
;  :datatype-splits         1117
;  :decisions               19770
;  :del-clause              131523
;  :final-checks            535
;  :interface-eqs           91
;  :max-generation          14
;  :max-memory              18.34
;  :memory                  17.03
;  :minimized-lits          689
;  :mk-bool-var             163101
;  :mk-clause               131523
;  :num-allocs              972418
;  :num-checks              415
;  :propagations            97447
;  :quant-instantiations    37833
;  :restarts                4
;  :rlimit-count            5518407)
(push) ; 16
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 17
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@230@04))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               129399
;  :arith-add-rows          89334
;  :arith-assert-diseq      7741
;  :arith-assert-lower      41790
;  :arith-assert-upper      27731
;  :arith-bound-prop        6258
;  :arith-conflicts         1189
;  :arith-eq-adapter        22278
;  :arith-fixed-eqs         15327
;  :arith-gcd-tests         3
;  :arith-grobner           294
;  :arith-ineq-splits       2
;  :arith-max-min           1922
;  :arith-nonlinear-bounds  233
;  :arith-nonlinear-horner  353
;  :arith-offset-eqs        18910
;  :arith-patches           4
;  :arith-patches_succ      1
;  :arith-pivots            12356
;  :arith-pseudo-nonlinear  60
;  :conflicts               2736
;  :datatype-accessor-ax    416
;  :datatype-constructor-ax 1805
;  :datatype-occurs-check   1061
;  :datatype-splits         1117
;  :decisions               19770
;  :del-clause              131523
;  :final-checks            535
;  :interface-eqs           91
;  :max-generation          14
;  :max-memory              18.34
;  :memory                  17.03
;  :minimized-lits          689
;  :mk-bool-var             163102
;  :mk-clause               131523
;  :num-allocs              972508
;  :num-checks              416
;  :propagations            97447
;  :quant-instantiations    37833
;  :restarts                4
;  :rlimit-count            5518496)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@230@04))
    (as None<option<array>>  option<array>))))
(pop) ; 16
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@230@04))
    (as None<option<array>>  option<array>))))
(pop) ; 15
(push) ; 15
; [else-branch: 288 | !(i1@230@04 < V@28@04 && 0 <= i1@230@04)]
(assert (not (and (< i1@230@04 V@28@04) (<= 0 i1@230@04))))
(pop) ; 15
(pop) ; 14
; Joined path conditions
(assert (implies
  (and (< i1@230@04 V@28@04) (<= 0 i1@230@04))
  (and
    (< i1@230@04 V@28@04)
    (<= 0 i1@230@04)
    (< i1@230@04 (alen<Int> (opt_get1 $Snap.unit source@26@04)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@230@04)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@230@04))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@230@04))
        (as None<option<array>>  option<array>))))))
; Joined path conditions
(pop) ; 13
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@230@04 Int)) (!
  (implies
    (and (< i1@230@04 V@28@04) (<= 0 i1@230@04))
    (and
      (< i1@230@04 V@28@04)
      (<= 0 i1@230@04)
      (< i1@230@04 (alen<Int> (opt_get1 $Snap.unit source@26@04)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@230@04)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@230@04))
      (not
        (=
          ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@230@04))
          (as None<option<array>>  option<array>)))))
  :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@230@04)))))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 12
(pop) ; 11
; Joined path conditions
(assert (implies
  (= exc@208@04 $Ref.null)
  (forall ((i1@230@04 Int)) (!
    (implies
      (and (< i1@230@04 V@28@04) (<= 0 i1@230@04))
      (and
        (< i1@230@04 V@28@04)
        (<= 0 i1@230@04)
        (< i1@230@04 (alen<Int> (opt_get1 $Snap.unit source@26@04)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@230@04)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@230@04))
        (not
          (=
            ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@230@04))
            (as None<option<array>>  option<array>)))))
    :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@230@04)))))
    :qid |prog.l<no position>-aux|))))
(push) ; 11
(assert (not (implies
  (= exc@208@04 $Ref.null)
  (forall ((i1@230@04 Int)) (!
    (implies
      (and (< i1@230@04 V@28@04) (<= 0 i1@230@04))
      (=
        (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@230@04))))
        V@28@04))
    :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@230@04)))))
    :qid |prog.l<no position>|)))))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               129399
;  :arith-add-rows          89334
;  :arith-assert-diseq      7741
;  :arith-assert-lower      41792
;  :arith-assert-upper      27731
;  :arith-bound-prop        6258
;  :arith-conflicts         1190
;  :arith-eq-adapter        22278
;  :arith-fixed-eqs         15327
;  :arith-gcd-tests         3
;  :arith-grobner           294
;  :arith-ineq-splits       2
;  :arith-max-min           1922
;  :arith-nonlinear-bounds  233
;  :arith-nonlinear-horner  353
;  :arith-offset-eqs        18910
;  :arith-patches           4
;  :arith-patches_succ      1
;  :arith-pivots            12357
;  :arith-pseudo-nonlinear  60
;  :conflicts               2737
;  :datatype-accessor-ax    416
;  :datatype-constructor-ax 1805
;  :datatype-occurs-check   1061
;  :datatype-splits         1117
;  :decisions               19770
;  :del-clause              131523
;  :final-checks            535
;  :interface-eqs           91
;  :max-generation          14
;  :max-memory              18.34
;  :memory                  17.02
;  :minimized-lits          689
;  :mk-bool-var             163106
;  :mk-clause               131523
;  :num-allocs              972975
;  :num-checks              417
;  :propagations            97447
;  :quant-instantiations    37833
;  :restarts                4
;  :rlimit-count            5519319)
(assert (implies
  (= exc@208@04 $Ref.null)
  (forall ((i1@230@04 Int)) (!
    (implies
      (and (< i1@230@04 V@28@04) (<= 0 i1@230@04))
      (=
        (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@230@04))))
        V@28@04))
    :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@230@04)))))
    :qid |prog.l<no position>|))))
; [eval] exc == null ==> (forall i1: Int :: { aloc(opt_get1(source), i1) } (forall i2: Int :: { aloc(opt_get1(source), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(source), i1).option$array$ == aloc(opt_get1(source), i2).option$array$ ==> i1 == i2))
; [eval] exc == null
(push) ; 11
(set-option :timeout 10)
(push) ; 12
(assert (not (not (= exc@208@04 $Ref.null))))
(check-sat)
; unknown
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               129430
;  :arith-add-rows          89334
;  :arith-assert-diseq      7741
;  :arith-assert-lower      41792
;  :arith-assert-upper      27731
;  :arith-bound-prop        6258
;  :arith-conflicts         1190
;  :arith-eq-adapter        22278
;  :arith-fixed-eqs         15327
;  :arith-gcd-tests         3
;  :arith-grobner           294
;  :arith-ineq-splits       2
;  :arith-max-min           1922
;  :arith-nonlinear-bounds  233
;  :arith-nonlinear-horner  353
;  :arith-offset-eqs        18910
;  :arith-patches           4
;  :arith-patches_succ      1
;  :arith-pivots            12357
;  :arith-pseudo-nonlinear  60
;  :conflicts               2737
;  :datatype-accessor-ax    416
;  :datatype-constructor-ax 1811
;  :datatype-occurs-check   1066
;  :datatype-splits         1119
;  :decisions               19776
;  :del-clause              131523
;  :final-checks            537
;  :interface-eqs           91
;  :max-generation          14
;  :max-memory              18.34
;  :memory                  17.03
;  :minimized-lits          689
;  :mk-bool-var             163109
;  :mk-clause               131523
;  :num-allocs              973775
;  :num-checks              418
;  :propagations            97447
;  :quant-instantiations    37833
;  :restarts                4
;  :rlimit-count            5520334)
; [then-branch: 289 | exc@208@04 == Null | live]
; [else-branch: 289 | exc@208@04 != Null | dead]
(push) ; 12
; [then-branch: 289 | exc@208@04 == Null]
; [eval] (forall i1: Int :: { aloc(opt_get1(source), i1) } (forall i2: Int :: { aloc(opt_get1(source), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(source), i1).option$array$ == aloc(opt_get1(source), i2).option$array$ ==> i1 == i2))
(declare-const i1@231@04 Int)
(push) ; 13
; [eval] (forall i2: Int :: { aloc(opt_get1(source), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(source), i1).option$array$ == aloc(opt_get1(source), i2).option$array$ ==> i1 == i2)
(declare-const i2@232@04 Int)
(push) ; 14
; [eval] 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(source), i1).option$array$ == aloc(opt_get1(source), i2).option$array$ ==> i1 == i2
; [eval] 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(source), i1).option$array$ == aloc(opt_get1(source), i2).option$array$
; [eval] 0 <= i1
(push) ; 15
; [then-branch: 290 | 0 <= i1@231@04 | live]
; [else-branch: 290 | !(0 <= i1@231@04) | live]
(push) ; 16
; [then-branch: 290 | 0 <= i1@231@04]
(assert (<= 0 i1@231@04))
; [eval] i1 < V
(push) ; 17
; [then-branch: 291 | i1@231@04 < V@28@04 | live]
; [else-branch: 291 | !(i1@231@04 < V@28@04) | live]
(push) ; 18
; [then-branch: 291 | i1@231@04 < V@28@04]
(assert (< i1@231@04 V@28@04))
; [eval] 0 <= i2
(push) ; 19
; [then-branch: 292 | 0 <= i2@232@04 | live]
; [else-branch: 292 | !(0 <= i2@232@04) | live]
(push) ; 20
; [then-branch: 292 | 0 <= i2@232@04]
(assert (<= 0 i2@232@04))
; [eval] i2 < V
(push) ; 21
; [then-branch: 293 | i2@232@04 < V@28@04 | live]
; [else-branch: 293 | !(i2@232@04 < V@28@04) | live]
(push) ; 22
; [then-branch: 293 | i2@232@04 < V@28@04]
(assert (< i2@232@04 V@28@04))
; [eval] aloc(opt_get1(source), i1).option$array$ == aloc(opt_get1(source), i2).option$array$
; [eval] aloc(opt_get1(source), i1)
; [eval] opt_get1(source)
(push) ; 23
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 23
; Joined path conditions
(push) ; 23
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 24
(assert (not (< i1@231@04 (alen<Int> (opt_get1 $Snap.unit source@26@04)))))
(check-sat)
; unsat
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               129430
;  :arith-add-rows          89334
;  :arith-assert-diseq      7741
;  :arith-assert-lower      41794
;  :arith-assert-upper      27731
;  :arith-bound-prop        6258
;  :arith-conflicts         1191
;  :arith-eq-adapter        22278
;  :arith-fixed-eqs         15327
;  :arith-gcd-tests         3
;  :arith-grobner           294
;  :arith-ineq-splits       2
;  :arith-max-min           1922
;  :arith-nonlinear-bounds  233
;  :arith-nonlinear-horner  353
;  :arith-offset-eqs        18910
;  :arith-patches           4
;  :arith-patches_succ      1
;  :arith-pivots            12357
;  :arith-pseudo-nonlinear  60
;  :conflicts               2738
;  :datatype-accessor-ax    416
;  :datatype-constructor-ax 1811
;  :datatype-occurs-check   1066
;  :datatype-splits         1119
;  :decisions               19776
;  :del-clause              131523
;  :final-checks            537
;  :interface-eqs           91
;  :max-generation          14
;  :max-memory              18.34
;  :memory                  17.03
;  :minimized-lits          689
;  :mk-bool-var             163113
;  :mk-clause               131523
;  :num-allocs              974060
;  :num-checks              419
;  :propagations            97447
;  :quant-instantiations    37833
;  :restarts                4
;  :rlimit-count            5520639)
(assert (< i1@231@04 (alen<Int> (opt_get1 $Snap.unit source@26@04))))
(pop) ; 23
; Joined path conditions
(assert (< i1@231@04 (alen<Int> (opt_get1 $Snap.unit source@26@04))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@231@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@231@04)))
(push) ; 23
(assert (not (<
  $Perm.No
  (+
    (ite
      (and
        (<
          (inv@42@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@231@04))
          V@28@04)
        (<=
          0
          (inv@42@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@231@04))))
      $k@41@04
      $Perm.No)
    (ite
      (and
        (<
          (inv@34@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@231@04))
          V@28@04)
        (<=
          0
          (inv@34@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@231@04))))
      $k@33@04
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 23
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               129430
;  :arith-add-rows          89334
;  :arith-assert-diseq      7741
;  :arith-assert-lower      41794
;  :arith-assert-upper      27731
;  :arith-bound-prop        6258
;  :arith-conflicts         1191
;  :arith-eq-adapter        22278
;  :arith-fixed-eqs         15327
;  :arith-gcd-tests         3
;  :arith-grobner           294
;  :arith-ineq-splits       2
;  :arith-max-min           1922
;  :arith-nonlinear-bounds  233
;  :arith-nonlinear-horner  353
;  :arith-offset-eqs        18910
;  :arith-patches           4
;  :arith-patches_succ      1
;  :arith-pivots            12357
;  :arith-pseudo-nonlinear  60
;  :conflicts               2739
;  :datatype-accessor-ax    416
;  :datatype-constructor-ax 1811
;  :datatype-occurs-check   1066
;  :datatype-splits         1119
;  :decisions               19776
;  :del-clause              131533
;  :final-checks            537
;  :interface-eqs           91
;  :max-generation          14
;  :max-memory              18.34
;  :memory                  17.03
;  :minimized-lits          689
;  :mk-bool-var             163125
;  :mk-clause               131533
;  :num-allocs              974272
;  :num-checks              420
;  :propagations            97447
;  :quant-instantiations    37833
;  :restarts                4
;  :rlimit-count            5521122)
; [eval] aloc(opt_get1(source), i2)
; [eval] opt_get1(source)
(push) ; 23
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 23
; Joined path conditions
(push) ; 23
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 24
(assert (not (< i2@232@04 (alen<Int> (opt_get1 $Snap.unit source@26@04)))))
(check-sat)
; unsat
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               129430
;  :arith-add-rows          89334
;  :arith-assert-diseq      7741
;  :arith-assert-lower      41794
;  :arith-assert-upper      27731
;  :arith-bound-prop        6258
;  :arith-conflicts         1191
;  :arith-eq-adapter        22278
;  :arith-fixed-eqs         15327
;  :arith-gcd-tests         3
;  :arith-grobner           294
;  :arith-ineq-splits       2
;  :arith-max-min           1922
;  :arith-nonlinear-bounds  233
;  :arith-nonlinear-horner  353
;  :arith-offset-eqs        18910
;  :arith-patches           4
;  :arith-patches_succ      1
;  :arith-pivots            12357
;  :arith-pseudo-nonlinear  60
;  :conflicts               2739
;  :datatype-accessor-ax    416
;  :datatype-constructor-ax 1811
;  :datatype-occurs-check   1066
;  :datatype-splits         1119
;  :decisions               19776
;  :del-clause              131533
;  :final-checks            537
;  :interface-eqs           91
;  :max-generation          14
;  :max-memory              18.34
;  :memory                  17.03
;  :minimized-lits          689
;  :mk-bool-var             163125
;  :mk-clause               131533
;  :num-allocs              974305
;  :num-checks              421
;  :propagations            97447
;  :quant-instantiations    37833
;  :restarts                4
;  :rlimit-count            5521143)
(assert (< i2@232@04 (alen<Int> (opt_get1 $Snap.unit source@26@04))))
(pop) ; 23
; Joined path conditions
(assert (< i2@232@04 (alen<Int> (opt_get1 $Snap.unit source@26@04))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@232@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@232@04)))
(push) ; 23
(assert (not (<
  $Perm.No
  (+
    (ite
      (and
        (<
          (inv@42@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@232@04))
          V@28@04)
        (<=
          0
          (inv@42@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@232@04))))
      $k@41@04
      $Perm.No)
    (ite
      (and
        (<
          (inv@34@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@232@04))
          V@28@04)
        (<=
          0
          (inv@34@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@232@04))))
      $k@33@04
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 23
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               129430
;  :arith-add-rows          89334
;  :arith-assert-diseq      7741
;  :arith-assert-lower      41794
;  :arith-assert-upper      27731
;  :arith-bound-prop        6258
;  :arith-conflicts         1191
;  :arith-eq-adapter        22278
;  :arith-fixed-eqs         15327
;  :arith-gcd-tests         3
;  :arith-grobner           294
;  :arith-ineq-splits       2
;  :arith-max-min           1922
;  :arith-nonlinear-bounds  233
;  :arith-nonlinear-horner  353
;  :arith-offset-eqs        18910
;  :arith-patches           4
;  :arith-patches_succ      1
;  :arith-pivots            12357
;  :arith-pseudo-nonlinear  60
;  :conflicts               2740
;  :datatype-accessor-ax    416
;  :datatype-constructor-ax 1811
;  :datatype-occurs-check   1066
;  :datatype-splits         1119
;  :decisions               19776
;  :del-clause              131543
;  :final-checks            537
;  :interface-eqs           91
;  :max-generation          14
;  :max-memory              18.34
;  :memory                  17.03
;  :minimized-lits          689
;  :mk-bool-var             163137
;  :mk-clause               131543
;  :num-allocs              974525
;  :num-checks              422
;  :propagations            97447
;  :quant-instantiations    37833
;  :restarts                4
;  :rlimit-count            5521626)
(pop) ; 22
(push) ; 22
; [else-branch: 293 | !(i2@232@04 < V@28@04)]
(assert (not (< i2@232@04 V@28@04)))
(pop) ; 22
(pop) ; 21
; Joined path conditions
(assert (implies
  (< i2@232@04 V@28@04)
  (and
    (< i2@232@04 V@28@04)
    (< i1@231@04 (alen<Int> (opt_get1 $Snap.unit source@26@04)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@231@04)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@231@04))
    (< i2@232@04 (alen<Int> (opt_get1 $Snap.unit source@26@04)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@232@04)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@232@04)))))
; Joined path conditions
(pop) ; 20
(push) ; 20
; [else-branch: 292 | !(0 <= i2@232@04)]
(assert (not (<= 0 i2@232@04)))
(pop) ; 20
(pop) ; 19
; Joined path conditions
(assert (implies
  (<= 0 i2@232@04)
  (and
    (<= 0 i2@232@04)
    (implies
      (< i2@232@04 V@28@04)
      (and
        (< i2@232@04 V@28@04)
        (< i1@231@04 (alen<Int> (opt_get1 $Snap.unit source@26@04)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@231@04)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@231@04))
        (< i2@232@04 (alen<Int> (opt_get1 $Snap.unit source@26@04)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@232@04)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@232@04)))))))
; Joined path conditions
(pop) ; 18
(push) ; 18
; [else-branch: 291 | !(i1@231@04 < V@28@04)]
(assert (not (< i1@231@04 V@28@04)))
(pop) ; 18
(pop) ; 17
; Joined path conditions
(assert (implies
  (< i1@231@04 V@28@04)
  (and
    (< i1@231@04 V@28@04)
    (implies
      (<= 0 i2@232@04)
      (and
        (<= 0 i2@232@04)
        (implies
          (< i2@232@04 V@28@04)
          (and
            (< i2@232@04 V@28@04)
            (< i1@231@04 (alen<Int> (opt_get1 $Snap.unit source@26@04)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@231@04)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@231@04))
            (< i2@232@04 (alen<Int> (opt_get1 $Snap.unit source@26@04)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@232@04)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@232@04)))))))))
; Joined path conditions
(pop) ; 16
(push) ; 16
; [else-branch: 290 | !(0 <= i1@231@04)]
(assert (not (<= 0 i1@231@04)))
(pop) ; 16
(pop) ; 15
; Joined path conditions
(assert (implies
  (<= 0 i1@231@04)
  (and
    (<= 0 i1@231@04)
    (implies
      (< i1@231@04 V@28@04)
      (and
        (< i1@231@04 V@28@04)
        (implies
          (<= 0 i2@232@04)
          (and
            (<= 0 i2@232@04)
            (implies
              (< i2@232@04 V@28@04)
              (and
                (< i2@232@04 V@28@04)
                (< i1@231@04 (alen<Int> (opt_get1 $Snap.unit source@26@04)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@231@04)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@231@04))
                (< i2@232@04 (alen<Int> (opt_get1 $Snap.unit source@26@04)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@232@04)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@232@04)))))))))))
; Joined path conditions
(push) ; 15
; [then-branch: 294 | Lookup(option$array$,sm@43@04,aloc((_, _), opt_get1(_, source@26@04), i1@231@04)) == Lookup(option$array$,sm@43@04,aloc((_, _), opt_get1(_, source@26@04), i2@232@04)) && i2@232@04 < V@28@04 && 0 <= i2@232@04 && i1@231@04 < V@28@04 && 0 <= i1@231@04 | live]
; [else-branch: 294 | !(Lookup(option$array$,sm@43@04,aloc((_, _), opt_get1(_, source@26@04), i1@231@04)) == Lookup(option$array$,sm@43@04,aloc((_, _), opt_get1(_, source@26@04), i2@232@04)) && i2@232@04 < V@28@04 && 0 <= i2@232@04 && i1@231@04 < V@28@04 && 0 <= i1@231@04) | live]
(push) ; 16
; [then-branch: 294 | Lookup(option$array$,sm@43@04,aloc((_, _), opt_get1(_, source@26@04), i1@231@04)) == Lookup(option$array$,sm@43@04,aloc((_, _), opt_get1(_, source@26@04), i2@232@04)) && i2@232@04 < V@28@04 && 0 <= i2@232@04 && i1@231@04 < V@28@04 && 0 <= i1@231@04]
(assert (and
  (and
    (and
      (and
        (=
          ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@231@04))
          ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@232@04)))
        (< i2@232@04 V@28@04))
      (<= 0 i2@232@04))
    (< i1@231@04 V@28@04))
  (<= 0 i1@231@04)))
; [eval] i1 == i2
(pop) ; 16
(push) ; 16
; [else-branch: 294 | !(Lookup(option$array$,sm@43@04,aloc((_, _), opt_get1(_, source@26@04), i1@231@04)) == Lookup(option$array$,sm@43@04,aloc((_, _), opt_get1(_, source@26@04), i2@232@04)) && i2@232@04 < V@28@04 && 0 <= i2@232@04 && i1@231@04 < V@28@04 && 0 <= i1@231@04)]
(assert (not
  (and
    (and
      (and
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@231@04))
            ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@232@04)))
          (< i2@232@04 V@28@04))
        (<= 0 i2@232@04))
      (< i1@231@04 V@28@04))
    (<= 0 i1@231@04))))
(pop) ; 16
(pop) ; 15
; Joined path conditions
(assert (implies
  (and
    (and
      (and
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@231@04))
            ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@232@04)))
          (< i2@232@04 V@28@04))
        (<= 0 i2@232@04))
      (< i1@231@04 V@28@04))
    (<= 0 i1@231@04))
  (and
    (=
      ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@231@04))
      ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@232@04)))
    (< i2@232@04 V@28@04)
    (<= 0 i2@232@04)
    (< i1@231@04 V@28@04)
    (<= 0 i1@231@04))))
; Joined path conditions
(pop) ; 14
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i2@232@04 Int)) (!
  (and
    (implies
      (<= 0 i1@231@04)
      (and
        (<= 0 i1@231@04)
        (implies
          (< i1@231@04 V@28@04)
          (and
            (< i1@231@04 V@28@04)
            (implies
              (<= 0 i2@232@04)
              (and
                (<= 0 i2@232@04)
                (implies
                  (< i2@232@04 V@28@04)
                  (and
                    (< i2@232@04 V@28@04)
                    (< i1@231@04 (alen<Int> (opt_get1 $Snap.unit source@26@04)))
                    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@231@04)) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@231@04))
                    (< i2@232@04 (alen<Int> (opt_get1 $Snap.unit source@26@04)))
                    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@232@04)) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@232@04))))))))))
    (implies
      (and
        (and
          (and
            (and
              (=
                ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@231@04))
                ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@232@04)))
              (< i2@232@04 V@28@04))
            (<= 0 i2@232@04))
          (< i1@231@04 V@28@04))
        (<= 0 i1@231@04))
      (and
        (=
          ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@231@04))
          ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@232@04)))
        (< i2@232@04 V@28@04)
        (<= 0 i2@232@04)
        (< i1@231@04 V@28@04)
        (<= 0 i1@231@04))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@232@04))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 13
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@231@04 Int)) (!
  (forall ((i2@232@04 Int)) (!
    (and
      (implies
        (<= 0 i1@231@04)
        (and
          (<= 0 i1@231@04)
          (implies
            (< i1@231@04 V@28@04)
            (and
              (< i1@231@04 V@28@04)
              (implies
                (<= 0 i2@232@04)
                (and
                  (<= 0 i2@232@04)
                  (implies
                    (< i2@232@04 V@28@04)
                    (and
                      (< i2@232@04 V@28@04)
                      (<
                        i1@231@04
                        (alen<Int> (opt_get1 $Snap.unit source@26@04)))
                      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@231@04)) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@231@04))
                      (<
                        i2@232@04
                        (alen<Int> (opt_get1 $Snap.unit source@26@04)))
                      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@232@04)) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@232@04))))))))))
      (implies
        (and
          (and
            (and
              (and
                (=
                  ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@231@04))
                  ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@232@04)))
                (< i2@232@04 V@28@04))
              (<= 0 i2@232@04))
            (< i1@231@04 V@28@04))
          (<= 0 i1@231@04))
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@231@04))
            ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@232@04)))
          (< i2@232@04 V@28@04)
          (<= 0 i2@232@04)
          (< i1@231@04 V@28@04)
          (<= 0 i1@231@04))))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@232@04))
    :qid |prog.l<no position>-aux|))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@231@04))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 12
(pop) ; 11
; Joined path conditions
(assert (implies
  (= exc@208@04 $Ref.null)
  (forall ((i1@231@04 Int)) (!
    (forall ((i2@232@04 Int)) (!
      (and
        (implies
          (<= 0 i1@231@04)
          (and
            (<= 0 i1@231@04)
            (implies
              (< i1@231@04 V@28@04)
              (and
                (< i1@231@04 V@28@04)
                (implies
                  (<= 0 i2@232@04)
                  (and
                    (<= 0 i2@232@04)
                    (implies
                      (< i2@232@04 V@28@04)
                      (and
                        (< i2@232@04 V@28@04)
                        (<
                          i1@231@04
                          (alen<Int> (opt_get1 $Snap.unit source@26@04)))
                        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
                          $Snap.unit
                          $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@231@04)) (aloc ($Snap.combine
                          $Snap.unit
                          $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@231@04))
                        (<
                          i2@232@04
                          (alen<Int> (opt_get1 $Snap.unit source@26@04)))
                        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
                          $Snap.unit
                          $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@232@04)) (aloc ($Snap.combine
                          $Snap.unit
                          $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@232@04))))))))))
        (implies
          (and
            (and
              (and
                (and
                  (=
                    ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@231@04))
                    ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@232@04)))
                  (< i2@232@04 V@28@04))
                (<= 0 i2@232@04))
              (< i1@231@04 V@28@04))
            (<= 0 i1@231@04))
          (and
            (=
              ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@231@04))
              ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@232@04)))
            (< i2@232@04 V@28@04)
            (<= 0 i2@232@04)
            (< i1@231@04 V@28@04)
            (<= 0 i1@231@04))))
      :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@232@04))
      :qid |prog.l<no position>-aux|))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@231@04))
    :qid |prog.l<no position>-aux|))))
(push) ; 11
(assert (not (implies
  (= exc@208@04 $Ref.null)
  (forall ((i1@231@04 Int)) (!
    (forall ((i2@232@04 Int)) (!
      (implies
        (and
          (and
            (and
              (and
                (=
                  ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@231@04))
                  ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@232@04)))
                (< i2@232@04 V@28@04))
              (<= 0 i2@232@04))
            (< i1@231@04 V@28@04))
          (<= 0 i1@231@04))
        (= i1@231@04 i2@232@04))
      :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@232@04))
      :qid |prog.l<no position>|))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@231@04))
    :qid |prog.l<no position>|)))))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               129431
;  :arith-add-rows          89335
;  :arith-assert-diseq      7742
;  :arith-assert-lower      41798
;  :arith-assert-upper      27731
;  :arith-bound-prop        6258
;  :arith-conflicts         1192
;  :arith-eq-adapter        22279
;  :arith-fixed-eqs         15327
;  :arith-gcd-tests         3
;  :arith-grobner           294
;  :arith-ineq-splits       2
;  :arith-max-min           1922
;  :arith-nonlinear-bounds  233
;  :arith-nonlinear-horner  353
;  :arith-offset-eqs        18910
;  :arith-patches           4
;  :arith-patches_succ      1
;  :arith-pivots            12359
;  :arith-pseudo-nonlinear  60
;  :conflicts               2741
;  :datatype-accessor-ax    416
;  :datatype-constructor-ax 1811
;  :datatype-occurs-check   1066
;  :datatype-splits         1119
;  :decisions               19776
;  :del-clause              131571
;  :final-checks            537
;  :interface-eqs           91
;  :max-generation          14
;  :max-memory              18.34
;  :memory                  17.02
;  :minimized-lits          689
;  :mk-bool-var             163159
;  :mk-clause               131571
;  :num-allocs              975573
;  :num-checks              423
;  :propagations            97447
;  :quant-instantiations    37833
;  :restarts                4
;  :rlimit-count            5523866)
(assert (implies
  (= exc@208@04 $Ref.null)
  (forall ((i1@231@04 Int)) (!
    (forall ((i2@232@04 Int)) (!
      (implies
        (and
          (and
            (and
              (and
                (=
                  ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@231@04))
                  ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@232@04)))
                (< i2@232@04 V@28@04))
              (<= 0 i2@232@04))
            (< i1@231@04 V@28@04))
          (<= 0 i1@231@04))
        (= i1@231@04 i2@232@04))
      :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i2@232@04))
      :qid |prog.l<no position>|))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@231@04))
    :qid |prog.l<no position>|))))
; [eval] exc == null ==> target != (None(): option[array])
; [eval] exc == null
(push) ; 11
(set-option :timeout 10)
(push) ; 12
(assert (not (not (= exc@208@04 $Ref.null))))
(check-sat)
; unknown
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               129462
;  :arith-add-rows          89335
;  :arith-assert-diseq      7742
;  :arith-assert-lower      41798
;  :arith-assert-upper      27731
;  :arith-bound-prop        6258
;  :arith-conflicts         1192
;  :arith-eq-adapter        22279
;  :arith-fixed-eqs         15327
;  :arith-gcd-tests         3
;  :arith-grobner           294
;  :arith-ineq-splits       2
;  :arith-max-min           1922
;  :arith-nonlinear-bounds  233
;  :arith-nonlinear-horner  353
;  :arith-offset-eqs        18910
;  :arith-patches           4
;  :arith-patches_succ      1
;  :arith-pivots            12359
;  :arith-pseudo-nonlinear  60
;  :conflicts               2741
;  :datatype-accessor-ax    416
;  :datatype-constructor-ax 1817
;  :datatype-occurs-check   1071
;  :datatype-splits         1121
;  :decisions               19782
;  :del-clause              131571
;  :final-checks            539
;  :interface-eqs           91
;  :max-generation          14
;  :max-memory              18.34
;  :memory                  17.03
;  :minimized-lits          689
;  :mk-bool-var             163162
;  :mk-clause               131571
;  :num-allocs              976504
;  :num-checks              424
;  :propagations            97447
;  :quant-instantiations    37833
;  :restarts                4
;  :rlimit-count            5525103)
; [then-branch: 295 | exc@208@04 == Null | live]
; [else-branch: 295 | exc@208@04 != Null | dead]
(push) ; 12
; [then-branch: 295 | exc@208@04 == Null]
; [eval] target != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 12
(pop) ; 11
; Joined path conditions
(set-option :timeout 0)
(push) ; 11
(assert (not (implies
  (= exc@208@04 $Ref.null)
  (not (= target@27@04 (as None<option<array>>  option<array>))))))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               129462
;  :arith-add-rows          89335
;  :arith-assert-diseq      7742
;  :arith-assert-lower      41798
;  :arith-assert-upper      27731
;  :arith-bound-prop        6258
;  :arith-conflicts         1192
;  :arith-eq-adapter        22279
;  :arith-fixed-eqs         15327
;  :arith-gcd-tests         3
;  :arith-grobner           294
;  :arith-ineq-splits       2
;  :arith-max-min           1922
;  :arith-nonlinear-bounds  233
;  :arith-nonlinear-horner  353
;  :arith-offset-eqs        18910
;  :arith-patches           4
;  :arith-patches_succ      1
;  :arith-pivots            12359
;  :arith-pseudo-nonlinear  60
;  :conflicts               2741
;  :datatype-accessor-ax    416
;  :datatype-constructor-ax 1817
;  :datatype-occurs-check   1071
;  :datatype-splits         1121
;  :decisions               19782
;  :del-clause              131571
;  :final-checks            539
;  :interface-eqs           91
;  :max-generation          14
;  :max-memory              18.34
;  :memory                  17.03
;  :minimized-lits          689
;  :mk-bool-var             163162
;  :mk-clause               131571
;  :num-allocs              976529
;  :num-checks              425
;  :propagations            97447
;  :quant-instantiations    37833
;  :restarts                4
;  :rlimit-count            5525123)
(assert (implies
  (= exc@208@04 $Ref.null)
  (not (= target@27@04 (as None<option<array>>  option<array>)))))
; [eval] exc == null ==> alen(opt_get1(target)) == V
; [eval] exc == null
(push) ; 11
(set-option :timeout 10)
(push) ; 12
(assert (not (not (= exc@208@04 $Ref.null))))
(check-sat)
; unknown
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               129493
;  :arith-add-rows          89335
;  :arith-assert-diseq      7742
;  :arith-assert-lower      41798
;  :arith-assert-upper      27731
;  :arith-bound-prop        6258
;  :arith-conflicts         1192
;  :arith-eq-adapter        22279
;  :arith-fixed-eqs         15327
;  :arith-gcd-tests         3
;  :arith-grobner           294
;  :arith-ineq-splits       2
;  :arith-max-min           1922
;  :arith-nonlinear-bounds  233
;  :arith-nonlinear-horner  353
;  :arith-offset-eqs        18910
;  :arith-patches           4
;  :arith-patches_succ      1
;  :arith-pivots            12359
;  :arith-pseudo-nonlinear  60
;  :conflicts               2741
;  :datatype-accessor-ax    416
;  :datatype-constructor-ax 1823
;  :datatype-occurs-check   1076
;  :datatype-splits         1123
;  :decisions               19788
;  :del-clause              131571
;  :final-checks            541
;  :interface-eqs           91
;  :max-generation          14
;  :max-memory              18.34
;  :memory                  17.03
;  :minimized-lits          689
;  :mk-bool-var             163164
;  :mk-clause               131571
;  :num-allocs              977126
;  :num-checks              426
;  :propagations            97447
;  :quant-instantiations    37833
;  :restarts                4
;  :rlimit-count            5525832)
; [then-branch: 296 | exc@208@04 == Null | live]
; [else-branch: 296 | exc@208@04 != Null | dead]
(push) ; 12
; [then-branch: 296 | exc@208@04 == Null]
; [eval] alen(opt_get1(target)) == V
; [eval] alen(opt_get1(target))
; [eval] opt_get1(target)
(push) ; 13
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 13
; Joined path conditions
(pop) ; 12
(pop) ; 11
; Joined path conditions
(set-option :timeout 0)
(push) ; 11
(assert (not (implies
  (= exc@208@04 $Ref.null)
  (= (alen<Int> (opt_get1 $Snap.unit target@27@04)) V@28@04))))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               129493
;  :arith-add-rows          89335
;  :arith-assert-diseq      7742
;  :arith-assert-lower      41798
;  :arith-assert-upper      27731
;  :arith-bound-prop        6258
;  :arith-conflicts         1192
;  :arith-eq-adapter        22279
;  :arith-fixed-eqs         15327
;  :arith-gcd-tests         3
;  :arith-grobner           294
;  :arith-ineq-splits       2
;  :arith-max-min           1922
;  :arith-nonlinear-bounds  233
;  :arith-nonlinear-horner  353
;  :arith-offset-eqs        18910
;  :arith-patches           4
;  :arith-patches_succ      1
;  :arith-pivots            12359
;  :arith-pseudo-nonlinear  60
;  :conflicts               2741
;  :datatype-accessor-ax    416
;  :datatype-constructor-ax 1823
;  :datatype-occurs-check   1076
;  :datatype-splits         1123
;  :decisions               19788
;  :del-clause              131571
;  :final-checks            541
;  :interface-eqs           91
;  :max-generation          14
;  :max-memory              18.34
;  :memory                  17.03
;  :minimized-lits          689
;  :mk-bool-var             163164
;  :mk-clause               131571
;  :num-allocs              977145
;  :num-checks              427
;  :propagations            97447
;  :quant-instantiations    37833
;  :restarts                4
;  :rlimit-count            5525857)
(assert (implies
  (= exc@208@04 $Ref.null)
  (= (alen<Int> (opt_get1 $Snap.unit target@27@04)) V@28@04)))
; [eval] exc == null
(set-option :timeout 10)
(push) ; 11
(assert (not (not (= exc@208@04 $Ref.null))))
(check-sat)
; unknown
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               129524
;  :arith-add-rows          89335
;  :arith-assert-diseq      7742
;  :arith-assert-lower      41798
;  :arith-assert-upper      27731
;  :arith-bound-prop        6258
;  :arith-conflicts         1192
;  :arith-eq-adapter        22279
;  :arith-fixed-eqs         15327
;  :arith-gcd-tests         3
;  :arith-grobner           294
;  :arith-ineq-splits       2
;  :arith-max-min           1922
;  :arith-nonlinear-bounds  233
;  :arith-nonlinear-horner  353
;  :arith-offset-eqs        18910
;  :arith-patches           4
;  :arith-patches_succ      1
;  :arith-pivots            12359
;  :arith-pseudo-nonlinear  60
;  :conflicts               2741
;  :datatype-accessor-ax    416
;  :datatype-constructor-ax 1829
;  :datatype-occurs-check   1081
;  :datatype-splits         1125
;  :decisions               19794
;  :del-clause              131571
;  :final-checks            543
;  :interface-eqs           91
;  :max-generation          14
;  :max-memory              18.34
;  :memory                  17.03
;  :minimized-lits          689
;  :mk-bool-var             163166
;  :mk-clause               131571
;  :num-allocs              977742
;  :num-checks              428
;  :propagations            97447
;  :quant-instantiations    37833
;  :restarts                4
;  :rlimit-count            5526561)
; [then-branch: 297 | exc@208@04 == Null | live]
; [else-branch: 297 | exc@208@04 != Null | dead]
(push) ; 11
; [then-branch: 297 | exc@208@04 == Null]
(declare-const i1@233@04 Int)
(push) ; 12
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 13
; [then-branch: 298 | 0 <= i1@233@04 | live]
; [else-branch: 298 | !(0 <= i1@233@04) | live]
(push) ; 14
; [then-branch: 298 | 0 <= i1@233@04]
(assert (<= 0 i1@233@04))
; [eval] i1 < V
(pop) ; 14
(push) ; 14
; [else-branch: 298 | !(0 <= i1@233@04)]
(assert (not (<= 0 i1@233@04)))
(pop) ; 14
(pop) ; 13
; Joined path conditions
; Joined path conditions
(assert (and (< i1@233@04 V@28@04) (<= 0 i1@233@04)))
(declare-const $k@234@04 $Perm)
(assert ($Perm.isReadVar $k@234@04 $Perm.Write))
; [eval] aloc(opt_get1(target), i1)
; [eval] opt_get1(target)
(push) ; 13
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 13
; Joined path conditions
(push) ; 13
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 14
(assert (not (< i1@233@04 (alen<Int> (opt_get1 $Snap.unit target@27@04)))))
(check-sat)
; unsat
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               129524
;  :arith-add-rows          89335
;  :arith-assert-diseq      7743
;  :arith-assert-lower      41802
;  :arith-assert-upper      27732
;  :arith-bound-prop        6258
;  :arith-conflicts         1193
;  :arith-eq-adapter        22280
;  :arith-fixed-eqs         15327
;  :arith-gcd-tests         3
;  :arith-grobner           294
;  :arith-ineq-splits       2
;  :arith-max-min           1922
;  :arith-nonlinear-bounds  233
;  :arith-nonlinear-horner  353
;  :arith-offset-eqs        18910
;  :arith-patches           4
;  :arith-patches_succ      1
;  :arith-pivots            12360
;  :arith-pseudo-nonlinear  60
;  :conflicts               2742
;  :datatype-accessor-ax    416
;  :datatype-constructor-ax 1829
;  :datatype-occurs-check   1081
;  :datatype-splits         1125
;  :decisions               19794
;  :del-clause              131571
;  :final-checks            543
;  :interface-eqs           91
;  :max-generation          14
;  :max-memory              18.34
;  :memory                  17.03
;  :minimized-lits          689
;  :mk-bool-var             163172
;  :mk-clause               131573
;  :num-allocs              977908
;  :num-checks              429
;  :propagations            97448
;  :quant-instantiations    37833
;  :restarts                4
;  :rlimit-count            5526883)
(assert (< i1@233@04 (alen<Int> (opt_get1 $Snap.unit target@27@04))))
(pop) ; 13
; Joined path conditions
(assert (< i1@233@04 (alen<Int> (opt_get1 $Snap.unit target@27@04))))
(pop) ; 12
(declare-fun inv@235@04 ($Ref) Int)
; Nested auxiliary terms: globals
(assert ($Perm.isReadVar $k@234@04 $Perm.Write))
; Nested auxiliary terms: non-globals
(assert (forall ((i1@233@04 Int)) (!
  (< i1@233@04 (alen<Int> (opt_get1 $Snap.unit target@27@04)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@233@04))
  :qid |option$array$-aux|)))
(push) ; 12
(assert (not (forall ((i1@233@04 Int)) (!
  (implies
    (and (< i1@233@04 V@28@04) (<= 0 i1@233@04))
    (or (= $k@234@04 $Perm.No) (< $Perm.No $k@234@04)))
  
  ))))
(check-sat)
; unsat
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               129524
;  :arith-add-rows          89335
;  :arith-assert-diseq      7744
;  :arith-assert-lower      41804
;  :arith-assert-upper      27733
;  :arith-bound-prop        6258
;  :arith-conflicts         1193
;  :arith-eq-adapter        22281
;  :arith-fixed-eqs         15327
;  :arith-gcd-tests         3
;  :arith-grobner           294
;  :arith-ineq-splits       2
;  :arith-max-min           1922
;  :arith-nonlinear-bounds  233
;  :arith-nonlinear-horner  353
;  :arith-offset-eqs        18910
;  :arith-patches           4
;  :arith-patches_succ      1
;  :arith-pivots            12361
;  :arith-pseudo-nonlinear  60
;  :conflicts               2743
;  :datatype-accessor-ax    416
;  :datatype-constructor-ax 1829
;  :datatype-occurs-check   1081
;  :datatype-splits         1125
;  :decisions               19794
;  :del-clause              131573
;  :final-checks            543
;  :interface-eqs           91
;  :max-generation          14
;  :max-memory              18.34
;  :memory                  17.03
;  :minimized-lits          689
;  :mk-bool-var             163179
;  :mk-clause               131575
;  :num-allocs              978331
;  :num-checks              430
;  :propagations            97449
;  :quant-instantiations    37833
;  :restarts                4
;  :rlimit-count            5527432)
(declare-const sm@236@04 $FVF<option<array>>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@34@04 r) V@28@04) (<= 0 (inv@34@04 r)))
      (< $Perm.No $k@33@04)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@236@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@31@04))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@236@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@31@04))))) r))
  :qid |qp.fvfValDef71|)))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (ite
          (and (< (inv@42@04 r) V@28@04) (<= 0 (inv@42@04 r)))
          $k@41@04
          $Perm.No)
        (pTaken@227@04 r)))
    (=
      ($FVF.lookup_option$array$ (as sm@236@04  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@31@04))))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@236@04  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@31@04))))))))))) r))
  :qid |qp.fvfValDef72|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@31@04))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@31@04))))))))))) r) r))
  :pattern (($FVF.lookup_option$array$ (as sm@236@04  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef73|)))
; Check receiver injectivity
(push) ; 12
(assert (not (forall ((i11@233@04 Int) (i12@233@04 Int)) (!
  (implies
    (and
      (and
        (and
          (and (< i11@233@04 V@28@04) (<= 0 i11@233@04))
          ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@236@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@27@04) i11@233@04)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@27@04) i11@233@04)))
        (< $Perm.No $k@234@04))
      (and
        (and
          (and (< i12@233@04 V@28@04) (<= 0 i12@233@04))
          ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@236@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@27@04) i12@233@04)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@27@04) i12@233@04)))
        (< $Perm.No $k@234@04))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i11@233@04)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i12@233@04)))
    (= i11@233@04 i12@233@04))
  
  :qid |option$array$-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               129527
;  :arith-add-rows          89335
;  :arith-assert-diseq      7745
;  :arith-assert-lower      41808
;  :arith-assert-upper      27733
;  :arith-bound-prop        6258
;  :arith-conflicts         1194
;  :arith-eq-adapter        22282
;  :arith-fixed-eqs         15327
;  :arith-gcd-tests         3
;  :arith-grobner           294
;  :arith-ineq-splits       2
;  :arith-max-min           1922
;  :arith-nonlinear-bounds  233
;  :arith-nonlinear-horner  353
;  :arith-offset-eqs        18910
;  :arith-patches           4
;  :arith-patches_succ      1
;  :arith-pivots            12361
;  :arith-pseudo-nonlinear  60
;  :conflicts               2744
;  :datatype-accessor-ax    416
;  :datatype-constructor-ax 1829
;  :datatype-occurs-check   1081
;  :datatype-splits         1125
;  :decisions               19794
;  :del-clause              131577
;  :final-checks            543
;  :interface-eqs           91
;  :max-generation          14
;  :max-memory              18.34
;  :memory                  17.03
;  :minimized-lits          689
;  :mk-bool-var             163192
;  :mk-clause               131579
;  :num-allocs              979202
;  :num-checks              431
;  :propagations            97449
;  :quant-instantiations    37833
;  :restarts                4
;  :rlimit-count            5529581)
; Definitional axioms for inverse functions
(assert (forall ((i1@233@04 Int)) (!
  (implies
    (and (and (< i1@233@04 V@28@04) (<= 0 i1@233@04)) (< $Perm.No $k@234@04))
    (=
      (inv@235@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@233@04))
      i1@233@04))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@233@04))
  :qid |option$array$-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and (< (inv@235@04 r) V@28@04) (<= 0 (inv@235@04 r)))
      (< $Perm.No $k@234@04))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) (inv@235@04 r))
      r))
  :pattern ((inv@235@04 r))
  :qid |option$array$-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@235@04 r) V@28@04) (<= 0 (inv@235@04 r)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@236@04  $FVF<option<array>>) r) r))
  :pattern ((inv@235@04 r))
  )))
; Precomputing data for removing quantified permissions
(define-fun pTaken@237@04 ((r $Ref)) $Perm
  (ite
    (and (< (inv@235@04 r) V@28@04) (<= 0 (inv@235@04 r)))
    ($Perm.min
      (ite
        (and (< (inv@34@04 r) V@28@04) (<= 0 (inv@34@04 r)))
        $k@33@04
        $Perm.No)
      $k@234@04)
    $Perm.No))
(define-fun pTaken@238@04 ((r $Ref)) $Perm
  (ite
    (and (< (inv@235@04 r) V@28@04) (<= 0 (inv@235@04 r)))
    ($Perm.min
      (-
        (ite
          (and (< (inv@42@04 r) V@28@04) (<= 0 (inv@42@04 r)))
          $k@41@04
          $Perm.No)
        (pTaken@227@04 r))
      (- $k@234@04 (pTaken@237@04 r)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Constrain original permissions $k@234@04
(assert (forall ((r $Ref)) (!
  (implies
    (not
      (=
        (ite
          (and (< (inv@34@04 r) V@28@04) (<= 0 (inv@34@04 r)))
          $k@33@04
          $Perm.No)
        $Perm.No))
    (ite
      (and (< (inv@34@04 r) V@28@04) (<= 0 (inv@34@04 r)))
      (<
        (ite
          (and (< (inv@235@04 r) V@28@04) (<= 0 (inv@235@04 r)))
          $k@234@04
          $Perm.No)
        $k@33@04)
      (<
        (ite
          (and (< (inv@235@04 r) V@28@04) (<= 0 (inv@235@04 r)))
          $k@234@04
          $Perm.No)
        $Perm.No)))
  :pattern ((inv@34@04 r))
  :pattern ((inv@235@04 r))
  :qid |qp.srp74|)))
; Intermediate check if already taken enough permissions
(set-option :timeout 500)
(push) ; 12
(assert (not (forall ((r $Ref)) (!
  (implies
    (and (< (inv@235@04 r) V@28@04) (<= 0 (inv@235@04 r)))
    (= (- $k@234@04 (pTaken@237@04 r)) $Perm.No))
  
  ))))
(check-sat)
; unsat
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               129559
;  :arith-add-rows          89335
;  :arith-assert-diseq      7746
;  :arith-assert-lower      41810
;  :arith-assert-upper      27733
;  :arith-bound-prop        6258
;  :arith-conflicts         1195
;  :arith-eq-adapter        22283
;  :arith-fixed-eqs         15327
;  :arith-gcd-tests         3
;  :arith-grobner           294
;  :arith-ineq-splits       2
;  :arith-max-min           1922
;  :arith-nonlinear-bounds  233
;  :arith-nonlinear-horner  353
;  :arith-offset-eqs        18910
;  :arith-patches           4
;  :arith-patches_succ      1
;  :arith-pivots            12361
;  :arith-pseudo-nonlinear  60
;  :conflicts               2745
;  :datatype-accessor-ax    416
;  :datatype-constructor-ax 1835
;  :datatype-occurs-check   1086
;  :datatype-splits         1127
;  :decisions               19800
;  :del-clause              131590
;  :final-checks            545
;  :interface-eqs           91
;  :max-generation          14
;  :max-memory              18.34
;  :memory                  17.03
;  :minimized-lits          689
;  :mk-bool-var             163214
;  :mk-clause               131590
;  :num-allocs              980923
;  :num-checks              433
;  :propagations            97449
;  :quant-instantiations    37833
;  :restarts                4
;  :rlimit-count            5532259)
; Final check if taken enough permissions
; Done removing quantified permissions
; Definitional axioms for snapshot map values
; [eval] exc == null ==> (forall i1: Int :: { aloc(opt_get1(target), i1) } 0 <= i1 && i1 < V ==> aloc(opt_get1(target), i1).option$array$ != (None(): option[array]))
; [eval] exc == null
(push) ; 12
(set-option :timeout 10)
(push) ; 13
(assert (not (not (= exc@208@04 $Ref.null))))
(check-sat)
; unknown
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               129590
;  :arith-add-rows          89335
;  :arith-assert-diseq      7746
;  :arith-assert-lower      41810
;  :arith-assert-upper      27733
;  :arith-bound-prop        6258
;  :arith-conflicts         1195
;  :arith-eq-adapter        22283
;  :arith-fixed-eqs         15327
;  :arith-gcd-tests         3
;  :arith-grobner           294
;  :arith-ineq-splits       2
;  :arith-max-min           1922
;  :arith-nonlinear-bounds  233
;  :arith-nonlinear-horner  353
;  :arith-offset-eqs        18910
;  :arith-patches           4
;  :arith-patches_succ      1
;  :arith-pivots            12361
;  :arith-pseudo-nonlinear  60
;  :conflicts               2745
;  :datatype-accessor-ax    416
;  :datatype-constructor-ax 1841
;  :datatype-occurs-check   1091
;  :datatype-splits         1129
;  :decisions               19806
;  :del-clause              131590
;  :final-checks            547
;  :interface-eqs           91
;  :max-generation          14
;  :max-memory              18.34
;  :memory                  17.03
;  :minimized-lits          689
;  :mk-bool-var             163216
;  :mk-clause               131590
;  :num-allocs              981531
;  :num-checks              434
;  :propagations            97449
;  :quant-instantiations    37833
;  :restarts                4
;  :rlimit-count            5532974)
; [then-branch: 299 | exc@208@04 == Null | live]
; [else-branch: 299 | exc@208@04 != Null | dead]
(push) ; 13
; [then-branch: 299 | exc@208@04 == Null]
; [eval] (forall i1: Int :: { aloc(opt_get1(target), i1) } 0 <= i1 && i1 < V ==> aloc(opt_get1(target), i1).option$array$ != (None(): option[array]))
(declare-const i1@239@04 Int)
(push) ; 14
; [eval] 0 <= i1 && i1 < V ==> aloc(opt_get1(target), i1).option$array$ != (None(): option[array])
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 15
; [then-branch: 300 | 0 <= i1@239@04 | live]
; [else-branch: 300 | !(0 <= i1@239@04) | live]
(push) ; 16
; [then-branch: 300 | 0 <= i1@239@04]
(assert (<= 0 i1@239@04))
; [eval] i1 < V
(pop) ; 16
(push) ; 16
; [else-branch: 300 | !(0 <= i1@239@04)]
(assert (not (<= 0 i1@239@04)))
(pop) ; 16
(pop) ; 15
; Joined path conditions
; Joined path conditions
(push) ; 15
; [then-branch: 301 | i1@239@04 < V@28@04 && 0 <= i1@239@04 | live]
; [else-branch: 301 | !(i1@239@04 < V@28@04 && 0 <= i1@239@04) | live]
(push) ; 16
; [then-branch: 301 | i1@239@04 < V@28@04 && 0 <= i1@239@04]
(assert (and (< i1@239@04 V@28@04) (<= 0 i1@239@04)))
; [eval] aloc(opt_get1(target), i1).option$array$ != (None(): option[array])
; [eval] aloc(opt_get1(target), i1)
; [eval] opt_get1(target)
(push) ; 17
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 17
; Joined path conditions
(push) ; 17
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 18
(assert (not (< i1@239@04 (alen<Int> (opt_get1 $Snap.unit target@27@04)))))
(check-sat)
; unsat
(pop) ; 18
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               129590
;  :arith-add-rows          89335
;  :arith-assert-diseq      7746
;  :arith-assert-lower      41812
;  :arith-assert-upper      27733
;  :arith-bound-prop        6258
;  :arith-conflicts         1196
;  :arith-eq-adapter        22283
;  :arith-fixed-eqs         15327
;  :arith-gcd-tests         3
;  :arith-grobner           294
;  :arith-ineq-splits       2
;  :arith-max-min           1922
;  :arith-nonlinear-bounds  233
;  :arith-nonlinear-horner  353
;  :arith-offset-eqs        18910
;  :arith-patches           4
;  :arith-patches_succ      1
;  :arith-pivots            12361
;  :arith-pseudo-nonlinear  60
;  :conflicts               2746
;  :datatype-accessor-ax    416
;  :datatype-constructor-ax 1841
;  :datatype-occurs-check   1091
;  :datatype-splits         1129
;  :decisions               19806
;  :del-clause              131590
;  :final-checks            547
;  :interface-eqs           91
;  :max-generation          14
;  :max-memory              18.34
;  :memory                  17.03
;  :minimized-lits          689
;  :mk-bool-var             163218
;  :mk-clause               131590
;  :num-allocs              981635
;  :num-checks              435
;  :propagations            97449
;  :quant-instantiations    37833
;  :restarts                4
;  :rlimit-count            5533160)
(assert (< i1@239@04 (alen<Int> (opt_get1 $Snap.unit target@27@04))))
(pop) ; 17
; Joined path conditions
(assert (< i1@239@04 (alen<Int> (opt_get1 $Snap.unit target@27@04))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@239@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@239@04)))
(push) ; 17
(assert (not (<
  $Perm.No
  (+
    (ite
      (and
        (<
          (inv@42@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@239@04))
          V@28@04)
        (<=
          0
          (inv@42@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@239@04))))
      $k@41@04
      $Perm.No)
    (ite
      (and
        (<
          (inv@34@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@239@04))
          V@28@04)
        (<=
          0
          (inv@34@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@239@04))))
      $k@33@04
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               129590
;  :arith-add-rows          89335
;  :arith-assert-diseq      7746
;  :arith-assert-lower      41812
;  :arith-assert-upper      27733
;  :arith-bound-prop        6258
;  :arith-conflicts         1196
;  :arith-eq-adapter        22283
;  :arith-fixed-eqs         15327
;  :arith-gcd-tests         3
;  :arith-grobner           294
;  :arith-ineq-splits       2
;  :arith-max-min           1922
;  :arith-nonlinear-bounds  233
;  :arith-nonlinear-horner  353
;  :arith-offset-eqs        18910
;  :arith-patches           4
;  :arith-patches_succ      1
;  :arith-pivots            12361
;  :arith-pseudo-nonlinear  60
;  :conflicts               2747
;  :datatype-accessor-ax    416
;  :datatype-constructor-ax 1841
;  :datatype-occurs-check   1091
;  :datatype-splits         1129
;  :decisions               19806
;  :del-clause              131600
;  :final-checks            547
;  :interface-eqs           91
;  :max-generation          14
;  :max-memory              18.34
;  :memory                  17.03
;  :minimized-lits          689
;  :mk-bool-var             163230
;  :mk-clause               131600
;  :num-allocs              981847
;  :num-checks              436
;  :propagations            97449
;  :quant-instantiations    37833
;  :restarts                4
;  :rlimit-count            5533643)
; [eval] (None(): option[array])
(pop) ; 16
(push) ; 16
; [else-branch: 301 | !(i1@239@04 < V@28@04 && 0 <= i1@239@04)]
(assert (not (and (< i1@239@04 V@28@04) (<= 0 i1@239@04))))
(pop) ; 16
(pop) ; 15
; Joined path conditions
(assert (implies
  (and (< i1@239@04 V@28@04) (<= 0 i1@239@04))
  (and
    (< i1@239@04 V@28@04)
    (<= 0 i1@239@04)
    (< i1@239@04 (alen<Int> (opt_get1 $Snap.unit target@27@04)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@239@04)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@239@04)))))
; Joined path conditions
(pop) ; 14
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@239@04 Int)) (!
  (implies
    (and (< i1@239@04 V@28@04) (<= 0 i1@239@04))
    (and
      (< i1@239@04 V@28@04)
      (<= 0 i1@239@04)
      (< i1@239@04 (alen<Int> (opt_get1 $Snap.unit target@27@04)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@239@04)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@239@04))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@239@04))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 13
(pop) ; 12
; Joined path conditions
(assert (implies
  (= exc@208@04 $Ref.null)
  (forall ((i1@239@04 Int)) (!
    (implies
      (and (< i1@239@04 V@28@04) (<= 0 i1@239@04))
      (and
        (< i1@239@04 V@28@04)
        (<= 0 i1@239@04)
        (< i1@239@04 (alen<Int> (opt_get1 $Snap.unit target@27@04)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@239@04)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@239@04))))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@239@04))
    :qid |prog.l<no position>-aux|))))
(push) ; 12
(assert (not (implies
  (= exc@208@04 $Ref.null)
  (forall ((i1@239@04 Int)) (!
    (implies
      (and (< i1@239@04 V@28@04) (<= 0 i1@239@04))
      (not
        (=
          ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@239@04))
          (as None<option<array>>  option<array>))))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@239@04))
    :qid |prog.l<no position>|)))))
(check-sat)
; unsat
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               129591
;  :arith-add-rows          89335
;  :arith-assert-diseq      7746
;  :arith-assert-lower      41814
;  :arith-assert-upper      27733
;  :arith-bound-prop        6258
;  :arith-conflicts         1197
;  :arith-eq-adapter        22283
;  :arith-fixed-eqs         15327
;  :arith-gcd-tests         3
;  :arith-grobner           294
;  :arith-ineq-splits       2
;  :arith-max-min           1922
;  :arith-nonlinear-bounds  233
;  :arith-nonlinear-horner  353
;  :arith-offset-eqs        18910
;  :arith-patches           4
;  :arith-patches_succ      1
;  :arith-pivots            12361
;  :arith-pseudo-nonlinear  60
;  :conflicts               2748
;  :datatype-accessor-ax    416
;  :datatype-constructor-ax 1841
;  :datatype-occurs-check   1091
;  :datatype-splits         1129
;  :decisions               19806
;  :del-clause              131600
;  :final-checks            547
;  :interface-eqs           91
;  :max-generation          14
;  :max-memory              18.34
;  :memory                  17.03
;  :minimized-lits          689
;  :mk-bool-var             163234
;  :mk-clause               131600
;  :num-allocs              982290
;  :num-checks              437
;  :propagations            97449
;  :quant-instantiations    37833
;  :restarts                4
;  :rlimit-count            5534345)
(assert (implies
  (= exc@208@04 $Ref.null)
  (forall ((i1@239@04 Int)) (!
    (implies
      (and (< i1@239@04 V@28@04) (<= 0 i1@239@04))
      (not
        (=
          ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@239@04))
          (as None<option<array>>  option<array>))))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@239@04))
    :qid |prog.l<no position>|))))
; [eval] exc == null ==> (forall i1: Int :: { alen(opt_get1(aloc(opt_get1(target), i1).option$array$)) } 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(target), i1).option$array$)) == V)
; [eval] exc == null
(push) ; 12
(set-option :timeout 10)
(push) ; 13
(assert (not (not (= exc@208@04 $Ref.null))))
(check-sat)
; unknown
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               129622
;  :arith-add-rows          89335
;  :arith-assert-diseq      7746
;  :arith-assert-lower      41814
;  :arith-assert-upper      27733
;  :arith-bound-prop        6258
;  :arith-conflicts         1197
;  :arith-eq-adapter        22283
;  :arith-fixed-eqs         15327
;  :arith-gcd-tests         3
;  :arith-grobner           294
;  :arith-ineq-splits       2
;  :arith-max-min           1922
;  :arith-nonlinear-bounds  233
;  :arith-nonlinear-horner  353
;  :arith-offset-eqs        18910
;  :arith-patches           4
;  :arith-patches_succ      1
;  :arith-pivots            12361
;  :arith-pseudo-nonlinear  60
;  :conflicts               2748
;  :datatype-accessor-ax    416
;  :datatype-constructor-ax 1847
;  :datatype-occurs-check   1096
;  :datatype-splits         1131
;  :decisions               19812
;  :del-clause              131600
;  :final-checks            549
;  :interface-eqs           91
;  :max-generation          14
;  :max-memory              18.34
;  :memory                  17.03
;  :minimized-lits          689
;  :mk-bool-var             163237
;  :mk-clause               131600
;  :num-allocs              983093
;  :num-checks              438
;  :propagations            97449
;  :quant-instantiations    37833
;  :restarts                4
;  :rlimit-count            5535375)
; [then-branch: 302 | exc@208@04 == Null | live]
; [else-branch: 302 | exc@208@04 != Null | dead]
(push) ; 13
; [then-branch: 302 | exc@208@04 == Null]
; [eval] (forall i1: Int :: { alen(opt_get1(aloc(opt_get1(target), i1).option$array$)) } 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(target), i1).option$array$)) == V)
(declare-const i1@240@04 Int)
(push) ; 14
; [eval] 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(target), i1).option$array$)) == V
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 15
; [then-branch: 303 | 0 <= i1@240@04 | live]
; [else-branch: 303 | !(0 <= i1@240@04) | live]
(push) ; 16
; [then-branch: 303 | 0 <= i1@240@04]
(assert (<= 0 i1@240@04))
; [eval] i1 < V
(pop) ; 16
(push) ; 16
; [else-branch: 303 | !(0 <= i1@240@04)]
(assert (not (<= 0 i1@240@04)))
(pop) ; 16
(pop) ; 15
; Joined path conditions
; Joined path conditions
(push) ; 15
; [then-branch: 304 | i1@240@04 < V@28@04 && 0 <= i1@240@04 | live]
; [else-branch: 304 | !(i1@240@04 < V@28@04 && 0 <= i1@240@04) | live]
(push) ; 16
; [then-branch: 304 | i1@240@04 < V@28@04 && 0 <= i1@240@04]
(assert (and (< i1@240@04 V@28@04) (<= 0 i1@240@04)))
; [eval] alen(opt_get1(aloc(opt_get1(target), i1).option$array$)) == V
; [eval] alen(opt_get1(aloc(opt_get1(target), i1).option$array$))
; [eval] opt_get1(aloc(opt_get1(target), i1).option$array$)
; [eval] aloc(opt_get1(target), i1)
; [eval] opt_get1(target)
(push) ; 17
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 17
; Joined path conditions
(push) ; 17
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 18
(assert (not (< i1@240@04 (alen<Int> (opt_get1 $Snap.unit target@27@04)))))
(check-sat)
; unsat
(pop) ; 18
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               129622
;  :arith-add-rows          89335
;  :arith-assert-diseq      7746
;  :arith-assert-lower      41816
;  :arith-assert-upper      27733
;  :arith-bound-prop        6258
;  :arith-conflicts         1198
;  :arith-eq-adapter        22283
;  :arith-fixed-eqs         15327
;  :arith-gcd-tests         3
;  :arith-grobner           294
;  :arith-ineq-splits       2
;  :arith-max-min           1922
;  :arith-nonlinear-bounds  233
;  :arith-nonlinear-horner  353
;  :arith-offset-eqs        18910
;  :arith-patches           4
;  :arith-patches_succ      1
;  :arith-pivots            12361
;  :arith-pseudo-nonlinear  60
;  :conflicts               2749
;  :datatype-accessor-ax    416
;  :datatype-constructor-ax 1847
;  :datatype-occurs-check   1096
;  :datatype-splits         1131
;  :decisions               19812
;  :del-clause              131600
;  :final-checks            549
;  :interface-eqs           91
;  :max-generation          14
;  :max-memory              18.34
;  :memory                  17.03
;  :minimized-lits          689
;  :mk-bool-var             163239
;  :mk-clause               131600
;  :num-allocs              983197
;  :num-checks              439
;  :propagations            97449
;  :quant-instantiations    37833
;  :restarts                4
;  :rlimit-count            5535561)
(assert (< i1@240@04 (alen<Int> (opt_get1 $Snap.unit target@27@04))))
(pop) ; 17
; Joined path conditions
(assert (< i1@240@04 (alen<Int> (opt_get1 $Snap.unit target@27@04))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@240@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@240@04)))
(push) ; 17
(assert (not (<
  $Perm.No
  (+
    (ite
      (and
        (<
          (inv@42@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@240@04))
          V@28@04)
        (<=
          0
          (inv@42@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@240@04))))
      $k@41@04
      $Perm.No)
    (ite
      (and
        (<
          (inv@34@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@240@04))
          V@28@04)
        (<=
          0
          (inv@34@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@240@04))))
      $k@33@04
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               129622
;  :arith-add-rows          89335
;  :arith-assert-diseq      7746
;  :arith-assert-lower      41816
;  :arith-assert-upper      27733
;  :arith-bound-prop        6258
;  :arith-conflicts         1198
;  :arith-eq-adapter        22283
;  :arith-fixed-eqs         15327
;  :arith-gcd-tests         3
;  :arith-grobner           294
;  :arith-ineq-splits       2
;  :arith-max-min           1922
;  :arith-nonlinear-bounds  233
;  :arith-nonlinear-horner  353
;  :arith-offset-eqs        18910
;  :arith-patches           4
;  :arith-patches_succ      1
;  :arith-pivots            12361
;  :arith-pseudo-nonlinear  60
;  :conflicts               2750
;  :datatype-accessor-ax    416
;  :datatype-constructor-ax 1847
;  :datatype-occurs-check   1096
;  :datatype-splits         1131
;  :decisions               19812
;  :del-clause              131610
;  :final-checks            549
;  :interface-eqs           91
;  :max-generation          14
;  :max-memory              18.34
;  :memory                  17.03
;  :minimized-lits          689
;  :mk-bool-var             163251
;  :mk-clause               131610
;  :num-allocs              983410
;  :num-checks              440
;  :propagations            97449
;  :quant-instantiations    37833
;  :restarts                4
;  :rlimit-count            5536044)
(push) ; 17
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 18
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@240@04))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 18
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               129622
;  :arith-add-rows          89335
;  :arith-assert-diseq      7746
;  :arith-assert-lower      41816
;  :arith-assert-upper      27733
;  :arith-bound-prop        6258
;  :arith-conflicts         1198
;  :arith-eq-adapter        22283
;  :arith-fixed-eqs         15327
;  :arith-gcd-tests         3
;  :arith-grobner           294
;  :arith-ineq-splits       2
;  :arith-max-min           1922
;  :arith-nonlinear-bounds  233
;  :arith-nonlinear-horner  353
;  :arith-offset-eqs        18910
;  :arith-patches           4
;  :arith-patches_succ      1
;  :arith-pivots            12361
;  :arith-pseudo-nonlinear  60
;  :conflicts               2751
;  :datatype-accessor-ax    416
;  :datatype-constructor-ax 1847
;  :datatype-occurs-check   1096
;  :datatype-splits         1131
;  :decisions               19812
;  :del-clause              131610
;  :final-checks            549
;  :interface-eqs           91
;  :max-generation          14
;  :max-memory              18.34
;  :memory                  17.03
;  :minimized-lits          689
;  :mk-bool-var             163252
;  :mk-clause               131610
;  :num-allocs              983505
;  :num-checks              441
;  :propagations            97449
;  :quant-instantiations    37833
;  :restarts                4
;  :rlimit-count            5536133)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@240@04))
    (as None<option<array>>  option<array>))))
(pop) ; 17
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@240@04))
    (as None<option<array>>  option<array>))))
(pop) ; 16
(push) ; 16
; [else-branch: 304 | !(i1@240@04 < V@28@04 && 0 <= i1@240@04)]
(assert (not (and (< i1@240@04 V@28@04) (<= 0 i1@240@04))))
(pop) ; 16
(pop) ; 15
; Joined path conditions
(assert (implies
  (and (< i1@240@04 V@28@04) (<= 0 i1@240@04))
  (and
    (< i1@240@04 V@28@04)
    (<= 0 i1@240@04)
    (< i1@240@04 (alen<Int> (opt_get1 $Snap.unit target@27@04)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@240@04)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@240@04))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@240@04))
        (as None<option<array>>  option<array>))))))
; Joined path conditions
(pop) ; 14
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@240@04 Int)) (!
  (implies
    (and (< i1@240@04 V@28@04) (<= 0 i1@240@04))
    (and
      (< i1@240@04 V@28@04)
      (<= 0 i1@240@04)
      (< i1@240@04 (alen<Int> (opt_get1 $Snap.unit target@27@04)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@240@04)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@240@04))
      (not
        (=
          ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@240@04))
          (as None<option<array>>  option<array>)))))
  :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@240@04)))))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 13
(pop) ; 12
; Joined path conditions
(assert (implies
  (= exc@208@04 $Ref.null)
  (forall ((i1@240@04 Int)) (!
    (implies
      (and (< i1@240@04 V@28@04) (<= 0 i1@240@04))
      (and
        (< i1@240@04 V@28@04)
        (<= 0 i1@240@04)
        (< i1@240@04 (alen<Int> (opt_get1 $Snap.unit target@27@04)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@240@04)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@240@04))
        (not
          (=
            ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@240@04))
            (as None<option<array>>  option<array>)))))
    :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@240@04)))))
    :qid |prog.l<no position>-aux|))))
(push) ; 12
(assert (not (implies
  (= exc@208@04 $Ref.null)
  (forall ((i1@240@04 Int)) (!
    (implies
      (and (< i1@240@04 V@28@04) (<= 0 i1@240@04))
      (=
        (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@240@04))))
        V@28@04))
    :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@240@04)))))
    :qid |prog.l<no position>|)))))
(check-sat)
; unsat
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               129622
;  :arith-add-rows          89335
;  :arith-assert-diseq      7746
;  :arith-assert-lower      41818
;  :arith-assert-upper      27733
;  :arith-bound-prop        6258
;  :arith-conflicts         1199
;  :arith-eq-adapter        22283
;  :arith-fixed-eqs         15327
;  :arith-gcd-tests         3
;  :arith-grobner           294
;  :arith-ineq-splits       2
;  :arith-max-min           1922
;  :arith-nonlinear-bounds  233
;  :arith-nonlinear-horner  353
;  :arith-offset-eqs        18910
;  :arith-patches           4
;  :arith-patches_succ      1
;  :arith-pivots            12361
;  :arith-pseudo-nonlinear  60
;  :conflicts               2752
;  :datatype-accessor-ax    416
;  :datatype-constructor-ax 1847
;  :datatype-occurs-check   1096
;  :datatype-splits         1131
;  :decisions               19812
;  :del-clause              131610
;  :final-checks            549
;  :interface-eqs           91
;  :max-generation          14
;  :max-memory              18.34
;  :memory                  17.03
;  :minimized-lits          689
;  :mk-bool-var             163256
;  :mk-clause               131610
;  :num-allocs              983959
;  :num-checks              442
;  :propagations            97449
;  :quant-instantiations    37833
;  :restarts                4
;  :rlimit-count            5536953)
(assert (implies
  (= exc@208@04 $Ref.null)
  (forall ((i1@240@04 Int)) (!
    (implies
      (and (< i1@240@04 V@28@04) (<= 0 i1@240@04))
      (=
        (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@240@04))))
        V@28@04))
    :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@240@04)))))
    :qid |prog.l<no position>|))))
; [eval] exc == null ==> (forall i1: Int :: { aloc(opt_get1(target), i1) } (forall i2: Int :: { aloc(opt_get1(target), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(target), i1).option$array$ == aloc(opt_get1(target), i2).option$array$ ==> i1 == i2))
; [eval] exc == null
(push) ; 12
(set-option :timeout 10)
(push) ; 13
(assert (not (not (= exc@208@04 $Ref.null))))
(check-sat)
; unknown
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               129653
;  :arith-add-rows          89335
;  :arith-assert-diseq      7746
;  :arith-assert-lower      41818
;  :arith-assert-upper      27733
;  :arith-bound-prop        6258
;  :arith-conflicts         1199
;  :arith-eq-adapter        22283
;  :arith-fixed-eqs         15327
;  :arith-gcd-tests         3
;  :arith-grobner           294
;  :arith-ineq-splits       2
;  :arith-max-min           1922
;  :arith-nonlinear-bounds  233
;  :arith-nonlinear-horner  353
;  :arith-offset-eqs        18910
;  :arith-patches           4
;  :arith-patches_succ      1
;  :arith-pivots            12361
;  :arith-pseudo-nonlinear  60
;  :conflicts               2752
;  :datatype-accessor-ax    416
;  :datatype-constructor-ax 1853
;  :datatype-occurs-check   1101
;  :datatype-splits         1133
;  :decisions               19818
;  :del-clause              131610
;  :final-checks            551
;  :interface-eqs           91
;  :max-generation          14
;  :max-memory              18.34
;  :memory                  17.03
;  :minimized-lits          689
;  :mk-bool-var             163259
;  :mk-clause               131610
;  :num-allocs              984762
;  :num-checks              443
;  :propagations            97449
;  :quant-instantiations    37833
;  :restarts                4
;  :rlimit-count            5537985)
; [then-branch: 305 | exc@208@04 == Null | live]
; [else-branch: 305 | exc@208@04 != Null | dead]
(push) ; 13
; [then-branch: 305 | exc@208@04 == Null]
; [eval] (forall i1: Int :: { aloc(opt_get1(target), i1) } (forall i2: Int :: { aloc(opt_get1(target), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(target), i1).option$array$ == aloc(opt_get1(target), i2).option$array$ ==> i1 == i2))
(declare-const i1@241@04 Int)
(push) ; 14
; [eval] (forall i2: Int :: { aloc(opt_get1(target), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(target), i1).option$array$ == aloc(opt_get1(target), i2).option$array$ ==> i1 == i2)
(declare-const i2@242@04 Int)
(push) ; 15
; [eval] 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(target), i1).option$array$ == aloc(opt_get1(target), i2).option$array$ ==> i1 == i2
; [eval] 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(target), i1).option$array$ == aloc(opt_get1(target), i2).option$array$
; [eval] 0 <= i1
(push) ; 16
; [then-branch: 306 | 0 <= i1@241@04 | live]
; [else-branch: 306 | !(0 <= i1@241@04) | live]
(push) ; 17
; [then-branch: 306 | 0 <= i1@241@04]
(assert (<= 0 i1@241@04))
; [eval] i1 < V
(push) ; 18
; [then-branch: 307 | i1@241@04 < V@28@04 | live]
; [else-branch: 307 | !(i1@241@04 < V@28@04) | live]
(push) ; 19
; [then-branch: 307 | i1@241@04 < V@28@04]
(assert (< i1@241@04 V@28@04))
; [eval] 0 <= i2
(push) ; 20
; [then-branch: 308 | 0 <= i2@242@04 | live]
; [else-branch: 308 | !(0 <= i2@242@04) | live]
(push) ; 21
; [then-branch: 308 | 0 <= i2@242@04]
(assert (<= 0 i2@242@04))
; [eval] i2 < V
(push) ; 22
; [then-branch: 309 | i2@242@04 < V@28@04 | live]
; [else-branch: 309 | !(i2@242@04 < V@28@04) | live]
(push) ; 23
; [then-branch: 309 | i2@242@04 < V@28@04]
(assert (< i2@242@04 V@28@04))
; [eval] aloc(opt_get1(target), i1).option$array$ == aloc(opt_get1(target), i2).option$array$
; [eval] aloc(opt_get1(target), i1)
; [eval] opt_get1(target)
(push) ; 24
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 24
; Joined path conditions
(push) ; 24
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 25
(assert (not (< i1@241@04 (alen<Int> (opt_get1 $Snap.unit target@27@04)))))
(check-sat)
; unsat
(pop) ; 25
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               129653
;  :arith-add-rows          89335
;  :arith-assert-diseq      7746
;  :arith-assert-lower      41820
;  :arith-assert-upper      27733
;  :arith-bound-prop        6258
;  :arith-conflicts         1200
;  :arith-eq-adapter        22283
;  :arith-fixed-eqs         15327
;  :arith-gcd-tests         3
;  :arith-grobner           294
;  :arith-ineq-splits       2
;  :arith-max-min           1922
;  :arith-nonlinear-bounds  233
;  :arith-nonlinear-horner  353
;  :arith-offset-eqs        18910
;  :arith-patches           4
;  :arith-patches_succ      1
;  :arith-pivots            12361
;  :arith-pseudo-nonlinear  60
;  :conflicts               2753
;  :datatype-accessor-ax    416
;  :datatype-constructor-ax 1853
;  :datatype-occurs-check   1101
;  :datatype-splits         1133
;  :decisions               19818
;  :del-clause              131610
;  :final-checks            551
;  :interface-eqs           91
;  :max-generation          14
;  :max-memory              18.34
;  :memory                  17.03
;  :minimized-lits          689
;  :mk-bool-var             163263
;  :mk-clause               131610
;  :num-allocs              985037
;  :num-checks              444
;  :propagations            97449
;  :quant-instantiations    37833
;  :restarts                4
;  :rlimit-count            5538298)
(assert (< i1@241@04 (alen<Int> (opt_get1 $Snap.unit target@27@04))))
(pop) ; 24
; Joined path conditions
(assert (< i1@241@04 (alen<Int> (opt_get1 $Snap.unit target@27@04))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@241@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@241@04)))
(push) ; 24
(assert (not (<
  $Perm.No
  (+
    (ite
      (and
        (<
          (inv@42@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@241@04))
          V@28@04)
        (<=
          0
          (inv@42@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@241@04))))
      $k@41@04
      $Perm.No)
    (ite
      (and
        (<
          (inv@34@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@241@04))
          V@28@04)
        (<=
          0
          (inv@34@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@241@04))))
      $k@33@04
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               129653
;  :arith-add-rows          89335
;  :arith-assert-diseq      7746
;  :arith-assert-lower      41820
;  :arith-assert-upper      27733
;  :arith-bound-prop        6258
;  :arith-conflicts         1200
;  :arith-eq-adapter        22283
;  :arith-fixed-eqs         15327
;  :arith-gcd-tests         3
;  :arith-grobner           294
;  :arith-ineq-splits       2
;  :arith-max-min           1922
;  :arith-nonlinear-bounds  233
;  :arith-nonlinear-horner  353
;  :arith-offset-eqs        18910
;  :arith-patches           4
;  :arith-patches_succ      1
;  :arith-pivots            12361
;  :arith-pseudo-nonlinear  60
;  :conflicts               2754
;  :datatype-accessor-ax    416
;  :datatype-constructor-ax 1853
;  :datatype-occurs-check   1101
;  :datatype-splits         1133
;  :decisions               19818
;  :del-clause              131620
;  :final-checks            551
;  :interface-eqs           91
;  :max-generation          14
;  :max-memory              18.34
;  :memory                  17.03
;  :minimized-lits          689
;  :mk-bool-var             163275
;  :mk-clause               131620
;  :num-allocs              985249
;  :num-checks              445
;  :propagations            97449
;  :quant-instantiations    37833
;  :restarts                4
;  :rlimit-count            5538781)
; [eval] aloc(opt_get1(target), i2)
; [eval] opt_get1(target)
(push) ; 24
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 24
; Joined path conditions
(push) ; 24
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 25
(assert (not (< i2@242@04 (alen<Int> (opt_get1 $Snap.unit target@27@04)))))
(check-sat)
; unsat
(pop) ; 25
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               129653
;  :arith-add-rows          89335
;  :arith-assert-diseq      7746
;  :arith-assert-lower      41820
;  :arith-assert-upper      27733
;  :arith-bound-prop        6258
;  :arith-conflicts         1200
;  :arith-eq-adapter        22283
;  :arith-fixed-eqs         15327
;  :arith-gcd-tests         3
;  :arith-grobner           294
;  :arith-ineq-splits       2
;  :arith-max-min           1922
;  :arith-nonlinear-bounds  233
;  :arith-nonlinear-horner  353
;  :arith-offset-eqs        18910
;  :arith-patches           4
;  :arith-patches_succ      1
;  :arith-pivots            12361
;  :arith-pseudo-nonlinear  60
;  :conflicts               2754
;  :datatype-accessor-ax    416
;  :datatype-constructor-ax 1853
;  :datatype-occurs-check   1101
;  :datatype-splits         1133
;  :decisions               19818
;  :del-clause              131620
;  :final-checks            551
;  :interface-eqs           91
;  :max-generation          14
;  :max-memory              18.34
;  :memory                  17.03
;  :minimized-lits          689
;  :mk-bool-var             163275
;  :mk-clause               131620
;  :num-allocs              985276
;  :num-checks              446
;  :propagations            97449
;  :quant-instantiations    37833
;  :restarts                4
;  :rlimit-count            5538802)
(assert (< i2@242@04 (alen<Int> (opt_get1 $Snap.unit target@27@04))))
(pop) ; 24
; Joined path conditions
(assert (< i2@242@04 (alen<Int> (opt_get1 $Snap.unit target@27@04))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@242@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@242@04)))
(push) ; 24
(assert (not (<
  $Perm.No
  (+
    (ite
      (and
        (<
          (inv@42@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@242@04))
          V@28@04)
        (<=
          0
          (inv@42@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@242@04))))
      $k@41@04
      $Perm.No)
    (ite
      (and
        (<
          (inv@34@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@242@04))
          V@28@04)
        (<=
          0
          (inv@34@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@242@04))))
      $k@33@04
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               129653
;  :arith-add-rows          89335
;  :arith-assert-diseq      7746
;  :arith-assert-lower      41820
;  :arith-assert-upper      27733
;  :arith-bound-prop        6258
;  :arith-conflicts         1200
;  :arith-eq-adapter        22283
;  :arith-fixed-eqs         15327
;  :arith-gcd-tests         3
;  :arith-grobner           294
;  :arith-ineq-splits       2
;  :arith-max-min           1922
;  :arith-nonlinear-bounds  233
;  :arith-nonlinear-horner  353
;  :arith-offset-eqs        18910
;  :arith-patches           4
;  :arith-patches_succ      1
;  :arith-pivots            12361
;  :arith-pseudo-nonlinear  60
;  :conflicts               2755
;  :datatype-accessor-ax    416
;  :datatype-constructor-ax 1853
;  :datatype-occurs-check   1101
;  :datatype-splits         1133
;  :decisions               19818
;  :del-clause              131630
;  :final-checks            551
;  :interface-eqs           91
;  :max-generation          14
;  :max-memory              18.34
;  :memory                  17.03
;  :minimized-lits          689
;  :mk-bool-var             163287
;  :mk-clause               131630
;  :num-allocs              985488
;  :num-checks              447
;  :propagations            97449
;  :quant-instantiations    37833
;  :restarts                4
;  :rlimit-count            5539285)
(pop) ; 23
(push) ; 23
; [else-branch: 309 | !(i2@242@04 < V@28@04)]
(assert (not (< i2@242@04 V@28@04)))
(pop) ; 23
(pop) ; 22
; Joined path conditions
(assert (implies
  (< i2@242@04 V@28@04)
  (and
    (< i2@242@04 V@28@04)
    (< i1@241@04 (alen<Int> (opt_get1 $Snap.unit target@27@04)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@241@04)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@241@04))
    (< i2@242@04 (alen<Int> (opt_get1 $Snap.unit target@27@04)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@242@04)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@242@04)))))
; Joined path conditions
(pop) ; 21
(push) ; 21
; [else-branch: 308 | !(0 <= i2@242@04)]
(assert (not (<= 0 i2@242@04)))
(pop) ; 21
(pop) ; 20
; Joined path conditions
(assert (implies
  (<= 0 i2@242@04)
  (and
    (<= 0 i2@242@04)
    (implies
      (< i2@242@04 V@28@04)
      (and
        (< i2@242@04 V@28@04)
        (< i1@241@04 (alen<Int> (opt_get1 $Snap.unit target@27@04)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@241@04)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@241@04))
        (< i2@242@04 (alen<Int> (opt_get1 $Snap.unit target@27@04)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@242@04)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@242@04)))))))
; Joined path conditions
(pop) ; 19
(push) ; 19
; [else-branch: 307 | !(i1@241@04 < V@28@04)]
(assert (not (< i1@241@04 V@28@04)))
(pop) ; 19
(pop) ; 18
; Joined path conditions
(assert (implies
  (< i1@241@04 V@28@04)
  (and
    (< i1@241@04 V@28@04)
    (implies
      (<= 0 i2@242@04)
      (and
        (<= 0 i2@242@04)
        (implies
          (< i2@242@04 V@28@04)
          (and
            (< i2@242@04 V@28@04)
            (< i1@241@04 (alen<Int> (opt_get1 $Snap.unit target@27@04)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@241@04)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@241@04))
            (< i2@242@04 (alen<Int> (opt_get1 $Snap.unit target@27@04)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@242@04)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@242@04)))))))))
; Joined path conditions
(pop) ; 17
(push) ; 17
; [else-branch: 306 | !(0 <= i1@241@04)]
(assert (not (<= 0 i1@241@04)))
(pop) ; 17
(pop) ; 16
; Joined path conditions
(assert (implies
  (<= 0 i1@241@04)
  (and
    (<= 0 i1@241@04)
    (implies
      (< i1@241@04 V@28@04)
      (and
        (< i1@241@04 V@28@04)
        (implies
          (<= 0 i2@242@04)
          (and
            (<= 0 i2@242@04)
            (implies
              (< i2@242@04 V@28@04)
              (and
                (< i2@242@04 V@28@04)
                (< i1@241@04 (alen<Int> (opt_get1 $Snap.unit target@27@04)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@241@04)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@241@04))
                (< i2@242@04 (alen<Int> (opt_get1 $Snap.unit target@27@04)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@242@04)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@242@04)))))))))))
; Joined path conditions
(push) ; 16
; [then-branch: 310 | Lookup(option$array$,sm@43@04,aloc((_, _), opt_get1(_, target@27@04), i1@241@04)) == Lookup(option$array$,sm@43@04,aloc((_, _), opt_get1(_, target@27@04), i2@242@04)) && i2@242@04 < V@28@04 && 0 <= i2@242@04 && i1@241@04 < V@28@04 && 0 <= i1@241@04 | live]
; [else-branch: 310 | !(Lookup(option$array$,sm@43@04,aloc((_, _), opt_get1(_, target@27@04), i1@241@04)) == Lookup(option$array$,sm@43@04,aloc((_, _), opt_get1(_, target@27@04), i2@242@04)) && i2@242@04 < V@28@04 && 0 <= i2@242@04 && i1@241@04 < V@28@04 && 0 <= i1@241@04) | live]
(push) ; 17
; [then-branch: 310 | Lookup(option$array$,sm@43@04,aloc((_, _), opt_get1(_, target@27@04), i1@241@04)) == Lookup(option$array$,sm@43@04,aloc((_, _), opt_get1(_, target@27@04), i2@242@04)) && i2@242@04 < V@28@04 && 0 <= i2@242@04 && i1@241@04 < V@28@04 && 0 <= i1@241@04]
(assert (and
  (and
    (and
      (and
        (=
          ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@241@04))
          ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@242@04)))
        (< i2@242@04 V@28@04))
      (<= 0 i2@242@04))
    (< i1@241@04 V@28@04))
  (<= 0 i1@241@04)))
; [eval] i1 == i2
(pop) ; 17
(push) ; 17
; [else-branch: 310 | !(Lookup(option$array$,sm@43@04,aloc((_, _), opt_get1(_, target@27@04), i1@241@04)) == Lookup(option$array$,sm@43@04,aloc((_, _), opt_get1(_, target@27@04), i2@242@04)) && i2@242@04 < V@28@04 && 0 <= i2@242@04 && i1@241@04 < V@28@04 && 0 <= i1@241@04)]
(assert (not
  (and
    (and
      (and
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@241@04))
            ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@242@04)))
          (< i2@242@04 V@28@04))
        (<= 0 i2@242@04))
      (< i1@241@04 V@28@04))
    (<= 0 i1@241@04))))
(pop) ; 17
(pop) ; 16
; Joined path conditions
(assert (implies
  (and
    (and
      (and
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@241@04))
            ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@242@04)))
          (< i2@242@04 V@28@04))
        (<= 0 i2@242@04))
      (< i1@241@04 V@28@04))
    (<= 0 i1@241@04))
  (and
    (=
      ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@241@04))
      ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@242@04)))
    (< i2@242@04 V@28@04)
    (<= 0 i2@242@04)
    (< i1@241@04 V@28@04)
    (<= 0 i1@241@04))))
; Joined path conditions
(pop) ; 15
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i2@242@04 Int)) (!
  (and
    (implies
      (<= 0 i1@241@04)
      (and
        (<= 0 i1@241@04)
        (implies
          (< i1@241@04 V@28@04)
          (and
            (< i1@241@04 V@28@04)
            (implies
              (<= 0 i2@242@04)
              (and
                (<= 0 i2@242@04)
                (implies
                  (< i2@242@04 V@28@04)
                  (and
                    (< i2@242@04 V@28@04)
                    (< i1@241@04 (alen<Int> (opt_get1 $Snap.unit target@27@04)))
                    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@241@04)) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@241@04))
                    (< i2@242@04 (alen<Int> (opt_get1 $Snap.unit target@27@04)))
                    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@242@04)) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@242@04))))))))))
    (implies
      (and
        (and
          (and
            (and
              (=
                ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@241@04))
                ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@242@04)))
              (< i2@242@04 V@28@04))
            (<= 0 i2@242@04))
          (< i1@241@04 V@28@04))
        (<= 0 i1@241@04))
      (and
        (=
          ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@241@04))
          ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@242@04)))
        (< i2@242@04 V@28@04)
        (<= 0 i2@242@04)
        (< i1@241@04 V@28@04)
        (<= 0 i1@241@04))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@242@04))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 14
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@241@04 Int)) (!
  (forall ((i2@242@04 Int)) (!
    (and
      (implies
        (<= 0 i1@241@04)
        (and
          (<= 0 i1@241@04)
          (implies
            (< i1@241@04 V@28@04)
            (and
              (< i1@241@04 V@28@04)
              (implies
                (<= 0 i2@242@04)
                (and
                  (<= 0 i2@242@04)
                  (implies
                    (< i2@242@04 V@28@04)
                    (and
                      (< i2@242@04 V@28@04)
                      (<
                        i1@241@04
                        (alen<Int> (opt_get1 $Snap.unit target@27@04)))
                      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@241@04)) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@241@04))
                      (<
                        i2@242@04
                        (alen<Int> (opt_get1 $Snap.unit target@27@04)))
                      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@242@04)) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@242@04))))))))))
      (implies
        (and
          (and
            (and
              (and
                (=
                  ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@241@04))
                  ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@242@04)))
                (< i2@242@04 V@28@04))
              (<= 0 i2@242@04))
            (< i1@241@04 V@28@04))
          (<= 0 i1@241@04))
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@241@04))
            ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@242@04)))
          (< i2@242@04 V@28@04)
          (<= 0 i2@242@04)
          (< i1@241@04 V@28@04)
          (<= 0 i1@241@04))))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@242@04))
    :qid |prog.l<no position>-aux|))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@241@04))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 13
(pop) ; 12
; Joined path conditions
(assert (implies
  (= exc@208@04 $Ref.null)
  (forall ((i1@241@04 Int)) (!
    (forall ((i2@242@04 Int)) (!
      (and
        (implies
          (<= 0 i1@241@04)
          (and
            (<= 0 i1@241@04)
            (implies
              (< i1@241@04 V@28@04)
              (and
                (< i1@241@04 V@28@04)
                (implies
                  (<= 0 i2@242@04)
                  (and
                    (<= 0 i2@242@04)
                    (implies
                      (< i2@242@04 V@28@04)
                      (and
                        (< i2@242@04 V@28@04)
                        (<
                          i1@241@04
                          (alen<Int> (opt_get1 $Snap.unit target@27@04)))
                        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
                          $Snap.unit
                          $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@241@04)) (aloc ($Snap.combine
                          $Snap.unit
                          $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@241@04))
                        (<
                          i2@242@04
                          (alen<Int> (opt_get1 $Snap.unit target@27@04)))
                        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
                          $Snap.unit
                          $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@242@04)) (aloc ($Snap.combine
                          $Snap.unit
                          $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@242@04))))))))))
        (implies
          (and
            (and
              (and
                (and
                  (=
                    ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@241@04))
                    ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@242@04)))
                  (< i2@242@04 V@28@04))
                (<= 0 i2@242@04))
              (< i1@241@04 V@28@04))
            (<= 0 i1@241@04))
          (and
            (=
              ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@241@04))
              ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@242@04)))
            (< i2@242@04 V@28@04)
            (<= 0 i2@242@04)
            (< i1@241@04 V@28@04)
            (<= 0 i1@241@04))))
      :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@242@04))
      :qid |prog.l<no position>-aux|))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@241@04))
    :qid |prog.l<no position>-aux|))))
(push) ; 12
(assert (not (implies
  (= exc@208@04 $Ref.null)
  (forall ((i1@241@04 Int)) (!
    (forall ((i2@242@04 Int)) (!
      (implies
        (and
          (and
            (and
              (and
                (=
                  ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@241@04))
                  ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@242@04)))
                (< i2@242@04 V@28@04))
              (<= 0 i2@242@04))
            (< i1@241@04 V@28@04))
          (<= 0 i1@241@04))
        (= i1@241@04 i2@242@04))
      :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@242@04))
      :qid |prog.l<no position>|))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@241@04))
    :qid |prog.l<no position>|)))))
(check-sat)
; unsat
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               129655
;  :arith-add-rows          89336
;  :arith-assert-diseq      7747
;  :arith-assert-lower      41824
;  :arith-assert-upper      27733
;  :arith-bound-prop        6258
;  :arith-conflicts         1201
;  :arith-eq-adapter        22284
;  :arith-fixed-eqs         15327
;  :arith-gcd-tests         3
;  :arith-grobner           294
;  :arith-ineq-splits       2
;  :arith-max-min           1922
;  :arith-nonlinear-bounds  233
;  :arith-nonlinear-horner  353
;  :arith-offset-eqs        18910
;  :arith-patches           4
;  :arith-patches_succ      1
;  :arith-pivots            12363
;  :arith-pseudo-nonlinear  60
;  :conflicts               2756
;  :datatype-accessor-ax    416
;  :datatype-constructor-ax 1853
;  :datatype-occurs-check   1101
;  :datatype-splits         1133
;  :decisions               19818
;  :del-clause              131658
;  :final-checks            551
;  :interface-eqs           91
;  :max-generation          14
;  :max-memory              18.34
;  :memory                  17.03
;  :minimized-lits          689
;  :mk-bool-var             163310
;  :mk-clause               131658
;  :num-allocs              986481
;  :num-checks              448
;  :propagations            97449
;  :quant-instantiations    37833
;  :restarts                4
;  :rlimit-count            5541530)
(assert (implies
  (= exc@208@04 $Ref.null)
  (forall ((i1@241@04 Int)) (!
    (forall ((i2@242@04 Int)) (!
      (implies
        (and
          (and
            (and
              (and
                (=
                  ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@241@04))
                  ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@242@04)))
                (< i2@242@04 V@28@04))
              (<= 0 i2@242@04))
            (< i1@241@04 V@28@04))
          (<= 0 i1@241@04))
        (= i1@241@04 i2@242@04))
      :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i2@242@04))
      :qid |prog.l<no position>|))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@241@04))
    :qid |prog.l<no position>|))))
; [eval] exc == null
(set-option :timeout 10)
(push) ; 12
(assert (not (not (= exc@208@04 $Ref.null))))
(check-sat)
; unknown
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               129686
;  :arith-add-rows          89336
;  :arith-assert-diseq      7747
;  :arith-assert-lower      41824
;  :arith-assert-upper      27733
;  :arith-bound-prop        6258
;  :arith-conflicts         1201
;  :arith-eq-adapter        22284
;  :arith-fixed-eqs         15327
;  :arith-gcd-tests         3
;  :arith-grobner           294
;  :arith-ineq-splits       2
;  :arith-max-min           1922
;  :arith-nonlinear-bounds  233
;  :arith-nonlinear-horner  353
;  :arith-offset-eqs        18910
;  :arith-patches           4
;  :arith-patches_succ      1
;  :arith-pivots            12363
;  :arith-pseudo-nonlinear  60
;  :conflicts               2756
;  :datatype-accessor-ax    416
;  :datatype-constructor-ax 1859
;  :datatype-occurs-check   1106
;  :datatype-splits         1135
;  :decisions               19824
;  :del-clause              131658
;  :final-checks            553
;  :interface-eqs           91
;  :max-generation          14
;  :max-memory              18.34
;  :memory                  17.03
;  :minimized-lits          689
;  :mk-bool-var             163313
;  :mk-clause               131658
;  :num-allocs              987414
;  :num-checks              449
;  :propagations            97449
;  :quant-instantiations    37833
;  :restarts                4
;  :rlimit-count            5542779)
; [then-branch: 311 | exc@208@04 == Null | live]
; [else-branch: 311 | exc@208@04 != Null | dead]
(push) ; 12
; [then-branch: 311 | exc@208@04 == Null]
(declare-const i1@243@04 Int)
(declare-const j1@244@04 Int)
(push) ; 13
; [eval] 0 <= i1 && i1 < V && (0 <= j1 && j1 < V)
; [eval] 0 <= i1
(push) ; 14
; [then-branch: 312 | 0 <= i1@243@04 | live]
; [else-branch: 312 | !(0 <= i1@243@04) | live]
(push) ; 15
; [then-branch: 312 | 0 <= i1@243@04]
(assert (<= 0 i1@243@04))
; [eval] i1 < V
(push) ; 16
; [then-branch: 313 | i1@243@04 < V@28@04 | live]
; [else-branch: 313 | !(i1@243@04 < V@28@04) | live]
(push) ; 17
; [then-branch: 313 | i1@243@04 < V@28@04]
(assert (< i1@243@04 V@28@04))
; [eval] 0 <= j1
(push) ; 18
; [then-branch: 314 | 0 <= j1@244@04 | live]
; [else-branch: 314 | !(0 <= j1@244@04) | live]
(push) ; 19
; [then-branch: 314 | 0 <= j1@244@04]
(assert (<= 0 j1@244@04))
; [eval] j1 < V
(pop) ; 19
(push) ; 19
; [else-branch: 314 | !(0 <= j1@244@04)]
(assert (not (<= 0 j1@244@04)))
(pop) ; 19
(pop) ; 18
; Joined path conditions
; Joined path conditions
(pop) ; 17
(push) ; 17
; [else-branch: 313 | !(i1@243@04 < V@28@04)]
(assert (not (< i1@243@04 V@28@04)))
(pop) ; 17
(pop) ; 16
; Joined path conditions
; Joined path conditions
(pop) ; 15
(push) ; 15
; [else-branch: 312 | !(0 <= i1@243@04)]
(assert (not (<= 0 i1@243@04)))
(pop) ; 15
(pop) ; 14
; Joined path conditions
; Joined path conditions
(assert (and
  (and (and (< j1@244@04 V@28@04) (<= 0 j1@244@04)) (< i1@243@04 V@28@04))
  (<= 0 i1@243@04)))
(declare-const $k@245@04 $Perm)
(assert ($Perm.isReadVar $k@245@04 $Perm.Write))
; [eval] aloc(opt_get1(aloc(opt_get1(source), i1).option$array$), j1)
; [eval] opt_get1(aloc(opt_get1(source), i1).option$array$)
; [eval] aloc(opt_get1(source), i1)
; [eval] opt_get1(source)
(push) ; 14
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 14
; Joined path conditions
(push) ; 14
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 15
(assert (not (< i1@243@04 (alen<Int> (opt_get1 $Snap.unit source@26@04)))))
(check-sat)
; unsat
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               129686
;  :arith-add-rows          89336
;  :arith-assert-diseq      7748
;  :arith-assert-lower      41832
;  :arith-assert-upper      27734
;  :arith-bound-prop        6258
;  :arith-conflicts         1203
;  :arith-eq-adapter        22285
;  :arith-fixed-eqs         15327
;  :arith-gcd-tests         3
;  :arith-grobner           294
;  :arith-ineq-splits       2
;  :arith-max-min           1922
;  :arith-nonlinear-bounds  233
;  :arith-nonlinear-horner  353
;  :arith-offset-eqs        18910
;  :arith-patches           4
;  :arith-patches_succ      1
;  :arith-pivots            12365
;  :arith-pseudo-nonlinear  60
;  :conflicts               2758
;  :datatype-accessor-ax    416
;  :datatype-constructor-ax 1859
;  :datatype-occurs-check   1106
;  :datatype-splits         1135
;  :decisions               19824
;  :del-clause              131658
;  :final-checks            553
;  :interface-eqs           91
;  :max-generation          14
;  :max-memory              18.34
;  :memory                  17.03
;  :minimized-lits          689
;  :mk-bool-var             163323
;  :mk-clause               131660
;  :num-allocs              987748
;  :num-checks              450
;  :propagations            97450
;  :quant-instantiations    37833
;  :restarts                4
;  :rlimit-count            5543383)
(assert (< i1@243@04 (alen<Int> (opt_get1 $Snap.unit source@26@04))))
(pop) ; 14
; Joined path conditions
(assert (< i1@243@04 (alen<Int> (opt_get1 $Snap.unit source@26@04))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@243@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@243@04)))
(push) ; 14
(assert (not (<
  $Perm.No
  (+
    (ite
      (and
        (<
          (inv@42@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@243@04))
          V@28@04)
        (<=
          0
          (inv@42@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@243@04))))
      $k@41@04
      $Perm.No)
    (ite
      (and
        (<
          (inv@34@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@243@04))
          V@28@04)
        (<=
          0
          (inv@34@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@243@04))))
      $k@33@04
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               129686
;  :arith-add-rows          89336
;  :arith-assert-diseq      7748
;  :arith-assert-lower      41832
;  :arith-assert-upper      27734
;  :arith-bound-prop        6258
;  :arith-conflicts         1203
;  :arith-eq-adapter        22285
;  :arith-fixed-eqs         15327
;  :arith-gcd-tests         3
;  :arith-grobner           294
;  :arith-ineq-splits       2
;  :arith-max-min           1922
;  :arith-nonlinear-bounds  233
;  :arith-nonlinear-horner  353
;  :arith-offset-eqs        18910
;  :arith-patches           4
;  :arith-patches_succ      1
;  :arith-pivots            12365
;  :arith-pseudo-nonlinear  60
;  :conflicts               2759
;  :datatype-accessor-ax    416
;  :datatype-constructor-ax 1859
;  :datatype-occurs-check   1106
;  :datatype-splits         1135
;  :decisions               19824
;  :del-clause              131668
;  :final-checks            553
;  :interface-eqs           91
;  :max-generation          14
;  :max-memory              18.34
;  :memory                  17.03
;  :minimized-lits          689
;  :mk-bool-var             163335
;  :mk-clause               131670
;  :num-allocs              987960
;  :num-checks              451
;  :propagations            97450
;  :quant-instantiations    37833
;  :restarts                4
;  :rlimit-count            5543866)
(push) ; 14
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 15
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@243@04))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               129686
;  :arith-add-rows          89336
;  :arith-assert-diseq      7748
;  :arith-assert-lower      41832
;  :arith-assert-upper      27734
;  :arith-bound-prop        6258
;  :arith-conflicts         1203
;  :arith-eq-adapter        22285
;  :arith-fixed-eqs         15327
;  :arith-gcd-tests         3
;  :arith-grobner           294
;  :arith-ineq-splits       2
;  :arith-max-min           1922
;  :arith-nonlinear-bounds  233
;  :arith-nonlinear-horner  353
;  :arith-offset-eqs        18910
;  :arith-patches           4
;  :arith-patches_succ      1
;  :arith-pivots            12365
;  :arith-pseudo-nonlinear  60
;  :conflicts               2760
;  :datatype-accessor-ax    416
;  :datatype-constructor-ax 1859
;  :datatype-occurs-check   1106
;  :datatype-splits         1135
;  :decisions               19824
;  :del-clause              131668
;  :final-checks            553
;  :interface-eqs           91
;  :max-generation          14
;  :max-memory              18.34
;  :memory                  17.03
;  :minimized-lits          689
;  :mk-bool-var             163336
;  :mk-clause               131670
;  :num-allocs              988050
;  :num-checks              452
;  :propagations            97450
;  :quant-instantiations    37833
;  :restarts                4
;  :rlimit-count            5543955)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@243@04))
    (as None<option<array>>  option<array>))))
(pop) ; 14
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@243@04))
    (as None<option<array>>  option<array>))))
(push) ; 14
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 15
(assert (not (<
  j1@244@04
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@243@04)))))))
(check-sat)
; unsat
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               129686
;  :arith-add-rows          89336
;  :arith-assert-diseq      7748
;  :arith-assert-lower      41832
;  :arith-assert-upper      27734
;  :arith-bound-prop        6258
;  :arith-conflicts         1203
;  :arith-eq-adapter        22285
;  :arith-fixed-eqs         15327
;  :arith-gcd-tests         3
;  :arith-grobner           294
;  :arith-ineq-splits       2
;  :arith-max-min           1922
;  :arith-nonlinear-bounds  233
;  :arith-nonlinear-horner  353
;  :arith-offset-eqs        18910
;  :arith-patches           4
;  :arith-patches_succ      1
;  :arith-pivots            12365
;  :arith-pseudo-nonlinear  60
;  :conflicts               2761
;  :datatype-accessor-ax    416
;  :datatype-constructor-ax 1859
;  :datatype-occurs-check   1106
;  :datatype-splits         1135
;  :decisions               19824
;  :del-clause              131668
;  :final-checks            553
;  :interface-eqs           91
;  :max-generation          14
;  :max-memory              18.34
;  :memory                  17.03
;  :minimized-lits          689
;  :mk-bool-var             163338
;  :mk-clause               131670
;  :num-allocs              988207
;  :num-checks              453
;  :propagations            97450
;  :quant-instantiations    37833
;  :restarts                4
;  :rlimit-count            5544208)
(assert (<
  j1@244@04
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@243@04))))))
(pop) ; 14
; Joined path conditions
(assert (<
  j1@244@04
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@243@04))))))
(pop) ; 13
(declare-fun inv@246@04 ($Ref) Int)
(declare-fun inv@247@04 ($Ref) Int)
; Nested auxiliary terms: globals
(assert ($Perm.isReadVar $k@245@04 $Perm.Write))
; Nested auxiliary terms: non-globals
(assert (forall ((i1@243@04 Int) (j1@244@04 Int)) (!
  (and
    (< i1@243@04 (alen<Int> (opt_get1 $Snap.unit source@26@04)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@243@04)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@243@04))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@243@04))
        (as None<option<array>>  option<array>)))
    (<
      j1@244@04
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@243@04))))))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@243@04))) j1@244@04))
  :qid |int-aux|)))
(push) ; 13
(assert (not (forall ((i1@243@04 Int) (j1@244@04 Int)) (!
  (implies
    (and
      (and (and (< j1@244@04 V@28@04) (<= 0 j1@244@04)) (< i1@243@04 V@28@04))
      (<= 0 i1@243@04))
    (or (= $k@245@04 $Perm.No) (< $Perm.No $k@245@04)))
  
  ))))
(check-sat)
; unsat
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               129686
;  :arith-add-rows          89336
;  :arith-assert-diseq      7749
;  :arith-assert-lower      41834
;  :arith-assert-upper      27735
;  :arith-bound-prop        6258
;  :arith-conflicts         1203
;  :arith-eq-adapter        22286
;  :arith-fixed-eqs         15327
;  :arith-gcd-tests         3
;  :arith-grobner           294
;  :arith-ineq-splits       2
;  :arith-max-min           1922
;  :arith-nonlinear-bounds  233
;  :arith-nonlinear-horner  353
;  :arith-offset-eqs        18910
;  :arith-patches           4
;  :arith-patches_succ      1
;  :arith-pivots            12365
;  :arith-pseudo-nonlinear  60
;  :conflicts               2762
;  :datatype-accessor-ax    416
;  :datatype-constructor-ax 1859
;  :datatype-occurs-check   1106
;  :datatype-splits         1135
;  :decisions               19824
;  :del-clause              131670
;  :final-checks            553
;  :interface-eqs           91
;  :max-generation          14
;  :max-memory              18.34
;  :memory                  17.03
;  :minimized-lits          689
;  :mk-bool-var             163347
;  :mk-clause               131672
;  :num-allocs              988736
;  :num-checks              454
;  :propagations            97451
;  :quant-instantiations    37833
;  :restarts                4
;  :rlimit-count            5545095)
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 13
(assert (not (forall ((i11@243@04 Int) (j11@244@04 Int) (i12@243@04 Int) (j12@244@04 Int)) (!
  (implies
    (and
      (and
        (and
          (and
            (and
              (and (< j11@244@04 V@28@04) (<= 0 j11@244@04))
              (< i11@243@04 V@28@04))
            (<= 0 i11@243@04))
          ($FVF.loc_int ($FVF.lookup_int (as sm@221@04  $FVF<Int>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@26@04) i11@243@04))) j11@244@04)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@26@04) i11@243@04))) j11@244@04)))
        (< $Perm.No $k@245@04))
      (and
        (and
          (and
            (and
              (and (< j12@244@04 V@28@04) (<= 0 j12@244@04))
              (< i12@243@04 V@28@04))
            (<= 0 i12@243@04))
          ($FVF.loc_int ($FVF.lookup_int (as sm@221@04  $FVF<Int>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@26@04) i12@243@04))) j12@244@04)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@26@04) i12@243@04))) j12@244@04)))
        (< $Perm.No $k@245@04))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@26@04) i11@243@04))) j11@244@04)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@26@04) i12@243@04))) j12@244@04)))
    (and (= i11@243@04 i12@243@04) (= j11@244@04 j12@244@04)))
  
  :qid |int-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               129690
;  :arith-add-rows          89336
;  :arith-assert-diseq      7749
;  :arith-assert-lower      41842
;  :arith-assert-upper      27735
;  :arith-bound-prop        6258
;  :arith-conflicts         1204
;  :arith-eq-adapter        22288
;  :arith-fixed-eqs         15327
;  :arith-gcd-tests         3
;  :arith-grobner           294
;  :arith-ineq-splits       2
;  :arith-max-min           1922
;  :arith-nonlinear-bounds  233
;  :arith-nonlinear-horner  353
;  :arith-offset-eqs        18910
;  :arith-patches           4
;  :arith-patches_succ      1
;  :arith-pivots            12365
;  :arith-pseudo-nonlinear  60
;  :conflicts               2763
;  :datatype-accessor-ax    416
;  :datatype-constructor-ax 1859
;  :datatype-occurs-check   1106
;  :datatype-splits         1135
;  :decisions               19824
;  :del-clause              131679
;  :final-checks            553
;  :interface-eqs           91
;  :max-generation          14
;  :max-memory              18.34
;  :memory                  17.03
;  :minimized-lits          689
;  :mk-bool-var             163365
;  :mk-clause               131681
;  :num-allocs              989149
;  :num-checks              455
;  :propagations            97451
;  :quant-instantiations    37833
;  :restarts                4
;  :rlimit-count            5546028)
; Definitional axioms for inverse functions
(assert (forall ((i1@243@04 Int) (j1@244@04 Int)) (!
  (implies
    (and
      (and
        (and (and (< j1@244@04 V@28@04) (<= 0 j1@244@04)) (< i1@243@04 V@28@04))
        (<= 0 i1@243@04))
      (< $Perm.No $k@245@04))
    (and
      (=
        (inv@246@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@243@04))) j1@244@04))
        i1@243@04)
      (=
        (inv@247@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@243@04))) j1@244@04))
        j1@244@04)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit source@26@04) i1@243@04))) j1@244@04))
  :qid |int-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and
          (and (< (inv@247@04 r) V@28@04) (<= 0 (inv@247@04 r)))
          (< (inv@246@04 r) V@28@04))
        (<= 0 (inv@246@04 r)))
      (< $Perm.No $k@245@04))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@26@04) (inv@246@04 r)))) (inv@247@04 r))
      r))
  :pattern ((inv@246@04 r))
  :pattern ((inv@247@04 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@247@04 r) V@28@04) (<= 0 (inv@247@04 r)))
        (< (inv@246@04 r) V@28@04))
      (<= 0 (inv@246@04 r)))
    ($FVF.loc_int ($FVF.lookup_int (as sm@221@04  $FVF<Int>) r) r))
  :pattern ((inv@246@04 r) (inv@247@04 r))
  )))
; Precomputing data for removing quantified permissions
(define-fun pTaken@248@04 ((r $Ref)) $Perm
  (ite
    (and
      (and
        (and (< (inv@247@04 r) V@28@04) (<= 0 (inv@247@04 r)))
        (< (inv@246@04 r) V@28@04))
      (<= 0 (inv@246@04 r)))
    ($Perm.min
      (ite
        (and
          (and
            (and (< (inv@220@04 r) V@28@04) (<= 0 (inv@220@04 r)))
            (< (inv@219@04 r) V@28@04))
          (<= 0 (inv@219@04 r)))
        $k@218@04
        $Perm.No)
      $k@245@04)
    $Perm.No))
(define-fun pTaken@249@04 ((r $Ref)) $Perm
  (ite
    (and
      (and
        (and (< (inv@247@04 r) V@28@04) (<= 0 (inv@247@04 r)))
        (< (inv@246@04 r) V@28@04))
      (<= 0 (inv@246@04 r)))
    ($Perm.min
      (ite
        (and
          (and
            (and (< (inv@214@04 r) V@28@04) (<= 0 (inv@214@04 r)))
            (< (inv@213@04 r) V@28@04))
          (<= 0 (inv@213@04 r)))
        $Perm.Write
        $Perm.No)
      (- $k@245@04 (pTaken@248@04 r)))
    $Perm.No))
(define-fun pTaken@250@04 ((r $Ref)) $Perm
  (ite
    (and
      (and
        (and (< (inv@247@04 r) V@28@04) (<= 0 (inv@247@04 r)))
        (< (inv@246@04 r) V@28@04))
      (<= 0 (inv@246@04 r)))
    ($Perm.min
      (-
        (ite
          (and
            (and
              (and (< (inv@52@04 r) V@28@04) (<= 0 (inv@52@04 r)))
              (< (inv@51@04 r) V@28@04))
            (<= 0 (inv@51@04 r)))
          $k@50@04
          $Perm.No)
        (pTaken@207@04 r))
      (- (- $k@245@04 (pTaken@248@04 r)) (pTaken@249@04 r)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Constrain original permissions $k@245@04
(assert (forall ((r $Ref)) (!
  (implies
    (not
      (=
        (ite
          (and
            (and
              (and (< (inv@220@04 r) V@28@04) (<= 0 (inv@220@04 r)))
              (< (inv@219@04 r) V@28@04))
            (<= 0 (inv@219@04 r)))
          $k@218@04
          $Perm.No)
        $Perm.No))
    (ite
      (and
        (and
          (and (< (inv@220@04 r) V@28@04) (<= 0 (inv@220@04 r)))
          (< (inv@219@04 r) V@28@04))
        (<= 0 (inv@219@04 r)))
      (<
        (ite
          (and
            (and
              (and (< (inv@247@04 r) V@28@04) (<= 0 (inv@247@04 r)))
              (< (inv@246@04 r) V@28@04))
            (<= 0 (inv@246@04 r)))
          $k@245@04
          $Perm.No)
        $k@218@04)
      (<
        (ite
          (and
            (and
              (and (< (inv@247@04 r) V@28@04) (<= 0 (inv@247@04 r)))
              (< (inv@246@04 r) V@28@04))
            (<= 0 (inv@246@04 r)))
          $k@245@04
          $Perm.No)
        $Perm.No)))
  :pattern ((inv@220@04 r))
  :pattern ((inv@219@04 r))
  :pattern ((inv@247@04 r))
  :pattern ((inv@246@04 r))
  :qid |qp.srp75|)))
; Intermediate check if already taken enough permissions
(set-option :timeout 500)
(push) ; 13
(assert (not (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@247@04 r) V@28@04) (<= 0 (inv@247@04 r)))
        (< (inv@246@04 r) V@28@04))
      (<= 0 (inv@246@04 r)))
    (= (- $k@245@04 (pTaken@248@04 r)) $Perm.No))
  
  ))))
(check-sat)
; unsat
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               129722
;  :arith-add-rows          89336
;  :arith-assert-diseq      7750
;  :arith-assert-lower      41846
;  :arith-assert-upper      27735
;  :arith-bound-prop        6258
;  :arith-conflicts         1205
;  :arith-eq-adapter        22289
;  :arith-fixed-eqs         15327
;  :arith-gcd-tests         3
;  :arith-grobner           294
;  :arith-ineq-splits       2
;  :arith-max-min           1922
;  :arith-nonlinear-bounds  233
;  :arith-nonlinear-horner  353
;  :arith-offset-eqs        18910
;  :arith-patches           4
;  :arith-patches_succ      1
;  :arith-pivots            12367
;  :arith-pseudo-nonlinear  60
;  :conflicts               2764
;  :datatype-accessor-ax    416
;  :datatype-constructor-ax 1865
;  :datatype-occurs-check   1111
;  :datatype-splits         1137
;  :decisions               19830
;  :del-clause              131694
;  :final-checks            555
;  :interface-eqs           91
;  :max-generation          14
;  :max-memory              18.34
;  :memory                  17.03
;  :minimized-lits          689
;  :mk-bool-var             163391
;  :mk-clause               131694
;  :num-allocs              991175
;  :num-checks              457
;  :propagations            97451
;  :quant-instantiations    37833
;  :restarts                4
;  :rlimit-count            5549954)
; Final check if taken enough permissions
; Done removing quantified permissions
; Definitional axioms for snapshot map values
; [eval] exc == null
(set-option :timeout 10)
(push) ; 13
(assert (not (not (= exc@208@04 $Ref.null))))
(check-sat)
; unknown
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               129753
;  :arith-add-rows          89336
;  :arith-assert-diseq      7750
;  :arith-assert-lower      41846
;  :arith-assert-upper      27735
;  :arith-bound-prop        6258
;  :arith-conflicts         1205
;  :arith-eq-adapter        22289
;  :arith-fixed-eqs         15327
;  :arith-gcd-tests         3
;  :arith-grobner           294
;  :arith-ineq-splits       2
;  :arith-max-min           1922
;  :arith-nonlinear-bounds  233
;  :arith-nonlinear-horner  353
;  :arith-offset-eqs        18910
;  :arith-patches           4
;  :arith-patches_succ      1
;  :arith-pivots            12367
;  :arith-pseudo-nonlinear  60
;  :conflicts               2764
;  :datatype-accessor-ax    416
;  :datatype-constructor-ax 1871
;  :datatype-occurs-check   1116
;  :datatype-splits         1139
;  :decisions               19836
;  :del-clause              131694
;  :final-checks            557
;  :interface-eqs           91
;  :max-generation          14
;  :max-memory              18.34
;  :memory                  17.04
;  :minimized-lits          689
;  :mk-bool-var             163393
;  :mk-clause               131694
;  :num-allocs              991790
;  :num-checks              458
;  :propagations            97451
;  :quant-instantiations    37833
;  :restarts                4
;  :rlimit-count            5550678)
; [then-branch: 315 | exc@208@04 == Null | live]
; [else-branch: 315 | exc@208@04 != Null | dead]
(push) ; 13
; [then-branch: 315 | exc@208@04 == Null]
(declare-const i1@251@04 Int)
(declare-const j1@252@04 Int)
(push) ; 14
; [eval] 0 <= i1 && i1 < V && (0 <= j1 && j1 < V)
; [eval] 0 <= i1
(push) ; 15
; [then-branch: 316 | 0 <= i1@251@04 | live]
; [else-branch: 316 | !(0 <= i1@251@04) | live]
(push) ; 16
; [then-branch: 316 | 0 <= i1@251@04]
(assert (<= 0 i1@251@04))
; [eval] i1 < V
(push) ; 17
; [then-branch: 317 | i1@251@04 < V@28@04 | live]
; [else-branch: 317 | !(i1@251@04 < V@28@04) | live]
(push) ; 18
; [then-branch: 317 | i1@251@04 < V@28@04]
(assert (< i1@251@04 V@28@04))
; [eval] 0 <= j1
(push) ; 19
; [then-branch: 318 | 0 <= j1@252@04 | live]
; [else-branch: 318 | !(0 <= j1@252@04) | live]
(push) ; 20
; [then-branch: 318 | 0 <= j1@252@04]
(assert (<= 0 j1@252@04))
; [eval] j1 < V
(pop) ; 20
(push) ; 20
; [else-branch: 318 | !(0 <= j1@252@04)]
(assert (not (<= 0 j1@252@04)))
(pop) ; 20
(pop) ; 19
; Joined path conditions
; Joined path conditions
(pop) ; 18
(push) ; 18
; [else-branch: 317 | !(i1@251@04 < V@28@04)]
(assert (not (< i1@251@04 V@28@04)))
(pop) ; 18
(pop) ; 17
; Joined path conditions
; Joined path conditions
(pop) ; 16
(push) ; 16
; [else-branch: 316 | !(0 <= i1@251@04)]
(assert (not (<= 0 i1@251@04)))
(pop) ; 16
(pop) ; 15
; Joined path conditions
; Joined path conditions
(assert (and
  (and (and (< j1@252@04 V@28@04) (<= 0 j1@252@04)) (< i1@251@04 V@28@04))
  (<= 0 i1@251@04)))
; [eval] aloc(opt_get1(aloc(opt_get1(target), i1).option$array$), j1)
; [eval] opt_get1(aloc(opt_get1(target), i1).option$array$)
; [eval] aloc(opt_get1(target), i1)
; [eval] opt_get1(target)
(push) ; 15
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 15
; Joined path conditions
(push) ; 15
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 16
(assert (not (< i1@251@04 (alen<Int> (opt_get1 $Snap.unit target@27@04)))))
(check-sat)
; unsat
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               129753
;  :arith-add-rows          89336
;  :arith-assert-diseq      7750
;  :arith-assert-lower      41852
;  :arith-assert-upper      27735
;  :arith-bound-prop        6258
;  :arith-conflicts         1207
;  :arith-eq-adapter        22289
;  :arith-fixed-eqs         15327
;  :arith-gcd-tests         3
;  :arith-grobner           294
;  :arith-ineq-splits       2
;  :arith-max-min           1922
;  :arith-nonlinear-bounds  233
;  :arith-nonlinear-horner  353
;  :arith-offset-eqs        18910
;  :arith-patches           4
;  :arith-patches_succ      1
;  :arith-pivots            12370
;  :arith-pseudo-nonlinear  60
;  :conflicts               2766
;  :datatype-accessor-ax    416
;  :datatype-constructor-ax 1871
;  :datatype-occurs-check   1116
;  :datatype-splits         1139
;  :decisions               19836
;  :del-clause              131694
;  :final-checks            557
;  :interface-eqs           91
;  :max-generation          14
;  :max-memory              18.34
;  :memory                  17.04
;  :minimized-lits          689
;  :mk-bool-var             163399
;  :mk-clause               131694
;  :num-allocs              992064
;  :num-checks              459
;  :propagations            97451
;  :quant-instantiations    37833
;  :restarts                4
;  :rlimit-count            5551142)
(assert (< i1@251@04 (alen<Int> (opt_get1 $Snap.unit target@27@04))))
(pop) ; 15
; Joined path conditions
(assert (< i1@251@04 (alen<Int> (opt_get1 $Snap.unit target@27@04))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@251@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@251@04)))
(push) ; 15
(assert (not (<
  $Perm.No
  (+
    (ite
      (and
        (<
          (inv@42@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@251@04))
          V@28@04)
        (<=
          0
          (inv@42@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@251@04))))
      $k@41@04
      $Perm.No)
    (ite
      (and
        (<
          (inv@34@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@251@04))
          V@28@04)
        (<=
          0
          (inv@34@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@251@04))))
      $k@33@04
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               129753
;  :arith-add-rows          89336
;  :arith-assert-diseq      7750
;  :arith-assert-lower      41852
;  :arith-assert-upper      27735
;  :arith-bound-prop        6258
;  :arith-conflicts         1207
;  :arith-eq-adapter        22289
;  :arith-fixed-eqs         15327
;  :arith-gcd-tests         3
;  :arith-grobner           294
;  :arith-ineq-splits       2
;  :arith-max-min           1922
;  :arith-nonlinear-bounds  233
;  :arith-nonlinear-horner  353
;  :arith-offset-eqs        18910
;  :arith-patches           4
;  :arith-patches_succ      1
;  :arith-pivots            12370
;  :arith-pseudo-nonlinear  60
;  :conflicts               2767
;  :datatype-accessor-ax    416
;  :datatype-constructor-ax 1871
;  :datatype-occurs-check   1116
;  :datatype-splits         1139
;  :decisions               19836
;  :del-clause              131704
;  :final-checks            557
;  :interface-eqs           91
;  :max-generation          14
;  :max-memory              18.34
;  :memory                  17.04
;  :minimized-lits          689
;  :mk-bool-var             163411
;  :mk-clause               131704
;  :num-allocs              992276
;  :num-checks              460
;  :propagations            97451
;  :quant-instantiations    37833
;  :restarts                4
;  :rlimit-count            5551625)
(push) ; 15
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 16
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@251@04))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               129753
;  :arith-add-rows          89336
;  :arith-assert-diseq      7750
;  :arith-assert-lower      41852
;  :arith-assert-upper      27735
;  :arith-bound-prop        6258
;  :arith-conflicts         1207
;  :arith-eq-adapter        22289
;  :arith-fixed-eqs         15327
;  :arith-gcd-tests         3
;  :arith-grobner           294
;  :arith-ineq-splits       2
;  :arith-max-min           1922
;  :arith-nonlinear-bounds  233
;  :arith-nonlinear-horner  353
;  :arith-offset-eqs        18910
;  :arith-patches           4
;  :arith-patches_succ      1
;  :arith-pivots            12370
;  :arith-pseudo-nonlinear  60
;  :conflicts               2768
;  :datatype-accessor-ax    416
;  :datatype-constructor-ax 1871
;  :datatype-occurs-check   1116
;  :datatype-splits         1139
;  :decisions               19836
;  :del-clause              131704
;  :final-checks            557
;  :interface-eqs           91
;  :max-generation          14
;  :max-memory              18.34
;  :memory                  17.04
;  :minimized-lits          689
;  :mk-bool-var             163412
;  :mk-clause               131704
;  :num-allocs              992366
;  :num-checks              461
;  :propagations            97451
;  :quant-instantiations    37833
;  :restarts                4
;  :rlimit-count            5551714)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@251@04))
    (as None<option<array>>  option<array>))))
(pop) ; 15
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@251@04))
    (as None<option<array>>  option<array>))))
(push) ; 15
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 16
(assert (not (<
  j1@252@04
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@251@04)))))))
(check-sat)
; unsat
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               129753
;  :arith-add-rows          89337
;  :arith-assert-diseq      7750
;  :arith-assert-lower      41852
;  :arith-assert-upper      27735
;  :arith-bound-prop        6258
;  :arith-conflicts         1207
;  :arith-eq-adapter        22289
;  :arith-fixed-eqs         15327
;  :arith-gcd-tests         3
;  :arith-grobner           294
;  :arith-ineq-splits       2
;  :arith-max-min           1922
;  :arith-nonlinear-bounds  233
;  :arith-nonlinear-horner  353
;  :arith-offset-eqs        18910
;  :arith-patches           4
;  :arith-patches_succ      1
;  :arith-pivots            12370
;  :arith-pseudo-nonlinear  60
;  :conflicts               2769
;  :datatype-accessor-ax    416
;  :datatype-constructor-ax 1871
;  :datatype-occurs-check   1116
;  :datatype-splits         1139
;  :decisions               19836
;  :del-clause              131704
;  :final-checks            557
;  :interface-eqs           91
;  :max-generation          14
;  :max-memory              18.34
;  :memory                  17.04
;  :minimized-lits          689
;  :mk-bool-var             163414
;  :mk-clause               131704
;  :num-allocs              992516
;  :num-checks              462
;  :propagations            97451
;  :quant-instantiations    37833
;  :restarts                4
;  :rlimit-count            5551964)
(assert (<
  j1@252@04
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@251@04))))))
(pop) ; 15
; Joined path conditions
(assert (<
  j1@252@04
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@251@04))))))
(pop) ; 14
(declare-fun inv@253@04 ($Ref) Int)
(declare-fun inv@254@04 ($Ref) Int)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(assert (forall ((i1@251@04 Int) (j1@252@04 Int)) (!
  (and
    (< i1@251@04 (alen<Int> (opt_get1 $Snap.unit target@27@04)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@251@04)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@251@04))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@251@04))
        (as None<option<array>>  option<array>)))
    (<
      j1@252@04
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@251@04))))))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@251@04))) j1@252@04))
  :qid |int-aux|)))
(declare-const sm@255@04 $FVF<Int>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (ite
          (and
            (and
              (and (< (inv@52@04 r) V@28@04) (<= 0 (inv@52@04 r)))
              (< (inv@51@04 r) V@28@04))
            (<= 0 (inv@51@04 r)))
          $k@50@04
          $Perm.No)
        (pTaken@207@04 r)))
    (=
      ($FVF.lookup_int (as sm@255@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@31@04))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@255@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@31@04))))))))))))))) r))
  :qid |qp.fvfValDef76|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@214@04 r) V@28@04) (<= 0 (inv@214@04 r)))
        (< (inv@213@04 r) V@28@04))
      (<= 0 (inv@213@04 r)))
    (=
      ($FVF.lookup_int (as sm@255@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@210@04))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@255@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@210@04))))))))))))))) r))
  :qid |qp.fvfValDef77|)))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (ite
          (and
            (and
              (and (< (inv@220@04 r) V@28@04) (<= 0 (inv@220@04 r)))
              (< (inv@219@04 r) V@28@04))
            (<= 0 (inv@219@04 r)))
          $k@218@04
          $Perm.No)
        (pTaken@248@04 r)))
    (=
      ($FVF.lookup_int (as sm@255@04  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@210@04)))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@255@04  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@210@04)))))))))))))))) r))
  :qid |qp.fvfValDef78|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@31@04))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@210@04))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@210@04)))))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@255@04  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef79|)))
; Check receiver injectivity
(push) ; 14
(assert (not (forall ((i11@251@04 Int) (j11@252@04 Int) (i12@251@04 Int) (j12@252@04 Int)) (!
  (implies
    (and
      (and
        (and
          (and
            (and (< j11@252@04 V@28@04) (<= 0 j11@252@04))
            (< i11@251@04 V@28@04))
          (<= 0 i11@251@04))
        ($FVF.loc_int ($FVF.lookup_int (as sm@255@04  $FVF<Int>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@27@04) i11@251@04))) j11@252@04)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@27@04) i11@251@04))) j11@252@04)))
      (and
        (and
          (and
            (and (< j12@252@04 V@28@04) (<= 0 j12@252@04))
            (< i12@251@04 V@28@04))
          (<= 0 i12@251@04))
        ($FVF.loc_int ($FVF.lookup_int (as sm@255@04  $FVF<Int>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@27@04) i12@251@04))) j12@252@04)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@27@04) i12@251@04))) j12@252@04)))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@27@04) i11@251@04))) j11@252@04)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@27@04) i12@251@04))) j12@252@04)))
    (and (= i11@251@04 i12@251@04) (= j11@252@04 j12@252@04)))
  
  :qid |int-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               129758
;  :arith-add-rows          89337
;  :arith-assert-diseq      7750
;  :arith-assert-lower      41860
;  :arith-assert-upper      27735
;  :arith-bound-prop        6258
;  :arith-conflicts         1208
;  :arith-eq-adapter        22291
;  :arith-fixed-eqs         15327
;  :arith-gcd-tests         3
;  :arith-grobner           294
;  :arith-ineq-splits       2
;  :arith-max-min           1922
;  :arith-nonlinear-bounds  233
;  :arith-nonlinear-horner  353
;  :arith-offset-eqs        18910
;  :arith-patches           4
;  :arith-patches_succ      1
;  :arith-pivots            12371
;  :arith-pseudo-nonlinear  60
;  :conflicts               2770
;  :datatype-accessor-ax    416
;  :datatype-constructor-ax 1871
;  :datatype-occurs-check   1116
;  :datatype-splits         1139
;  :decisions               19836
;  :del-clause              131713
;  :final-checks            557
;  :interface-eqs           91
;  :max-generation          14
;  :max-memory              18.34
;  :memory                  17.03
;  :minimized-lits          689
;  :mk-bool-var             163438
;  :mk-clause               131713
;  :num-allocs              993941
;  :num-checks              463
;  :propagations            97451
;  :quant-instantiations    37833
;  :restarts                4
;  :rlimit-count            5556946)
; Definitional axioms for inverse functions
(assert (forall ((i1@251@04 Int) (j1@252@04 Int)) (!
  (implies
    (and
      (and (and (< j1@252@04 V@28@04) (<= 0 j1@252@04)) (< i1@251@04 V@28@04))
      (<= 0 i1@251@04))
    (and
      (=
        (inv@253@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@251@04))) j1@252@04))
        i1@251@04)
      (=
        (inv@254@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@251@04))) j1@252@04))
        j1@252@04)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit target@27@04) i1@251@04))) j1@252@04))
  :qid |int-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@254@04 r) V@28@04) (<= 0 (inv@254@04 r)))
        (< (inv@253@04 r) V@28@04))
      (<= 0 (inv@253@04 r)))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@27@04) (inv@253@04 r)))) (inv@254@04 r))
      r))
  :pattern ((inv@253@04 r))
  :pattern ((inv@254@04 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@254@04 r) V@28@04) (<= 0 (inv@254@04 r)))
        (< (inv@253@04 r) V@28@04))
      (<= 0 (inv@253@04 r)))
    ($FVF.loc_int ($FVF.lookup_int (as sm@255@04  $FVF<Int>) r) r))
  :pattern ((inv@253@04 r) (inv@254@04 r))
  )))
; Precomputing data for removing quantified permissions
(define-fun pTaken@256@04 ((r $Ref)) $Perm
  (ite
    (and
      (and
        (and (< (inv@254@04 r) V@28@04) (<= 0 (inv@254@04 r)))
        (< (inv@253@04 r) V@28@04))
      (<= 0 (inv@253@04 r)))
    ($Perm.min
      (-
        (ite
          (and
            (and
              (and (< (inv@52@04 r) V@28@04) (<= 0 (inv@52@04 r)))
              (< (inv@51@04 r) V@28@04))
            (<= 0 (inv@51@04 r)))
          $k@50@04
          $Perm.No)
        (pTaken@207@04 r))
      $Perm.Write)
    $Perm.No))
(define-fun pTaken@257@04 ((r $Ref)) $Perm
  (ite
    (and
      (and
        (and (< (inv@254@04 r) V@28@04) (<= 0 (inv@254@04 r)))
        (< (inv@253@04 r) V@28@04))
      (<= 0 (inv@253@04 r)))
    ($Perm.min
      (ite
        (and
          (and
            (and (< (inv@214@04 r) V@28@04) (<= 0 (inv@214@04 r)))
            (< (inv@213@04 r) V@28@04))
          (<= 0 (inv@213@04 r)))
        $Perm.Write
        $Perm.No)
      (- $Perm.Write (pTaken@256@04 r)))
    $Perm.No))
(define-fun pTaken@258@04 ((r $Ref)) $Perm
  (ite
    (and
      (and
        (and (< (inv@254@04 r) V@28@04) (<= 0 (inv@254@04 r)))
        (< (inv@253@04 r) V@28@04))
      (<= 0 (inv@253@04 r)))
    ($Perm.min
      (-
        (ite
          (and
            (and
              (and (< (inv@220@04 r) V@28@04) (<= 0 (inv@220@04 r)))
              (< (inv@219@04 r) V@28@04))
            (<= 0 (inv@219@04 r)))
          $k@218@04
          $Perm.No)
        (pTaken@248@04 r))
      (- (- $Perm.Write (pTaken@256@04 r)) (pTaken@257@04 r)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 500)
(push) ; 14
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (-
        (ite
          (and
            (and
              (and (< (inv@52@04 r) V@28@04) (<= 0 (inv@52@04 r)))
              (< (inv@51@04 r) V@28@04))
            (<= 0 (inv@51@04 r)))
          $k@50@04
          $Perm.No)
        (pTaken@207@04 r))
      (pTaken@256@04 r))
    $Perm.No)
  
  ))))
(check-sat)
; unsat
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               129824
;  :arith-add-rows          89337
;  :arith-assert-diseq      7753
;  :arith-assert-lower      41880
;  :arith-assert-upper      27745
;  :arith-bound-prop        6258
;  :arith-conflicts         1213
;  :arith-eq-adapter        22303
;  :arith-fixed-eqs         15327
;  :arith-gcd-tests         3
;  :arith-grobner           294
;  :arith-ineq-splits       2
;  :arith-max-min           1922
;  :arith-nonlinear-bounds  233
;  :arith-nonlinear-horner  353
;  :arith-offset-eqs        18911
;  :arith-patches           4
;  :arith-patches_succ      1
;  :arith-pivots            12379
;  :arith-pseudo-nonlinear  60
;  :conflicts               2781
;  :datatype-accessor-ax    416
;  :datatype-constructor-ax 1881
;  :datatype-occurs-check   1121
;  :datatype-splits         1141
;  :decisions               19852
;  :del-clause              131760
;  :final-checks            559
;  :interface-eqs           91
;  :max-generation          14
;  :max-memory              18.34
;  :memory                  17.03
;  :minimized-lits          689
;  :mk-bool-var             163515
;  :mk-clause               131760
;  :num-allocs              995910
;  :num-checks              465
;  :propagations            97477
;  :quant-instantiations    37836
;  :restarts                4
;  :rlimit-count            5561048
;  :time                    0.00)
; Intermediate check if already taken enough permissions
(push) ; 14
(assert (not (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@254@04 r) V@28@04) (<= 0 (inv@254@04 r)))
        (< (inv@253@04 r) V@28@04))
      (<= 0 (inv@253@04 r)))
    (= (- $Perm.Write (pTaken@256@04 r)) $Perm.No))
  
  ))))
(check-sat)
; unsat
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               129826
;  :arith-add-rows          89337
;  :arith-assert-diseq      7753
;  :arith-assert-lower      41884
;  :arith-assert-upper      27745
;  :arith-bound-prop        6258
;  :arith-conflicts         1214
;  :arith-eq-adapter        22303
;  :arith-fixed-eqs         15327
;  :arith-gcd-tests         3
;  :arith-grobner           294
;  :arith-ineq-splits       2
;  :arith-max-min           1922
;  :arith-nonlinear-bounds  233
;  :arith-nonlinear-horner  353
;  :arith-offset-eqs        18911
;  :arith-patches           4
;  :arith-patches_succ      1
;  :arith-pivots            12379
;  :arith-pseudo-nonlinear  60
;  :conflicts               2782
;  :datatype-accessor-ax    416
;  :datatype-constructor-ax 1881
;  :datatype-occurs-check   1121
;  :datatype-splits         1141
;  :decisions               19852
;  :del-clause              131778
;  :final-checks            559
;  :interface-eqs           91
;  :max-generation          14
;  :max-memory              18.34
;  :memory                  17.04
;  :minimized-lits          689
;  :mk-bool-var             163543
;  :mk-clause               131778
;  :num-allocs              996342
;  :num-checks              466
;  :propagations            97477
;  :quant-instantiations    37836
;  :restarts                4
;  :rlimit-count            5562253)
; Final check if taken enough permissions
; Done removing quantified permissions
; Definitional axioms for snapshot map values
; [eval] exc == null ==> (forall unknown: Int :: { opt_get1(aloc(opt_get1(target), unknown).option$array$) } { opt_get1(aloc(opt_get1(source), unknown).option$array$) } 0 <= unknown && unknown < V ==> (forall unknown1: Int :: { aloc(opt_get1(aloc(opt_get1(target), unknown).option$array$), unknown1) } { aloc(opt_get1(aloc(opt_get1(source), unknown).option$array$), unknown1) } 0 <= unknown1 && unknown1 < V ==> aloc(opt_get1(aloc(opt_get1(target), unknown).option$array$), unknown1).int == aloc(opt_get1(aloc(opt_get1(source), unknown).option$array$), unknown1).int))
; [eval] exc == null
(push) ; 14
(set-option :timeout 10)
(push) ; 15
(assert (not (not (= exc@208@04 $Ref.null))))
(check-sat)
; unknown
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               129857
;  :arith-add-rows          89337
;  :arith-assert-diseq      7753
;  :arith-assert-lower      41884
;  :arith-assert-upper      27745
;  :arith-bound-prop        6258
;  :arith-conflicts         1214
;  :arith-eq-adapter        22303
;  :arith-fixed-eqs         15327
;  :arith-gcd-tests         3
;  :arith-grobner           294
;  :arith-ineq-splits       2
;  :arith-max-min           1922
;  :arith-nonlinear-bounds  233
;  :arith-nonlinear-horner  353
;  :arith-offset-eqs        18911
;  :arith-patches           4
;  :arith-patches_succ      1
;  :arith-pivots            12379
;  :arith-pseudo-nonlinear  60
;  :conflicts               2782
;  :datatype-accessor-ax    416
;  :datatype-constructor-ax 1887
;  :datatype-occurs-check   1126
;  :datatype-splits         1143
;  :decisions               19858
;  :del-clause              131778
;  :final-checks            561
;  :interface-eqs           91
;  :max-generation          14
;  :max-memory              18.34
;  :memory                  17.04
;  :minimized-lits          689
;  :mk-bool-var             163545
;  :mk-clause               131778
;  :num-allocs              996957
;  :num-checks              467
;  :propagations            97477
;  :quant-instantiations    37836
;  :restarts                4
;  :rlimit-count            5562990)
; [then-branch: 319 | exc@208@04 == Null | live]
; [else-branch: 319 | exc@208@04 != Null | dead]
(push) ; 15
; [then-branch: 319 | exc@208@04 == Null]
; [eval] (forall unknown: Int :: { opt_get1(aloc(opt_get1(target), unknown).option$array$) } { opt_get1(aloc(opt_get1(source), unknown).option$array$) } 0 <= unknown && unknown < V ==> (forall unknown1: Int :: { aloc(opt_get1(aloc(opt_get1(target), unknown).option$array$), unknown1) } { aloc(opt_get1(aloc(opt_get1(source), unknown).option$array$), unknown1) } 0 <= unknown1 && unknown1 < V ==> aloc(opt_get1(aloc(opt_get1(target), unknown).option$array$), unknown1).int == aloc(opt_get1(aloc(opt_get1(source), unknown).option$array$), unknown1).int))
(declare-const unknown@259@04 Int)
(push) ; 16
; [eval] 0 <= unknown && unknown < V ==> (forall unknown1: Int :: { aloc(opt_get1(aloc(opt_get1(target), unknown).option$array$), unknown1) } { aloc(opt_get1(aloc(opt_get1(source), unknown).option$array$), unknown1) } 0 <= unknown1 && unknown1 < V ==> aloc(opt_get1(aloc(opt_get1(target), unknown).option$array$), unknown1).int == aloc(opt_get1(aloc(opt_get1(source), unknown).option$array$), unknown1).int)
; [eval] 0 <= unknown && unknown < V
; [eval] 0 <= unknown
(push) ; 17
; [then-branch: 320 | 0 <= unknown@259@04 | live]
; [else-branch: 320 | !(0 <= unknown@259@04) | live]
(push) ; 18
; [then-branch: 320 | 0 <= unknown@259@04]
(assert (<= 0 unknown@259@04))
; [eval] unknown < V
(pop) ; 18
(push) ; 18
; [else-branch: 320 | !(0 <= unknown@259@04)]
(assert (not (<= 0 unknown@259@04)))
(pop) ; 18
(pop) ; 17
; Joined path conditions
; Joined path conditions
(push) ; 17
; [then-branch: 321 | unknown@259@04 < V@28@04 && 0 <= unknown@259@04 | live]
; [else-branch: 321 | !(unknown@259@04 < V@28@04 && 0 <= unknown@259@04) | live]
(push) ; 18
; [then-branch: 321 | unknown@259@04 < V@28@04 && 0 <= unknown@259@04]
(assert (and (< unknown@259@04 V@28@04) (<= 0 unknown@259@04)))
; [eval] (forall unknown1: Int :: { aloc(opt_get1(aloc(opt_get1(target), unknown).option$array$), unknown1) } { aloc(opt_get1(aloc(opt_get1(source), unknown).option$array$), unknown1) } 0 <= unknown1 && unknown1 < V ==> aloc(opt_get1(aloc(opt_get1(target), unknown).option$array$), unknown1).int == aloc(opt_get1(aloc(opt_get1(source), unknown).option$array$), unknown1).int)
(declare-const unknown1@260@04 Int)
(push) ; 19
; [eval] 0 <= unknown1 && unknown1 < V ==> aloc(opt_get1(aloc(opt_get1(target), unknown).option$array$), unknown1).int == aloc(opt_get1(aloc(opt_get1(source), unknown).option$array$), unknown1).int
; [eval] 0 <= unknown1 && unknown1 < V
; [eval] 0 <= unknown1
(push) ; 20
; [then-branch: 322 | 0 <= unknown1@260@04 | live]
; [else-branch: 322 | !(0 <= unknown1@260@04) | live]
(push) ; 21
; [then-branch: 322 | 0 <= unknown1@260@04]
(assert (<= 0 unknown1@260@04))
; [eval] unknown1 < V
(pop) ; 21
(push) ; 21
; [else-branch: 322 | !(0 <= unknown1@260@04)]
(assert (not (<= 0 unknown1@260@04)))
(pop) ; 21
(pop) ; 20
; Joined path conditions
; Joined path conditions
(push) ; 20
; [then-branch: 323 | unknown1@260@04 < V@28@04 && 0 <= unknown1@260@04 | live]
; [else-branch: 323 | !(unknown1@260@04 < V@28@04 && 0 <= unknown1@260@04) | live]
(push) ; 21
; [then-branch: 323 | unknown1@260@04 < V@28@04 && 0 <= unknown1@260@04]
(assert (and (< unknown1@260@04 V@28@04) (<= 0 unknown1@260@04)))
; [eval] aloc(opt_get1(aloc(opt_get1(target), unknown).option$array$), unknown1).int == aloc(opt_get1(aloc(opt_get1(source), unknown).option$array$), unknown1).int
; [eval] aloc(opt_get1(aloc(opt_get1(target), unknown).option$array$), unknown1)
; [eval] opt_get1(aloc(opt_get1(target), unknown).option$array$)
; [eval] aloc(opt_get1(target), unknown)
; [eval] opt_get1(target)
(push) ; 22
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 22
; Joined path conditions
(push) ; 22
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 23
(assert (not (< unknown@259@04 (alen<Int> (opt_get1 $Snap.unit target@27@04)))))
(check-sat)
; unsat
(pop) ; 23
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               129857
;  :arith-add-rows          89337
;  :arith-assert-diseq      7753
;  :arith-assert-lower      41886
;  :arith-assert-upper      27745
;  :arith-bound-prop        6258
;  :arith-conflicts         1215
;  :arith-eq-adapter        22303
;  :arith-fixed-eqs         15327
;  :arith-gcd-tests         3
;  :arith-grobner           294
;  :arith-ineq-splits       2
;  :arith-max-min           1922
;  :arith-nonlinear-bounds  233
;  :arith-nonlinear-horner  353
;  :arith-offset-eqs        18911
;  :arith-patches           4
;  :arith-patches_succ      1
;  :arith-pivots            12379
;  :arith-pseudo-nonlinear  60
;  :conflicts               2783
;  :datatype-accessor-ax    416
;  :datatype-constructor-ax 1887
;  :datatype-occurs-check   1126
;  :datatype-splits         1143
;  :decisions               19858
;  :del-clause              131778
;  :final-checks            561
;  :interface-eqs           91
;  :max-generation          14
;  :max-memory              18.34
;  :memory                  17.04
;  :minimized-lits          689
;  :mk-bool-var             163549
;  :mk-clause               131778
;  :num-allocs              997137
;  :num-checks              468
;  :propagations            97477
;  :quant-instantiations    37836
;  :restarts                4
;  :rlimit-count            5563312)
(assert (< unknown@259@04 (alen<Int> (opt_get1 $Snap.unit target@27@04))))
(pop) ; 22
; Joined path conditions
(assert (< unknown@259@04 (alen<Int> (opt_get1 $Snap.unit target@27@04))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@259@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@259@04)))
(push) ; 22
(assert (not (<
  $Perm.No
  (+
    (ite
      (and
        (<
          (inv@42@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@259@04))
          V@28@04)
        (<=
          0
          (inv@42@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@259@04))))
      $k@41@04
      $Perm.No)
    (ite
      (and
        (<
          (inv@34@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@259@04))
          V@28@04)
        (<=
          0
          (inv@34@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@259@04))))
      $k@33@04
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 22
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               129857
;  :arith-add-rows          89337
;  :arith-assert-diseq      7753
;  :arith-assert-lower      41886
;  :arith-assert-upper      27745
;  :arith-bound-prop        6258
;  :arith-conflicts         1215
;  :arith-eq-adapter        22303
;  :arith-fixed-eqs         15327
;  :arith-gcd-tests         3
;  :arith-grobner           294
;  :arith-ineq-splits       2
;  :arith-max-min           1922
;  :arith-nonlinear-bounds  233
;  :arith-nonlinear-horner  353
;  :arith-offset-eqs        18911
;  :arith-patches           4
;  :arith-patches_succ      1
;  :arith-pivots            12379
;  :arith-pseudo-nonlinear  60
;  :conflicts               2784
;  :datatype-accessor-ax    416
;  :datatype-constructor-ax 1887
;  :datatype-occurs-check   1126
;  :datatype-splits         1143
;  :decisions               19858
;  :del-clause              131788
;  :final-checks            561
;  :interface-eqs           91
;  :max-generation          14
;  :max-memory              18.34
;  :memory                  17.04
;  :minimized-lits          689
;  :mk-bool-var             163561
;  :mk-clause               131788
;  :num-allocs              997350
;  :num-checks              469
;  :propagations            97477
;  :quant-instantiations    37836
;  :restarts                4
;  :rlimit-count            5563795)
(push) ; 22
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 23
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@259@04))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 23
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               129857
;  :arith-add-rows          89337
;  :arith-assert-diseq      7753
;  :arith-assert-lower      41886
;  :arith-assert-upper      27745
;  :arith-bound-prop        6258
;  :arith-conflicts         1215
;  :arith-eq-adapter        22303
;  :arith-fixed-eqs         15327
;  :arith-gcd-tests         3
;  :arith-grobner           294
;  :arith-ineq-splits       2
;  :arith-max-min           1922
;  :arith-nonlinear-bounds  233
;  :arith-nonlinear-horner  353
;  :arith-offset-eqs        18911
;  :arith-patches           4
;  :arith-patches_succ      1
;  :arith-pivots            12379
;  :arith-pseudo-nonlinear  60
;  :conflicts               2785
;  :datatype-accessor-ax    416
;  :datatype-constructor-ax 1887
;  :datatype-occurs-check   1126
;  :datatype-splits         1143
;  :decisions               19858
;  :del-clause              131788
;  :final-checks            561
;  :interface-eqs           91
;  :max-generation          14
;  :max-memory              18.34
;  :memory                  17.04
;  :minimized-lits          689
;  :mk-bool-var             163562
;  :mk-clause               131788
;  :num-allocs              997440
;  :num-checks              470
;  :propagations            97477
;  :quant-instantiations    37836
;  :restarts                4
;  :rlimit-count            5563884)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@259@04))
    (as None<option<array>>  option<array>))))
(pop) ; 22
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@259@04))
    (as None<option<array>>  option<array>))))
(push) ; 22
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 23
(assert (not (<
  unknown1@260@04
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@259@04)))))))
(check-sat)
; unsat
(pop) ; 23
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               129857
;  :arith-add-rows          89337
;  :arith-assert-diseq      7753
;  :arith-assert-lower      41886
;  :arith-assert-upper      27745
;  :arith-bound-prop        6258
;  :arith-conflicts         1215
;  :arith-eq-adapter        22303
;  :arith-fixed-eqs         15327
;  :arith-gcd-tests         3
;  :arith-grobner           294
;  :arith-ineq-splits       2
;  :arith-max-min           1922
;  :arith-nonlinear-bounds  233
;  :arith-nonlinear-horner  353
;  :arith-offset-eqs        18911
;  :arith-patches           4
;  :arith-patches_succ      1
;  :arith-pivots            12379
;  :arith-pseudo-nonlinear  60
;  :conflicts               2786
;  :datatype-accessor-ax    416
;  :datatype-constructor-ax 1887
;  :datatype-occurs-check   1126
;  :datatype-splits         1143
;  :decisions               19858
;  :del-clause              131788
;  :final-checks            561
;  :interface-eqs           91
;  :max-generation          14
;  :max-memory              18.34
;  :memory                  17.04
;  :minimized-lits          689
;  :mk-bool-var             163564
;  :mk-clause               131788
;  :num-allocs              997593
;  :num-checks              471
;  :propagations            97477
;  :quant-instantiations    37836
;  :restarts                4
;  :rlimit-count            5564137)
(assert (<
  unknown1@260@04
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@259@04))))))
(pop) ; 22
; Joined path conditions
(assert (<
  unknown1@260@04
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@259@04))))))
(assert ($FVF.loc_int ($FVF.lookup_int (as sm@221@04  $FVF<Int>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@259@04))) unknown1@260@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@259@04))) unknown1@260@04)))
(push) ; 22
(assert (not (<
  $Perm.No
  (+
    (+
      (ite
        (and
          (and
            (and
              (<
                (inv@220@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@259@04))) unknown1@260@04))
                V@28@04)
              (<=
                0
                (inv@220@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@259@04))) unknown1@260@04))))
            (<
              (inv@219@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@259@04))) unknown1@260@04))
              V@28@04))
          (<=
            0
            (inv@219@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@259@04))) unknown1@260@04))))
        $k@218@04
        $Perm.No)
      (ite
        (and
          (and
            (and
              (<
                (inv@214@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@259@04))) unknown1@260@04))
                V@28@04)
              (<=
                0
                (inv@214@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@259@04))) unknown1@260@04))))
            (<
              (inv@213@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@259@04))) unknown1@260@04))
              V@28@04))
          (<=
            0
            (inv@213@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@259@04))) unknown1@260@04))))
        $Perm.Write
        $Perm.No))
    (-
      (ite
        (and
          (and
            (and
              (<
                (inv@52@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@259@04))) unknown1@260@04))
                V@28@04)
              (<=
                0
                (inv@52@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@259@04))) unknown1@260@04))))
            (<
              (inv@51@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@259@04))) unknown1@260@04))
              V@28@04))
          (<=
            0
            (inv@51@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@259@04))) unknown1@260@04))))
        $k@50@04
        $Perm.No)
      (pTaken@207@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@259@04))) unknown1@260@04)))))))
(check-sat)
; unsat
(pop) ; 22
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               129857
;  :arith-add-rows          89337
;  :arith-assert-diseq      7753
;  :arith-assert-lower      41886
;  :arith-assert-upper      27745
;  :arith-bound-prop        6258
;  :arith-conflicts         1215
;  :arith-eq-adapter        22303
;  :arith-fixed-eqs         15327
;  :arith-gcd-tests         3
;  :arith-grobner           294
;  :arith-ineq-splits       2
;  :arith-max-min           1922
;  :arith-nonlinear-bounds  233
;  :arith-nonlinear-horner  353
;  :arith-offset-eqs        18911
;  :arith-patches           4
;  :arith-patches_succ      1
;  :arith-pivots            12379
;  :arith-pseudo-nonlinear  60
;  :conflicts               2787
;  :datatype-accessor-ax    416
;  :datatype-constructor-ax 1887
;  :datatype-occurs-check   1126
;  :datatype-splits         1143
;  :decisions               19858
;  :del-clause              131818
;  :final-checks            561
;  :interface-eqs           91
;  :max-generation          14
;  :max-memory              18.34
;  :memory                  17.05
;  :minimized-lits          689
;  :mk-bool-var             163598
;  :mk-clause               131818
;  :num-allocs              998029
;  :num-checks              472
;  :propagations            97477
;  :quant-instantiations    37836
;  :restarts                4
;  :rlimit-count            5565554)
; [eval] aloc(opt_get1(aloc(opt_get1(source), unknown).option$array$), unknown1)
; [eval] opt_get1(aloc(opt_get1(source), unknown).option$array$)
; [eval] aloc(opt_get1(source), unknown)
; [eval] opt_get1(source)
(push) ; 22
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 22
; Joined path conditions
(push) ; 22
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 23
(assert (not (< unknown@259@04 (alen<Int> (opt_get1 $Snap.unit source@26@04)))))
(check-sat)
; unsat
(pop) ; 23
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               129857
;  :arith-add-rows          89337
;  :arith-assert-diseq      7753
;  :arith-assert-lower      41886
;  :arith-assert-upper      27745
;  :arith-bound-prop        6258
;  :arith-conflicts         1215
;  :arith-eq-adapter        22303
;  :arith-fixed-eqs         15327
;  :arith-gcd-tests         3
;  :arith-grobner           294
;  :arith-ineq-splits       2
;  :arith-max-min           1922
;  :arith-nonlinear-bounds  233
;  :arith-nonlinear-horner  353
;  :arith-offset-eqs        18911
;  :arith-patches           4
;  :arith-patches_succ      1
;  :arith-pivots            12379
;  :arith-pseudo-nonlinear  60
;  :conflicts               2787
;  :datatype-accessor-ax    416
;  :datatype-constructor-ax 1887
;  :datatype-occurs-check   1126
;  :datatype-splits         1143
;  :decisions               19858
;  :del-clause              131818
;  :final-checks            561
;  :interface-eqs           91
;  :max-generation          14
;  :max-memory              18.34
;  :memory                  17.05
;  :minimized-lits          689
;  :mk-bool-var             163598
;  :mk-clause               131818
;  :num-allocs              998056
;  :num-checks              473
;  :propagations            97477
;  :quant-instantiations    37836
;  :restarts                4
;  :rlimit-count            5565575)
(assert (< unknown@259@04 (alen<Int> (opt_get1 $Snap.unit source@26@04))))
(pop) ; 22
; Joined path conditions
(assert (< unknown@259@04 (alen<Int> (opt_get1 $Snap.unit source@26@04))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@259@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@259@04)))
(push) ; 22
(assert (not (<
  $Perm.No
  (+
    (ite
      (and
        (<
          (inv@42@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@259@04))
          V@28@04)
        (<=
          0
          (inv@42@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@259@04))))
      $k@41@04
      $Perm.No)
    (ite
      (and
        (<
          (inv@34@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@259@04))
          V@28@04)
        (<=
          0
          (inv@34@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@259@04))))
      $k@33@04
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 22
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               129857
;  :arith-add-rows          89337
;  :arith-assert-diseq      7753
;  :arith-assert-lower      41886
;  :arith-assert-upper      27745
;  :arith-bound-prop        6258
;  :arith-conflicts         1215
;  :arith-eq-adapter        22303
;  :arith-fixed-eqs         15327
;  :arith-gcd-tests         3
;  :arith-grobner           294
;  :arith-ineq-splits       2
;  :arith-max-min           1922
;  :arith-nonlinear-bounds  233
;  :arith-nonlinear-horner  353
;  :arith-offset-eqs        18911
;  :arith-patches           4
;  :arith-patches_succ      1
;  :arith-pivots            12379
;  :arith-pseudo-nonlinear  60
;  :conflicts               2788
;  :datatype-accessor-ax    416
;  :datatype-constructor-ax 1887
;  :datatype-occurs-check   1126
;  :datatype-splits         1143
;  :decisions               19858
;  :del-clause              131828
;  :final-checks            561
;  :interface-eqs           91
;  :max-generation          14
;  :max-memory              18.34
;  :memory                  17.05
;  :minimized-lits          689
;  :mk-bool-var             163610
;  :mk-clause               131828
;  :num-allocs              998265
;  :num-checks              474
;  :propagations            97477
;  :quant-instantiations    37836
;  :restarts                4
;  :rlimit-count            5566058)
(push) ; 22
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 23
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@259@04))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 23
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               129857
;  :arith-add-rows          89337
;  :arith-assert-diseq      7753
;  :arith-assert-lower      41886
;  :arith-assert-upper      27745
;  :arith-bound-prop        6258
;  :arith-conflicts         1215
;  :arith-eq-adapter        22303
;  :arith-fixed-eqs         15327
;  :arith-gcd-tests         3
;  :arith-grobner           294
;  :arith-ineq-splits       2
;  :arith-max-min           1922
;  :arith-nonlinear-bounds  233
;  :arith-nonlinear-horner  353
;  :arith-offset-eqs        18911
;  :arith-patches           4
;  :arith-patches_succ      1
;  :arith-pivots            12379
;  :arith-pseudo-nonlinear  60
;  :conflicts               2789
;  :datatype-accessor-ax    416
;  :datatype-constructor-ax 1887
;  :datatype-occurs-check   1126
;  :datatype-splits         1143
;  :decisions               19858
;  :del-clause              131828
;  :final-checks            561
;  :interface-eqs           91
;  :max-generation          14
;  :max-memory              18.34
;  :memory                  17.05
;  :minimized-lits          689
;  :mk-bool-var             163611
;  :mk-clause               131828
;  :num-allocs              998355
;  :num-checks              475
;  :propagations            97477
;  :quant-instantiations    37836
;  :restarts                4
;  :rlimit-count            5566147)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@259@04))
    (as None<option<array>>  option<array>))))
(pop) ; 22
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@259@04))
    (as None<option<array>>  option<array>))))
(push) ; 22
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 23
(assert (not (<
  unknown1@260@04
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@259@04)))))))
(check-sat)
; unsat
(pop) ; 23
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               129857
;  :arith-add-rows          89337
;  :arith-assert-diseq      7753
;  :arith-assert-lower      41886
;  :arith-assert-upper      27745
;  :arith-bound-prop        6258
;  :arith-conflicts         1215
;  :arith-eq-adapter        22303
;  :arith-fixed-eqs         15327
;  :arith-gcd-tests         3
;  :arith-grobner           294
;  :arith-ineq-splits       2
;  :arith-max-min           1922
;  :arith-nonlinear-bounds  233
;  :arith-nonlinear-horner  353
;  :arith-offset-eqs        18911
;  :arith-patches           4
;  :arith-patches_succ      1
;  :arith-pivots            12379
;  :arith-pseudo-nonlinear  60
;  :conflicts               2790
;  :datatype-accessor-ax    416
;  :datatype-constructor-ax 1887
;  :datatype-occurs-check   1126
;  :datatype-splits         1143
;  :decisions               19858
;  :del-clause              131828
;  :final-checks            561
;  :interface-eqs           91
;  :max-generation          14
;  :max-memory              18.34
;  :memory                  17.05
;  :minimized-lits          689
;  :mk-bool-var             163613
;  :mk-clause               131828
;  :num-allocs              998509
;  :num-checks              476
;  :propagations            97477
;  :quant-instantiations    37836
;  :restarts                4
;  :rlimit-count            5566400)
(assert (<
  unknown1@260@04
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@259@04))))))
(pop) ; 22
; Joined path conditions
(assert (<
  unknown1@260@04
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@259@04))))))
(assert ($FVF.loc_int ($FVF.lookup_int (as sm@221@04  $FVF<Int>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@259@04))) unknown1@260@04)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@259@04))) unknown1@260@04)))
(push) ; 22
(assert (not (<
  $Perm.No
  (+
    (+
      (ite
        (and
          (and
            (and
              (<
                (inv@220@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@259@04))) unknown1@260@04))
                V@28@04)
              (<=
                0
                (inv@220@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@259@04))) unknown1@260@04))))
            (<
              (inv@219@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@259@04))) unknown1@260@04))
              V@28@04))
          (<=
            0
            (inv@219@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@259@04))) unknown1@260@04))))
        $k@218@04
        $Perm.No)
      (ite
        (and
          (and
            (and
              (<
                (inv@214@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@259@04))) unknown1@260@04))
                V@28@04)
              (<=
                0
                (inv@214@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@259@04))) unknown1@260@04))))
            (<
              (inv@213@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@259@04))) unknown1@260@04))
              V@28@04))
          (<=
            0
            (inv@213@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@259@04))) unknown1@260@04))))
        $Perm.Write
        $Perm.No))
    (-
      (ite
        (and
          (and
            (and
              (<
                (inv@52@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@259@04))) unknown1@260@04))
                V@28@04)
              (<=
                0
                (inv@52@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@259@04))) unknown1@260@04))))
            (<
              (inv@51@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@259@04))) unknown1@260@04))
              V@28@04))
          (<=
            0
            (inv@51@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@259@04))) unknown1@260@04))))
        $k@50@04
        $Perm.No)
      (pTaken@207@04 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@259@04))) unknown1@260@04)))))))
(check-sat)
; unsat
(pop) ; 22
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               129857
;  :arith-add-rows          89337
;  :arith-assert-diseq      7753
;  :arith-assert-lower      41886
;  :arith-assert-upper      27745
;  :arith-bound-prop        6258
;  :arith-conflicts         1215
;  :arith-eq-adapter        22303
;  :arith-fixed-eqs         15327
;  :arith-gcd-tests         3
;  :arith-grobner           294
;  :arith-ineq-splits       2
;  :arith-max-min           1922
;  :arith-nonlinear-bounds  233
;  :arith-nonlinear-horner  353
;  :arith-offset-eqs        18911
;  :arith-patches           4
;  :arith-patches_succ      1
;  :arith-pivots            12379
;  :arith-pseudo-nonlinear  60
;  :conflicts               2791
;  :datatype-accessor-ax    416
;  :datatype-constructor-ax 1887
;  :datatype-occurs-check   1126
;  :datatype-splits         1143
;  :decisions               19858
;  :del-clause              131858
;  :final-checks            561
;  :interface-eqs           91
;  :max-generation          14
;  :max-memory              18.34
;  :memory                  17.05
;  :minimized-lits          689
;  :mk-bool-var             163647
;  :mk-clause               131858
;  :num-allocs              998923
;  :num-checks              477
;  :propagations            97477
;  :quant-instantiations    37836
;  :restarts                4
;  :rlimit-count            5567809)
(pop) ; 21
(push) ; 21
; [else-branch: 323 | !(unknown1@260@04 < V@28@04 && 0 <= unknown1@260@04)]
(assert (not (and (< unknown1@260@04 V@28@04) (<= 0 unknown1@260@04))))
(pop) ; 21
(pop) ; 20
; Joined path conditions
(assert (implies
  (and (< unknown1@260@04 V@28@04) (<= 0 unknown1@260@04))
  (and
    (< unknown1@260@04 V@28@04)
    (<= 0 unknown1@260@04)
    (< unknown@259@04 (alen<Int> (opt_get1 $Snap.unit target@27@04)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@259@04)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@259@04))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@259@04))
        (as None<option<array>>  option<array>)))
    (<
      unknown1@260@04
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@259@04)))))
    ($FVF.loc_int ($FVF.lookup_int (as sm@221@04  $FVF<Int>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@259@04))) unknown1@260@04)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@259@04))) unknown1@260@04))
    (< unknown@259@04 (alen<Int> (opt_get1 $Snap.unit source@26@04)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@259@04)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@259@04))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@259@04))
        (as None<option<array>>  option<array>)))
    (<
      unknown1@260@04
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@259@04)))))
    ($FVF.loc_int ($FVF.lookup_int (as sm@221@04  $FVF<Int>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@259@04))) unknown1@260@04)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@259@04))) unknown1@260@04)))))
; Joined path conditions
(pop) ; 19
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((unknown1@260@04 Int)) (!
  (implies
    (and (< unknown1@260@04 V@28@04) (<= 0 unknown1@260@04))
    (and
      (< unknown1@260@04 V@28@04)
      (<= 0 unknown1@260@04)
      (< unknown@259@04 (alen<Int> (opt_get1 $Snap.unit target@27@04)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@259@04)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@259@04))
      (not
        (=
          ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@259@04))
          (as None<option<array>>  option<array>)))
      (<
        unknown1@260@04
        (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@259@04)))))
      ($FVF.loc_int ($FVF.lookup_int (as sm@221@04  $FVF<Int>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@259@04))) unknown1@260@04)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@259@04))) unknown1@260@04))
      (< unknown@259@04 (alen<Int> (opt_get1 $Snap.unit source@26@04)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@259@04)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@259@04))
      (not
        (=
          ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@259@04))
          (as None<option<array>>  option<array>)))
      (<
        unknown1@260@04
        (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@259@04)))))
      ($FVF.loc_int ($FVF.lookup_int (as sm@221@04  $FVF<Int>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@259@04))) unknown1@260@04)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@259@04))) unknown1@260@04))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@259@04))) unknown1@260@04))
  :qid |prog.l<no position>-aux|)))
(assert (forall ((unknown1@260@04 Int)) (!
  (implies
    (and (< unknown1@260@04 V@28@04) (<= 0 unknown1@260@04))
    (and
      (< unknown1@260@04 V@28@04)
      (<= 0 unknown1@260@04)
      (< unknown@259@04 (alen<Int> (opt_get1 $Snap.unit target@27@04)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@259@04)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@259@04))
      (not
        (=
          ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@259@04))
          (as None<option<array>>  option<array>)))
      (<
        unknown1@260@04
        (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@259@04)))))
      ($FVF.loc_int ($FVF.lookup_int (as sm@221@04  $FVF<Int>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@259@04))) unknown1@260@04)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@259@04))) unknown1@260@04))
      (< unknown@259@04 (alen<Int> (opt_get1 $Snap.unit source@26@04)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@259@04)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@259@04))
      (not
        (=
          ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@259@04))
          (as None<option<array>>  option<array>)))
      (<
        unknown1@260@04
        (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@259@04)))))
      ($FVF.loc_int ($FVF.lookup_int (as sm@221@04  $FVF<Int>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@259@04))) unknown1@260@04)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@259@04))) unknown1@260@04))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@259@04))) unknown1@260@04))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 18
(push) ; 18
; [else-branch: 321 | !(unknown@259@04 < V@28@04 && 0 <= unknown@259@04)]
(assert (not (and (< unknown@259@04 V@28@04) (<= 0 unknown@259@04))))
(pop) ; 18
(pop) ; 17
; Joined path conditions
(assert (implies
  (and (< unknown@259@04 V@28@04) (<= 0 unknown@259@04))
  (and
    (< unknown@259@04 V@28@04)
    (<= 0 unknown@259@04)
    (forall ((unknown1@260@04 Int)) (!
      (implies
        (and (< unknown1@260@04 V@28@04) (<= 0 unknown1@260@04))
        (and
          (< unknown1@260@04 V@28@04)
          (<= 0 unknown1@260@04)
          (< unknown@259@04 (alen<Int> (opt_get1 $Snap.unit target@27@04)))
          ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@259@04)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@259@04))
          (not
            (=
              ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@259@04))
              (as None<option<array>>  option<array>)))
          (<
            unknown1@260@04
            (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@259@04)))))
          ($FVF.loc_int ($FVF.lookup_int (as sm@221@04  $FVF<Int>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@259@04))) unknown1@260@04)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@259@04))) unknown1@260@04))
          (< unknown@259@04 (alen<Int> (opt_get1 $Snap.unit source@26@04)))
          ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@259@04)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@259@04))
          (not
            (=
              ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@259@04))
              (as None<option<array>>  option<array>)))
          (<
            unknown1@260@04
            (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@259@04)))))
          ($FVF.loc_int ($FVF.lookup_int (as sm@221@04  $FVF<Int>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@259@04))) unknown1@260@04)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@259@04))) unknown1@260@04))))
      :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@259@04))) unknown1@260@04))
      :qid |prog.l<no position>-aux|))
    (forall ((unknown1@260@04 Int)) (!
      (implies
        (and (< unknown1@260@04 V@28@04) (<= 0 unknown1@260@04))
        (and
          (< unknown1@260@04 V@28@04)
          (<= 0 unknown1@260@04)
          (< unknown@259@04 (alen<Int> (opt_get1 $Snap.unit target@27@04)))
          ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@259@04)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@259@04))
          (not
            (=
              ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@259@04))
              (as None<option<array>>  option<array>)))
          (<
            unknown1@260@04
            (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@259@04)))))
          ($FVF.loc_int ($FVF.lookup_int (as sm@221@04  $FVF<Int>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@259@04))) unknown1@260@04)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@259@04))) unknown1@260@04))
          (< unknown@259@04 (alen<Int> (opt_get1 $Snap.unit source@26@04)))
          ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@259@04)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@259@04))
          (not
            (=
              ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@259@04))
              (as None<option<array>>  option<array>)))
          (<
            unknown1@260@04
            (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@259@04)))))
          ($FVF.loc_int ($FVF.lookup_int (as sm@221@04  $FVF<Int>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@259@04))) unknown1@260@04)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@259@04))) unknown1@260@04))))
      :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@259@04))) unknown1@260@04))
      :qid |prog.l<no position>-aux|)))))
; Joined path conditions
(pop) ; 16
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((unknown@259@04 Int)) (!
  (implies
    (and (< unknown@259@04 V@28@04) (<= 0 unknown@259@04))
    (and
      (< unknown@259@04 V@28@04)
      (<= 0 unknown@259@04)
      (forall ((unknown1@260@04 Int)) (!
        (implies
          (and (< unknown1@260@04 V@28@04) (<= 0 unknown1@260@04))
          (and
            (< unknown1@260@04 V@28@04)
            (<= 0 unknown1@260@04)
            (< unknown@259@04 (alen<Int> (opt_get1 $Snap.unit target@27@04)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@259@04)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@259@04))
            (not
              (=
                ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@259@04))
                (as None<option<array>>  option<array>)))
            (<
              unknown1@260@04
              (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@259@04)))))
            ($FVF.loc_int ($FVF.lookup_int (as sm@221@04  $FVF<Int>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@259@04))) unknown1@260@04)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@259@04))) unknown1@260@04))
            (< unknown@259@04 (alen<Int> (opt_get1 $Snap.unit source@26@04)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@259@04)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@259@04))
            (not
              (=
                ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@259@04))
                (as None<option<array>>  option<array>)))
            (<
              unknown1@260@04
              (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@259@04)))))
            ($FVF.loc_int ($FVF.lookup_int (as sm@221@04  $FVF<Int>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@259@04))) unknown1@260@04)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@259@04))) unknown1@260@04))))
        :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@259@04))) unknown1@260@04))
        :qid |prog.l<no position>-aux|))
      (forall ((unknown1@260@04 Int)) (!
        (implies
          (and (< unknown1@260@04 V@28@04) (<= 0 unknown1@260@04))
          (and
            (< unknown1@260@04 V@28@04)
            (<= 0 unknown1@260@04)
            (< unknown@259@04 (alen<Int> (opt_get1 $Snap.unit target@27@04)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@259@04)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@259@04))
            (not
              (=
                ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@259@04))
                (as None<option<array>>  option<array>)))
            (<
              unknown1@260@04
              (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@259@04)))))
            ($FVF.loc_int ($FVF.lookup_int (as sm@221@04  $FVF<Int>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@259@04))) unknown1@260@04)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@259@04))) unknown1@260@04))
            (< unknown@259@04 (alen<Int> (opt_get1 $Snap.unit source@26@04)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@259@04)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@259@04))
            (not
              (=
                ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@259@04))
                (as None<option<array>>  option<array>)))
            (<
              unknown1@260@04
              (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@259@04)))))
            ($FVF.loc_int ($FVF.lookup_int (as sm@221@04  $FVF<Int>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@259@04))) unknown1@260@04)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@259@04))) unknown1@260@04))))
        :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@259@04))) unknown1@260@04))
        :qid |prog.l<no position>-aux|))))
  :pattern ((opt_get1%limited $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@259@04))))
  :qid |prog.l<no position>-aux|)))
(assert (forall ((unknown@259@04 Int)) (!
  (implies
    (and (< unknown@259@04 V@28@04) (<= 0 unknown@259@04))
    (and
      (< unknown@259@04 V@28@04)
      (<= 0 unknown@259@04)
      (forall ((unknown1@260@04 Int)) (!
        (implies
          (and (< unknown1@260@04 V@28@04) (<= 0 unknown1@260@04))
          (and
            (< unknown1@260@04 V@28@04)
            (<= 0 unknown1@260@04)
            (< unknown@259@04 (alen<Int> (opt_get1 $Snap.unit target@27@04)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@259@04)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@259@04))
            (not
              (=
                ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@259@04))
                (as None<option<array>>  option<array>)))
            (<
              unknown1@260@04
              (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@259@04)))))
            ($FVF.loc_int ($FVF.lookup_int (as sm@221@04  $FVF<Int>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@259@04))) unknown1@260@04)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@259@04))) unknown1@260@04))
            (< unknown@259@04 (alen<Int> (opt_get1 $Snap.unit source@26@04)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@259@04)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@259@04))
            (not
              (=
                ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@259@04))
                (as None<option<array>>  option<array>)))
            (<
              unknown1@260@04
              (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@259@04)))))
            ($FVF.loc_int ($FVF.lookup_int (as sm@221@04  $FVF<Int>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@259@04))) unknown1@260@04)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@259@04))) unknown1@260@04))))
        :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@259@04))) unknown1@260@04))
        :qid |prog.l<no position>-aux|))
      (forall ((unknown1@260@04 Int)) (!
        (implies
          (and (< unknown1@260@04 V@28@04) (<= 0 unknown1@260@04))
          (and
            (< unknown1@260@04 V@28@04)
            (<= 0 unknown1@260@04)
            (< unknown@259@04 (alen<Int> (opt_get1 $Snap.unit target@27@04)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@259@04)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@259@04))
            (not
              (=
                ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@259@04))
                (as None<option<array>>  option<array>)))
            (<
              unknown1@260@04
              (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@259@04)))))
            ($FVF.loc_int ($FVF.lookup_int (as sm@221@04  $FVF<Int>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@259@04))) unknown1@260@04)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@259@04))) unknown1@260@04))
            (< unknown@259@04 (alen<Int> (opt_get1 $Snap.unit source@26@04)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@259@04)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@259@04))
            (not
              (=
                ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@259@04))
                (as None<option<array>>  option<array>)))
            (<
              unknown1@260@04
              (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@259@04)))))
            ($FVF.loc_int ($FVF.lookup_int (as sm@221@04  $FVF<Int>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@259@04))) unknown1@260@04)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@259@04))) unknown1@260@04))))
        :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@259@04))) unknown1@260@04))
        :qid |prog.l<no position>-aux|))))
  :pattern ((opt_get1%limited $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@259@04))))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 15
(pop) ; 14
; Joined path conditions
(assert (implies
  (= exc@208@04 $Ref.null)
  (and
    (forall ((unknown@259@04 Int)) (!
      (implies
        (and (< unknown@259@04 V@28@04) (<= 0 unknown@259@04))
        (and
          (< unknown@259@04 V@28@04)
          (<= 0 unknown@259@04)
          (forall ((unknown1@260@04 Int)) (!
            (implies
              (and (< unknown1@260@04 V@28@04) (<= 0 unknown1@260@04))
              (and
                (< unknown1@260@04 V@28@04)
                (<= 0 unknown1@260@04)
                (< unknown@259@04 (alen<Int> (opt_get1 $Snap.unit target@27@04)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@259@04)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@259@04))
                (not
                  (=
                    ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@259@04))
                    (as None<option<array>>  option<array>)))
                (<
                  unknown1@260@04
                  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@259@04)))))
                ($FVF.loc_int ($FVF.lookup_int (as sm@221@04  $FVF<Int>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@259@04))) unknown1@260@04)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@259@04))) unknown1@260@04))
                (< unknown@259@04 (alen<Int> (opt_get1 $Snap.unit source@26@04)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@259@04)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@259@04))
                (not
                  (=
                    ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@259@04))
                    (as None<option<array>>  option<array>)))
                (<
                  unknown1@260@04
                  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@259@04)))))
                ($FVF.loc_int ($FVF.lookup_int (as sm@221@04  $FVF<Int>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@259@04))) unknown1@260@04)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@259@04))) unknown1@260@04))))
            :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@259@04))) unknown1@260@04))
            :qid |prog.l<no position>-aux|))
          (forall ((unknown1@260@04 Int)) (!
            (implies
              (and (< unknown1@260@04 V@28@04) (<= 0 unknown1@260@04))
              (and
                (< unknown1@260@04 V@28@04)
                (<= 0 unknown1@260@04)
                (< unknown@259@04 (alen<Int> (opt_get1 $Snap.unit target@27@04)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@259@04)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@259@04))
                (not
                  (=
                    ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@259@04))
                    (as None<option<array>>  option<array>)))
                (<
                  unknown1@260@04
                  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@259@04)))))
                ($FVF.loc_int ($FVF.lookup_int (as sm@221@04  $FVF<Int>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@259@04))) unknown1@260@04)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@259@04))) unknown1@260@04))
                (< unknown@259@04 (alen<Int> (opt_get1 $Snap.unit source@26@04)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@259@04)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@259@04))
                (not
                  (=
                    ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@259@04))
                    (as None<option<array>>  option<array>)))
                (<
                  unknown1@260@04
                  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@259@04)))))
                ($FVF.loc_int ($FVF.lookup_int (as sm@221@04  $FVF<Int>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@259@04))) unknown1@260@04)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@259@04))) unknown1@260@04))))
            :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@259@04))) unknown1@260@04))
            :qid |prog.l<no position>-aux|))))
      :pattern ((opt_get1%limited $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@259@04))))
      :qid |prog.l<no position>-aux|))
    (forall ((unknown@259@04 Int)) (!
      (implies
        (and (< unknown@259@04 V@28@04) (<= 0 unknown@259@04))
        (and
          (< unknown@259@04 V@28@04)
          (<= 0 unknown@259@04)
          (forall ((unknown1@260@04 Int)) (!
            (implies
              (and (< unknown1@260@04 V@28@04) (<= 0 unknown1@260@04))
              (and
                (< unknown1@260@04 V@28@04)
                (<= 0 unknown1@260@04)
                (< unknown@259@04 (alen<Int> (opt_get1 $Snap.unit target@27@04)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@259@04)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@259@04))
                (not
                  (=
                    ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@259@04))
                    (as None<option<array>>  option<array>)))
                (<
                  unknown1@260@04
                  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@259@04)))))
                ($FVF.loc_int ($FVF.lookup_int (as sm@221@04  $FVF<Int>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@259@04))) unknown1@260@04)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@259@04))) unknown1@260@04))
                (< unknown@259@04 (alen<Int> (opt_get1 $Snap.unit source@26@04)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@259@04)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@259@04))
                (not
                  (=
                    ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@259@04))
                    (as None<option<array>>  option<array>)))
                (<
                  unknown1@260@04
                  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@259@04)))))
                ($FVF.loc_int ($FVF.lookup_int (as sm@221@04  $FVF<Int>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@259@04))) unknown1@260@04)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@259@04))) unknown1@260@04))))
            :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@259@04))) unknown1@260@04))
            :qid |prog.l<no position>-aux|))
          (forall ((unknown1@260@04 Int)) (!
            (implies
              (and (< unknown1@260@04 V@28@04) (<= 0 unknown1@260@04))
              (and
                (< unknown1@260@04 V@28@04)
                (<= 0 unknown1@260@04)
                (< unknown@259@04 (alen<Int> (opt_get1 $Snap.unit target@27@04)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@259@04)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@259@04))
                (not
                  (=
                    ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@259@04))
                    (as None<option<array>>  option<array>)))
                (<
                  unknown1@260@04
                  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@259@04)))))
                ($FVF.loc_int ($FVF.lookup_int (as sm@221@04  $FVF<Int>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@259@04))) unknown1@260@04)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@259@04))) unknown1@260@04))
                (< unknown@259@04 (alen<Int> (opt_get1 $Snap.unit source@26@04)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@259@04)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@259@04))
                (not
                  (=
                    ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@259@04))
                    (as None<option<array>>  option<array>)))
                (<
                  unknown1@260@04
                  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@259@04)))))
                ($FVF.loc_int ($FVF.lookup_int (as sm@221@04  $FVF<Int>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@259@04))) unknown1@260@04)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@259@04))) unknown1@260@04))))
            :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@259@04))) unknown1@260@04))
            :qid |prog.l<no position>-aux|))))
      :pattern ((opt_get1%limited $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@259@04))))
      :qid |prog.l<no position>-aux|)))))
(push) ; 14
(assert (not (implies
  (= exc@208@04 $Ref.null)
  (forall ((unknown@259@04 Int)) (!
    (implies
      (and (< unknown@259@04 V@28@04) (<= 0 unknown@259@04))
      (forall ((unknown1@260@04 Int)) (!
        (implies
          (and (< unknown1@260@04 V@28@04) (<= 0 unknown1@260@04))
          (=
            ($FVF.lookup_int (as sm@221@04  $FVF<Int>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@259@04))) unknown1@260@04))
            ($FVF.lookup_int (as sm@221@04  $FVF<Int>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@259@04))) unknown1@260@04))))
        :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@259@04))) unknown1@260@04))
        :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@259@04))) unknown1@260@04))
        :qid |prog.l<no position>|)))
    :pattern ((opt_get1%limited $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@259@04))))
    :pattern ((opt_get1%limited $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@259@04))))
    :qid |prog.l<no position>|)))))
(check-sat)
; unsat
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               129857
;  :arith-add-rows          89337
;  :arith-assert-diseq      7753
;  :arith-assert-lower      41890
;  :arith-assert-upper      27745
;  :arith-bound-prop        6258
;  :arith-conflicts         1216
;  :arith-eq-adapter        22303
;  :arith-fixed-eqs         15327
;  :arith-gcd-tests         3
;  :arith-grobner           294
;  :arith-ineq-splits       2
;  :arith-max-min           1922
;  :arith-nonlinear-bounds  233
;  :arith-nonlinear-horner  353
;  :arith-offset-eqs        18911
;  :arith-patches           4
;  :arith-patches_succ      1
;  :arith-pivots            12381
;  :arith-pseudo-nonlinear  60
;  :conflicts               2792
;  :datatype-accessor-ax    416
;  :datatype-constructor-ax 1887
;  :datatype-occurs-check   1126
;  :datatype-splits         1143
;  :decisions               19858
;  :del-clause              131858
;  :final-checks            561
;  :interface-eqs           91
;  :max-generation          14
;  :max-memory              18.34
;  :memory                  17.04
;  :minimized-lits          689
;  :mk-bool-var             163654
;  :mk-clause               131858
;  :num-allocs              1000945
;  :num-checks              478
;  :propagations            97477
;  :quant-instantiations    37836
;  :restarts                4
;  :rlimit-count            5573358)
(assert (implies
  (= exc@208@04 $Ref.null)
  (forall ((unknown@259@04 Int)) (!
    (implies
      (and (< unknown@259@04 V@28@04) (<= 0 unknown@259@04))
      (forall ((unknown1@260@04 Int)) (!
        (implies
          (and (< unknown1@260@04 V@28@04) (<= 0 unknown1@260@04))
          (=
            ($FVF.lookup_int (as sm@221@04  $FVF<Int>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@259@04))) unknown1@260@04))
            ($FVF.lookup_int (as sm@221@04  $FVF<Int>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@259@04))) unknown1@260@04))))
        :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@259@04))) unknown1@260@04))
        :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@259@04))) unknown1@260@04))
        :qid |prog.l<no position>|)))
    :pattern ((opt_get1%limited $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@27@04) unknown@259@04))))
    :pattern ((opt_get1%limited $Snap.unit ($FVF.lookup_option$array$ (as sm@43@04  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@26@04) unknown@259@04))))
    :qid |prog.l<no position>|))))
(pop) ; 13
(pop) ; 12
(pop) ; 11
(pop) ; 10
(pop) ; 9
(pop) ; 8
(pop) ; 7
(pop) ; 6
(pop) ; 5
(pop) ; 4
(pop) ; 3
(pop) ; 2
(pop) ; 1
