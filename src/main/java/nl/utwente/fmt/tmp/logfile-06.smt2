(get-info :version)
; (:version "4.8.6")
; Started: 2022-06-09 19:28:09
; Silicon.version: 1.1-SNAPSHOT (cd20cf02@(detached))
; Input file: -
; Verifier id: 00
; ------------------------------------------------------------
; Begin preamble
; ////////// Static preamble
; 
; ; /z3config.smt2
(set-option :print-success true) ; Boogie: false
(set-option :global-decls true) ; Boogie: default
(set-option :auto_config false) ; Usually a good idea
(set-option :smt.restart_strategy 0)
(set-option :smt.restart_factor |1.5|)
(set-option :smt.case_split 3)
(set-option :smt.delay_units true)
(set-option :smt.delay_units_threshold 16)
(set-option :nnf.sk_hack true)
(set-option :type_check true)
(set-option :smt.bv.reflect true)
(set-option :smt.mbqi false)
(set-option :smt.qi.eager_threshold 100)
(set-option :smt.qi.cost "(+ weight generation)")
(set-option :smt.qi.max_multi_patterns 1000)
(set-option :smt.phase_selection 0) ; default: 3, Boogie: 0
(set-option :sat.phase caching)
(set-option :sat.random_seed 0)
(set-option :nlsat.randomize true)
(set-option :nlsat.seed 0)
(set-option :nlsat.shuffle_vars false)
(set-option :fp.spacer.order_children 0) ; Not available with Z3 4.5
(set-option :fp.spacer.random_seed 0) ; Not available with Z3 4.5
(set-option :smt.arith.random_initial_value true) ; Boogie: true
(set-option :smt.random_seed 0)
(set-option :sls.random_offset true)
(set-option :sls.random_seed 0)
(set-option :sls.restart_init false)
(set-option :sls.walksat_ucb true)
(set-option :model.v2 true)
; 
; ; /preamble.smt2
(declare-datatypes () ((
    $Snap ($Snap.unit)
    ($Snap.combine ($Snap.first $Snap) ($Snap.second $Snap)))))
(declare-sort $Ref 0)
(declare-const $Ref.null $Ref)
(declare-sort $FPM)
(declare-sort $PPM)
(define-sort $Perm () Real)
(define-const $Perm.Write $Perm 1.0)
(define-const $Perm.No $Perm 0.0)
(define-fun $Perm.isValidVar ((p $Perm)) Bool
	(<= $Perm.No p))
(define-fun $Perm.isReadVar ((p $Perm) (ub $Perm)) Bool
    (and ($Perm.isValidVar p)
         (not (= p $Perm.No))
         (< p $Perm.Write)))
(define-fun $Perm.min ((p1 $Perm) (p2 $Perm)) Real
    (ite (<= p1 p2) p1 p2))
(define-fun $Math.min ((a Int) (b Int)) Int
    (ite (<= a b) a b))
(define-fun $Math.clip ((a Int)) Int
    (ite (< a 0) 0 a))
; ////////// Sorts
(declare-sort Seq<Int>)
(declare-sort Set<option<array>>)
(declare-sort Set<Bool>)
(declare-sort Set<Int>)
(declare-sort Set<$Ref>)
(declare-sort Set<$Snap>)
(declare-sort t_null)
(declare-sort any)
(declare-sort void)
(declare-sort option<any>)
(declare-sort option<array>)
(declare-sort array)
(declare-sort $FVF<Int>)
(declare-sort $FVF<option<array>>)
(declare-sort $FVF<Bool>)
(declare-sort $FVF<$Ref>)
; ////////// Sort wrappers
; Declaring additional sort wrappers
(declare-fun $SortWrappers.IntTo$Snap (Int) $Snap)
(declare-fun $SortWrappers.$SnapToInt ($Snap) Int)
(assert (forall ((x Int)) (!
    (= x ($SortWrappers.$SnapToInt($SortWrappers.IntTo$Snap x)))
    :pattern (($SortWrappers.IntTo$Snap x))
    :qid |$Snap.$SnapToIntTo$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.IntTo$Snap($SortWrappers.$SnapToInt x)))
    :pattern (($SortWrappers.$SnapToInt x))
    :qid |$Snap.IntTo$SnapToInt|
    )))
(declare-fun $SortWrappers.BoolTo$Snap (Bool) $Snap)
(declare-fun $SortWrappers.$SnapToBool ($Snap) Bool)
(assert (forall ((x Bool)) (!
    (= x ($SortWrappers.$SnapToBool($SortWrappers.BoolTo$Snap x)))
    :pattern (($SortWrappers.BoolTo$Snap x))
    :qid |$Snap.$SnapToBoolTo$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.BoolTo$Snap($SortWrappers.$SnapToBool x)))
    :pattern (($SortWrappers.$SnapToBool x))
    :qid |$Snap.BoolTo$SnapToBool|
    )))
(declare-fun $SortWrappers.$RefTo$Snap ($Ref) $Snap)
(declare-fun $SortWrappers.$SnapTo$Ref ($Snap) $Ref)
(assert (forall ((x $Ref)) (!
    (= x ($SortWrappers.$SnapTo$Ref($SortWrappers.$RefTo$Snap x)))
    :pattern (($SortWrappers.$RefTo$Snap x))
    :qid |$Snap.$SnapTo$RefTo$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.$RefTo$Snap($SortWrappers.$SnapTo$Ref x)))
    :pattern (($SortWrappers.$SnapTo$Ref x))
    :qid |$Snap.$RefTo$SnapTo$Ref|
    )))
(declare-fun $SortWrappers.$PermTo$Snap ($Perm) $Snap)
(declare-fun $SortWrappers.$SnapTo$Perm ($Snap) $Perm)
(assert (forall ((x $Perm)) (!
    (= x ($SortWrappers.$SnapTo$Perm($SortWrappers.$PermTo$Snap x)))
    :pattern (($SortWrappers.$PermTo$Snap x))
    :qid |$Snap.$SnapTo$PermTo$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.$PermTo$Snap($SortWrappers.$SnapTo$Perm x)))
    :pattern (($SortWrappers.$SnapTo$Perm x))
    :qid |$Snap.$PermTo$SnapTo$Perm|
    )))
; Declaring additional sort wrappers
(declare-fun $SortWrappers.Seq<Int>To$Snap (Seq<Int>) $Snap)
(declare-fun $SortWrappers.$SnapToSeq<Int> ($Snap) Seq<Int>)
(assert (forall ((x Seq<Int>)) (!
    (= x ($SortWrappers.$SnapToSeq<Int>($SortWrappers.Seq<Int>To$Snap x)))
    :pattern (($SortWrappers.Seq<Int>To$Snap x))
    :qid |$Snap.$SnapToSeq<Int>To$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.Seq<Int>To$Snap($SortWrappers.$SnapToSeq<Int> x)))
    :pattern (($SortWrappers.$SnapToSeq<Int> x))
    :qid |$Snap.Seq<Int>To$SnapToSeq<Int>|
    )))
; Declaring additional sort wrappers
(declare-fun $SortWrappers.Set<option<array>>To$Snap (Set<option<array>>) $Snap)
(declare-fun $SortWrappers.$SnapToSet<option<array>> ($Snap) Set<option<array>>)
(assert (forall ((x Set<option<array>>)) (!
    (= x ($SortWrappers.$SnapToSet<option<array>>($SortWrappers.Set<option<array>>To$Snap x)))
    :pattern (($SortWrappers.Set<option<array>>To$Snap x))
    :qid |$Snap.$SnapToSet<option<array>>To$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.Set<option<array>>To$Snap($SortWrappers.$SnapToSet<option<array>> x)))
    :pattern (($SortWrappers.$SnapToSet<option<array>> x))
    :qid |$Snap.Set<option<array>>To$SnapToSet<option<array>>|
    )))
(declare-fun $SortWrappers.Set<Bool>To$Snap (Set<Bool>) $Snap)
(declare-fun $SortWrappers.$SnapToSet<Bool> ($Snap) Set<Bool>)
(assert (forall ((x Set<Bool>)) (!
    (= x ($SortWrappers.$SnapToSet<Bool>($SortWrappers.Set<Bool>To$Snap x)))
    :pattern (($SortWrappers.Set<Bool>To$Snap x))
    :qid |$Snap.$SnapToSet<Bool>To$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.Set<Bool>To$Snap($SortWrappers.$SnapToSet<Bool> x)))
    :pattern (($SortWrappers.$SnapToSet<Bool> x))
    :qid |$Snap.Set<Bool>To$SnapToSet<Bool>|
    )))
(declare-fun $SortWrappers.Set<Int>To$Snap (Set<Int>) $Snap)
(declare-fun $SortWrappers.$SnapToSet<Int> ($Snap) Set<Int>)
(assert (forall ((x Set<Int>)) (!
    (= x ($SortWrappers.$SnapToSet<Int>($SortWrappers.Set<Int>To$Snap x)))
    :pattern (($SortWrappers.Set<Int>To$Snap x))
    :qid |$Snap.$SnapToSet<Int>To$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.Set<Int>To$Snap($SortWrappers.$SnapToSet<Int> x)))
    :pattern (($SortWrappers.$SnapToSet<Int> x))
    :qid |$Snap.Set<Int>To$SnapToSet<Int>|
    )))
(declare-fun $SortWrappers.Set<$Ref>To$Snap (Set<$Ref>) $Snap)
(declare-fun $SortWrappers.$SnapToSet<$Ref> ($Snap) Set<$Ref>)
(assert (forall ((x Set<$Ref>)) (!
    (= x ($SortWrappers.$SnapToSet<$Ref>($SortWrappers.Set<$Ref>To$Snap x)))
    :pattern (($SortWrappers.Set<$Ref>To$Snap x))
    :qid |$Snap.$SnapToSet<$Ref>To$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.Set<$Ref>To$Snap($SortWrappers.$SnapToSet<$Ref> x)))
    :pattern (($SortWrappers.$SnapToSet<$Ref> x))
    :qid |$Snap.Set<$Ref>To$SnapToSet<$Ref>|
    )))
(declare-fun $SortWrappers.Set<$Snap>To$Snap (Set<$Snap>) $Snap)
(declare-fun $SortWrappers.$SnapToSet<$Snap> ($Snap) Set<$Snap>)
(assert (forall ((x Set<$Snap>)) (!
    (= x ($SortWrappers.$SnapToSet<$Snap>($SortWrappers.Set<$Snap>To$Snap x)))
    :pattern (($SortWrappers.Set<$Snap>To$Snap x))
    :qid |$Snap.$SnapToSet<$Snap>To$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.Set<$Snap>To$Snap($SortWrappers.$SnapToSet<$Snap> x)))
    :pattern (($SortWrappers.$SnapToSet<$Snap> x))
    :qid |$Snap.Set<$Snap>To$SnapToSet<$Snap>|
    )))
; Declaring additional sort wrappers
(declare-fun $SortWrappers.t_nullTo$Snap (t_null) $Snap)
(declare-fun $SortWrappers.$SnapTot_null ($Snap) t_null)
(assert (forall ((x t_null)) (!
    (= x ($SortWrappers.$SnapTot_null($SortWrappers.t_nullTo$Snap x)))
    :pattern (($SortWrappers.t_nullTo$Snap x))
    :qid |$Snap.$SnapTot_nullTo$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.t_nullTo$Snap($SortWrappers.$SnapTot_null x)))
    :pattern (($SortWrappers.$SnapTot_null x))
    :qid |$Snap.t_nullTo$SnapTot_null|
    )))
(declare-fun $SortWrappers.anyTo$Snap (any) $Snap)
(declare-fun $SortWrappers.$SnapToany ($Snap) any)
(assert (forall ((x any)) (!
    (= x ($SortWrappers.$SnapToany($SortWrappers.anyTo$Snap x)))
    :pattern (($SortWrappers.anyTo$Snap x))
    :qid |$Snap.$SnapToanyTo$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.anyTo$Snap($SortWrappers.$SnapToany x)))
    :pattern (($SortWrappers.$SnapToany x))
    :qid |$Snap.anyTo$SnapToany|
    )))
(declare-fun $SortWrappers.voidTo$Snap (void) $Snap)
(declare-fun $SortWrappers.$SnapTovoid ($Snap) void)
(assert (forall ((x void)) (!
    (= x ($SortWrappers.$SnapTovoid($SortWrappers.voidTo$Snap x)))
    :pattern (($SortWrappers.voidTo$Snap x))
    :qid |$Snap.$SnapTovoidTo$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.voidTo$Snap($SortWrappers.$SnapTovoid x)))
    :pattern (($SortWrappers.$SnapTovoid x))
    :qid |$Snap.voidTo$SnapTovoid|
    )))
(declare-fun $SortWrappers.option<any>To$Snap (option<any>) $Snap)
(declare-fun $SortWrappers.$SnapTooption<any> ($Snap) option<any>)
(assert (forall ((x option<any>)) (!
    (= x ($SortWrappers.$SnapTooption<any>($SortWrappers.option<any>To$Snap x)))
    :pattern (($SortWrappers.option<any>To$Snap x))
    :qid |$Snap.$SnapTooption<any>To$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.option<any>To$Snap($SortWrappers.$SnapTooption<any> x)))
    :pattern (($SortWrappers.$SnapTooption<any> x))
    :qid |$Snap.option<any>To$SnapTooption<any>|
    )))
(declare-fun $SortWrappers.option<array>To$Snap (option<array>) $Snap)
(declare-fun $SortWrappers.$SnapTooption<array> ($Snap) option<array>)
(assert (forall ((x option<array>)) (!
    (= x ($SortWrappers.$SnapTooption<array>($SortWrappers.option<array>To$Snap x)))
    :pattern (($SortWrappers.option<array>To$Snap x))
    :qid |$Snap.$SnapTooption<array>To$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.option<array>To$Snap($SortWrappers.$SnapTooption<array> x)))
    :pattern (($SortWrappers.$SnapTooption<array> x))
    :qid |$Snap.option<array>To$SnapTooption<array>|
    )))
(declare-fun $SortWrappers.arrayTo$Snap (array) $Snap)
(declare-fun $SortWrappers.$SnapToarray ($Snap) array)
(assert (forall ((x array)) (!
    (= x ($SortWrappers.$SnapToarray($SortWrappers.arrayTo$Snap x)))
    :pattern (($SortWrappers.arrayTo$Snap x))
    :qid |$Snap.$SnapToarrayTo$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.arrayTo$Snap($SortWrappers.$SnapToarray x)))
    :pattern (($SortWrappers.$SnapToarray x))
    :qid |$Snap.arrayTo$SnapToarray|
    )))
; Declaring additional sort wrappers
(declare-fun $SortWrappers.$FVF<Int>To$Snap ($FVF<Int>) $Snap)
(declare-fun $SortWrappers.$SnapTo$FVF<Int> ($Snap) $FVF<Int>)
(assert (forall ((x $FVF<Int>)) (!
    (= x ($SortWrappers.$SnapTo$FVF<Int>($SortWrappers.$FVF<Int>To$Snap x)))
    :pattern (($SortWrappers.$FVF<Int>To$Snap x))
    :qid |$Snap.$SnapTo$FVF<Int>To$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.$FVF<Int>To$Snap($SortWrappers.$SnapTo$FVF<Int> x)))
    :pattern (($SortWrappers.$SnapTo$FVF<Int> x))
    :qid |$Snap.$FVF<Int>To$SnapTo$FVF<Int>|
    )))
(declare-fun $SortWrappers.$FVF<option<array>>To$Snap ($FVF<option<array>>) $Snap)
(declare-fun $SortWrappers.$SnapTo$FVF<option<array>> ($Snap) $FVF<option<array>>)
(assert (forall ((x $FVF<option<array>>)) (!
    (= x ($SortWrappers.$SnapTo$FVF<option<array>>($SortWrappers.$FVF<option<array>>To$Snap x)))
    :pattern (($SortWrappers.$FVF<option<array>>To$Snap x))
    :qid |$Snap.$SnapTo$FVF<option<array>>To$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.$FVF<option<array>>To$Snap($SortWrappers.$SnapTo$FVF<option<array>> x)))
    :pattern (($SortWrappers.$SnapTo$FVF<option<array>> x))
    :qid |$Snap.$FVF<option<array>>To$SnapTo$FVF<option<array>>|
    )))
(declare-fun $SortWrappers.$FVF<Bool>To$Snap ($FVF<Bool>) $Snap)
(declare-fun $SortWrappers.$SnapTo$FVF<Bool> ($Snap) $FVF<Bool>)
(assert (forall ((x $FVF<Bool>)) (!
    (= x ($SortWrappers.$SnapTo$FVF<Bool>($SortWrappers.$FVF<Bool>To$Snap x)))
    :pattern (($SortWrappers.$FVF<Bool>To$Snap x))
    :qid |$Snap.$SnapTo$FVF<Bool>To$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.$FVF<Bool>To$Snap($SortWrappers.$SnapTo$FVF<Bool> x)))
    :pattern (($SortWrappers.$SnapTo$FVF<Bool> x))
    :qid |$Snap.$FVF<Bool>To$SnapTo$FVF<Bool>|
    )))
(declare-fun $SortWrappers.$FVF<$Ref>To$Snap ($FVF<$Ref>) $Snap)
(declare-fun $SortWrappers.$SnapTo$FVF<$Ref> ($Snap) $FVF<$Ref>)
(assert (forall ((x $FVF<$Ref>)) (!
    (= x ($SortWrappers.$SnapTo$FVF<$Ref>($SortWrappers.$FVF<$Ref>To$Snap x)))
    :pattern (($SortWrappers.$FVF<$Ref>To$Snap x))
    :qid |$Snap.$SnapTo$FVF<$Ref>To$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.$FVF<$Ref>To$Snap($SortWrappers.$SnapTo$FVF<$Ref> x)))
    :pattern (($SortWrappers.$SnapTo$FVF<$Ref> x))
    :qid |$Snap.$FVF<$Ref>To$SnapTo$FVF<$Ref>|
    )))
; ////////// Symbols
(declare-fun Set_in (option<array> Set<option<array>>) Bool)
(declare-fun Set_card (Set<option<array>>) Int)
(declare-const Set_empty Set<option<array>>)
(declare-fun Set_singleton (option<array>) Set<option<array>>)
(declare-fun Set_unionone (Set<option<array>> option<array>) Set<option<array>>)
(declare-fun Set_union (Set<option<array>> Set<option<array>>) Set<option<array>>)
(declare-fun Set_disjoint (Set<option<array>> Set<option<array>>) Bool)
(declare-fun Set_difference (Set<option<array>> Set<option<array>>) Set<option<array>>)
(declare-fun Set_intersection (Set<option<array>> Set<option<array>>) Set<option<array>>)
(declare-fun Set_subset (Set<option<array>> Set<option<array>>) Bool)
(declare-fun Set_equal (Set<option<array>> Set<option<array>>) Bool)
(declare-fun Set_in (Bool Set<Bool>) Bool)
(declare-fun Set_card (Set<Bool>) Int)
(declare-const Set_empty Set<Bool>)
(declare-fun Set_singleton (Bool) Set<Bool>)
(declare-fun Set_unionone (Set<Bool> Bool) Set<Bool>)
(declare-fun Set_union (Set<Bool> Set<Bool>) Set<Bool>)
(declare-fun Set_disjoint (Set<Bool> Set<Bool>) Bool)
(declare-fun Set_difference (Set<Bool> Set<Bool>) Set<Bool>)
(declare-fun Set_intersection (Set<Bool> Set<Bool>) Set<Bool>)
(declare-fun Set_subset (Set<Bool> Set<Bool>) Bool)
(declare-fun Set_equal (Set<Bool> Set<Bool>) Bool)
(declare-fun Set_in (Int Set<Int>) Bool)
(declare-fun Set_card (Set<Int>) Int)
(declare-const Set_empty Set<Int>)
(declare-fun Set_singleton (Int) Set<Int>)
(declare-fun Set_unionone (Set<Int> Int) Set<Int>)
(declare-fun Set_union (Set<Int> Set<Int>) Set<Int>)
(declare-fun Set_disjoint (Set<Int> Set<Int>) Bool)
(declare-fun Set_difference (Set<Int> Set<Int>) Set<Int>)
(declare-fun Set_intersection (Set<Int> Set<Int>) Set<Int>)
(declare-fun Set_subset (Set<Int> Set<Int>) Bool)
(declare-fun Set_equal (Set<Int> Set<Int>) Bool)
(declare-fun Set_in ($Ref Set<$Ref>) Bool)
(declare-fun Set_card (Set<$Ref>) Int)
(declare-const Set_empty Set<$Ref>)
(declare-fun Set_singleton ($Ref) Set<$Ref>)
(declare-fun Set_unionone (Set<$Ref> $Ref) Set<$Ref>)
(declare-fun Set_union (Set<$Ref> Set<$Ref>) Set<$Ref>)
(declare-fun Set_disjoint (Set<$Ref> Set<$Ref>) Bool)
(declare-fun Set_difference (Set<$Ref> Set<$Ref>) Set<$Ref>)
(declare-fun Set_intersection (Set<$Ref> Set<$Ref>) Set<$Ref>)
(declare-fun Set_subset (Set<$Ref> Set<$Ref>) Bool)
(declare-fun Set_equal (Set<$Ref> Set<$Ref>) Bool)
(declare-fun Set_in ($Snap Set<$Snap>) Bool)
(declare-fun Set_card (Set<$Snap>) Int)
(declare-const Set_empty Set<$Snap>)
(declare-fun Set_singleton ($Snap) Set<$Snap>)
(declare-fun Set_unionone (Set<$Snap> $Snap) Set<$Snap>)
(declare-fun Set_union (Set<$Snap> Set<$Snap>) Set<$Snap>)
(declare-fun Set_disjoint (Set<$Snap> Set<$Snap>) Bool)
(declare-fun Set_difference (Set<$Snap> Set<$Snap>) Set<$Snap>)
(declare-fun Set_intersection (Set<$Snap> Set<$Snap>) Set<$Snap>)
(declare-fun Set_subset (Set<$Snap> Set<$Snap>) Bool)
(declare-fun Set_equal (Set<$Snap> Set<$Snap>) Bool)
(declare-fun Seq_length (Seq<Int>) Int)
(declare-const Seq_empty Seq<Int>)
(declare-fun Seq_singleton (Int) Seq<Int>)
(declare-fun Seq_build (Seq<Int> Int) Seq<Int>)
(declare-fun Seq_index (Seq<Int> Int) Int)
(declare-fun Seq_append (Seq<Int> Seq<Int>) Seq<Int>)
(declare-fun Seq_update (Seq<Int> Int Int) Seq<Int>)
(declare-fun Seq_contains (Seq<Int> Int) Bool)
(declare-fun Seq_take (Seq<Int> Int) Seq<Int>)
(declare-fun Seq_drop (Seq<Int> Int) Seq<Int>)
(declare-fun Seq_equal (Seq<Int> Seq<Int>) Bool)
(declare-fun Seq_sameuntil (Seq<Int> Seq<Int> Int) Bool)
(declare-fun Seq_range (Int Int) Seq<Int>)
(declare-fun array_loc<Ref> (array Int) $Ref)
(declare-fun alen<Int> (array) Int)
(declare-fun loc_inv_1<array> ($Ref) array)
(declare-fun loc_inv_2<Int> ($Ref) Int)
(declare-const None<option<array>> option<array>)
(declare-fun some<option<array>> (array) option<array>)
(declare-fun option_get<array> (option<array>) array)
(declare-const v_null<t_null> t_null)
(declare-const None<option<any>> option<any>)
(declare-fun some<option<any>> (any) option<any>)
(declare-fun option_get<any> (option<any>) any)
(declare-const unit<void> void)
; /field_value_functions_declarations.smt2 [int: Int]
(declare-fun $FVF.domain_int ($FVF<Int>) Set<$Ref>)
(declare-fun $FVF.lookup_int ($FVF<Int> $Ref) Int)
(declare-fun $FVF.after_int ($FVF<Int> $FVF<Int>) Bool)
(declare-fun $FVF.loc_int (Int $Ref) Bool)
(declare-fun $FVF.perm_int ($FPM $Ref) $Perm)
(declare-const $fvfTOP_int $FVF<Int>)
; /field_value_functions_declarations.smt2 [option$array$: option[array]]
(declare-fun $FVF.domain_option$array$ ($FVF<option<array>>) Set<$Ref>)
(declare-fun $FVF.lookup_option$array$ ($FVF<option<array>> $Ref) option<array>)
(declare-fun $FVF.after_option$array$ ($FVF<option<array>> $FVF<option<array>>) Bool)
(declare-fun $FVF.loc_option$array$ (option<array> $Ref) Bool)
(declare-fun $FVF.perm_option$array$ ($FPM $Ref) $Perm)
(declare-const $fvfTOP_option$array$ $FVF<option<array>>)
; /field_value_functions_declarations.smt2 [bool: Bool]
(declare-fun $FVF.domain_bool ($FVF<Bool>) Set<$Ref>)
(declare-fun $FVF.lookup_bool ($FVF<Bool> $Ref) Bool)
(declare-fun $FVF.after_bool ($FVF<Bool> $FVF<Bool>) Bool)
(declare-fun $FVF.loc_bool (Bool $Ref) Bool)
(declare-fun $FVF.perm_bool ($FPM $Ref) $Perm)
(declare-const $fvfTOP_bool $FVF<Bool>)
; Declaring symbols related to program functions (from program analysis)
(declare-fun aloc ($Snap array Int) $Ref)
(declare-fun aloc%limited ($Snap array Int) $Ref)
(declare-fun aloc%stateless (array Int) Bool)
(declare-fun opt_get1 ($Snap option<array>) array)
(declare-fun opt_get1%limited ($Snap option<array>) array)
(declare-fun opt_get1%stateless (option<array>) Bool)
(declare-fun any_as ($Snap any) any)
(declare-fun any_as%limited ($Snap any) any)
(declare-fun any_as%stateless (any) Bool)
(declare-fun opt_get ($Snap option<any>) any)
(declare-fun opt_get%limited ($Snap option<any>) any)
(declare-fun opt_get%stateless (option<any>) Bool)
(declare-fun lemma_skew_symetry ($Snap $Ref option<array> Int Int Int) Bool)
(declare-fun lemma_skew_symetry%limited ($Snap $Ref option<array> Int Int Int) Bool)
(declare-fun lemma_skew_symetry%stateless ($Ref option<array> Int Int Int) Bool)
(declare-fun FlowNetwork ($Snap $Ref option<array> Int Int Int) Bool)
(declare-fun FlowNetwork%limited ($Snap $Ref option<array> Int Int Int) Bool)
(declare-fun FlowNetwork%stateless ($Ref option<array> Int Int Int) Bool)
(declare-fun ExPath ($Snap $Ref option<array> Int Int Int) Bool)
(declare-fun ExPath%limited ($Snap $Ref option<array> Int Int Int) Bool)
(declare-fun ExPath%stateless ($Ref option<array> Int Int Int) Bool)
(declare-fun value ($Snap $Ref option<array> Int Int Int) Int)
(declare-fun value%limited ($Snap $Ref option<array> Int Int Int) Int)
(declare-fun value%stateless ($Ref option<array> Int Int Int) Bool)
(declare-fun valid_graph_vertices ($Snap $Ref option<array> Int) Bool)
(declare-fun valid_graph_vertices%limited ($Snap $Ref option<array> Int) Bool)
(declare-fun valid_graph_vertices%stateless ($Ref option<array> Int) Bool)
(declare-fun scale ($Snap $Perm) $Perm)
(declare-fun scale%limited ($Snap $Perm) $Perm)
(declare-fun scale%stateless ($Perm) Bool)
(declare-fun as_any ($Snap any) any)
(declare-fun as_any%limited ($Snap any) any)
(declare-fun as_any%stateless (any) Bool)
(declare-fun ResidualNetwork ($Snap $Ref option<array> Int) Bool)
(declare-fun ResidualNetwork%limited ($Snap $Ref option<array> Int) Bool)
(declare-fun ResidualNetwork%stateless ($Ref option<array> Int) Bool)
(declare-fun type ($Snap $Ref) Int)
(declare-fun type%limited ($Snap $Ref) Int)
(declare-fun type%stateless ($Ref) Bool)
(declare-fun lemma_max_flow_min_cut ($Snap $Ref option<array> Int Int Int) Bool)
(declare-fun lemma_max_flow_min_cut%limited ($Snap $Ref option<array> Int Int Int) Bool)
(declare-fun lemma_max_flow_min_cut%stateless ($Ref option<array> Int Int Int) Bool)
(declare-fun lemma_capacity_constrain ($Snap $Ref option<array> Int Int Int) Bool)
(declare-fun lemma_capacity_constrain%limited ($Snap $Ref option<array> Int Int Int) Bool)
(declare-fun lemma_capacity_constrain%stateless ($Ref option<array> Int Int Int) Bool)
(declare-fun opt_or_else ($Snap option<any> any) any)
(declare-fun opt_or_else%limited ($Snap option<any> any) any)
(declare-fun opt_or_else%stateless (option<any> any) Bool)
(declare-fun valid_graph_vertices1 ($Snap $Ref Seq<Int> Int) Bool)
(declare-fun valid_graph_vertices1%limited ($Snap $Ref Seq<Int> Int) Bool)
(declare-fun valid_graph_vertices1%stateless ($Ref Seq<Int> Int) Bool)
(declare-fun flow ($Snap $Ref option<array> Int Int Int) Int)
(declare-fun flow%limited ($Snap $Ref option<array> Int Int Int) Int)
(declare-fun flow%stateless ($Ref option<array> Int Int Int) Bool)
(declare-fun lemma_flow_conservation ($Snap $Ref option<array> Int Int Int) Bool)
(declare-fun lemma_flow_conservation%limited ($Snap $Ref option<array> Int Int Int) Bool)
(declare-fun lemma_flow_conservation%stateless ($Ref option<array> Int Int Int) Bool)
(declare-fun subtype ($Snap Int Int) Bool)
(declare-fun subtype%limited ($Snap Int Int) Bool)
(declare-fun subtype%stateless (Int Int) Bool)
; Snapshot variable to be used during function verification
(declare-fun s@$ () $Snap)
; Declaring predicate trigger functions
(declare-fun lock_inv_FordFulkerson%trigger ($Snap $Ref) Bool)
(declare-fun lock_held_FordFulkerson%trigger ($Snap $Ref) Bool)
(declare-fun lock_inv_Object%trigger ($Snap $Ref) Bool)
(declare-fun lock_held_Object%trigger ($Snap $Ref) Bool)
; ////////// Uniqueness assumptions from domains
; ////////// Axioms
(assert (forall ((s Seq<Int>)) (!
  (<= 0 (Seq_length s))
  :pattern ((Seq_length s))
  :qid |$Seq[Int]_prog.seq_length_non_negative|)))
(assert (= (Seq_length (as Seq_empty  Seq<Int>)) 0))
(assert (forall ((s Seq<Int>)) (!
  (implies (= (Seq_length s) 0) (= s (as Seq_empty  Seq<Int>)))
  :pattern ((Seq_length s))
  :qid |$Seq[Int]_prog.only_empty_seq_length_zero|)))
(assert (forall ((e Int)) (!
  (= (Seq_length (Seq_singleton e)) 1)
  :pattern ((Seq_length (Seq_singleton e)))
  :qid |$Seq[Int]_prog.length_singleton_seq|)))
(assert (forall ((s Seq<Int>) (e Int)) (!
  (= (Seq_length (Seq_build s e)) (+ 1 (Seq_length s)))
  :pattern ((Seq_length (Seq_build s e)))
  :qid |$Seq[Int]_prog.length_seq_build_inc_by_one|)))
(assert (forall ((s Seq<Int>) (i Int) (e Int)) (!
  (ite
    (= i (Seq_length s))
    (= (Seq_index (Seq_build s e) i) e)
    (= (Seq_index (Seq_build s e) i) (Seq_index s i)))
  :pattern ((Seq_index (Seq_build s e) i))
  :qid |$Seq[Int]_prog.seq_index_over_build|)))
(assert (forall ((s1 Seq<Int>) (s2 Seq<Int>)) (!
  (implies
    (and
      (not (= s1 (as Seq_empty  Seq<Int>)))
      (not (= s2 (as Seq_empty  Seq<Int>))))
    (= (Seq_length (Seq_append s1 s2)) (+ (Seq_length s1) (Seq_length s2))))
  :pattern ((Seq_length (Seq_append s1 s2)))
  :qid |$Seq[Int]_prog.seq_length_over_append|)))
(assert (forall ((e Int)) (!
  (= (Seq_index (Seq_singleton e) 0) e)
  :pattern ((Seq_index (Seq_singleton e) 0))
  :qid |$Seq[Int]_prog.seq_index_over_singleton|)))
(assert (forall ((e1 Int) (e2 Int)) (!
  (= (Seq_contains (Seq_singleton e1) e2) (= e1 e2))
  :pattern ((Seq_contains (Seq_singleton e1) e2))
  :qid |$Seq[Int]_prog.seq_contains_over_singleton|)))
(assert (forall ((s Seq<Int>)) (!
  (= (Seq_append (as Seq_empty  Seq<Int>) s) s)
  :pattern ((Seq_append (as Seq_empty  Seq<Int>) s))
  :qid |$Seq[Int]_prog.seq_append_empty_left|)))
(assert (forall ((s Seq<Int>)) (!
  (= (Seq_append s (as Seq_empty  Seq<Int>)) s)
  :pattern ((Seq_append s (as Seq_empty  Seq<Int>)))
  :qid |$Seq[Int]_prog.seq_append_empty_right|)))
(assert (forall ((s1 Seq<Int>) (s2 Seq<Int>) (i Int)) (!
  (implies
    (and
      (not (= s1 (as Seq_empty  Seq<Int>)))
      (not (= s2 (as Seq_empty  Seq<Int>))))
    (ite
      (< i (Seq_length s1))
      (= (Seq_index (Seq_append s1 s2) i) (Seq_index s1 i))
      (= (Seq_index (Seq_append s1 s2) i) (Seq_index s2 (- i (Seq_length s1))))))
  :pattern ((Seq_index (Seq_append s1 s2) i))
  :pattern ((Seq_index s1 i) (Seq_append s1 s2))
  :qid |$Seq[Int]_prog.seq_index_over_append|)))
(assert (forall ((s Seq<Int>) (i Int) (e Int)) (!
  (implies
    (and (<= 0 i) (< i (Seq_length s)))
    (= (Seq_length (Seq_update s i e)) (Seq_length s)))
  :pattern ((Seq_length (Seq_update s i e)))
  :qid |$Seq[Int]_prog.seq_length_invariant_over_update|)))
(assert (forall ((s Seq<Int>) (i Int) (e Int) (j Int)) (!
  (ite
    (implies (and (<= 0 i) (< i (Seq_length s))) (= i j))
    (= (Seq_index (Seq_update s i e) j) e)
    (= (Seq_index (Seq_update s i e) j) (Seq_index s j)))
  :pattern ((Seq_index (Seq_update s i e) j))
  :qid |$Seq[Int]_prog.seq_index_over_update|)))
(assert (forall ((s Seq<Int>) (e Int)) (!
  (=
    (Seq_contains s e)
    (exists ((i Int)) (!
      (and (<= 0 i) (and (< i (Seq_length s)) (= (Seq_index s i) e)))
      :pattern ((Seq_index s i))
      )))
  :pattern ((Seq_contains s e))
  :qid |$Seq[Int]_prog.seq_element_contains_index_exists|)))
(assert (forall ((e Int)) (!
  (not (Seq_contains (as Seq_empty  Seq<Int>) e))
  :pattern ((Seq_contains (as Seq_empty  Seq<Int>) e))
  :qid |$Seq[Int]_prog.empty_seq_contains_nothing|)))
(assert (forall ((s1 Seq<Int>) (s2 Seq<Int>) (e Int)) (!
  (=
    (Seq_contains (Seq_append s1 s2) e)
    (or (Seq_contains s1 e) (Seq_contains s2 e)))
  :pattern ((Seq_contains (Seq_append s1 s2) e))
  :qid |$Seq[Int]_prog.seq_contains_over_append|)))
(assert (forall ((s Seq<Int>) (e1 Int) (e2 Int)) (!
  (= (Seq_contains (Seq_build s e1) e2) (or (= e1 e2) (Seq_contains s e2)))
  :pattern ((Seq_contains (Seq_build s e1) e2))
  :qid |$Seq[Int]_prog.seq_contains_over_build|)))
(assert (forall ((s Seq<Int>) (n Int)) (!
  (implies (<= n 0) (= (Seq_take s n) (as Seq_empty  Seq<Int>)))
  :pattern ((Seq_take s n))
  :qid |$Seq[Int]_prog.seq_take_negative_length|)))
(assert (forall ((s Seq<Int>) (n Int) (e Int)) (!
  (=
    (Seq_contains (Seq_take s n) e)
    (exists ((i Int)) (!
      (and
        (<= 0 i)
        (and (< i n) (and (< i (Seq_length s)) (= (Seq_index s i) e))))
      :pattern ((Seq_index s i))
      )))
  :pattern ((Seq_contains (Seq_take s n) e))
  :qid |$Seq[Int]_prog.seq_contains_over_take_index_exists|)))
(assert (forall ((s Seq<Int>) (n Int)) (!
  (implies (<= n 0) (= (Seq_drop s n) s))
  :pattern ((Seq_drop s n))
  :qid |$Seq[Int]_prog.seq_drop_negative_length|)))
(assert (forall ((s Seq<Int>) (n Int) (e Int)) (!
  (=
    (Seq_contains (Seq_drop s n) e)
    (exists ((i Int)) (!
      (and
        (<= 0 i)
        (and (<= n i) (and (< i (Seq_length s)) (= (Seq_index s i) e))))
      :pattern ((Seq_index s i))
      )))
  :pattern ((Seq_contains (Seq_drop s n) e))
  :qid |$Seq[Int]_prog.seq_contains_over_drop_index_exists|)))
(assert (forall ((s1 Seq<Int>) (s2 Seq<Int>)) (!
  (=
    (Seq_equal s1 s2)
    (and
      (= (Seq_length s1) (Seq_length s2))
      (forall ((i Int)) (!
        (implies
          (and (<= 0 i) (< i (Seq_length s1)))
          (= (Seq_index s1 i) (Seq_index s2 i)))
        :pattern ((Seq_index s1 i))
        :pattern ((Seq_index s2 i))
        ))))
  :pattern ((Seq_equal s1 s2))
  :qid |$Seq[Int]_prog.extensional_seq_equality|)))
(assert (forall ((s1 Seq<Int>) (s2 Seq<Int>)) (!
  (implies (Seq_equal s1 s2) (= s1 s2))
  :pattern ((Seq_equal s1 s2))
  :qid |$Seq[Int]_prog.seq_equality_identity|)))
(assert (forall ((s1 Seq<Int>) (s2 Seq<Int>) (n Int)) (!
  (=
    (Seq_sameuntil s1 s2 n)
    (forall ((i Int)) (!
      (implies (and (<= 0 i) (< i n)) (= (Seq_index s1 i) (Seq_index s2 i)))
      :pattern ((Seq_index s1 i))
      :pattern ((Seq_index s2 i))
      )))
  :pattern ((Seq_sameuntil s1 s2 n))
  :qid |$Seq[Int]_prog.extensional_seq_equality_prefix|)))
(assert (forall ((s Seq<Int>) (n Int)) (!
  (implies
    (<= 0 n)
    (ite
      (<= n (Seq_length s))
      (= (Seq_length (Seq_take s n)) n)
      (= (Seq_length (Seq_take s n)) (Seq_length s))))
  :pattern ((Seq_length (Seq_take s n)))
  :qid |$Seq[Int]_prog.seq_length_over_take|)))
(assert (forall ((s Seq<Int>) (n Int) (i Int)) (!
  (implies
    (and (<= 0 i) (and (< i n) (< i (Seq_length s))))
    (= (Seq_index (Seq_take s n) i) (Seq_index s i)))
  :pattern ((Seq_index (Seq_take s n) i))
  :pattern ((Seq_index s i) (Seq_take s n))
  :qid |$Seq[Int]_prog.seq_index_over_take|)))
(assert (forall ((s Seq<Int>) (n Int)) (!
  (implies
    (<= 0 n)
    (ite
      (<= n (Seq_length s))
      (= (Seq_length (Seq_drop s n)) (- (Seq_length s) n))
      (= (Seq_length (Seq_drop s n)) 0)))
  :pattern ((Seq_length (Seq_drop s n)))
  :qid |$Seq[Int]_prog.seq_length_over_drop|)))
(assert (forall ((s Seq<Int>) (n Int) (i Int)) (!
  (implies
    (and (<= 0 n) (and (<= 0 i) (< i (- (Seq_length s) n))))
    (= (Seq_index (Seq_drop s n) i) (Seq_index s (+ i n))))
  :pattern ((Seq_index (Seq_drop s n) i))
  :qid |$Seq[Int]_prog.seq_index_over_drop_1|)))
(assert (forall ((s Seq<Int>) (n Int) (i Int)) (!
  (implies
    (and (<= 0 n) (and (<= n i) (< i (Seq_length s))))
    (= (Seq_index (Seq_drop s n) (- i n)) (Seq_index s i)))
  :pattern ((Seq_index s i) (Seq_drop s n))
  :qid |$Seq[Int]_prog.seq_index_over_drop_2|)))
(assert (forall ((s Seq<Int>) (i Int) (e Int) (n Int)) (!
  (implies
    (and (<= 0 i) (and (< i n) (< n (Seq_length s))))
    (= (Seq_take (Seq_update s i e) n) (Seq_update (Seq_take s n) i e)))
  :pattern ((Seq_take (Seq_update s i e) n))
  :qid |$Seq[Int]_prog.seq_take_over_update_1|)))
(assert (forall ((s Seq<Int>) (i Int) (e Int) (n Int)) (!
  (implies
    (and (<= n i) (< i (Seq_length s)))
    (= (Seq_take (Seq_update s i e) n) (Seq_take s n)))
  :pattern ((Seq_take (Seq_update s i e) n))
  :qid |$Seq[Int]_prog.seq_take_over_update_2|)))
(assert (forall ((s Seq<Int>) (i Int) (e Int) (n Int)) (!
  (implies
    (and (<= 0 n) (and (<= n i) (< i (Seq_length s))))
    (= (Seq_drop (Seq_update s i e) n) (Seq_update (Seq_drop s n) (- i n) e)))
  :pattern ((Seq_drop (Seq_update s i e) n))
  :qid |$Seq[Int]_prog.seq_drop_over_update_1|)))
(assert (forall ((s Seq<Int>) (i Int) (e Int) (n Int)) (!
  (implies
    (and (<= 0 i) (and (< i n) (< n (Seq_length s))))
    (= (Seq_drop (Seq_update s i e) n) (Seq_drop s n)))
  :pattern ((Seq_drop (Seq_update s i e) n))
  :qid |$Seq[Int]_prog.seq_drop_over_update_2|)))
(assert (forall ((s Seq<Int>) (e Int) (n Int)) (!
  (implies
    (and (<= 0 n) (<= n (Seq_length s)))
    (= (Seq_drop (Seq_build s e) n) (Seq_build (Seq_drop s n) e)))
  :pattern ((Seq_drop (Seq_build s e) n))
  :qid |$Seq[Int]_prog.seq_drop_over_build|)))
(assert (forall ((min_ Int) (max Int)) (!
  (ite
    (< min_ max)
    (= (Seq_length (Seq_range min_ max)) (- max min_))
    (= (Seq_length (Seq_range min_ max)) 0))
  :pattern ((Seq_length (Seq_range min_ max)))
  :qid |$Seq[Int]_prog.ranged_seq_length|)))
(assert (forall ((min_ Int) (max Int) (i Int)) (!
  (implies
    (and (<= 0 i) (< i (- max min_)))
    (= (Seq_index (Seq_range min_ max) i) (+ min_ i)))
  :pattern ((Seq_index (Seq_range min_ max) i))
  :qid |$Seq[Int]_prog.ranged_seq_index|)))
(assert (forall ((min_ Int) (max Int) (e Int)) (!
  (= (Seq_contains (Seq_range min_ max) e) (and (<= min_ e) (< e max)))
  :pattern ((Seq_contains (Seq_range min_ max) e))
  :qid |$Seq[Int]_prog.ranged_seq_contains|)))
(assert (forall ((s Set<option<array>>)) (!
  (<= 0 (Set_card s))
  :pattern ((Set_card s))
  :qid |$Set[option[array]]_prog.card_non_negative|)))
(assert (forall ((e option<array>)) (!
  (not (Set_in e (as Set_empty  Set<option<array>>)))
  :pattern ((Set_in e (as Set_empty  Set<option<array>>)))
  :qid |$Set[option[array]]_prog.in_empty_set|)))
(assert (forall ((s Set<option<array>>)) (!
  (and
    (= (= (Set_card s) 0) (= s (as Set_empty  Set<option<array>>)))
    (implies
      (not (= (Set_card s) 0))
      (exists ((e option<array>)) (!
        (Set_in e s)
        :pattern ((Set_in e s))
        ))))
  :pattern ((Set_card s))
  :qid |$Set[option[array]]_prog.empty_set_cardinality|)))
(assert (forall ((e option<array>)) (!
  (Set_in e (Set_singleton e))
  :pattern ((Set_singleton e))
  :qid |$Set[option[array]]_prog.in_singleton_set|)))
(assert (forall ((e1 option<array>) (e2 option<array>)) (!
  (= (Set_in e1 (Set_singleton e2)) (= e1 e2))
  :pattern ((Set_in e1 (Set_singleton e2)))
  :qid |$Set[option[array]]_prog.in_singleton_set_equality|)))
(assert (forall ((e option<array>)) (!
  (= (Set_card (Set_singleton e)) 1)
  :pattern ((Set_card (Set_singleton e)))
  :qid |$Set[option[array]]_prog.singleton_set_cardinality|)))
(assert (forall ((s Set<option<array>>) (e option<array>)) (!
  (Set_in e (Set_unionone s e))
  :pattern ((Set_unionone s e))
  :qid |$Set[option[array]]_prog.in_unionone_same|)))
(assert (forall ((s Set<option<array>>) (e1 option<array>) (e2 option<array>)) (!
  (= (Set_in e1 (Set_unionone s e2)) (or (= e1 e2) (Set_in e1 s)))
  :pattern ((Set_in e1 (Set_unionone s e2)))
  :qid |$Set[option[array]]_prog.in_unionone_other|)))
(assert (forall ((s Set<option<array>>) (e1 option<array>) (e2 option<array>)) (!
  (implies (Set_in e1 s) (Set_in e1 (Set_unionone s e2)))
  :pattern ((Set_in e1 s) (Set_unionone s e2))
  :qid |$Set[option[array]]_prog.invariance_in_unionone|)))
(assert (forall ((s Set<option<array>>) (e option<array>)) (!
  (implies (Set_in e s) (= (Set_card (Set_unionone s e)) (Set_card s)))
  :pattern ((Set_card (Set_unionone s e)))
  :qid |$Set[option[array]]_prog.unionone_cardinality_invariant|)))
(assert (forall ((s Set<option<array>>) (e option<array>)) (!
  (implies
    (not (Set_in e s))
    (= (Set_card (Set_unionone s e)) (+ (Set_card s) 1)))
  :pattern ((Set_card (Set_unionone s e)))
  :qid |$Set[option[array]]_prog.unionone_cardinality_changed|)))
(assert (forall ((s1 Set<option<array>>) (s2 Set<option<array>>) (e option<array>)) (!
  (= (Set_in e (Set_union s1 s2)) (or (Set_in e s1) (Set_in e s2)))
  :pattern ((Set_in e (Set_union s1 s2)))
  :qid |$Set[option[array]]_prog.in_union_in_one|)))
(assert (forall ((s1 Set<option<array>>) (s2 Set<option<array>>) (e option<array>)) (!
  (implies (Set_in e s1) (Set_in e (Set_union s1 s2)))
  :pattern ((Set_in e s1) (Set_union s1 s2))
  :qid |$Set[option[array]]_prog.in_left_in_union|)))
(assert (forall ((s1 Set<option<array>>) (s2 Set<option<array>>) (e option<array>)) (!
  (implies (Set_in e s2) (Set_in e (Set_union s1 s2)))
  :pattern ((Set_in e s2) (Set_union s1 s2))
  :qid |$Set[option[array]]_prog.in_right_in_union|)))
(assert (forall ((s1 Set<option<array>>) (s2 Set<option<array>>) (e option<array>)) (!
  (= (Set_in e (Set_intersection s1 s2)) (and (Set_in e s1) (Set_in e s2)))
  :pattern ((Set_in e (Set_intersection s1 s2)))
  :pattern ((Set_intersection s1 s2) (Set_in e s1))
  :pattern ((Set_intersection s1 s2) (Set_in e s2))
  :qid |$Set[option[array]]_prog.in_intersection_in_both|)))
(assert (forall ((s1 Set<option<array>>) (s2 Set<option<array>>)) (!
  (= (Set_union s1 (Set_union s1 s2)) (Set_union s1 s2))
  :pattern ((Set_union s1 (Set_union s1 s2)))
  :qid |$Set[option[array]]_prog.union_left_idempotency|)))
(assert (forall ((s1 Set<option<array>>) (s2 Set<option<array>>)) (!
  (= (Set_union (Set_union s1 s2) s2) (Set_union s1 s2))
  :pattern ((Set_union (Set_union s1 s2) s2))
  :qid |$Set[option[array]]_prog.union_right_idempotency|)))
(assert (forall ((s1 Set<option<array>>) (s2 Set<option<array>>)) (!
  (= (Set_intersection s1 (Set_intersection s1 s2)) (Set_intersection s1 s2))
  :pattern ((Set_intersection s1 (Set_intersection s1 s2)))
  :qid |$Set[option[array]]_prog.intersection_left_idempotency|)))
(assert (forall ((s1 Set<option<array>>) (s2 Set<option<array>>)) (!
  (= (Set_intersection (Set_intersection s1 s2) s2) (Set_intersection s1 s2))
  :pattern ((Set_intersection (Set_intersection s1 s2) s2))
  :qid |$Set[option[array]]_prog.intersection_right_idempotency|)))
(assert (forall ((s1 Set<option<array>>) (s2 Set<option<array>>)) (!
  (=
    (+ (Set_card (Set_union s1 s2)) (Set_card (Set_intersection s1 s2)))
    (+ (Set_card s1) (Set_card s2)))
  :pattern ((Set_card (Set_union s1 s2)))
  :pattern ((Set_card (Set_intersection s1 s2)))
  :qid |$Set[option[array]]_prog.cardinality_sums|)))
(assert (forall ((s1 Set<option<array>>) (s2 Set<option<array>>) (e option<array>)) (!
  (= (Set_in e (Set_difference s1 s2)) (and (Set_in e s1) (not (Set_in e s2))))
  :pattern ((Set_in e (Set_difference s1 s2)))
  :qid |$Set[option[array]]_prog.in_difference|)))
(assert (forall ((s1 Set<option<array>>) (s2 Set<option<array>>) (e option<array>)) (!
  (implies (Set_in e s2) (not (Set_in e (Set_difference s1 s2))))
  :pattern ((Set_difference s1 s2) (Set_in e s2))
  :qid |$Set[option[array]]_prog.not_in_difference|)))
(assert (forall ((s1 Set<option<array>>) (s2 Set<option<array>>)) (!
  (=
    (Set_subset s1 s2)
    (forall ((e option<array>)) (!
      (implies (Set_in e s1) (Set_in e s2))
      :pattern ((Set_in e s1))
      :pattern ((Set_in e s2))
      )))
  :pattern ((Set_subset s1 s2))
  :qid |$Set[option[array]]_prog.subset_definition|)))
(assert (forall ((s1 Set<option<array>>) (s2 Set<option<array>>)) (!
  (=
    (Set_equal s1 s2)
    (forall ((e option<array>)) (!
      (= (Set_in e s1) (Set_in e s2))
      :pattern ((Set_in e s1))
      :pattern ((Set_in e s2))
      )))
  :pattern ((Set_equal s1 s2))
  :qid |$Set[option[array]]_prog.equality_definition|)))
(assert (forall ((s1 Set<option<array>>) (s2 Set<option<array>>)) (!
  (implies (Set_equal s1 s2) (= s1 s2))
  :pattern ((Set_equal s1 s2))
  :qid |$Set[option[array]]_prog.native_equality|)))
(assert (forall ((s1 Set<option<array>>) (s2 Set<option<array>>)) (!
  (=
    (Set_disjoint s1 s2)
    (forall ((e option<array>)) (!
      (or (not (Set_in e s1)) (not (Set_in e s2)))
      :pattern ((Set_in e s1))
      :pattern ((Set_in e s2))
      )))
  :pattern ((Set_disjoint s1 s2))
  :qid |$Set[option[array]]_prog.disjointness_definition|)))
(assert (forall ((s1 Set<option<array>>) (s2 Set<option<array>>)) (!
  (and
    (=
      (+
        (+ (Set_card (Set_difference s1 s2)) (Set_card (Set_difference s2 s1)))
        (Set_card (Set_intersection s1 s2)))
      (Set_card (Set_union s1 s2)))
    (=
      (Set_card (Set_difference s1 s2))
      (- (Set_card s1) (Set_card (Set_intersection s1 s2)))))
  :pattern ((Set_card (Set_difference s1 s2)))
  :qid |$Set[option[array]]_prog.cardinality_difference|)))
(assert (forall ((s Set<Bool>)) (!
  (<= 0 (Set_card s))
  :pattern ((Set_card s))
  :qid |$Set[Bool]_prog.card_non_negative|)))
(assert (forall ((e Bool)) (!
  (not (Set_in e (as Set_empty  Set<Bool>)))
  :pattern ((Set_in e (as Set_empty  Set<Bool>)))
  :qid |$Set[Bool]_prog.in_empty_set|)))
(assert (forall ((s Set<Bool>)) (!
  (and
    (= (= (Set_card s) 0) (= s (as Set_empty  Set<Bool>)))
    (implies
      (not (= (Set_card s) 0))
      (exists ((e Bool)) (!
        (Set_in e s)
        :pattern ((Set_in e s))
        ))))
  :pattern ((Set_card s))
  :qid |$Set[Bool]_prog.empty_set_cardinality|)))
(assert (forall ((e Bool)) (!
  (Set_in e (Set_singleton e))
  :pattern ((Set_singleton e))
  :qid |$Set[Bool]_prog.in_singleton_set|)))
(assert (forall ((e1 Bool) (e2 Bool)) (!
  (= (Set_in e1 (Set_singleton e2)) (= e1 e2))
  :pattern ((Set_in e1 (Set_singleton e2)))
  :qid |$Set[Bool]_prog.in_singleton_set_equality|)))
(assert (forall ((e Bool)) (!
  (= (Set_card (Set_singleton e)) 1)
  :pattern ((Set_card (Set_singleton e)))
  :qid |$Set[Bool]_prog.singleton_set_cardinality|)))
(assert (forall ((s Set<Bool>) (e Bool)) (!
  (Set_in e (Set_unionone s e))
  :pattern ((Set_unionone s e))
  :qid |$Set[Bool]_prog.in_unionone_same|)))
(assert (forall ((s Set<Bool>) (e1 Bool) (e2 Bool)) (!
  (= (Set_in e1 (Set_unionone s e2)) (or (= e1 e2) (Set_in e1 s)))
  :pattern ((Set_in e1 (Set_unionone s e2)))
  :qid |$Set[Bool]_prog.in_unionone_other|)))
(assert (forall ((s Set<Bool>) (e1 Bool) (e2 Bool)) (!
  (implies (Set_in e1 s) (Set_in e1 (Set_unionone s e2)))
  :pattern ((Set_in e1 s) (Set_unionone s e2))
  :qid |$Set[Bool]_prog.invariance_in_unionone|)))
(assert (forall ((s Set<Bool>) (e Bool)) (!
  (implies (Set_in e s) (= (Set_card (Set_unionone s e)) (Set_card s)))
  :pattern ((Set_card (Set_unionone s e)))
  :qid |$Set[Bool]_prog.unionone_cardinality_invariant|)))
(assert (forall ((s Set<Bool>) (e Bool)) (!
  (implies
    (not (Set_in e s))
    (= (Set_card (Set_unionone s e)) (+ (Set_card s) 1)))
  :pattern ((Set_card (Set_unionone s e)))
  :qid |$Set[Bool]_prog.unionone_cardinality_changed|)))
(assert (forall ((s1 Set<Bool>) (s2 Set<Bool>) (e Bool)) (!
  (= (Set_in e (Set_union s1 s2)) (or (Set_in e s1) (Set_in e s2)))
  :pattern ((Set_in e (Set_union s1 s2)))
  :qid |$Set[Bool]_prog.in_union_in_one|)))
(assert (forall ((s1 Set<Bool>) (s2 Set<Bool>) (e Bool)) (!
  (implies (Set_in e s1) (Set_in e (Set_union s1 s2)))
  :pattern ((Set_in e s1) (Set_union s1 s2))
  :qid |$Set[Bool]_prog.in_left_in_union|)))
(assert (forall ((s1 Set<Bool>) (s2 Set<Bool>) (e Bool)) (!
  (implies (Set_in e s2) (Set_in e (Set_union s1 s2)))
  :pattern ((Set_in e s2) (Set_union s1 s2))
  :qid |$Set[Bool]_prog.in_right_in_union|)))
(assert (forall ((s1 Set<Bool>) (s2 Set<Bool>) (e Bool)) (!
  (= (Set_in e (Set_intersection s1 s2)) (and (Set_in e s1) (Set_in e s2)))
  :pattern ((Set_in e (Set_intersection s1 s2)))
  :pattern ((Set_intersection s1 s2) (Set_in e s1))
  :pattern ((Set_intersection s1 s2) (Set_in e s2))
  :qid |$Set[Bool]_prog.in_intersection_in_both|)))
(assert (forall ((s1 Set<Bool>) (s2 Set<Bool>)) (!
  (= (Set_union s1 (Set_union s1 s2)) (Set_union s1 s2))
  :pattern ((Set_union s1 (Set_union s1 s2)))
  :qid |$Set[Bool]_prog.union_left_idempotency|)))
(assert (forall ((s1 Set<Bool>) (s2 Set<Bool>)) (!
  (= (Set_union (Set_union s1 s2) s2) (Set_union s1 s2))
  :pattern ((Set_union (Set_union s1 s2) s2))
  :qid |$Set[Bool]_prog.union_right_idempotency|)))
(assert (forall ((s1 Set<Bool>) (s2 Set<Bool>)) (!
  (= (Set_intersection s1 (Set_intersection s1 s2)) (Set_intersection s1 s2))
  :pattern ((Set_intersection s1 (Set_intersection s1 s2)))
  :qid |$Set[Bool]_prog.intersection_left_idempotency|)))
(assert (forall ((s1 Set<Bool>) (s2 Set<Bool>)) (!
  (= (Set_intersection (Set_intersection s1 s2) s2) (Set_intersection s1 s2))
  :pattern ((Set_intersection (Set_intersection s1 s2) s2))
  :qid |$Set[Bool]_prog.intersection_right_idempotency|)))
(assert (forall ((s1 Set<Bool>) (s2 Set<Bool>)) (!
  (=
    (+ (Set_card (Set_union s1 s2)) (Set_card (Set_intersection s1 s2)))
    (+ (Set_card s1) (Set_card s2)))
  :pattern ((Set_card (Set_union s1 s2)))
  :pattern ((Set_card (Set_intersection s1 s2)))
  :qid |$Set[Bool]_prog.cardinality_sums|)))
(assert (forall ((s1 Set<Bool>) (s2 Set<Bool>) (e Bool)) (!
  (= (Set_in e (Set_difference s1 s2)) (and (Set_in e s1) (not (Set_in e s2))))
  :pattern ((Set_in e (Set_difference s1 s2)))
  :qid |$Set[Bool]_prog.in_difference|)))
(assert (forall ((s1 Set<Bool>) (s2 Set<Bool>) (e Bool)) (!
  (implies (Set_in e s2) (not (Set_in e (Set_difference s1 s2))))
  :pattern ((Set_difference s1 s2) (Set_in e s2))
  :qid |$Set[Bool]_prog.not_in_difference|)))
(assert (forall ((s1 Set<Bool>) (s2 Set<Bool>)) (!
  (=
    (Set_subset s1 s2)
    (forall ((e Bool)) (!
      (implies (Set_in e s1) (Set_in e s2))
      :pattern ((Set_in e s1))
      :pattern ((Set_in e s2))
      )))
  :pattern ((Set_subset s1 s2))
  :qid |$Set[Bool]_prog.subset_definition|)))
(assert (forall ((s1 Set<Bool>) (s2 Set<Bool>)) (!
  (=
    (Set_equal s1 s2)
    (forall ((e Bool)) (!
      (= (Set_in e s1) (Set_in e s2))
      :pattern ((Set_in e s1))
      :pattern ((Set_in e s2))
      )))
  :pattern ((Set_equal s1 s2))
  :qid |$Set[Bool]_prog.equality_definition|)))
(assert (forall ((s1 Set<Bool>) (s2 Set<Bool>)) (!
  (implies (Set_equal s1 s2) (= s1 s2))
  :pattern ((Set_equal s1 s2))
  :qid |$Set[Bool]_prog.native_equality|)))
(assert (forall ((s1 Set<Bool>) (s2 Set<Bool>)) (!
  (=
    (Set_disjoint s1 s2)
    (forall ((e Bool)) (!
      (or (not (Set_in e s1)) (not (Set_in e s2)))
      :pattern ((Set_in e s1))
      :pattern ((Set_in e s2))
      )))
  :pattern ((Set_disjoint s1 s2))
  :qid |$Set[Bool]_prog.disjointness_definition|)))
(assert (forall ((s1 Set<Bool>) (s2 Set<Bool>)) (!
  (and
    (=
      (+
        (+ (Set_card (Set_difference s1 s2)) (Set_card (Set_difference s2 s1)))
        (Set_card (Set_intersection s1 s2)))
      (Set_card (Set_union s1 s2)))
    (=
      (Set_card (Set_difference s1 s2))
      (- (Set_card s1) (Set_card (Set_intersection s1 s2)))))
  :pattern ((Set_card (Set_difference s1 s2)))
  :qid |$Set[Bool]_prog.cardinality_difference|)))
(assert (forall ((s Set<Int>)) (!
  (<= 0 (Set_card s))
  :pattern ((Set_card s))
  :qid |$Set[Int]_prog.card_non_negative|)))
(assert (forall ((e Int)) (!
  (not (Set_in e (as Set_empty  Set<Int>)))
  :pattern ((Set_in e (as Set_empty  Set<Int>)))
  :qid |$Set[Int]_prog.in_empty_set|)))
(assert (forall ((s Set<Int>)) (!
  (and
    (= (= (Set_card s) 0) (= s (as Set_empty  Set<Int>)))
    (implies
      (not (= (Set_card s) 0))
      (exists ((e Int)) (!
        (Set_in e s)
        :pattern ((Set_in e s))
        ))))
  :pattern ((Set_card s))
  :qid |$Set[Int]_prog.empty_set_cardinality|)))
(assert (forall ((e Int)) (!
  (Set_in e (Set_singleton e))
  :pattern ((Set_singleton e))
  :qid |$Set[Int]_prog.in_singleton_set|)))
(assert (forall ((e1 Int) (e2 Int)) (!
  (= (Set_in e1 (Set_singleton e2)) (= e1 e2))
  :pattern ((Set_in e1 (Set_singleton e2)))
  :qid |$Set[Int]_prog.in_singleton_set_equality|)))
(assert (forall ((e Int)) (!
  (= (Set_card (Set_singleton e)) 1)
  :pattern ((Set_card (Set_singleton e)))
  :qid |$Set[Int]_prog.singleton_set_cardinality|)))
(assert (forall ((s Set<Int>) (e Int)) (!
  (Set_in e (Set_unionone s e))
  :pattern ((Set_unionone s e))
  :qid |$Set[Int]_prog.in_unionone_same|)))
(assert (forall ((s Set<Int>) (e1 Int) (e2 Int)) (!
  (= (Set_in e1 (Set_unionone s e2)) (or (= e1 e2) (Set_in e1 s)))
  :pattern ((Set_in e1 (Set_unionone s e2)))
  :qid |$Set[Int]_prog.in_unionone_other|)))
(assert (forall ((s Set<Int>) (e1 Int) (e2 Int)) (!
  (implies (Set_in e1 s) (Set_in e1 (Set_unionone s e2)))
  :pattern ((Set_in e1 s) (Set_unionone s e2))
  :qid |$Set[Int]_prog.invariance_in_unionone|)))
(assert (forall ((s Set<Int>) (e Int)) (!
  (implies (Set_in e s) (= (Set_card (Set_unionone s e)) (Set_card s)))
  :pattern ((Set_card (Set_unionone s e)))
  :qid |$Set[Int]_prog.unionone_cardinality_invariant|)))
(assert (forall ((s Set<Int>) (e Int)) (!
  (implies
    (not (Set_in e s))
    (= (Set_card (Set_unionone s e)) (+ (Set_card s) 1)))
  :pattern ((Set_card (Set_unionone s e)))
  :qid |$Set[Int]_prog.unionone_cardinality_changed|)))
(assert (forall ((s1 Set<Int>) (s2 Set<Int>) (e Int)) (!
  (= (Set_in e (Set_union s1 s2)) (or (Set_in e s1) (Set_in e s2)))
  :pattern ((Set_in e (Set_union s1 s2)))
  :qid |$Set[Int]_prog.in_union_in_one|)))
(assert (forall ((s1 Set<Int>) (s2 Set<Int>) (e Int)) (!
  (implies (Set_in e s1) (Set_in e (Set_union s1 s2)))
  :pattern ((Set_in e s1) (Set_union s1 s2))
  :qid |$Set[Int]_prog.in_left_in_union|)))
(assert (forall ((s1 Set<Int>) (s2 Set<Int>) (e Int)) (!
  (implies (Set_in e s2) (Set_in e (Set_union s1 s2)))
  :pattern ((Set_in e s2) (Set_union s1 s2))
  :qid |$Set[Int]_prog.in_right_in_union|)))
(assert (forall ((s1 Set<Int>) (s2 Set<Int>) (e Int)) (!
  (= (Set_in e (Set_intersection s1 s2)) (and (Set_in e s1) (Set_in e s2)))
  :pattern ((Set_in e (Set_intersection s1 s2)))
  :pattern ((Set_intersection s1 s2) (Set_in e s1))
  :pattern ((Set_intersection s1 s2) (Set_in e s2))
  :qid |$Set[Int]_prog.in_intersection_in_both|)))
(assert (forall ((s1 Set<Int>) (s2 Set<Int>)) (!
  (= (Set_union s1 (Set_union s1 s2)) (Set_union s1 s2))
  :pattern ((Set_union s1 (Set_union s1 s2)))
  :qid |$Set[Int]_prog.union_left_idempotency|)))
(assert (forall ((s1 Set<Int>) (s2 Set<Int>)) (!
  (= (Set_union (Set_union s1 s2) s2) (Set_union s1 s2))
  :pattern ((Set_union (Set_union s1 s2) s2))
  :qid |$Set[Int]_prog.union_right_idempotency|)))
(assert (forall ((s1 Set<Int>) (s2 Set<Int>)) (!
  (= (Set_intersection s1 (Set_intersection s1 s2)) (Set_intersection s1 s2))
  :pattern ((Set_intersection s1 (Set_intersection s1 s2)))
  :qid |$Set[Int]_prog.intersection_left_idempotency|)))
(assert (forall ((s1 Set<Int>) (s2 Set<Int>)) (!
  (= (Set_intersection (Set_intersection s1 s2) s2) (Set_intersection s1 s2))
  :pattern ((Set_intersection (Set_intersection s1 s2) s2))
  :qid |$Set[Int]_prog.intersection_right_idempotency|)))
(assert (forall ((s1 Set<Int>) (s2 Set<Int>)) (!
  (=
    (+ (Set_card (Set_union s1 s2)) (Set_card (Set_intersection s1 s2)))
    (+ (Set_card s1) (Set_card s2)))
  :pattern ((Set_card (Set_union s1 s2)))
  :pattern ((Set_card (Set_intersection s1 s2)))
  :qid |$Set[Int]_prog.cardinality_sums|)))
(assert (forall ((s1 Set<Int>) (s2 Set<Int>) (e Int)) (!
  (= (Set_in e (Set_difference s1 s2)) (and (Set_in e s1) (not (Set_in e s2))))
  :pattern ((Set_in e (Set_difference s1 s2)))
  :qid |$Set[Int]_prog.in_difference|)))
(assert (forall ((s1 Set<Int>) (s2 Set<Int>) (e Int)) (!
  (implies (Set_in e s2) (not (Set_in e (Set_difference s1 s2))))
  :pattern ((Set_difference s1 s2) (Set_in e s2))
  :qid |$Set[Int]_prog.not_in_difference|)))
(assert (forall ((s1 Set<Int>) (s2 Set<Int>)) (!
  (=
    (Set_subset s1 s2)
    (forall ((e Int)) (!
      (implies (Set_in e s1) (Set_in e s2))
      :pattern ((Set_in e s1))
      :pattern ((Set_in e s2))
      )))
  :pattern ((Set_subset s1 s2))
  :qid |$Set[Int]_prog.subset_definition|)))
(assert (forall ((s1 Set<Int>) (s2 Set<Int>)) (!
  (=
    (Set_equal s1 s2)
    (forall ((e Int)) (!
      (= (Set_in e s1) (Set_in e s2))
      :pattern ((Set_in e s1))
      :pattern ((Set_in e s2))
      )))
  :pattern ((Set_equal s1 s2))
  :qid |$Set[Int]_prog.equality_definition|)))
(assert (forall ((s1 Set<Int>) (s2 Set<Int>)) (!
  (implies (Set_equal s1 s2) (= s1 s2))
  :pattern ((Set_equal s1 s2))
  :qid |$Set[Int]_prog.native_equality|)))
(assert (forall ((s1 Set<Int>) (s2 Set<Int>)) (!
  (=
    (Set_disjoint s1 s2)
    (forall ((e Int)) (!
      (or (not (Set_in e s1)) (not (Set_in e s2)))
      :pattern ((Set_in e s1))
      :pattern ((Set_in e s2))
      )))
  :pattern ((Set_disjoint s1 s2))
  :qid |$Set[Int]_prog.disjointness_definition|)))
(assert (forall ((s1 Set<Int>) (s2 Set<Int>)) (!
  (and
    (=
      (+
        (+ (Set_card (Set_difference s1 s2)) (Set_card (Set_difference s2 s1)))
        (Set_card (Set_intersection s1 s2)))
      (Set_card (Set_union s1 s2)))
    (=
      (Set_card (Set_difference s1 s2))
      (- (Set_card s1) (Set_card (Set_intersection s1 s2)))))
  :pattern ((Set_card (Set_difference s1 s2)))
  :qid |$Set[Int]_prog.cardinality_difference|)))
(assert (forall ((s Set<$Ref>)) (!
  (<= 0 (Set_card s))
  :pattern ((Set_card s))
  :qid |$Set[Ref]_prog.card_non_negative|)))
(assert (forall ((e $Ref)) (!
  (not (Set_in e (as Set_empty  Set<$Ref>)))
  :pattern ((Set_in e (as Set_empty  Set<$Ref>)))
  :qid |$Set[Ref]_prog.in_empty_set|)))
(assert (forall ((s Set<$Ref>)) (!
  (and
    (= (= (Set_card s) 0) (= s (as Set_empty  Set<$Ref>)))
    (implies
      (not (= (Set_card s) 0))
      (exists ((e $Ref)) (!
        (Set_in e s)
        :pattern ((Set_in e s))
        ))))
  :pattern ((Set_card s))
  :qid |$Set[Ref]_prog.empty_set_cardinality|)))
(assert (forall ((e $Ref)) (!
  (Set_in e (Set_singleton e))
  :pattern ((Set_singleton e))
  :qid |$Set[Ref]_prog.in_singleton_set|)))
(assert (forall ((e1 $Ref) (e2 $Ref)) (!
  (= (Set_in e1 (Set_singleton e2)) (= e1 e2))
  :pattern ((Set_in e1 (Set_singleton e2)))
  :qid |$Set[Ref]_prog.in_singleton_set_equality|)))
(assert (forall ((e $Ref)) (!
  (= (Set_card (Set_singleton e)) 1)
  :pattern ((Set_card (Set_singleton e)))
  :qid |$Set[Ref]_prog.singleton_set_cardinality|)))
(assert (forall ((s Set<$Ref>) (e $Ref)) (!
  (Set_in e (Set_unionone s e))
  :pattern ((Set_unionone s e))
  :qid |$Set[Ref]_prog.in_unionone_same|)))
(assert (forall ((s Set<$Ref>) (e1 $Ref) (e2 $Ref)) (!
  (= (Set_in e1 (Set_unionone s e2)) (or (= e1 e2) (Set_in e1 s)))
  :pattern ((Set_in e1 (Set_unionone s e2)))
  :qid |$Set[Ref]_prog.in_unionone_other|)))
(assert (forall ((s Set<$Ref>) (e1 $Ref) (e2 $Ref)) (!
  (implies (Set_in e1 s) (Set_in e1 (Set_unionone s e2)))
  :pattern ((Set_in e1 s) (Set_unionone s e2))
  :qid |$Set[Ref]_prog.invariance_in_unionone|)))
(assert (forall ((s Set<$Ref>) (e $Ref)) (!
  (implies (Set_in e s) (= (Set_card (Set_unionone s e)) (Set_card s)))
  :pattern ((Set_card (Set_unionone s e)))
  :qid |$Set[Ref]_prog.unionone_cardinality_invariant|)))
(assert (forall ((s Set<$Ref>) (e $Ref)) (!
  (implies
    (not (Set_in e s))
    (= (Set_card (Set_unionone s e)) (+ (Set_card s) 1)))
  :pattern ((Set_card (Set_unionone s e)))
  :qid |$Set[Ref]_prog.unionone_cardinality_changed|)))
(assert (forall ((s1 Set<$Ref>) (s2 Set<$Ref>) (e $Ref)) (!
  (= (Set_in e (Set_union s1 s2)) (or (Set_in e s1) (Set_in e s2)))
  :pattern ((Set_in e (Set_union s1 s2)))
  :qid |$Set[Ref]_prog.in_union_in_one|)))
(assert (forall ((s1 Set<$Ref>) (s2 Set<$Ref>) (e $Ref)) (!
  (implies (Set_in e s1) (Set_in e (Set_union s1 s2)))
  :pattern ((Set_in e s1) (Set_union s1 s2))
  :qid |$Set[Ref]_prog.in_left_in_union|)))
(assert (forall ((s1 Set<$Ref>) (s2 Set<$Ref>) (e $Ref)) (!
  (implies (Set_in e s2) (Set_in e (Set_union s1 s2)))
  :pattern ((Set_in e s2) (Set_union s1 s2))
  :qid |$Set[Ref]_prog.in_right_in_union|)))
(assert (forall ((s1 Set<$Ref>) (s2 Set<$Ref>) (e $Ref)) (!
  (= (Set_in e (Set_intersection s1 s2)) (and (Set_in e s1) (Set_in e s2)))
  :pattern ((Set_in e (Set_intersection s1 s2)))
  :pattern ((Set_intersection s1 s2) (Set_in e s1))
  :pattern ((Set_intersection s1 s2) (Set_in e s2))
  :qid |$Set[Ref]_prog.in_intersection_in_both|)))
(assert (forall ((s1 Set<$Ref>) (s2 Set<$Ref>)) (!
  (= (Set_union s1 (Set_union s1 s2)) (Set_union s1 s2))
  :pattern ((Set_union s1 (Set_union s1 s2)))
  :qid |$Set[Ref]_prog.union_left_idempotency|)))
(assert (forall ((s1 Set<$Ref>) (s2 Set<$Ref>)) (!
  (= (Set_union (Set_union s1 s2) s2) (Set_union s1 s2))
  :pattern ((Set_union (Set_union s1 s2) s2))
  :qid |$Set[Ref]_prog.union_right_idempotency|)))
(assert (forall ((s1 Set<$Ref>) (s2 Set<$Ref>)) (!
  (= (Set_intersection s1 (Set_intersection s1 s2)) (Set_intersection s1 s2))
  :pattern ((Set_intersection s1 (Set_intersection s1 s2)))
  :qid |$Set[Ref]_prog.intersection_left_idempotency|)))
(assert (forall ((s1 Set<$Ref>) (s2 Set<$Ref>)) (!
  (= (Set_intersection (Set_intersection s1 s2) s2) (Set_intersection s1 s2))
  :pattern ((Set_intersection (Set_intersection s1 s2) s2))
  :qid |$Set[Ref]_prog.intersection_right_idempotency|)))
(assert (forall ((s1 Set<$Ref>) (s2 Set<$Ref>)) (!
  (=
    (+ (Set_card (Set_union s1 s2)) (Set_card (Set_intersection s1 s2)))
    (+ (Set_card s1) (Set_card s2)))
  :pattern ((Set_card (Set_union s1 s2)))
  :pattern ((Set_card (Set_intersection s1 s2)))
  :qid |$Set[Ref]_prog.cardinality_sums|)))
(assert (forall ((s1 Set<$Ref>) (s2 Set<$Ref>) (e $Ref)) (!
  (= (Set_in e (Set_difference s1 s2)) (and (Set_in e s1) (not (Set_in e s2))))
  :pattern ((Set_in e (Set_difference s1 s2)))
  :qid |$Set[Ref]_prog.in_difference|)))
(assert (forall ((s1 Set<$Ref>) (s2 Set<$Ref>) (e $Ref)) (!
  (implies (Set_in e s2) (not (Set_in e (Set_difference s1 s2))))
  :pattern ((Set_difference s1 s2) (Set_in e s2))
  :qid |$Set[Ref]_prog.not_in_difference|)))
(assert (forall ((s1 Set<$Ref>) (s2 Set<$Ref>)) (!
  (=
    (Set_subset s1 s2)
    (forall ((e $Ref)) (!
      (implies (Set_in e s1) (Set_in e s2))
      :pattern ((Set_in e s1))
      :pattern ((Set_in e s2))
      )))
  :pattern ((Set_subset s1 s2))
  :qid |$Set[Ref]_prog.subset_definition|)))
(assert (forall ((s1 Set<$Ref>) (s2 Set<$Ref>)) (!
  (=
    (Set_equal s1 s2)
    (forall ((e $Ref)) (!
      (= (Set_in e s1) (Set_in e s2))
      :pattern ((Set_in e s1))
      :pattern ((Set_in e s2))
      )))
  :pattern ((Set_equal s1 s2))
  :qid |$Set[Ref]_prog.equality_definition|)))
(assert (forall ((s1 Set<$Ref>) (s2 Set<$Ref>)) (!
  (implies (Set_equal s1 s2) (= s1 s2))
  :pattern ((Set_equal s1 s2))
  :qid |$Set[Ref]_prog.native_equality|)))
(assert (forall ((s1 Set<$Ref>) (s2 Set<$Ref>)) (!
  (=
    (Set_disjoint s1 s2)
    (forall ((e $Ref)) (!
      (or (not (Set_in e s1)) (not (Set_in e s2)))
      :pattern ((Set_in e s1))
      :pattern ((Set_in e s2))
      )))
  :pattern ((Set_disjoint s1 s2))
  :qid |$Set[Ref]_prog.disjointness_definition|)))
(assert (forall ((s1 Set<$Ref>) (s2 Set<$Ref>)) (!
  (and
    (=
      (+
        (+ (Set_card (Set_difference s1 s2)) (Set_card (Set_difference s2 s1)))
        (Set_card (Set_intersection s1 s2)))
      (Set_card (Set_union s1 s2)))
    (=
      (Set_card (Set_difference s1 s2))
      (- (Set_card s1) (Set_card (Set_intersection s1 s2)))))
  :pattern ((Set_card (Set_difference s1 s2)))
  :qid |$Set[Ref]_prog.cardinality_difference|)))
(assert (forall ((s Set<$Snap>)) (!
  (<= 0 (Set_card s))
  :pattern ((Set_card s))
  :qid |$Set[Snap]_prog.card_non_negative|)))
(assert (forall ((e $Snap)) (!
  (not (Set_in e (as Set_empty  Set<$Snap>)))
  :pattern ((Set_in e (as Set_empty  Set<$Snap>)))
  :qid |$Set[Snap]_prog.in_empty_set|)))
(assert (forall ((s Set<$Snap>)) (!
  (and
    (= (= (Set_card s) 0) (= s (as Set_empty  Set<$Snap>)))
    (implies
      (not (= (Set_card s) 0))
      (exists ((e $Snap)) (!
        (Set_in e s)
        :pattern ((Set_in e s))
        ))))
  :pattern ((Set_card s))
  :qid |$Set[Snap]_prog.empty_set_cardinality|)))
(assert (forall ((e $Snap)) (!
  (Set_in e (Set_singleton e))
  :pattern ((Set_singleton e))
  :qid |$Set[Snap]_prog.in_singleton_set|)))
(assert (forall ((e1 $Snap) (e2 $Snap)) (!
  (= (Set_in e1 (Set_singleton e2)) (= e1 e2))
  :pattern ((Set_in e1 (Set_singleton e2)))
  :qid |$Set[Snap]_prog.in_singleton_set_equality|)))
(assert (forall ((e $Snap)) (!
  (= (Set_card (Set_singleton e)) 1)
  :pattern ((Set_card (Set_singleton e)))
  :qid |$Set[Snap]_prog.singleton_set_cardinality|)))
(assert (forall ((s Set<$Snap>) (e $Snap)) (!
  (Set_in e (Set_unionone s e))
  :pattern ((Set_unionone s e))
  :qid |$Set[Snap]_prog.in_unionone_same|)))
(assert (forall ((s Set<$Snap>) (e1 $Snap) (e2 $Snap)) (!
  (= (Set_in e1 (Set_unionone s e2)) (or (= e1 e2) (Set_in e1 s)))
  :pattern ((Set_in e1 (Set_unionone s e2)))
  :qid |$Set[Snap]_prog.in_unionone_other|)))
(assert (forall ((s Set<$Snap>) (e1 $Snap) (e2 $Snap)) (!
  (implies (Set_in e1 s) (Set_in e1 (Set_unionone s e2)))
  :pattern ((Set_in e1 s) (Set_unionone s e2))
  :qid |$Set[Snap]_prog.invariance_in_unionone|)))
(assert (forall ((s Set<$Snap>) (e $Snap)) (!
  (implies (Set_in e s) (= (Set_card (Set_unionone s e)) (Set_card s)))
  :pattern ((Set_card (Set_unionone s e)))
  :qid |$Set[Snap]_prog.unionone_cardinality_invariant|)))
(assert (forall ((s Set<$Snap>) (e $Snap)) (!
  (implies
    (not (Set_in e s))
    (= (Set_card (Set_unionone s e)) (+ (Set_card s) 1)))
  :pattern ((Set_card (Set_unionone s e)))
  :qid |$Set[Snap]_prog.unionone_cardinality_changed|)))
(assert (forall ((s1 Set<$Snap>) (s2 Set<$Snap>) (e $Snap)) (!
  (= (Set_in e (Set_union s1 s2)) (or (Set_in e s1) (Set_in e s2)))
  :pattern ((Set_in e (Set_union s1 s2)))
  :qid |$Set[Snap]_prog.in_union_in_one|)))
(assert (forall ((s1 Set<$Snap>) (s2 Set<$Snap>) (e $Snap)) (!
  (implies (Set_in e s1) (Set_in e (Set_union s1 s2)))
  :pattern ((Set_in e s1) (Set_union s1 s2))
  :qid |$Set[Snap]_prog.in_left_in_union|)))
(assert (forall ((s1 Set<$Snap>) (s2 Set<$Snap>) (e $Snap)) (!
  (implies (Set_in e s2) (Set_in e (Set_union s1 s2)))
  :pattern ((Set_in e s2) (Set_union s1 s2))
  :qid |$Set[Snap]_prog.in_right_in_union|)))
(assert (forall ((s1 Set<$Snap>) (s2 Set<$Snap>) (e $Snap)) (!
  (= (Set_in e (Set_intersection s1 s2)) (and (Set_in e s1) (Set_in e s2)))
  :pattern ((Set_in e (Set_intersection s1 s2)))
  :pattern ((Set_intersection s1 s2) (Set_in e s1))
  :pattern ((Set_intersection s1 s2) (Set_in e s2))
  :qid |$Set[Snap]_prog.in_intersection_in_both|)))
(assert (forall ((s1 Set<$Snap>) (s2 Set<$Snap>)) (!
  (= (Set_union s1 (Set_union s1 s2)) (Set_union s1 s2))
  :pattern ((Set_union s1 (Set_union s1 s2)))
  :qid |$Set[Snap]_prog.union_left_idempotency|)))
(assert (forall ((s1 Set<$Snap>) (s2 Set<$Snap>)) (!
  (= (Set_union (Set_union s1 s2) s2) (Set_union s1 s2))
  :pattern ((Set_union (Set_union s1 s2) s2))
  :qid |$Set[Snap]_prog.union_right_idempotency|)))
(assert (forall ((s1 Set<$Snap>) (s2 Set<$Snap>)) (!
  (= (Set_intersection s1 (Set_intersection s1 s2)) (Set_intersection s1 s2))
  :pattern ((Set_intersection s1 (Set_intersection s1 s2)))
  :qid |$Set[Snap]_prog.intersection_left_idempotency|)))
(assert (forall ((s1 Set<$Snap>) (s2 Set<$Snap>)) (!
  (= (Set_intersection (Set_intersection s1 s2) s2) (Set_intersection s1 s2))
  :pattern ((Set_intersection (Set_intersection s1 s2) s2))
  :qid |$Set[Snap]_prog.intersection_right_idempotency|)))
(assert (forall ((s1 Set<$Snap>) (s2 Set<$Snap>)) (!
  (=
    (+ (Set_card (Set_union s1 s2)) (Set_card (Set_intersection s1 s2)))
    (+ (Set_card s1) (Set_card s2)))
  :pattern ((Set_card (Set_union s1 s2)))
  :pattern ((Set_card (Set_intersection s1 s2)))
  :qid |$Set[Snap]_prog.cardinality_sums|)))
(assert (forall ((s1 Set<$Snap>) (s2 Set<$Snap>) (e $Snap)) (!
  (= (Set_in e (Set_difference s1 s2)) (and (Set_in e s1) (not (Set_in e s2))))
  :pattern ((Set_in e (Set_difference s1 s2)))
  :qid |$Set[Snap]_prog.in_difference|)))
(assert (forall ((s1 Set<$Snap>) (s2 Set<$Snap>) (e $Snap)) (!
  (implies (Set_in e s2) (not (Set_in e (Set_difference s1 s2))))
  :pattern ((Set_difference s1 s2) (Set_in e s2))
  :qid |$Set[Snap]_prog.not_in_difference|)))
(assert (forall ((s1 Set<$Snap>) (s2 Set<$Snap>)) (!
  (=
    (Set_subset s1 s2)
    (forall ((e $Snap)) (!
      (implies (Set_in e s1) (Set_in e s2))
      :pattern ((Set_in e s1))
      :pattern ((Set_in e s2))
      )))
  :pattern ((Set_subset s1 s2))
  :qid |$Set[Snap]_prog.subset_definition|)))
(assert (forall ((s1 Set<$Snap>) (s2 Set<$Snap>)) (!
  (=
    (Set_equal s1 s2)
    (forall ((e $Snap)) (!
      (= (Set_in e s1) (Set_in e s2))
      :pattern ((Set_in e s1))
      :pattern ((Set_in e s2))
      )))
  :pattern ((Set_equal s1 s2))
  :qid |$Set[Snap]_prog.equality_definition|)))
(assert (forall ((s1 Set<$Snap>) (s2 Set<$Snap>)) (!
  (implies (Set_equal s1 s2) (= s1 s2))
  :pattern ((Set_equal s1 s2))
  :qid |$Set[Snap]_prog.native_equality|)))
(assert (forall ((s1 Set<$Snap>) (s2 Set<$Snap>)) (!
  (=
    (Set_disjoint s1 s2)
    (forall ((e $Snap)) (!
      (or (not (Set_in e s1)) (not (Set_in e s2)))
      :pattern ((Set_in e s1))
      :pattern ((Set_in e s2))
      )))
  :pattern ((Set_disjoint s1 s2))
  :qid |$Set[Snap]_prog.disjointness_definition|)))
(assert (forall ((s1 Set<$Snap>) (s2 Set<$Snap>)) (!
  (and
    (=
      (+
        (+ (Set_card (Set_difference s1 s2)) (Set_card (Set_difference s2 s1)))
        (Set_card (Set_intersection s1 s2)))
      (Set_card (Set_union s1 s2)))
    (=
      (Set_card (Set_difference s1 s2))
      (- (Set_card s1) (Set_card (Set_intersection s1 s2)))))
  :pattern ((Set_card (Set_difference s1 s2)))
  :qid |$Set[Snap]_prog.cardinality_difference|)))
(assert (forall ((a2 array)) (!
  (forall ((i1 Int)) (!
    (and
      (= (loc_inv_1<array> (array_loc<Ref> a2 i1)) a2)
      (= (loc_inv_2<Int> (array_loc<Ref> a2 i1)) i1))
    :pattern ((loc_inv_1<array> (array_loc<Ref> a2 i1)))
    :pattern ((loc_inv_2<Int> (array_loc<Ref> a2 i1)))
    ))
  
  )))
(assert (forall ((a2 array)) (!
  (>= (alen<Int> a2) 0)
  :pattern ((alen<Int> a2))
  )))
(assert (forall ((x1 array)) (!
  (not (= (as None<option<array>>  option<array>) (some<option<array>> x1)))
  :pattern ((some<option<array>> x1))
  )))
(assert (forall ((x1 array)) (!
  (= (option_get<array> (some<option<array>> x1)) x1)
  :pattern ((option_get<array> (some<option<array>> x1)))
  )))
(assert (forall ((opt1 option<array>)) (!
  (= (some<option<array>> (option_get<array> opt1)) opt1)
  :pattern ((some<option<array>> (option_get<array> opt1)))
  )))
(assert (forall ((v t_null)) (!
  (= (as v_null<t_null>  t_null) v)
  
  )))
(assert (forall ((x1 any)) (!
  (not (= (as None<option<any>>  option<any>) (some<option<any>> x1)))
  :pattern ((some<option<any>> x1))
  )))
(assert (forall ((x1 any)) (!
  (= (option_get<any> (some<option<any>> x1)) x1)
  :pattern ((option_get<any> (some<option<any>> x1)))
  )))
(assert (forall ((opt1 option<any>)) (!
  (= (some<option<any>> (option_get<any> opt1)) opt1)
  :pattern ((some<option<any>> (option_get<any> opt1)))
  )))
(assert (forall ((v void)) (!
  (= (as unit<void>  void) v)
  
  )))
; /field_value_functions_axioms.smt2 [int: Int]
(assert (forall ((vs $FVF<Int>) (ws $FVF<Int>)) (!
    (implies
      (and
        (Set_equal ($FVF.domain_int vs) ($FVF.domain_int ws))
        (forall ((x $Ref)) (!
          (implies
            (Set_in x ($FVF.domain_int vs))
            (= ($FVF.lookup_int vs x) ($FVF.lookup_int ws x)))
          :pattern (($FVF.lookup_int vs x) ($FVF.lookup_int ws x))
          :qid |qp.$FVF<Int>-eq-inner|
          )))
      (= vs ws))
    :pattern (($SortWrappers.$FVF<Int>To$Snap vs)
              ($SortWrappers.$FVF<Int>To$Snap ws)
              )
    :qid |qp.$FVF<Int>-eq-outer|
    )))
(assert (forall ((r $Ref) (pm $FPM)) (!
    ($Perm.isValidVar ($FVF.perm_int pm r))
    :pattern ($FVF.perm_int pm r))))
(assert (forall ((r $Ref) (f Int)) (!
    (= ($FVF.loc_int f r) true)
    :pattern ($FVF.loc_int f r))))
; /field_value_functions_axioms.smt2 [option$array$: option[array]]
(assert (forall ((vs $FVF<option<array>>) (ws $FVF<option<array>>)) (!
    (implies
      (and
        (Set_equal ($FVF.domain_option$array$ vs) ($FVF.domain_option$array$ ws))
        (forall ((x $Ref)) (!
          (implies
            (Set_in x ($FVF.domain_option$array$ vs))
            (= ($FVF.lookup_option$array$ vs x) ($FVF.lookup_option$array$ ws x)))
          :pattern (($FVF.lookup_option$array$ vs x) ($FVF.lookup_option$array$ ws x))
          :qid |qp.$FVF<option<array>>-eq-inner|
          )))
      (= vs ws))
    :pattern (($SortWrappers.$FVF<option<array>>To$Snap vs)
              ($SortWrappers.$FVF<option<array>>To$Snap ws)
              )
    :qid |qp.$FVF<option<array>>-eq-outer|
    )))
(assert (forall ((r $Ref) (pm $FPM)) (!
    ($Perm.isValidVar ($FVF.perm_option$array$ pm r))
    :pattern ($FVF.perm_option$array$ pm r))))
(assert (forall ((r $Ref) (f option<array>)) (!
    (= ($FVF.loc_option$array$ f r) true)
    :pattern ($FVF.loc_option$array$ f r))))
; /field_value_functions_axioms.smt2 [bool: Bool]
(assert (forall ((vs $FVF<Bool>) (ws $FVF<Bool>)) (!
    (implies
      (and
        (Set_equal ($FVF.domain_bool vs) ($FVF.domain_bool ws))
        (forall ((x $Ref)) (!
          (implies
            (Set_in x ($FVF.domain_bool vs))
            (= ($FVF.lookup_bool vs x) ($FVF.lookup_bool ws x)))
          :pattern (($FVF.lookup_bool vs x) ($FVF.lookup_bool ws x))
          :qid |qp.$FVF<Bool>-eq-inner|
          )))
      (= vs ws))
    :pattern (($SortWrappers.$FVF<Bool>To$Snap vs)
              ($SortWrappers.$FVF<Bool>To$Snap ws)
              )
    :qid |qp.$FVF<Bool>-eq-outer|
    )))
(assert (forall ((r $Ref) (pm $FPM)) (!
    ($Perm.isValidVar ($FVF.perm_bool pm r))
    :pattern ($FVF.perm_bool pm r))))
(assert (forall ((r $Ref) (f Bool)) (!
    (= ($FVF.loc_bool f r) true)
    :pattern ($FVF.loc_bool f r))))
; End preamble
; ------------------------------------------------------------
; State saturation: after preamble
(set-option :timeout 100)
(check-sat)
; unknown
; ------------------------------------------------------------
; Begin function- and predicate-related preamble
; Declaring symbols related to program functions (from verification)
(declare-fun $k@85@00 () $Perm)
(declare-fun inv@86@00 ($Snap $Ref option<array> Int $Ref) Int)
(declare-fun sm@87@00 ($Snap $Ref option<array> Int) $FVF<Int>)
(assert (forall ((s@$ $Snap) (a2@0@00 array) (i1@1@00 Int)) (!
  (= (aloc%limited s@$ a2@0@00 i1@1@00) (aloc s@$ a2@0@00 i1@1@00))
  :pattern ((aloc s@$ a2@0@00 i1@1@00))
  )))
(assert (forall ((s@$ $Snap) (a2@0@00 array) (i1@1@00 Int)) (!
  (aloc%stateless a2@0@00 i1@1@00)
  :pattern ((aloc%limited s@$ a2@0@00 i1@1@00))
  )))
(assert (forall ((s@$ $Snap) (a2@0@00 array) (i1@1@00 Int)) (!
  (let ((result@2@00 (aloc%limited s@$ a2@0@00 i1@1@00))) (implies
    (and (<= 0 i1@1@00) (< i1@1@00 (alen<Int> a2@0@00)))
    (and
      (= (loc_inv_1<array> result@2@00) a2@0@00)
      (= (loc_inv_2<Int> result@2@00) i1@1@00))))
  :pattern ((aloc%limited s@$ a2@0@00 i1@1@00))
  )))
(assert (forall ((s@$ $Snap) (a2@0@00 array) (i1@1@00 Int)) (!
  (implies
    (and (<= 0 i1@1@00) (< i1@1@00 (alen<Int> a2@0@00)))
    (= (aloc s@$ a2@0@00 i1@1@00) (array_loc<Ref> a2@0@00 i1@1@00)))
  :pattern ((aloc s@$ a2@0@00 i1@1@00))
  )))
(assert (forall ((s@$ $Snap) (opt1@3@00 option<array>)) (!
  (= (opt_get1%limited s@$ opt1@3@00) (opt_get1 s@$ opt1@3@00))
  :pattern ((opt_get1 s@$ opt1@3@00))
  )))
(assert (forall ((s@$ $Snap) (opt1@3@00 option<array>)) (!
  (opt_get1%stateless opt1@3@00)
  :pattern ((opt_get1%limited s@$ opt1@3@00))
  )))
(assert (forall ((s@$ $Snap) (opt1@3@00 option<array>)) (!
  (let ((result@4@00 (opt_get1%limited s@$ opt1@3@00))) (implies
    (not (= opt1@3@00 (as None<option<array>>  option<array>)))
    (= (some<option<array>> result@4@00) opt1@3@00)))
  :pattern ((opt_get1%limited s@$ opt1@3@00))
  )))
(assert (forall ((s@$ $Snap) (opt1@3@00 option<array>)) (!
  (implies
    (not (= opt1@3@00 (as None<option<array>>  option<array>)))
    (= (opt_get1 s@$ opt1@3@00) (option_get<array> opt1@3@00)))
  :pattern ((opt_get1 s@$ opt1@3@00))
  )))
(assert (forall ((s@$ $Snap) (t@5@00 any)) (!
  (= (any_as%limited s@$ t@5@00) (any_as s@$ t@5@00))
  :pattern ((any_as s@$ t@5@00))
  )))
(assert (forall ((s@$ $Snap) (t@5@00 any)) (!
  (any_as%stateless t@5@00)
  :pattern ((any_as%limited s@$ t@5@00))
  )))
(assert (forall ((s@$ $Snap) (opt1@7@00 option<any>)) (!
  (= (opt_get%limited s@$ opt1@7@00) (opt_get s@$ opt1@7@00))
  :pattern ((opt_get s@$ opt1@7@00))
  )))
(assert (forall ((s@$ $Snap) (opt1@7@00 option<any>)) (!
  (opt_get%stateless opt1@7@00)
  :pattern ((opt_get%limited s@$ opt1@7@00))
  )))
(assert (forall ((s@$ $Snap) (opt1@7@00 option<any>)) (!
  (let ((result@8@00 (opt_get%limited s@$ opt1@7@00))) (implies
    (not (= opt1@7@00 (as None<option<any>>  option<any>)))
    (= (some<option<any>> result@8@00) opt1@7@00)))
  :pattern ((opt_get%limited s@$ opt1@7@00))
  )))
(assert (forall ((s@$ $Snap) (opt1@7@00 option<any>)) (!
  (implies
    (not (= opt1@7@00 (as None<option<any>>  option<any>)))
    (= (opt_get s@$ opt1@7@00) (option_get<any> opt1@7@00)))
  :pattern ((opt_get s@$ opt1@7@00))
  )))
(assert (forall ((s@$ $Snap) (this@9@00 $Ref) (G@10@00 option<array>) (V@11@00 Int) (s@12@00 Int) (t@13@00 Int)) (!
  (=
    (lemma_skew_symetry%limited s@$ this@9@00 G@10@00 V@11@00 s@12@00 t@13@00)
    (lemma_skew_symetry s@$ this@9@00 G@10@00 V@11@00 s@12@00 t@13@00))
  :pattern ((lemma_skew_symetry s@$ this@9@00 G@10@00 V@11@00 s@12@00 t@13@00))
  )))
(assert (forall ((s@$ $Snap) (this@9@00 $Ref) (G@10@00 option<array>) (V@11@00 Int) (s@12@00 Int) (t@13@00 Int)) (!
  (lemma_skew_symetry%stateless this@9@00 G@10@00 V@11@00 s@12@00 t@13@00)
  :pattern ((lemma_skew_symetry%limited s@$ this@9@00 G@10@00 V@11@00 s@12@00 t@13@00))
  )))
(assert (forall ((s@$ $Snap) (this@9@00 $Ref) (G@10@00 option<array>) (V@11@00 Int) (s@12@00 Int) (t@13@00 Int)) (!
  (implies
    (not (= this@9@00 $Ref.null))
    (= (lemma_skew_symetry s@$ this@9@00 G@10@00 V@11@00 s@12@00 t@13@00) false))
  :pattern ((lemma_skew_symetry s@$ this@9@00 G@10@00 V@11@00 s@12@00 t@13@00))
  )))
(assert (forall ((s@$ $Snap) (this@15@00 $Ref) (G@16@00 option<array>) (V@17@00 Int) (s@18@00 Int) (t@19@00 Int)) (!
  (=
    (FlowNetwork%limited s@$ this@15@00 G@16@00 V@17@00 s@18@00 t@19@00)
    (FlowNetwork s@$ this@15@00 G@16@00 V@17@00 s@18@00 t@19@00))
  :pattern ((FlowNetwork s@$ this@15@00 G@16@00 V@17@00 s@18@00 t@19@00))
  )))
(assert (forall ((s@$ $Snap) (this@15@00 $Ref) (G@16@00 option<array>) (V@17@00 Int) (s@18@00 Int) (t@19@00 Int)) (!
  (FlowNetwork%stateless this@15@00 G@16@00 V@17@00 s@18@00 t@19@00)
  :pattern ((FlowNetwork%limited s@$ this@15@00 G@16@00 V@17@00 s@18@00 t@19@00))
  )))
(assert (forall ((s@$ $Snap) (this@15@00 $Ref) (G@16@00 option<array>) (V@17@00 Int) (s@18@00 Int) (t@19@00 Int)) (!
  (implies
    (not (= this@15@00 $Ref.null))
    (=
      (FlowNetwork s@$ this@15@00 G@16@00 V@17@00 s@18@00 t@19@00)
      (and (and (< 0 V@17@00) (= s@18@00 0)) (not (= s@18@00 t@19@00)))))
  :pattern ((FlowNetwork s@$ this@15@00 G@16@00 V@17@00 s@18@00 t@19@00))
  )))
(assert (forall ((s@$ $Snap) (this@21@00 $Ref) (G@22@00 option<array>) (V@23@00 Int) (s@24@00 Int) (t@25@00 Int)) (!
  (=
    (ExPath%limited s@$ this@21@00 G@22@00 V@23@00 s@24@00 t@25@00)
    (ExPath s@$ this@21@00 G@22@00 V@23@00 s@24@00 t@25@00))
  :pattern ((ExPath s@$ this@21@00 G@22@00 V@23@00 s@24@00 t@25@00))
  )))
(assert (forall ((s@$ $Snap) (this@21@00 $Ref) (G@22@00 option<array>) (V@23@00 Int) (s@24@00 Int) (t@25@00 Int)) (!
  (ExPath%stateless this@21@00 G@22@00 V@23@00 s@24@00 t@25@00)
  :pattern ((ExPath%limited s@$ this@21@00 G@22@00 V@23@00 s@24@00 t@25@00))
  )))
(assert (forall ((s@$ $Snap) (this@21@00 $Ref) (G@22@00 option<array>) (V@23@00 Int) (s@24@00 Int) (t@25@00 Int)) (!
  (implies
    (not (= this@21@00 $Ref.null))
    (= (ExPath s@$ this@21@00 G@22@00 V@23@00 s@24@00 t@25@00) false))
  :pattern ((ExPath s@$ this@21@00 G@22@00 V@23@00 s@24@00 t@25@00))
  )))
(assert (forall ((s@$ $Snap) (this@27@00 $Ref) (G@28@00 option<array>) (V@29@00 Int) (s@30@00 Int) (t@31@00 Int)) (!
  (=
    (value%limited s@$ this@27@00 G@28@00 V@29@00 s@30@00 t@31@00)
    (value s@$ this@27@00 G@28@00 V@29@00 s@30@00 t@31@00))
  :pattern ((value s@$ this@27@00 G@28@00 V@29@00 s@30@00 t@31@00))
  )))
(assert (forall ((s@$ $Snap) (this@27@00 $Ref) (G@28@00 option<array>) (V@29@00 Int) (s@30@00 Int) (t@31@00 Int)) (!
  (value%stateless this@27@00 G@28@00 V@29@00 s@30@00 t@31@00)
  :pattern ((value%limited s@$ this@27@00 G@28@00 V@29@00 s@30@00 t@31@00))
  )))
(assert (forall ((s@$ $Snap) (this@27@00 $Ref) (G@28@00 option<array>) (V@29@00 Int) (s@30@00 Int) (t@31@00 Int)) (!
  (implies
    (not (= this@27@00 $Ref.null))
    (= (value s@$ this@27@00 G@28@00 V@29@00 s@30@00 t@31@00) 0))
  :pattern ((value s@$ this@27@00 G@28@00 V@29@00 s@30@00 t@31@00))
  )))
(assert (forall ((s@$ $Snap) (this@33@00 $Ref) (p@34@00 option<array>) (V@35@00 Int)) (!
  (=
    (valid_graph_vertices%limited s@$ this@33@00 p@34@00 V@35@00)
    (valid_graph_vertices s@$ this@33@00 p@34@00 V@35@00))
  :pattern ((valid_graph_vertices s@$ this@33@00 p@34@00 V@35@00))
  )))
(assert (forall ((s@$ $Snap) (this@33@00 $Ref) (p@34@00 option<array>) (V@35@00 Int)) (!
  (valid_graph_vertices%stateless this@33@00 p@34@00 V@35@00)
  :pattern ((valid_graph_vertices%limited s@$ this@33@00 p@34@00 V@35@00))
  )))
(assert (forall ((s@$ $Snap) (this@33@00 $Ref) (p@34@00 option<array>) (V@35@00 Int)) (!
  (and
    (forall ((i1@84@00 Int)) (!
      (implies
        (and (and (< i1@84@00 V@35@00) (<= 0 i1@84@00)) (< $Perm.No $k@85@00))
        (=
          (inv@86@00 s@$ this@33@00 p@34@00 V@35@00 (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit p@34@00) i1@84@00))
          i1@84@00))
      :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@34@00) i1@84@00))
      ))
    (forall ((r $Ref)) (!
      (implies
        (and
          (and
            (< (inv@86@00 s@$ this@33@00 p@34@00 V@35@00 r) V@35@00)
            (<= 0 (inv@86@00 s@$ this@33@00 p@34@00 V@35@00 r)))
          (< $Perm.No $k@85@00))
        (=
          (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@34@00) (inv@86@00 s@$ this@33@00 p@34@00 V@35@00 r))
          r))
      :pattern ((inv@86@00 s@$ this@33@00 p@34@00 V@35@00 r))
      :qid |int-fctOfInv|))
    (forall ((r $Ref)) (!
      (implies
        (ite
          (and
            (< (inv@86@00 s@$ this@33@00 p@34@00 V@35@00 r) V@35@00)
            (<= 0 (inv@86@00 s@$ this@33@00 p@34@00 V@35@00 r)))
          (< $Perm.No $k@85@00)
          false)
        (=
          ($FVF.lookup_int (sm@87@00 s@$ this@33@00 p@34@00 V@35@00) r)
          ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second s@$)))) r)))
      :pattern (($FVF.lookup_int (sm@87@00 s@$ this@33@00 p@34@00 V@35@00) r))
      :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second s@$)))) r))
      :qid |qp.fvfValDef0|))
    (forall ((r $Ref)) (!
      ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second s@$)))) r) r)
      :pattern (($FVF.lookup_int (sm@87@00 s@$ this@33@00 p@34@00 V@35@00) r))
      :qid |qp.fvfResTrgDef1|))
    ($Perm.isReadVar $k@85@00 $Perm.Write)
    (implies
      (and
        (not (= this@33@00 $Ref.null))
        (not (= p@34@00 (as None<option<array>>  option<array>)))
        (= (alen<Int> (opt_get1 $Snap.unit p@34@00)) V@35@00))
      (=
        (valid_graph_vertices s@$ this@33@00 p@34@00 V@35@00)
        (and
          (forall ((unknown_ Int)) (!
            (implies
              (and
                (<= 0 unknown_)
                (< unknown_ (alen<Int> (opt_get1 $Snap.unit p@34@00))))
              (<=
                0
                ($FVF.lookup_int (sm@87@00 s@$ this@33@00 p@34@00 V@35@00) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit p@34@00) unknown_))))
            :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@34@00) unknown_))
            ))
          (forall ((unknown_ Int)) (!
            (implies
              (and
                (<= 0 unknown_)
                (< unknown_ (alen<Int> (opt_get1 $Snap.unit p@34@00))))
              (<
                ($FVF.lookup_int (sm@87@00 s@$ this@33@00 p@34@00 V@35@00) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit p@34@00) unknown_))
                V@35@00))
            :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@34@00) unknown_))
            ))))))
  :pattern ((valid_graph_vertices s@$ this@33@00 p@34@00 V@35@00))
  )))
(assert (forall ((s@$ $Snap) (amount@37@00 $Perm)) (!
  (= (scale%limited s@$ amount@37@00) (scale s@$ amount@37@00))
  :pattern ((scale s@$ amount@37@00))
  )))
(assert (forall ((s@$ $Snap) (amount@37@00 $Perm)) (!
  (scale%stateless amount@37@00)
  :pattern ((scale%limited s@$ amount@37@00))
  )))
(assert (forall ((s@$ $Snap) (amount@37@00 $Perm)) (!
  (implies (>= amount@37@00 $Perm.No) (= (scale s@$ amount@37@00) amount@37@00))
  :pattern ((scale s@$ amount@37@00))
  )))
(assert (forall ((s@$ $Snap) (t@39@00 any)) (!
  (= (as_any%limited s@$ t@39@00) (as_any s@$ t@39@00))
  :pattern ((as_any s@$ t@39@00))
  )))
(assert (forall ((s@$ $Snap) (t@39@00 any)) (!
  (as_any%stateless t@39@00)
  :pattern ((as_any%limited s@$ t@39@00))
  )))
(assert (forall ((s@$ $Snap) (t@39@00 any)) (!
  (let ((result@40@00 (as_any%limited s@$ t@39@00))) (=
    (any_as $Snap.unit result@40@00)
    t@39@00))
  :pattern ((as_any%limited s@$ t@39@00))
  )))
(assert (forall ((s@$ $Snap) (this@41@00 $Ref) (G@42@00 option<array>) (V@43@00 Int)) (!
  (=
    (ResidualNetwork%limited s@$ this@41@00 G@42@00 V@43@00)
    (ResidualNetwork s@$ this@41@00 G@42@00 V@43@00))
  :pattern ((ResidualNetwork s@$ this@41@00 G@42@00 V@43@00))
  )))
(assert (forall ((s@$ $Snap) (this@41@00 $Ref) (G@42@00 option<array>) (V@43@00 Int)) (!
  (ResidualNetwork%stateless this@41@00 G@42@00 V@43@00)
  :pattern ((ResidualNetwork%limited s@$ this@41@00 G@42@00 V@43@00))
  )))
(assert (forall ((s@$ $Snap) (this@41@00 $Ref) (G@42@00 option<array>) (V@43@00 Int)) (!
  (implies
    (not (= this@41@00 $Ref.null))
    (= (ResidualNetwork s@$ this@41@00 G@42@00 V@43@00) false))
  :pattern ((ResidualNetwork s@$ this@41@00 G@42@00 V@43@00))
  )))
(assert (forall ((s@$ $Snap) (type1@45@00 $Ref)) (!
  (= (type%limited s@$ type1@45@00) (type s@$ type1@45@00))
  :pattern ((type s@$ type1@45@00))
  )))
(assert (forall ((s@$ $Snap) (type1@45@00 $Ref)) (!
  (type%stateless type1@45@00)
  :pattern ((type%limited s@$ type1@45@00))
  )))
(assert (forall ((s@$ $Snap) (type1@45@00 $Ref)) (!
  (let ((result@46@00 (type%limited s@$ type1@45@00))) (and
    (<= 0 result@46@00)
    (< result@46@00 3)
    (implies (= type1@45@00 $Ref.null) (= result@46@00 0))
    (implies (not (= type1@45@00 $Ref.null)) (not (= result@46@00 0)))))
  :pattern ((type%limited s@$ type1@45@00))
  )))
(assert (forall ((s@$ $Snap) (this@47@00 $Ref) (G@48@00 option<array>) (V@49@00 Int) (s@50@00 Int) (t@51@00 Int)) (!
  (=
    (lemma_max_flow_min_cut%limited s@$ this@47@00 G@48@00 V@49@00 s@50@00 t@51@00)
    (lemma_max_flow_min_cut s@$ this@47@00 G@48@00 V@49@00 s@50@00 t@51@00))
  :pattern ((lemma_max_flow_min_cut s@$ this@47@00 G@48@00 V@49@00 s@50@00 t@51@00))
  )))
(assert (forall ((s@$ $Snap) (this@47@00 $Ref) (G@48@00 option<array>) (V@49@00 Int) (s@50@00 Int) (t@51@00 Int)) (!
  (lemma_max_flow_min_cut%stateless this@47@00 G@48@00 V@49@00 s@50@00 t@51@00)
  :pattern ((lemma_max_flow_min_cut%limited s@$ this@47@00 G@48@00 V@49@00 s@50@00 t@51@00))
  )))
(assert (forall ((s@$ $Snap) (this@47@00 $Ref) (G@48@00 option<array>) (V@49@00 Int) (s@50@00 Int) (t@51@00 Int)) (!
  (implies
    (not (= this@47@00 $Ref.null))
    (=
      (lemma_max_flow_min_cut s@$ this@47@00 G@48@00 V@49@00 s@50@00 t@51@00)
      false))
  :pattern ((lemma_max_flow_min_cut s@$ this@47@00 G@48@00 V@49@00 s@50@00 t@51@00))
  )))
(assert (forall ((s@$ $Snap) (this@53@00 $Ref) (G@54@00 option<array>) (V@55@00 Int) (s@56@00 Int) (t@57@00 Int)) (!
  (=
    (lemma_capacity_constrain%limited s@$ this@53@00 G@54@00 V@55@00 s@56@00 t@57@00)
    (lemma_capacity_constrain s@$ this@53@00 G@54@00 V@55@00 s@56@00 t@57@00))
  :pattern ((lemma_capacity_constrain s@$ this@53@00 G@54@00 V@55@00 s@56@00 t@57@00))
  )))
(assert (forall ((s@$ $Snap) (this@53@00 $Ref) (G@54@00 option<array>) (V@55@00 Int) (s@56@00 Int) (t@57@00 Int)) (!
  (lemma_capacity_constrain%stateless this@53@00 G@54@00 V@55@00 s@56@00 t@57@00)
  :pattern ((lemma_capacity_constrain%limited s@$ this@53@00 G@54@00 V@55@00 s@56@00 t@57@00))
  )))
(assert (forall ((s@$ $Snap) (this@53@00 $Ref) (G@54@00 option<array>) (V@55@00 Int) (s@56@00 Int) (t@57@00 Int)) (!
  (implies
    (not (= this@53@00 $Ref.null))
    (=
      (lemma_capacity_constrain s@$ this@53@00 G@54@00 V@55@00 s@56@00 t@57@00)
      false))
  :pattern ((lemma_capacity_constrain s@$ this@53@00 G@54@00 V@55@00 s@56@00 t@57@00))
  )))
(assert (forall ((s@$ $Snap) (opt1@59@00 option<any>) (alt@60@00 any)) (!
  (=
    (opt_or_else%limited s@$ opt1@59@00 alt@60@00)
    (opt_or_else s@$ opt1@59@00 alt@60@00))
  :pattern ((opt_or_else s@$ opt1@59@00 alt@60@00))
  )))
(assert (forall ((s@$ $Snap) (opt1@59@00 option<any>) (alt@60@00 any)) (!
  (opt_or_else%stateless opt1@59@00 alt@60@00)
  :pattern ((opt_or_else%limited s@$ opt1@59@00 alt@60@00))
  )))
(assert (forall ((s@$ $Snap) (opt1@59@00 option<any>) (alt@60@00 any)) (!
  (let ((result@61@00 (opt_or_else%limited s@$ opt1@59@00 alt@60@00))) (and
    (implies
      (= opt1@59@00 (as None<option<any>>  option<any>))
      (= result@61@00 alt@60@00))
    (implies
      (not (= opt1@59@00 (as None<option<any>>  option<any>)))
      (= result@61@00 (opt_get $Snap.unit opt1@59@00)))))
  :pattern ((opt_or_else%limited s@$ opt1@59@00 alt@60@00))
  )))
(assert (forall ((s@$ $Snap) (opt1@59@00 option<any>) (alt@60@00 any)) (!
  (=
    (opt_or_else s@$ opt1@59@00 alt@60@00)
    (ite
      (= opt1@59@00 (as None<option<any>>  option<any>))
      alt@60@00
      (opt_get $Snap.unit opt1@59@00)))
  :pattern ((opt_or_else s@$ opt1@59@00 alt@60@00))
  )))
(assert (forall ((s@$ $Snap) (this@62@00 $Ref) (p@63@00 Seq<Int>) (V@64@00 Int)) (!
  (=
    (valid_graph_vertices1%limited s@$ this@62@00 p@63@00 V@64@00)
    (valid_graph_vertices1 s@$ this@62@00 p@63@00 V@64@00))
  :pattern ((valid_graph_vertices1 s@$ this@62@00 p@63@00 V@64@00))
  )))
(assert (forall ((s@$ $Snap) (this@62@00 $Ref) (p@63@00 Seq<Int>) (V@64@00 Int)) (!
  (valid_graph_vertices1%stateless this@62@00 p@63@00 V@64@00)
  :pattern ((valid_graph_vertices1%limited s@$ this@62@00 p@63@00 V@64@00))
  )))
(assert (forall ((s@$ $Snap) (this@62@00 $Ref) (p@63@00 Seq<Int>) (V@64@00 Int)) (!
  (implies
    (not (= this@62@00 $Ref.null))
    (=
      (valid_graph_vertices1 s@$ this@62@00 p@63@00 V@64@00)
      (and
        (forall ((unknown_ Int)) (!
          (implies
            (and (<= 0 unknown_) (< unknown_ (Seq_length p@63@00)))
            (<= 0 (Seq_index p@63@00 unknown_)))
          :pattern ((Seq_index p@63@00 unknown_))
          ))
        (forall ((unknown_ Int)) (!
          (implies
            (and (<= 0 unknown_) (< unknown_ (Seq_length p@63@00)))
            (< (Seq_index p@63@00 unknown_) V@64@00))
          :pattern ((Seq_index p@63@00 unknown_))
          )))))
  :pattern ((valid_graph_vertices1 s@$ this@62@00 p@63@00 V@64@00))
  )))
(assert (forall ((s@$ $Snap) (this@66@00 $Ref) (G@67@00 option<array>) (V@68@00 Int) (s@69@00 Int) (t@70@00 Int)) (!
  (=
    (flow%limited s@$ this@66@00 G@67@00 V@68@00 s@69@00 t@70@00)
    (flow s@$ this@66@00 G@67@00 V@68@00 s@69@00 t@70@00))
  :pattern ((flow s@$ this@66@00 G@67@00 V@68@00 s@69@00 t@70@00))
  )))
(assert (forall ((s@$ $Snap) (this@66@00 $Ref) (G@67@00 option<array>) (V@68@00 Int) (s@69@00 Int) (t@70@00 Int)) (!
  (flow%stateless this@66@00 G@67@00 V@68@00 s@69@00 t@70@00)
  :pattern ((flow%limited s@$ this@66@00 G@67@00 V@68@00 s@69@00 t@70@00))
  )))
(assert (forall ((s@$ $Snap) (this@66@00 $Ref) (G@67@00 option<array>) (V@68@00 Int) (s@69@00 Int) (t@70@00 Int)) (!
  (implies
    (not (= this@66@00 $Ref.null))
    (= (flow s@$ this@66@00 G@67@00 V@68@00 s@69@00 t@70@00) 0))
  :pattern ((flow s@$ this@66@00 G@67@00 V@68@00 s@69@00 t@70@00))
  )))
(assert (forall ((s@$ $Snap) (this@72@00 $Ref) (G@73@00 option<array>) (V@74@00 Int) (s@75@00 Int) (t@76@00 Int)) (!
  (=
    (lemma_flow_conservation%limited s@$ this@72@00 G@73@00 V@74@00 s@75@00 t@76@00)
    (lemma_flow_conservation s@$ this@72@00 G@73@00 V@74@00 s@75@00 t@76@00))
  :pattern ((lemma_flow_conservation s@$ this@72@00 G@73@00 V@74@00 s@75@00 t@76@00))
  )))
(assert (forall ((s@$ $Snap) (this@72@00 $Ref) (G@73@00 option<array>) (V@74@00 Int) (s@75@00 Int) (t@76@00 Int)) (!
  (lemma_flow_conservation%stateless this@72@00 G@73@00 V@74@00 s@75@00 t@76@00)
  :pattern ((lemma_flow_conservation%limited s@$ this@72@00 G@73@00 V@74@00 s@75@00 t@76@00))
  )))
(assert (forall ((s@$ $Snap) (this@72@00 $Ref) (G@73@00 option<array>) (V@74@00 Int) (s@75@00 Int) (t@76@00 Int)) (!
  (implies
    (not (= this@72@00 $Ref.null))
    (=
      (lemma_flow_conservation s@$ this@72@00 G@73@00 V@74@00 s@75@00 t@76@00)
      false))
  :pattern ((lemma_flow_conservation s@$ this@72@00 G@73@00 V@74@00 s@75@00 t@76@00))
  )))
(assert (forall ((s@$ $Snap) (subtype1@78@00 Int) (subtype2@79@00 Int)) (!
  (=
    (subtype%limited s@$ subtype1@78@00 subtype2@79@00)
    (subtype s@$ subtype1@78@00 subtype2@79@00))
  :pattern ((subtype s@$ subtype1@78@00 subtype2@79@00))
  )))
(assert (forall ((s@$ $Snap) (subtype1@78@00 Int) (subtype2@79@00 Int)) (!
  (subtype%stateless subtype1@78@00 subtype2@79@00)
  :pattern ((subtype%limited s@$ subtype1@78@00 subtype2@79@00))
  )))
(assert (forall ((s@$ $Snap) (subtype1@78@00 Int) (subtype2@79@00 Int)) (!
  (implies
    (and
      (<= 0 subtype1@78@00)
      (< subtype1@78@00 3)
      (<= 0 subtype2@79@00)
      (<= subtype2@79@00 2))
    (=
      (subtype s@$ subtype1@78@00 subtype2@79@00)
      (and
        (implies (= subtype1@78@00 1) (= subtype2@79@00 1))
        (implies (= subtype1@78@00 2) (= subtype2@79@00 2)))))
  :pattern ((subtype s@$ subtype1@78@00 subtype2@79@00))
  )))
; End function- and predicate-related preamble
; ------------------------------------------------------------
; ---------- make_array1 ----------
(declare-const tid@0@06 Int)
(declare-const dim0@1@06 Int)
(declare-const exc@2@06 $Ref)
(declare-const res@3@06 option<array>)
(declare-const tid@4@06 Int)
(declare-const dim0@5@06 Int)
(declare-const exc@6@06 $Ref)
(declare-const res@7@06 option<array>)
(push) ; 1
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
(push) ; 2
(declare-const $t@8@06 $Snap)
(assert (= $t@8@06 ($Snap.combine ($Snap.first $t@8@06) ($Snap.second $t@8@06))))
(assert (= ($Snap.first $t@8@06) $Snap.unit))
; [eval] exc == null
(assert (= exc@6@06 $Ref.null))
(assert (=
  ($Snap.second $t@8@06)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@8@06))
    ($Snap.second ($Snap.second $t@8@06)))))
(assert (= ($Snap.first ($Snap.second $t@8@06)) $Snap.unit))
; [eval] exc == null ==> res != (None(): option[array])
; [eval] exc == null
(push) ; 3
(set-option :timeout 10)
(push) ; 4
(assert (not (not (= exc@6@06 $Ref.null))))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               16
;  :arith-assert-lower      1
;  :arith-assert-upper      1
;  :arith-eq-adapter        1
;  :datatype-accessor-ax    3
;  :datatype-constructor-ax 1
;  :datatype-occurs-check   2
;  :datatype-splits         1
;  :decisions               1
;  :final-checks            3
;  :max-generation          1
;  :max-memory              4.14
;  :memory                  3.92
;  :mk-bool-var             304
;  :num-allocs              122041
;  :num-checks              2
;  :quant-instantiations    1
;  :rlimit-count            120659)
; [then-branch: 0 | exc@6@06 == Null | live]
; [else-branch: 0 | exc@6@06 != Null | dead]
(push) ; 4
; [then-branch: 0 | exc@6@06 == Null]
; [eval] res != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 4
(pop) ; 3
; Joined path conditions
(assert (implies
  (= exc@6@06 $Ref.null)
  (not (= res@7@06 (as None<option<array>>  option<array>)))))
(assert (=
  ($Snap.second ($Snap.second $t@8@06))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second $t@8@06)))
    ($Snap.second ($Snap.second ($Snap.second $t@8@06))))))
(assert (= ($Snap.first ($Snap.second ($Snap.second $t@8@06))) $Snap.unit))
; [eval] exc == null ==> alen(opt_get1(res)) == dim0
; [eval] exc == null
(push) ; 3
(push) ; 4
(assert (not (not (= exc@6@06 $Ref.null))))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               24
;  :arith-assert-lower      1
;  :arith-assert-upper      1
;  :arith-eq-adapter        1
;  :datatype-accessor-ax    4
;  :datatype-constructor-ax 2
;  :datatype-occurs-check   4
;  :datatype-splits         2
;  :decisions               2
;  :final-checks            5
;  :max-generation          1
;  :max-memory              4.14
;  :memory                  3.92
;  :mk-bool-var             308
;  :num-allocs              122502
;  :num-checks              3
;  :quant-instantiations    1
;  :rlimit-count            121229)
; [then-branch: 1 | exc@6@06 == Null | live]
; [else-branch: 1 | exc@6@06 != Null | dead]
(push) ; 4
; [then-branch: 1 | exc@6@06 == Null]
; [eval] alen(opt_get1(res)) == dim0
; [eval] alen(opt_get1(res))
; [eval] opt_get1(res)
(push) ; 5
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(set-option :timeout 0)
(push) ; 6
(assert (not (not (= res@7@06 (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               24
;  :arith-assert-lower      1
;  :arith-assert-upper      1
;  :arith-eq-adapter        1
;  :datatype-accessor-ax    4
;  :datatype-constructor-ax 2
;  :datatype-occurs-check   4
;  :datatype-splits         2
;  :decisions               2
;  :final-checks            5
;  :max-generation          1
;  :max-memory              4.14
;  :memory                  3.92
;  :mk-bool-var             308
;  :num-allocs              122575
;  :num-checks              4
;  :quant-instantiations    1
;  :rlimit-count            121250)
(assert (not (= res@7@06 (as None<option<array>>  option<array>))))
(pop) ; 5
; Joined path conditions
(assert (not (= res@7@06 (as None<option<array>>  option<array>))))
(pop) ; 4
(pop) ; 3
; Joined path conditions
(assert (implies
  (= exc@6@06 $Ref.null)
  (= (alen<Int> (opt_get1 $Snap.unit res@7@06)) dim0@5@06)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second $t@8@06)))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@8@06))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@8@06)))))))
; [eval] exc == null
(set-option :timeout 10)
(push) ; 3
(assert (not (not (= exc@6@06 $Ref.null))))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               37
;  :arith-assert-lower      2
;  :arith-assert-upper      1
;  :arith-eq-adapter        1
;  :datatype-accessor-ax    5
;  :datatype-constructor-ax 4
;  :datatype-occurs-check   6
;  :datatype-splits         4
;  :decisions               4
;  :final-checks            7
;  :max-generation          2
;  :max-memory              4.14
;  :memory                  3.94
;  :mk-bool-var             317
;  :num-allocs              123210
;  :num-checks              5
;  :quant-instantiations    6
;  :rlimit-count            121910)
; [then-branch: 2 | exc@6@06 == Null | live]
; [else-branch: 2 | exc@6@06 != Null | dead]
(push) ; 3
; [then-branch: 2 | exc@6@06 == Null]
(declare-const i0@9@06 Int)
(push) ; 4
; [eval] 0 <= i0 && i0 < dim0
; [eval] 0 <= i0
(push) ; 5
; [then-branch: 3 | 0 <= i0@9@06 | live]
; [else-branch: 3 | !(0 <= i0@9@06) | live]
(push) ; 6
; [then-branch: 3 | 0 <= i0@9@06]
(assert (<= 0 i0@9@06))
; [eval] i0 < dim0
(pop) ; 6
(push) ; 6
; [else-branch: 3 | !(0 <= i0@9@06)]
(assert (not (<= 0 i0@9@06)))
(pop) ; 6
(pop) ; 5
; Joined path conditions
; Joined path conditions
(assert (and (< i0@9@06 dim0@5@06) (<= 0 i0@9@06)))
; [eval] aloc(opt_get1(res), i0)
; [eval] opt_get1(res)
(push) ; 5
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(set-option :timeout 0)
(push) ; 6
(assert (not (not (= res@7@06 (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               38
;  :arith-add-rows          1
;  :arith-assert-lower      5
;  :arith-assert-upper      2
;  :arith-eq-adapter        2
;  :arith-fixed-eqs         1
;  :arith-pivots            2
;  :datatype-accessor-ax    5
;  :datatype-constructor-ax 4
;  :datatype-occurs-check   6
;  :datatype-splits         4
;  :decisions               4
;  :final-checks            7
;  :max-generation          2
;  :max-memory              4.14
;  :memory                  3.95
;  :mk-bool-var             321
;  :num-allocs              123387
;  :num-checks              6
;  :quant-instantiations    6
;  :rlimit-count            122120)
(assert (not (= res@7@06 (as None<option<array>>  option<array>))))
(pop) ; 5
; Joined path conditions
(assert (not (= res@7@06 (as None<option<array>>  option<array>))))
(push) ; 5
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 6
(assert (not (< i0@9@06 (alen<Int> (opt_get1 $Snap.unit res@7@06)))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               38
;  :arith-add-rows          1
;  :arith-assert-lower      5
;  :arith-assert-upper      2
;  :arith-eq-adapter        2
;  :arith-fixed-eqs         1
;  :arith-pivots            2
;  :datatype-accessor-ax    5
;  :datatype-constructor-ax 4
;  :datatype-occurs-check   6
;  :datatype-splits         4
;  :decisions               4
;  :final-checks            7
;  :max-generation          2
;  :max-memory              4.14
;  :memory                  3.95
;  :mk-bool-var             321
;  :num-allocs              123405
;  :num-checks              7
;  :quant-instantiations    6
;  :rlimit-count            122151)
(assert (< i0@9@06 (alen<Int> (opt_get1 $Snap.unit res@7@06))))
(pop) ; 5
; Joined path conditions
(assert (< i0@9@06 (alen<Int> (opt_get1 $Snap.unit res@7@06))))
(declare-const sm@10@06 $FVF<Int>)
; Definitional axioms for snapshot map values
; [eval] aloc(opt_get1(res), i0)
; [eval] opt_get1(res)
(push) ; 5
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 5
; Joined path conditions
(push) ; 5
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(pop) ; 5
; Joined path conditions
(pop) ; 4
(declare-fun inv@11@06 ($Ref) Int)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(assert (forall ((i0@9@06 Int)) (!
  (and
    (not (= res@7@06 (as None<option<array>>  option<array>)))
    (< i0@9@06 (alen<Int> (opt_get1 $Snap.unit res@7@06))))
  :pattern (($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@8@06))))) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit res@7@06) i0@9@06)) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit res@7@06) i0@9@06)))
  :qid |int-aux|)))
; Check receiver injectivity
(push) ; 4
(assert (not (forall ((i01@9@06 Int) (i02@9@06 Int)) (!
  (implies
    (and
      (and (< i01@9@06 dim0@5@06) (<= 0 i01@9@06))
      (and (< i02@9@06 dim0@5@06) (<= 0 i02@9@06))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@7@06) i01@9@06)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@7@06) i02@9@06)))
    (= i01@9@06 i02@9@06))
  
  :qid |int-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               60
;  :arith-add-rows          21
;  :arith-assert-diseq      1
;  :arith-assert-lower      12
;  :arith-assert-upper      6
;  :arith-bound-prop        2
;  :arith-conflicts         1
;  :arith-eq-adapter        4
;  :arith-fixed-eqs         2
;  :arith-offset-eqs        1
;  :arith-pivots            15
;  :conflicts               2
;  :datatype-accessor-ax    6
;  :datatype-constructor-ax 4
;  :datatype-occurs-check   6
;  :datatype-splits         4
;  :decisions               5
;  :del-clause              17
;  :final-checks            7
;  :max-generation          2
;  :max-memory              4.14
;  :memory                  3.98
;  :mk-bool-var             346
;  :mk-clause               17
;  :num-allocs              124188
;  :num-checks              8
;  :propagations            15
;  :quant-instantiations    14
;  :rlimit-count            123588)
; Definitional axioms for inverse functions
(assert (forall ((i0@9@06 Int)) (!
  (implies
    (and (< i0@9@06 dim0@5@06) (<= 0 i0@9@06))
    (=
      (inv@11@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@7@06) i0@9@06))
      i0@9@06))
  :pattern (($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@8@06))))) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit res@7@06) i0@9@06)) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit res@7@06) i0@9@06)))
  )))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@11@06 r) dim0@5@06) (<= 0 (inv@11@06 r)))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@7@06) (inv@11@06 r))
      r))
  :pattern ((inv@11@06 r))
  :qid |int-fctOfInv|)))
; Permissions are non-negative
; Field permissions are at most one
; Permission implies non-null receiver
(assert (forall ((i0@9@06 Int)) (!
  (implies
    (and (< i0@9@06 dim0@5@06) (<= 0 i0@9@06))
    (not
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@7@06) i0@9@06)
        $Ref.null)))
  :pattern (($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@8@06))))) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit res@7@06) i0@9@06)) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit res@7@06) i0@9@06)))
  :qid |int-permImpliesNonNull|)))
(declare-const sm@12@06 $FVF<Int>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@11@06 r) dim0@5@06) (<= 0 (inv@11@06 r)))
    (=
      ($FVF.lookup_int (as sm@12@06  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@8@06))))) r)))
  :pattern (($FVF.lookup_int (as sm@12@06  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@8@06))))) r))
  :qid |qp.fvfValDef1|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@8@06))))) r) r)
  :pattern (($FVF.lookup_int (as sm@12@06  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef2|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@11@06 r) dim0@5@06) (<= 0 (inv@11@06 r)))
    ($FVF.loc_int ($FVF.lookup_int (as sm@12@06  $FVF<Int>) r) r))
  :pattern ((inv@11@06 r))
  )))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@8@06))))
  $Snap.unit))
; [eval] exc == null ==> (forall i0: Int :: { aloc(opt_get1(res), i0).int } 0 <= i0 && i0 < dim0 ==> aloc(opt_get1(res), i0).int == 0)
; [eval] exc == null
(push) ; 4
(set-option :timeout 10)
(push) ; 5
(assert (not (not (= exc@6@06 $Ref.null))))
(check-sat)
; unknown
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               64
;  :arith-add-rows          21
;  :arith-assert-diseq      1
;  :arith-assert-lower      12
;  :arith-assert-upper      6
;  :arith-bound-prop        2
;  :arith-conflicts         1
;  :arith-eq-adapter        4
;  :arith-fixed-eqs         2
;  :arith-offset-eqs        1
;  :arith-pivots            15
;  :conflicts               2
;  :datatype-accessor-ax    6
;  :datatype-constructor-ax 5
;  :datatype-occurs-check   9
;  :datatype-splits         5
;  :decisions               6
;  :del-clause              17
;  :final-checks            9
;  :max-generation          2
;  :max-memory              4.14
;  :memory                  3.99
;  :mk-bool-var             354
;  :mk-clause               17
;  :num-allocs              125482
;  :num-checks              9
;  :propagations            15
;  :quant-instantiations    14
;  :rlimit-count            125872)
; [then-branch: 4 | exc@6@06 == Null | live]
; [else-branch: 4 | exc@6@06 != Null | dead]
(push) ; 5
; [then-branch: 4 | exc@6@06 == Null]
; [eval] (forall i0: Int :: { aloc(opt_get1(res), i0).int } 0 <= i0 && i0 < dim0 ==> aloc(opt_get1(res), i0).int == 0)
(declare-const i0@13@06 Int)
(push) ; 6
; [eval] 0 <= i0 && i0 < dim0 ==> aloc(opt_get1(res), i0).int == 0
; [eval] 0 <= i0 && i0 < dim0
; [eval] 0 <= i0
(push) ; 7
; [then-branch: 5 | 0 <= i0@13@06 | live]
; [else-branch: 5 | !(0 <= i0@13@06) | live]
(push) ; 8
; [then-branch: 5 | 0 <= i0@13@06]
(assert (<= 0 i0@13@06))
; [eval] i0 < dim0
(pop) ; 8
(push) ; 8
; [else-branch: 5 | !(0 <= i0@13@06)]
(assert (not (<= 0 i0@13@06)))
(pop) ; 8
(pop) ; 7
; Joined path conditions
; Joined path conditions
(push) ; 7
; [then-branch: 6 | i0@13@06 < dim0@5@06 && 0 <= i0@13@06 | live]
; [else-branch: 6 | !(i0@13@06 < dim0@5@06 && 0 <= i0@13@06) | live]
(push) ; 8
; [then-branch: 6 | i0@13@06 < dim0@5@06 && 0 <= i0@13@06]
(assert (and (< i0@13@06 dim0@5@06) (<= 0 i0@13@06)))
; [eval] aloc(opt_get1(res), i0).int == 0
; [eval] aloc(opt_get1(res), i0)
; [eval] opt_get1(res)
(push) ; 9
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(set-option :timeout 0)
(push) ; 10
(assert (not (not (= res@7@06 (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               65
;  :arith-add-rows          22
;  :arith-assert-diseq      1
;  :arith-assert-lower      14
;  :arith-assert-upper      8
;  :arith-bound-prop        2
;  :arith-conflicts         1
;  :arith-eq-adapter        5
;  :arith-fixed-eqs         3
;  :arith-offset-eqs        1
;  :arith-pivots            17
;  :conflicts               2
;  :datatype-accessor-ax    6
;  :datatype-constructor-ax 5
;  :datatype-occurs-check   9
;  :datatype-splits         5
;  :decisions               6
;  :del-clause              17
;  :final-checks            9
;  :max-generation          2
;  :max-memory              4.14
;  :memory                  4.00
;  :mk-bool-var             358
;  :mk-clause               17
;  :num-allocs              125660
;  :num-checks              10
;  :propagations            15
;  :quant-instantiations    14
;  :rlimit-count            126088)
(assert (not (= res@7@06 (as None<option<array>>  option<array>))))
(pop) ; 9
; Joined path conditions
(assert (not (= res@7@06 (as None<option<array>>  option<array>))))
(push) ; 9
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 10
(assert (not (< i0@13@06 (alen<Int> (opt_get1 $Snap.unit res@7@06)))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               65
;  :arith-add-rows          22
;  :arith-assert-diseq      1
;  :arith-assert-lower      14
;  :arith-assert-upper      8
;  :arith-bound-prop        2
;  :arith-conflicts         1
;  :arith-eq-adapter        5
;  :arith-fixed-eqs         3
;  :arith-offset-eqs        1
;  :arith-pivots            17
;  :conflicts               2
;  :datatype-accessor-ax    6
;  :datatype-constructor-ax 5
;  :datatype-occurs-check   9
;  :datatype-splits         5
;  :decisions               6
;  :del-clause              17
;  :final-checks            9
;  :max-generation          2
;  :max-memory              4.14
;  :memory                  4.00
;  :mk-bool-var             358
;  :mk-clause               17
;  :num-allocs              125688
;  :num-checks              11
;  :propagations            15
;  :quant-instantiations    14
;  :rlimit-count            126119)
(assert (< i0@13@06 (alen<Int> (opt_get1 $Snap.unit res@7@06))))
(pop) ; 9
; Joined path conditions
(assert (< i0@13@06 (alen<Int> (opt_get1 $Snap.unit res@7@06))))
(assert ($FVF.loc_int ($FVF.lookup_int (as sm@12@06  $FVF<Int>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit res@7@06) i0@13@06)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit res@7@06) i0@13@06)))
(push) ; 9
(assert (not (and
  (<
    (inv@11@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@7@06) i0@13@06))
    dim0@5@06)
  (<=
    0
    (inv@11@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@7@06) i0@13@06))))))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               79
;  :arith-add-rows          25
;  :arith-assert-diseq      1
;  :arith-assert-lower      15
;  :arith-assert-upper      9
;  :arith-bound-prop        5
;  :arith-conflicts         1
;  :arith-eq-adapter        6
;  :arith-fixed-eqs         4
;  :arith-offset-eqs        4
;  :arith-pivots            18
;  :conflicts               3
;  :datatype-accessor-ax    6
;  :datatype-constructor-ax 5
;  :datatype-occurs-check   9
;  :datatype-splits         5
;  :decisions               6
;  :del-clause              17
;  :final-checks            9
;  :max-generation          2
;  :max-memory              4.14
;  :memory                  4.01
;  :mk-bool-var             376
;  :mk-clause               29
;  :num-allocs              126017
;  :num-checks              12
;  :propagations            21
;  :quant-instantiations    24
;  :rlimit-count            126732)
(pop) ; 8
(push) ; 8
; [else-branch: 6 | !(i0@13@06 < dim0@5@06 && 0 <= i0@13@06)]
(assert (not (and (< i0@13@06 dim0@5@06) (<= 0 i0@13@06))))
(pop) ; 8
(pop) ; 7
; Joined path conditions
(assert (implies
  (and (< i0@13@06 dim0@5@06) (<= 0 i0@13@06))
  (and
    (< i0@13@06 dim0@5@06)
    (<= 0 i0@13@06)
    (not (= res@7@06 (as None<option<array>>  option<array>)))
    (< i0@13@06 (alen<Int> (opt_get1 $Snap.unit res@7@06)))
    ($FVF.loc_int ($FVF.lookup_int (as sm@12@06  $FVF<Int>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@7@06) i0@13@06)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@7@06) i0@13@06)))))
; Joined path conditions
; Definitional axioms for snapshot map values
(pop) ; 6
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i0@13@06 Int)) (!
  (implies
    (and (< i0@13@06 dim0@5@06) (<= 0 i0@13@06))
    (and
      (< i0@13@06 dim0@5@06)
      (<= 0 i0@13@06)
      (not (= res@7@06 (as None<option<array>>  option<array>)))
      (< i0@13@06 (alen<Int> (opt_get1 $Snap.unit res@7@06)))
      ($FVF.loc_int ($FVF.lookup_int (as sm@12@06  $FVF<Int>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit res@7@06) i0@13@06)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit res@7@06) i0@13@06))))
  :pattern (($FVF.loc_int ($FVF.lookup_int (as sm@12@06  $FVF<Int>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit res@7@06) i0@13@06)) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit res@7@06) i0@13@06)))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (implies
  (= exc@6@06 $Ref.null)
  (forall ((i0@13@06 Int)) (!
    (implies
      (and (< i0@13@06 dim0@5@06) (<= 0 i0@13@06))
      (and
        (< i0@13@06 dim0@5@06)
        (<= 0 i0@13@06)
        (not (= res@7@06 (as None<option<array>>  option<array>)))
        (< i0@13@06 (alen<Int> (opt_get1 $Snap.unit res@7@06)))
        ($FVF.loc_int ($FVF.lookup_int (as sm@12@06  $FVF<Int>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@7@06) i0@13@06)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@7@06) i0@13@06))))
    :pattern (($FVF.loc_int ($FVF.lookup_int (as sm@12@06  $FVF<Int>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@7@06) i0@13@06)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@7@06) i0@13@06)))
    :qid |prog.l<no position>-aux|))))
(assert (implies
  (= exc@6@06 $Ref.null)
  (forall ((i0@13@06 Int)) (!
    (implies
      (and (< i0@13@06 dim0@5@06) (<= 0 i0@13@06))
      (=
        ($FVF.lookup_int (as sm@12@06  $FVF<Int>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@7@06) i0@13@06))
        0))
    :pattern (($FVF.loc_int ($FVF.lookup_int (as sm@12@06  $FVF<Int>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@7@06) i0@13@06)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@7@06) i0@13@06)))
    :qid |prog.l<no position>|))))
(pop) ; 3
(pop) ; 2
(push) ; 2
; [exec]
; inhale false
(pop) ; 2
(pop) ; 1
; ---------- max_flow ----------
(declare-const this@14@06 $Ref)
(declare-const tid@15@06 Int)
(declare-const G@16@06 option<array>)
(declare-const s@17@06 Int)
(declare-const t@18@06 Int)
(declare-const V@19@06 Int)
(declare-const exc@20@06 $Ref)
(declare-const res@21@06 Int)
(declare-const this@22@06 $Ref)
(declare-const tid@23@06 Int)
(declare-const G@24@06 option<array>)
(declare-const s@25@06 Int)
(declare-const t@26@06 Int)
(declare-const V@27@06 Int)
(declare-const exc@28@06 $Ref)
(declare-const res@29@06 Int)
(push) ; 1
(declare-const $t@30@06 $Snap)
(assert (= $t@30@06 ($Snap.combine ($Snap.first $t@30@06) ($Snap.second $t@30@06))))
(assert (= ($Snap.first $t@30@06) $Snap.unit))
; [eval] this != null
(assert (not (= this@22@06 $Ref.null)))
(assert (=
  ($Snap.second $t@30@06)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@30@06))
    ($Snap.second ($Snap.second $t@30@06)))))
(assert (= ($Snap.first ($Snap.second $t@30@06)) $Snap.unit))
; [eval] G != (None(): option[array])
; [eval] (None(): option[array])
(assert (not (= G@24@06 (as None<option<array>>  option<array>))))
(assert (=
  ($Snap.second ($Snap.second $t@30@06))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second $t@30@06)))
    ($Snap.second ($Snap.second ($Snap.second $t@30@06))))))
(assert (= ($Snap.first ($Snap.second ($Snap.second $t@30@06))) $Snap.unit))
; [eval] alen(opt_get1(G)) == V
; [eval] alen(opt_get1(G))
; [eval] opt_get1(G)
(push) ; 2
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 2
; Joined path conditions
(assert (= (alen<Int> (opt_get1 $Snap.unit G@24@06)) V@27@06))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second $t@30@06)))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@30@06))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@30@06)))))))
(declare-const i1@31@06 Int)
(push) ; 2
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 3
; [then-branch: 7 | 0 <= i1@31@06 | live]
; [else-branch: 7 | !(0 <= i1@31@06) | live]
(push) ; 4
; [then-branch: 7 | 0 <= i1@31@06]
(assert (<= 0 i1@31@06))
; [eval] i1 < V
(pop) ; 4
(push) ; 4
; [else-branch: 7 | !(0 <= i1@31@06)]
(assert (not (<= 0 i1@31@06)))
(pop) ; 4
(pop) ; 3
; Joined path conditions
; Joined path conditions
(assert (and (< i1@31@06 V@27@06) (<= 0 i1@31@06)))
; [eval] aloc(opt_get1(G), i1)
; [eval] opt_get1(G)
(push) ; 3
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 3
; Joined path conditions
(push) ; 3
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 4
(assert (not (< i1@31@06 (alen<Int> (opt_get1 $Snap.unit G@24@06)))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               108
;  :arith-add-rows          27
;  :arith-assert-diseq      1
;  :arith-assert-lower      18
;  :arith-assert-upper      11
;  :arith-bound-prop        5
;  :arith-conflicts         1
;  :arith-eq-adapter        7
;  :arith-fixed-eqs         5
;  :arith-offset-eqs        4
;  :arith-pivots            23
;  :conflicts               3
;  :datatype-accessor-ax    11
;  :datatype-constructor-ax 5
;  :datatype-occurs-check   9
;  :datatype-splits         5
;  :decisions               6
;  :del-clause              29
;  :final-checks            9
;  :max-generation          2
;  :max-memory              4.14
;  :memory                  4.02
;  :mk-bool-var             396
;  :mk-clause               29
;  :num-allocs              126615
;  :num-checks              13
;  :propagations            21
;  :quant-instantiations    29
;  :rlimit-count            127896)
(assert (< i1@31@06 (alen<Int> (opt_get1 $Snap.unit G@24@06))))
(pop) ; 3
; Joined path conditions
(assert (< i1@31@06 (alen<Int> (opt_get1 $Snap.unit G@24@06))))
(declare-const $k@32@06 $Perm)
(assert ($Perm.isReadVar $k@32@06 $Perm.Write))
(pop) ; 2
(declare-fun inv@33@06 ($Ref) Int)
; Nested auxiliary terms: globals
(assert ($Perm.isReadVar $k@32@06 $Perm.Write))
; Nested auxiliary terms: non-globals
(assert (forall ((i1@31@06 Int)) (!
  (< i1@31@06 (alen<Int> (opt_get1 $Snap.unit G@24@06)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@31@06))
  :qid |option$array$-aux|)))
(push) ; 2
(assert (not (forall ((i1@31@06 Int)) (!
  (implies
    (and (< i1@31@06 V@27@06) (<= 0 i1@31@06))
    (or (= $k@32@06 $Perm.No) (< $Perm.No $k@32@06)))
  
  ))))
(check-sat)
; unsat
(pop) ; 2
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               110
;  :arith-add-rows          27
;  :arith-assert-diseq      2
;  :arith-assert-lower      20
;  :arith-assert-upper      12
;  :arith-bound-prop        5
;  :arith-conflicts         1
;  :arith-eq-adapter        8
;  :arith-fixed-eqs         5
;  :arith-offset-eqs        4
;  :arith-pivots            25
;  :conflicts               4
;  :datatype-accessor-ax    12
;  :datatype-constructor-ax 5
;  :datatype-occurs-check   9
;  :datatype-splits         5
;  :decisions               6
;  :del-clause              29
;  :final-checks            9
;  :max-generation          2
;  :max-memory              4.14
;  :memory                  4.02
;  :mk-bool-var             403
;  :mk-clause               31
;  :num-allocs              127102
;  :num-checks              14
;  :propagations            22
;  :quant-instantiations    29
;  :rlimit-count            128476)
; Check receiver injectivity
(push) ; 2
(assert (not (forall ((i11@31@06 Int) (i12@31@06 Int)) (!
  (implies
    (and
      (and (and (< i11@31@06 V@27@06) (<= 0 i11@31@06)) (< $Perm.No $k@32@06))
      (and (and (< i12@31@06 V@27@06) (<= 0 i12@31@06)) (< $Perm.No $k@32@06))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i11@31@06)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i12@31@06)))
    (= i11@31@06 i12@31@06))
  
  :qid |option$array$-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 2
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               125
;  :arith-add-rows          35
;  :arith-assert-diseq      4
;  :arith-assert-lower      24
;  :arith-assert-upper      14
;  :arith-bound-prop        7
;  :arith-conflicts         1
;  :arith-eq-adapter        10
;  :arith-fixed-eqs         6
;  :arith-offset-eqs        6
;  :arith-pivots            32
;  :conflicts               5
;  :datatype-accessor-ax    12
;  :datatype-constructor-ax 5
;  :datatype-occurs-check   9
;  :datatype-splits         5
;  :decisions               6
;  :del-clause              44
;  :final-checks            9
;  :max-generation          2
;  :max-memory              4.14
;  :memory                  4.01
;  :mk-bool-var             429
;  :mk-clause               46
;  :num-allocs              127472
;  :num-checks              15
;  :propagations            28
;  :quant-instantiations    39
;  :rlimit-count            129370)
; Definitional axioms for inverse functions
(assert (forall ((i1@31@06 Int)) (!
  (implies
    (and (and (< i1@31@06 V@27@06) (<= 0 i1@31@06)) (< $Perm.No $k@32@06))
    (=
      (inv@33@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@31@06))
      i1@31@06))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@31@06))
  )))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and (< (inv@33@06 r) V@27@06) (<= 0 (inv@33@06 r)))
      (< $Perm.No $k@32@06))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) (inv@33@06 r))
      r))
  :pattern ((inv@33@06 r))
  :qid |option$array$-fctOfInv|)))
; Permissions are non-negative
(assert (forall ((i1@31@06 Int)) (!
  (<= $Perm.No $k@32@06)
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@31@06))
  :qid |option$array$-permAtLeastZero|)))
; Field permissions are at most one
(assert (forall ((i1@31@06 Int)) (!
  (<= $k@32@06 $Perm.Write)
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@31@06))
  :qid |option$array$-permAtMostOne|)))
; Permission implies non-null receiver
(assert (forall ((i1@31@06 Int)) (!
  (implies
    (and (and (< i1@31@06 V@27@06) (<= 0 i1@31@06)) (< $Perm.No $k@32@06))
    (not
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@31@06)
        $Ref.null)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@31@06))
  :qid |option$array$-permImpliesNonNull|)))
(declare-const sm@34@06 $FVF<option<array>>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@33@06 r) V@27@06) (<= 0 (inv@33@06 r)))
      (< $Perm.No $k@32@06)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@34@06  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@30@06))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@34@06  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@30@06))))) r))
  :qid |qp.fvfValDef3|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@30@06))))) r) r)
  :pattern (($FVF.lookup_option$array$ (as sm@34@06  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef4|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@33@06 r) V@27@06) (<= 0 (inv@33@06 r)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@34@06  $FVF<option<array>>) r) r))
  :pattern ((inv@33@06 r))
  )))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@30@06))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@30@06)))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@30@06))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@30@06)))))
  $Snap.unit))
; [eval] (forall i1: Int :: { aloc(opt_get1(G), i1) } 0 <= i1 && i1 < V ==> aloc(opt_get1(G), i1).option$array$ != (None(): option[array]))
(declare-const i1@35@06 Int)
(push) ; 2
; [eval] 0 <= i1 && i1 < V ==> aloc(opt_get1(G), i1).option$array$ != (None(): option[array])
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 3
; [then-branch: 8 | 0 <= i1@35@06 | live]
; [else-branch: 8 | !(0 <= i1@35@06) | live]
(push) ; 4
; [then-branch: 8 | 0 <= i1@35@06]
(assert (<= 0 i1@35@06))
; [eval] i1 < V
(pop) ; 4
(push) ; 4
; [else-branch: 8 | !(0 <= i1@35@06)]
(assert (not (<= 0 i1@35@06)))
(pop) ; 4
(pop) ; 3
; Joined path conditions
; Joined path conditions
(push) ; 3
; [then-branch: 9 | i1@35@06 < V@27@06 && 0 <= i1@35@06 | live]
; [else-branch: 9 | !(i1@35@06 < V@27@06 && 0 <= i1@35@06) | live]
(push) ; 4
; [then-branch: 9 | i1@35@06 < V@27@06 && 0 <= i1@35@06]
(assert (and (< i1@35@06 V@27@06) (<= 0 i1@35@06)))
; [eval] aloc(opt_get1(G), i1).option$array$ != (None(): option[array])
; [eval] aloc(opt_get1(G), i1)
; [eval] opt_get1(G)
(push) ; 5
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 5
; Joined path conditions
(push) ; 5
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 6
(assert (not (< i1@35@06 (alen<Int> (opt_get1 $Snap.unit G@24@06)))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               133
;  :arith-add-rows          35
;  :arith-assert-diseq      4
;  :arith-assert-lower      26
;  :arith-assert-upper      17
;  :arith-bound-prop        7
;  :arith-conflicts         1
;  :arith-eq-adapter        11
;  :arith-fixed-eqs         7
;  :arith-offset-eqs        6
;  :arith-pivots            33
;  :conflicts               5
;  :datatype-accessor-ax    13
;  :datatype-constructor-ax 5
;  :datatype-occurs-check   9
;  :datatype-splits         5
;  :decisions               6
;  :del-clause              44
;  :final-checks            9
;  :max-generation          2
;  :max-memory              4.14
;  :memory                  4.02
;  :mk-bool-var             443
;  :mk-clause               46
;  :num-allocs              128705
;  :num-checks              16
;  :propagations            28
;  :quant-instantiations    39
;  :rlimit-count            131716)
(assert (< i1@35@06 (alen<Int> (opt_get1 $Snap.unit G@24@06))))
(pop) ; 5
; Joined path conditions
(assert (< i1@35@06 (alen<Int> (opt_get1 $Snap.unit G@24@06))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@34@06  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@35@06)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@35@06)))
(push) ; 5
(assert (not (ite
  (and
    (<
      (inv@33@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@35@06))
      V@27@06)
    (<=
      0
      (inv@33@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@35@06))))
  (< $Perm.No $k@32@06)
  false)))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               138
;  :arith-add-rows          40
;  :arith-assert-diseq      4
;  :arith-assert-lower      27
;  :arith-assert-upper      19
;  :arith-bound-prop        8
;  :arith-conflicts         2
;  :arith-eq-adapter        12
;  :arith-fixed-eqs         8
;  :arith-offset-eqs        6
;  :arith-pivots            35
;  :conflicts               6
;  :datatype-accessor-ax    13
;  :datatype-constructor-ax 5
;  :datatype-occurs-check   9
;  :datatype-splits         5
;  :decisions               6
;  :del-clause              44
;  :final-checks            9
;  :max-generation          2
;  :max-memory              4.14
;  :memory                  4.03
;  :mk-bool-var             461
;  :mk-clause               53
;  :num-allocs              129002
;  :num-checks              17
;  :propagations            28
;  :quant-instantiations    49
;  :rlimit-count            132390)
; [eval] (None(): option[array])
(pop) ; 4
(push) ; 4
; [else-branch: 9 | !(i1@35@06 < V@27@06 && 0 <= i1@35@06)]
(assert (not (and (< i1@35@06 V@27@06) (<= 0 i1@35@06))))
(pop) ; 4
(pop) ; 3
; Joined path conditions
(assert (implies
  (and (< i1@35@06 V@27@06) (<= 0 i1@35@06))
  (and
    (< i1@35@06 V@27@06)
    (<= 0 i1@35@06)
    (< i1@35@06 (alen<Int> (opt_get1 $Snap.unit G@24@06)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@34@06  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@35@06)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@35@06)))))
; Joined path conditions
(pop) ; 2
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@35@06 Int)) (!
  (implies
    (and (< i1@35@06 V@27@06) (<= 0 i1@35@06))
    (and
      (< i1@35@06 V@27@06)
      (<= 0 i1@35@06)
      (< i1@35@06 (alen<Int> (opt_get1 $Snap.unit G@24@06)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@34@06  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@35@06)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@35@06))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@35@06))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(assert (forall ((i1@35@06 Int)) (!
  (implies
    (and (< i1@35@06 V@27@06) (<= 0 i1@35@06))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@34@06  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@35@06))
        (as None<option<array>>  option<array>))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@35@06))
  :qid |prog.l<no position>|)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@30@06)))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@30@06))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@30@06)))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@30@06))))))
  $Snap.unit))
; [eval] (forall i1: Int :: { alen(opt_get1(aloc(opt_get1(G), i1).option$array$)) } 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(G), i1).option$array$)) == V)
(declare-const i1@36@06 Int)
(push) ; 2
; [eval] 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(G), i1).option$array$)) == V
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 3
; [then-branch: 10 | 0 <= i1@36@06 | live]
; [else-branch: 10 | !(0 <= i1@36@06) | live]
(push) ; 4
; [then-branch: 10 | 0 <= i1@36@06]
(assert (<= 0 i1@36@06))
; [eval] i1 < V
(pop) ; 4
(push) ; 4
; [else-branch: 10 | !(0 <= i1@36@06)]
(assert (not (<= 0 i1@36@06)))
(pop) ; 4
(pop) ; 3
; Joined path conditions
; Joined path conditions
(push) ; 3
; [then-branch: 11 | i1@36@06 < V@27@06 && 0 <= i1@36@06 | live]
; [else-branch: 11 | !(i1@36@06 < V@27@06 && 0 <= i1@36@06) | live]
(push) ; 4
; [then-branch: 11 | i1@36@06 < V@27@06 && 0 <= i1@36@06]
(assert (and (< i1@36@06 V@27@06) (<= 0 i1@36@06)))
; [eval] alen(opt_get1(aloc(opt_get1(G), i1).option$array$)) == V
; [eval] alen(opt_get1(aloc(opt_get1(G), i1).option$array$))
; [eval] opt_get1(aloc(opt_get1(G), i1).option$array$)
; [eval] aloc(opt_get1(G), i1)
; [eval] opt_get1(G)
(push) ; 5
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 5
; Joined path conditions
(push) ; 5
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 6
(assert (not (< i1@36@06 (alen<Int> (opt_get1 $Snap.unit G@24@06)))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               146
;  :arith-add-rows          47
;  :arith-assert-diseq      4
;  :arith-assert-lower      30
;  :arith-assert-upper      20
;  :arith-bound-prop        8
;  :arith-conflicts         2
;  :arith-eq-adapter        13
;  :arith-fixed-eqs         9
;  :arith-offset-eqs        6
;  :arith-pivots            39
;  :conflicts               6
;  :datatype-accessor-ax    14
;  :datatype-constructor-ax 5
;  :datatype-occurs-check   9
;  :datatype-splits         5
;  :decisions               6
;  :del-clause              51
;  :final-checks            9
;  :max-generation          2
;  :max-memory              4.14
;  :memory                  4.03
;  :mk-bool-var             470
;  :mk-clause               53
;  :num-allocs              129575
;  :num-checks              18
;  :propagations            28
;  :quant-instantiations    49
;  :rlimit-count            133616)
(assert (< i1@36@06 (alen<Int> (opt_get1 $Snap.unit G@24@06))))
(pop) ; 5
; Joined path conditions
(assert (< i1@36@06 (alen<Int> (opt_get1 $Snap.unit G@24@06))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@34@06  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@36@06)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@36@06)))
(push) ; 5
(assert (not (ite
  (and
    (<
      (inv@33@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@36@06))
      V@27@06)
    (<=
      0
      (inv@33@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@36@06))))
  (< $Perm.No $k@32@06)
  false)))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               150
;  :arith-add-rows          52
;  :arith-assert-diseq      4
;  :arith-assert-lower      31
;  :arith-assert-upper      22
;  :arith-bound-prop        9
;  :arith-conflicts         3
;  :arith-eq-adapter        14
;  :arith-fixed-eqs         10
;  :arith-offset-eqs        6
;  :arith-pivots            41
;  :conflicts               7
;  :datatype-accessor-ax    14
;  :datatype-constructor-ax 5
;  :datatype-occurs-check   9
;  :datatype-splits         5
;  :decisions               6
;  :del-clause              51
;  :final-checks            9
;  :max-generation          2
;  :max-memory              4.14
;  :memory                  4.04
;  :mk-bool-var             489
;  :mk-clause               60
;  :num-allocs              129856
;  :num-checks              19
;  :propagations            28
;  :quant-instantiations    61
;  :rlimit-count            134325)
(push) ; 5
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 6
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@34@06  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@36@06))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               150
;  :arith-add-rows          52
;  :arith-assert-diseq      4
;  :arith-assert-lower      31
;  :arith-assert-upper      22
;  :arith-bound-prop        9
;  :arith-conflicts         3
;  :arith-eq-adapter        14
;  :arith-fixed-eqs         10
;  :arith-offset-eqs        6
;  :arith-pivots            41
;  :conflicts               8
;  :datatype-accessor-ax    14
;  :datatype-constructor-ax 5
;  :datatype-occurs-check   9
;  :datatype-splits         5
;  :decisions               6
;  :del-clause              51
;  :final-checks            9
;  :max-generation          2
;  :max-memory              4.14
;  :memory                  4.04
;  :mk-bool-var             489
;  :mk-clause               60
;  :num-allocs              129944
;  :num-checks              20
;  :propagations            28
;  :quant-instantiations    61
;  :rlimit-count            134420)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@34@06  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@36@06))
    (as None<option<array>>  option<array>))))
(pop) ; 5
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@34@06  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@36@06))
    (as None<option<array>>  option<array>))))
(pop) ; 4
(push) ; 4
; [else-branch: 11 | !(i1@36@06 < V@27@06 && 0 <= i1@36@06)]
(assert (not (and (< i1@36@06 V@27@06) (<= 0 i1@36@06))))
(pop) ; 4
(pop) ; 3
; Joined path conditions
(assert (implies
  (and (< i1@36@06 V@27@06) (<= 0 i1@36@06))
  (and
    (< i1@36@06 V@27@06)
    (<= 0 i1@36@06)
    (< i1@36@06 (alen<Int> (opt_get1 $Snap.unit G@24@06)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@34@06  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@36@06)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@36@06))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@34@06  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@36@06))
        (as None<option<array>>  option<array>))))))
; Joined path conditions
(pop) ; 2
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@36@06 Int)) (!
  (implies
    (and (< i1@36@06 V@27@06) (<= 0 i1@36@06))
    (and
      (< i1@36@06 V@27@06)
      (<= 0 i1@36@06)
      (< i1@36@06 (alen<Int> (opt_get1 $Snap.unit G@24@06)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@34@06  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@36@06)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@36@06))
      (not
        (=
          ($FVF.lookup_option$array$ (as sm@34@06  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@36@06))
          (as None<option<array>>  option<array>)))))
  :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@34@06  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@36@06)))))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(assert (forall ((i1@36@06 Int)) (!
  (implies
    (and (< i1@36@06 V@27@06) (<= 0 i1@36@06))
    (=
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@34@06  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@36@06))))
      V@27@06))
  :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@34@06  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@36@06)))))
  :qid |prog.l<no position>|)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@30@06))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@30@06)))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@30@06))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@30@06)))))))
  $Snap.unit))
; [eval] (forall i1: Int :: { aloc(opt_get1(G), i1) } (forall i2: Int :: { aloc(opt_get1(G), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(G), i1).option$array$ == aloc(opt_get1(G), i2).option$array$ ==> i1 == i2))
(declare-const i1@37@06 Int)
(push) ; 2
; [eval] (forall i2: Int :: { aloc(opt_get1(G), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(G), i1).option$array$ == aloc(opt_get1(G), i2).option$array$ ==> i1 == i2)
(declare-const i2@38@06 Int)
(push) ; 3
; [eval] 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(G), i1).option$array$ == aloc(opt_get1(G), i2).option$array$ ==> i1 == i2
; [eval] 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(G), i1).option$array$ == aloc(opt_get1(G), i2).option$array$
; [eval] 0 <= i1
(push) ; 4
; [then-branch: 12 | 0 <= i1@37@06 | live]
; [else-branch: 12 | !(0 <= i1@37@06) | live]
(push) ; 5
; [then-branch: 12 | 0 <= i1@37@06]
(assert (<= 0 i1@37@06))
; [eval] i1 < V
(push) ; 6
; [then-branch: 13 | i1@37@06 < V@27@06 | live]
; [else-branch: 13 | !(i1@37@06 < V@27@06) | live]
(push) ; 7
; [then-branch: 13 | i1@37@06 < V@27@06]
(assert (< i1@37@06 V@27@06))
; [eval] 0 <= i2
(push) ; 8
; [then-branch: 14 | 0 <= i2@38@06 | live]
; [else-branch: 14 | !(0 <= i2@38@06) | live]
(push) ; 9
; [then-branch: 14 | 0 <= i2@38@06]
(assert (<= 0 i2@38@06))
; [eval] i2 < V
(push) ; 10
; [then-branch: 15 | i2@38@06 < V@27@06 | live]
; [else-branch: 15 | !(i2@38@06 < V@27@06) | live]
(push) ; 11
; [then-branch: 15 | i2@38@06 < V@27@06]
(assert (< i2@38@06 V@27@06))
; [eval] aloc(opt_get1(G), i1).option$array$ == aloc(opt_get1(G), i2).option$array$
; [eval] aloc(opt_get1(G), i1)
; [eval] opt_get1(G)
(push) ; 12
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 12
; Joined path conditions
(push) ; 12
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 13
(assert (not (< i1@37@06 (alen<Int> (opt_get1 $Snap.unit G@24@06)))))
(check-sat)
; unsat
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               158
;  :arith-add-rows          56
;  :arith-assert-diseq      4
;  :arith-assert-lower      35
;  :arith-assert-upper      24
;  :arith-bound-prop        9
;  :arith-conflicts         3
;  :arith-eq-adapter        15
;  :arith-fixed-eqs         11
;  :arith-offset-eqs        6
;  :arith-pivots            47
;  :conflicts               8
;  :datatype-accessor-ax    15
;  :datatype-constructor-ax 5
;  :datatype-occurs-check   9
;  :datatype-splits         5
;  :decisions               6
;  :del-clause              58
;  :final-checks            9
;  :max-generation          2
;  :max-memory              4.14
;  :memory                  4.04
;  :mk-bool-var             500
;  :mk-clause               60
;  :num-allocs              130769
;  :num-checks              21
;  :propagations            28
;  :quant-instantiations    61
;  :rlimit-count            135842)
(assert (< i1@37@06 (alen<Int> (opt_get1 $Snap.unit G@24@06))))
(pop) ; 12
; Joined path conditions
(assert (< i1@37@06 (alen<Int> (opt_get1 $Snap.unit G@24@06))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@34@06  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@37@06)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@37@06)))
(push) ; 12
(assert (not (ite
  (and
    (<
      (inv@33@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@37@06))
      V@27@06)
    (<=
      0
      (inv@33@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@37@06))))
  (< $Perm.No $k@32@06)
  false)))
(check-sat)
; unsat
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               170
;  :arith-add-rows          59
;  :arith-assert-diseq      4
;  :arith-assert-lower      36
;  :arith-assert-upper      25
;  :arith-bound-prop        12
;  :arith-conflicts         3
;  :arith-eq-adapter        16
;  :arith-fixed-eqs         12
;  :arith-offset-eqs        9
;  :arith-pivots            48
;  :conflicts               9
;  :datatype-accessor-ax    15
;  :datatype-constructor-ax 5
;  :datatype-occurs-check   9
;  :datatype-splits         5
;  :decisions               6
;  :del-clause              58
;  :final-checks            9
;  :max-generation          2
;  :max-memory              4.14
;  :memory                  4.08
;  :mk-bool-var             519
;  :mk-clause               68
;  :num-allocs              131052
;  :num-checks              22
;  :propagations            32
;  :quant-instantiations    73
;  :rlimit-count            136511)
; [eval] aloc(opt_get1(G), i2)
; [eval] opt_get1(G)
(push) ; 12
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 12
; Joined path conditions
(push) ; 12
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 13
(assert (not (< i2@38@06 (alen<Int> (opt_get1 $Snap.unit G@24@06)))))
(check-sat)
; unsat
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               170
;  :arith-add-rows          59
;  :arith-assert-diseq      4
;  :arith-assert-lower      36
;  :arith-assert-upper      25
;  :arith-bound-prop        12
;  :arith-conflicts         3
;  :arith-eq-adapter        16
;  :arith-fixed-eqs         12
;  :arith-offset-eqs        9
;  :arith-pivots            48
;  :conflicts               9
;  :datatype-accessor-ax    15
;  :datatype-constructor-ax 5
;  :datatype-occurs-check   9
;  :datatype-splits         5
;  :decisions               6
;  :del-clause              58
;  :final-checks            9
;  :max-generation          2
;  :max-memory              4.14
;  :memory                  4.08
;  :mk-bool-var             519
;  :mk-clause               68
;  :num-allocs              131083
;  :num-checks              23
;  :propagations            32
;  :quant-instantiations    73
;  :rlimit-count            136541)
(assert (< i2@38@06 (alen<Int> (opt_get1 $Snap.unit G@24@06))))
(pop) ; 12
; Joined path conditions
(assert (< i2@38@06 (alen<Int> (opt_get1 $Snap.unit G@24@06))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@34@06  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@24@06) i2@38@06)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@24@06) i2@38@06)))
(push) ; 12
(assert (not (ite
  (and
    (<
      (inv@33@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i2@38@06))
      V@27@06)
    (<=
      0
      (inv@33@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i2@38@06))))
  (< $Perm.No $k@32@06)
  false)))
(check-sat)
; unsat
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               178
;  :arith-add-rows          67
;  :arith-assert-diseq      4
;  :arith-assert-lower      37
;  :arith-assert-upper      27
;  :arith-bound-prop        14
;  :arith-conflicts         4
;  :arith-eq-adapter        17
;  :arith-fixed-eqs         13
;  :arith-offset-eqs        10
;  :arith-pivots            50
;  :conflicts               10
;  :datatype-accessor-ax    15
;  :datatype-constructor-ax 5
;  :datatype-occurs-check   9
;  :datatype-splits         5
;  :decisions               6
;  :del-clause              58
;  :final-checks            9
;  :max-generation          2
;  :max-memory              4.14
;  :memory                  4.11
;  :mk-bool-var             538
;  :mk-clause               75
;  :num-allocs              131412
;  :num-checks              24
;  :propagations            35
;  :quant-instantiations    84
;  :rlimit-count            137265)
(pop) ; 11
(push) ; 11
; [else-branch: 15 | !(i2@38@06 < V@27@06)]
(assert (not (< i2@38@06 V@27@06)))
(pop) ; 11
(pop) ; 10
; Joined path conditions
(assert (implies
  (< i2@38@06 V@27@06)
  (and
    (< i2@38@06 V@27@06)
    (< i1@37@06 (alen<Int> (opt_get1 $Snap.unit G@24@06)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@34@06  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@37@06)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@37@06))
    (< i2@38@06 (alen<Int> (opt_get1 $Snap.unit G@24@06)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@34@06  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@24@06) i2@38@06)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@24@06) i2@38@06)))))
; Joined path conditions
(pop) ; 9
(push) ; 9
; [else-branch: 14 | !(0 <= i2@38@06)]
(assert (not (<= 0 i2@38@06)))
(pop) ; 9
(pop) ; 8
; Joined path conditions
(assert (implies
  (<= 0 i2@38@06)
  (and
    (<= 0 i2@38@06)
    (implies
      (< i2@38@06 V@27@06)
      (and
        (< i2@38@06 V@27@06)
        (< i1@37@06 (alen<Int> (opt_get1 $Snap.unit G@24@06)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@34@06  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@37@06)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@37@06))
        (< i2@38@06 (alen<Int> (opt_get1 $Snap.unit G@24@06)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@34@06  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@24@06) i2@38@06)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@24@06) i2@38@06)))))))
; Joined path conditions
(pop) ; 7
(push) ; 7
; [else-branch: 13 | !(i1@37@06 < V@27@06)]
(assert (not (< i1@37@06 V@27@06)))
(pop) ; 7
(pop) ; 6
; Joined path conditions
(assert (implies
  (< i1@37@06 V@27@06)
  (and
    (< i1@37@06 V@27@06)
    (implies
      (<= 0 i2@38@06)
      (and
        (<= 0 i2@38@06)
        (implies
          (< i2@38@06 V@27@06)
          (and
            (< i2@38@06 V@27@06)
            (< i1@37@06 (alen<Int> (opt_get1 $Snap.unit G@24@06)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@34@06  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@37@06)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@37@06))
            (< i2@38@06 (alen<Int> (opt_get1 $Snap.unit G@24@06)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@34@06  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@24@06) i2@38@06)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@24@06) i2@38@06)))))))))
; Joined path conditions
(pop) ; 5
(push) ; 5
; [else-branch: 12 | !(0 <= i1@37@06)]
(assert (not (<= 0 i1@37@06)))
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (implies
  (<= 0 i1@37@06)
  (and
    (<= 0 i1@37@06)
    (implies
      (< i1@37@06 V@27@06)
      (and
        (< i1@37@06 V@27@06)
        (implies
          (<= 0 i2@38@06)
          (and
            (<= 0 i2@38@06)
            (implies
              (< i2@38@06 V@27@06)
              (and
                (< i2@38@06 V@27@06)
                (< i1@37@06 (alen<Int> (opt_get1 $Snap.unit G@24@06)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@34@06  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@37@06)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@37@06))
                (< i2@38@06 (alen<Int> (opt_get1 $Snap.unit G@24@06)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@34@06  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@24@06) i2@38@06)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@24@06) i2@38@06)))))))))))
; Joined path conditions
(push) ; 4
; [then-branch: 16 | Lookup(option$array$,sm@34@06,aloc((_, _), opt_get1(_, G@24@06), i1@37@06)) == Lookup(option$array$,sm@34@06,aloc((_, _), opt_get1(_, G@24@06), i2@38@06)) && i2@38@06 < V@27@06 && 0 <= i2@38@06 && i1@37@06 < V@27@06 && 0 <= i1@37@06 | live]
; [else-branch: 16 | !(Lookup(option$array$,sm@34@06,aloc((_, _), opt_get1(_, G@24@06), i1@37@06)) == Lookup(option$array$,sm@34@06,aloc((_, _), opt_get1(_, G@24@06), i2@38@06)) && i2@38@06 < V@27@06 && 0 <= i2@38@06 && i1@37@06 < V@27@06 && 0 <= i1@37@06) | live]
(push) ; 5
; [then-branch: 16 | Lookup(option$array$,sm@34@06,aloc((_, _), opt_get1(_, G@24@06), i1@37@06)) == Lookup(option$array$,sm@34@06,aloc((_, _), opt_get1(_, G@24@06), i2@38@06)) && i2@38@06 < V@27@06 && 0 <= i2@38@06 && i1@37@06 < V@27@06 && 0 <= i1@37@06]
(assert (and
  (and
    (and
      (and
        (=
          ($FVF.lookup_option$array$ (as sm@34@06  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@37@06))
          ($FVF.lookup_option$array$ (as sm@34@06  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@24@06) i2@38@06)))
        (< i2@38@06 V@27@06))
      (<= 0 i2@38@06))
    (< i1@37@06 V@27@06))
  (<= 0 i1@37@06)))
; [eval] i1 == i2
(pop) ; 5
(push) ; 5
; [else-branch: 16 | !(Lookup(option$array$,sm@34@06,aloc((_, _), opt_get1(_, G@24@06), i1@37@06)) == Lookup(option$array$,sm@34@06,aloc((_, _), opt_get1(_, G@24@06), i2@38@06)) && i2@38@06 < V@27@06 && 0 <= i2@38@06 && i1@37@06 < V@27@06 && 0 <= i1@37@06)]
(assert (not
  (and
    (and
      (and
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@34@06  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@37@06))
            ($FVF.lookup_option$array$ (as sm@34@06  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@24@06) i2@38@06)))
          (< i2@38@06 V@27@06))
        (<= 0 i2@38@06))
      (< i1@37@06 V@27@06))
    (<= 0 i1@37@06))))
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (implies
  (and
    (and
      (and
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@34@06  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@37@06))
            ($FVF.lookup_option$array$ (as sm@34@06  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@24@06) i2@38@06)))
          (< i2@38@06 V@27@06))
        (<= 0 i2@38@06))
      (< i1@37@06 V@27@06))
    (<= 0 i1@37@06))
  (and
    (=
      ($FVF.lookup_option$array$ (as sm@34@06  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@37@06))
      ($FVF.lookup_option$array$ (as sm@34@06  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@24@06) i2@38@06)))
    (< i2@38@06 V@27@06)
    (<= 0 i2@38@06)
    (< i1@37@06 V@27@06)
    (<= 0 i1@37@06))))
; Joined path conditions
(pop) ; 3
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i2@38@06 Int)) (!
  (and
    (implies
      (<= 0 i1@37@06)
      (and
        (<= 0 i1@37@06)
        (implies
          (< i1@37@06 V@27@06)
          (and
            (< i1@37@06 V@27@06)
            (implies
              (<= 0 i2@38@06)
              (and
                (<= 0 i2@38@06)
                (implies
                  (< i2@38@06 V@27@06)
                  (and
                    (< i2@38@06 V@27@06)
                    (< i1@37@06 (alen<Int> (opt_get1 $Snap.unit G@24@06)))
                    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@34@06  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@37@06)) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@37@06))
                    (< i2@38@06 (alen<Int> (opt_get1 $Snap.unit G@24@06)))
                    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@34@06  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit G@24@06) i2@38@06)) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit G@24@06) i2@38@06))))))))))
    (implies
      (and
        (and
          (and
            (and
              (=
                ($FVF.lookup_option$array$ (as sm@34@06  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@37@06))
                ($FVF.lookup_option$array$ (as sm@34@06  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@24@06) i2@38@06)))
              (< i2@38@06 V@27@06))
            (<= 0 i2@38@06))
          (< i1@37@06 V@27@06))
        (<= 0 i1@37@06))
      (and
        (=
          ($FVF.lookup_option$array$ (as sm@34@06  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@37@06))
          ($FVF.lookup_option$array$ (as sm@34@06  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@24@06) i2@38@06)))
        (< i2@38@06 V@27@06)
        (<= 0 i2@38@06)
        (< i1@37@06 V@27@06)
        (<= 0 i1@37@06))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i2@38@06))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 2
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@37@06 Int)) (!
  (forall ((i2@38@06 Int)) (!
    (and
      (implies
        (<= 0 i1@37@06)
        (and
          (<= 0 i1@37@06)
          (implies
            (< i1@37@06 V@27@06)
            (and
              (< i1@37@06 V@27@06)
              (implies
                (<= 0 i2@38@06)
                (and
                  (<= 0 i2@38@06)
                  (implies
                    (< i2@38@06 V@27@06)
                    (and
                      (< i2@38@06 V@27@06)
                      (< i1@37@06 (alen<Int> (opt_get1 $Snap.unit G@24@06)))
                      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@34@06  $FVF<option<array>>) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@37@06)) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@37@06))
                      (< i2@38@06 (alen<Int> (opt_get1 $Snap.unit G@24@06)))
                      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@34@06  $FVF<option<array>>) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit G@24@06) i2@38@06)) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit G@24@06) i2@38@06))))))))))
      (implies
        (and
          (and
            (and
              (and
                (=
                  ($FVF.lookup_option$array$ (as sm@34@06  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@37@06))
                  ($FVF.lookup_option$array$ (as sm@34@06  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit G@24@06) i2@38@06)))
                (< i2@38@06 V@27@06))
              (<= 0 i2@38@06))
            (< i1@37@06 V@27@06))
          (<= 0 i1@37@06))
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@34@06  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@37@06))
            ($FVF.lookup_option$array$ (as sm@34@06  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@24@06) i2@38@06)))
          (< i2@38@06 V@27@06)
          (<= 0 i2@38@06)
          (< i1@37@06 V@27@06)
          (<= 0 i1@37@06))))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i2@38@06))
    :qid |prog.l<no position>-aux|))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@37@06))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(assert (forall ((i1@37@06 Int)) (!
  (forall ((i2@38@06 Int)) (!
    (implies
      (and
        (and
          (and
            (and
              (=
                ($FVF.lookup_option$array$ (as sm@34@06  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@37@06))
                ($FVF.lookup_option$array$ (as sm@34@06  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@24@06) i2@38@06)))
              (< i2@38@06 V@27@06))
            (<= 0 i2@38@06))
          (< i1@37@06 V@27@06))
        (<= 0 i1@37@06))
      (= i1@37@06 i2@38@06))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i2@38@06))
    :qid |prog.l<no position>|))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@37@06))
  :qid |prog.l<no position>|)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@30@06)))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@30@06))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@30@06)))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@30@06))))))))
  $Snap.unit))
; [eval] 0 <= s
(assert (<= 0 s@25@06))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@30@06))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@30@06)))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@30@06))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@30@06)))))))))
  $Snap.unit))
; [eval] s < V
(assert (< s@25@06 V@27@06))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@30@06)))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@30@06))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@30@06)))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@30@06))))))))))
  $Snap.unit))
; [eval] 0 <= t
(assert (<= 0 t@26@06))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@30@06))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@30@06)))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@30@06))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@30@06)))))))))))
  $Snap.unit))
; [eval] t < V
(assert (< t@26@06 V@27@06))
(declare-const i1@39@06 Int)
(declare-const j1@40@06 Int)
(push) ; 2
; [eval] 0 <= i1 && i1 < V && (0 <= j1 && j1 < V)
; [eval] 0 <= i1
(push) ; 3
; [then-branch: 17 | 0 <= i1@39@06 | live]
; [else-branch: 17 | !(0 <= i1@39@06) | live]
(push) ; 4
; [then-branch: 17 | 0 <= i1@39@06]
(assert (<= 0 i1@39@06))
; [eval] i1 < V
(push) ; 5
; [then-branch: 18 | i1@39@06 < V@27@06 | live]
; [else-branch: 18 | !(i1@39@06 < V@27@06) | live]
(push) ; 6
; [then-branch: 18 | i1@39@06 < V@27@06]
(assert (< i1@39@06 V@27@06))
; [eval] 0 <= j1
(push) ; 7
; [then-branch: 19 | 0 <= j1@40@06 | live]
; [else-branch: 19 | !(0 <= j1@40@06) | live]
(push) ; 8
; [then-branch: 19 | 0 <= j1@40@06]
(assert (<= 0 j1@40@06))
; [eval] j1 < V
(pop) ; 8
(push) ; 8
; [else-branch: 19 | !(0 <= j1@40@06)]
(assert (not (<= 0 j1@40@06)))
(pop) ; 8
(pop) ; 7
; Joined path conditions
; Joined path conditions
(pop) ; 6
(push) ; 6
; [else-branch: 18 | !(i1@39@06 < V@27@06)]
(assert (not (< i1@39@06 V@27@06)))
(pop) ; 6
(pop) ; 5
; Joined path conditions
; Joined path conditions
(pop) ; 4
(push) ; 4
; [else-branch: 17 | !(0 <= i1@39@06)]
(assert (not (<= 0 i1@39@06)))
(pop) ; 4
(pop) ; 3
; Joined path conditions
; Joined path conditions
(assert (and
  (and (and (< j1@40@06 V@27@06) (<= 0 j1@40@06)) (< i1@39@06 V@27@06))
  (<= 0 i1@39@06)))
; [eval] aloc(opt_get1(aloc(opt_get1(G), i1).option$array$), j1)
; [eval] opt_get1(aloc(opt_get1(G), i1).option$array$)
; [eval] aloc(opt_get1(G), i1)
; [eval] opt_get1(G)
(push) ; 3
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 3
; Joined path conditions
(push) ; 3
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 4
(assert (not (< i1@39@06 (alen<Int> (opt_get1 $Snap.unit G@24@06)))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               206
;  :arith-add-rows          79
;  :arith-assert-diseq      4
;  :arith-assert-lower      49
;  :arith-assert-upper      29
;  :arith-bound-prop        14
;  :arith-conflicts         4
;  :arith-eq-adapter        19
;  :arith-fixed-eqs         15
;  :arith-offset-eqs        10
;  :arith-pivots            63
;  :conflicts               10
;  :datatype-accessor-ax    19
;  :datatype-constructor-ax 5
;  :datatype-occurs-check   9
;  :datatype-splits         5
;  :decisions               6
;  :del-clause              97
;  :final-checks            9
;  :max-generation          2
;  :max-memory              4.14
;  :memory                  4.13
;  :mk-bool-var             577
;  :mk-clause               99
;  :num-allocs              132917
;  :num-checks              25
;  :propagations            35
;  :quant-instantiations    84
;  :rlimit-count            141001)
(assert (< i1@39@06 (alen<Int> (opt_get1 $Snap.unit G@24@06))))
(pop) ; 3
; Joined path conditions
(assert (< i1@39@06 (alen<Int> (opt_get1 $Snap.unit G@24@06))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@34@06  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@39@06)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@39@06)))
(push) ; 3
(assert (not (ite
  (and
    (<
      (inv@33@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@39@06))
      V@27@06)
    (<=
      0
      (inv@33@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@39@06))))
  (< $Perm.No $k@32@06)
  false)))
(check-sat)
; unsat
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               212
;  :arith-add-rows          86
;  :arith-assert-diseq      4
;  :arith-assert-lower      50
;  :arith-assert-upper      31
;  :arith-bound-prop        15
;  :arith-conflicts         5
;  :arith-eq-adapter        20
;  :arith-fixed-eqs         16
;  :arith-offset-eqs        11
;  :arith-pivots            65
;  :conflicts               11
;  :datatype-accessor-ax    19
;  :datatype-constructor-ax 5
;  :datatype-occurs-check   9
;  :datatype-splits         5
;  :decisions               6
;  :del-clause              97
;  :final-checks            9
;  :max-generation          3
;  :max-memory              4.16
;  :memory                  4.15
;  :mk-bool-var             606
;  :mk-clause               106
;  :num-allocs              133306
;  :num-checks              26
;  :propagations            35
;  :quant-instantiations    99
;  :rlimit-count            142051)
(push) ; 3
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 4
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@34@06  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@39@06))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               212
;  :arith-add-rows          86
;  :arith-assert-diseq      4
;  :arith-assert-lower      50
;  :arith-assert-upper      31
;  :arith-bound-prop        15
;  :arith-conflicts         5
;  :arith-eq-adapter        20
;  :arith-fixed-eqs         16
;  :arith-offset-eqs        11
;  :arith-pivots            65
;  :conflicts               12
;  :datatype-accessor-ax    19
;  :datatype-constructor-ax 5
;  :datatype-occurs-check   9
;  :datatype-splits         5
;  :decisions               6
;  :del-clause              97
;  :final-checks            9
;  :max-generation          3
;  :max-memory              4.16
;  :memory                  4.15
;  :mk-bool-var             606
;  :mk-clause               106
;  :num-allocs              133394
;  :num-checks              27
;  :propagations            35
;  :quant-instantiations    99
;  :rlimit-count            142146)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@34@06  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@39@06))
    (as None<option<array>>  option<array>))))
(pop) ; 3
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@34@06  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@39@06))
    (as None<option<array>>  option<array>))))
(push) ; 3
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 4
(assert (not (<
  j1@40@06
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@34@06  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@39@06)))))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               218
;  :arith-add-rows          92
;  :arith-assert-diseq      4
;  :arith-assert-lower      53
;  :arith-assert-upper      32
;  :arith-bound-prop        15
;  :arith-conflicts         6
;  :arith-eq-adapter        21
;  :arith-fixed-eqs         17
;  :arith-offset-eqs        11
;  :arith-pivots            69
;  :conflicts               13
;  :datatype-accessor-ax    19
;  :datatype-constructor-ax 5
;  :datatype-occurs-check   9
;  :datatype-splits         5
;  :decisions               6
;  :del-clause              101
;  :final-checks            9
;  :max-generation          3
;  :max-memory              4.16
;  :memory                  4.15
;  :mk-bool-var             617
;  :mk-clause               110
;  :num-allocs              133595
;  :num-checks              28
;  :propagations            37
;  :quant-instantiations    106
;  :rlimit-count            142667)
(assert (<
  j1@40@06
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@34@06  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@39@06))))))
(pop) ; 3
; Joined path conditions
(assert (<
  j1@40@06
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@34@06  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@39@06))))))
(pop) ; 2
(declare-fun inv@41@06 ($Ref) Int)
(declare-fun inv@42@06 ($Ref) Int)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(assert (forall ((i1@39@06 Int) (j1@40@06 Int)) (!
  (and
    (< i1@39@06 (alen<Int> (opt_get1 $Snap.unit G@24@06)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@34@06  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@39@06)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@39@06))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@34@06  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@39@06))
        (as None<option<array>>  option<array>)))
    (<
      j1@40@06
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@34@06  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@39@06))))))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@34@06  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@39@06))) j1@40@06))
  :qid |int-aux|)))
; Check receiver injectivity
(push) ; 2
(assert (not (forall ((i11@39@06 Int) (j11@40@06 Int) (i12@39@06 Int) (j12@40@06 Int)) (!
  (implies
    (and
      (and
        (and (and (< j11@40@06 V@27@06) (<= 0 j11@40@06)) (< i11@39@06 V@27@06))
        (<= 0 i11@39@06))
      (and
        (and (and (< j12@40@06 V@27@06) (<= 0 j12@40@06)) (< i12@39@06 V@27@06))
        (<= 0 i12@39@06))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@34@06  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@24@06) i11@39@06))) j11@40@06)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@34@06  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@24@06) i12@39@06))) j12@40@06)))
    (and (= i11@39@06 i12@39@06) (= j11@40@06 j12@40@06)))
  
  :qid |int-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 2
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               259
;  :arith-add-rows          112
;  :arith-assert-diseq      4
;  :arith-assert-lower      66
;  :arith-assert-upper      35
;  :arith-bound-prop        17
;  :arith-conflicts         6
;  :arith-eq-adapter        27
;  :arith-fixed-eqs         19
;  :arith-offset-eqs        13
;  :arith-pivots            79
;  :conflicts               14
;  :datatype-accessor-ax    19
;  :datatype-constructor-ax 5
;  :datatype-occurs-check   9
;  :datatype-splits         5
;  :decisions               6
;  :del-clause              167
;  :final-checks            9
;  :max-generation          3
;  :max-memory              4.24
;  :memory                  4.23
;  :mk-bool-var             750
;  :mk-clause               169
;  :num-allocs              134904
;  :num-checks              29
;  :propagations            61
;  :quant-instantiations    164
;  :rlimit-count            146369
;  :time                    0.00)
; Definitional axioms for inverse functions
(assert (forall ((i1@39@06 Int) (j1@40@06 Int)) (!
  (implies
    (and
      (and (and (< j1@40@06 V@27@06) (<= 0 j1@40@06)) (< i1@39@06 V@27@06))
      (<= 0 i1@39@06))
    (and
      (=
        (inv@41@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@34@06  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@39@06))) j1@40@06))
        i1@39@06)
      (=
        (inv@42@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@34@06  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@39@06))) j1@40@06))
        j1@40@06)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@34@06  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@39@06))) j1@40@06))
  )))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@42@06 r) V@27@06) (<= 0 (inv@42@06 r)))
        (< (inv@41@06 r) V@27@06))
      (<= 0 (inv@41@06 r)))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@34@06  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@24@06) (inv@41@06 r)))) (inv@42@06 r))
      r))
  :pattern ((inv@41@06 r))
  :pattern ((inv@42@06 r))
  :qid |int-fctOfInv|)))
; Permissions are non-negative
; Field permissions are at most one
; Permission implies non-null receiver
(assert (forall ((i1@39@06 Int) (j1@40@06 Int)) (!
  (implies
    (and
      (and (and (< j1@40@06 V@27@06) (<= 0 j1@40@06)) (< i1@39@06 V@27@06))
      (<= 0 i1@39@06))
    (not
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@34@06  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@39@06))) j1@40@06)
        $Ref.null)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@34@06  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@39@06))) j1@40@06))
  :qid |int-permImpliesNonNull|)))
(declare-const sm@43@06 $FVF<Int>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@42@06 r) V@27@06) (<= 0 (inv@42@06 r)))
        (< (inv@41@06 r) V@27@06))
      (<= 0 (inv@41@06 r)))
    (=
      ($FVF.lookup_int (as sm@43@06  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@30@06)))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@43@06  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@30@06)))))))))))) r))
  :qid |qp.fvfValDef5|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@30@06)))))))))))) r) r)
  :pattern (($FVF.lookup_int (as sm@43@06  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef6|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@42@06 r) V@27@06) (<= 0 (inv@42@06 r)))
        (< (inv@41@06 r) V@27@06))
      (<= 0 (inv@41@06 r)))
    ($FVF.loc_int ($FVF.lookup_int (as sm@43@06  $FVF<Int>) r) r))
  :pattern ((inv@41@06 r) (inv@42@06 r))
  )))
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
(push) ; 2
(declare-const $t@44@06 $Snap)
(assert (= $t@44@06 ($Snap.combine ($Snap.first $t@44@06) ($Snap.second $t@44@06))))
(assert (= ($Snap.first $t@44@06) $Snap.unit))
; [eval] exc == null
(assert (= exc@28@06 $Ref.null))
(assert (=
  ($Snap.second $t@44@06)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@44@06))
    ($Snap.second ($Snap.second $t@44@06)))))
(assert (= ($Snap.first ($Snap.second $t@44@06)) $Snap.unit))
; [eval] exc == null ==> G != (None(): option[array])
; [eval] exc == null
(push) ; 3
(set-option :timeout 10)
(push) ; 4
(assert (not (not (= exc@28@06 $Ref.null))))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               286
;  :arith-add-rows          112
;  :arith-assert-diseq      4
;  :arith-assert-lower      66
;  :arith-assert-upper      35
;  :arith-bound-prop        17
;  :arith-conflicts         6
;  :arith-eq-adapter        27
;  :arith-fixed-eqs         19
;  :arith-offset-eqs        13
;  :arith-pivots            80
;  :conflicts               14
;  :datatype-accessor-ax    21
;  :datatype-constructor-ax 10
;  :datatype-occurs-check   15
;  :datatype-splits         8
;  :decisions               11
;  :del-clause              169
;  :final-checks            13
;  :max-generation          3
;  :max-memory              4.27
;  :memory                  4.26
;  :mk-bool-var             764
;  :mk-clause               169
;  :num-allocs              136982
;  :num-checks              31
;  :propagations            61
;  :quant-instantiations    164
;  :rlimit-count            150097)
; [then-branch: 20 | exc@28@06 == Null | live]
; [else-branch: 20 | exc@28@06 != Null | dead]
(push) ; 4
; [then-branch: 20 | exc@28@06 == Null]
; [eval] G != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 4
(pop) ; 3
; Joined path conditions
(assert (implies
  (= exc@28@06 $Ref.null)
  (not (= G@24@06 (as None<option<array>>  option<array>)))))
(assert (=
  ($Snap.second ($Snap.second $t@44@06))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second $t@44@06)))
    ($Snap.second ($Snap.second ($Snap.second $t@44@06))))))
(assert (= ($Snap.first ($Snap.second ($Snap.second $t@44@06))) $Snap.unit))
; [eval] exc == null ==> alen(opt_get1(G)) == V
; [eval] exc == null
(push) ; 3
(push) ; 4
(assert (not (not (= exc@28@06 $Ref.null))))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               302
;  :arith-add-rows          112
;  :arith-assert-diseq      4
;  :arith-assert-lower      66
;  :arith-assert-upper      35
;  :arith-bound-prop        17
;  :arith-conflicts         6
;  :arith-eq-adapter        27
;  :arith-fixed-eqs         19
;  :arith-offset-eqs        13
;  :arith-pivots            80
;  :conflicts               14
;  :datatype-accessor-ax    22
;  :datatype-constructor-ax 13
;  :datatype-occurs-check   18
;  :datatype-splits         9
;  :decisions               14
;  :del-clause              169
;  :final-checks            15
;  :max-generation          3
;  :max-memory              4.27
;  :memory                  4.26
;  :mk-bool-var             767
;  :mk-clause               169
;  :num-allocs              137570
;  :num-checks              32
;  :propagations            61
;  :quant-instantiations    164
;  :rlimit-count            150696)
; [then-branch: 21 | exc@28@06 == Null | live]
; [else-branch: 21 | exc@28@06 != Null | dead]
(push) ; 4
; [then-branch: 21 | exc@28@06 == Null]
; [eval] alen(opt_get1(G)) == V
; [eval] alen(opt_get1(G))
; [eval] opt_get1(G)
(push) ; 5
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 5
; Joined path conditions
(pop) ; 4
(pop) ; 3
; Joined path conditions
(assert (implies
  (= exc@28@06 $Ref.null)
  (= (alen<Int> (opt_get1 $Snap.unit G@24@06)) V@27@06)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second $t@44@06)))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@44@06))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@44@06)))))))
; [eval] exc == null
(push) ; 3
(assert (not (not (= exc@28@06 $Ref.null))))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               320
;  :arith-add-rows          112
;  :arith-assert-diseq      4
;  :arith-assert-lower      66
;  :arith-assert-upper      35
;  :arith-bound-prop        17
;  :arith-conflicts         6
;  :arith-eq-adapter        27
;  :arith-fixed-eqs         19
;  :arith-offset-eqs        13
;  :arith-pivots            80
;  :conflicts               14
;  :datatype-accessor-ax    23
;  :datatype-constructor-ax 17
;  :datatype-occurs-check   21
;  :datatype-splits         11
;  :decisions               18
;  :del-clause              169
;  :final-checks            17
;  :max-generation          3
;  :max-memory              4.27
;  :memory                  4.26
;  :mk-bool-var             770
;  :mk-clause               169
;  :num-allocs              138153
;  :num-checks              33
;  :propagations            61
;  :quant-instantiations    164
;  :rlimit-count            151287)
; [then-branch: 22 | exc@28@06 == Null | live]
; [else-branch: 22 | exc@28@06 != Null | dead]
(push) ; 3
; [then-branch: 22 | exc@28@06 == Null]
(declare-const i1@45@06 Int)
(push) ; 4
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 5
; [then-branch: 23 | 0 <= i1@45@06 | live]
; [else-branch: 23 | !(0 <= i1@45@06) | live]
(push) ; 6
; [then-branch: 23 | 0 <= i1@45@06]
(assert (<= 0 i1@45@06))
; [eval] i1 < V
(pop) ; 6
(push) ; 6
; [else-branch: 23 | !(0 <= i1@45@06)]
(assert (not (<= 0 i1@45@06)))
(pop) ; 6
(pop) ; 5
; Joined path conditions
; Joined path conditions
(assert (and (< i1@45@06 V@27@06) (<= 0 i1@45@06)))
; [eval] aloc(opt_get1(G), i1)
; [eval] opt_get1(G)
(push) ; 5
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 5
; Joined path conditions
(push) ; 5
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 6
(assert (not (< i1@45@06 (alen<Int> (opt_get1 $Snap.unit G@24@06)))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               320
;  :arith-add-rows          113
;  :arith-assert-diseq      4
;  :arith-assert-lower      68
;  :arith-assert-upper      35
;  :arith-bound-prop        17
;  :arith-conflicts         6
;  :arith-eq-adapter        27
;  :arith-fixed-eqs         19
;  :arith-offset-eqs        13
;  :arith-pivots            81
;  :conflicts               14
;  :datatype-accessor-ax    23
;  :datatype-constructor-ax 17
;  :datatype-occurs-check   21
;  :datatype-splits         11
;  :decisions               18
;  :del-clause              169
;  :final-checks            17
;  :max-generation          3
;  :max-memory              4.27
;  :memory                  4.26
;  :mk-bool-var             772
;  :mk-clause               169
;  :num-allocs              138255
;  :num-checks              34
;  :propagations            61
;  :quant-instantiations    164
;  :rlimit-count            151478)
(assert (< i1@45@06 (alen<Int> (opt_get1 $Snap.unit G@24@06))))
(pop) ; 5
; Joined path conditions
(assert (< i1@45@06 (alen<Int> (opt_get1 $Snap.unit G@24@06))))
(declare-const $k@46@06 $Perm)
(assert ($Perm.isReadVar $k@46@06 $Perm.Write))
(pop) ; 4
(declare-fun inv@47@06 ($Ref) Int)
; Nested auxiliary terms: globals
(assert ($Perm.isReadVar $k@46@06 $Perm.Write))
; Nested auxiliary terms: non-globals
(assert (forall ((i1@45@06 Int)) (!
  (< i1@45@06 (alen<Int> (opt_get1 $Snap.unit G@24@06)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@45@06))
  :qid |option$array$-aux|)))
(push) ; 4
(assert (not (forall ((i1@45@06 Int)) (!
  (implies
    (and (< i1@45@06 V@27@06) (<= 0 i1@45@06))
    (or (= $k@46@06 $Perm.No) (< $Perm.No $k@46@06)))
  
  ))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               320
;  :arith-add-rows          114
;  :arith-assert-diseq      5
;  :arith-assert-lower      70
;  :arith-assert-upper      36
;  :arith-bound-prop        17
;  :arith-conflicts         6
;  :arith-eq-adapter        28
;  :arith-fixed-eqs         19
;  :arith-offset-eqs        13
;  :arith-pivots            82
;  :conflicts               15
;  :datatype-accessor-ax    23
;  :datatype-constructor-ax 17
;  :datatype-occurs-check   21
;  :datatype-splits         11
;  :decisions               18
;  :del-clause              169
;  :final-checks            17
;  :max-generation          3
;  :max-memory              4.27
;  :memory                  4.26
;  :mk-bool-var             779
;  :mk-clause               171
;  :num-allocs              138719
;  :num-checks              35
;  :propagations            62
;  :quant-instantiations    164
;  :rlimit-count            152053)
; Check receiver injectivity
(push) ; 4
(assert (not (forall ((i11@45@06 Int) (i12@45@06 Int)) (!
  (implies
    (and
      (and (and (< i11@45@06 V@27@06) (<= 0 i11@45@06)) (< $Perm.No $k@46@06))
      (and (and (< i12@45@06 V@27@06) (<= 0 i12@45@06)) (< $Perm.No $k@46@06))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i11@45@06)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i12@45@06)))
    (= i11@45@06 i12@45@06))
  
  :qid |option$array$-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               327
;  :arith-add-rows          120
;  :arith-assert-diseq      6
;  :arith-assert-lower      74
;  :arith-assert-upper      36
;  :arith-bound-prop        17
;  :arith-conflicts         6
;  :arith-eq-adapter        29
;  :arith-fixed-eqs         19
;  :arith-offset-eqs        13
;  :arith-pivots            84
;  :conflicts               16
;  :datatype-accessor-ax    23
;  :datatype-constructor-ax 17
;  :datatype-occurs-check   21
;  :datatype-splits         11
;  :decisions               18
;  :del-clause              175
;  :final-checks            17
;  :max-generation          3
;  :max-memory              4.27
;  :memory                  4.26
;  :mk-bool-var             797
;  :mk-clause               177
;  :num-allocs              139085
;  :num-checks              36
;  :propagations            62
;  :quant-instantiations    175
;  :rlimit-count            152786)
; Definitional axioms for inverse functions
(assert (forall ((i1@45@06 Int)) (!
  (implies
    (and (and (< i1@45@06 V@27@06) (<= 0 i1@45@06)) (< $Perm.No $k@46@06))
    (=
      (inv@47@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@45@06))
      i1@45@06))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@45@06))
  )))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and (< (inv@47@06 r) V@27@06) (<= 0 (inv@47@06 r)))
      (< $Perm.No $k@46@06))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) (inv@47@06 r))
      r))
  :pattern ((inv@47@06 r))
  :qid |option$array$-fctOfInv|)))
; Permissions are non-negative
(assert (forall ((i1@45@06 Int)) (!
  (<= $Perm.No $k@46@06)
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@45@06))
  :qid |option$array$-permAtLeastZero|)))
; Field permissions are at most one
(assert (forall ((i1@45@06 Int)) (!
  (<= $k@46@06 $Perm.Write)
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@45@06))
  :qid |option$array$-permAtMostOne|)))
; Permission implies non-null receiver
(assert (forall ((i1@45@06 Int)) (!
  (implies
    (and (and (< i1@45@06 V@27@06) (<= 0 i1@45@06)) (< $Perm.No $k@46@06))
    (not
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@45@06)
        $Ref.null)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@45@06))
  :qid |option$array$-permImpliesNonNull|)))
(declare-const sm@48@06 $FVF<option<array>>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@47@06 r) V@27@06) (<= 0 (inv@47@06 r)))
      (< $Perm.No $k@46@06)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@48@06  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@44@06))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@48@06  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@44@06))))) r))
  :qid |qp.fvfValDef7|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@44@06))))) r) r)
  :pattern (($FVF.lookup_option$array$ (as sm@48@06  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef8|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@47@06 r) V@27@06) (<= 0 (inv@47@06 r)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@48@06  $FVF<option<array>>) r) r))
  :pattern ((inv@47@06 r))
  )))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@44@06))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@44@06)))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@44@06))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@44@06)))))
  $Snap.unit))
; [eval] exc == null ==> (forall i1: Int :: { aloc(opt_get1(G), i1) } 0 <= i1 && i1 < V ==> aloc(opt_get1(G), i1).option$array$ != (None(): option[array]))
; [eval] exc == null
(push) ; 4
(set-option :timeout 10)
(push) ; 5
(assert (not (not (= exc@28@06 $Ref.null))))
(check-sat)
; unknown
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               348
;  :arith-add-rows          120
;  :arith-assert-diseq      6
;  :arith-assert-lower      74
;  :arith-assert-upper      37
;  :arith-bound-prop        17
;  :arith-conflicts         6
;  :arith-eq-adapter        29
;  :arith-fixed-eqs         19
;  :arith-offset-eqs        13
;  :arith-pivots            84
;  :conflicts               16
;  :datatype-accessor-ax    24
;  :datatype-constructor-ax 21
;  :datatype-occurs-check   24
;  :datatype-splits         13
;  :decisions               22
;  :del-clause              175
;  :final-checks            19
;  :max-generation          3
;  :max-memory              4.28
;  :memory                  4.28
;  :mk-bool-var             808
;  :mk-clause               177
;  :num-allocs              140663
;  :num-checks              37
;  :propagations            62
;  :quant-instantiations    175
;  :rlimit-count            155402)
; [then-branch: 24 | exc@28@06 == Null | live]
; [else-branch: 24 | exc@28@06 != Null | dead]
(push) ; 5
; [then-branch: 24 | exc@28@06 == Null]
; [eval] (forall i1: Int :: { aloc(opt_get1(G), i1) } 0 <= i1 && i1 < V ==> aloc(opt_get1(G), i1).option$array$ != (None(): option[array]))
(declare-const i1@49@06 Int)
(push) ; 6
; [eval] 0 <= i1 && i1 < V ==> aloc(opt_get1(G), i1).option$array$ != (None(): option[array])
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 7
; [then-branch: 25 | 0 <= i1@49@06 | live]
; [else-branch: 25 | !(0 <= i1@49@06) | live]
(push) ; 8
; [then-branch: 25 | 0 <= i1@49@06]
(assert (<= 0 i1@49@06))
; [eval] i1 < V
(pop) ; 8
(push) ; 8
; [else-branch: 25 | !(0 <= i1@49@06)]
(assert (not (<= 0 i1@49@06)))
(pop) ; 8
(pop) ; 7
; Joined path conditions
; Joined path conditions
(push) ; 7
; [then-branch: 26 | i1@49@06 < V@27@06 && 0 <= i1@49@06 | live]
; [else-branch: 26 | !(i1@49@06 < V@27@06 && 0 <= i1@49@06) | live]
(push) ; 8
; [then-branch: 26 | i1@49@06 < V@27@06 && 0 <= i1@49@06]
(assert (and (< i1@49@06 V@27@06) (<= 0 i1@49@06)))
; [eval] aloc(opt_get1(G), i1).option$array$ != (None(): option[array])
; [eval] aloc(opt_get1(G), i1)
; [eval] opt_get1(G)
(push) ; 9
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 9
; Joined path conditions
(push) ; 9
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 10
(assert (not (< i1@49@06 (alen<Int> (opt_get1 $Snap.unit G@24@06)))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               348
;  :arith-add-rows          121
;  :arith-assert-diseq      6
;  :arith-assert-lower      76
;  :arith-assert-upper      37
;  :arith-bound-prop        17
;  :arith-conflicts         6
;  :arith-eq-adapter        29
;  :arith-fixed-eqs         19
;  :arith-offset-eqs        13
;  :arith-pivots            85
;  :conflicts               16
;  :datatype-accessor-ax    24
;  :datatype-constructor-ax 21
;  :datatype-occurs-check   24
;  :datatype-splits         13
;  :decisions               22
;  :del-clause              175
;  :final-checks            19
;  :max-generation          3
;  :max-memory              4.28
;  :memory                  4.28
;  :mk-bool-var             810
;  :mk-clause               177
;  :num-allocs              140765
;  :num-checks              38
;  :propagations            62
;  :quant-instantiations    175
;  :rlimit-count            155603)
(assert (< i1@49@06 (alen<Int> (opt_get1 $Snap.unit G@24@06))))
(pop) ; 9
; Joined path conditions
(assert (< i1@49@06 (alen<Int> (opt_get1 $Snap.unit G@24@06))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@48@06  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@49@06)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@49@06)))
(push) ; 9
(assert (not (ite
  (and
    (<
      (inv@47@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@49@06))
      V@27@06)
    (<=
      0
      (inv@47@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@49@06))))
  (< $Perm.No $k@46@06)
  false)))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               364
;  :arith-add-rows          134
;  :arith-assert-diseq      6
;  :arith-assert-lower      78
;  :arith-assert-upper      40
;  :arith-bound-prop        20
;  :arith-conflicts         7
;  :arith-eq-adapter        31
;  :arith-fixed-eqs         21
;  :arith-offset-eqs        18
;  :arith-pivots            88
;  :conflicts               17
;  :datatype-accessor-ax    24
;  :datatype-constructor-ax 21
;  :datatype-occurs-check   24
;  :datatype-splits         13
;  :decisions               22
;  :del-clause              175
;  :final-checks            19
;  :max-generation          3
;  :max-memory              4.33
;  :memory                  4.30
;  :mk-bool-var             857
;  :mk-clause               197
;  :num-allocs              141220
;  :num-checks              39
;  :propagations            66
;  :quant-instantiations    198
;  :rlimit-count            157017)
; [eval] (None(): option[array])
(pop) ; 8
(push) ; 8
; [else-branch: 26 | !(i1@49@06 < V@27@06 && 0 <= i1@49@06)]
(assert (not (and (< i1@49@06 V@27@06) (<= 0 i1@49@06))))
(pop) ; 8
(pop) ; 7
; Joined path conditions
(assert (implies
  (and (< i1@49@06 V@27@06) (<= 0 i1@49@06))
  (and
    (< i1@49@06 V@27@06)
    (<= 0 i1@49@06)
    (< i1@49@06 (alen<Int> (opt_get1 $Snap.unit G@24@06)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@48@06  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@49@06)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@49@06)))))
; Joined path conditions
(pop) ; 6
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@49@06 Int)) (!
  (implies
    (and (< i1@49@06 V@27@06) (<= 0 i1@49@06))
    (and
      (< i1@49@06 V@27@06)
      (<= 0 i1@49@06)
      (< i1@49@06 (alen<Int> (opt_get1 $Snap.unit G@24@06)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@48@06  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@49@06)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@49@06))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@49@06))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (implies
  (= exc@28@06 $Ref.null)
  (forall ((i1@49@06 Int)) (!
    (implies
      (and (< i1@49@06 V@27@06) (<= 0 i1@49@06))
      (and
        (< i1@49@06 V@27@06)
        (<= 0 i1@49@06)
        (< i1@49@06 (alen<Int> (opt_get1 $Snap.unit G@24@06)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@48@06  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@49@06)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@49@06))))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@49@06))
    :qid |prog.l<no position>-aux|))))
(assert (implies
  (= exc@28@06 $Ref.null)
  (forall ((i1@49@06 Int)) (!
    (implies
      (and (< i1@49@06 V@27@06) (<= 0 i1@49@06))
      (not
        (=
          ($FVF.lookup_option$array$ (as sm@48@06  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@49@06))
          (as None<option<array>>  option<array>))))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@49@06))
    :qid |prog.l<no position>|))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@44@06)))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@44@06))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@44@06)))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@44@06))))))
  $Snap.unit))
; [eval] exc == null ==> (forall i1: Int :: { alen(opt_get1(aloc(opt_get1(G), i1).option$array$)) } 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(G), i1).option$array$)) == V)
; [eval] exc == null
(push) ; 4
(set-option :timeout 10)
(push) ; 5
(assert (not (not (= exc@28@06 $Ref.null))))
(check-sat)
; unknown
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               386
;  :arith-add-rows          137
;  :arith-assert-diseq      6
;  :arith-assert-lower      78
;  :arith-assert-upper      40
;  :arith-bound-prop        20
;  :arith-conflicts         7
;  :arith-eq-adapter        31
;  :arith-fixed-eqs         21
;  :arith-offset-eqs        18
;  :arith-pivots            91
;  :conflicts               17
;  :datatype-accessor-ax    25
;  :datatype-constructor-ax 25
;  :datatype-occurs-check   27
;  :datatype-splits         15
;  :decisions               26
;  :del-clause              195
;  :final-checks            21
;  :max-generation          3
;  :max-memory              4.33
;  :memory                  4.31
;  :mk-bool-var             863
;  :mk-clause               197
;  :num-allocs              142189
;  :num-checks              40
;  :propagations            66
;  :quant-instantiations    198
;  :rlimit-count            158507)
; [then-branch: 27 | exc@28@06 == Null | live]
; [else-branch: 27 | exc@28@06 != Null | dead]
(push) ; 5
; [then-branch: 27 | exc@28@06 == Null]
; [eval] (forall i1: Int :: { alen(opt_get1(aloc(opt_get1(G), i1).option$array$)) } 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(G), i1).option$array$)) == V)
(declare-const i1@50@06 Int)
(push) ; 6
; [eval] 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(G), i1).option$array$)) == V
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 7
; [then-branch: 28 | 0 <= i1@50@06 | live]
; [else-branch: 28 | !(0 <= i1@50@06) | live]
(push) ; 8
; [then-branch: 28 | 0 <= i1@50@06]
(assert (<= 0 i1@50@06))
; [eval] i1 < V
(pop) ; 8
(push) ; 8
; [else-branch: 28 | !(0 <= i1@50@06)]
(assert (not (<= 0 i1@50@06)))
(pop) ; 8
(pop) ; 7
; Joined path conditions
; Joined path conditions
(push) ; 7
; [then-branch: 29 | i1@50@06 < V@27@06 && 0 <= i1@50@06 | live]
; [else-branch: 29 | !(i1@50@06 < V@27@06 && 0 <= i1@50@06) | live]
(push) ; 8
; [then-branch: 29 | i1@50@06 < V@27@06 && 0 <= i1@50@06]
(assert (and (< i1@50@06 V@27@06) (<= 0 i1@50@06)))
; [eval] alen(opt_get1(aloc(opt_get1(G), i1).option$array$)) == V
; [eval] alen(opt_get1(aloc(opt_get1(G), i1).option$array$))
; [eval] opt_get1(aloc(opt_get1(G), i1).option$array$)
; [eval] aloc(opt_get1(G), i1)
; [eval] opt_get1(G)
(push) ; 9
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 9
; Joined path conditions
(push) ; 9
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 10
(assert (not (< i1@50@06 (alen<Int> (opt_get1 $Snap.unit G@24@06)))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               386
;  :arith-add-rows          138
;  :arith-assert-diseq      6
;  :arith-assert-lower      80
;  :arith-assert-upper      40
;  :arith-bound-prop        20
;  :arith-conflicts         7
;  :arith-eq-adapter        31
;  :arith-fixed-eqs         21
;  :arith-offset-eqs        18
;  :arith-pivots            92
;  :conflicts               17
;  :datatype-accessor-ax    25
;  :datatype-constructor-ax 25
;  :datatype-occurs-check   27
;  :datatype-splits         15
;  :decisions               26
;  :del-clause              195
;  :final-checks            21
;  :max-generation          3
;  :max-memory              4.33
;  :memory                  4.31
;  :mk-bool-var             865
;  :mk-clause               197
;  :num-allocs              142291
;  :num-checks              41
;  :propagations            66
;  :quant-instantiations    198
;  :rlimit-count            158708)
(assert (< i1@50@06 (alen<Int> (opt_get1 $Snap.unit G@24@06))))
(pop) ; 9
; Joined path conditions
(assert (< i1@50@06 (alen<Int> (opt_get1 $Snap.unit G@24@06))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@48@06  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@50@06)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@50@06)))
(push) ; 9
(assert (not (ite
  (and
    (<
      (inv@47@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@50@06))
      V@27@06)
    (<=
      0
      (inv@47@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@50@06))))
  (< $Perm.No $k@46@06)
  false)))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               404
;  :arith-add-rows          151
;  :arith-assert-diseq      6
;  :arith-assert-lower      82
;  :arith-assert-upper      43
;  :arith-bound-prop        23
;  :arith-conflicts         8
;  :arith-eq-adapter        33
;  :arith-fixed-eqs         23
;  :arith-offset-eqs        23
;  :arith-pivots            95
;  :conflicts               18
;  :datatype-accessor-ax    25
;  :datatype-constructor-ax 25
;  :datatype-occurs-check   27
;  :datatype-splits         15
;  :decisions               26
;  :del-clause              195
;  :final-checks            21
;  :max-generation          3
;  :max-memory              4.33
;  :memory                  4.30
;  :mk-bool-var             916
;  :mk-clause               217
;  :num-allocs              142723
;  :num-checks              42
;  :propagations            70
;  :quant-instantiations    223
;  :rlimit-count            160149)
(push) ; 9
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 10
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@48@06  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@50@06))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               404
;  :arith-add-rows          151
;  :arith-assert-diseq      6
;  :arith-assert-lower      82
;  :arith-assert-upper      43
;  :arith-bound-prop        23
;  :arith-conflicts         8
;  :arith-eq-adapter        33
;  :arith-fixed-eqs         23
;  :arith-offset-eqs        23
;  :arith-pivots            95
;  :conflicts               19
;  :datatype-accessor-ax    25
;  :datatype-constructor-ax 25
;  :datatype-occurs-check   27
;  :datatype-splits         15
;  :decisions               26
;  :del-clause              195
;  :final-checks            21
;  :max-generation          3
;  :max-memory              4.33
;  :memory                  4.30
;  :mk-bool-var             916
;  :mk-clause               217
;  :num-allocs              142811
;  :num-checks              43
;  :propagations            70
;  :quant-instantiations    223
;  :rlimit-count            160244)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@48@06  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@50@06))
    (as None<option<array>>  option<array>))))
(pop) ; 9
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@48@06  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@50@06))
    (as None<option<array>>  option<array>))))
(pop) ; 8
(push) ; 8
; [else-branch: 29 | !(i1@50@06 < V@27@06 && 0 <= i1@50@06)]
(assert (not (and (< i1@50@06 V@27@06) (<= 0 i1@50@06))))
(pop) ; 8
(pop) ; 7
; Joined path conditions
(assert (implies
  (and (< i1@50@06 V@27@06) (<= 0 i1@50@06))
  (and
    (< i1@50@06 V@27@06)
    (<= 0 i1@50@06)
    (< i1@50@06 (alen<Int> (opt_get1 $Snap.unit G@24@06)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@48@06  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@50@06)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@50@06))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@48@06  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@50@06))
        (as None<option<array>>  option<array>))))))
; Joined path conditions
(pop) ; 6
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@50@06 Int)) (!
  (implies
    (and (< i1@50@06 V@27@06) (<= 0 i1@50@06))
    (and
      (< i1@50@06 V@27@06)
      (<= 0 i1@50@06)
      (< i1@50@06 (alen<Int> (opt_get1 $Snap.unit G@24@06)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@48@06  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@50@06)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@50@06))
      (not
        (=
          ($FVF.lookup_option$array$ (as sm@48@06  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@50@06))
          (as None<option<array>>  option<array>)))))
  :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@48@06  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@50@06)))))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (implies
  (= exc@28@06 $Ref.null)
  (forall ((i1@50@06 Int)) (!
    (implies
      (and (< i1@50@06 V@27@06) (<= 0 i1@50@06))
      (and
        (< i1@50@06 V@27@06)
        (<= 0 i1@50@06)
        (< i1@50@06 (alen<Int> (opt_get1 $Snap.unit G@24@06)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@48@06  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@50@06)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@50@06))
        (not
          (=
            ($FVF.lookup_option$array$ (as sm@48@06  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@50@06))
            (as None<option<array>>  option<array>)))))
    :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@48@06  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@50@06)))))
    :qid |prog.l<no position>-aux|))))
(assert (implies
  (= exc@28@06 $Ref.null)
  (forall ((i1@50@06 Int)) (!
    (implies
      (and (< i1@50@06 V@27@06) (<= 0 i1@50@06))
      (=
        (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@48@06  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@50@06))))
        V@27@06))
    :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@48@06  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@50@06)))))
    :qid |prog.l<no position>|))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@44@06))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@44@06)))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@44@06))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@44@06)))))))
  $Snap.unit))
; [eval] exc == null ==> (forall i1: Int :: { aloc(opt_get1(G), i1) } (forall i2: Int :: { aloc(opt_get1(G), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(G), i1).option$array$ == aloc(opt_get1(G), i2).option$array$ ==> i1 == i2))
; [eval] exc == null
(push) ; 4
(set-option :timeout 10)
(push) ; 5
(assert (not (not (= exc@28@06 $Ref.null))))
(check-sat)
; unknown
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               427
;  :arith-add-rows          154
;  :arith-assert-diseq      6
;  :arith-assert-lower      82
;  :arith-assert-upper      43
;  :arith-bound-prop        23
;  :arith-conflicts         8
;  :arith-eq-adapter        33
;  :arith-fixed-eqs         23
;  :arith-offset-eqs        23
;  :arith-pivots            98
;  :conflicts               19
;  :datatype-accessor-ax    26
;  :datatype-constructor-ax 29
;  :datatype-occurs-check   30
;  :datatype-splits         17
;  :decisions               30
;  :del-clause              215
;  :final-checks            23
;  :max-generation          3
;  :max-memory              4.34
;  :memory                  4.33
;  :mk-bool-var             922
;  :mk-clause               217
;  :num-allocs              143815
;  :num-checks              44
;  :propagations            70
;  :quant-instantiations    223
;  :rlimit-count            161839)
; [then-branch: 30 | exc@28@06 == Null | live]
; [else-branch: 30 | exc@28@06 != Null | dead]
(push) ; 5
; [then-branch: 30 | exc@28@06 == Null]
; [eval] (forall i1: Int :: { aloc(opt_get1(G), i1) } (forall i2: Int :: { aloc(opt_get1(G), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(G), i1).option$array$ == aloc(opt_get1(G), i2).option$array$ ==> i1 == i2))
(declare-const i1@51@06 Int)
(push) ; 6
; [eval] (forall i2: Int :: { aloc(opt_get1(G), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(G), i1).option$array$ == aloc(opt_get1(G), i2).option$array$ ==> i1 == i2)
(declare-const i2@52@06 Int)
(push) ; 7
; [eval] 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(G), i1).option$array$ == aloc(opt_get1(G), i2).option$array$ ==> i1 == i2
; [eval] 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(G), i1).option$array$ == aloc(opt_get1(G), i2).option$array$
; [eval] 0 <= i1
(push) ; 8
; [then-branch: 31 | 0 <= i1@51@06 | live]
; [else-branch: 31 | !(0 <= i1@51@06) | live]
(push) ; 9
; [then-branch: 31 | 0 <= i1@51@06]
(assert (<= 0 i1@51@06))
; [eval] i1 < V
(push) ; 10
; [then-branch: 32 | i1@51@06 < V@27@06 | live]
; [else-branch: 32 | !(i1@51@06 < V@27@06) | live]
(push) ; 11
; [then-branch: 32 | i1@51@06 < V@27@06]
(assert (< i1@51@06 V@27@06))
; [eval] 0 <= i2
(push) ; 12
; [then-branch: 33 | 0 <= i2@52@06 | live]
; [else-branch: 33 | !(0 <= i2@52@06) | live]
(push) ; 13
; [then-branch: 33 | 0 <= i2@52@06]
(assert (<= 0 i2@52@06))
; [eval] i2 < V
(push) ; 14
; [then-branch: 34 | i2@52@06 < V@27@06 | live]
; [else-branch: 34 | !(i2@52@06 < V@27@06) | live]
(push) ; 15
; [then-branch: 34 | i2@52@06 < V@27@06]
(assert (< i2@52@06 V@27@06))
; [eval] aloc(opt_get1(G), i1).option$array$ == aloc(opt_get1(G), i2).option$array$
; [eval] aloc(opt_get1(G), i1)
; [eval] opt_get1(G)
(push) ; 16
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 16
; Joined path conditions
(push) ; 16
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 17
(assert (not (< i1@51@06 (alen<Int> (opt_get1 $Snap.unit G@24@06)))))
(check-sat)
; unsat
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               427
;  :arith-add-rows          156
;  :arith-assert-diseq      6
;  :arith-assert-lower      86
;  :arith-assert-upper      43
;  :arith-bound-prop        23
;  :arith-conflicts         8
;  :arith-eq-adapter        33
;  :arith-fixed-eqs         23
;  :arith-offset-eqs        23
;  :arith-pivots            99
;  :conflicts               19
;  :datatype-accessor-ax    26
;  :datatype-constructor-ax 29
;  :datatype-occurs-check   30
;  :datatype-splits         17
;  :decisions               30
;  :del-clause              215
;  :final-checks            23
;  :max-generation          3
;  :max-memory              4.34
;  :memory                  4.33
;  :mk-bool-var             926
;  :mk-clause               217
;  :num-allocs              144094
;  :num-checks              45
;  :propagations            70
;  :quant-instantiations    223
;  :rlimit-count            162186)
(assert (< i1@51@06 (alen<Int> (opt_get1 $Snap.unit G@24@06))))
(pop) ; 16
; Joined path conditions
(assert (< i1@51@06 (alen<Int> (opt_get1 $Snap.unit G@24@06))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@48@06  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@51@06)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@51@06)))
(push) ; 16
(assert (not (ite
  (and
    (<
      (inv@47@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@51@06))
      V@27@06)
    (<=
      0
      (inv@47@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@51@06))))
  (< $Perm.No $k@46@06)
  false)))
(check-sat)
; unsat
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               437
;  :arith-add-rows          166
;  :arith-assert-diseq      6
;  :arith-assert-lower      88
;  :arith-assert-upper      46
;  :arith-bound-prop        25
;  :arith-conflicts         9
;  :arith-eq-adapter        35
;  :arith-fixed-eqs         25
;  :arith-offset-eqs        23
;  :arith-pivots            102
;  :conflicts               20
;  :datatype-accessor-ax    26
;  :datatype-constructor-ax 29
;  :datatype-occurs-check   30
;  :datatype-splits         17
;  :decisions               30
;  :del-clause              215
;  :final-checks            23
;  :max-generation          3
;  :max-memory              4.35
;  :memory                  4.33
;  :mk-bool-var             977
;  :mk-clause               237
;  :num-allocs              144527
;  :num-checks              46
;  :propagations            71
;  :quant-instantiations    248
;  :rlimit-count            163601)
; [eval] aloc(opt_get1(G), i2)
; [eval] opt_get1(G)
(push) ; 16
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 16
; Joined path conditions
(push) ; 16
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 17
(assert (not (< i2@52@06 (alen<Int> (opt_get1 $Snap.unit G@24@06)))))
(check-sat)
; unsat
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               437
;  :arith-add-rows          166
;  :arith-assert-diseq      6
;  :arith-assert-lower      88
;  :arith-assert-upper      46
;  :arith-bound-prop        25
;  :arith-conflicts         9
;  :arith-eq-adapter        35
;  :arith-fixed-eqs         25
;  :arith-offset-eqs        23
;  :arith-pivots            102
;  :conflicts               20
;  :datatype-accessor-ax    26
;  :datatype-constructor-ax 29
;  :datatype-occurs-check   30
;  :datatype-splits         17
;  :decisions               30
;  :del-clause              215
;  :final-checks            23
;  :max-generation          3
;  :max-memory              4.35
;  :memory                  4.33
;  :mk-bool-var             977
;  :mk-clause               237
;  :num-allocs              144552
;  :num-checks              47
;  :propagations            71
;  :quant-instantiations    248
;  :rlimit-count            163631)
(assert (< i2@52@06 (alen<Int> (opt_get1 $Snap.unit G@24@06))))
(pop) ; 16
; Joined path conditions
(assert (< i2@52@06 (alen<Int> (opt_get1 $Snap.unit G@24@06))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@48@06  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@24@06) i2@52@06)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@24@06) i2@52@06)))
(push) ; 16
(assert (not (ite
  (and
    (<
      (inv@47@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i2@52@06))
      V@27@06)
    (<=
      0
      (inv@47@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i2@52@06))))
  (< $Perm.No $k@46@06)
  false)))
(check-sat)
; unsat
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               454
;  :arith-add-rows          182
;  :arith-assert-diseq      6
;  :arith-assert-lower      90
;  :arith-assert-upper      49
;  :arith-bound-prop        28
;  :arith-conflicts         10
;  :arith-eq-adapter        38
;  :arith-fixed-eqs         27
;  :arith-offset-eqs        28
;  :arith-pivots            105
;  :conflicts               21
;  :datatype-accessor-ax    26
;  :datatype-constructor-ax 29
;  :datatype-occurs-check   30
;  :datatype-splits         17
;  :decisions               30
;  :del-clause              215
;  :final-checks            23
;  :max-generation          3
;  :max-memory              4.36
;  :memory                  4.35
;  :mk-bool-var             1035
;  :mk-clause               269
;  :num-allocs              145026
;  :num-checks              48
;  :propagations            81
;  :quant-instantiations    273
;  :rlimit-count            165192)
(pop) ; 15
(push) ; 15
; [else-branch: 34 | !(i2@52@06 < V@27@06)]
(assert (not (< i2@52@06 V@27@06)))
(pop) ; 15
(pop) ; 14
; Joined path conditions
(assert (implies
  (< i2@52@06 V@27@06)
  (and
    (< i2@52@06 V@27@06)
    (< i1@51@06 (alen<Int> (opt_get1 $Snap.unit G@24@06)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@48@06  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@51@06)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@51@06))
    (< i2@52@06 (alen<Int> (opt_get1 $Snap.unit G@24@06)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@48@06  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@24@06) i2@52@06)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@24@06) i2@52@06)))))
; Joined path conditions
(pop) ; 13
(push) ; 13
; [else-branch: 33 | !(0 <= i2@52@06)]
(assert (not (<= 0 i2@52@06)))
(pop) ; 13
(pop) ; 12
; Joined path conditions
(assert (implies
  (<= 0 i2@52@06)
  (and
    (<= 0 i2@52@06)
    (implies
      (< i2@52@06 V@27@06)
      (and
        (< i2@52@06 V@27@06)
        (< i1@51@06 (alen<Int> (opt_get1 $Snap.unit G@24@06)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@48@06  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@51@06)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@51@06))
        (< i2@52@06 (alen<Int> (opt_get1 $Snap.unit G@24@06)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@48@06  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@24@06) i2@52@06)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@24@06) i2@52@06)))))))
; Joined path conditions
(pop) ; 11
(push) ; 11
; [else-branch: 32 | !(i1@51@06 < V@27@06)]
(assert (not (< i1@51@06 V@27@06)))
(pop) ; 11
(pop) ; 10
; Joined path conditions
(assert (implies
  (< i1@51@06 V@27@06)
  (and
    (< i1@51@06 V@27@06)
    (implies
      (<= 0 i2@52@06)
      (and
        (<= 0 i2@52@06)
        (implies
          (< i2@52@06 V@27@06)
          (and
            (< i2@52@06 V@27@06)
            (< i1@51@06 (alen<Int> (opt_get1 $Snap.unit G@24@06)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@48@06  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@51@06)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@51@06))
            (< i2@52@06 (alen<Int> (opt_get1 $Snap.unit G@24@06)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@48@06  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@24@06) i2@52@06)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@24@06) i2@52@06)))))))))
; Joined path conditions
(pop) ; 9
(push) ; 9
; [else-branch: 31 | !(0 <= i1@51@06)]
(assert (not (<= 0 i1@51@06)))
(pop) ; 9
(pop) ; 8
; Joined path conditions
(assert (implies
  (<= 0 i1@51@06)
  (and
    (<= 0 i1@51@06)
    (implies
      (< i1@51@06 V@27@06)
      (and
        (< i1@51@06 V@27@06)
        (implies
          (<= 0 i2@52@06)
          (and
            (<= 0 i2@52@06)
            (implies
              (< i2@52@06 V@27@06)
              (and
                (< i2@52@06 V@27@06)
                (< i1@51@06 (alen<Int> (opt_get1 $Snap.unit G@24@06)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@48@06  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@51@06)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@51@06))
                (< i2@52@06 (alen<Int> (opt_get1 $Snap.unit G@24@06)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@48@06  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@24@06) i2@52@06)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@24@06) i2@52@06)))))))))))
; Joined path conditions
(push) ; 8
; [then-branch: 35 | Lookup(option$array$,sm@48@06,aloc((_, _), opt_get1(_, G@24@06), i1@51@06)) == Lookup(option$array$,sm@48@06,aloc((_, _), opt_get1(_, G@24@06), i2@52@06)) && i2@52@06 < V@27@06 && 0 <= i2@52@06 && i1@51@06 < V@27@06 && 0 <= i1@51@06 | live]
; [else-branch: 35 | !(Lookup(option$array$,sm@48@06,aloc((_, _), opt_get1(_, G@24@06), i1@51@06)) == Lookup(option$array$,sm@48@06,aloc((_, _), opt_get1(_, G@24@06), i2@52@06)) && i2@52@06 < V@27@06 && 0 <= i2@52@06 && i1@51@06 < V@27@06 && 0 <= i1@51@06) | live]
(push) ; 9
; [then-branch: 35 | Lookup(option$array$,sm@48@06,aloc((_, _), opt_get1(_, G@24@06), i1@51@06)) == Lookup(option$array$,sm@48@06,aloc((_, _), opt_get1(_, G@24@06), i2@52@06)) && i2@52@06 < V@27@06 && 0 <= i2@52@06 && i1@51@06 < V@27@06 && 0 <= i1@51@06]
(assert (and
  (and
    (and
      (and
        (=
          ($FVF.lookup_option$array$ (as sm@48@06  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@51@06))
          ($FVF.lookup_option$array$ (as sm@48@06  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@24@06) i2@52@06)))
        (< i2@52@06 V@27@06))
      (<= 0 i2@52@06))
    (< i1@51@06 V@27@06))
  (<= 0 i1@51@06)))
; [eval] i1 == i2
(pop) ; 9
(push) ; 9
; [else-branch: 35 | !(Lookup(option$array$,sm@48@06,aloc((_, _), opt_get1(_, G@24@06), i1@51@06)) == Lookup(option$array$,sm@48@06,aloc((_, _), opt_get1(_, G@24@06), i2@52@06)) && i2@52@06 < V@27@06 && 0 <= i2@52@06 && i1@51@06 < V@27@06 && 0 <= i1@51@06)]
(assert (not
  (and
    (and
      (and
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@48@06  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@51@06))
            ($FVF.lookup_option$array$ (as sm@48@06  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@24@06) i2@52@06)))
          (< i2@52@06 V@27@06))
        (<= 0 i2@52@06))
      (< i1@51@06 V@27@06))
    (<= 0 i1@51@06))))
(pop) ; 9
(pop) ; 8
; Joined path conditions
(assert (implies
  (and
    (and
      (and
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@48@06  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@51@06))
            ($FVF.lookup_option$array$ (as sm@48@06  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@24@06) i2@52@06)))
          (< i2@52@06 V@27@06))
        (<= 0 i2@52@06))
      (< i1@51@06 V@27@06))
    (<= 0 i1@51@06))
  (and
    (=
      ($FVF.lookup_option$array$ (as sm@48@06  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@51@06))
      ($FVF.lookup_option$array$ (as sm@48@06  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@24@06) i2@52@06)))
    (< i2@52@06 V@27@06)
    (<= 0 i2@52@06)
    (< i1@51@06 V@27@06)
    (<= 0 i1@51@06))))
; Joined path conditions
(pop) ; 7
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i2@52@06 Int)) (!
  (and
    (implies
      (<= 0 i1@51@06)
      (and
        (<= 0 i1@51@06)
        (implies
          (< i1@51@06 V@27@06)
          (and
            (< i1@51@06 V@27@06)
            (implies
              (<= 0 i2@52@06)
              (and
                (<= 0 i2@52@06)
                (implies
                  (< i2@52@06 V@27@06)
                  (and
                    (< i2@52@06 V@27@06)
                    (< i1@51@06 (alen<Int> (opt_get1 $Snap.unit G@24@06)))
                    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@48@06  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@51@06)) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@51@06))
                    (< i2@52@06 (alen<Int> (opt_get1 $Snap.unit G@24@06)))
                    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@48@06  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit G@24@06) i2@52@06)) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit G@24@06) i2@52@06))))))))))
    (implies
      (and
        (and
          (and
            (and
              (=
                ($FVF.lookup_option$array$ (as sm@48@06  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@51@06))
                ($FVF.lookup_option$array$ (as sm@48@06  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@24@06) i2@52@06)))
              (< i2@52@06 V@27@06))
            (<= 0 i2@52@06))
          (< i1@51@06 V@27@06))
        (<= 0 i1@51@06))
      (and
        (=
          ($FVF.lookup_option$array$ (as sm@48@06  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@51@06))
          ($FVF.lookup_option$array$ (as sm@48@06  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@24@06) i2@52@06)))
        (< i2@52@06 V@27@06)
        (<= 0 i2@52@06)
        (< i1@51@06 V@27@06)
        (<= 0 i1@51@06))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i2@52@06))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 6
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@51@06 Int)) (!
  (forall ((i2@52@06 Int)) (!
    (and
      (implies
        (<= 0 i1@51@06)
        (and
          (<= 0 i1@51@06)
          (implies
            (< i1@51@06 V@27@06)
            (and
              (< i1@51@06 V@27@06)
              (implies
                (<= 0 i2@52@06)
                (and
                  (<= 0 i2@52@06)
                  (implies
                    (< i2@52@06 V@27@06)
                    (and
                      (< i2@52@06 V@27@06)
                      (< i1@51@06 (alen<Int> (opt_get1 $Snap.unit G@24@06)))
                      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@48@06  $FVF<option<array>>) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@51@06)) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@51@06))
                      (< i2@52@06 (alen<Int> (opt_get1 $Snap.unit G@24@06)))
                      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@48@06  $FVF<option<array>>) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit G@24@06) i2@52@06)) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit G@24@06) i2@52@06))))))))))
      (implies
        (and
          (and
            (and
              (and
                (=
                  ($FVF.lookup_option$array$ (as sm@48@06  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@51@06))
                  ($FVF.lookup_option$array$ (as sm@48@06  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit G@24@06) i2@52@06)))
                (< i2@52@06 V@27@06))
              (<= 0 i2@52@06))
            (< i1@51@06 V@27@06))
          (<= 0 i1@51@06))
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@48@06  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@51@06))
            ($FVF.lookup_option$array$ (as sm@48@06  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@24@06) i2@52@06)))
          (< i2@52@06 V@27@06)
          (<= 0 i2@52@06)
          (< i1@51@06 V@27@06)
          (<= 0 i1@51@06))))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i2@52@06))
    :qid |prog.l<no position>-aux|))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@51@06))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (implies
  (= exc@28@06 $Ref.null)
  (forall ((i1@51@06 Int)) (!
    (forall ((i2@52@06 Int)) (!
      (and
        (implies
          (<= 0 i1@51@06)
          (and
            (<= 0 i1@51@06)
            (implies
              (< i1@51@06 V@27@06)
              (and
                (< i1@51@06 V@27@06)
                (implies
                  (<= 0 i2@52@06)
                  (and
                    (<= 0 i2@52@06)
                    (implies
                      (< i2@52@06 V@27@06)
                      (and
                        (< i2@52@06 V@27@06)
                        (< i1@51@06 (alen<Int> (opt_get1 $Snap.unit G@24@06)))
                        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@48@06  $FVF<option<array>>) (aloc ($Snap.combine
                          $Snap.unit
                          $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@51@06)) (aloc ($Snap.combine
                          $Snap.unit
                          $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@51@06))
                        (< i2@52@06 (alen<Int> (opt_get1 $Snap.unit G@24@06)))
                        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@48@06  $FVF<option<array>>) (aloc ($Snap.combine
                          $Snap.unit
                          $Snap.unit) (opt_get1 $Snap.unit G@24@06) i2@52@06)) (aloc ($Snap.combine
                          $Snap.unit
                          $Snap.unit) (opt_get1 $Snap.unit G@24@06) i2@52@06))))))))))
        (implies
          (and
            (and
              (and
                (and
                  (=
                    ($FVF.lookup_option$array$ (as sm@48@06  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@51@06))
                    ($FVF.lookup_option$array$ (as sm@48@06  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit G@24@06) i2@52@06)))
                  (< i2@52@06 V@27@06))
                (<= 0 i2@52@06))
              (< i1@51@06 V@27@06))
            (<= 0 i1@51@06))
          (and
            (=
              ($FVF.lookup_option$array$ (as sm@48@06  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@51@06))
              ($FVF.lookup_option$array$ (as sm@48@06  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit G@24@06) i2@52@06)))
            (< i2@52@06 V@27@06)
            (<= 0 i2@52@06)
            (< i1@51@06 V@27@06)
            (<= 0 i1@51@06))))
      :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i2@52@06))
      :qid |prog.l<no position>-aux|))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@51@06))
    :qid |prog.l<no position>-aux|))))
(assert (implies
  (= exc@28@06 $Ref.null)
  (forall ((i1@51@06 Int)) (!
    (forall ((i2@52@06 Int)) (!
      (implies
        (and
          (and
            (and
              (and
                (=
                  ($FVF.lookup_option$array$ (as sm@48@06  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@51@06))
                  ($FVF.lookup_option$array$ (as sm@48@06  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit G@24@06) i2@52@06)))
                (< i2@52@06 V@27@06))
              (<= 0 i2@52@06))
            (< i1@51@06 V@27@06))
          (<= 0 i1@51@06))
        (= i1@51@06 i2@52@06))
      :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i2@52@06))
      :qid |prog.l<no position>|))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@51@06))
    :qid |prog.l<no position>|))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@44@06)))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@44@06))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@44@06)))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@44@06))))))))
  $Snap.unit))
; [eval] exc == null ==> 0 <= s
; [eval] exc == null
(push) ; 4
(set-option :timeout 10)
(push) ; 5
(assert (not (not (= exc@28@06 $Ref.null))))
(check-sat)
; unknown
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               478
;  :arith-add-rows          190
;  :arith-assert-diseq      6
;  :arith-assert-lower      90
;  :arith-assert-upper      49
;  :arith-bound-prop        28
;  :arith-conflicts         10
;  :arith-eq-adapter        38
;  :arith-fixed-eqs         27
;  :arith-offset-eqs        28
;  :arith-pivots            111
;  :conflicts               21
;  :datatype-accessor-ax    27
;  :datatype-constructor-ax 33
;  :datatype-occurs-check   33
;  :datatype-splits         19
;  :decisions               34
;  :del-clause              291
;  :final-checks            25
;  :max-generation          3
;  :max-memory              4.37
;  :memory                  4.36
;  :mk-bool-var             1054
;  :mk-clause               293
;  :num-allocs              146575
;  :num-checks              49
;  :propagations            81
;  :quant-instantiations    273
;  :rlimit-count            168341)
; [then-branch: 36 | exc@28@06 == Null | live]
; [else-branch: 36 | exc@28@06 != Null | dead]
(push) ; 5
; [then-branch: 36 | exc@28@06 == Null]
; [eval] 0 <= s
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (implies (= exc@28@06 $Ref.null) (<= 0 s@25@06)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@44@06))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@44@06)))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@44@06))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@44@06)))))))))
  $Snap.unit))
; [eval] exc == null ==> s < V
; [eval] exc == null
(push) ; 4
(push) ; 5
(assert (not (not (= exc@28@06 $Ref.null))))
(check-sat)
; unknown
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               503
;  :arith-add-rows          190
;  :arith-assert-diseq      6
;  :arith-assert-lower      90
;  :arith-assert-upper      49
;  :arith-bound-prop        28
;  :arith-conflicts         10
;  :arith-eq-adapter        38
;  :arith-fixed-eqs         27
;  :arith-offset-eqs        28
;  :arith-pivots            111
;  :conflicts               21
;  :datatype-accessor-ax    28
;  :datatype-constructor-ax 37
;  :datatype-occurs-check   36
;  :datatype-splits         21
;  :decisions               38
;  :del-clause              291
;  :final-checks            27
;  :max-generation          3
;  :max-memory              4.37
;  :memory                  4.36
;  :mk-bool-var             1058
;  :mk-clause               293
;  :num-allocs              147199
;  :num-checks              50
;  :propagations            81
;  :quant-instantiations    273
;  :rlimit-count            169054)
; [then-branch: 37 | exc@28@06 == Null | live]
; [else-branch: 37 | exc@28@06 != Null | dead]
(push) ; 5
; [then-branch: 37 | exc@28@06 == Null]
; [eval] s < V
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (implies (= exc@28@06 $Ref.null) (< s@25@06 V@27@06)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@44@06)))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@44@06))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@44@06)))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@44@06))))))))))
  $Snap.unit))
; [eval] exc == null ==> 0 <= t
; [eval] exc == null
(push) ; 4
(push) ; 5
(assert (not (not (= exc@28@06 $Ref.null))))
(check-sat)
; unknown
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               529
;  :arith-add-rows          190
;  :arith-assert-diseq      6
;  :arith-assert-lower      90
;  :arith-assert-upper      49
;  :arith-bound-prop        28
;  :arith-conflicts         10
;  :arith-eq-adapter        38
;  :arith-fixed-eqs         27
;  :arith-offset-eqs        28
;  :arith-pivots            111
;  :conflicts               21
;  :datatype-accessor-ax    29
;  :datatype-constructor-ax 41
;  :datatype-occurs-check   39
;  :datatype-splits         23
;  :decisions               42
;  :del-clause              291
;  :final-checks            29
;  :max-generation          3
;  :max-memory              4.37
;  :memory                  4.36
;  :mk-bool-var             1062
;  :mk-clause               293
;  :num-allocs              147828
;  :num-checks              51
;  :propagations            81
;  :quant-instantiations    273
;  :rlimit-count            169785)
; [then-branch: 38 | exc@28@06 == Null | live]
; [else-branch: 38 | exc@28@06 != Null | dead]
(push) ; 5
; [then-branch: 38 | exc@28@06 == Null]
; [eval] 0 <= t
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (implies (= exc@28@06 $Ref.null) (<= 0 t@26@06)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@44@06))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@44@06)))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@44@06))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@44@06)))))))))))
  $Snap.unit))
; [eval] exc == null ==> t < V
; [eval] exc == null
(push) ; 4
(push) ; 5
(assert (not (not (= exc@28@06 $Ref.null))))
(check-sat)
; unknown
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               556
;  :arith-add-rows          190
;  :arith-assert-diseq      6
;  :arith-assert-lower      90
;  :arith-assert-upper      49
;  :arith-bound-prop        28
;  :arith-conflicts         10
;  :arith-eq-adapter        38
;  :arith-fixed-eqs         27
;  :arith-offset-eqs        28
;  :arith-pivots            111
;  :conflicts               21
;  :datatype-accessor-ax    30
;  :datatype-constructor-ax 45
;  :datatype-occurs-check   44
;  :datatype-splits         25
;  :decisions               46
;  :del-clause              291
;  :final-checks            31
;  :max-generation          3
;  :max-memory              4.37
;  :memory                  4.36
;  :mk-bool-var             1066
;  :mk-clause               293
;  :num-allocs              148456
;  :num-checks              52
;  :propagations            81
;  :quant-instantiations    273
;  :rlimit-count            170524)
; [then-branch: 39 | exc@28@06 == Null | live]
; [else-branch: 39 | exc@28@06 != Null | dead]
(push) ; 5
; [then-branch: 39 | exc@28@06 == Null]
; [eval] t < V
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (implies (= exc@28@06 $Ref.null) (< t@26@06 V@27@06)))
; [eval] exc == null
(push) ; 4
(assert (not (not (= exc@28@06 $Ref.null))))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               577
;  :arith-add-rows          190
;  :arith-assert-diseq      6
;  :arith-assert-lower      90
;  :arith-assert-upper      49
;  :arith-bound-prop        28
;  :arith-conflicts         10
;  :arith-eq-adapter        38
;  :arith-fixed-eqs         27
;  :arith-offset-eqs        28
;  :arith-pivots            111
;  :conflicts               21
;  :datatype-accessor-ax    30
;  :datatype-constructor-ax 49
;  :datatype-occurs-check   49
;  :datatype-splits         27
;  :decisions               50
;  :del-clause              291
;  :final-checks            33
;  :max-generation          3
;  :max-memory              4.37
;  :memory                  4.36
;  :mk-bool-var             1068
;  :mk-clause               293
;  :num-allocs              149020
;  :num-checks              53
;  :propagations            81
;  :quant-instantiations    273
;  :rlimit-count            171043)
; [then-branch: 40 | exc@28@06 == Null | live]
; [else-branch: 40 | exc@28@06 != Null | dead]
(push) ; 4
; [then-branch: 40 | exc@28@06 == Null]
(declare-const i1@53@06 Int)
(declare-const j1@54@06 Int)
(push) ; 5
; [eval] 0 <= i1 && i1 < V && (0 <= j1 && j1 < V)
; [eval] 0 <= i1
(push) ; 6
; [then-branch: 41 | 0 <= i1@53@06 | live]
; [else-branch: 41 | !(0 <= i1@53@06) | live]
(push) ; 7
; [then-branch: 41 | 0 <= i1@53@06]
(assert (<= 0 i1@53@06))
; [eval] i1 < V
(push) ; 8
; [then-branch: 42 | i1@53@06 < V@27@06 | live]
; [else-branch: 42 | !(i1@53@06 < V@27@06) | live]
(push) ; 9
; [then-branch: 42 | i1@53@06 < V@27@06]
(assert (< i1@53@06 V@27@06))
; [eval] 0 <= j1
(push) ; 10
; [then-branch: 43 | 0 <= j1@54@06 | live]
; [else-branch: 43 | !(0 <= j1@54@06) | live]
(push) ; 11
; [then-branch: 43 | 0 <= j1@54@06]
(assert (<= 0 j1@54@06))
; [eval] j1 < V
(pop) ; 11
(push) ; 11
; [else-branch: 43 | !(0 <= j1@54@06)]
(assert (not (<= 0 j1@54@06)))
(pop) ; 11
(pop) ; 10
; Joined path conditions
; Joined path conditions
(pop) ; 9
(push) ; 9
; [else-branch: 42 | !(i1@53@06 < V@27@06)]
(assert (not (< i1@53@06 V@27@06)))
(pop) ; 9
(pop) ; 8
; Joined path conditions
; Joined path conditions
(pop) ; 7
(push) ; 7
; [else-branch: 41 | !(0 <= i1@53@06)]
(assert (not (<= 0 i1@53@06)))
(pop) ; 7
(pop) ; 6
; Joined path conditions
; Joined path conditions
(assert (and
  (and (and (< j1@54@06 V@27@06) (<= 0 j1@54@06)) (< i1@53@06 V@27@06))
  (<= 0 i1@53@06)))
; [eval] aloc(opt_get1(aloc(opt_get1(G), i1).option$array$), j1)
; [eval] opt_get1(aloc(opt_get1(G), i1).option$array$)
; [eval] aloc(opt_get1(G), i1)
; [eval] opt_get1(G)
(push) ; 6
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 6
; Joined path conditions
(push) ; 6
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 7
(assert (not (< i1@53@06 (alen<Int> (opt_get1 $Snap.unit G@24@06)))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               577
;  :arith-add-rows          193
;  :arith-assert-diseq      6
;  :arith-assert-lower      96
;  :arith-assert-upper      49
;  :arith-bound-prop        28
;  :arith-conflicts         10
;  :arith-eq-adapter        38
;  :arith-fixed-eqs         27
;  :arith-offset-eqs        28
;  :arith-pivots            113
;  :conflicts               21
;  :datatype-accessor-ax    30
;  :datatype-constructor-ax 49
;  :datatype-occurs-check   49
;  :datatype-splits         27
;  :decisions               50
;  :del-clause              291
;  :final-checks            33
;  :max-generation          3
;  :max-memory              4.37
;  :memory                  4.36
;  :mk-bool-var             1074
;  :mk-clause               293
;  :num-allocs              149292
;  :num-checks              54
;  :propagations            81
;  :quant-instantiations    273
;  :rlimit-count            171528)
(assert (< i1@53@06 (alen<Int> (opt_get1 $Snap.unit G@24@06))))
(pop) ; 6
; Joined path conditions
(assert (< i1@53@06 (alen<Int> (opt_get1 $Snap.unit G@24@06))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@48@06  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@53@06)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@53@06)))
(push) ; 6
(assert (not (ite
  (and
    (<
      (inv@47@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@53@06))
      V@27@06)
    (<=
      0
      (inv@47@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@53@06))))
  (< $Perm.No $k@46@06)
  false)))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               587
;  :arith-add-rows          203
;  :arith-assert-diseq      6
;  :arith-assert-lower      98
;  :arith-assert-upper      52
;  :arith-bound-prop        30
;  :arith-conflicts         11
;  :arith-eq-adapter        40
;  :arith-fixed-eqs         29
;  :arith-offset-eqs        28
;  :arith-pivots            116
;  :conflicts               22
;  :datatype-accessor-ax    30
;  :datatype-constructor-ax 49
;  :datatype-occurs-check   49
;  :datatype-splits         27
;  :decisions               50
;  :del-clause              291
;  :final-checks            33
;  :max-generation          3
;  :max-memory              4.38
;  :memory                  4.36
;  :mk-bool-var             1134
;  :mk-clause               313
;  :num-allocs              149789
;  :num-checks              55
;  :propagations            82
;  :quant-instantiations    301
;  :rlimit-count            173260)
(push) ; 6
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 7
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@48@06  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@53@06))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               587
;  :arith-add-rows          203
;  :arith-assert-diseq      6
;  :arith-assert-lower      98
;  :arith-assert-upper      52
;  :arith-bound-prop        30
;  :arith-conflicts         11
;  :arith-eq-adapter        40
;  :arith-fixed-eqs         29
;  :arith-offset-eqs        28
;  :arith-pivots            116
;  :conflicts               23
;  :datatype-accessor-ax    30
;  :datatype-constructor-ax 49
;  :datatype-occurs-check   49
;  :datatype-splits         27
;  :decisions               50
;  :del-clause              291
;  :final-checks            33
;  :max-generation          3
;  :max-memory              4.38
;  :memory                  4.36
;  :mk-bool-var             1134
;  :mk-clause               313
;  :num-allocs              149877
;  :num-checks              56
;  :propagations            82
;  :quant-instantiations    301
;  :rlimit-count            173355)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@48@06  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@53@06))
    (as None<option<array>>  option<array>))))
(pop) ; 6
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@48@06  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@53@06))
    (as None<option<array>>  option<array>))))
(push) ; 6
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 7
(assert (not (<
  j1@54@06
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@48@06  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@53@06)))))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               593
;  :arith-add-rows          209
;  :arith-assert-diseq      6
;  :arith-assert-lower      101
;  :arith-assert-upper      53
;  :arith-bound-prop        30
;  :arith-conflicts         12
;  :arith-eq-adapter        41
;  :arith-fixed-eqs         30
;  :arith-offset-eqs        28
;  :arith-pivots            120
;  :conflicts               24
;  :datatype-accessor-ax    30
;  :datatype-constructor-ax 49
;  :datatype-occurs-check   49
;  :datatype-splits         27
;  :decisions               50
;  :del-clause              295
;  :final-checks            33
;  :max-generation          3
;  :max-memory              4.38
;  :memory                  4.37
;  :mk-bool-var             1145
;  :mk-clause               317
;  :num-allocs              150069
;  :num-checks              57
;  :propagations            84
;  :quant-instantiations    308
;  :rlimit-count            173862)
(assert (<
  j1@54@06
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@48@06  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@53@06))))))
(pop) ; 6
; Joined path conditions
(assert (<
  j1@54@06
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@48@06  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@53@06))))))
(pop) ; 5
(declare-fun inv@55@06 ($Ref) Int)
(declare-fun inv@56@06 ($Ref) Int)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(assert (forall ((i1@53@06 Int) (j1@54@06 Int)) (!
  (and
    (< i1@53@06 (alen<Int> (opt_get1 $Snap.unit G@24@06)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@48@06  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@53@06)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@53@06))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@48@06  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@53@06))
        (as None<option<array>>  option<array>)))
    (<
      j1@54@06
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@48@06  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@53@06))))))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@48@06  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@53@06))) j1@54@06))
  :qid |int-aux|)))
; Check receiver injectivity
(push) ; 5
(assert (not (forall ((i11@53@06 Int) (j11@54@06 Int) (i12@53@06 Int) (j12@54@06 Int)) (!
  (implies
    (and
      (and
        (and (and (< j11@54@06 V@27@06) (<= 0 j11@54@06)) (< i11@53@06 V@27@06))
        (<= 0 i11@53@06))
      (and
        (and (and (< j12@54@06 V@27@06) (<= 0 j12@54@06)) (< i12@53@06 V@27@06))
        (<= 0 i12@53@06))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@48@06  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@24@06) i11@53@06))) j11@54@06)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@48@06  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@24@06) i12@53@06))) j12@54@06)))
    (and (= i11@53@06 i12@53@06) (= j11@54@06 j12@54@06)))
  
  :qid |int-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               643
;  :arith-add-rows          240
;  :arith-assert-diseq      6
;  :arith-assert-lower      113
;  :arith-assert-upper      57
;  :arith-bound-prop        34
;  :arith-conflicts         12
;  :arith-eq-adapter        49
;  :arith-fixed-eqs         32
;  :arith-offset-eqs        34
;  :arith-pivots            135
;  :conflicts               25
;  :datatype-accessor-ax    30
;  :datatype-constructor-ax 49
;  :datatype-occurs-check   49
;  :datatype-splits         27
;  :decisions               50
;  :del-clause              386
;  :final-checks            33
;  :max-generation          3
;  :max-memory              4.48
;  :memory                  4.47
;  :mk-bool-var             1331
;  :mk-clause               388
;  :num-allocs              151493
;  :num-checks              58
;  :propagations            116
;  :quant-instantiations    390
;  :rlimit-count            178835
;  :time                    0.00)
; Definitional axioms for inverse functions
(assert (forall ((i1@53@06 Int) (j1@54@06 Int)) (!
  (implies
    (and
      (and (and (< j1@54@06 V@27@06) (<= 0 j1@54@06)) (< i1@53@06 V@27@06))
      (<= 0 i1@53@06))
    (and
      (=
        (inv@55@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@48@06  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@53@06))) j1@54@06))
        i1@53@06)
      (=
        (inv@56@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@48@06  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@53@06))) j1@54@06))
        j1@54@06)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@48@06  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@53@06))) j1@54@06))
  )))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@56@06 r) V@27@06) (<= 0 (inv@56@06 r)))
        (< (inv@55@06 r) V@27@06))
      (<= 0 (inv@55@06 r)))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@48@06  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@24@06) (inv@55@06 r)))) (inv@56@06 r))
      r))
  :pattern ((inv@55@06 r))
  :pattern ((inv@56@06 r))
  :qid |int-fctOfInv|)))
; Permissions are non-negative
; Field permissions are at most one
; Permission implies non-null receiver
(assert (forall ((i1@53@06 Int) (j1@54@06 Int)) (!
  (implies
    (and
      (and (and (< j1@54@06 V@27@06) (<= 0 j1@54@06)) (< i1@53@06 V@27@06))
      (<= 0 i1@53@06))
    (not
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@48@06  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@53@06))) j1@54@06)
        $Ref.null)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@48@06  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@53@06))) j1@54@06))
  :qid |int-permImpliesNonNull|)))
(declare-const sm@57@06 $FVF<Int>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@56@06 r) V@27@06) (<= 0 (inv@56@06 r)))
        (< (inv@55@06 r) V@27@06))
      (<= 0 (inv@55@06 r)))
    (=
      ($FVF.lookup_int (as sm@57@06  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@44@06)))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@57@06  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@44@06)))))))))))) r))
  :qid |qp.fvfValDef9|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@44@06)))))))))))) r) r)
  :pattern (($FVF.lookup_int (as sm@57@06  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef10|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@56@06 r) V@27@06) (<= 0 (inv@56@06 r)))
        (< (inv@55@06 r) V@27@06))
      (<= 0 (inv@55@06 r)))
    ($FVF.loc_int ($FVF.lookup_int (as sm@57@06  $FVF<Int>) r) r))
  :pattern ((inv@55@06 r) (inv@56@06 r))
  )))
(pop) ; 4
(pop) ; 3
(pop) ; 2
(push) ; 2
; [exec]
; var return: Int
(declare-const return@58@06 Int)
; [exec]
; var Gf: option[array]
(declare-const Gf@59@06 option<array>)
; [exec]
; var p: option[array]
(declare-const p@60@06 option<array>)
; [exec]
; var res1: option[array]
(declare-const res1@61@06 option<array>)
; [exec]
; var res2: void
(declare-const res2@62@06 void)
; [exec]
; var res3: option[array]
(declare-const res3@63@06 option<array>)
; [exec]
; var res4: void
(declare-const res4@64@06 void)
; [exec]
; var evaluationDummy: void
(declare-const evaluationDummy@65@06 void)
; [exec]
; var evaluationDummy1: void
(declare-const evaluationDummy1@66@06 void)
; [exec]
; exc := null
; [exec]
; exc, res1 := make_array(tid, V, V)
(declare-const exc@67@06 $Ref)
(declare-const res@68@06 option<array>)
(declare-const $t@69@06 $Snap)
(assert (= $t@69@06 ($Snap.combine ($Snap.first $t@69@06) ($Snap.second $t@69@06))))
(assert (= ($Snap.first $t@69@06) $Snap.unit))
; [eval] exc == null
(assert (= exc@67@06 $Ref.null))
(assert (=
  ($Snap.second $t@69@06)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@69@06))
    ($Snap.second ($Snap.second $t@69@06)))))
(assert (= ($Snap.first ($Snap.second $t@69@06)) $Snap.unit))
; [eval] exc == null ==> res != (None(): option[array])
; [eval] exc == null
(push) ; 3
(set-option :timeout 10)
(push) ; 4
(assert (not (not (= exc@67@06 $Ref.null))))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               665
;  :arith-add-rows          240
;  :arith-assert-diseq      6
;  :arith-assert-lower      113
;  :arith-assert-upper      57
;  :arith-bound-prop        34
;  :arith-conflicts         12
;  :arith-eq-adapter        49
;  :arith-fixed-eqs         32
;  :arith-offset-eqs        34
;  :arith-pivots            135
;  :conflicts               25
;  :datatype-accessor-ax    32
;  :datatype-constructor-ax 52
;  :datatype-occurs-check   52
;  :datatype-splits         28
;  :decisions               53
;  :del-clause              388
;  :final-checks            35
;  :max-generation          3
;  :max-memory              4.48
;  :memory                  4.47
;  :mk-bool-var             1337
;  :mk-clause               388
;  :num-allocs              152367
;  :num-checks              59
;  :propagations            116
;  :quant-instantiations    390
;  :rlimit-count            179841)
; [then-branch: 44 | exc@67@06 == Null | live]
; [else-branch: 44 | exc@67@06 != Null | dead]
(push) ; 4
; [then-branch: 44 | exc@67@06 == Null]
; [eval] res != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 4
(pop) ; 3
; Joined path conditions
(assert (implies
  (= exc@67@06 $Ref.null)
  (not (= res@68@06 (as None<option<array>>  option<array>)))))
(assert (=
  ($Snap.second ($Snap.second $t@69@06))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second $t@69@06)))
    ($Snap.second ($Snap.second ($Snap.second $t@69@06))))))
(assert (= ($Snap.first ($Snap.second ($Snap.second $t@69@06))) $Snap.unit))
; [eval] exc == null ==> alen(opt_get1(res)) == dim0
; [eval] exc == null
(push) ; 3
(push) ; 4
(assert (not (not (= exc@67@06 $Ref.null))))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               681
;  :arith-add-rows          240
;  :arith-assert-diseq      6
;  :arith-assert-lower      113
;  :arith-assert-upper      57
;  :arith-bound-prop        34
;  :arith-conflicts         12
;  :arith-eq-adapter        49
;  :arith-fixed-eqs         32
;  :arith-offset-eqs        34
;  :arith-pivots            135
;  :conflicts               25
;  :datatype-accessor-ax    33
;  :datatype-constructor-ax 55
;  :datatype-occurs-check   55
;  :datatype-splits         29
;  :decisions               56
;  :del-clause              388
;  :final-checks            37
;  :max-generation          3
;  :max-memory              4.50
;  :memory                  4.49
;  :mk-bool-var             1341
;  :mk-clause               388
;  :num-allocs              152972
;  :num-checks              60
;  :propagations            116
;  :quant-instantiations    390
;  :rlimit-count            180491)
; [then-branch: 45 | exc@67@06 == Null | live]
; [else-branch: 45 | exc@67@06 != Null | dead]
(push) ; 4
; [then-branch: 45 | exc@67@06 == Null]
; [eval] alen(opt_get1(res)) == dim0
; [eval] alen(opt_get1(res))
; [eval] opt_get1(res)
(push) ; 5
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(set-option :timeout 0)
(push) ; 6
(assert (not (not (= res@68@06 (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               681
;  :arith-add-rows          240
;  :arith-assert-diseq      6
;  :arith-assert-lower      113
;  :arith-assert-upper      57
;  :arith-bound-prop        34
;  :arith-conflicts         12
;  :arith-eq-adapter        49
;  :arith-fixed-eqs         32
;  :arith-offset-eqs        34
;  :arith-pivots            135
;  :conflicts               25
;  :datatype-accessor-ax    33
;  :datatype-constructor-ax 55
;  :datatype-occurs-check   55
;  :datatype-splits         29
;  :decisions               56
;  :del-clause              388
;  :final-checks            37
;  :max-generation          3
;  :max-memory              4.50
;  :memory                  4.49
;  :mk-bool-var             1341
;  :mk-clause               388
;  :num-allocs              152995
;  :num-checks              61
;  :propagations            116
;  :quant-instantiations    390
;  :rlimit-count            180512)
(assert (not (= res@68@06 (as None<option<array>>  option<array>))))
(pop) ; 5
; Joined path conditions
(assert (not (= res@68@06 (as None<option<array>>  option<array>))))
(pop) ; 4
(pop) ; 3
; Joined path conditions
(assert (implies
  (= exc@67@06 $Ref.null)
  (= (alen<Int> (opt_get1 $Snap.unit res@68@06)) V@27@06)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second $t@69@06)))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@69@06))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@06)))))))
; [eval] exc == null
(set-option :timeout 10)
(push) ; 3
(assert (not (not (= exc@67@06 $Ref.null))))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               705
;  :arith-add-rows          241
;  :arith-assert-diseq      6
;  :arith-assert-lower      115
;  :arith-assert-upper      58
;  :arith-bound-prop        34
;  :arith-conflicts         12
;  :arith-eq-adapter        50
;  :arith-fixed-eqs         33
;  :arith-offset-eqs        34
;  :arith-pivots            136
;  :conflicts               25
;  :datatype-accessor-ax    34
;  :datatype-constructor-ax 59
;  :datatype-occurs-check   58
;  :datatype-splits         31
;  :decisions               60
;  :del-clause              388
;  :final-checks            39
;  :max-generation          3
;  :max-memory              4.50
;  :memory                  4.49
;  :mk-bool-var             1353
;  :mk-clause               388
;  :num-allocs              153654
;  :num-checks              62
;  :propagations            116
;  :quant-instantiations    395
;  :rlimit-count            181273)
; [then-branch: 46 | exc@67@06 == Null | live]
; [else-branch: 46 | exc@67@06 != Null | dead]
(push) ; 3
; [then-branch: 46 | exc@67@06 == Null]
(declare-const i0@70@06 Int)
(push) ; 4
; [eval] 0 <= i0 && i0 < dim0
; [eval] 0 <= i0
(push) ; 5
; [then-branch: 47 | 0 <= i0@70@06 | live]
; [else-branch: 47 | !(0 <= i0@70@06) | live]
(push) ; 6
; [then-branch: 47 | 0 <= i0@70@06]
(assert (<= 0 i0@70@06))
; [eval] i0 < dim0
(pop) ; 6
(push) ; 6
; [else-branch: 47 | !(0 <= i0@70@06)]
(assert (not (<= 0 i0@70@06)))
(pop) ; 6
(pop) ; 5
; Joined path conditions
; Joined path conditions
(assert (and (< i0@70@06 V@27@06) (<= 0 i0@70@06)))
; [eval] aloc(opt_get1(res), i0)
; [eval] opt_get1(res)
(push) ; 5
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(set-option :timeout 0)
(push) ; 6
(assert (not (not (= res@68@06 (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               705
;  :arith-add-rows          242
;  :arith-assert-diseq      6
;  :arith-assert-lower      117
;  :arith-assert-upper      58
;  :arith-bound-prop        34
;  :arith-conflicts         12
;  :arith-eq-adapter        50
;  :arith-fixed-eqs         33
;  :arith-offset-eqs        34
;  :arith-pivots            137
;  :conflicts               25
;  :datatype-accessor-ax    34
;  :datatype-constructor-ax 59
;  :datatype-occurs-check   58
;  :datatype-splits         31
;  :decisions               60
;  :del-clause              388
;  :final-checks            39
;  :max-generation          3
;  :max-memory              4.50
;  :memory                  4.49
;  :mk-bool-var             1355
;  :mk-clause               388
;  :num-allocs              153752
;  :num-checks              63
;  :propagations            116
;  :quant-instantiations    395
;  :rlimit-count            181450)
(assert (not (= res@68@06 (as None<option<array>>  option<array>))))
(pop) ; 5
; Joined path conditions
(assert (not (= res@68@06 (as None<option<array>>  option<array>))))
(push) ; 5
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 6
(assert (not (< i0@70@06 (alen<Int> (opt_get1 $Snap.unit res@68@06)))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               705
;  :arith-add-rows          242
;  :arith-assert-diseq      6
;  :arith-assert-lower      117
;  :arith-assert-upper      58
;  :arith-bound-prop        34
;  :arith-conflicts         12
;  :arith-eq-adapter        50
;  :arith-fixed-eqs         33
;  :arith-offset-eqs        34
;  :arith-pivots            137
;  :conflicts               25
;  :datatype-accessor-ax    34
;  :datatype-constructor-ax 59
;  :datatype-occurs-check   58
;  :datatype-splits         31
;  :decisions               60
;  :del-clause              388
;  :final-checks            39
;  :max-generation          3
;  :max-memory              4.50
;  :memory                  4.49
;  :mk-bool-var             1355
;  :mk-clause               388
;  :num-allocs              153771
;  :num-checks              64
;  :propagations            116
;  :quant-instantiations    395
;  :rlimit-count            181481)
(assert (< i0@70@06 (alen<Int> (opt_get1 $Snap.unit res@68@06))))
(pop) ; 5
; Joined path conditions
(assert (< i0@70@06 (alen<Int> (opt_get1 $Snap.unit res@68@06))))
; Definitional axioms for snapshot map values
; [eval] aloc(opt_get1(res), i0)
; [eval] opt_get1(res)
(push) ; 5
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 5
; Joined path conditions
(push) ; 5
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(pop) ; 5
; Joined path conditions
(pop) ; 4
(declare-fun inv@71@06 ($Ref) Int)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(assert (forall ((i0@70@06 Int)) (!
  (and
    (not (= res@68@06 (as None<option<array>>  option<array>)))
    (< i0@70@06 (alen<Int> (opt_get1 $Snap.unit res@68@06))))
  :pattern (($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@69@06))))) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit res@68@06) i0@70@06)) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit res@68@06) i0@70@06)))
  :qid |option$array$-aux|)))
; Check receiver injectivity
(push) ; 4
(assert (not (forall ((i01@70@06 Int) (i02@70@06 Int)) (!
  (implies
    (and
      (and (< i01@70@06 V@27@06) (<= 0 i01@70@06))
      (and (< i02@70@06 V@27@06) (<= 0 i02@70@06))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@68@06) i01@70@06)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@68@06) i02@70@06)))
    (= i01@70@06 i02@70@06))
  
  :qid |option$array$-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               736
;  :arith-add-rows          279
;  :arith-assert-diseq      8
;  :arith-assert-lower      123
;  :arith-assert-upper      60
;  :arith-bound-prop        37
;  :arith-conflicts         12
;  :arith-eq-adapter        51
;  :arith-fixed-eqs         33
;  :arith-offset-eqs        34
;  :arith-pivots            145
;  :conflicts               29
;  :datatype-accessor-ax    34
;  :datatype-constructor-ax 61
;  :datatype-occurs-check   58
;  :datatype-splits         31
;  :decisions               63
;  :del-clause              405
;  :final-checks            39
;  :max-generation          3
;  :max-memory              4.50
;  :memory                  4.49
;  :mk-bool-var             1379
;  :mk-clause               405
;  :num-allocs              154351
;  :num-checks              65
;  :propagations            140
;  :quant-instantiations    403
;  :rlimit-count            183239)
; Definitional axioms for inverse functions
(assert (forall ((i0@70@06 Int)) (!
  (implies
    (and (< i0@70@06 V@27@06) (<= 0 i0@70@06))
    (=
      (inv@71@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@68@06) i0@70@06))
      i0@70@06))
  :pattern (($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@69@06))))) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit res@68@06) i0@70@06)) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit res@68@06) i0@70@06)))
  )))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@71@06 r) V@27@06) (<= 0 (inv@71@06 r)))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@68@06) (inv@71@06 r))
      r))
  :pattern ((inv@71@06 r))
  :qid |option$array$-fctOfInv|)))
; Permissions are non-negative
; Field permissions are at most one
; Permission implies non-null receiver
(assert (forall ((i0@70@06 Int)) (!
  (implies
    (and (< i0@70@06 V@27@06) (<= 0 i0@70@06))
    (not
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@68@06) i0@70@06)
        $Ref.null)))
  :pattern (($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@69@06))))) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit res@68@06) i0@70@06)) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit res@68@06) i0@70@06)))
  :qid |option$array$-permImpliesNonNull|)))
(declare-const sm@72@06 $FVF<option<array>>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@71@06 r) V@27@06) (<= 0 (inv@71@06 r)))
    (=
      ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@69@06))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@69@06))))) r))
  :qid |qp.fvfValDef11|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@33@06 r) V@27@06) (<= 0 (inv@33@06 r)))
      (< $Perm.No $k@32@06)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@30@06))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@30@06))))) r))
  :qid |qp.fvfValDef12|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@69@06))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@30@06))))) r) r))
  :pattern (($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef13|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@71@06 r) V@27@06) (<= 0 (inv@71@06 r)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) r) r))
  :pattern ((inv@71@06 r))
  )))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@06))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@06)))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@06))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@06)))))
  $Snap.unit))
; [eval] exc == null ==> (forall i0: Int :: { aloc(opt_get1(res), i0).option$array$ } 0 <= i0 && i0 < dim0 ==> aloc(opt_get1(res), i0).option$array$ != (None(): option[array]))
; [eval] exc == null
(push) ; 4
(set-option :timeout 10)
(push) ; 5
(assert (not (not (= exc@67@06 $Ref.null))))
(check-sat)
; unknown
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               757
;  :arith-add-rows          279
;  :arith-assert-diseq      8
;  :arith-assert-lower      123
;  :arith-assert-upper      60
;  :arith-bound-prop        37
;  :arith-conflicts         12
;  :arith-eq-adapter        51
;  :arith-fixed-eqs         33
;  :arith-offset-eqs        34
;  :arith-pivots            145
;  :conflicts               29
;  :datatype-accessor-ax    35
;  :datatype-constructor-ax 65
;  :datatype-occurs-check   61
;  :datatype-splits         33
;  :decisions               67
;  :del-clause              405
;  :final-checks            41
;  :max-generation          3
;  :max-memory              4.50
;  :memory                  4.49
;  :mk-bool-var             1390
;  :mk-clause               405
;  :num-allocs              156033
;  :num-checks              66
;  :propagations            140
;  :quant-instantiations    403
;  :rlimit-count            186539)
; [then-branch: 48 | exc@67@06 == Null | live]
; [else-branch: 48 | exc@67@06 != Null | dead]
(push) ; 5
; [then-branch: 48 | exc@67@06 == Null]
; [eval] (forall i0: Int :: { aloc(opt_get1(res), i0).option$array$ } 0 <= i0 && i0 < dim0 ==> aloc(opt_get1(res), i0).option$array$ != (None(): option[array]))
(declare-const i0@73@06 Int)
(push) ; 6
; [eval] 0 <= i0 && i0 < dim0 ==> aloc(opt_get1(res), i0).option$array$ != (None(): option[array])
; [eval] 0 <= i0 && i0 < dim0
; [eval] 0 <= i0
(push) ; 7
; [then-branch: 49 | 0 <= i0@73@06 | live]
; [else-branch: 49 | !(0 <= i0@73@06) | live]
(push) ; 8
; [then-branch: 49 | 0 <= i0@73@06]
(assert (<= 0 i0@73@06))
; [eval] i0 < dim0
(pop) ; 8
(push) ; 8
; [else-branch: 49 | !(0 <= i0@73@06)]
(assert (not (<= 0 i0@73@06)))
(pop) ; 8
(pop) ; 7
; Joined path conditions
; Joined path conditions
(push) ; 7
; [then-branch: 50 | i0@73@06 < V@27@06 && 0 <= i0@73@06 | live]
; [else-branch: 50 | !(i0@73@06 < V@27@06 && 0 <= i0@73@06) | live]
(push) ; 8
; [then-branch: 50 | i0@73@06 < V@27@06 && 0 <= i0@73@06]
(assert (and (< i0@73@06 V@27@06) (<= 0 i0@73@06)))
; [eval] aloc(opt_get1(res), i0).option$array$ != (None(): option[array])
; [eval] aloc(opt_get1(res), i0)
; [eval] opt_get1(res)
(push) ; 9
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(set-option :timeout 0)
(push) ; 10
(assert (not (not (= res@68@06 (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               757
;  :arith-add-rows          280
;  :arith-assert-diseq      8
;  :arith-assert-lower      125
;  :arith-assert-upper      60
;  :arith-bound-prop        37
;  :arith-conflicts         12
;  :arith-eq-adapter        51
;  :arith-fixed-eqs         33
;  :arith-offset-eqs        34
;  :arith-pivots            145
;  :conflicts               29
;  :datatype-accessor-ax    35
;  :datatype-constructor-ax 65
;  :datatype-occurs-check   61
;  :datatype-splits         33
;  :decisions               67
;  :del-clause              405
;  :final-checks            41
;  :max-generation          3
;  :max-memory              4.50
;  :memory                  4.49
;  :mk-bool-var             1392
;  :mk-clause               405
;  :num-allocs              156131
;  :num-checks              67
;  :propagations            140
;  :quant-instantiations    403
;  :rlimit-count            186721)
(assert (not (= res@68@06 (as None<option<array>>  option<array>))))
(pop) ; 9
; Joined path conditions
(assert (not (= res@68@06 (as None<option<array>>  option<array>))))
(push) ; 9
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 10
(assert (not (< i0@73@06 (alen<Int> (opt_get1 $Snap.unit res@68@06)))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               757
;  :arith-add-rows          280
;  :arith-assert-diseq      8
;  :arith-assert-lower      125
;  :arith-assert-upper      60
;  :arith-bound-prop        37
;  :arith-conflicts         12
;  :arith-eq-adapter        51
;  :arith-fixed-eqs         33
;  :arith-offset-eqs        34
;  :arith-pivots            145
;  :conflicts               29
;  :datatype-accessor-ax    35
;  :datatype-constructor-ax 65
;  :datatype-occurs-check   61
;  :datatype-splits         33
;  :decisions               67
;  :del-clause              405
;  :final-checks            41
;  :max-generation          3
;  :max-memory              4.50
;  :memory                  4.49
;  :mk-bool-var             1392
;  :mk-clause               405
;  :num-allocs              156150
;  :num-checks              68
;  :propagations            140
;  :quant-instantiations    403
;  :rlimit-count            186752)
(assert (< i0@73@06 (alen<Int> (opt_get1 $Snap.unit res@68@06))))
(pop) ; 9
; Joined path conditions
(assert (< i0@73@06 (alen<Int> (opt_get1 $Snap.unit res@68@06))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit res@68@06) i0@73@06)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit res@68@06) i0@73@06)))
(push) ; 9
(assert (not (<
  $Perm.No
  (+
    (ite
      (and
        (<
          (inv@71@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@68@06) i0@73@06))
          V@27@06)
        (<=
          0
          (inv@71@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@68@06) i0@73@06))))
      $Perm.Write
      $Perm.No)
    (ite
      (and
        (<
          (inv@33@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@68@06) i0@73@06))
          V@27@06)
        (<=
          0
          (inv@33@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@68@06) i0@73@06))))
      $k@32@06
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               798
;  :arith-add-rows          289
;  :arith-assert-diseq      10
;  :arith-assert-lower      133
;  :arith-assert-upper      69
;  :arith-bound-prop        40
;  :arith-conflicts         15
;  :arith-eq-adapter        60
;  :arith-fixed-eqs         35
;  :arith-offset-eqs        35
;  :arith-pivots            149
;  :conflicts               36
;  :datatype-accessor-ax    35
;  :datatype-constructor-ax 67
;  :datatype-occurs-check   61
;  :datatype-splits         33
;  :decisions               73
;  :del-clause              427
;  :final-checks            41
;  :max-generation          3
;  :max-memory              4.53
;  :memory                  4.52
;  :mk-bool-var             1460
;  :mk-clause               451
;  :num-allocs              156627
;  :num-checks              69
;  :propagations            172
;  :quant-instantiations    422
;  :rlimit-count            188155)
; [eval] (None(): option[array])
(pop) ; 8
(push) ; 8
; [else-branch: 50 | !(i0@73@06 < V@27@06 && 0 <= i0@73@06)]
(assert (not (and (< i0@73@06 V@27@06) (<= 0 i0@73@06))))
(pop) ; 8
(pop) ; 7
; Joined path conditions
(assert (implies
  (and (< i0@73@06 V@27@06) (<= 0 i0@73@06))
  (and
    (< i0@73@06 V@27@06)
    (<= 0 i0@73@06)
    (not (= res@68@06 (as None<option<array>>  option<array>)))
    (< i0@73@06 (alen<Int> (opt_get1 $Snap.unit res@68@06)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@68@06) i0@73@06)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@68@06) i0@73@06)))))
; Joined path conditions
; Definitional axioms for snapshot map values
(pop) ; 6
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i0@73@06 Int)) (!
  (implies
    (and (< i0@73@06 V@27@06) (<= 0 i0@73@06))
    (and
      (< i0@73@06 V@27@06)
      (<= 0 i0@73@06)
      (not (= res@68@06 (as None<option<array>>  option<array>)))
      (< i0@73@06 (alen<Int> (opt_get1 $Snap.unit res@68@06)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit res@68@06) i0@73@06)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit res@68@06) i0@73@06))))
  :pattern (($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit res@68@06) i0@73@06)) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit res@68@06) i0@73@06)))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (implies
  (= exc@67@06 $Ref.null)
  (forall ((i0@73@06 Int)) (!
    (implies
      (and (< i0@73@06 V@27@06) (<= 0 i0@73@06))
      (and
        (< i0@73@06 V@27@06)
        (<= 0 i0@73@06)
        (not (= res@68@06 (as None<option<array>>  option<array>)))
        (< i0@73@06 (alen<Int> (opt_get1 $Snap.unit res@68@06)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@68@06) i0@73@06)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@68@06) i0@73@06))))
    :pattern (($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@68@06) i0@73@06)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@68@06) i0@73@06)))
    :qid |prog.l<no position>-aux|))))
(assert (implies
  (= exc@67@06 $Ref.null)
  (forall ((i0@73@06 Int)) (!
    (implies
      (and (< i0@73@06 V@27@06) (<= 0 i0@73@06))
      (not
        (=
          ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit res@68@06) i0@73@06))
          (as None<option<array>>  option<array>))))
    :pattern (($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@68@06) i0@73@06)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@68@06) i0@73@06)))
    :qid |prog.l<no position>|))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@06)))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@06))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@06)))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@06))))))
  $Snap.unit))
; [eval] exc == null ==> (forall i0: Int :: { aloc(opt_get1(res), i0).option$array$ } 0 <= i0 && i0 < dim0 ==> alen(opt_get1(aloc(opt_get1(res), i0).option$array$)) == dim1)
; [eval] exc == null
(push) ; 4
(set-option :timeout 10)
(push) ; 5
(assert (not (not (= exc@67@06 $Ref.null))))
(check-sat)
; unknown
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               820
;  :arith-add-rows          291
;  :arith-assert-diseq      10
;  :arith-assert-lower      133
;  :arith-assert-upper      69
;  :arith-bound-prop        40
;  :arith-conflicts         15
;  :arith-eq-adapter        60
;  :arith-fixed-eqs         35
;  :arith-offset-eqs        35
;  :arith-pivots            151
;  :conflicts               36
;  :datatype-accessor-ax    36
;  :datatype-constructor-ax 71
;  :datatype-occurs-check   64
;  :datatype-splits         35
;  :decisions               77
;  :del-clause              451
;  :final-checks            43
;  :max-generation          3
;  :max-memory              4.53
;  :memory                  4.52
;  :mk-bool-var             1466
;  :mk-clause               451
;  :num-allocs              157616
;  :num-checks              70
;  :propagations            172
;  :quant-instantiations    422
;  :rlimit-count            189612)
; [then-branch: 51 | exc@67@06 == Null | live]
; [else-branch: 51 | exc@67@06 != Null | dead]
(push) ; 5
; [then-branch: 51 | exc@67@06 == Null]
; [eval] (forall i0: Int :: { aloc(opt_get1(res), i0).option$array$ } 0 <= i0 && i0 < dim0 ==> alen(opt_get1(aloc(opt_get1(res), i0).option$array$)) == dim1)
(declare-const i0@74@06 Int)
(push) ; 6
; [eval] 0 <= i0 && i0 < dim0 ==> alen(opt_get1(aloc(opt_get1(res), i0).option$array$)) == dim1
; [eval] 0 <= i0 && i0 < dim0
; [eval] 0 <= i0
(push) ; 7
; [then-branch: 52 | 0 <= i0@74@06 | live]
; [else-branch: 52 | !(0 <= i0@74@06) | live]
(push) ; 8
; [then-branch: 52 | 0 <= i0@74@06]
(assert (<= 0 i0@74@06))
; [eval] i0 < dim0
(pop) ; 8
(push) ; 8
; [else-branch: 52 | !(0 <= i0@74@06)]
(assert (not (<= 0 i0@74@06)))
(pop) ; 8
(pop) ; 7
; Joined path conditions
; Joined path conditions
(push) ; 7
; [then-branch: 53 | i0@74@06 < V@27@06 && 0 <= i0@74@06 | live]
; [else-branch: 53 | !(i0@74@06 < V@27@06 && 0 <= i0@74@06) | live]
(push) ; 8
; [then-branch: 53 | i0@74@06 < V@27@06 && 0 <= i0@74@06]
(assert (and (< i0@74@06 V@27@06) (<= 0 i0@74@06)))
; [eval] alen(opt_get1(aloc(opt_get1(res), i0).option$array$)) == dim1
; [eval] alen(opt_get1(aloc(opt_get1(res), i0).option$array$))
; [eval] opt_get1(aloc(opt_get1(res), i0).option$array$)
; [eval] aloc(opt_get1(res), i0)
; [eval] opt_get1(res)
(push) ; 9
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(set-option :timeout 0)
(push) ; 10
(assert (not (not (= res@68@06 (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               820
;  :arith-add-rows          292
;  :arith-assert-diseq      10
;  :arith-assert-lower      135
;  :arith-assert-upper      69
;  :arith-bound-prop        40
;  :arith-conflicts         15
;  :arith-eq-adapter        60
;  :arith-fixed-eqs         35
;  :arith-offset-eqs        35
;  :arith-pivots            152
;  :conflicts               36
;  :datatype-accessor-ax    36
;  :datatype-constructor-ax 71
;  :datatype-occurs-check   64
;  :datatype-splits         35
;  :decisions               77
;  :del-clause              451
;  :final-checks            43
;  :max-generation          3
;  :max-memory              4.53
;  :memory                  4.52
;  :mk-bool-var             1468
;  :mk-clause               451
;  :num-allocs              157714
;  :num-checks              71
;  :propagations            172
;  :quant-instantiations    422
;  :rlimit-count            189799)
(assert (not (= res@68@06 (as None<option<array>>  option<array>))))
(pop) ; 9
; Joined path conditions
(assert (not (= res@68@06 (as None<option<array>>  option<array>))))
(push) ; 9
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 10
(assert (not (< i0@74@06 (alen<Int> (opt_get1 $Snap.unit res@68@06)))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               820
;  :arith-add-rows          292
;  :arith-assert-diseq      10
;  :arith-assert-lower      135
;  :arith-assert-upper      69
;  :arith-bound-prop        40
;  :arith-conflicts         15
;  :arith-eq-adapter        60
;  :arith-fixed-eqs         35
;  :arith-offset-eqs        35
;  :arith-pivots            152
;  :conflicts               36
;  :datatype-accessor-ax    36
;  :datatype-constructor-ax 71
;  :datatype-occurs-check   64
;  :datatype-splits         35
;  :decisions               77
;  :del-clause              451
;  :final-checks            43
;  :max-generation          3
;  :max-memory              4.53
;  :memory                  4.52
;  :mk-bool-var             1468
;  :mk-clause               451
;  :num-allocs              157733
;  :num-checks              72
;  :propagations            172
;  :quant-instantiations    422
;  :rlimit-count            189830)
(assert (< i0@74@06 (alen<Int> (opt_get1 $Snap.unit res@68@06))))
(pop) ; 9
; Joined path conditions
(assert (< i0@74@06 (alen<Int> (opt_get1 $Snap.unit res@68@06))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit res@68@06) i0@74@06)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit res@68@06) i0@74@06)))
(push) ; 9
(assert (not (<
  $Perm.No
  (+
    (ite
      (and
        (<
          (inv@71@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@68@06) i0@74@06))
          V@27@06)
        (<=
          0
          (inv@71@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@68@06) i0@74@06))))
      $Perm.Write
      $Perm.No)
    (ite
      (and
        (<
          (inv@33@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@68@06) i0@74@06))
          V@27@06)
        (<=
          0
          (inv@33@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@68@06) i0@74@06))))
      $k@32@06
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               852
;  :arith-add-rows          307
;  :arith-assert-diseq      12
;  :arith-assert-lower      145
;  :arith-assert-upper      77
;  :arith-bound-prop        45
;  :arith-conflicts         17
;  :arith-eq-adapter        70
;  :arith-fixed-eqs         36
;  :arith-offset-eqs        38
;  :arith-pivots            159
;  :conflicts               44
;  :datatype-accessor-ax    36
;  :datatype-constructor-ax 73
;  :datatype-occurs-check   64
;  :datatype-splits         35
;  :decisions               88
;  :del-clause              511
;  :final-checks            43
;  :max-generation          3
;  :max-memory              4.60
;  :memory                  4.56
;  :mk-bool-var             1573
;  :mk-clause               534
;  :num-allocs              158300
;  :num-checks              73
;  :propagations            216
;  :quant-instantiations    445
;  :rlimit-count            191575)
(push) ; 9
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 10
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@68@06) i0@74@06))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               852
;  :arith-add-rows          307
;  :arith-assert-diseq      12
;  :arith-assert-lower      145
;  :arith-assert-upper      77
;  :arith-bound-prop        45
;  :arith-conflicts         17
;  :arith-eq-adapter        70
;  :arith-fixed-eqs         36
;  :arith-offset-eqs        38
;  :arith-pivots            159
;  :conflicts               45
;  :datatype-accessor-ax    36
;  :datatype-constructor-ax 73
;  :datatype-occurs-check   64
;  :datatype-splits         35
;  :decisions               88
;  :del-clause              511
;  :final-checks            43
;  :max-generation          3
;  :max-memory              4.60
;  :memory                  4.56
;  :mk-bool-var             1573
;  :mk-clause               534
;  :num-allocs              158388
;  :num-checks              74
;  :propagations            216
;  :quant-instantiations    445
;  :rlimit-count            191670)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@68@06) i0@74@06))
    (as None<option<array>>  option<array>))))
(pop) ; 9
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@68@06) i0@74@06))
    (as None<option<array>>  option<array>))))
(pop) ; 8
(push) ; 8
; [else-branch: 53 | !(i0@74@06 < V@27@06 && 0 <= i0@74@06)]
(assert (not (and (< i0@74@06 V@27@06) (<= 0 i0@74@06))))
(pop) ; 8
(pop) ; 7
; Joined path conditions
(assert (implies
  (and (< i0@74@06 V@27@06) (<= 0 i0@74@06))
  (and
    (< i0@74@06 V@27@06)
    (<= 0 i0@74@06)
    (not (= res@68@06 (as None<option<array>>  option<array>)))
    (< i0@74@06 (alen<Int> (opt_get1 $Snap.unit res@68@06)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@68@06) i0@74@06)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@68@06) i0@74@06))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@68@06) i0@74@06))
        (as None<option<array>>  option<array>))))))
; Joined path conditions
; Definitional axioms for snapshot map values
(pop) ; 6
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i0@74@06 Int)) (!
  (implies
    (and (< i0@74@06 V@27@06) (<= 0 i0@74@06))
    (and
      (< i0@74@06 V@27@06)
      (<= 0 i0@74@06)
      (not (= res@68@06 (as None<option<array>>  option<array>)))
      (< i0@74@06 (alen<Int> (opt_get1 $Snap.unit res@68@06)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit res@68@06) i0@74@06)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit res@68@06) i0@74@06))
      (not
        (=
          ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit res@68@06) i0@74@06))
          (as None<option<array>>  option<array>)))))
  :pattern (($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit res@68@06) i0@74@06)) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit res@68@06) i0@74@06)))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (implies
  (= exc@67@06 $Ref.null)
  (forall ((i0@74@06 Int)) (!
    (implies
      (and (< i0@74@06 V@27@06) (<= 0 i0@74@06))
      (and
        (< i0@74@06 V@27@06)
        (<= 0 i0@74@06)
        (not (= res@68@06 (as None<option<array>>  option<array>)))
        (< i0@74@06 (alen<Int> (opt_get1 $Snap.unit res@68@06)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@68@06) i0@74@06)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@68@06) i0@74@06))
        (not
          (=
            ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit res@68@06) i0@74@06))
            (as None<option<array>>  option<array>)))))
    :pattern (($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@68@06) i0@74@06)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@68@06) i0@74@06)))
    :qid |prog.l<no position>-aux|))))
(assert (implies
  (= exc@67@06 $Ref.null)
  (forall ((i0@74@06 Int)) (!
    (implies
      (and (< i0@74@06 V@27@06) (<= 0 i0@74@06))
      (=
        (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@68@06) i0@74@06))))
        V@27@06))
    :pattern (($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@68@06) i0@74@06)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@68@06) i0@74@06)))
    :qid |prog.l<no position>|))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@06))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@06)))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@06))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@06)))))))
  $Snap.unit))
; [eval] exc == null ==> (forall i0: Int, j0: Int :: { aloc(opt_get1(res), i0).option$array$,aloc(opt_get1(res), j0).option$array$ } 0 <= i0 && i0 < dim0 && (0 <= j0 && j0 < dim0) && aloc(opt_get1(res), i0).option$array$ == aloc(opt_get1(res), j0).option$array$ ==> i0 == j0)
; [eval] exc == null
(push) ; 4
(set-option :timeout 10)
(push) ; 5
(assert (not (not (= exc@67@06 $Ref.null))))
(check-sat)
; unknown
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               875
;  :arith-add-rows          309
;  :arith-assert-diseq      12
;  :arith-assert-lower      145
;  :arith-assert-upper      77
;  :arith-bound-prop        45
;  :arith-conflicts         17
;  :arith-eq-adapter        70
;  :arith-fixed-eqs         36
;  :arith-offset-eqs        38
;  :arith-pivots            162
;  :conflicts               45
;  :datatype-accessor-ax    37
;  :datatype-constructor-ax 77
;  :datatype-occurs-check   67
;  :datatype-splits         37
;  :decisions               92
;  :del-clause              534
;  :final-checks            45
;  :max-generation          3
;  :max-memory              4.60
;  :memory                  4.56
;  :mk-bool-var             1579
;  :mk-clause               534
;  :num-allocs              159387
;  :num-checks              75
;  :propagations            216
;  :quant-instantiations    445
;  :rlimit-count            193230)
; [then-branch: 54 | exc@67@06 == Null | live]
; [else-branch: 54 | exc@67@06 != Null | dead]
(push) ; 5
; [then-branch: 54 | exc@67@06 == Null]
; [eval] (forall i0: Int, j0: Int :: { aloc(opt_get1(res), i0).option$array$,aloc(opt_get1(res), j0).option$array$ } 0 <= i0 && i0 < dim0 && (0 <= j0 && j0 < dim0) && aloc(opt_get1(res), i0).option$array$ == aloc(opt_get1(res), j0).option$array$ ==> i0 == j0)
(declare-const i0@75@06 Int)
(declare-const j0@76@06 Int)
(push) ; 6
; [eval] 0 <= i0 && i0 < dim0 && (0 <= j0 && j0 < dim0) && aloc(opt_get1(res), i0).option$array$ == aloc(opt_get1(res), j0).option$array$ ==> i0 == j0
; [eval] 0 <= i0 && i0 < dim0 && (0 <= j0 && j0 < dim0) && aloc(opt_get1(res), i0).option$array$ == aloc(opt_get1(res), j0).option$array$
; [eval] 0 <= i0
(push) ; 7
; [then-branch: 55 | 0 <= i0@75@06 | live]
; [else-branch: 55 | !(0 <= i0@75@06) | live]
(push) ; 8
; [then-branch: 55 | 0 <= i0@75@06]
(assert (<= 0 i0@75@06))
; [eval] i0 < dim0
(push) ; 9
; [then-branch: 56 | i0@75@06 < V@27@06 | live]
; [else-branch: 56 | !(i0@75@06 < V@27@06) | live]
(push) ; 10
; [then-branch: 56 | i0@75@06 < V@27@06]
(assert (< i0@75@06 V@27@06))
; [eval] 0 <= j0
(push) ; 11
; [then-branch: 57 | 0 <= j0@76@06 | live]
; [else-branch: 57 | !(0 <= j0@76@06) | live]
(push) ; 12
; [then-branch: 57 | 0 <= j0@76@06]
(assert (<= 0 j0@76@06))
; [eval] j0 < dim0
(push) ; 13
; [then-branch: 58 | j0@76@06 < V@27@06 | live]
; [else-branch: 58 | !(j0@76@06 < V@27@06) | live]
(push) ; 14
; [then-branch: 58 | j0@76@06 < V@27@06]
(assert (< j0@76@06 V@27@06))
; [eval] aloc(opt_get1(res), i0).option$array$ == aloc(opt_get1(res), j0).option$array$
; [eval] aloc(opt_get1(res), i0)
; [eval] opt_get1(res)
(push) ; 15
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(set-option :timeout 0)
(push) ; 16
(assert (not (not (= res@68@06 (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               875
;  :arith-add-rows          311
;  :arith-assert-diseq      12
;  :arith-assert-lower      149
;  :arith-assert-upper      77
;  :arith-bound-prop        45
;  :arith-conflicts         17
;  :arith-eq-adapter        70
;  :arith-fixed-eqs         36
;  :arith-offset-eqs        38
;  :arith-pivots            164
;  :conflicts               45
;  :datatype-accessor-ax    37
;  :datatype-constructor-ax 77
;  :datatype-occurs-check   67
;  :datatype-splits         37
;  :decisions               92
;  :del-clause              534
;  :final-checks            45
;  :max-generation          3
;  :max-memory              4.60
;  :memory                  4.57
;  :mk-bool-var             1583
;  :mk-clause               534
;  :num-allocs              159662
;  :num-checks              76
;  :propagations            216
;  :quant-instantiations    445
;  :rlimit-count            193564)
(assert (not (= res@68@06 (as None<option<array>>  option<array>))))
(pop) ; 15
; Joined path conditions
(assert (not (= res@68@06 (as None<option<array>>  option<array>))))
(push) ; 15
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 16
(assert (not (< i0@75@06 (alen<Int> (opt_get1 $Snap.unit res@68@06)))))
(check-sat)
; unsat
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               875
;  :arith-add-rows          311
;  :arith-assert-diseq      12
;  :arith-assert-lower      149
;  :arith-assert-upper      77
;  :arith-bound-prop        45
;  :arith-conflicts         17
;  :arith-eq-adapter        70
;  :arith-fixed-eqs         36
;  :arith-offset-eqs        38
;  :arith-pivots            164
;  :conflicts               45
;  :datatype-accessor-ax    37
;  :datatype-constructor-ax 77
;  :datatype-occurs-check   67
;  :datatype-splits         37
;  :decisions               92
;  :del-clause              534
;  :final-checks            45
;  :max-generation          3
;  :max-memory              4.60
;  :memory                  4.57
;  :mk-bool-var             1583
;  :mk-clause               534
;  :num-allocs              159681
;  :num-checks              77
;  :propagations            216
;  :quant-instantiations    445
;  :rlimit-count            193595)
(assert (< i0@75@06 (alen<Int> (opt_get1 $Snap.unit res@68@06))))
(pop) ; 15
; Joined path conditions
(assert (< i0@75@06 (alen<Int> (opt_get1 $Snap.unit res@68@06))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit res@68@06) i0@75@06)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit res@68@06) i0@75@06)))
(push) ; 15
(assert (not (<
  $Perm.No
  (+
    (ite
      (and
        (<
          (inv@71@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@68@06) i0@75@06))
          V@27@06)
        (<=
          0
          (inv@71@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@68@06) i0@75@06))))
      $Perm.Write
      $Perm.No)
    (ite
      (and
        (<
          (inv@33@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@68@06) i0@75@06))
          V@27@06)
        (<=
          0
          (inv@33@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@68@06) i0@75@06))))
      $k@32@06
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               913
;  :arith-add-rows          323
;  :arith-assert-diseq      14
;  :arith-assert-lower      159
;  :arith-assert-upper      87
;  :arith-bound-prop        48
;  :arith-conflicts         20
;  :arith-eq-adapter        80
;  :arith-fixed-eqs         39
;  :arith-offset-eqs        39
;  :arith-pivots            170
;  :conflicts               51
;  :datatype-accessor-ax    37
;  :datatype-constructor-ax 79
;  :datatype-occurs-check   67
;  :datatype-splits         37
;  :decisions               97
;  :del-clause              552
;  :final-checks            45
;  :max-generation          3
;  :max-memory              4.60
;  :memory                  4.57
;  :mk-bool-var             1657
;  :mk-clause               577
;  :num-allocs              160170
;  :num-checks              78
;  :propagations            242
;  :quant-instantiations    472
;  :rlimit-count            195114)
; [eval] aloc(opt_get1(res), j0)
; [eval] opt_get1(res)
(push) ; 15
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 15
; Joined path conditions
(push) ; 15
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 16
(assert (not (< j0@76@06 (alen<Int> (opt_get1 $Snap.unit res@68@06)))))
(check-sat)
; unsat
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               913
;  :arith-add-rows          323
;  :arith-assert-diseq      14
;  :arith-assert-lower      159
;  :arith-assert-upper      87
;  :arith-bound-prop        48
;  :arith-conflicts         20
;  :arith-eq-adapter        80
;  :arith-fixed-eqs         39
;  :arith-offset-eqs        39
;  :arith-pivots            170
;  :conflicts               51
;  :datatype-accessor-ax    37
;  :datatype-constructor-ax 79
;  :datatype-occurs-check   67
;  :datatype-splits         37
;  :decisions               97
;  :del-clause              552
;  :final-checks            45
;  :max-generation          3
;  :max-memory              4.60
;  :memory                  4.57
;  :mk-bool-var             1657
;  :mk-clause               577
;  :num-allocs              160195
;  :num-checks              79
;  :propagations            242
;  :quant-instantiations    472
;  :rlimit-count            195144)
(assert (< j0@76@06 (alen<Int> (opt_get1 $Snap.unit res@68@06))))
(pop) ; 15
; Joined path conditions
(assert (< j0@76@06 (alen<Int> (opt_get1 $Snap.unit res@68@06))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit res@68@06) j0@76@06)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit res@68@06) j0@76@06)))
(push) ; 15
(assert (not (<
  $Perm.No
  (+
    (ite
      (and
        (<
          (inv@71@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@68@06) j0@76@06))
          V@27@06)
        (<=
          0
          (inv@71@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@68@06) j0@76@06))))
      $Perm.Write
      $Perm.No)
    (ite
      (and
        (<
          (inv@33@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@68@06) j0@76@06))
          V@27@06)
        (<=
          0
          (inv@33@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@68@06) j0@76@06))))
      $k@32@06
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               952
;  :arith-add-rows          335
;  :arith-assert-diseq      16
;  :arith-assert-lower      170
;  :arith-assert-upper      99
;  :arith-bound-prop        52
;  :arith-conflicts         24
;  :arith-eq-adapter        90
;  :arith-fixed-eqs         42
;  :arith-offset-eqs        40
;  :arith-pivots            175
;  :conflicts               61
;  :datatype-accessor-ax    37
;  :datatype-constructor-ax 81
;  :datatype-occurs-check   67
;  :datatype-splits         37
;  :decisions               106
;  :del-clause              587
;  :final-checks            45
;  :max-generation          3
;  :max-memory              4.60
;  :memory                  4.58
;  :mk-bool-var             1742
;  :mk-clause               630
;  :num-allocs              160774
;  :num-checks              80
;  :propagations            274
;  :quant-instantiations    499
;  :rlimit-count            196832)
(pop) ; 14
(push) ; 14
; [else-branch: 58 | !(j0@76@06 < V@27@06)]
(assert (not (< j0@76@06 V@27@06)))
(pop) ; 14
(pop) ; 13
; Joined path conditions
(assert (implies
  (< j0@76@06 V@27@06)
  (and
    (< j0@76@06 V@27@06)
    (not (= res@68@06 (as None<option<array>>  option<array>)))
    (< i0@75@06 (alen<Int> (opt_get1 $Snap.unit res@68@06)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@68@06) i0@75@06)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@68@06) i0@75@06))
    (< j0@76@06 (alen<Int> (opt_get1 $Snap.unit res@68@06)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@68@06) j0@76@06)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@68@06) j0@76@06)))))
; Joined path conditions
(pop) ; 12
(push) ; 12
; [else-branch: 57 | !(0 <= j0@76@06)]
(assert (not (<= 0 j0@76@06)))
(pop) ; 12
(pop) ; 11
; Joined path conditions
(assert (implies
  (<= 0 j0@76@06)
  (and
    (<= 0 j0@76@06)
    (implies
      (< j0@76@06 V@27@06)
      (and
        (< j0@76@06 V@27@06)
        (not (= res@68@06 (as None<option<array>>  option<array>)))
        (< i0@75@06 (alen<Int> (opt_get1 $Snap.unit res@68@06)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@68@06) i0@75@06)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@68@06) i0@75@06))
        (< j0@76@06 (alen<Int> (opt_get1 $Snap.unit res@68@06)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@68@06) j0@76@06)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@68@06) j0@76@06)))))))
; Joined path conditions
(pop) ; 10
(push) ; 10
; [else-branch: 56 | !(i0@75@06 < V@27@06)]
(assert (not (< i0@75@06 V@27@06)))
(pop) ; 10
(pop) ; 9
; Joined path conditions
(assert (implies
  (< i0@75@06 V@27@06)
  (and
    (< i0@75@06 V@27@06)
    (implies
      (<= 0 j0@76@06)
      (and
        (<= 0 j0@76@06)
        (implies
          (< j0@76@06 V@27@06)
          (and
            (< j0@76@06 V@27@06)
            (not (= res@68@06 (as None<option<array>>  option<array>)))
            (< i0@75@06 (alen<Int> (opt_get1 $Snap.unit res@68@06)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit res@68@06) i0@75@06)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit res@68@06) i0@75@06))
            (< j0@76@06 (alen<Int> (opt_get1 $Snap.unit res@68@06)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit res@68@06) j0@76@06)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit res@68@06) j0@76@06)))))))))
; Joined path conditions
(pop) ; 8
(push) ; 8
; [else-branch: 55 | !(0 <= i0@75@06)]
(assert (not (<= 0 i0@75@06)))
(pop) ; 8
(pop) ; 7
; Joined path conditions
(assert (implies
  (<= 0 i0@75@06)
  (and
    (<= 0 i0@75@06)
    (implies
      (< i0@75@06 V@27@06)
      (and
        (< i0@75@06 V@27@06)
        (implies
          (<= 0 j0@76@06)
          (and
            (<= 0 j0@76@06)
            (implies
              (< j0@76@06 V@27@06)
              (and
                (< j0@76@06 V@27@06)
                (not (= res@68@06 (as None<option<array>>  option<array>)))
                (< i0@75@06 (alen<Int> (opt_get1 $Snap.unit res@68@06)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit res@68@06) i0@75@06)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit res@68@06) i0@75@06))
                (< j0@76@06 (alen<Int> (opt_get1 $Snap.unit res@68@06)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit res@68@06) j0@76@06)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit res@68@06) j0@76@06)))))))))))
; Joined path conditions
(push) ; 7
; [then-branch: 59 | Lookup(option$array$,sm@72@06,aloc((_, _), opt_get1(_, res@68@06), i0@75@06)) == Lookup(option$array$,sm@72@06,aloc((_, _), opt_get1(_, res@68@06), j0@76@06)) && j0@76@06 < V@27@06 && 0 <= j0@76@06 && i0@75@06 < V@27@06 && 0 <= i0@75@06 | live]
; [else-branch: 59 | !(Lookup(option$array$,sm@72@06,aloc((_, _), opt_get1(_, res@68@06), i0@75@06)) == Lookup(option$array$,sm@72@06,aloc((_, _), opt_get1(_, res@68@06), j0@76@06)) && j0@76@06 < V@27@06 && 0 <= j0@76@06 && i0@75@06 < V@27@06 && 0 <= i0@75@06) | live]
(push) ; 8
; [then-branch: 59 | Lookup(option$array$,sm@72@06,aloc((_, _), opt_get1(_, res@68@06), i0@75@06)) == Lookup(option$array$,sm@72@06,aloc((_, _), opt_get1(_, res@68@06), j0@76@06)) && j0@76@06 < V@27@06 && 0 <= j0@76@06 && i0@75@06 < V@27@06 && 0 <= i0@75@06]
(assert (and
  (and
    (and
      (and
        (=
          ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit res@68@06) i0@75@06))
          ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit res@68@06) j0@76@06)))
        (< j0@76@06 V@27@06))
      (<= 0 j0@76@06))
    (< i0@75@06 V@27@06))
  (<= 0 i0@75@06)))
; [eval] i0 == j0
(pop) ; 8
(push) ; 8
; [else-branch: 59 | !(Lookup(option$array$,sm@72@06,aloc((_, _), opt_get1(_, res@68@06), i0@75@06)) == Lookup(option$array$,sm@72@06,aloc((_, _), opt_get1(_, res@68@06), j0@76@06)) && j0@76@06 < V@27@06 && 0 <= j0@76@06 && i0@75@06 < V@27@06 && 0 <= i0@75@06)]
(assert (not
  (and
    (and
      (and
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit res@68@06) i0@75@06))
            ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit res@68@06) j0@76@06)))
          (< j0@76@06 V@27@06))
        (<= 0 j0@76@06))
      (< i0@75@06 V@27@06))
    (<= 0 i0@75@06))))
(pop) ; 8
(pop) ; 7
; Joined path conditions
(assert (implies
  (and
    (and
      (and
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit res@68@06) i0@75@06))
            ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit res@68@06) j0@76@06)))
          (< j0@76@06 V@27@06))
        (<= 0 j0@76@06))
      (< i0@75@06 V@27@06))
    (<= 0 i0@75@06))
  (and
    (=
      ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit res@68@06) i0@75@06))
      ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit res@68@06) j0@76@06)))
    (< j0@76@06 V@27@06)
    (<= 0 j0@76@06)
    (< i0@75@06 V@27@06)
    (<= 0 i0@75@06))))
; Joined path conditions
; Definitional axioms for snapshot map values
; Definitional axioms for snapshot map values
(pop) ; 6
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i0@75@06 Int) (j0@76@06 Int)) (!
  (and
    (implies
      (<= 0 i0@75@06)
      (and
        (<= 0 i0@75@06)
        (implies
          (< i0@75@06 V@27@06)
          (and
            (< i0@75@06 V@27@06)
            (implies
              (<= 0 j0@76@06)
              (and
                (<= 0 j0@76@06)
                (implies
                  (< j0@76@06 V@27@06)
                  (and
                    (< j0@76@06 V@27@06)
                    (not (= res@68@06 (as None<option<array>>  option<array>)))
                    (< i0@75@06 (alen<Int> (opt_get1 $Snap.unit res@68@06)))
                    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit res@68@06) i0@75@06)) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit res@68@06) i0@75@06))
                    (< j0@76@06 (alen<Int> (opt_get1 $Snap.unit res@68@06)))
                    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit res@68@06) j0@76@06)) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit res@68@06) j0@76@06))))))))))
    (implies
      (and
        (and
          (and
            (and
              (=
                ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit res@68@06) i0@75@06))
                ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit res@68@06) j0@76@06)))
              (< j0@76@06 V@27@06))
            (<= 0 j0@76@06))
          (< i0@75@06 V@27@06))
        (<= 0 i0@75@06))
      (and
        (=
          ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit res@68@06) i0@75@06))
          ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit res@68@06) j0@76@06)))
        (< j0@76@06 V@27@06)
        (<= 0 j0@76@06)
        (< i0@75@06 V@27@06)
        (<= 0 i0@75@06))))
  :pattern (($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit res@68@06) i0@75@06)) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit res@68@06) i0@75@06)) ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit res@68@06) j0@76@06)) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit res@68@06) j0@76@06)))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (implies
  (= exc@67@06 $Ref.null)
  (forall ((i0@75@06 Int) (j0@76@06 Int)) (!
    (and
      (implies
        (<= 0 i0@75@06)
        (and
          (<= 0 i0@75@06)
          (implies
            (< i0@75@06 V@27@06)
            (and
              (< i0@75@06 V@27@06)
              (implies
                (<= 0 j0@76@06)
                (and
                  (<= 0 j0@76@06)
                  (implies
                    (< j0@76@06 V@27@06)
                    (and
                      (< j0@76@06 V@27@06)
                      (not (= res@68@06 (as None<option<array>>  option<array>)))
                      (< i0@75@06 (alen<Int> (opt_get1 $Snap.unit res@68@06)))
                      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit res@68@06) i0@75@06)) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit res@68@06) i0@75@06))
                      (< j0@76@06 (alen<Int> (opt_get1 $Snap.unit res@68@06)))
                      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit res@68@06) j0@76@06)) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit res@68@06) j0@76@06))))))))))
      (implies
        (and
          (and
            (and
              (and
                (=
                  ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit res@68@06) i0@75@06))
                  ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit res@68@06) j0@76@06)))
                (< j0@76@06 V@27@06))
              (<= 0 j0@76@06))
            (< i0@75@06 V@27@06))
          (<= 0 i0@75@06))
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit res@68@06) i0@75@06))
            ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit res@68@06) j0@76@06)))
          (< j0@76@06 V@27@06)
          (<= 0 j0@76@06)
          (< i0@75@06 V@27@06)
          (<= 0 i0@75@06))))
    :pattern (($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@68@06) i0@75@06)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@68@06) i0@75@06)) ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@68@06) j0@76@06)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@68@06) j0@76@06)))
    :qid |prog.l<no position>-aux|))))
(assert (implies
  (= exc@67@06 $Ref.null)
  (forall ((i0@75@06 Int) (j0@76@06 Int)) (!
    (implies
      (and
        (and
          (and
            (and
              (=
                ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit res@68@06) i0@75@06))
                ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit res@68@06) j0@76@06)))
              (< j0@76@06 V@27@06))
            (<= 0 j0@76@06))
          (< i0@75@06 V@27@06))
        (<= 0 i0@75@06))
      (= i0@75@06 j0@76@06))
    :pattern (($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@68@06) i0@75@06)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@68@06) i0@75@06)) ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@68@06) j0@76@06)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@68@06) j0@76@06)))
    :qid |prog.l<no position>|))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@06)))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@06))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@06)))))))))))
; [eval] exc == null
(set-option :timeout 10)
(push) ; 4
(assert (not (not (= exc@67@06 $Ref.null))))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               977
;  :arith-add-rows          341
;  :arith-assert-diseq      16
;  :arith-assert-lower      170
;  :arith-assert-upper      99
;  :arith-bound-prop        52
;  :arith-conflicts         24
;  :arith-eq-adapter        90
;  :arith-fixed-eqs         42
;  :arith-offset-eqs        40
;  :arith-pivots            181
;  :conflicts               61
;  :datatype-accessor-ax    38
;  :datatype-constructor-ax 86
;  :datatype-occurs-check   70
;  :datatype-splits         40
;  :decisions               111
;  :del-clause              654
;  :final-checks            47
;  :max-generation          3
;  :max-memory              4.60
;  :memory                  4.60
;  :mk-bool-var             1761
;  :mk-clause               654
;  :num-allocs              161989
;  :num-checks              81
;  :propagations            274
;  :quant-instantiations    499
;  :rlimit-count            199525)
; [then-branch: 60 | exc@67@06 == Null | live]
; [else-branch: 60 | exc@67@06 != Null | dead]
(push) ; 4
; [then-branch: 60 | exc@67@06 == Null]
(declare-const i0@77@06 Int)
(declare-const i1@78@06 Int)
(push) ; 5
; [eval] 0 <= i0 && i0 < dim0 && (0 <= i1 && i1 < dim1)
; [eval] 0 <= i0
(push) ; 6
; [then-branch: 61 | 0 <= i0@77@06 | live]
; [else-branch: 61 | !(0 <= i0@77@06) | live]
(push) ; 7
; [then-branch: 61 | 0 <= i0@77@06]
(assert (<= 0 i0@77@06))
; [eval] i0 < dim0
(push) ; 8
; [then-branch: 62 | i0@77@06 < V@27@06 | live]
; [else-branch: 62 | !(i0@77@06 < V@27@06) | live]
(push) ; 9
; [then-branch: 62 | i0@77@06 < V@27@06]
(assert (< i0@77@06 V@27@06))
; [eval] 0 <= i1
(push) ; 10
; [then-branch: 63 | 0 <= i1@78@06 | live]
; [else-branch: 63 | !(0 <= i1@78@06) | live]
(push) ; 11
; [then-branch: 63 | 0 <= i1@78@06]
(assert (<= 0 i1@78@06))
; [eval] i1 < dim1
(pop) ; 11
(push) ; 11
; [else-branch: 63 | !(0 <= i1@78@06)]
(assert (not (<= 0 i1@78@06)))
(pop) ; 11
(pop) ; 10
; Joined path conditions
; Joined path conditions
(pop) ; 9
(push) ; 9
; [else-branch: 62 | !(i0@77@06 < V@27@06)]
(assert (not (< i0@77@06 V@27@06)))
(pop) ; 9
(pop) ; 8
; Joined path conditions
; Joined path conditions
(pop) ; 7
(push) ; 7
; [else-branch: 61 | !(0 <= i0@77@06)]
(assert (not (<= 0 i0@77@06)))
(pop) ; 7
(pop) ; 6
; Joined path conditions
; Joined path conditions
(assert (and
  (and (and (< i1@78@06 V@27@06) (<= 0 i1@78@06)) (< i0@77@06 V@27@06))
  (<= 0 i0@77@06)))
; [eval] aloc(opt_get1(aloc(opt_get1(res), i0).option$array$), i1)
; [eval] opt_get1(aloc(opt_get1(res), i0).option$array$)
; [eval] aloc(opt_get1(res), i0)
; [eval] opt_get1(res)
(push) ; 6
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(set-option :timeout 0)
(push) ; 7
(assert (not (not (= res@68@06 (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               977
;  :arith-add-rows          344
;  :arith-assert-diseq      16
;  :arith-assert-lower      176
;  :arith-assert-upper      99
;  :arith-bound-prop        52
;  :arith-conflicts         24
;  :arith-eq-adapter        90
;  :arith-fixed-eqs         42
;  :arith-offset-eqs        40
;  :arith-pivots            182
;  :conflicts               61
;  :datatype-accessor-ax    38
;  :datatype-constructor-ax 86
;  :datatype-occurs-check   70
;  :datatype-splits         40
;  :decisions               111
;  :del-clause              654
;  :final-checks            47
;  :max-generation          3
;  :max-memory              4.60
;  :memory                  4.60
;  :mk-bool-var             1767
;  :mk-clause               654
;  :num-allocs              162257
;  :num-checks              82
;  :propagations            274
;  :quant-instantiations    499
;  :rlimit-count            199991)
(assert (not (= res@68@06 (as None<option<array>>  option<array>))))
(pop) ; 6
; Joined path conditions
(assert (not (= res@68@06 (as None<option<array>>  option<array>))))
(push) ; 6
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 7
(assert (not (< i0@77@06 (alen<Int> (opt_get1 $Snap.unit res@68@06)))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               977
;  :arith-add-rows          344
;  :arith-assert-diseq      16
;  :arith-assert-lower      176
;  :arith-assert-upper      99
;  :arith-bound-prop        52
;  :arith-conflicts         24
;  :arith-eq-adapter        90
;  :arith-fixed-eqs         42
;  :arith-offset-eqs        40
;  :arith-pivots            182
;  :conflicts               61
;  :datatype-accessor-ax    38
;  :datatype-constructor-ax 86
;  :datatype-occurs-check   70
;  :datatype-splits         40
;  :decisions               111
;  :del-clause              654
;  :final-checks            47
;  :max-generation          3
;  :max-memory              4.60
;  :memory                  4.60
;  :mk-bool-var             1767
;  :mk-clause               654
;  :num-allocs              162276
;  :num-checks              83
;  :propagations            274
;  :quant-instantiations    499
;  :rlimit-count            200022)
(assert (< i0@77@06 (alen<Int> (opt_get1 $Snap.unit res@68@06))))
(pop) ; 6
; Joined path conditions
(assert (< i0@77@06 (alen<Int> (opt_get1 $Snap.unit res@68@06))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit res@68@06) i0@77@06)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit res@68@06) i0@77@06)))
(push) ; 6
(assert (not (<
  $Perm.No
  (+
    (ite
      (and
        (<
          (inv@71@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@68@06) i0@77@06))
          V@27@06)
        (<=
          0
          (inv@71@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@68@06) i0@77@06))))
      $Perm.Write
      $Perm.No)
    (ite
      (and
        (<
          (inv@33@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@68@06) i0@77@06))
          V@27@06)
        (<=
          0
          (inv@33@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@68@06) i0@77@06))))
      $k@32@06
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1017
;  :arith-add-rows          356
;  :arith-assert-diseq      18
;  :arith-assert-lower      186
;  :arith-assert-upper      109
;  :arith-bound-prop        55
;  :arith-conflicts         27
;  :arith-eq-adapter        100
;  :arith-fixed-eqs         45
;  :arith-offset-eqs        41
;  :arith-pivots            187
;  :conflicts               67
;  :datatype-accessor-ax    38
;  :datatype-constructor-ax 88
;  :datatype-occurs-check   70
;  :datatype-splits         40
;  :decisions               116
;  :del-clause              672
;  :final-checks            47
;  :max-generation          3
;  :max-memory              4.61
;  :memory                  4.59
;  :mk-bool-var             1849
;  :mk-clause               698
;  :num-allocs              162765
;  :num-checks              84
;  :propagations            300
;  :quant-instantiations    527
;  :rlimit-count            201667)
(push) ; 6
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 7
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@68@06) i0@77@06))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1017
;  :arith-add-rows          356
;  :arith-assert-diseq      18
;  :arith-assert-lower      186
;  :arith-assert-upper      109
;  :arith-bound-prop        55
;  :arith-conflicts         27
;  :arith-eq-adapter        100
;  :arith-fixed-eqs         45
;  :arith-offset-eqs        41
;  :arith-pivots            187
;  :conflicts               68
;  :datatype-accessor-ax    38
;  :datatype-constructor-ax 88
;  :datatype-occurs-check   70
;  :datatype-splits         40
;  :decisions               116
;  :del-clause              672
;  :final-checks            47
;  :max-generation          3
;  :max-memory              4.61
;  :memory                  4.59
;  :mk-bool-var             1849
;  :mk-clause               698
;  :num-allocs              162853
;  :num-checks              85
;  :propagations            300
;  :quant-instantiations    527
;  :rlimit-count            201762)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@68@06) i0@77@06))
    (as None<option<array>>  option<array>))))
(pop) ; 6
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@68@06) i0@77@06))
    (as None<option<array>>  option<array>))))
(push) ; 6
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 7
(assert (not (<
  i1@78@06
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit res@68@06) i0@77@06)))))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1017
;  :arith-add-rows          359
;  :arith-assert-diseq      18
;  :arith-assert-lower      186
;  :arith-assert-upper      110
;  :arith-bound-prop        55
;  :arith-conflicts         28
;  :arith-eq-adapter        100
;  :arith-fixed-eqs         45
;  :arith-offset-eqs        41
;  :arith-pivots            189
;  :conflicts               69
;  :datatype-accessor-ax    38
;  :datatype-constructor-ax 88
;  :datatype-occurs-check   70
;  :datatype-splits         40
;  :decisions               116
;  :del-clause              672
;  :final-checks            47
;  :max-generation          3
;  :max-memory              4.61
;  :memory                  4.59
;  :mk-bool-var             1850
;  :mk-clause               698
;  :num-allocs              163002
;  :num-checks              86
;  :propagations            300
;  :quant-instantiations    527
;  :rlimit-count            202064)
(assert (<
  i1@78@06
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit res@68@06) i0@77@06))))))
(pop) ; 6
; Joined path conditions
(assert (<
  i1@78@06
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit res@68@06) i0@77@06))))))
; Definitional axioms for snapshot map values
; [eval] aloc(opt_get1(aloc(opt_get1(res), i0).option$array$), i1)
; [eval] opt_get1(aloc(opt_get1(res), i0).option$array$)
; [eval] aloc(opt_get1(res), i0)
; [eval] opt_get1(res)
(push) ; 6
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 6
; Joined path conditions
(push) ; 6
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(pop) ; 6
; Joined path conditions
(push) ; 6
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 6
; Joined path conditions
(push) ; 6
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(pop) ; 6
; Joined path conditions
(pop) ; 5
(declare-fun inv@79@06 ($Ref) Int)
(declare-fun inv@80@06 ($Ref) Int)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(assert (forall ((i0@77@06 Int) (i1@78@06 Int)) (!
  (and
    (not (= res@68@06 (as None<option<array>>  option<array>)))
    (< i0@77@06 (alen<Int> (opt_get1 $Snap.unit res@68@06)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@68@06) i0@77@06)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@68@06) i0@77@06))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@68@06) i0@77@06))
        (as None<option<array>>  option<array>)))
    (<
      i1@78@06
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit res@68@06) i0@77@06))))))
  :pattern (($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@06))))))))) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit res@68@06) i0@77@06))) i1@78@06)) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit res@68@06) i0@77@06))) i1@78@06)))
  :qid |int-aux|)))
; Check receiver injectivity
(push) ; 5
(assert (not (forall ((i01@77@06 Int) (i11@78@06 Int) (i02@77@06 Int) (i12@78@06 Int)) (!
  (implies
    (and
      (and
        (and (and (< i11@78@06 V@27@06) (<= 0 i11@78@06)) (< i01@77@06 V@27@06))
        (<= 0 i01@77@06))
      (and
        (and (and (< i12@78@06 V@27@06) (<= 0 i12@78@06)) (< i02@77@06 V@27@06))
        (<= 0 i02@77@06))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@68@06) i01@77@06))) i11@78@06)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@68@06) i02@77@06))) i12@78@06)))
    (and (= i01@77@06 i02@77@06) (= i11@78@06 i12@78@06)))
  
  :qid |int-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 5
; 0.02s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1151
;  :arith-add-rows          447
;  :arith-assert-diseq      24
;  :arith-assert-lower      211
;  :arith-assert-upper      121
;  :arith-bound-prop        60
;  :arith-conflicts         31
;  :arith-eq-adapter        120
;  :arith-fixed-eqs         51
;  :arith-offset-eqs        43
;  :arith-pivots            214
;  :conflicts               81
;  :datatype-accessor-ax    38
;  :datatype-constructor-ax 90
;  :datatype-occurs-check   70
;  :datatype-splits         40
;  :decisions               127
;  :del-clause              861
;  :final-checks            47
;  :max-generation          3
;  :max-memory              4.65
;  :memory                  4.64
;  :minimized-lits          2
;  :mk-bool-var             2247
;  :mk-clause               861
;  :num-allocs              164519
;  :num-checks              87
;  :propagations            417
;  :quant-instantiations    654
;  :rlimit-count            208818
;  :time                    0.00)
; Definitional axioms for inverse functions
(assert (forall ((i0@77@06 Int) (i1@78@06 Int)) (!
  (implies
    (and
      (and (and (< i1@78@06 V@27@06) (<= 0 i1@78@06)) (< i0@77@06 V@27@06))
      (<= 0 i0@77@06))
    (and
      (=
        (inv@79@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@68@06) i0@77@06))) i1@78@06))
        i0@77@06)
      (=
        (inv@80@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@68@06) i0@77@06))) i1@78@06))
        i1@78@06)))
  :pattern (($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@06))))))))) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit res@68@06) i0@77@06))) i1@78@06)) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit res@68@06) i0@77@06))) i1@78@06)))
  )))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@80@06 r) V@27@06) (<= 0 (inv@80@06 r)))
        (< (inv@79@06 r) V@27@06))
      (<= 0 (inv@79@06 r)))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit res@68@06) (inv@79@06 r)))) (inv@80@06 r))
      r))
  :pattern ((inv@79@06 r))
  :pattern ((inv@80@06 r))
  :qid |int-fctOfInv|)))
; Permissions are non-negative
; Field permissions are at most one
; Permission implies non-null receiver
(assert (forall ((i0@77@06 Int) (i1@78@06 Int)) (!
  (implies
    (and
      (and (and (< i1@78@06 V@27@06) (<= 0 i1@78@06)) (< i0@77@06 V@27@06))
      (<= 0 i0@77@06))
    (not
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@68@06) i0@77@06))) i1@78@06)
        $Ref.null)))
  :pattern (($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@06))))))))) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit res@68@06) i0@77@06))) i1@78@06)) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit res@68@06) i0@77@06))) i1@78@06)))
  :qid |int-permImpliesNonNull|)))
(declare-const sm@81@06 $FVF<Int>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@80@06 r) V@27@06) (<= 0 (inv@80@06 r)))
        (< (inv@79@06 r) V@27@06))
      (<= 0 (inv@79@06 r)))
    (=
      ($FVF.lookup_int (as sm@81@06  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@06))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@81@06  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@06))))))))) r))
  :qid |qp.fvfValDef14|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@42@06 r) V@27@06) (<= 0 (inv@42@06 r)))
        (< (inv@41@06 r) V@27@06))
      (<= 0 (inv@41@06 r)))
    (=
      ($FVF.lookup_int (as sm@81@06  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@30@06)))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@81@06  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@30@06)))))))))))) r))
  :qid |qp.fvfValDef15|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@06))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@30@06)))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@81@06  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef16|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@80@06 r) V@27@06) (<= 0 (inv@80@06 r)))
        (< (inv@79@06 r) V@27@06))
      (<= 0 (inv@79@06 r)))
    ($FVF.loc_int ($FVF.lookup_int (as sm@81@06  $FVF<Int>) r) r))
  :pattern ((inv@79@06 r) (inv@80@06 r))
  )))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@06))))))))
  $Snap.unit))
; [eval] exc == null ==> (forall i0: Int, i1: Int :: { aloc(opt_get1(aloc(opt_get1(res), i0).option$array$), i1).int } 0 <= i0 && i0 < dim0 && (0 <= i1 && i1 < dim1) ==> aloc(opt_get1(aloc(opt_get1(res), i0).option$array$), i1).int == 0)
; [eval] exc == null
(push) ; 5
(set-option :timeout 10)
(push) ; 6
(assert (not (not (= exc@67@06 $Ref.null))))
(check-sat)
; unknown
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1171
;  :arith-add-rows          447
;  :arith-assert-diseq      24
;  :arith-assert-lower      211
;  :arith-assert-upper      121
;  :arith-bound-prop        60
;  :arith-conflicts         31
;  :arith-eq-adapter        120
;  :arith-fixed-eqs         51
;  :arith-offset-eqs        43
;  :arith-pivots            214
;  :conflicts               81
;  :datatype-accessor-ax    38
;  :datatype-constructor-ax 94
;  :datatype-occurs-check   73
;  :datatype-splits         42
;  :decisions               131
;  :del-clause              861
;  :final-checks            49
;  :max-generation          3
;  :max-memory              4.68
;  :memory                  4.67
;  :minimized-lits          2
;  :mk-bool-var             2257
;  :mk-clause               861
;  :num-allocs              166197
;  :num-checks              88
;  :propagations            417
;  :quant-instantiations    654
;  :rlimit-count            213202)
; [then-branch: 64 | exc@67@06 == Null | live]
; [else-branch: 64 | exc@67@06 != Null | dead]
(push) ; 6
; [then-branch: 64 | exc@67@06 == Null]
; [eval] (forall i0: Int, i1: Int :: { aloc(opt_get1(aloc(opt_get1(res), i0).option$array$), i1).int } 0 <= i0 && i0 < dim0 && (0 <= i1 && i1 < dim1) ==> aloc(opt_get1(aloc(opt_get1(res), i0).option$array$), i1).int == 0)
(declare-const i0@82@06 Int)
(declare-const i1@83@06 Int)
(push) ; 7
; [eval] 0 <= i0 && i0 < dim0 && (0 <= i1 && i1 < dim1) ==> aloc(opt_get1(aloc(opt_get1(res), i0).option$array$), i1).int == 0
; [eval] 0 <= i0 && i0 < dim0 && (0 <= i1 && i1 < dim1)
; [eval] 0 <= i0
(push) ; 8
; [then-branch: 65 | 0 <= i0@82@06 | live]
; [else-branch: 65 | !(0 <= i0@82@06) | live]
(push) ; 9
; [then-branch: 65 | 0 <= i0@82@06]
(assert (<= 0 i0@82@06))
; [eval] i0 < dim0
(push) ; 10
; [then-branch: 66 | i0@82@06 < V@27@06 | live]
; [else-branch: 66 | !(i0@82@06 < V@27@06) | live]
(push) ; 11
; [then-branch: 66 | i0@82@06 < V@27@06]
(assert (< i0@82@06 V@27@06))
; [eval] 0 <= i1
(push) ; 12
; [then-branch: 67 | 0 <= i1@83@06 | live]
; [else-branch: 67 | !(0 <= i1@83@06) | live]
(push) ; 13
; [then-branch: 67 | 0 <= i1@83@06]
(assert (<= 0 i1@83@06))
; [eval] i1 < dim1
(pop) ; 13
(push) ; 13
; [else-branch: 67 | !(0 <= i1@83@06)]
(assert (not (<= 0 i1@83@06)))
(pop) ; 13
(pop) ; 12
; Joined path conditions
; Joined path conditions
(pop) ; 11
(push) ; 11
; [else-branch: 66 | !(i0@82@06 < V@27@06)]
(assert (not (< i0@82@06 V@27@06)))
(pop) ; 11
(pop) ; 10
; Joined path conditions
; Joined path conditions
(pop) ; 9
(push) ; 9
; [else-branch: 65 | !(0 <= i0@82@06)]
(assert (not (<= 0 i0@82@06)))
(pop) ; 9
(pop) ; 8
; Joined path conditions
; Joined path conditions
(push) ; 8
; [then-branch: 68 | i1@83@06 < V@27@06 && 0 <= i1@83@06 && i0@82@06 < V@27@06 && 0 <= i0@82@06 | live]
; [else-branch: 68 | !(i1@83@06 < V@27@06 && 0 <= i1@83@06 && i0@82@06 < V@27@06 && 0 <= i0@82@06) | live]
(push) ; 9
; [then-branch: 68 | i1@83@06 < V@27@06 && 0 <= i1@83@06 && i0@82@06 < V@27@06 && 0 <= i0@82@06]
(assert (and
  (and (and (< i1@83@06 V@27@06) (<= 0 i1@83@06)) (< i0@82@06 V@27@06))
  (<= 0 i0@82@06)))
; [eval] aloc(opt_get1(aloc(opt_get1(res), i0).option$array$), i1).int == 0
; [eval] aloc(opt_get1(aloc(opt_get1(res), i0).option$array$), i1)
; [eval] opt_get1(aloc(opt_get1(res), i0).option$array$)
; [eval] aloc(opt_get1(res), i0)
; [eval] opt_get1(res)
(push) ; 10
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(set-option :timeout 0)
(push) ; 11
(assert (not (not (= res@68@06 (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1171
;  :arith-add-rows          450
;  :arith-assert-diseq      24
;  :arith-assert-lower      217
;  :arith-assert-upper      121
;  :arith-bound-prop        60
;  :arith-conflicts         31
;  :arith-eq-adapter        120
;  :arith-fixed-eqs         51
;  :arith-offset-eqs        43
;  :arith-pivots            215
;  :conflicts               81
;  :datatype-accessor-ax    38
;  :datatype-constructor-ax 94
;  :datatype-occurs-check   73
;  :datatype-splits         42
;  :decisions               131
;  :del-clause              861
;  :final-checks            49
;  :max-generation          3
;  :max-memory              4.68
;  :memory                  4.67
;  :minimized-lits          2
;  :mk-bool-var             2263
;  :mk-clause               861
;  :num-allocs              166466
;  :num-checks              89
;  :propagations            417
;  :quant-instantiations    654
;  :rlimit-count            213678)
(assert (not (= res@68@06 (as None<option<array>>  option<array>))))
(pop) ; 10
; Joined path conditions
(assert (not (= res@68@06 (as None<option<array>>  option<array>))))
(push) ; 10
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 11
(assert (not (< i0@82@06 (alen<Int> (opt_get1 $Snap.unit res@68@06)))))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1171
;  :arith-add-rows          450
;  :arith-assert-diseq      24
;  :arith-assert-lower      217
;  :arith-assert-upper      121
;  :arith-bound-prop        60
;  :arith-conflicts         31
;  :arith-eq-adapter        120
;  :arith-fixed-eqs         51
;  :arith-offset-eqs        43
;  :arith-pivots            215
;  :conflicts               81
;  :datatype-accessor-ax    38
;  :datatype-constructor-ax 94
;  :datatype-occurs-check   73
;  :datatype-splits         42
;  :decisions               131
;  :del-clause              861
;  :final-checks            49
;  :max-generation          3
;  :max-memory              4.68
;  :memory                  4.67
;  :minimized-lits          2
;  :mk-bool-var             2263
;  :mk-clause               861
;  :num-allocs              166486
;  :num-checks              90
;  :propagations            417
;  :quant-instantiations    654
;  :rlimit-count            213709)
(assert (< i0@82@06 (alen<Int> (opt_get1 $Snap.unit res@68@06))))
(pop) ; 10
; Joined path conditions
(assert (< i0@82@06 (alen<Int> (opt_get1 $Snap.unit res@68@06))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit res@68@06) i0@82@06)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit res@68@06) i0@82@06)))
(push) ; 10
(assert (not (<
  $Perm.No
  (+
    (ite
      (and
        (<
          (inv@71@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@68@06) i0@82@06))
          V@27@06)
        (<=
          0
          (inv@71@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@68@06) i0@82@06))))
      $Perm.Write
      $Perm.No)
    (ite
      (and
        (<
          (inv@33@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@68@06) i0@82@06))
          V@27@06)
        (<=
          0
          (inv@33@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@68@06) i0@82@06))))
      $k@32@06
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1211
;  :arith-add-rows          462
;  :arith-assert-diseq      26
;  :arith-assert-lower      227
;  :arith-assert-upper      131
;  :arith-bound-prop        63
;  :arith-conflicts         34
;  :arith-eq-adapter        130
;  :arith-fixed-eqs         54
;  :arith-offset-eqs        46
;  :arith-pivots            220
;  :conflicts               87
;  :datatype-accessor-ax    38
;  :datatype-constructor-ax 96
;  :datatype-occurs-check   73
;  :datatype-splits         42
;  :decisions               136
;  :del-clause              879
;  :final-checks            49
;  :max-generation          3
;  :max-memory              4.68
;  :memory                  4.67
;  :minimized-lits          2
;  :mk-bool-var             2344
;  :mk-clause               904
;  :num-allocs              166978
;  :num-checks              91
;  :propagations            443
;  :quant-instantiations    682
;  :rlimit-count            215353)
(push) ; 10
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 11
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@68@06) i0@82@06))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1211
;  :arith-add-rows          462
;  :arith-assert-diseq      26
;  :arith-assert-lower      227
;  :arith-assert-upper      131
;  :arith-bound-prop        63
;  :arith-conflicts         34
;  :arith-eq-adapter        130
;  :arith-fixed-eqs         54
;  :arith-offset-eqs        46
;  :arith-pivots            220
;  :conflicts               88
;  :datatype-accessor-ax    38
;  :datatype-constructor-ax 96
;  :datatype-occurs-check   73
;  :datatype-splits         42
;  :decisions               136
;  :del-clause              879
;  :final-checks            49
;  :max-generation          3
;  :max-memory              4.68
;  :memory                  4.67
;  :minimized-lits          2
;  :mk-bool-var             2344
;  :mk-clause               904
;  :num-allocs              167067
;  :num-checks              92
;  :propagations            443
;  :quant-instantiations    682
;  :rlimit-count            215448)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@68@06) i0@82@06))
    (as None<option<array>>  option<array>))))
(pop) ; 10
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@68@06) i0@82@06))
    (as None<option<array>>  option<array>))))
(push) ; 10
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 11
(assert (not (<
  i1@83@06
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit res@68@06) i0@82@06)))))))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1211
;  :arith-add-rows          465
;  :arith-assert-diseq      26
;  :arith-assert-lower      227
;  :arith-assert-upper      132
;  :arith-bound-prop        63
;  :arith-conflicts         35
;  :arith-eq-adapter        130
;  :arith-fixed-eqs         54
;  :arith-offset-eqs        46
;  :arith-pivots            222
;  :conflicts               89
;  :datatype-accessor-ax    38
;  :datatype-constructor-ax 96
;  :datatype-occurs-check   73
;  :datatype-splits         42
;  :decisions               136
;  :del-clause              879
;  :final-checks            49
;  :max-generation          3
;  :max-memory              4.68
;  :memory                  4.67
;  :minimized-lits          2
;  :mk-bool-var             2345
;  :mk-clause               904
;  :num-allocs              167217
;  :num-checks              93
;  :propagations            443
;  :quant-instantiations    682
;  :rlimit-count            215750)
(assert (<
  i1@83@06
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit res@68@06) i0@82@06))))))
(pop) ; 10
; Joined path conditions
(assert (<
  i1@83@06
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit res@68@06) i0@82@06))))))
(assert ($FVF.loc_int ($FVF.lookup_int (as sm@81@06  $FVF<Int>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit res@68@06) i0@82@06))) i1@83@06)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit res@68@06) i0@82@06))) i1@83@06)))
(push) ; 10
(assert (not (<
  $Perm.No
  (+
    (ite
      (and
        (and
          (and
            (<
              (inv@80@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit res@68@06) i0@82@06))) i1@83@06))
              V@27@06)
            (<=
              0
              (inv@80@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit res@68@06) i0@82@06))) i1@83@06))))
          (<
            (inv@79@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit res@68@06) i0@82@06))) i1@83@06))
            V@27@06))
        (<=
          0
          (inv@79@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit res@68@06) i0@82@06))) i1@83@06))))
      $Perm.Write
      $Perm.No)
    (ite
      (and
        (and
          (and
            (<
              (inv@42@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit res@68@06) i0@82@06))) i1@83@06))
              V@27@06)
            (<=
              0
              (inv@42@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit res@68@06) i0@82@06))) i1@83@06))))
          (<
            (inv@41@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit res@68@06) i0@82@06))) i1@83@06))
            V@27@06))
        (<=
          0
          (inv@41@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit res@68@06) i0@82@06))) i1@83@06))))
      $Perm.Write
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1258
;  :arith-add-rows          481
;  :arith-assert-diseq      27
;  :arith-assert-lower      241
;  :arith-assert-upper      144
;  :arith-bound-prop        67
;  :arith-conflicts         39
;  :arith-eq-adapter        141
;  :arith-fixed-eqs         56
;  :arith-offset-eqs        53
;  :arith-pivots            229
;  :conflicts               100
;  :datatype-accessor-ax    38
;  :datatype-constructor-ax 98
;  :datatype-occurs-check   73
;  :datatype-splits         42
;  :decisions               152
;  :del-clause              951
;  :final-checks            49
;  :max-generation          3
;  :max-memory              5.01
;  :memory                  4.86
;  :minimized-lits          2
;  :mk-bool-var             2468
;  :mk-clause               1006
;  :num-allocs              167948
;  :num-checks              94
;  :propagations            499
;  :quant-instantiations    707
;  :rlimit-count            218477
;  :time                    0.00)
(pop) ; 9
(push) ; 9
; [else-branch: 68 | !(i1@83@06 < V@27@06 && 0 <= i1@83@06 && i0@82@06 < V@27@06 && 0 <= i0@82@06)]
(assert (not
  (and
    (and (and (< i1@83@06 V@27@06) (<= 0 i1@83@06)) (< i0@82@06 V@27@06))
    (<= 0 i0@82@06))))
(pop) ; 9
(pop) ; 8
; Joined path conditions
(assert (implies
  (and
    (and (and (< i1@83@06 V@27@06) (<= 0 i1@83@06)) (< i0@82@06 V@27@06))
    (<= 0 i0@82@06))
  (and
    (< i1@83@06 V@27@06)
    (<= 0 i1@83@06)
    (< i0@82@06 V@27@06)
    (<= 0 i0@82@06)
    (not (= res@68@06 (as None<option<array>>  option<array>)))
    (< i0@82@06 (alen<Int> (opt_get1 $Snap.unit res@68@06)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@68@06) i0@82@06)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@68@06) i0@82@06))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@68@06) i0@82@06))
        (as None<option<array>>  option<array>)))
    (<
      i1@83@06
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit res@68@06) i0@82@06)))))
    ($FVF.loc_int ($FVF.lookup_int (as sm@81@06  $FVF<Int>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@68@06) i0@82@06))) i1@83@06)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@68@06) i0@82@06))) i1@83@06)))))
; Joined path conditions
; Definitional axioms for snapshot map values
(pop) ; 7
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i0@82@06 Int) (i1@83@06 Int)) (!
  (implies
    (and
      (and (and (< i1@83@06 V@27@06) (<= 0 i1@83@06)) (< i0@82@06 V@27@06))
      (<= 0 i0@82@06))
    (and
      (< i1@83@06 V@27@06)
      (<= 0 i1@83@06)
      (< i0@82@06 V@27@06)
      (<= 0 i0@82@06)
      (not (= res@68@06 (as None<option<array>>  option<array>)))
      (< i0@82@06 (alen<Int> (opt_get1 $Snap.unit res@68@06)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit res@68@06) i0@82@06)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit res@68@06) i0@82@06))
      (not
        (=
          ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit res@68@06) i0@82@06))
          (as None<option<array>>  option<array>)))
      (<
        i1@83@06
        (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@68@06) i0@82@06)))))
      ($FVF.loc_int ($FVF.lookup_int (as sm@81@06  $FVF<Int>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit res@68@06) i0@82@06))) i1@83@06)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit res@68@06) i0@82@06))) i1@83@06))))
  :pattern (($FVF.loc_int ($FVF.lookup_int (as sm@81@06  $FVF<Int>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit res@68@06) i0@82@06))) i1@83@06)) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit res@68@06) i0@82@06))) i1@83@06)))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 6
(pop) ; 5
; Joined path conditions
(assert (implies
  (= exc@67@06 $Ref.null)
  (forall ((i0@82@06 Int) (i1@83@06 Int)) (!
    (implies
      (and
        (and (and (< i1@83@06 V@27@06) (<= 0 i1@83@06)) (< i0@82@06 V@27@06))
        (<= 0 i0@82@06))
      (and
        (< i1@83@06 V@27@06)
        (<= 0 i1@83@06)
        (< i0@82@06 V@27@06)
        (<= 0 i0@82@06)
        (not (= res@68@06 (as None<option<array>>  option<array>)))
        (< i0@82@06 (alen<Int> (opt_get1 $Snap.unit res@68@06)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@68@06) i0@82@06)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@68@06) i0@82@06))
        (not
          (=
            ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit res@68@06) i0@82@06))
            (as None<option<array>>  option<array>)))
        (<
          i1@83@06
          (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit res@68@06) i0@82@06)))))
        ($FVF.loc_int ($FVF.lookup_int (as sm@81@06  $FVF<Int>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@68@06) i0@82@06))) i1@83@06)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@68@06) i0@82@06))) i1@83@06))))
    :pattern (($FVF.loc_int ($FVF.lookup_int (as sm@81@06  $FVF<Int>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@68@06) i0@82@06))) i1@83@06)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@68@06) i0@82@06))) i1@83@06)))
    :qid |prog.l<no position>-aux|))))
(assert (implies
  (= exc@67@06 $Ref.null)
  (forall ((i0@82@06 Int) (i1@83@06 Int)) (!
    (implies
      (and
        (and (and (< i1@83@06 V@27@06) (<= 0 i1@83@06)) (< i0@82@06 V@27@06))
        (<= 0 i0@82@06))
      (=
        ($FVF.lookup_int (as sm@81@06  $FVF<Int>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@68@06) i0@82@06))) i1@83@06))
        0))
    :pattern (($FVF.loc_int ($FVF.lookup_int (as sm@81@06  $FVF<Int>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@68@06) i0@82@06))) i1@83@06)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@68@06) i0@82@06))) i1@83@06)))
    :qid |prog.l<no position>|))))
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
; [eval] exc != null
; [then-branch: 69 | exc@67@06 != Null | dead]
; [else-branch: 69 | exc@67@06 == Null | live]
(push) ; 5
; [else-branch: 69 | exc@67@06 == Null]
(pop) ; 5
; [eval] !(exc != null)
; [eval] exc != null
(set-option :timeout 10)
(push) ; 5
(assert (not (not (= exc@67@06 $Ref.null))))
(check-sat)
; unknown
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1296
;  :arith-add-rows          490
;  :arith-assert-diseq      27
;  :arith-assert-lower      241
;  :arith-assert-upper      144
;  :arith-bound-prop        67
;  :arith-conflicts         39
;  :arith-eq-adapter        141
;  :arith-fixed-eqs         56
;  :arith-offset-eqs        53
;  :arith-pivots            237
;  :conflicts               100
;  :datatype-accessor-ax    38
;  :datatype-constructor-ax 106
;  :datatype-occurs-check   79
;  :datatype-splits         46
;  :decisions               160
;  :del-clause              1006
;  :final-checks            53
;  :max-generation          3
;  :max-memory              5.01
;  :memory                  4.88
;  :minimized-lits          2
;  :mk-bool-var             2474
;  :mk-clause               1006
;  :num-allocs              169475
;  :num-checks              96
;  :propagations            499
;  :quant-instantiations    707
;  :rlimit-count            220825)
; [then-branch: 70 | exc@67@06 == Null | live]
; [else-branch: 70 | exc@67@06 != Null | dead]
(push) ; 5
; [then-branch: 70 | exc@67@06 == Null]
; [exec]
; Gf := res1
; [exec]
; exc, res2 := copy(this, tid, G, Gf, V)
; [eval] this != null
; [eval] source != (None(): option[array])
; [eval] (None(): option[array])
; [eval] alen(opt_get1(source)) == V
; [eval] alen(opt_get1(source))
; [eval] opt_get1(source)
(push) ; 6
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 6
; Joined path conditions
(declare-const i1@84@06 Int)
(push) ; 6
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 7
; [then-branch: 71 | 0 <= i1@84@06 | live]
; [else-branch: 71 | !(0 <= i1@84@06) | live]
(push) ; 8
; [then-branch: 71 | 0 <= i1@84@06]
(assert (<= 0 i1@84@06))
; [eval] i1 < V
(pop) ; 8
(push) ; 8
; [else-branch: 71 | !(0 <= i1@84@06)]
(assert (not (<= 0 i1@84@06)))
(pop) ; 8
(pop) ; 7
; Joined path conditions
; Joined path conditions
(assert (and (< i1@84@06 V@27@06) (<= 0 i1@84@06)))
(declare-const $k@85@06 $Perm)
(assert ($Perm.isReadVar $k@85@06 $Perm.Write))
; [eval] aloc(opt_get1(source), i1)
; [eval] opt_get1(source)
(push) ; 7
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 7
; Joined path conditions
(push) ; 7
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 8
(assert (not (< i1@84@06 (alen<Int> (opt_get1 $Snap.unit G@24@06)))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1296
;  :arith-add-rows          491
;  :arith-assert-diseq      28
;  :arith-assert-lower      245
;  :arith-assert-upper      145
;  :arith-bound-prop        67
;  :arith-conflicts         39
;  :arith-eq-adapter        142
;  :arith-fixed-eqs         56
;  :arith-offset-eqs        53
;  :arith-pivots            238
;  :conflicts               100
;  :datatype-accessor-ax    38
;  :datatype-constructor-ax 106
;  :datatype-occurs-check   79
;  :datatype-splits         46
;  :decisions               160
;  :del-clause              1006
;  :final-checks            53
;  :max-generation          3
;  :max-memory              5.01
;  :memory                  4.88
;  :minimized-lits          2
;  :mk-bool-var             2480
;  :mk-clause               1008
;  :num-allocs              169645
;  :num-checks              97
;  :propagations            500
;  :quant-instantiations    707
;  :rlimit-count            221163)
(assert (< i1@84@06 (alen<Int> (opt_get1 $Snap.unit G@24@06))))
(pop) ; 7
; Joined path conditions
(assert (< i1@84@06 (alen<Int> (opt_get1 $Snap.unit G@24@06))))
(pop) ; 6
(declare-fun inv@86@06 ($Ref) Int)
; Nested auxiliary terms: globals
(assert ($Perm.isReadVar $k@85@06 $Perm.Write))
; Nested auxiliary terms: non-globals
(assert (forall ((i1@84@06 Int)) (!
  (< i1@84@06 (alen<Int> (opt_get1 $Snap.unit G@24@06)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@84@06))
  :qid |option$array$-aux|)))
(push) ; 6
(assert (not (forall ((i1@84@06 Int)) (!
  (implies
    (and (< i1@84@06 V@27@06) (<= 0 i1@84@06))
    (or (= $k@85@06 $Perm.No) (< $Perm.No $k@85@06)))
  
  ))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1296
;  :arith-add-rows          492
;  :arith-assert-diseq      29
;  :arith-assert-lower      247
;  :arith-assert-upper      146
;  :arith-bound-prop        67
;  :arith-conflicts         39
;  :arith-eq-adapter        143
;  :arith-fixed-eqs         56
;  :arith-offset-eqs        53
;  :arith-pivots            239
;  :conflicts               101
;  :datatype-accessor-ax    38
;  :datatype-constructor-ax 106
;  :datatype-occurs-check   79
;  :datatype-splits         46
;  :decisions               160
;  :del-clause              1008
;  :final-checks            53
;  :max-generation          3
;  :max-memory              5.01
;  :memory                  4.88
;  :minimized-lits          2
;  :mk-bool-var             2487
;  :mk-clause               1010
;  :num-allocs              170073
;  :num-checks              98
;  :propagations            501
;  :quant-instantiations    707
;  :rlimit-count            221714)
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 6
(assert (not (forall ((i11@84@06 Int) (i12@84@06 Int)) (!
  (implies
    (and
      (and
        (and
          (and (< i11@84@06 V@27@06) (<= 0 i11@84@06))
          ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@24@06) i11@84@06)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@24@06) i11@84@06)))
        (< $Perm.No $k@85@06))
      (and
        (and
          (and (< i12@84@06 V@27@06) (<= 0 i12@84@06))
          ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@24@06) i12@84@06)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@24@06) i12@84@06)))
        (< $Perm.No $k@85@06))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i11@84@06)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i12@84@06)))
    (= i11@84@06 i12@84@06))
  
  :qid |option$array$-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1305
;  :arith-add-rows          498
;  :arith-assert-diseq      30
;  :arith-assert-lower      251
;  :arith-assert-upper      146
;  :arith-bound-prop        67
;  :arith-conflicts         39
;  :arith-eq-adapter        144
;  :arith-fixed-eqs         56
;  :arith-offset-eqs        53
;  :arith-pivots            239
;  :conflicts               102
;  :datatype-accessor-ax    38
;  :datatype-constructor-ax 106
;  :datatype-occurs-check   79
;  :datatype-splits         46
;  :decisions               160
;  :del-clause              1019
;  :final-checks            53
;  :max-generation          3
;  :max-memory              5.01
;  :memory                  4.88
;  :minimized-lits          2
;  :mk-bool-var             2516
;  :mk-clause               1021
;  :num-allocs              170485
;  :num-checks              99
;  :propagations            503
;  :quant-instantiations    721
;  :rlimit-count            222647)
; Definitional axioms for inverse functions
(assert (forall ((i1@84@06 Int)) (!
  (implies
    (and (and (< i1@84@06 V@27@06) (<= 0 i1@84@06)) (< $Perm.No $k@85@06))
    (=
      (inv@86@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@84@06))
      i1@84@06))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@84@06))
  :qid |option$array$-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and (< (inv@86@06 r) V@27@06) (<= 0 (inv@86@06 r)))
      (< $Perm.No $k@85@06))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) (inv@86@06 r))
      r))
  :pattern ((inv@86@06 r))
  :qid |option$array$-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@86@06 r) V@27@06) (<= 0 (inv@86@06 r)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) r) r))
  :pattern ((inv@86@06 r))
  )))
; Precomputing data for removing quantified permissions
(define-fun pTaken@87@06 ((r $Ref)) $Perm
  (ite
    (and (< (inv@86@06 r) V@27@06) (<= 0 (inv@86@06 r)))
    ($Perm.min
      (ite
        (and (< (inv@71@06 r) V@27@06) (<= 0 (inv@71@06 r)))
        $Perm.Write
        $Perm.No)
      $k@85@06)
    $Perm.No))
(define-fun pTaken@88@06 ((r $Ref)) $Perm
  (ite
    (and (< (inv@86@06 r) V@27@06) (<= 0 (inv@86@06 r)))
    ($Perm.min
      (ite
        (and (< (inv@33@06 r) V@27@06) (<= 0 (inv@33@06 r)))
        $k@32@06
        $Perm.No)
      (- $k@85@06 (pTaken@87@06 r)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Constrain original permissions $k@85@06
(assert (forall ((r $Ref)) (!
  (implies
    (not
      (=
        (ite
          (and (< (inv@71@06 r) V@27@06) (<= 0 (inv@71@06 r)))
          $Perm.Write
          $Perm.No)
        $Perm.No))
    (ite
      (and (< (inv@71@06 r) V@27@06) (<= 0 (inv@71@06 r)))
      (<
        (ite
          (and (< (inv@86@06 r) V@27@06) (<= 0 (inv@86@06 r)))
          $k@85@06
          $Perm.No)
        $Perm.Write)
      (<
        (ite
          (and (< (inv@86@06 r) V@27@06) (<= 0 (inv@86@06 r)))
          $k@85@06
          $Perm.No)
        $Perm.No)))
  :pattern ((inv@71@06 r))
  :pattern ((inv@86@06 r))
  :qid |qp.srp17|)))
; Intermediate check if already taken enough permissions
(set-option :timeout 500)
(push) ; 6
(assert (not (forall ((r $Ref)) (!
  (implies
    (and (< (inv@86@06 r) V@27@06) (<= 0 (inv@86@06 r)))
    (= (- $k@85@06 (pTaken@87@06 r)) $Perm.No))
  
  ))))
(check-sat)
; unknown
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1408
;  :arith-add-rows          519
;  :arith-assert-diseq      36
;  :arith-assert-lower      263
;  :arith-assert-upper      161
;  :arith-bound-prop        70
;  :arith-conflicts         42
;  :arith-eq-adapter        158
;  :arith-fixed-eqs         59
;  :arith-offset-eqs        56
;  :arith-pivots            254
;  :conflicts               108
;  :datatype-accessor-ax    39
;  :datatype-constructor-ax 117
;  :datatype-occurs-check   88
;  :datatype-splits         53
;  :decisions               185
;  :del-clause              1106
;  :final-checks            60
;  :interface-eqs           2
;  :max-generation          4
;  :max-memory              5.01
;  :memory                  4.91
;  :minimized-lits          2
;  :mk-bool-var             2644
;  :mk-clause               1106
;  :num-allocs              173300
;  :num-checks              101
;  :propagations            543
;  :quant-instantiations    751
;  :rlimit-count            227628
;  :time                    0.00)
; Constrain original permissions $k@85@06
(assert (forall ((r $Ref)) (!
  (implies
    (not
      (=
        (ite
          (and (< (inv@33@06 r) V@27@06) (<= 0 (inv@33@06 r)))
          $k@32@06
          $Perm.No)
        $Perm.No))
    (ite
      (and (< (inv@33@06 r) V@27@06) (<= 0 (inv@33@06 r)))
      (<
        (ite
          (and (< (inv@86@06 r) V@27@06) (<= 0 (inv@86@06 r)))
          $k@85@06
          $Perm.No)
        $k@32@06)
      (<
        (ite
          (and (< (inv@86@06 r) V@27@06) (<= 0 (inv@86@06 r)))
          $k@85@06
          $Perm.No)
        $Perm.No)))
  :pattern ((inv@33@06 r))
  :pattern ((inv@86@06 r))
  :qid |qp.srp18|)))
; Intermediate check if already taken enough permissions
(push) ; 6
(assert (not (forall ((r $Ref)) (!
  (implies
    (and (< (inv@86@06 r) V@27@06) (<= 0 (inv@86@06 r)))
    (= (- (- $k@85@06 (pTaken@87@06 r)) (pTaken@88@06 r)) $Perm.No))
  
  ))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1527
;  :arith-add-rows          603
;  :arith-assert-diseq      58
;  :arith-assert-lower      316
;  :arith-assert-upper      191
;  :arith-bound-prop        86
;  :arith-conflicts         48
;  :arith-eq-adapter        200
;  :arith-fixed-eqs         73
;  :arith-offset-eqs        68
;  :arith-pivots            282
;  :conflicts               119
;  :datatype-accessor-ax    39
;  :datatype-constructor-ax 119
;  :datatype-occurs-check   88
;  :datatype-splits         53
;  :decisions               197
;  :del-clause              1264
;  :final-checks            60
;  :interface-eqs           2
;  :max-generation          4
;  :max-memory              5.01
;  :memory                  4.91
;  :minimized-lits          6
;  :mk-bool-var             2853
;  :mk-clause               1264
;  :num-allocs              174715
;  :num-checks              102
;  :propagations            624
;  :quant-instantiations    778
;  :rlimit-count            232006
;  :time                    0.00)
; Final check if taken enough permissions
; Done removing quantified permissions
; Definitional axioms for snapshot map values
; [eval] (forall i1: Int :: { aloc(opt_get1(source), i1) } 0 <= i1 && i1 < V ==> aloc(opt_get1(source), i1).option$array$ != (None(): option[array]))
(declare-const i1@89@06 Int)
(push) ; 6
; [eval] 0 <= i1 && i1 < V ==> aloc(opt_get1(source), i1).option$array$ != (None(): option[array])
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 7
; [then-branch: 72 | 0 <= i1@89@06 | live]
; [else-branch: 72 | !(0 <= i1@89@06) | live]
(push) ; 8
; [then-branch: 72 | 0 <= i1@89@06]
(assert (<= 0 i1@89@06))
; [eval] i1 < V
(pop) ; 8
(push) ; 8
; [else-branch: 72 | !(0 <= i1@89@06)]
(assert (not (<= 0 i1@89@06)))
(pop) ; 8
(pop) ; 7
; Joined path conditions
; Joined path conditions
(push) ; 7
; [then-branch: 73 | i1@89@06 < V@27@06 && 0 <= i1@89@06 | live]
; [else-branch: 73 | !(i1@89@06 < V@27@06 && 0 <= i1@89@06) | live]
(push) ; 8
; [then-branch: 73 | i1@89@06 < V@27@06 && 0 <= i1@89@06]
(assert (and (< i1@89@06 V@27@06) (<= 0 i1@89@06)))
; [eval] aloc(opt_get1(source), i1).option$array$ != (None(): option[array])
; [eval] aloc(opt_get1(source), i1)
; [eval] opt_get1(source)
(push) ; 9
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 9
; Joined path conditions
(push) ; 9
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 10
(assert (not (< i1@89@06 (alen<Int> (opt_get1 $Snap.unit G@24@06)))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1527
;  :arith-add-rows          604
;  :arith-assert-diseq      58
;  :arith-assert-lower      318
;  :arith-assert-upper      191
;  :arith-bound-prop        86
;  :arith-conflicts         48
;  :arith-eq-adapter        200
;  :arith-fixed-eqs         73
;  :arith-offset-eqs        68
;  :arith-pivots            282
;  :conflicts               119
;  :datatype-accessor-ax    39
;  :datatype-constructor-ax 119
;  :datatype-occurs-check   88
;  :datatype-splits         53
;  :decisions               197
;  :del-clause              1264
;  :final-checks            60
;  :interface-eqs           2
;  :max-generation          4
;  :max-memory              5.01
;  :memory                  4.91
;  :minimized-lits          6
;  :mk-bool-var             2855
;  :mk-clause               1264
;  :num-allocs              174824
;  :num-checks              103
;  :propagations            624
;  :quant-instantiations    778
;  :rlimit-count            232197)
(assert (< i1@89@06 (alen<Int> (opt_get1 $Snap.unit G@24@06))))
(pop) ; 9
; Joined path conditions
(assert (< i1@89@06 (alen<Int> (opt_get1 $Snap.unit G@24@06))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@89@06)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@89@06)))
(push) ; 9
(assert (not (<
  $Perm.No
  (+
    (ite
      (and
        (<
          (inv@71@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@89@06))
          V@27@06)
        (<=
          0
          (inv@71@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@89@06))))
      $Perm.Write
      $Perm.No)
    (ite
      (and
        (<
          (inv@33@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@89@06))
          V@27@06)
        (<=
          0
          (inv@33@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@89@06))))
      $k@32@06
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1577
;  :arith-add-rows          628
;  :arith-assert-diseq      61
;  :arith-assert-lower      333
;  :arith-assert-upper      200
;  :arith-bound-prop        95
;  :arith-conflicts         50
;  :arith-eq-adapter        212
;  :arith-fixed-eqs         77
;  :arith-offset-eqs        73
;  :arith-pivots            292
;  :conflicts               128
;  :datatype-accessor-ax    39
;  :datatype-constructor-ax 121
;  :datatype-occurs-check   88
;  :datatype-splits         53
;  :decisions               205
;  :del-clause              1296
;  :final-checks            60
;  :interface-eqs           2
;  :max-generation          4
;  :max-memory              5.01
;  :memory                  4.92
;  :minimized-lits          6
;  :mk-bool-var             2974
;  :mk-clause               1346
;  :num-allocs              175495
;  :num-checks              104
;  :propagations            653
;  :quant-instantiations    804
;  :rlimit-count            234242)
; [eval] (None(): option[array])
(pop) ; 8
(push) ; 8
; [else-branch: 73 | !(i1@89@06 < V@27@06 && 0 <= i1@89@06)]
(assert (not (and (< i1@89@06 V@27@06) (<= 0 i1@89@06))))
(pop) ; 8
(pop) ; 7
; Joined path conditions
(assert (implies
  (and (< i1@89@06 V@27@06) (<= 0 i1@89@06))
  (and
    (< i1@89@06 V@27@06)
    (<= 0 i1@89@06)
    (< i1@89@06 (alen<Int> (opt_get1 $Snap.unit G@24@06)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@89@06)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@89@06)))))
; Joined path conditions
(pop) ; 6
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@89@06 Int)) (!
  (implies
    (and (< i1@89@06 V@27@06) (<= 0 i1@89@06))
    (and
      (< i1@89@06 V@27@06)
      (<= 0 i1@89@06)
      (< i1@89@06 (alen<Int> (opt_get1 $Snap.unit G@24@06)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@89@06)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@89@06))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@89@06))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(push) ; 6
(assert (not (forall ((i1@89@06 Int)) (!
  (implies
    (and (< i1@89@06 V@27@06) (<= 0 i1@89@06))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@89@06))
        (as None<option<array>>  option<array>))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@89@06))
  :qid |prog.l<no position>|))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1605
;  :arith-add-rows          645
;  :arith-assert-diseq      61
;  :arith-assert-lower      337
;  :arith-assert-upper      203
;  :arith-bound-prop        97
;  :arith-conflicts         51
;  :arith-eq-adapter        214
;  :arith-fixed-eqs         79
;  :arith-offset-eqs        73
;  :arith-pivots            301
;  :conflicts               133
;  :datatype-accessor-ax    39
;  :datatype-constructor-ax 123
;  :datatype-occurs-check   88
;  :datatype-splits         53
;  :decisions               209
;  :del-clause              1404
;  :final-checks            60
;  :interface-eqs           2
;  :max-generation          4
;  :max-memory              5.01
;  :memory                  4.91
;  :minimized-lits          6
;  :mk-bool-var             3046
;  :mk-clause               1404
;  :num-allocs              176178
;  :num-checks              105
;  :propagations            666
;  :quant-instantiations    831
;  :rlimit-count            236425)
(assert (forall ((i1@89@06 Int)) (!
  (implies
    (and (< i1@89@06 V@27@06) (<= 0 i1@89@06))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@89@06))
        (as None<option<array>>  option<array>))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@89@06))
  :qid |prog.l<no position>|)))
; [eval] (forall i1: Int :: { alen(opt_get1(aloc(opt_get1(source), i1).option$array$)) } 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(source), i1).option$array$)) == V)
(declare-const i1@90@06 Int)
(push) ; 6
; [eval] 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(source), i1).option$array$)) == V
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 7
; [then-branch: 74 | 0 <= i1@90@06 | live]
; [else-branch: 74 | !(0 <= i1@90@06) | live]
(push) ; 8
; [then-branch: 74 | 0 <= i1@90@06]
(assert (<= 0 i1@90@06))
; [eval] i1 < V
(pop) ; 8
(push) ; 8
; [else-branch: 74 | !(0 <= i1@90@06)]
(assert (not (<= 0 i1@90@06)))
(pop) ; 8
(pop) ; 7
; Joined path conditions
; Joined path conditions
(push) ; 7
; [then-branch: 75 | i1@90@06 < V@27@06 && 0 <= i1@90@06 | live]
; [else-branch: 75 | !(i1@90@06 < V@27@06 && 0 <= i1@90@06) | live]
(push) ; 8
; [then-branch: 75 | i1@90@06 < V@27@06 && 0 <= i1@90@06]
(assert (and (< i1@90@06 V@27@06) (<= 0 i1@90@06)))
; [eval] alen(opt_get1(aloc(opt_get1(source), i1).option$array$)) == V
; [eval] alen(opt_get1(aloc(opt_get1(source), i1).option$array$))
; [eval] opt_get1(aloc(opt_get1(source), i1).option$array$)
; [eval] aloc(opt_get1(source), i1)
; [eval] opt_get1(source)
(push) ; 9
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 9
; Joined path conditions
(push) ; 9
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 10
(assert (not (< i1@90@06 (alen<Int> (opt_get1 $Snap.unit G@24@06)))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1605
;  :arith-add-rows          646
;  :arith-assert-diseq      61
;  :arith-assert-lower      339
;  :arith-assert-upper      203
;  :arith-bound-prop        97
;  :arith-conflicts         51
;  :arith-eq-adapter        214
;  :arith-fixed-eqs         79
;  :arith-offset-eqs        73
;  :arith-pivots            301
;  :conflicts               133
;  :datatype-accessor-ax    39
;  :datatype-constructor-ax 123
;  :datatype-occurs-check   88
;  :datatype-splits         53
;  :decisions               209
;  :del-clause              1404
;  :final-checks            60
;  :interface-eqs           2
;  :max-generation          4
;  :max-memory              5.01
;  :memory                  4.91
;  :minimized-lits          6
;  :mk-bool-var             3049
;  :mk-clause               1404
;  :num-allocs              176470
;  :num-checks              106
;  :propagations            666
;  :quant-instantiations    831
;  :rlimit-count            236925)
(assert (< i1@90@06 (alen<Int> (opt_get1 $Snap.unit G@24@06))))
(pop) ; 9
; Joined path conditions
(assert (< i1@90@06 (alen<Int> (opt_get1 $Snap.unit G@24@06))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@90@06)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@90@06)))
(push) ; 9
(assert (not (<
  $Perm.No
  (+
    (ite
      (and
        (<
          (inv@71@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@90@06))
          V@27@06)
        (<=
          0
          (inv@71@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@90@06))))
      $Perm.Write
      $Perm.No)
    (ite
      (and
        (<
          (inv@33@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@90@06))
          V@27@06)
        (<=
          0
          (inv@33@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@90@06))))
      $k@32@06
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1668
;  :arith-add-rows          674
;  :arith-assert-diseq      64
;  :arith-assert-lower      359
;  :arith-assert-upper      213
;  :arith-bound-prop        107
;  :arith-conflicts         53
;  :arith-eq-adapter        227
;  :arith-fixed-eqs         84
;  :arith-offset-eqs        84
;  :arith-pivots            314
;  :conflicts               140
;  :datatype-accessor-ax    39
;  :datatype-constructor-ax 125
;  :datatype-occurs-check   88
;  :datatype-splits         53
;  :decisions               215
;  :del-clause              1439
;  :final-checks            60
;  :interface-eqs           2
;  :max-generation          4
;  :max-memory              5.01
;  :memory                  4.93
;  :minimized-lits          6
;  :mk-bool-var             3164
;  :mk-clause               1489
;  :num-allocs              177135
;  :num-checks              107
;  :propagations            710
;  :quant-instantiations    860
;  :rlimit-count            239194)
(push) ; 9
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 10
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@90@06))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1668
;  :arith-add-rows          674
;  :arith-assert-diseq      64
;  :arith-assert-lower      359
;  :arith-assert-upper      213
;  :arith-bound-prop        107
;  :arith-conflicts         53
;  :arith-eq-adapter        227
;  :arith-fixed-eqs         84
;  :arith-offset-eqs        84
;  :arith-pivots            314
;  :conflicts               141
;  :datatype-accessor-ax    39
;  :datatype-constructor-ax 125
;  :datatype-occurs-check   88
;  :datatype-splits         53
;  :decisions               215
;  :del-clause              1439
;  :final-checks            60
;  :interface-eqs           2
;  :max-generation          4
;  :max-memory              5.01
;  :memory                  4.93
;  :minimized-lits          6
;  :mk-bool-var             3164
;  :mk-clause               1489
;  :num-allocs              177224
;  :num-checks              108
;  :propagations            710
;  :quant-instantiations    860
;  :rlimit-count            239289)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@90@06))
    (as None<option<array>>  option<array>))))
(pop) ; 9
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@90@06))
    (as None<option<array>>  option<array>))))
(pop) ; 8
(push) ; 8
; [else-branch: 75 | !(i1@90@06 < V@27@06 && 0 <= i1@90@06)]
(assert (not (and (< i1@90@06 V@27@06) (<= 0 i1@90@06))))
(pop) ; 8
(pop) ; 7
; Joined path conditions
(assert (implies
  (and (< i1@90@06 V@27@06) (<= 0 i1@90@06))
  (and
    (< i1@90@06 V@27@06)
    (<= 0 i1@90@06)
    (< i1@90@06 (alen<Int> (opt_get1 $Snap.unit G@24@06)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@90@06)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@90@06))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@90@06))
        (as None<option<array>>  option<array>))))))
; Joined path conditions
(pop) ; 6
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@90@06 Int)) (!
  (implies
    (and (< i1@90@06 V@27@06) (<= 0 i1@90@06))
    (and
      (< i1@90@06 V@27@06)
      (<= 0 i1@90@06)
      (< i1@90@06 (alen<Int> (opt_get1 $Snap.unit G@24@06)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@90@06)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@90@06))
      (not
        (=
          ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@90@06))
          (as None<option<array>>  option<array>)))))
  :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@90@06)))))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(push) ; 6
(assert (not (forall ((i1@90@06 Int)) (!
  (implies
    (and (< i1@90@06 V@27@06) (<= 0 i1@90@06))
    (=
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@90@06))))
      V@27@06))
  :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@90@06)))))
  :qid |prog.l<no position>|))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1705
;  :arith-add-rows          695
;  :arith-assert-diseq      66
;  :arith-assert-lower      367
;  :arith-assert-upper      216
;  :arith-bound-prop        111
;  :arith-conflicts         54
;  :arith-eq-adapter        230
;  :arith-fixed-eqs         86
;  :arith-offset-eqs        89
;  :arith-pivots            327
;  :conflicts               148
;  :datatype-accessor-ax    39
;  :datatype-constructor-ax 127
;  :datatype-occurs-check   88
;  :datatype-splits         53
;  :decisions               221
;  :del-clause              1553
;  :final-checks            60
;  :interface-eqs           2
;  :max-generation          4
;  :max-memory              5.01
;  :memory                  4.94
;  :minimized-lits          6
;  :mk-bool-var             3246
;  :mk-clause               1553
;  :num-allocs              177962
;  :num-checks              109
;  :propagations            729
;  :quant-instantiations    894
;  :rlimit-count            241842
;  :time                    0.00)
(assert (forall ((i1@90@06 Int)) (!
  (implies
    (and (< i1@90@06 V@27@06) (<= 0 i1@90@06))
    (=
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@90@06))))
      V@27@06))
  :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@90@06)))))
  :qid |prog.l<no position>|)))
; [eval] (forall i1: Int :: { aloc(opt_get1(source), i1) } (forall i2: Int :: { aloc(opt_get1(source), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(source), i1).option$array$ == aloc(opt_get1(source), i2).option$array$ ==> i1 == i2))
(declare-const i1@91@06 Int)
(push) ; 6
; [eval] (forall i2: Int :: { aloc(opt_get1(source), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(source), i1).option$array$ == aloc(opt_get1(source), i2).option$array$ ==> i1 == i2)
(declare-const i2@92@06 Int)
(push) ; 7
; [eval] 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(source), i1).option$array$ == aloc(opt_get1(source), i2).option$array$ ==> i1 == i2
; [eval] 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(source), i1).option$array$ == aloc(opt_get1(source), i2).option$array$
; [eval] 0 <= i1
(push) ; 8
; [then-branch: 76 | 0 <= i1@91@06 | live]
; [else-branch: 76 | !(0 <= i1@91@06) | live]
(push) ; 9
; [then-branch: 76 | 0 <= i1@91@06]
(assert (<= 0 i1@91@06))
; [eval] i1 < V
(push) ; 10
; [then-branch: 77 | i1@91@06 < V@27@06 | live]
; [else-branch: 77 | !(i1@91@06 < V@27@06) | live]
(push) ; 11
; [then-branch: 77 | i1@91@06 < V@27@06]
(assert (< i1@91@06 V@27@06))
; [eval] 0 <= i2
(push) ; 12
; [then-branch: 78 | 0 <= i2@92@06 | live]
; [else-branch: 78 | !(0 <= i2@92@06) | live]
(push) ; 13
; [then-branch: 78 | 0 <= i2@92@06]
(assert (<= 0 i2@92@06))
; [eval] i2 < V
(push) ; 14
; [then-branch: 79 | i2@92@06 < V@27@06 | live]
; [else-branch: 79 | !(i2@92@06 < V@27@06) | live]
(push) ; 15
; [then-branch: 79 | i2@92@06 < V@27@06]
(assert (< i2@92@06 V@27@06))
; [eval] aloc(opt_get1(source), i1).option$array$ == aloc(opt_get1(source), i2).option$array$
; [eval] aloc(opt_get1(source), i1)
; [eval] opt_get1(source)
(push) ; 16
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 16
; Joined path conditions
(push) ; 16
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 17
(assert (not (< i1@91@06 (alen<Int> (opt_get1 $Snap.unit G@24@06)))))
(check-sat)
; unsat
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1705
;  :arith-add-rows          697
;  :arith-assert-diseq      66
;  :arith-assert-lower      371
;  :arith-assert-upper      216
;  :arith-bound-prop        111
;  :arith-conflicts         54
;  :arith-eq-adapter        230
;  :arith-fixed-eqs         86
;  :arith-offset-eqs        89
;  :arith-pivots            329
;  :conflicts               148
;  :datatype-accessor-ax    39
;  :datatype-constructor-ax 127
;  :datatype-occurs-check   88
;  :datatype-splits         53
;  :decisions               221
;  :del-clause              1553
;  :final-checks            60
;  :interface-eqs           2
;  :max-generation          4
;  :max-memory              5.01
;  :memory                  4.94
;  :minimized-lits          6
;  :mk-bool-var             3251
;  :mk-clause               1553
;  :num-allocs              178439
;  :num-checks              110
;  :propagations            729
;  :quant-instantiations    894
;  :rlimit-count            242499)
(assert (< i1@91@06 (alen<Int> (opt_get1 $Snap.unit G@24@06))))
(pop) ; 16
; Joined path conditions
(assert (< i1@91@06 (alen<Int> (opt_get1 $Snap.unit G@24@06))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@91@06)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@91@06)))
(push) ; 16
(assert (not (<
  $Perm.No
  (+
    (ite
      (and
        (<
          (inv@71@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@91@06))
          V@27@06)
        (<=
          0
          (inv@71@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@91@06))))
      $Perm.Write
      $Perm.No)
    (ite
      (and
        (<
          (inv@33@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@91@06))
          V@27@06)
        (<=
          0
          (inv@33@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@91@06))))
      $k@32@06
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1758
;  :arith-add-rows          722
;  :arith-assert-diseq      69
;  :arith-assert-lower      391
;  :arith-assert-upper      226
;  :arith-bound-prop        121
;  :arith-conflicts         56
;  :arith-eq-adapter        243
;  :arith-fixed-eqs         91
;  :arith-offset-eqs        95
;  :arith-pivots            341
;  :conflicts               154
;  :datatype-accessor-ax    39
;  :datatype-constructor-ax 129
;  :datatype-occurs-check   88
;  :datatype-splits         53
;  :decisions               226
;  :del-clause              1582
;  :final-checks            60
;  :interface-eqs           2
;  :max-generation          4
;  :max-memory              5.01
;  :memory                  4.98
;  :minimized-lits          6
;  :mk-bool-var             3356
;  :mk-clause               1632
;  :num-allocs              179081
;  :num-checks              111
;  :propagations            772
;  :quant-instantiations    922
;  :rlimit-count            244627)
; [eval] aloc(opt_get1(source), i2)
; [eval] opt_get1(source)
(push) ; 16
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 16
; Joined path conditions
(push) ; 16
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 17
(assert (not (< i2@92@06 (alen<Int> (opt_get1 $Snap.unit G@24@06)))))
(check-sat)
; unsat
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1758
;  :arith-add-rows          722
;  :arith-assert-diseq      69
;  :arith-assert-lower      391
;  :arith-assert-upper      226
;  :arith-bound-prop        121
;  :arith-conflicts         56
;  :arith-eq-adapter        243
;  :arith-fixed-eqs         91
;  :arith-offset-eqs        95
;  :arith-pivots            341
;  :conflicts               154
;  :datatype-accessor-ax    39
;  :datatype-constructor-ax 129
;  :datatype-occurs-check   88
;  :datatype-splits         53
;  :decisions               226
;  :del-clause              1582
;  :final-checks            60
;  :interface-eqs           2
;  :max-generation          4
;  :max-memory              5.01
;  :memory                  4.98
;  :minimized-lits          6
;  :mk-bool-var             3356
;  :mk-clause               1632
;  :num-allocs              179107
;  :num-checks              112
;  :propagations            772
;  :quant-instantiations    922
;  :rlimit-count            244657)
(assert (< i2@92@06 (alen<Int> (opt_get1 $Snap.unit G@24@06))))
(pop) ; 16
; Joined path conditions
(assert (< i2@92@06 (alen<Int> (opt_get1 $Snap.unit G@24@06))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@24@06) i2@92@06)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@24@06) i2@92@06)))
(push) ; 16
(assert (not (<
  $Perm.No
  (+
    (ite
      (and
        (<
          (inv@71@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i2@92@06))
          V@27@06)
        (<=
          0
          (inv@71@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i2@92@06))))
      $Perm.Write
      $Perm.No)
    (ite
      (and
        (<
          (inv@33@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i2@92@06))
          V@27@06)
        (<=
          0
          (inv@33@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i2@92@06))))
      $k@32@06
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1823
;  :arith-add-rows          760
;  :arith-assert-diseq      74
;  :arith-assert-lower      413
;  :arith-assert-upper      237
;  :arith-bound-prop        135
;  :arith-conflicts         59
;  :arith-eq-adapter        257
;  :arith-fixed-eqs         96
;  :arith-offset-eqs        100
;  :arith-pivots            351
;  :conflicts               166
;  :datatype-accessor-ax    39
;  :datatype-constructor-ax 131
;  :datatype-occurs-check   88
;  :datatype-splits         53
;  :decisions               237
;  :del-clause              1638
;  :final-checks            60
;  :interface-eqs           2
;  :max-generation          4
;  :max-memory              5.15
;  :memory                  5.09
;  :minimized-lits          6
;  :mk-bool-var             3509
;  :mk-clause               1750
;  :num-allocs              179934
;  :num-checks              113
;  :propagations            824
;  :quant-instantiations    952
;  :rlimit-count            247265)
(pop) ; 15
(push) ; 15
; [else-branch: 79 | !(i2@92@06 < V@27@06)]
(assert (not (< i2@92@06 V@27@06)))
(pop) ; 15
(pop) ; 14
; Joined path conditions
(assert (implies
  (< i2@92@06 V@27@06)
  (and
    (< i2@92@06 V@27@06)
    (< i1@91@06 (alen<Int> (opt_get1 $Snap.unit G@24@06)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@91@06)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@91@06))
    (< i2@92@06 (alen<Int> (opt_get1 $Snap.unit G@24@06)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@24@06) i2@92@06)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@24@06) i2@92@06)))))
; Joined path conditions
(pop) ; 13
(push) ; 13
; [else-branch: 78 | !(0 <= i2@92@06)]
(assert (not (<= 0 i2@92@06)))
(pop) ; 13
(pop) ; 12
; Joined path conditions
(assert (implies
  (<= 0 i2@92@06)
  (and
    (<= 0 i2@92@06)
    (implies
      (< i2@92@06 V@27@06)
      (and
        (< i2@92@06 V@27@06)
        (< i1@91@06 (alen<Int> (opt_get1 $Snap.unit G@24@06)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@91@06)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@91@06))
        (< i2@92@06 (alen<Int> (opt_get1 $Snap.unit G@24@06)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@24@06) i2@92@06)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@24@06) i2@92@06)))))))
; Joined path conditions
(pop) ; 11
(push) ; 11
; [else-branch: 77 | !(i1@91@06 < V@27@06)]
(assert (not (< i1@91@06 V@27@06)))
(pop) ; 11
(pop) ; 10
; Joined path conditions
(assert (implies
  (< i1@91@06 V@27@06)
  (and
    (< i1@91@06 V@27@06)
    (implies
      (<= 0 i2@92@06)
      (and
        (<= 0 i2@92@06)
        (implies
          (< i2@92@06 V@27@06)
          (and
            (< i2@92@06 V@27@06)
            (< i1@91@06 (alen<Int> (opt_get1 $Snap.unit G@24@06)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@91@06)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@91@06))
            (< i2@92@06 (alen<Int> (opt_get1 $Snap.unit G@24@06)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@24@06) i2@92@06)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@24@06) i2@92@06)))))))))
; Joined path conditions
(pop) ; 9
(push) ; 9
; [else-branch: 76 | !(0 <= i1@91@06)]
(assert (not (<= 0 i1@91@06)))
(pop) ; 9
(pop) ; 8
; Joined path conditions
(assert (implies
  (<= 0 i1@91@06)
  (and
    (<= 0 i1@91@06)
    (implies
      (< i1@91@06 V@27@06)
      (and
        (< i1@91@06 V@27@06)
        (implies
          (<= 0 i2@92@06)
          (and
            (<= 0 i2@92@06)
            (implies
              (< i2@92@06 V@27@06)
              (and
                (< i2@92@06 V@27@06)
                (< i1@91@06 (alen<Int> (opt_get1 $Snap.unit G@24@06)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@91@06)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@91@06))
                (< i2@92@06 (alen<Int> (opt_get1 $Snap.unit G@24@06)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@24@06) i2@92@06)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@24@06) i2@92@06)))))))))))
; Joined path conditions
(push) ; 8
; [then-branch: 80 | Lookup(option$array$,sm@72@06,aloc((_, _), opt_get1(_, G@24@06), i1@91@06)) == Lookup(option$array$,sm@72@06,aloc((_, _), opt_get1(_, G@24@06), i2@92@06)) && i2@92@06 < V@27@06 && 0 <= i2@92@06 && i1@91@06 < V@27@06 && 0 <= i1@91@06 | live]
; [else-branch: 80 | !(Lookup(option$array$,sm@72@06,aloc((_, _), opt_get1(_, G@24@06), i1@91@06)) == Lookup(option$array$,sm@72@06,aloc((_, _), opt_get1(_, G@24@06), i2@92@06)) && i2@92@06 < V@27@06 && 0 <= i2@92@06 && i1@91@06 < V@27@06 && 0 <= i1@91@06) | live]
(push) ; 9
; [then-branch: 80 | Lookup(option$array$,sm@72@06,aloc((_, _), opt_get1(_, G@24@06), i1@91@06)) == Lookup(option$array$,sm@72@06,aloc((_, _), opt_get1(_, G@24@06), i2@92@06)) && i2@92@06 < V@27@06 && 0 <= i2@92@06 && i1@91@06 < V@27@06 && 0 <= i1@91@06]
(assert (and
  (and
    (and
      (and
        (=
          ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@91@06))
          ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@24@06) i2@92@06)))
        (< i2@92@06 V@27@06))
      (<= 0 i2@92@06))
    (< i1@91@06 V@27@06))
  (<= 0 i1@91@06)))
; [eval] i1 == i2
(pop) ; 9
(push) ; 9
; [else-branch: 80 | !(Lookup(option$array$,sm@72@06,aloc((_, _), opt_get1(_, G@24@06), i1@91@06)) == Lookup(option$array$,sm@72@06,aloc((_, _), opt_get1(_, G@24@06), i2@92@06)) && i2@92@06 < V@27@06 && 0 <= i2@92@06 && i1@91@06 < V@27@06 && 0 <= i1@91@06)]
(assert (not
  (and
    (and
      (and
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@91@06))
            ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@24@06) i2@92@06)))
          (< i2@92@06 V@27@06))
        (<= 0 i2@92@06))
      (< i1@91@06 V@27@06))
    (<= 0 i1@91@06))))
(pop) ; 9
(pop) ; 8
; Joined path conditions
(assert (implies
  (and
    (and
      (and
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@91@06))
            ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@24@06) i2@92@06)))
          (< i2@92@06 V@27@06))
        (<= 0 i2@92@06))
      (< i1@91@06 V@27@06))
    (<= 0 i1@91@06))
  (and
    (=
      ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@91@06))
      ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@24@06) i2@92@06)))
    (< i2@92@06 V@27@06)
    (<= 0 i2@92@06)
    (< i1@91@06 V@27@06)
    (<= 0 i1@91@06))))
; Joined path conditions
(pop) ; 7
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i2@92@06 Int)) (!
  (and
    (implies
      (<= 0 i1@91@06)
      (and
        (<= 0 i1@91@06)
        (implies
          (< i1@91@06 V@27@06)
          (and
            (< i1@91@06 V@27@06)
            (implies
              (<= 0 i2@92@06)
              (and
                (<= 0 i2@92@06)
                (implies
                  (< i2@92@06 V@27@06)
                  (and
                    (< i2@92@06 V@27@06)
                    (< i1@91@06 (alen<Int> (opt_get1 $Snap.unit G@24@06)))
                    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@91@06)) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@91@06))
                    (< i2@92@06 (alen<Int> (opt_get1 $Snap.unit G@24@06)))
                    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit G@24@06) i2@92@06)) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit G@24@06) i2@92@06))))))))))
    (implies
      (and
        (and
          (and
            (and
              (=
                ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@91@06))
                ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@24@06) i2@92@06)))
              (< i2@92@06 V@27@06))
            (<= 0 i2@92@06))
          (< i1@91@06 V@27@06))
        (<= 0 i1@91@06))
      (and
        (=
          ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@91@06))
          ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@24@06) i2@92@06)))
        (< i2@92@06 V@27@06)
        (<= 0 i2@92@06)
        (< i1@91@06 V@27@06)
        (<= 0 i1@91@06))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i2@92@06))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 6
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@91@06 Int)) (!
  (forall ((i2@92@06 Int)) (!
    (and
      (implies
        (<= 0 i1@91@06)
        (and
          (<= 0 i1@91@06)
          (implies
            (< i1@91@06 V@27@06)
            (and
              (< i1@91@06 V@27@06)
              (implies
                (<= 0 i2@92@06)
                (and
                  (<= 0 i2@92@06)
                  (implies
                    (< i2@92@06 V@27@06)
                    (and
                      (< i2@92@06 V@27@06)
                      (< i1@91@06 (alen<Int> (opt_get1 $Snap.unit G@24@06)))
                      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@91@06)) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@91@06))
                      (< i2@92@06 (alen<Int> (opt_get1 $Snap.unit G@24@06)))
                      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit G@24@06) i2@92@06)) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit G@24@06) i2@92@06))))))))))
      (implies
        (and
          (and
            (and
              (and
                (=
                  ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@91@06))
                  ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit G@24@06) i2@92@06)))
                (< i2@92@06 V@27@06))
              (<= 0 i2@92@06))
            (< i1@91@06 V@27@06))
          (<= 0 i1@91@06))
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@91@06))
            ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@24@06) i2@92@06)))
          (< i2@92@06 V@27@06)
          (<= 0 i2@92@06)
          (< i1@91@06 V@27@06)
          (<= 0 i1@91@06))))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i2@92@06))
    :qid |prog.l<no position>-aux|))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@91@06))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(push) ; 6
(assert (not (forall ((i1@91@06 Int)) (!
  (forall ((i2@92@06 Int)) (!
    (implies
      (and
        (and
          (and
            (and
              (=
                ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@91@06))
                ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@24@06) i2@92@06)))
              (< i2@92@06 V@27@06))
            (<= 0 i2@92@06))
          (< i1@91@06 V@27@06))
        (<= 0 i1@91@06))
      (= i1@91@06 i2@92@06))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i2@92@06))
    :qid |prog.l<no position>|))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@91@06))
  :qid |prog.l<no position>|))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1876
;  :arith-add-rows          815
;  :arith-assert-diseq      75
;  :arith-assert-lower      424
;  :arith-assert-upper      243
;  :arith-bound-prop        142
;  :arith-conflicts         61
;  :arith-eq-adapter        262
;  :arith-fixed-eqs         100
;  :arith-offset-eqs        110
;  :arith-pivots            375
;  :conflicts               174
;  :datatype-accessor-ax    39
;  :datatype-constructor-ax 133
;  :datatype-occurs-check   88
;  :datatype-splits         53
;  :decisions               244
;  :del-clause              1887
;  :final-checks            60
;  :interface-eqs           2
;  :max-generation          4
;  :max-memory              5.15
;  :memory                  5.12
;  :minimized-lits          6
;  :mk-bool-var             3697
;  :mk-clause               1887
;  :num-allocs              181509
;  :num-checks              114
;  :propagations            857
;  :quant-instantiations    1012
;  :rlimit-count            253409
;  :time                    0.00)
(assert (forall ((i1@91@06 Int)) (!
  (forall ((i2@92@06 Int)) (!
    (implies
      (and
        (and
          (and
            (and
              (=
                ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@91@06))
                ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@24@06) i2@92@06)))
              (< i2@92@06 V@27@06))
            (<= 0 i2@92@06))
          (< i1@91@06 V@27@06))
        (<= 0 i1@91@06))
      (= i1@91@06 i2@92@06))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i2@92@06))
    :qid |prog.l<no position>|))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@91@06))
  :qid |prog.l<no position>|)))
; [eval] target != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 6
(assert (not (not (= res@68@06 (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1876
;  :arith-add-rows          815
;  :arith-assert-diseq      75
;  :arith-assert-lower      424
;  :arith-assert-upper      243
;  :arith-bound-prop        142
;  :arith-conflicts         61
;  :arith-eq-adapter        262
;  :arith-fixed-eqs         100
;  :arith-offset-eqs        110
;  :arith-pivots            375
;  :conflicts               174
;  :datatype-accessor-ax    39
;  :datatype-constructor-ax 133
;  :datatype-occurs-check   88
;  :datatype-splits         53
;  :decisions               244
;  :del-clause              1887
;  :final-checks            60
;  :interface-eqs           2
;  :max-generation          4
;  :max-memory              5.15
;  :memory                  5.12
;  :minimized-lits          6
;  :mk-bool-var             3698
;  :mk-clause               1887
;  :num-allocs              181853
;  :num-checks              115
;  :propagations            857
;  :quant-instantiations    1012
;  :rlimit-count            253949)
(assert (not (= res@68@06 (as None<option<array>>  option<array>))))
; [eval] alen(opt_get1(target)) == V
; [eval] alen(opt_get1(target))
; [eval] opt_get1(target)
(push) ; 6
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 6
; Joined path conditions
(push) ; 6
(assert (not (= (alen<Int> (opt_get1 $Snap.unit res@68@06)) V@27@06)))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1876
;  :arith-add-rows          815
;  :arith-assert-diseq      75
;  :arith-assert-lower      424
;  :arith-assert-upper      243
;  :arith-bound-prop        142
;  :arith-conflicts         61
;  :arith-eq-adapter        262
;  :arith-fixed-eqs         100
;  :arith-offset-eqs        110
;  :arith-pivots            375
;  :conflicts               174
;  :datatype-accessor-ax    39
;  :datatype-constructor-ax 133
;  :datatype-occurs-check   88
;  :datatype-splits         53
;  :decisions               244
;  :del-clause              1887
;  :final-checks            60
;  :interface-eqs           2
;  :max-generation          4
;  :max-memory              5.15
;  :memory                  5.12
;  :minimized-lits          6
;  :mk-bool-var             3698
;  :mk-clause               1887
;  :num-allocs              181869
;  :num-checks              116
;  :propagations            857
;  :quant-instantiations    1012
;  :rlimit-count            253968)
(assert (= (alen<Int> (opt_get1 $Snap.unit res@68@06)) V@27@06))
(declare-const i1@93@06 Int)
(push) ; 6
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 7
; [then-branch: 81 | 0 <= i1@93@06 | live]
; [else-branch: 81 | !(0 <= i1@93@06) | live]
(push) ; 8
; [then-branch: 81 | 0 <= i1@93@06]
(assert (<= 0 i1@93@06))
; [eval] i1 < V
(pop) ; 8
(push) ; 8
; [else-branch: 81 | !(0 <= i1@93@06)]
(assert (not (<= 0 i1@93@06)))
(pop) ; 8
(pop) ; 7
; Joined path conditions
; Joined path conditions
(assert (and (< i1@93@06 V@27@06) (<= 0 i1@93@06)))
(declare-const $k@94@06 $Perm)
(assert ($Perm.isReadVar $k@94@06 $Perm.Write))
; [eval] aloc(opt_get1(target), i1)
; [eval] opt_get1(target)
(push) ; 7
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 7
; Joined path conditions
(push) ; 7
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 8
(assert (not (< i1@93@06 (alen<Int> (opt_get1 $Snap.unit res@68@06)))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1876
;  :arith-add-rows          816
;  :arith-assert-diseq      76
;  :arith-assert-lower      428
;  :arith-assert-upper      244
;  :arith-bound-prop        142
;  :arith-conflicts         61
;  :arith-eq-adapter        263
;  :arith-fixed-eqs         100
;  :arith-offset-eqs        110
;  :arith-pivots            376
;  :conflicts               174
;  :datatype-accessor-ax    39
;  :datatype-constructor-ax 133
;  :datatype-occurs-check   88
;  :datatype-splits         53
;  :decisions               244
;  :del-clause              1887
;  :final-checks            60
;  :interface-eqs           2
;  :max-generation          4
;  :max-memory              5.15
;  :memory                  5.12
;  :minimized-lits          6
;  :mk-bool-var             3704
;  :mk-clause               1889
;  :num-allocs              182037
;  :num-checks              117
;  :propagations            858
;  :quant-instantiations    1012
;  :rlimit-count            254299)
(assert (< i1@93@06 (alen<Int> (opt_get1 $Snap.unit res@68@06))))
(pop) ; 7
; Joined path conditions
(assert (< i1@93@06 (alen<Int> (opt_get1 $Snap.unit res@68@06))))
(pop) ; 6
(declare-fun inv@95@06 ($Ref) Int)
; Nested auxiliary terms: globals
(assert ($Perm.isReadVar $k@94@06 $Perm.Write))
; Nested auxiliary terms: non-globals
(assert (forall ((i1@93@06 Int)) (!
  (< i1@93@06 (alen<Int> (opt_get1 $Snap.unit res@68@06)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@93@06))
  :qid |option$array$-aux|)))
(push) ; 6
(assert (not (forall ((i1@93@06 Int)) (!
  (implies
    (and (< i1@93@06 V@27@06) (<= 0 i1@93@06))
    (or (= $k@94@06 $Perm.No) (< $Perm.No $k@94@06)))
  
  ))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1876
;  :arith-add-rows          817
;  :arith-assert-diseq      77
;  :arith-assert-lower      430
;  :arith-assert-upper      245
;  :arith-bound-prop        142
;  :arith-conflicts         61
;  :arith-eq-adapter        264
;  :arith-fixed-eqs         100
;  :arith-offset-eqs        110
;  :arith-pivots            377
;  :conflicts               175
;  :datatype-accessor-ax    39
;  :datatype-constructor-ax 133
;  :datatype-occurs-check   88
;  :datatype-splits         53
;  :decisions               244
;  :del-clause              1889
;  :final-checks            60
;  :interface-eqs           2
;  :max-generation          4
;  :max-memory              5.15
;  :memory                  5.12
;  :minimized-lits          6
;  :mk-bool-var             3711
;  :mk-clause               1891
;  :num-allocs              182465
;  :num-checks              118
;  :propagations            859
;  :quant-instantiations    1012
;  :rlimit-count            254849)
(declare-const sm@96@06 $FVF<option<array>>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (ite
          (and (< (inv@33@06 r) V@27@06) (<= 0 (inv@33@06 r)))
          $k@32@06
          $Perm.No)
        (pTaken@88@06 r)))
    (=
      ($FVF.lookup_option$array$ (as sm@96@06  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@30@06))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@96@06  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@30@06))))) r))
  :qid |qp.fvfValDef19|)))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (ite
          (and (< (inv@71@06 r) V@27@06) (<= 0 (inv@71@06 r)))
          $Perm.Write
          $Perm.No)
        (pTaken@87@06 r)))
    (=
      ($FVF.lookup_option$array$ (as sm@96@06  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@69@06))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@96@06  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@69@06))))) r))
  :qid |qp.fvfValDef20|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@30@06))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@69@06))))) r) r))
  :pattern (($FVF.lookup_option$array$ (as sm@96@06  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef21|)))
; Check receiver injectivity
(push) ; 6
(assert (not (forall ((i11@93@06 Int) (i12@93@06 Int)) (!
  (implies
    (and
      (and
        (and
          (and (< i11@93@06 V@27@06) (<= 0 i11@93@06))
          ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@96@06  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit res@68@06) i11@93@06)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit res@68@06) i11@93@06)))
        (< $Perm.No $k@94@06))
      (and
        (and
          (and (< i12@93@06 V@27@06) (<= 0 i12@93@06))
          ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@96@06  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit res@68@06) i12@93@06)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit res@68@06) i12@93@06)))
        (< $Perm.No $k@94@06))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@68@06) i11@93@06)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@68@06) i12@93@06)))
    (= i11@93@06 i12@93@06))
  
  :qid |option$array$-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1893
;  :arith-add-rows          827
;  :arith-assert-diseq      78
;  :arith-assert-lower      434
;  :arith-assert-upper      245
;  :arith-bound-prop        143
;  :arith-conflicts         61
;  :arith-eq-adapter        266
;  :arith-fixed-eqs         100
;  :arith-offset-eqs        111
;  :arith-pivots            379
;  :conflicts               176
;  :datatype-accessor-ax    39
;  :datatype-constructor-ax 133
;  :datatype-occurs-check   88
;  :datatype-splits         53
;  :decisions               244
;  :del-clause              1936
;  :final-checks            60
;  :interface-eqs           2
;  :max-generation          4
;  :max-memory              5.15
;  :memory                  5.12
;  :minimized-lits          6
;  :mk-bool-var             3779
;  :mk-clause               1938
;  :num-allocs              183701
;  :num-checks              119
;  :propagations            864
;  :quant-instantiations    1035
;  :rlimit-count            258173)
; Definitional axioms for inverse functions
(assert (forall ((i1@93@06 Int)) (!
  (implies
    (and (and (< i1@93@06 V@27@06) (<= 0 i1@93@06)) (< $Perm.No $k@94@06))
    (=
      (inv@95@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@93@06))
      i1@93@06))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@93@06))
  :qid |option$array$-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and (< (inv@95@06 r) V@27@06) (<= 0 (inv@95@06 r)))
      (< $Perm.No $k@94@06))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@68@06) (inv@95@06 r))
      r))
  :pattern ((inv@95@06 r))
  :qid |option$array$-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@95@06 r) V@27@06) (<= 0 (inv@95@06 r)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@96@06  $FVF<option<array>>) r) r))
  :pattern ((inv@95@06 r))
  )))
; Precomputing data for removing quantified permissions
(define-fun pTaken@97@06 ((r $Ref)) $Perm
  (ite
    (and (< (inv@95@06 r) V@27@06) (<= 0 (inv@95@06 r)))
    ($Perm.min
      (-
        (ite
          (and (< (inv@33@06 r) V@27@06) (<= 0 (inv@33@06 r)))
          $k@32@06
          $Perm.No)
        (pTaken@88@06 r))
      $k@94@06)
    $Perm.No))
(define-fun pTaken@98@06 ((r $Ref)) $Perm
  (ite
    (and (< (inv@95@06 r) V@27@06) (<= 0 (inv@95@06 r)))
    ($Perm.min
      (-
        (ite
          (and (< (inv@71@06 r) V@27@06) (<= 0 (inv@71@06 r)))
          $Perm.Write
          $Perm.No)
        (pTaken@87@06 r))
      (- $k@94@06 (pTaken@97@06 r)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Constrain original permissions $k@94@06
(assert (forall ((r $Ref)) (!
  (implies
    (not
      (=
        (-
          (ite
            (and (< (inv@33@06 r) V@27@06) (<= 0 (inv@33@06 r)))
            $k@32@06
            $Perm.No)
          (pTaken@88@06 r))
        $Perm.No))
    (<
      (ite
        (and (< (inv@95@06 r) V@27@06) (<= 0 (inv@95@06 r)))
        $k@94@06
        $Perm.No)
      (-
        (ite
          (and (< (inv@33@06 r) V@27@06) (<= 0 (inv@33@06 r)))
          $k@32@06
          $Perm.No)
        (pTaken@88@06 r))))
  :pattern ((inv@33@06 r))
  :pattern ((inv@95@06 r))
  :qid |qp.srp22|)))
; Intermediate check if already taken enough permissions
(set-option :timeout 500)
(push) ; 6
(assert (not (forall ((r $Ref)) (!
  (implies
    (and (< (inv@95@06 r) V@27@06) (<= 0 (inv@95@06 r)))
    (= (- $k@94@06 (pTaken@97@06 r)) $Perm.No))
  
  ))))
(check-sat)
; unknown
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               2130
;  :arith-add-rows          918
;  :arith-assert-diseq      99
;  :arith-assert-lower      504
;  :arith-assert-upper      279
;  :arith-bound-prop        166
;  :arith-conflicts         67
;  :arith-eq-adapter        316
;  :arith-fixed-eqs         113
;  :arith-offset-eqs        126
;  :arith-pivots            422
;  :conflicts               189
;  :datatype-accessor-ax    40
;  :datatype-constructor-ax 144
;  :datatype-occurs-check   97
;  :datatype-splits         60
;  :decisions               280
;  :del-clause              2181
;  :final-checks            65
;  :interface-eqs           2
;  :max-generation          6
;  :max-memory              5.18
;  :memory                  5.15
;  :minimized-lits          6
;  :mk-bool-var             4113
;  :mk-clause               2183
;  :num-allocs              187698
;  :num-checks              121
;  :propagations            1007
;  :quant-instantiations    1128
;  :rlimit-count            268620
;  :time                    0.00)
; Constrain original permissions $k@94@06
(assert (forall ((r $Ref)) (!
  (implies
    (not
      (=
        (-
          (ite
            (and (< (inv@71@06 r) V@27@06) (<= 0 (inv@71@06 r)))
            $Perm.Write
            $Perm.No)
          (pTaken@87@06 r))
        $Perm.No))
    (<
      (ite
        (and (< (inv@95@06 r) V@27@06) (<= 0 (inv@95@06 r)))
        $k@94@06
        $Perm.No)
      (-
        (ite
          (and (< (inv@71@06 r) V@27@06) (<= 0 (inv@71@06 r)))
          $Perm.Write
          $Perm.No)
        (pTaken@87@06 r))))
  :pattern ((inv@71@06 r))
  :pattern ((inv@95@06 r))
  :qid |qp.srp23|)))
; Intermediate check if already taken enough permissions
(push) ; 6
(assert (not (forall ((r $Ref)) (!
  (implies
    (and (< (inv@95@06 r) V@27@06) (<= 0 (inv@95@06 r)))
    (= (- (- $k@94@06 (pTaken@97@06 r)) (pTaken@98@06 r)) $Perm.No))
  
  ))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               2414
;  :arith-add-rows          1175
;  :arith-assert-diseq      126
;  :arith-assert-lower      595
;  :arith-assert-upper      336
;  :arith-bound-prop        198
;  :arith-conflicts         76
;  :arith-eq-adapter        386
;  :arith-fixed-eqs         145
;  :arith-offset-eqs        171
;  :arith-pivots            481
;  :conflicts               207
;  :datatype-accessor-ax    40
;  :datatype-constructor-ax 146
;  :datatype-occurs-check   97
;  :datatype-splits         60
;  :decisions               299
;  :del-clause              2479
;  :final-checks            65
;  :interface-eqs           2
;  :max-generation          6
;  :max-memory              5.19
;  :memory                  5.17
;  :minimized-lits          8
;  :mk-bool-var             4524
;  :mk-clause               2481
;  :num-allocs              190088
;  :num-checks              122
;  :propagations            1236
;  :quant-instantiations    1204
;  :rlimit-count            278998
;  :time                    0.00)
; Final check if taken enough permissions
; Done removing quantified permissions
; Definitional axioms for snapshot map values
; [eval] (forall i1: Int :: { aloc(opt_get1(target), i1) } 0 <= i1 && i1 < V ==> aloc(opt_get1(target), i1).option$array$ != (None(): option[array]))
(declare-const i1@99@06 Int)
(push) ; 6
; [eval] 0 <= i1 && i1 < V ==> aloc(opt_get1(target), i1).option$array$ != (None(): option[array])
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 7
; [then-branch: 82 | 0 <= i1@99@06 | live]
; [else-branch: 82 | !(0 <= i1@99@06) | live]
(push) ; 8
; [then-branch: 82 | 0 <= i1@99@06]
(assert (<= 0 i1@99@06))
; [eval] i1 < V
(pop) ; 8
(push) ; 8
; [else-branch: 82 | !(0 <= i1@99@06)]
(assert (not (<= 0 i1@99@06)))
(pop) ; 8
(pop) ; 7
; Joined path conditions
; Joined path conditions
(push) ; 7
; [then-branch: 83 | i1@99@06 < V@27@06 && 0 <= i1@99@06 | live]
; [else-branch: 83 | !(i1@99@06 < V@27@06 && 0 <= i1@99@06) | live]
(push) ; 8
; [then-branch: 83 | i1@99@06 < V@27@06 && 0 <= i1@99@06]
(assert (and (< i1@99@06 V@27@06) (<= 0 i1@99@06)))
; [eval] aloc(opt_get1(target), i1).option$array$ != (None(): option[array])
; [eval] aloc(opt_get1(target), i1)
; [eval] opt_get1(target)
(push) ; 9
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 9
; Joined path conditions
(push) ; 9
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 10
(assert (not (< i1@99@06 (alen<Int> (opt_get1 $Snap.unit res@68@06)))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               2414
;  :arith-add-rows          1176
;  :arith-assert-diseq      126
;  :arith-assert-lower      597
;  :arith-assert-upper      336
;  :arith-bound-prop        198
;  :arith-conflicts         76
;  :arith-eq-adapter        386
;  :arith-fixed-eqs         145
;  :arith-offset-eqs        171
;  :arith-pivots            482
;  :conflicts               207
;  :datatype-accessor-ax    40
;  :datatype-constructor-ax 146
;  :datatype-occurs-check   97
;  :datatype-splits         60
;  :decisions               299
;  :del-clause              2479
;  :final-checks            65
;  :interface-eqs           2
;  :max-generation          6
;  :max-memory              5.19
;  :memory                  5.17
;  :minimized-lits          8
;  :mk-bool-var             4526
;  :mk-clause               2481
;  :num-allocs              190197
;  :num-checks              123
;  :propagations            1236
;  :quant-instantiations    1204
;  :rlimit-count            279194)
(assert (< i1@99@06 (alen<Int> (opt_get1 $Snap.unit res@68@06))))
(pop) ; 9
; Joined path conditions
(assert (< i1@99@06 (alen<Int> (opt_get1 $Snap.unit res@68@06))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@99@06)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@99@06)))
(push) ; 9
(assert (not (<
  $Perm.No
  (+
    (ite
      (and
        (<
          (inv@71@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@99@06))
          V@27@06)
        (<=
          0
          (inv@71@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@99@06))))
      $Perm.Write
      $Perm.No)
    (ite
      (and
        (<
          (inv@33@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@99@06))
          V@27@06)
        (<=
          0
          (inv@33@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@99@06))))
      $k@32@06
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               2503
;  :arith-add-rows          1242
;  :arith-assert-diseq      130
;  :arith-assert-lower      624
;  :arith-assert-upper      353
;  :arith-bound-prop        214
;  :arith-conflicts         80
;  :arith-eq-adapter        408
;  :arith-fixed-eqs         151
;  :arith-offset-eqs        183
;  :arith-pivots            497
;  :conflicts               218
;  :datatype-accessor-ax    40
;  :datatype-constructor-ax 148
;  :datatype-occurs-check   97
;  :datatype-splits         60
;  :decisions               311
;  :del-clause              2539
;  :final-checks            65
;  :interface-eqs           2
;  :max-generation          6
;  :max-memory              5.19
;  :memory                  5.18
;  :minimized-lits          8
;  :mk-bool-var             4725
;  :mk-clause               2615
;  :num-allocs              191296
;  :num-checks              124
;  :propagations            1323
;  :quant-instantiations    1257
;  :rlimit-count            283375
;  :time                    0.00)
; [eval] (None(): option[array])
(pop) ; 8
(push) ; 8
; [else-branch: 83 | !(i1@99@06 < V@27@06 && 0 <= i1@99@06)]
(assert (not (and (< i1@99@06 V@27@06) (<= 0 i1@99@06))))
(pop) ; 8
(pop) ; 7
; Joined path conditions
(assert (implies
  (and (< i1@99@06 V@27@06) (<= 0 i1@99@06))
  (and
    (< i1@99@06 V@27@06)
    (<= 0 i1@99@06)
    (< i1@99@06 (alen<Int> (opt_get1 $Snap.unit res@68@06)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@99@06)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@99@06)))))
; Joined path conditions
(pop) ; 6
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@99@06 Int)) (!
  (implies
    (and (< i1@99@06 V@27@06) (<= 0 i1@99@06))
    (and
      (< i1@99@06 V@27@06)
      (<= 0 i1@99@06)
      (< i1@99@06 (alen<Int> (opt_get1 $Snap.unit res@68@06)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@99@06)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@99@06))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@99@06))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(push) ; 6
(assert (not (forall ((i1@99@06 Int)) (!
  (implies
    (and (< i1@99@06 V@27@06) (<= 0 i1@99@06))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@99@06))
        (as None<option<array>>  option<array>))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@99@06))
  :qid |prog.l<no position>|))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               2513
;  :arith-add-rows          1258
;  :arith-assert-diseq      130
;  :arith-assert-lower      627
;  :arith-assert-upper      354
;  :arith-bound-prop        216
;  :arith-conflicts         80
;  :arith-eq-adapter        412
;  :arith-fixed-eqs         152
;  :arith-offset-eqs        184
;  :arith-pivots            507
;  :conflicts               219
;  :datatype-accessor-ax    40
;  :datatype-constructor-ax 148
;  :datatype-occurs-check   97
;  :datatype-splits         60
;  :decisions               311
;  :del-clause              2687
;  :final-checks            65
;  :interface-eqs           2
;  :max-generation          6
;  :max-memory              5.19
;  :memory                  5.17
;  :minimized-lits          8
;  :mk-bool-var             4817
;  :mk-clause               2689
;  :num-allocs              192039
;  :num-checks              125
;  :propagations            1331
;  :quant-instantiations    1286
;  :rlimit-count            285475)
(assert (forall ((i1@99@06 Int)) (!
  (implies
    (and (< i1@99@06 V@27@06) (<= 0 i1@99@06))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@99@06))
        (as None<option<array>>  option<array>))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@99@06))
  :qid |prog.l<no position>|)))
; [eval] (forall i1: Int :: { alen(opt_get1(aloc(opt_get1(target), i1).option$array$)) } 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(target), i1).option$array$)) == V)
(declare-const i1@100@06 Int)
(push) ; 6
; [eval] 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(target), i1).option$array$)) == V
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 7
; [then-branch: 84 | 0 <= i1@100@06 | live]
; [else-branch: 84 | !(0 <= i1@100@06) | live]
(push) ; 8
; [then-branch: 84 | 0 <= i1@100@06]
(assert (<= 0 i1@100@06))
; [eval] i1 < V
(pop) ; 8
(push) ; 8
; [else-branch: 84 | !(0 <= i1@100@06)]
(assert (not (<= 0 i1@100@06)))
(pop) ; 8
(pop) ; 7
; Joined path conditions
; Joined path conditions
(push) ; 7
; [then-branch: 85 | i1@100@06 < V@27@06 && 0 <= i1@100@06 | live]
; [else-branch: 85 | !(i1@100@06 < V@27@06 && 0 <= i1@100@06) | live]
(push) ; 8
; [then-branch: 85 | i1@100@06 < V@27@06 && 0 <= i1@100@06]
(assert (and (< i1@100@06 V@27@06) (<= 0 i1@100@06)))
; [eval] alen(opt_get1(aloc(opt_get1(target), i1).option$array$)) == V
; [eval] alen(opt_get1(aloc(opt_get1(target), i1).option$array$))
; [eval] opt_get1(aloc(opt_get1(target), i1).option$array$)
; [eval] aloc(opt_get1(target), i1)
; [eval] opt_get1(target)
(push) ; 9
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 9
; Joined path conditions
(push) ; 9
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 10
(assert (not (< i1@100@06 (alen<Int> (opt_get1 $Snap.unit res@68@06)))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               2513
;  :arith-add-rows          1259
;  :arith-assert-diseq      130
;  :arith-assert-lower      628
;  :arith-assert-upper      355
;  :arith-bound-prop        216
;  :arith-conflicts         80
;  :arith-eq-adapter        412
;  :arith-fixed-eqs         152
;  :arith-offset-eqs        184
;  :arith-pivots            507
;  :conflicts               219
;  :datatype-accessor-ax    40
;  :datatype-constructor-ax 148
;  :datatype-occurs-check   97
;  :datatype-splits         60
;  :decisions               311
;  :del-clause              2687
;  :final-checks            65
;  :interface-eqs           2
;  :max-generation          6
;  :max-memory              5.19
;  :memory                  5.17
;  :minimized-lits          8
;  :mk-bool-var             4820
;  :mk-clause               2689
;  :num-allocs              192348
;  :num-checks              126
;  :propagations            1331
;  :quant-instantiations    1286
;  :rlimit-count            285967)
(assert (< i1@100@06 (alen<Int> (opt_get1 $Snap.unit res@68@06))))
(pop) ; 9
; Joined path conditions
(assert (< i1@100@06 (alen<Int> (opt_get1 $Snap.unit res@68@06))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@100@06)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@100@06)))
(push) ; 9
(assert (not (<
  $Perm.No
  (+
    (ite
      (and
        (<
          (inv@71@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@100@06))
          V@27@06)
        (<=
          0
          (inv@71@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@100@06))))
      $Perm.Write
      $Perm.No)
    (ite
      (and
        (<
          (inv@33@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@100@06))
          V@27@06)
        (<=
          0
          (inv@33@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@100@06))))
      $k@32@06
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               2568
;  :arith-add-rows          1281
;  :arith-assert-diseq      132
;  :arith-assert-lower      640
;  :arith-assert-upper      366
;  :arith-bound-prop        221
;  :arith-conflicts         83
;  :arith-eq-adapter        426
;  :arith-fixed-eqs         156
;  :arith-offset-eqs        187
;  :arith-pivots            516
;  :conflicts               226
;  :datatype-accessor-ax    40
;  :datatype-constructor-ax 150
;  :datatype-occurs-check   97
;  :datatype-splits         60
;  :decisions               317
;  :del-clause              2710
;  :final-checks            65
;  :interface-eqs           2
;  :max-generation          6
;  :max-memory              5.21
;  :memory                  5.20
;  :minimized-lits          8
;  :mk-bool-var             4954
;  :mk-clause               2786
;  :num-allocs              193079
;  :num-checks              127
;  :propagations            1376
;  :quant-instantiations    1326
;  :rlimit-count            288457)
(push) ; 9
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 10
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@100@06))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               2568
;  :arith-add-rows          1281
;  :arith-assert-diseq      132
;  :arith-assert-lower      640
;  :arith-assert-upper      366
;  :arith-bound-prop        221
;  :arith-conflicts         83
;  :arith-eq-adapter        426
;  :arith-fixed-eqs         156
;  :arith-offset-eqs        187
;  :arith-pivots            516
;  :conflicts               227
;  :datatype-accessor-ax    40
;  :datatype-constructor-ax 150
;  :datatype-occurs-check   97
;  :datatype-splits         60
;  :decisions               317
;  :del-clause              2710
;  :final-checks            65
;  :interface-eqs           2
;  :max-generation          6
;  :max-memory              5.21
;  :memory                  5.20
;  :minimized-lits          8
;  :mk-bool-var             4954
;  :mk-clause               2786
;  :num-allocs              193168
;  :num-checks              128
;  :propagations            1376
;  :quant-instantiations    1326
;  :rlimit-count            288552)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@100@06))
    (as None<option<array>>  option<array>))))
(pop) ; 9
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@100@06))
    (as None<option<array>>  option<array>))))
(pop) ; 8
(push) ; 8
; [else-branch: 85 | !(i1@100@06 < V@27@06 && 0 <= i1@100@06)]
(assert (not (and (< i1@100@06 V@27@06) (<= 0 i1@100@06))))
(pop) ; 8
(pop) ; 7
; Joined path conditions
(assert (implies
  (and (< i1@100@06 V@27@06) (<= 0 i1@100@06))
  (and
    (< i1@100@06 V@27@06)
    (<= 0 i1@100@06)
    (< i1@100@06 (alen<Int> (opt_get1 $Snap.unit res@68@06)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@100@06)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@100@06))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@100@06))
        (as None<option<array>>  option<array>))))))
; Joined path conditions
(pop) ; 6
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@100@06 Int)) (!
  (implies
    (and (< i1@100@06 V@27@06) (<= 0 i1@100@06))
    (and
      (< i1@100@06 V@27@06)
      (<= 0 i1@100@06)
      (< i1@100@06 (alen<Int> (opt_get1 $Snap.unit res@68@06)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@100@06)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@100@06))
      (not
        (=
          ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@100@06))
          (as None<option<array>>  option<array>)))))
  :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@100@06)))))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(push) ; 6
(assert (not (forall ((i1@100@06 Int)) (!
  (implies
    (and (< i1@100@06 V@27@06) (<= 0 i1@100@06))
    (=
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@100@06))))
      V@27@06))
  :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@100@06)))))
  :qid |prog.l<no position>|))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               2572
;  :arith-add-rows          1291
;  :arith-assert-diseq      133
;  :arith-assert-lower      642
;  :arith-assert-upper      367
;  :arith-bound-prop        221
;  :arith-conflicts         83
;  :arith-eq-adapter        430
;  :arith-fixed-eqs         156
;  :arith-offset-eqs        187
;  :arith-pivots            521
;  :conflicts               228
;  :datatype-accessor-ax    40
;  :datatype-constructor-ax 150
;  :datatype-occurs-check   97
;  :datatype-splits         60
;  :decisions               317
;  :del-clause              2846
;  :final-checks            65
;  :interface-eqs           2
;  :max-generation          6
;  :max-memory              5.21
;  :memory                  5.20
;  :minimized-lits          8
;  :mk-bool-var             5037
;  :mk-clause               2848
;  :num-allocs              193875
;  :num-checks              129
;  :propagations            1381
;  :quant-instantiations    1357
;  :rlimit-count            290548)
(assert (forall ((i1@100@06 Int)) (!
  (implies
    (and (< i1@100@06 V@27@06) (<= 0 i1@100@06))
    (=
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@100@06))))
      V@27@06))
  :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@100@06)))))
  :qid |prog.l<no position>|)))
; [eval] (forall i1: Int :: { aloc(opt_get1(target), i1) } (forall i2: Int :: { aloc(opt_get1(target), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(target), i1).option$array$ == aloc(opt_get1(target), i2).option$array$ ==> i1 == i2))
(declare-const i1@101@06 Int)
(push) ; 6
; [eval] (forall i2: Int :: { aloc(opt_get1(target), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(target), i1).option$array$ == aloc(opt_get1(target), i2).option$array$ ==> i1 == i2)
(declare-const i2@102@06 Int)
(push) ; 7
; [eval] 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(target), i1).option$array$ == aloc(opt_get1(target), i2).option$array$ ==> i1 == i2
; [eval] 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(target), i1).option$array$ == aloc(opt_get1(target), i2).option$array$
; [eval] 0 <= i1
(push) ; 8
; [then-branch: 86 | 0 <= i1@101@06 | live]
; [else-branch: 86 | !(0 <= i1@101@06) | live]
(push) ; 9
; [then-branch: 86 | 0 <= i1@101@06]
(assert (<= 0 i1@101@06))
; [eval] i1 < V
(push) ; 10
; [then-branch: 87 | i1@101@06 < V@27@06 | live]
; [else-branch: 87 | !(i1@101@06 < V@27@06) | live]
(push) ; 11
; [then-branch: 87 | i1@101@06 < V@27@06]
(assert (< i1@101@06 V@27@06))
; [eval] 0 <= i2
(push) ; 12
; [then-branch: 88 | 0 <= i2@102@06 | live]
; [else-branch: 88 | !(0 <= i2@102@06) | live]
(push) ; 13
; [then-branch: 88 | 0 <= i2@102@06]
(assert (<= 0 i2@102@06))
; [eval] i2 < V
(push) ; 14
; [then-branch: 89 | i2@102@06 < V@27@06 | live]
; [else-branch: 89 | !(i2@102@06 < V@27@06) | live]
(push) ; 15
; [then-branch: 89 | i2@102@06 < V@27@06]
(assert (< i2@102@06 V@27@06))
; [eval] aloc(opt_get1(target), i1).option$array$ == aloc(opt_get1(target), i2).option$array$
; [eval] aloc(opt_get1(target), i1)
; [eval] opt_get1(target)
(push) ; 16
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 16
; Joined path conditions
(push) ; 16
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 17
(assert (not (< i1@101@06 (alen<Int> (opt_get1 $Snap.unit res@68@06)))))
(check-sat)
; unsat
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               2572
;  :arith-add-rows          1293
;  :arith-assert-diseq      133
;  :arith-assert-lower      646
;  :arith-assert-upper      367
;  :arith-bound-prop        221
;  :arith-conflicts         83
;  :arith-eq-adapter        430
;  :arith-fixed-eqs         156
;  :arith-offset-eqs        187
;  :arith-pivots            522
;  :conflicts               228
;  :datatype-accessor-ax    40
;  :datatype-constructor-ax 150
;  :datatype-occurs-check   97
;  :datatype-splits         60
;  :decisions               317
;  :del-clause              2846
;  :final-checks            65
;  :interface-eqs           2
;  :max-generation          6
;  :max-memory              5.21
;  :memory                  5.20
;  :minimized-lits          8
;  :mk-bool-var             5042
;  :mk-clause               2848
;  :num-allocs              194355
;  :num-checks              130
;  :propagations            1381
;  :quant-instantiations    1357
;  :rlimit-count            291199)
(assert (< i1@101@06 (alen<Int> (opt_get1 $Snap.unit res@68@06))))
(pop) ; 16
; Joined path conditions
(assert (< i1@101@06 (alen<Int> (opt_get1 $Snap.unit res@68@06))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@101@06)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@101@06)))
(push) ; 16
(assert (not (<
  $Perm.No
  (+
    (ite
      (and
        (<
          (inv@71@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@101@06))
          V@27@06)
        (<=
          0
          (inv@71@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@101@06))))
      $Perm.Write
      $Perm.No)
    (ite
      (and
        (<
          (inv@33@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@101@06))
          V@27@06)
        (<=
          0
          (inv@33@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@101@06))))
      $k@32@06
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               2618
;  :arith-add-rows          1319
;  :arith-assert-diseq      135
;  :arith-assert-lower      658
;  :arith-assert-upper      378
;  :arith-bound-prop        227
;  :arith-conflicts         86
;  :arith-eq-adapter        443
;  :arith-fixed-eqs         160
;  :arith-offset-eqs        190
;  :arith-pivots            529
;  :conflicts               234
;  :datatype-accessor-ax    40
;  :datatype-constructor-ax 152
;  :datatype-occurs-check   97
;  :datatype-splits         60
;  :decisions               322
;  :del-clause              2861
;  :final-checks            65
;  :interface-eqs           2
;  :max-generation          6
;  :max-memory              5.22
;  :memory                  5.21
;  :minimized-lits          8
;  :mk-bool-var             5166
;  :mk-clause               2937
;  :num-allocs              195059
;  :num-checks              131
;  :propagations            1417
;  :quant-instantiations    1397
;  :rlimit-count            293755)
; [eval] aloc(opt_get1(target), i2)
; [eval] opt_get1(target)
(push) ; 16
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 16
; Joined path conditions
(push) ; 16
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 17
(assert (not (< i2@102@06 (alen<Int> (opt_get1 $Snap.unit res@68@06)))))
(check-sat)
; unsat
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               2618
;  :arith-add-rows          1319
;  :arith-assert-diseq      135
;  :arith-assert-lower      658
;  :arith-assert-upper      378
;  :arith-bound-prop        227
;  :arith-conflicts         86
;  :arith-eq-adapter        443
;  :arith-fixed-eqs         160
;  :arith-offset-eqs        190
;  :arith-pivots            529
;  :conflicts               234
;  :datatype-accessor-ax    40
;  :datatype-constructor-ax 152
;  :datatype-occurs-check   97
;  :datatype-splits         60
;  :decisions               322
;  :del-clause              2861
;  :final-checks            65
;  :interface-eqs           2
;  :max-generation          6
;  :max-memory              5.22
;  :memory                  5.21
;  :minimized-lits          8
;  :mk-bool-var             5166
;  :mk-clause               2937
;  :num-allocs              195085
;  :num-checks              132
;  :propagations            1417
;  :quant-instantiations    1397
;  :rlimit-count            293785)
(assert (< i2@102@06 (alen<Int> (opt_get1 $Snap.unit res@68@06))))
(pop) ; 16
; Joined path conditions
(assert (< i2@102@06 (alen<Int> (opt_get1 $Snap.unit res@68@06))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit res@68@06) i2@102@06)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit res@68@06) i2@102@06)))
(push) ; 16
(assert (not (<
  $Perm.No
  (+
    (ite
      (and
        (<
          (inv@71@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@68@06) i2@102@06))
          V@27@06)
        (<=
          0
          (inv@71@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@68@06) i2@102@06))))
      $Perm.Write
      $Perm.No)
    (ite
      (and
        (<
          (inv@33@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@68@06) i2@102@06))
          V@27@06)
        (<=
          0
          (inv@33@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@68@06) i2@102@06))))
      $k@32@06
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 16
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               2955
;  :arith-add-rows          1502
;  :arith-assert-diseq      171
;  :arith-assert-lower      782
;  :arith-assert-upper      453
;  :arith-bound-prop        266
;  :arith-conflicts         93
;  :arith-eq-adapter        519
;  :arith-fixed-eqs         188
;  :arith-offset-eqs        239
;  :arith-pivots            571
;  :conflicts               247
;  :datatype-accessor-ax    40
;  :datatype-constructor-ax 154
;  :datatype-occurs-check   97
;  :datatype-splits         60
;  :decisions               358
;  :del-clause              3293
;  :final-checks            65
;  :interface-eqs           2
;  :max-generation          6
;  :max-memory              5.49
;  :memory                  5.48
;  :minimized-lits          8
;  :mk-bool-var             5801
;  :mk-clause               3440
;  :num-allocs              198173
;  :num-checks              133
;  :propagations            1739
;  :quant-instantiations    1586
;  :rlimit-count            308171
;  :time                    0.01)
(pop) ; 15
(push) ; 15
; [else-branch: 89 | !(i2@102@06 < V@27@06)]
(assert (not (< i2@102@06 V@27@06)))
(pop) ; 15
(pop) ; 14
; Joined path conditions
(assert (implies
  (< i2@102@06 V@27@06)
  (and
    (< i2@102@06 V@27@06)
    (< i1@101@06 (alen<Int> (opt_get1 $Snap.unit res@68@06)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@101@06)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@101@06))
    (< i2@102@06 (alen<Int> (opt_get1 $Snap.unit res@68@06)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@68@06) i2@102@06)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@68@06) i2@102@06)))))
; Joined path conditions
(pop) ; 13
(push) ; 13
; [else-branch: 88 | !(0 <= i2@102@06)]
(assert (not (<= 0 i2@102@06)))
(pop) ; 13
(pop) ; 12
; Joined path conditions
(assert (implies
  (<= 0 i2@102@06)
  (and
    (<= 0 i2@102@06)
    (implies
      (< i2@102@06 V@27@06)
      (and
        (< i2@102@06 V@27@06)
        (< i1@101@06 (alen<Int> (opt_get1 $Snap.unit res@68@06)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@101@06)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@101@06))
        (< i2@102@06 (alen<Int> (opt_get1 $Snap.unit res@68@06)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@68@06) i2@102@06)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@68@06) i2@102@06)))))))
; Joined path conditions
(pop) ; 11
(push) ; 11
; [else-branch: 87 | !(i1@101@06 < V@27@06)]
(assert (not (< i1@101@06 V@27@06)))
(pop) ; 11
(pop) ; 10
; Joined path conditions
(assert (implies
  (< i1@101@06 V@27@06)
  (and
    (< i1@101@06 V@27@06)
    (implies
      (<= 0 i2@102@06)
      (and
        (<= 0 i2@102@06)
        (implies
          (< i2@102@06 V@27@06)
          (and
            (< i2@102@06 V@27@06)
            (< i1@101@06 (alen<Int> (opt_get1 $Snap.unit res@68@06)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@101@06)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@101@06))
            (< i2@102@06 (alen<Int> (opt_get1 $Snap.unit res@68@06)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit res@68@06) i2@102@06)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit res@68@06) i2@102@06)))))))))
; Joined path conditions
(pop) ; 9
(push) ; 9
; [else-branch: 86 | !(0 <= i1@101@06)]
(assert (not (<= 0 i1@101@06)))
(pop) ; 9
(pop) ; 8
; Joined path conditions
(assert (implies
  (<= 0 i1@101@06)
  (and
    (<= 0 i1@101@06)
    (implies
      (< i1@101@06 V@27@06)
      (and
        (< i1@101@06 V@27@06)
        (implies
          (<= 0 i2@102@06)
          (and
            (<= 0 i2@102@06)
            (implies
              (< i2@102@06 V@27@06)
              (and
                (< i2@102@06 V@27@06)
                (< i1@101@06 (alen<Int> (opt_get1 $Snap.unit res@68@06)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@101@06)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@101@06))
                (< i2@102@06 (alen<Int> (opt_get1 $Snap.unit res@68@06)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit res@68@06) i2@102@06)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit res@68@06) i2@102@06)))))))))))
; Joined path conditions
(push) ; 8
; [then-branch: 90 | Lookup(option$array$,sm@72@06,aloc((_, _), opt_get1(_, res@68@06), i1@101@06)) == Lookup(option$array$,sm@72@06,aloc((_, _), opt_get1(_, res@68@06), i2@102@06)) && i2@102@06 < V@27@06 && 0 <= i2@102@06 && i1@101@06 < V@27@06 && 0 <= i1@101@06 | live]
; [else-branch: 90 | !(Lookup(option$array$,sm@72@06,aloc((_, _), opt_get1(_, res@68@06), i1@101@06)) == Lookup(option$array$,sm@72@06,aloc((_, _), opt_get1(_, res@68@06), i2@102@06)) && i2@102@06 < V@27@06 && 0 <= i2@102@06 && i1@101@06 < V@27@06 && 0 <= i1@101@06) | live]
(push) ; 9
; [then-branch: 90 | Lookup(option$array$,sm@72@06,aloc((_, _), opt_get1(_, res@68@06), i1@101@06)) == Lookup(option$array$,sm@72@06,aloc((_, _), opt_get1(_, res@68@06), i2@102@06)) && i2@102@06 < V@27@06 && 0 <= i2@102@06 && i1@101@06 < V@27@06 && 0 <= i1@101@06]
(assert (and
  (and
    (and
      (and
        (=
          ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@101@06))
          ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit res@68@06) i2@102@06)))
        (< i2@102@06 V@27@06))
      (<= 0 i2@102@06))
    (< i1@101@06 V@27@06))
  (<= 0 i1@101@06)))
; [eval] i1 == i2
(pop) ; 9
(push) ; 9
; [else-branch: 90 | !(Lookup(option$array$,sm@72@06,aloc((_, _), opt_get1(_, res@68@06), i1@101@06)) == Lookup(option$array$,sm@72@06,aloc((_, _), opt_get1(_, res@68@06), i2@102@06)) && i2@102@06 < V@27@06 && 0 <= i2@102@06 && i1@101@06 < V@27@06 && 0 <= i1@101@06)]
(assert (not
  (and
    (and
      (and
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@101@06))
            ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit res@68@06) i2@102@06)))
          (< i2@102@06 V@27@06))
        (<= 0 i2@102@06))
      (< i1@101@06 V@27@06))
    (<= 0 i1@101@06))))
(pop) ; 9
(pop) ; 8
; Joined path conditions
(assert (implies
  (and
    (and
      (and
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@101@06))
            ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit res@68@06) i2@102@06)))
          (< i2@102@06 V@27@06))
        (<= 0 i2@102@06))
      (< i1@101@06 V@27@06))
    (<= 0 i1@101@06))
  (and
    (=
      ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@101@06))
      ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit res@68@06) i2@102@06)))
    (< i2@102@06 V@27@06)
    (<= 0 i2@102@06)
    (< i1@101@06 V@27@06)
    (<= 0 i1@101@06))))
; Joined path conditions
(pop) ; 7
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i2@102@06 Int)) (!
  (and
    (implies
      (<= 0 i1@101@06)
      (and
        (<= 0 i1@101@06)
        (implies
          (< i1@101@06 V@27@06)
          (and
            (< i1@101@06 V@27@06)
            (implies
              (<= 0 i2@102@06)
              (and
                (<= 0 i2@102@06)
                (implies
                  (< i2@102@06 V@27@06)
                  (and
                    (< i2@102@06 V@27@06)
                    (< i1@101@06 (alen<Int> (opt_get1 $Snap.unit res@68@06)))
                    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@101@06)) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@101@06))
                    (< i2@102@06 (alen<Int> (opt_get1 $Snap.unit res@68@06)))
                    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit res@68@06) i2@102@06)) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit res@68@06) i2@102@06))))))))))
    (implies
      (and
        (and
          (and
            (and
              (=
                ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@101@06))
                ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit res@68@06) i2@102@06)))
              (< i2@102@06 V@27@06))
            (<= 0 i2@102@06))
          (< i1@101@06 V@27@06))
        (<= 0 i1@101@06))
      (and
        (=
          ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@101@06))
          ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit res@68@06) i2@102@06)))
        (< i2@102@06 V@27@06)
        (<= 0 i2@102@06)
        (< i1@101@06 V@27@06)
        (<= 0 i1@101@06))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@68@06) i2@102@06))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 6
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@101@06 Int)) (!
  (forall ((i2@102@06 Int)) (!
    (and
      (implies
        (<= 0 i1@101@06)
        (and
          (<= 0 i1@101@06)
          (implies
            (< i1@101@06 V@27@06)
            (and
              (< i1@101@06 V@27@06)
              (implies
                (<= 0 i2@102@06)
                (and
                  (<= 0 i2@102@06)
                  (implies
                    (< i2@102@06 V@27@06)
                    (and
                      (< i2@102@06 V@27@06)
                      (< i1@101@06 (alen<Int> (opt_get1 $Snap.unit res@68@06)))
                      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@101@06)) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@101@06))
                      (< i2@102@06 (alen<Int> (opt_get1 $Snap.unit res@68@06)))
                      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit res@68@06) i2@102@06)) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit res@68@06) i2@102@06))))))))))
      (implies
        (and
          (and
            (and
              (and
                (=
                  ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@101@06))
                  ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit res@68@06) i2@102@06)))
                (< i2@102@06 V@27@06))
              (<= 0 i2@102@06))
            (< i1@101@06 V@27@06))
          (<= 0 i1@101@06))
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@101@06))
            ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit res@68@06) i2@102@06)))
          (< i2@102@06 V@27@06)
          (<= 0 i2@102@06)
          (< i1@101@06 V@27@06)
          (<= 0 i1@101@06))))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@68@06) i2@102@06))
    :qid |prog.l<no position>-aux|))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@101@06))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(push) ; 6
(assert (not (forall ((i1@101@06 Int)) (!
  (forall ((i2@102@06 Int)) (!
    (implies
      (and
        (and
          (and
            (and
              (=
                ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@101@06))
                ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit res@68@06) i2@102@06)))
              (< i2@102@06 V@27@06))
            (<= 0 i2@102@06))
          (< i1@101@06 V@27@06))
        (<= 0 i1@101@06))
      (= i1@101@06 i2@102@06))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@68@06) i2@102@06))
    :qid |prog.l<no position>|))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@101@06))
  :qid |prog.l<no position>|))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               2966
;  :arith-add-rows          1526
;  :arith-assert-diseq      173
;  :arith-assert-lower      787
;  :arith-assert-upper      454
;  :arith-bound-prop        267
;  :arith-conflicts         93
;  :arith-eq-adapter        528
;  :arith-fixed-eqs         189
;  :arith-offset-eqs        239
;  :arith-pivots            585
;  :conflicts               248
;  :datatype-accessor-ax    40
;  :datatype-constructor-ax 154
;  :datatype-occurs-check   97
;  :datatype-splits         60
;  :decisions               358
;  :del-clause              3607
;  :final-checks            65
;  :interface-eqs           2
;  :max-generation          6
;  :max-memory              5.49
;  :memory                  5.47
;  :minimized-lits          8
;  :mk-bool-var             6007
;  :mk-clause               3609
;  :num-allocs              199817
;  :num-checks              134
;  :propagations            1747
;  :quant-instantiations    1649
;  :rlimit-count            313778
;  :time                    0.00)
(assert (forall ((i1@101@06 Int)) (!
  (forall ((i2@102@06 Int)) (!
    (implies
      (and
        (and
          (and
            (and
              (=
                ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@101@06))
                ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit res@68@06) i2@102@06)))
              (< i2@102@06 V@27@06))
            (<= 0 i2@102@06))
          (< i1@101@06 V@27@06))
        (<= 0 i1@101@06))
      (= i1@101@06 i2@102@06))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@68@06) i2@102@06))
    :qid |prog.l<no position>|))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@101@06))
  :qid |prog.l<no position>|)))
(declare-const i1@103@06 Int)
(declare-const j1@104@06 Int)
(push) ; 6
; [eval] 0 <= i1 && i1 < V && (0 <= j1 && j1 < V)
; [eval] 0 <= i1
(push) ; 7
; [then-branch: 91 | 0 <= i1@103@06 | live]
; [else-branch: 91 | !(0 <= i1@103@06) | live]
(push) ; 8
; [then-branch: 91 | 0 <= i1@103@06]
(assert (<= 0 i1@103@06))
; [eval] i1 < V
(push) ; 9
; [then-branch: 92 | i1@103@06 < V@27@06 | live]
; [else-branch: 92 | !(i1@103@06 < V@27@06) | live]
(push) ; 10
; [then-branch: 92 | i1@103@06 < V@27@06]
(assert (< i1@103@06 V@27@06))
; [eval] 0 <= j1
(push) ; 11
; [then-branch: 93 | 0 <= j1@104@06 | live]
; [else-branch: 93 | !(0 <= j1@104@06) | live]
(push) ; 12
; [then-branch: 93 | 0 <= j1@104@06]
(assert (<= 0 j1@104@06))
; [eval] j1 < V
(pop) ; 12
(push) ; 12
; [else-branch: 93 | !(0 <= j1@104@06)]
(assert (not (<= 0 j1@104@06)))
(pop) ; 12
(pop) ; 11
; Joined path conditions
; Joined path conditions
(pop) ; 10
(push) ; 10
; [else-branch: 92 | !(i1@103@06 < V@27@06)]
(assert (not (< i1@103@06 V@27@06)))
(pop) ; 10
(pop) ; 9
; Joined path conditions
; Joined path conditions
(pop) ; 8
(push) ; 8
; [else-branch: 91 | !(0 <= i1@103@06)]
(assert (not (<= 0 i1@103@06)))
(pop) ; 8
(pop) ; 7
; Joined path conditions
; Joined path conditions
(assert (and
  (and (and (< j1@104@06 V@27@06) (<= 0 j1@104@06)) (< i1@103@06 V@27@06))
  (<= 0 i1@103@06)))
; [eval] aloc(opt_get1(aloc(opt_get1(source), i1).option$array$), j1)
; [eval] opt_get1(aloc(opt_get1(source), i1).option$array$)
; [eval] aloc(opt_get1(source), i1)
; [eval] opt_get1(source)
(push) ; 7
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 7
; Joined path conditions
(push) ; 7
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 8
(assert (not (< i1@103@06 (alen<Int> (opt_get1 $Snap.unit G@24@06)))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               2966
;  :arith-add-rows          1529
;  :arith-assert-diseq      173
;  :arith-assert-lower      793
;  :arith-assert-upper      454
;  :arith-bound-prop        267
;  :arith-conflicts         93
;  :arith-eq-adapter        528
;  :arith-fixed-eqs         189
;  :arith-offset-eqs        239
;  :arith-pivots            588
;  :conflicts               248
;  :datatype-accessor-ax    40
;  :datatype-constructor-ax 154
;  :datatype-occurs-check   97
;  :datatype-splits         60
;  :decisions               358
;  :del-clause              3607
;  :final-checks            65
;  :interface-eqs           2
;  :max-generation          6
;  :max-memory              5.49
;  :memory                  5.47
;  :minimized-lits          8
;  :mk-bool-var             6014
;  :mk-clause               3609
;  :num-allocs              200417
;  :num-checks              135
;  :propagations            1747
;  :quant-instantiations    1649
;  :rlimit-count            314792)
(assert (< i1@103@06 (alen<Int> (opt_get1 $Snap.unit G@24@06))))
(pop) ; 7
; Joined path conditions
(assert (< i1@103@06 (alen<Int> (opt_get1 $Snap.unit G@24@06))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@103@06)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@103@06)))
(push) ; 7
(assert (not (<
  $Perm.No
  (+
    (ite
      (and
        (<
          (inv@71@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@103@06))
          V@27@06)
        (<=
          0
          (inv@71@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@103@06))))
      $Perm.Write
      $Perm.No)
    (ite
      (and
        (<
          (inv@33@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@103@06))
          V@27@06)
        (<=
          0
          (inv@33@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@103@06))))
      $k@32@06
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               3025
;  :arith-add-rows          1580
;  :arith-assert-diseq      176
;  :arith-assert-lower      814
;  :arith-assert-upper      465
;  :arith-bound-prop        278
;  :arith-conflicts         95
;  :arith-eq-adapter        544
;  :arith-fixed-eqs         194
;  :arith-offset-eqs        247
;  :arith-pivots            601
;  :conflicts               254
;  :datatype-accessor-ax    40
;  :datatype-constructor-ax 156
;  :datatype-occurs-check   97
;  :datatype-splits         60
;  :decisions               363
;  :del-clause              3643
;  :final-checks            65
;  :interface-eqs           2
;  :max-generation          6
;  :max-memory              5.49
;  :memory                  5.48
;  :minimized-lits          8
;  :mk-bool-var             6160
;  :mk-clause               3715
;  :num-allocs              201310
;  :num-checks              136
;  :propagations            1795
;  :quant-instantiations    1684
;  :rlimit-count            318058)
(push) ; 7
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 8
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@103@06))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               3025
;  :arith-add-rows          1580
;  :arith-assert-diseq      176
;  :arith-assert-lower      814
;  :arith-assert-upper      465
;  :arith-bound-prop        278
;  :arith-conflicts         95
;  :arith-eq-adapter        544
;  :arith-fixed-eqs         194
;  :arith-offset-eqs        247
;  :arith-pivots            601
;  :conflicts               255
;  :datatype-accessor-ax    40
;  :datatype-constructor-ax 156
;  :datatype-occurs-check   97
;  :datatype-splits         60
;  :decisions               363
;  :del-clause              3643
;  :final-checks            65
;  :interface-eqs           2
;  :max-generation          6
;  :max-memory              5.49
;  :memory                  5.48
;  :minimized-lits          8
;  :mk-bool-var             6160
;  :mk-clause               3715
;  :num-allocs              201400
;  :num-checks              137
;  :propagations            1795
;  :quant-instantiations    1684
;  :rlimit-count            318153)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@103@06))
    (as None<option<array>>  option<array>))))
(pop) ; 7
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@103@06))
    (as None<option<array>>  option<array>))))
(push) ; 7
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 8
(assert (not (<
  j1@104@06
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@103@06)))))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               3031
;  :arith-add-rows          1586
;  :arith-assert-diseq      176
;  :arith-assert-lower      817
;  :arith-assert-upper      466
;  :arith-bound-prop        278
;  :arith-conflicts         96
;  :arith-eq-adapter        545
;  :arith-fixed-eqs         195
;  :arith-offset-eqs        247
;  :arith-pivots            605
;  :conflicts               256
;  :datatype-accessor-ax    40
;  :datatype-constructor-ax 156
;  :datatype-occurs-check   97
;  :datatype-splits         60
;  :decisions               363
;  :del-clause              3647
;  :final-checks            65
;  :interface-eqs           2
;  :max-generation          6
;  :max-memory              5.49
;  :memory                  5.48
;  :minimized-lits          8
;  :mk-bool-var             6171
;  :mk-clause               3719
;  :num-allocs              201594
;  :num-checks              138
;  :propagations            1797
;  :quant-instantiations    1691
;  :rlimit-count            318661)
(assert (<
  j1@104@06
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@103@06))))))
(pop) ; 7
; Joined path conditions
(assert (<
  j1@104@06
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@103@06))))))
(pop) ; 6
(declare-fun inv@105@06 ($Ref) Int)
(declare-fun inv@106@06 ($Ref) Int)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(assert (forall ((i1@103@06 Int) (j1@104@06 Int)) (!
  (and
    (< i1@103@06 (alen<Int> (opt_get1 $Snap.unit G@24@06)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@103@06)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@103@06))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@103@06))
        (as None<option<array>>  option<array>)))
    (<
      j1@104@06
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@103@06))))))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@103@06))) j1@104@06))
  :qid |int-aux|)))
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 6
(assert (not (forall ((i11@103@06 Int) (j11@104@06 Int) (i12@103@06 Int) (j12@104@06 Int)) (!
  (implies
    (and
      (and
        (and
          (and
            (and (< j11@104@06 V@27@06) (<= 0 j11@104@06))
            (< i11@103@06 V@27@06))
          (<= 0 i11@103@06))
        ($FVF.loc_int ($FVF.lookup_int (as sm@81@06  $FVF<Int>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@24@06) i11@103@06))) j11@104@06)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@24@06) i11@103@06))) j11@104@06)))
      (and
        (and
          (and
            (and (< j12@104@06 V@27@06) (<= 0 j12@104@06))
            (< i12@103@06 V@27@06))
          (<= 0 i12@103@06))
        ($FVF.loc_int ($FVF.lookup_int (as sm@81@06  $FVF<Int>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@24@06) i12@103@06))) j12@104@06)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@24@06) i12@103@06))) j12@104@06)))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@24@06) i11@103@06))) j11@104@06)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@24@06) i12@103@06))) j12@104@06)))
    (and (= i11@103@06 i12@103@06) (= j11@104@06 j12@104@06)))
  
  :qid |int-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               3084
;  :arith-add-rows          1624
;  :arith-assert-diseq      176
;  :arith-assert-lower      830
;  :arith-assert-upper      469
;  :arith-bound-prop        282
;  :arith-conflicts         96
;  :arith-eq-adapter        555
;  :arith-fixed-eqs         197
;  :arith-offset-eqs        253
;  :arith-pivots            622
;  :conflicts               257
;  :datatype-accessor-ax    40
;  :datatype-constructor-ax 156
;  :datatype-occurs-check   97
;  :datatype-splits         60
;  :decisions               363
;  :del-clause              3910
;  :final-checks            65
;  :interface-eqs           2
;  :max-generation          6
;  :max-memory              5.52
;  :memory                  5.49
;  :minimized-lits          8
;  :mk-bool-var             6474
;  :mk-clause               3912
;  :num-allocs              203368
;  :num-checks              139
;  :propagations            1835
;  :quant-instantiations    1794
;  :rlimit-count            325228
;  :time                    0.00)
; Definitional axioms for inverse functions
(assert (forall ((i1@103@06 Int) (j1@104@06 Int)) (!
  (implies
    (and
      (and (and (< j1@104@06 V@27@06) (<= 0 j1@104@06)) (< i1@103@06 V@27@06))
      (<= 0 i1@103@06))
    (and
      (=
        (inv@105@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@103@06))) j1@104@06))
        i1@103@06)
      (=
        (inv@106@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@103@06))) j1@104@06))
        j1@104@06)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@103@06))) j1@104@06))
  :qid |int-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@106@06 r) V@27@06) (<= 0 (inv@106@06 r)))
        (< (inv@105@06 r) V@27@06))
      (<= 0 (inv@105@06 r)))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@24@06) (inv@105@06 r)))) (inv@106@06 r))
      r))
  :pattern ((inv@105@06 r))
  :pattern ((inv@106@06 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@106@06 r) V@27@06) (<= 0 (inv@106@06 r)))
        (< (inv@105@06 r) V@27@06))
      (<= 0 (inv@105@06 r)))
    ($FVF.loc_int ($FVF.lookup_int (as sm@81@06  $FVF<Int>) r) r))
  :pattern ((inv@105@06 r) (inv@106@06 r))
  )))
; Precomputing data for removing quantified permissions
(define-fun pTaken@107@06 ((r $Ref)) $Perm
  (ite
    (and
      (and
        (and (< (inv@106@06 r) V@27@06) (<= 0 (inv@106@06 r)))
        (< (inv@105@06 r) V@27@06))
      (<= 0 (inv@105@06 r)))
    ($Perm.min
      (ite
        (and
          (and
            (and (< (inv@80@06 r) V@27@06) (<= 0 (inv@80@06 r)))
            (< (inv@79@06 r) V@27@06))
          (<= 0 (inv@79@06 r)))
        $Perm.Write
        $Perm.No)
      $Perm.Write)
    $Perm.No))
(define-fun pTaken@108@06 ((r $Ref)) $Perm
  (ite
    (and
      (and
        (and (< (inv@106@06 r) V@27@06) (<= 0 (inv@106@06 r)))
        (< (inv@105@06 r) V@27@06))
      (<= 0 (inv@105@06 r)))
    ($Perm.min
      (ite
        (and
          (and
            (and (< (inv@42@06 r) V@27@06) (<= 0 (inv@42@06 r)))
            (< (inv@41@06 r) V@27@06))
          (<= 0 (inv@41@06 r)))
        $Perm.Write
        $Perm.No)
      (- $Perm.Write (pTaken@107@06 r)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 500)
(push) ; 6
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and
          (and
            (and (< (inv@80@06 r) V@27@06) (<= 0 (inv@80@06 r)))
            (< (inv@79@06 r) V@27@06))
          (<= 0 (inv@79@06 r)))
        $Perm.Write
        $Perm.No)
      (pTaken@107@06 r))
    $Perm.No)
  
  ))))
(check-sat)
; unknown
(pop) ; 6
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               3462
;  :arith-add-rows          1736
;  :arith-assert-diseq      198
;  :arith-assert-lower      928
;  :arith-assert-upper      551
;  :arith-bound-prop        309
;  :arith-conflicts         99
;  :arith-eq-adapter        633
;  :arith-fixed-eqs         231
;  :arith-offset-eqs        270
;  :arith-pivots            675
;  :conflicts               266
;  :datatype-accessor-ax    42
;  :datatype-constructor-ax 170
;  :datatype-occurs-check   108
;  :datatype-splits         71
;  :decisions               431
;  :del-clause              4445
;  :final-checks            75
;  :interface-eqs           6
;  :max-generation          7
;  :max-memory              5.59
;  :memory                  5.54
;  :minimized-lits          9
;  :mk-bool-var             7209
;  :mk-clause               4445
;  :num-allocs              208444
;  :num-checks              141
;  :propagations            2070
;  :quant-instantiations    1975
;  :rlimit-count            338912
;  :time                    0.01)
; Intermediate check if already taken enough permissions
(push) ; 6
(assert (not (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@106@06 r) V@27@06) (<= 0 (inv@106@06 r)))
        (< (inv@105@06 r) V@27@06))
      (<= 0 (inv@105@06 r)))
    (= (- $Perm.Write (pTaken@107@06 r)) $Perm.No))
  
  ))))
(check-sat)
; unknown
(pop) ; 6
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               3740
;  :arith-add-rows          1880
;  :arith-assert-diseq      213
;  :arith-assert-lower      997
;  :arith-assert-upper      596
;  :arith-bound-prop        331
;  :arith-conflicts         104
;  :arith-eq-adapter        676
;  :arith-fixed-eqs         254
;  :arith-offset-eqs        300
;  :arith-pivots            726
;  :conflicts               274
;  :datatype-accessor-ax    44
;  :datatype-constructor-ax 180
;  :datatype-occurs-check   116
;  :datatype-splits         80
;  :decisions               476
;  :del-clause              4748
;  :final-checks            79
;  :interface-eqs           6
;  :max-generation          7
;  :max-memory              5.63
;  :memory                  5.57
;  :minimized-lits          9
;  :mk-bool-var             7616
;  :mk-clause               4748
;  :num-allocs              211269
;  :num-checks              142
;  :propagations            2195
;  :quant-instantiations    2079
;  :rlimit-count            348841
;  :time                    0.01)
; Chunk depleted?
(push) ; 6
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and
          (and
            (and (< (inv@42@06 r) V@27@06) (<= 0 (inv@42@06 r)))
            (< (inv@41@06 r) V@27@06))
          (<= 0 (inv@41@06 r)))
        $Perm.Write
        $Perm.No)
      (pTaken@108@06 r))
    $Perm.No)
  
  ))))
(check-sat)
; unknown
(pop) ; 6
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               4444
;  :arith-add-rows          2202
;  :arith-assert-diseq      274
;  :arith-assert-lower      1263
;  :arith-assert-upper      749
;  :arith-bound-prop        392
;  :arith-conflicts         112
;  :arith-eq-adapter        833
;  :arith-fixed-eqs         330
;  :arith-offset-eqs        380
;  :arith-pivots            835
;  :conflicts               289
;  :datatype-accessor-ax    46
;  :datatype-constructor-ax 190
;  :datatype-occurs-check   124
;  :datatype-splits         89
;  :decisions               589
;  :del-clause              5530
;  :final-checks            83
;  :interface-eqs           6
;  :max-generation          7
;  :max-memory              5.80
;  :memory                  5.74
;  :minimized-lits          10
;  :mk-bool-var             8657
;  :mk-clause               5530
;  :num-allocs              217026
;  :num-checks              143
;  :propagations            2613
;  :quant-instantiations    2288
;  :rlimit-count            369777
;  :time                    0.01)
; Intermediate check if already taken enough permissions
(push) ; 6
(assert (not (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@106@06 r) V@27@06) (<= 0 (inv@106@06 r)))
        (< (inv@105@06 r) V@27@06))
      (<= 0 (inv@105@06 r)))
    (= (- (- $Perm.Write (pTaken@107@06 r)) (pTaken@108@06 r)) $Perm.No))
  
  ))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               4671
;  :arith-add-rows          2325
;  :arith-assert-diseq      294
;  :arith-assert-lower      1321
;  :arith-assert-upper      805
;  :arith-bound-prop        404
;  :arith-conflicts         120
;  :arith-eq-adapter        882
;  :arith-fixed-eqs         353
;  :arith-offset-eqs        396
;  :arith-pivots            885
;  :conflicts               301
;  :datatype-accessor-ax    46
;  :datatype-constructor-ax 192
;  :datatype-occurs-check   124
;  :datatype-splits         89
;  :decisions               604
;  :del-clause              5753
;  :final-checks            83
;  :interface-eqs           6
;  :max-generation          7
;  :max-memory              5.80
;  :memory                  5.72
;  :minimized-lits          11
;  :mk-bool-var             8990
;  :mk-clause               5753
;  :num-allocs              218698
;  :num-checks              144
;  :propagations            2742
;  :quant-instantiations    2367
;  :rlimit-count            377371
;  :time                    0.00)
; Final check if taken enough permissions
; Done removing quantified permissions
; Definitional axioms for snapshot map values
(declare-const i1@109@06 Int)
(declare-const j1@110@06 Int)
(push) ; 6
; [eval] 0 <= i1 && i1 < V && (0 <= j1 && j1 < V)
; [eval] 0 <= i1
(push) ; 7
; [then-branch: 94 | 0 <= i1@109@06 | live]
; [else-branch: 94 | !(0 <= i1@109@06) | live]
(push) ; 8
; [then-branch: 94 | 0 <= i1@109@06]
(assert (<= 0 i1@109@06))
; [eval] i1 < V
(push) ; 9
; [then-branch: 95 | i1@109@06 < V@27@06 | live]
; [else-branch: 95 | !(i1@109@06 < V@27@06) | live]
(push) ; 10
; [then-branch: 95 | i1@109@06 < V@27@06]
(assert (< i1@109@06 V@27@06))
; [eval] 0 <= j1
(push) ; 11
; [then-branch: 96 | 0 <= j1@110@06 | live]
; [else-branch: 96 | !(0 <= j1@110@06) | live]
(push) ; 12
; [then-branch: 96 | 0 <= j1@110@06]
(assert (<= 0 j1@110@06))
; [eval] j1 < V
(pop) ; 12
(push) ; 12
; [else-branch: 96 | !(0 <= j1@110@06)]
(assert (not (<= 0 j1@110@06)))
(pop) ; 12
(pop) ; 11
; Joined path conditions
; Joined path conditions
(pop) ; 10
(push) ; 10
; [else-branch: 95 | !(i1@109@06 < V@27@06)]
(assert (not (< i1@109@06 V@27@06)))
(pop) ; 10
(pop) ; 9
; Joined path conditions
; Joined path conditions
(pop) ; 8
(push) ; 8
; [else-branch: 94 | !(0 <= i1@109@06)]
(assert (not (<= 0 i1@109@06)))
(pop) ; 8
(pop) ; 7
; Joined path conditions
; Joined path conditions
(assert (and
  (and (and (< j1@110@06 V@27@06) (<= 0 j1@110@06)) (< i1@109@06 V@27@06))
  (<= 0 i1@109@06)))
; [eval] aloc(opt_get1(aloc(opt_get1(target), i1).option$array$), j1)
; [eval] opt_get1(aloc(opt_get1(target), i1).option$array$)
; [eval] aloc(opt_get1(target), i1)
; [eval] opt_get1(target)
(push) ; 7
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 7
; Joined path conditions
(push) ; 7
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 8
(assert (not (< i1@109@06 (alen<Int> (opt_get1 $Snap.unit res@68@06)))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               4671
;  :arith-add-rows          2328
;  :arith-assert-diseq      294
;  :arith-assert-lower      1327
;  :arith-assert-upper      805
;  :arith-bound-prop        404
;  :arith-conflicts         120
;  :arith-eq-adapter        882
;  :arith-fixed-eqs         353
;  :arith-offset-eqs        396
;  :arith-pivots            885
;  :conflicts               301
;  :datatype-accessor-ax    46
;  :datatype-constructor-ax 192
;  :datatype-occurs-check   124
;  :datatype-splits         89
;  :decisions               604
;  :del-clause              5753
;  :final-checks            83
;  :interface-eqs           6
;  :max-generation          7
;  :max-memory              5.80
;  :memory                  5.72
;  :minimized-lits          11
;  :mk-bool-var             8996
;  :mk-clause               5753
;  :num-allocs              218977
;  :num-checks              145
;  :propagations            2742
;  :quant-instantiations    2367
;  :rlimit-count            377840)
(assert (< i1@109@06 (alen<Int> (opt_get1 $Snap.unit res@68@06))))
(pop) ; 7
; Joined path conditions
(assert (< i1@109@06 (alen<Int> (opt_get1 $Snap.unit res@68@06))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@109@06)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@109@06)))
(push) ; 7
(assert (not (<
  $Perm.No
  (+
    (ite
      (and
        (<
          (inv@71@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@109@06))
          V@27@06)
        (<=
          0
          (inv@71@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@109@06))))
      $Perm.Write
      $Perm.No)
    (ite
      (and
        (<
          (inv@33@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@109@06))
          V@27@06)
        (<=
          0
          (inv@33@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@109@06))))
      $k@32@06
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               4754
;  :arith-add-rows          2375
;  :arith-assert-diseq      297
;  :arith-assert-lower      1348
;  :arith-assert-upper      822
;  :arith-bound-prop        414
;  :arith-conflicts         124
;  :arith-eq-adapter        901
;  :arith-fixed-eqs         358
;  :arith-offset-eqs        411
;  :arith-pivots            897
;  :conflicts               313
;  :datatype-accessor-ax    46
;  :datatype-constructor-ax 194
;  :datatype-occurs-check   124
;  :datatype-splits         89
;  :decisions               616
;  :del-clause              5809
;  :final-checks            83
;  :interface-eqs           6
;  :max-generation          7
;  :max-memory              5.80
;  :memory                  5.73
;  :minimized-lits          11
;  :mk-bool-var             9194
;  :mk-clause               5883
;  :num-allocs              220110
;  :num-checks              146
;  :propagations            2811
;  :quant-instantiations    2426
;  :rlimit-count            382088
;  :time                    0.00)
(push) ; 7
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 8
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@109@06))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               4754
;  :arith-add-rows          2375
;  :arith-assert-diseq      297
;  :arith-assert-lower      1348
;  :arith-assert-upper      822
;  :arith-bound-prop        414
;  :arith-conflicts         124
;  :arith-eq-adapter        901
;  :arith-fixed-eqs         358
;  :arith-offset-eqs        411
;  :arith-pivots            897
;  :conflicts               314
;  :datatype-accessor-ax    46
;  :datatype-constructor-ax 194
;  :datatype-occurs-check   124
;  :datatype-splits         89
;  :decisions               616
;  :del-clause              5809
;  :final-checks            83
;  :interface-eqs           6
;  :max-generation          7
;  :max-memory              5.80
;  :memory                  5.73
;  :minimized-lits          11
;  :mk-bool-var             9194
;  :mk-clause               5883
;  :num-allocs              220199
;  :num-checks              147
;  :propagations            2811
;  :quant-instantiations    2426
;  :rlimit-count            382183)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@109@06))
    (as None<option<array>>  option<array>))))
(pop) ; 7
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@109@06))
    (as None<option<array>>  option<array>))))
(push) ; 7
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 8
(assert (not (<
  j1@110@06
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@109@06)))))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               4754
;  :arith-add-rows          2378
;  :arith-assert-diseq      297
;  :arith-assert-lower      1349
;  :arith-assert-upper      822
;  :arith-bound-prop        414
;  :arith-conflicts         125
;  :arith-eq-adapter        901
;  :arith-fixed-eqs         358
;  :arith-offset-eqs        411
;  :arith-pivots            899
;  :conflicts               315
;  :datatype-accessor-ax    46
;  :datatype-constructor-ax 194
;  :datatype-occurs-check   124
;  :datatype-splits         89
;  :decisions               616
;  :del-clause              5809
;  :final-checks            83
;  :interface-eqs           6
;  :max-generation          7
;  :max-memory              5.80
;  :memory                  5.73
;  :minimized-lits          11
;  :mk-bool-var             9195
;  :mk-clause               5883
;  :num-allocs              220356
;  :num-checks              148
;  :propagations            2811
;  :quant-instantiations    2426
;  :rlimit-count            382485)
(assert (<
  j1@110@06
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@109@06))))))
(pop) ; 7
; Joined path conditions
(assert (<
  j1@110@06
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@109@06))))))
(pop) ; 6
(declare-fun inv@111@06 ($Ref) Int)
(declare-fun inv@112@06 ($Ref) Int)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(assert (forall ((i1@109@06 Int) (j1@110@06 Int)) (!
  (and
    (< i1@109@06 (alen<Int> (opt_get1 $Snap.unit res@68@06)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@109@06)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@109@06))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@109@06))
        (as None<option<array>>  option<array>)))
    (<
      j1@110@06
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@109@06))))))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@109@06))) j1@110@06))
  :qid |int-aux|)))
(declare-const sm@113@06 $FVF<Int>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (ite
          (and
            (and
              (and (< (inv@42@06 r) V@27@06) (<= 0 (inv@42@06 r)))
              (< (inv@41@06 r) V@27@06))
            (<= 0 (inv@41@06 r)))
          $Perm.Write
          $Perm.No)
        (pTaken@108@06 r)))
    (=
      ($FVF.lookup_int (as sm@113@06  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@30@06)))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@113@06  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@30@06)))))))))))) r))
  :qid |qp.fvfValDef24|)))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (ite
          (and
            (and
              (and (< (inv@80@06 r) V@27@06) (<= 0 (inv@80@06 r)))
              (< (inv@79@06 r) V@27@06))
            (<= 0 (inv@79@06 r)))
          $Perm.Write
          $Perm.No)
        (pTaken@107@06 r)))
    (=
      ($FVF.lookup_int (as sm@113@06  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@06))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@113@06  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@06))))))))) r))
  :qid |qp.fvfValDef25|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@30@06)))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@69@06))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@113@06  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef26|)))
; Check receiver injectivity
(push) ; 6
(assert (not (forall ((i11@109@06 Int) (j11@110@06 Int) (i12@109@06 Int) (j12@110@06 Int)) (!
  (implies
    (and
      (and
        (and
          (and
            (and (< j11@110@06 V@27@06) (<= 0 j11@110@06))
            (< i11@109@06 V@27@06))
          (<= 0 i11@109@06))
        ($FVF.loc_int ($FVF.lookup_int (as sm@113@06  $FVF<Int>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@68@06) i11@109@06))) j11@110@06)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@68@06) i11@109@06))) j11@110@06)))
      (and
        (and
          (and
            (and (< j12@110@06 V@27@06) (<= 0 j12@110@06))
            (< i12@109@06 V@27@06))
          (<= 0 i12@109@06))
        ($FVF.loc_int ($FVF.lookup_int (as sm@113@06  $FVF<Int>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@68@06) i12@109@06))) j12@110@06)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@68@06) i12@109@06))) j12@110@06)))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@68@06) i11@109@06))) j11@110@06)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@68@06) i12@109@06))) j12@110@06)))
    (and (= i11@109@06 i12@109@06) (= j11@110@06 j12@110@06)))
  
  :qid |int-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               4833
;  :arith-add-rows          2415
;  :arith-assert-diseq      297
;  :arith-assert-lower      1362
;  :arith-assert-upper      827
;  :arith-bound-prop        417
;  :arith-conflicts         125
;  :arith-eq-adapter        918
;  :arith-fixed-eqs         361
;  :arith-offset-eqs        411
;  :arith-pivots            914
;  :conflicts               316
;  :datatype-accessor-ax    46
;  :datatype-constructor-ax 194
;  :datatype-occurs-check   124
;  :datatype-splits         89
;  :decisions               616
;  :del-clause              6118
;  :final-checks            83
;  :interface-eqs           6
;  :max-generation          7
;  :max-memory              6.05
;  :memory                  5.90
;  :minimized-lits          11
;  :mk-bool-var             9509
;  :mk-clause               6118
;  :num-allocs              222797
;  :num-checks              149
;  :propagations            2853
;  :quant-instantiations    2531
;  :rlimit-count            392127
;  :time                    0.00)
; Definitional axioms for inverse functions
(assert (forall ((i1@109@06 Int) (j1@110@06 Int)) (!
  (implies
    (and
      (and (and (< j1@110@06 V@27@06) (<= 0 j1@110@06)) (< i1@109@06 V@27@06))
      (<= 0 i1@109@06))
    (and
      (=
        (inv@111@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@109@06))) j1@110@06))
        i1@109@06)
      (=
        (inv@112@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@109@06))) j1@110@06))
        j1@110@06)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@109@06))) j1@110@06))
  :qid |int-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@112@06 r) V@27@06) (<= 0 (inv@112@06 r)))
        (< (inv@111@06 r) V@27@06))
      (<= 0 (inv@111@06 r)))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@06  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit res@68@06) (inv@111@06 r)))) (inv@112@06 r))
      r))
  :pattern ((inv@111@06 r))
  :pattern ((inv@112@06 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@112@06 r) V@27@06) (<= 0 (inv@112@06 r)))
        (< (inv@111@06 r) V@27@06))
      (<= 0 (inv@111@06 r)))
    ($FVF.loc_int ($FVF.lookup_int (as sm@113@06  $FVF<Int>) r) r))
  :pattern ((inv@111@06 r) (inv@112@06 r))
  )))
; Precomputing data for removing quantified permissions
(define-fun pTaken@114@06 ((r $Ref)) $Perm
  (ite
    (and
      (and
        (and (< (inv@112@06 r) V@27@06) (<= 0 (inv@112@06 r)))
        (< (inv@111@06 r) V@27@06))
      (<= 0 (inv@111@06 r)))
    ($Perm.min
      (-
        (ite
          (and
            (and
              (and (< (inv@42@06 r) V@27@06) (<= 0 (inv@42@06 r)))
              (< (inv@41@06 r) V@27@06))
            (<= 0 (inv@41@06 r)))
          $Perm.Write
          $Perm.No)
        (pTaken@108@06 r))
      $Perm.Write)
    $Perm.No))
(define-fun pTaken@115@06 ((r $Ref)) $Perm
  (ite
    (and
      (and
        (and (< (inv@112@06 r) V@27@06) (<= 0 (inv@112@06 r)))
        (< (inv@111@06 r) V@27@06))
      (<= 0 (inv@111@06 r)))
    ($Perm.min
      (-
        (ite
          (and
            (and
              (and (< (inv@80@06 r) V@27@06) (<= 0 (inv@80@06 r)))
              (< (inv@79@06 r) V@27@06))
            (<= 0 (inv@79@06 r)))
          $Perm.Write
          $Perm.No)
        (pTaken@107@06 r))
      (- $Perm.Write (pTaken@114@06 r)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 500)
(push) ; 6
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (-
        (ite
          (and
            (and
              (and (< (inv@42@06 r) V@27@06) (<= 0 (inv@42@06 r)))
              (< (inv@41@06 r) V@27@06))
            (<= 0 (inv@41@06 r)))
          $Perm.Write
          $Perm.No)
        (pTaken@108@06 r))
      (pTaken@114@06 r))
    $Perm.No)
  
  ))))
(check-sat)
; unsat
(pop) ; 6
; 0.02s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               5809
;  :arith-add-rows          2943
;  :arith-assert-diseq      336
;  :arith-assert-lower      1635
;  :arith-assert-upper      1028
;  :arith-bound-prop        472
;  :arith-conflicts         141
;  :arith-eq-adapter        1126
;  :arith-fixed-eqs         507
;  :arith-offset-eqs        447
;  :arith-pivots            1094
;  :conflicts               341
;  :datatype-accessor-ax    46
;  :datatype-constructor-ax 200
;  :datatype-occurs-check   127
;  :datatype-splits         91
;  :decisions               654
;  :del-clause              7610
;  :final-checks            85
;  :interface-eqs           6
;  :max-generation          7
;  :max-memory              6.61
;  :memory                  6.39
;  :minimized-lits          19
;  :mk-bool-var             11739
;  :mk-clause               7610
;  :num-allocs              232797
;  :num-checks              151
;  :propagations            3387
;  :quant-instantiations    3154
;  :rlimit-count            425214
;  :time                    0.02)
; Intermediate check if already taken enough permissions
(push) ; 6
(assert (not (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@112@06 r) V@27@06) (<= 0 (inv@112@06 r)))
        (< (inv@111@06 r) V@27@06))
      (<= 0 (inv@111@06 r)))
    (= (- $Perm.Write (pTaken@114@06 r)) $Perm.No))
  
  ))))
(check-sat)
; unknown
(pop) ; 6
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               6327
;  :arith-add-rows          3156
;  :arith-assert-diseq      375
;  :arith-assert-lower      1796
;  :arith-assert-upper      1161
;  :arith-bound-prop        518
;  :arith-conflicts         151
;  :arith-eq-adapter        1235
;  :arith-fixed-eqs         563
;  :arith-offset-eqs        510
;  :arith-pivots            1168
;  :conflicts               357
;  :datatype-accessor-ax    48
;  :datatype-constructor-ax 210
;  :datatype-occurs-check   135
;  :datatype-splits         100
;  :decisions               723
;  :del-clause              8194
;  :final-checks            89
;  :interface-eqs           6
;  :max-generation          7
;  :max-memory              6.61
;  :memory                  6.48
;  :minimized-lits          21
;  :mk-bool-var             12560
;  :mk-clause               8194
;  :num-allocs              237232
;  :num-checks              152
;  :propagations            3689
;  :quant-instantiations    3335
;  :rlimit-count            442194
;  :time                    0.01)
; Chunk depleted?
(push) ; 6
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (-
        (ite
          (and
            (and
              (and (< (inv@80@06 r) V@27@06) (<= 0 (inv@80@06 r)))
              (< (inv@79@06 r) V@27@06))
            (<= 0 (inv@79@06 r)))
          $Perm.Write
          $Perm.No)
        (pTaken@107@06 r))
      (pTaken@115@06 r))
    $Perm.No)
  
  ))))
(check-sat)
; unsat
(pop) ; 6
; 0.02s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               7642
;  :arith-add-rows          3930
;  :arith-assert-diseq      436
;  :arith-assert-lower      2220
;  :arith-assert-upper      1462
;  :arith-bound-prop        612
;  :arith-conflicts         174
;  :arith-eq-adapter        1506
;  :arith-fixed-eqs         757
;  :arith-offset-eqs        635
;  :arith-pivots            1406
;  :conflicts               392
;  :datatype-accessor-ax    49
;  :datatype-constructor-ax 213
;  :datatype-occurs-check   135
;  :datatype-splits         100
;  :decisions               811
;  :del-clause              9950
;  :final-checks            89
;  :interface-eqs           6
;  :max-generation          8
;  :max-memory              6.73
;  :memory                  6.66
;  :minimized-lits          34
;  :mk-bool-var             15108
;  :mk-clause               9950
;  :num-allocs              247279
;  :num-checks              153
;  :propagations            4482
;  :quant-instantiations    3985
;  :rlimit-count            482385
;  :time                    0.02)
; Intermediate check if already taken enough permissions
(push) ; 6
(assert (not (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@112@06 r) V@27@06) (<= 0 (inv@112@06 r)))
        (< (inv@111@06 r) V@27@06))
      (<= 0 (inv@111@06 r)))
    (= (- (- $Perm.Write (pTaken@114@06 r)) (pTaken@115@06 r)) $Perm.No))
  
  ))))
(check-sat)
; unsat
(pop) ; 6
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               8402
;  :arith-add-rows          4414
;  :arith-assert-diseq      481
;  :arith-assert-lower      2422
;  :arith-assert-upper      1610
;  :arith-bound-prop        670
;  :arith-conflicts         189
;  :arith-eq-adapter        1657
;  :arith-fixed-eqs         846
;  :arith-offset-eqs        716
;  :arith-pivots            1549
;  :conflicts               420
;  :datatype-accessor-ax    50
;  :datatype-constructor-ax 217
;  :datatype-occurs-check   135
;  :datatype-splits         100
;  :decisions               858
;  :del-clause              10871
;  :final-checks            89
;  :interface-eqs           6
;  :max-generation          8
;  :max-memory              6.73
;  :memory                  6.68
;  :minimized-lits          51
;  :mk-bool-var             16351
;  :mk-clause               10871
;  :num-allocs              252470
;  :num-checks              154
;  :propagations            4986
;  :quant-instantiations    4309
;  :rlimit-count            509415
;  :time                    0.01)
; Final check if taken enough permissions
; Done removing quantified permissions
; Definitional axioms for snapshot map values
(declare-const exc@116@06 $Ref)
(declare-const res@117@06 void)
(declare-const $t@118@06 $Snap)
(assert (= $t@118@06 ($Snap.combine ($Snap.first $t@118@06) ($Snap.second $t@118@06))))
(assert (= ($Snap.first $t@118@06) $Snap.unit))
; [eval] exc == null
(assert (= exc@116@06 $Ref.null))
(assert (=
  ($Snap.second $t@118@06)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@118@06))
    ($Snap.second ($Snap.second $t@118@06)))))
(assert (= ($Snap.first ($Snap.second $t@118@06)) $Snap.unit))
; [eval] exc == null ==> source != (None(): option[array])
; [eval] exc == null
(push) ; 6
(set-option :timeout 10)
(push) ; 7
(assert (not (not (= exc@116@06 $Ref.null))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               8438
;  :arith-add-rows          4414
;  :arith-assert-diseq      481
;  :arith-assert-lower      2422
;  :arith-assert-upper      1610
;  :arith-bound-prop        670
;  :arith-conflicts         189
;  :arith-eq-adapter        1657
;  :arith-fixed-eqs         846
;  :arith-offset-eqs        716
;  :arith-pivots            1549
;  :conflicts               420
;  :datatype-accessor-ax    52
;  :datatype-constructor-ax 222
;  :datatype-occurs-check   139
;  :datatype-splits         103
;  :decisions               863
;  :del-clause              10871
;  :final-checks            91
;  :interface-eqs           6
;  :max-generation          8
;  :max-memory              6.73
;  :memory                  6.68
;  :minimized-lits          51
;  :mk-bool-var             16359
;  :mk-clause               10871
;  :num-allocs              253191
;  :num-checks              155
;  :propagations            4986
;  :quant-instantiations    4309
;  :rlimit-count            510254)
; [then-branch: 97 | exc@116@06 == Null | live]
; [else-branch: 97 | exc@116@06 != Null | dead]
(push) ; 7
; [then-branch: 97 | exc@116@06 == Null]
; [eval] source != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 7
(pop) ; 6
; Joined path conditions
(assert (implies
  (= exc@116@06 $Ref.null)
  (not (= G@24@06 (as None<option<array>>  option<array>)))))
(assert (=
  ($Snap.second ($Snap.second $t@118@06))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second $t@118@06)))
    ($Snap.second ($Snap.second ($Snap.second $t@118@06))))))
(assert (= ($Snap.first ($Snap.second ($Snap.second $t@118@06))) $Snap.unit))
; [eval] exc == null ==> alen(opt_get1(source)) == V
; [eval] exc == null
(push) ; 6
(push) ; 7
(assert (not (not (= exc@116@06 $Ref.null))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               8468
;  :arith-add-rows          4414
;  :arith-assert-diseq      481
;  :arith-assert-lower      2422
;  :arith-assert-upper      1610
;  :arith-bound-prop        670
;  :arith-conflicts         189
;  :arith-eq-adapter        1657
;  :arith-fixed-eqs         846
;  :arith-offset-eqs        716
;  :arith-pivots            1549
;  :conflicts               420
;  :datatype-accessor-ax    53
;  :datatype-constructor-ax 227
;  :datatype-occurs-check   143
;  :datatype-splits         106
;  :decisions               868
;  :del-clause              10871
;  :final-checks            93
;  :interface-eqs           6
;  :max-generation          8
;  :max-memory              6.73
;  :memory                  6.68
;  :minimized-lits          51
;  :mk-bool-var             16364
;  :mk-clause               10871
;  :num-allocs              253852
;  :num-checks              156
;  :propagations            4986
;  :quant-instantiations    4309
;  :rlimit-count            510973)
; [then-branch: 98 | exc@116@06 == Null | live]
; [else-branch: 98 | exc@116@06 != Null | dead]
(push) ; 7
; [then-branch: 98 | exc@116@06 == Null]
; [eval] alen(opt_get1(source)) == V
; [eval] alen(opt_get1(source))
; [eval] opt_get1(source)
(push) ; 8
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 8
; Joined path conditions
(pop) ; 7
(pop) ; 6
; Joined path conditions
(assert (implies
  (= exc@116@06 $Ref.null)
  (= (alen<Int> (opt_get1 $Snap.unit G@24@06)) V@27@06)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second $t@118@06)))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@118@06))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@118@06)))))))
; [eval] exc == null
(push) ; 6
(assert (not (not (= exc@116@06 $Ref.null))))
(check-sat)
; unknown
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               8500
;  :arith-add-rows          4414
;  :arith-assert-diseq      481
;  :arith-assert-lower      2422
;  :arith-assert-upper      1610
;  :arith-bound-prop        670
;  :arith-conflicts         189
;  :arith-eq-adapter        1657
;  :arith-fixed-eqs         846
;  :arith-offset-eqs        716
;  :arith-pivots            1549
;  :conflicts               420
;  :datatype-accessor-ax    54
;  :datatype-constructor-ax 233
;  :datatype-occurs-check   147
;  :datatype-splits         110
;  :decisions               874
;  :del-clause              10871
;  :final-checks            95
;  :interface-eqs           6
;  :max-generation          8
;  :max-memory              6.73
;  :memory                  6.68
;  :minimized-lits          51
;  :mk-bool-var             16369
;  :mk-clause               10871
;  :num-allocs              254512
;  :num-checks              157
;  :propagations            4986
;  :quant-instantiations    4309
;  :rlimit-count            511684)
; [then-branch: 99 | exc@116@06 == Null | live]
; [else-branch: 99 | exc@116@06 != Null | dead]
(push) ; 6
; [then-branch: 99 | exc@116@06 == Null]
(declare-const i1@119@06 Int)
(push) ; 7
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 8
; [then-branch: 100 | 0 <= i1@119@06 | live]
; [else-branch: 100 | !(0 <= i1@119@06) | live]
(push) ; 9
; [then-branch: 100 | 0 <= i1@119@06]
(assert (<= 0 i1@119@06))
; [eval] i1 < V
(pop) ; 9
(push) ; 9
; [else-branch: 100 | !(0 <= i1@119@06)]
(assert (not (<= 0 i1@119@06)))
(pop) ; 9
(pop) ; 8
; Joined path conditions
; Joined path conditions
(assert (and (< i1@119@06 V@27@06) (<= 0 i1@119@06)))
; [eval] aloc(opt_get1(source), i1)
; [eval] opt_get1(source)
(push) ; 8
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 8
; Joined path conditions
(push) ; 8
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 9
(assert (not (< i1@119@06 (alen<Int> (opt_get1 $Snap.unit G@24@06)))))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               8500
;  :arith-add-rows          4415
;  :arith-assert-diseq      481
;  :arith-assert-lower      2424
;  :arith-assert-upper      1610
;  :arith-bound-prop        670
;  :arith-conflicts         189
;  :arith-eq-adapter        1657
;  :arith-fixed-eqs         846
;  :arith-offset-eqs        716
;  :arith-pivots            1549
;  :conflicts               420
;  :datatype-accessor-ax    54
;  :datatype-constructor-ax 233
;  :datatype-occurs-check   147
;  :datatype-splits         110
;  :decisions               874
;  :del-clause              10871
;  :final-checks            95
;  :interface-eqs           6
;  :max-generation          8
;  :max-memory              6.73
;  :memory                  6.68
;  :minimized-lits          51
;  :mk-bool-var             16371
;  :mk-clause               10871
;  :num-allocs              254615
;  :num-checks              158
;  :propagations            4986
;  :quant-instantiations    4309
;  :rlimit-count            511868)
(assert (< i1@119@06 (alen<Int> (opt_get1 $Snap.unit G@24@06))))
(pop) ; 8
; Joined path conditions
(assert (< i1@119@06 (alen<Int> (opt_get1 $Snap.unit G@24@06))))
(declare-const $k@120@06 $Perm)
(assert ($Perm.isReadVar $k@120@06 $Perm.Write))
(pop) ; 7
(declare-fun inv@121@06 ($Ref) Int)
; Nested auxiliary terms: globals
(assert ($Perm.isReadVar $k@120@06 $Perm.Write))
; Nested auxiliary terms: non-globals
(assert (forall ((i1@119@06 Int)) (!
  (< i1@119@06 (alen<Int> (opt_get1 $Snap.unit G@24@06)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@119@06))
  :qid |option$array$-aux|)))
(push) ; 7
(assert (not (forall ((i1@119@06 Int)) (!
  (implies
    (and (< i1@119@06 V@27@06) (<= 0 i1@119@06))
    (or (= $k@120@06 $Perm.No) (< $Perm.No $k@120@06)))
  
  ))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               8500
;  :arith-add-rows          4416
;  :arith-assert-diseq      482
;  :arith-assert-lower      2426
;  :arith-assert-upper      1611
;  :arith-bound-prop        670
;  :arith-conflicts         189
;  :arith-eq-adapter        1658
;  :arith-fixed-eqs         846
;  :arith-offset-eqs        716
;  :arith-pivots            1549
;  :conflicts               421
;  :datatype-accessor-ax    54
;  :datatype-constructor-ax 233
;  :datatype-occurs-check   147
;  :datatype-splits         110
;  :decisions               874
;  :del-clause              10871
;  :final-checks            95
;  :interface-eqs           6
;  :max-generation          8
;  :max-memory              6.73
;  :memory                  6.68
;  :minimized-lits          51
;  :mk-bool-var             16378
;  :mk-clause               10873
;  :num-allocs              255081
;  :num-checks              159
;  :propagations            4987
;  :quant-instantiations    4309
;  :rlimit-count            512440)
; Check receiver injectivity
(push) ; 7
(assert (not (forall ((i11@119@06 Int) (i12@119@06 Int)) (!
  (implies
    (and
      (and (and (< i11@119@06 V@27@06) (<= 0 i11@119@06)) (< $Perm.No $k@120@06))
      (and (and (< i12@119@06 V@27@06) (<= 0 i12@119@06)) (< $Perm.No $k@120@06))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i11@119@06)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i12@119@06)))
    (= i11@119@06 i12@119@06))
  
  :qid |option$array$-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               8508
;  :arith-add-rows          4420
;  :arith-assert-diseq      483
;  :arith-assert-lower      2430
;  :arith-assert-upper      1611
;  :arith-bound-prop        670
;  :arith-conflicts         189
;  :arith-eq-adapter        1659
;  :arith-fixed-eqs         846
;  :arith-offset-eqs        716
;  :arith-pivots            1549
;  :conflicts               422
;  :datatype-accessor-ax    54
;  :datatype-constructor-ax 233
;  :datatype-occurs-check   147
;  :datatype-splits         110
;  :decisions               874
;  :del-clause              10877
;  :final-checks            95
;  :interface-eqs           6
;  :max-generation          8
;  :max-memory              6.73
;  :memory                  6.67
;  :minimized-lits          51
;  :mk-bool-var             16397
;  :mk-clause               10879
;  :num-allocs              255453
;  :num-checks              160
;  :propagations            4987
;  :quant-instantiations    4324
;  :rlimit-count            513210)
; Definitional axioms for inverse functions
(assert (forall ((i1@119@06 Int)) (!
  (implies
    (and (and (< i1@119@06 V@27@06) (<= 0 i1@119@06)) (< $Perm.No $k@120@06))
    (=
      (inv@121@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@119@06))
      i1@119@06))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@119@06))
  )))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and (< (inv@121@06 r) V@27@06) (<= 0 (inv@121@06 r)))
      (< $Perm.No $k@120@06))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) (inv@121@06 r))
      r))
  :pattern ((inv@121@06 r))
  :qid |option$array$-fctOfInv|)))
; Permissions are non-negative
(assert (forall ((i1@119@06 Int)) (!
  (<= $Perm.No $k@120@06)
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@119@06))
  :qid |option$array$-permAtLeastZero|)))
; Field permissions are at most one
(assert (forall ((i1@119@06 Int)) (!
  (<= $k@120@06 $Perm.Write)
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@119@06))
  :qid |option$array$-permAtMostOne|)))
; Permission implies non-null receiver
(assert (forall ((i1@119@06 Int)) (!
  (implies
    (and (and (< i1@119@06 V@27@06) (<= 0 i1@119@06)) (< $Perm.No $k@120@06))
    (not
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@119@06)
        $Ref.null)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@119@06))
  :qid |option$array$-permImpliesNonNull|)))
(declare-const sm@122@06 $FVF<option<array>>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@121@06 r) V@27@06) (<= 0 (inv@121@06 r)))
      (< $Perm.No $k@120@06)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@122@06  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@118@06))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@122@06  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@118@06))))) r))
  :qid |qp.fvfValDef27|)))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (-
          (ite
            (and (< (inv@71@06 r) V@27@06) (<= 0 (inv@71@06 r)))
            $Perm.Write
            $Perm.No)
          (pTaken@87@06 r))
        (pTaken@98@06 r)))
    (=
      ($FVF.lookup_option$array$ (as sm@122@06  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@69@06))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@122@06  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@69@06))))) r))
  :qid |qp.fvfValDef28|)))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (-
          (ite
            (and (< (inv@33@06 r) V@27@06) (<= 0 (inv@33@06 r)))
            $k@32@06
            $Perm.No)
          (pTaken@88@06 r))
        (pTaken@97@06 r)))
    (=
      ($FVF.lookup_option$array$ (as sm@122@06  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@30@06))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@122@06  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@30@06))))) r))
  :qid |qp.fvfValDef29|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@118@06))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@69@06))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@30@06))))) r) r))
  :pattern (($FVF.lookup_option$array$ (as sm@122@06  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef30|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@121@06 r) V@27@06) (<= 0 (inv@121@06 r)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@122@06  $FVF<option<array>>) r) r))
  :pattern ((inv@121@06 r))
  )))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@118@06))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@118@06)))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@118@06))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@118@06)))))
  $Snap.unit))
; [eval] exc == null ==> (forall i1: Int :: { aloc(opt_get1(source), i1) } 0 <= i1 && i1 < V ==> aloc(opt_get1(source), i1).option$array$ != (None(): option[array]))
; [eval] exc == null
(push) ; 7
(set-option :timeout 10)
(push) ; 8
(assert (not (not (= exc@116@06 $Ref.null))))
(check-sat)
; unknown
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               8543
;  :arith-add-rows          4420
;  :arith-assert-diseq      483
;  :arith-assert-lower      2430
;  :arith-assert-upper      1612
;  :arith-bound-prop        670
;  :arith-conflicts         189
;  :arith-eq-adapter        1659
;  :arith-fixed-eqs         846
;  :arith-offset-eqs        716
;  :arith-pivots            1549
;  :conflicts               422
;  :datatype-accessor-ax    55
;  :datatype-constructor-ax 239
;  :datatype-occurs-check   151
;  :datatype-splits         114
;  :decisions               880
;  :del-clause              10877
;  :final-checks            97
;  :interface-eqs           6
;  :max-generation          8
;  :max-memory              6.73
;  :memory                  6.67
;  :minimized-lits          51
;  :mk-bool-var             16412
;  :mk-clause               10879
;  :num-allocs              257905
;  :num-checks              161
;  :propagations            4987
;  :quant-instantiations    4324
;  :rlimit-count            519154)
; [then-branch: 101 | exc@116@06 == Null | live]
; [else-branch: 101 | exc@116@06 != Null | dead]
(push) ; 8
; [then-branch: 101 | exc@116@06 == Null]
; [eval] (forall i1: Int :: { aloc(opt_get1(source), i1) } 0 <= i1 && i1 < V ==> aloc(opt_get1(source), i1).option$array$ != (None(): option[array]))
(declare-const i1@123@06 Int)
(push) ; 9
; [eval] 0 <= i1 && i1 < V ==> aloc(opt_get1(source), i1).option$array$ != (None(): option[array])
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 10
; [then-branch: 102 | 0 <= i1@123@06 | live]
; [else-branch: 102 | !(0 <= i1@123@06) | live]
(push) ; 11
; [then-branch: 102 | 0 <= i1@123@06]
(assert (<= 0 i1@123@06))
; [eval] i1 < V
(pop) ; 11
(push) ; 11
; [else-branch: 102 | !(0 <= i1@123@06)]
(assert (not (<= 0 i1@123@06)))
(pop) ; 11
(pop) ; 10
; Joined path conditions
; Joined path conditions
(push) ; 10
; [then-branch: 103 | i1@123@06 < V@27@06 && 0 <= i1@123@06 | live]
; [else-branch: 103 | !(i1@123@06 < V@27@06 && 0 <= i1@123@06) | live]
(push) ; 11
; [then-branch: 103 | i1@123@06 < V@27@06 && 0 <= i1@123@06]
(assert (and (< i1@123@06 V@27@06) (<= 0 i1@123@06)))
; [eval] aloc(opt_get1(source), i1).option$array$ != (None(): option[array])
; [eval] aloc(opt_get1(source), i1)
; [eval] opt_get1(source)
(push) ; 12
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 12
; Joined path conditions
(push) ; 12
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 13
(assert (not (< i1@123@06 (alen<Int> (opt_get1 $Snap.unit G@24@06)))))
(check-sat)
; unsat
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               8543
;  :arith-add-rows          4421
;  :arith-assert-diseq      483
;  :arith-assert-lower      2432
;  :arith-assert-upper      1612
;  :arith-bound-prop        670
;  :arith-conflicts         189
;  :arith-eq-adapter        1659
;  :arith-fixed-eqs         846
;  :arith-offset-eqs        716
;  :arith-pivots            1549
;  :conflicts               422
;  :datatype-accessor-ax    55
;  :datatype-constructor-ax 239
;  :datatype-occurs-check   151
;  :datatype-splits         114
;  :decisions               880
;  :del-clause              10877
;  :final-checks            97
;  :interface-eqs           6
;  :max-generation          8
;  :max-memory              6.73
;  :memory                  6.67
;  :minimized-lits          51
;  :mk-bool-var             16414
;  :mk-clause               10879
;  :num-allocs              258008
;  :num-checks              162
;  :propagations            4987
;  :quant-instantiations    4324
;  :rlimit-count            519350)
(assert (< i1@123@06 (alen<Int> (opt_get1 $Snap.unit G@24@06))))
(pop) ; 12
; Joined path conditions
(assert (< i1@123@06 (alen<Int> (opt_get1 $Snap.unit G@24@06))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@122@06  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@123@06)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@123@06)))
(push) ; 12
(assert (not (<
  $Perm.No
  (+
    (+
      (ite
        (and
          (<
            (inv@121@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@123@06))
            V@27@06)
          (<=
            0
            (inv@121@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@123@06))))
        $k@120@06
        $Perm.No)
      (-
        (-
          (ite
            (and
              (<
                (inv@71@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@123@06))
                V@27@06)
              (<=
                0
                (inv@71@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@123@06))))
            $Perm.Write
            $Perm.No)
          (pTaken@87@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@123@06)))
        (pTaken@98@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@123@06))))
    (-
      (-
        (ite
          (and
            (<
              (inv@33@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@123@06))
              V@27@06)
            (<=
              0
              (inv@33@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@123@06))))
          $k@32@06
          $Perm.No)
        (pTaken@88@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@123@06)))
      (pTaken@97@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@123@06)))))))
(check-sat)
; unsat
(pop) ; 12
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               9014
;  :arith-add-rows          5055
;  :arith-assert-diseq      545
;  :arith-assert-lower      2592
;  :arith-assert-upper      1719
;  :arith-bound-prop        727
;  :arith-conflicts         199
;  :arith-eq-adapter        1796
;  :arith-fixed-eqs         899
;  :arith-offset-eqs        789
;  :arith-pivots            1629
;  :conflicts               442
;  :datatype-accessor-ax    55
;  :datatype-constructor-ax 241
;  :datatype-occurs-check   151
;  :datatype-splits         114
;  :decisions               943
;  :del-clause              11624
;  :final-checks            97
;  :interface-eqs           6
;  :max-generation          8
;  :max-memory              6.73
;  :memory                  6.69
;  :minimized-lits          55
;  :mk-bool-var             17422
;  :mk-clause               11728
;  :num-allocs              261807
;  :num-checks              163
;  :propagations            5358
;  :quant-instantiations    4512
;  :rlimit-count            545330
;  :time                    0.01)
; [eval] (None(): option[array])
(pop) ; 11
(push) ; 11
; [else-branch: 103 | !(i1@123@06 < V@27@06 && 0 <= i1@123@06)]
(assert (not (and (< i1@123@06 V@27@06) (<= 0 i1@123@06))))
(pop) ; 11
(pop) ; 10
; Joined path conditions
(assert (implies
  (and (< i1@123@06 V@27@06) (<= 0 i1@123@06))
  (and
    (< i1@123@06 V@27@06)
    (<= 0 i1@123@06)
    (< i1@123@06 (alen<Int> (opt_get1 $Snap.unit G@24@06)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@122@06  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@123@06)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@123@06)))))
; Joined path conditions
(pop) ; 9
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@123@06 Int)) (!
  (implies
    (and (< i1@123@06 V@27@06) (<= 0 i1@123@06))
    (and
      (< i1@123@06 V@27@06)
      (<= 0 i1@123@06)
      (< i1@123@06 (alen<Int> (opt_get1 $Snap.unit G@24@06)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@122@06  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@123@06)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@123@06))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@123@06))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 8
(pop) ; 7
; Joined path conditions
(assert (implies
  (= exc@116@06 $Ref.null)
  (forall ((i1@123@06 Int)) (!
    (implies
      (and (< i1@123@06 V@27@06) (<= 0 i1@123@06))
      (and
        (< i1@123@06 V@27@06)
        (<= 0 i1@123@06)
        (< i1@123@06 (alen<Int> (opt_get1 $Snap.unit G@24@06)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@122@06  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@123@06)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@123@06))))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@123@06))
    :qid |prog.l<no position>-aux|))))
(assert (implies
  (= exc@116@06 $Ref.null)
  (forall ((i1@123@06 Int)) (!
    (implies
      (and (< i1@123@06 V@27@06) (<= 0 i1@123@06))
      (not
        (=
          ($FVF.lookup_option$array$ (as sm@122@06  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@123@06))
          (as None<option<array>>  option<array>))))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@123@06))
    :qid |prog.l<no position>|))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@118@06)))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@118@06))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@118@06)))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@118@06))))))
  $Snap.unit))
; [eval] exc == null ==> (forall i1: Int :: { alen(opt_get1(aloc(opt_get1(source), i1).option$array$)) } 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(source), i1).option$array$)) == V)
; [eval] exc == null
(push) ; 7
(set-option :timeout 10)
(push) ; 8
(assert (not (not (= exc@116@06 $Ref.null))))
(check-sat)
; unknown
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               9050
;  :arith-add-rows          5073
;  :arith-assert-diseq      545
;  :arith-assert-lower      2592
;  :arith-assert-upper      1719
;  :arith-bound-prop        727
;  :arith-conflicts         199
;  :arith-eq-adapter        1796
;  :arith-fixed-eqs         899
;  :arith-offset-eqs        789
;  :arith-pivots            1640
;  :conflicts               442
;  :datatype-accessor-ax    56
;  :datatype-constructor-ax 247
;  :datatype-occurs-check   155
;  :datatype-splits         118
;  :decisions               949
;  :del-clause              11726
;  :final-checks            99
;  :interface-eqs           6
;  :max-generation          8
;  :max-memory              6.73
;  :memory                  6.69
;  :minimized-lits          55
;  :mk-bool-var             17430
;  :mk-clause               11728
;  :num-allocs              262861
;  :num-checks              164
;  :propagations            5358
;  :quant-instantiations    4512
;  :rlimit-count            547230)
; [then-branch: 104 | exc@116@06 == Null | live]
; [else-branch: 104 | exc@116@06 != Null | dead]
(push) ; 8
; [then-branch: 104 | exc@116@06 == Null]
; [eval] (forall i1: Int :: { alen(opt_get1(aloc(opt_get1(source), i1).option$array$)) } 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(source), i1).option$array$)) == V)
(declare-const i1@124@06 Int)
(push) ; 9
; [eval] 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(source), i1).option$array$)) == V
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 10
; [then-branch: 105 | 0 <= i1@124@06 | live]
; [else-branch: 105 | !(0 <= i1@124@06) | live]
(push) ; 11
; [then-branch: 105 | 0 <= i1@124@06]
(assert (<= 0 i1@124@06))
; [eval] i1 < V
(pop) ; 11
(push) ; 11
; [else-branch: 105 | !(0 <= i1@124@06)]
(assert (not (<= 0 i1@124@06)))
(pop) ; 11
(pop) ; 10
; Joined path conditions
; Joined path conditions
(push) ; 10
; [then-branch: 106 | i1@124@06 < V@27@06 && 0 <= i1@124@06 | live]
; [else-branch: 106 | !(i1@124@06 < V@27@06 && 0 <= i1@124@06) | live]
(push) ; 11
; [then-branch: 106 | i1@124@06 < V@27@06 && 0 <= i1@124@06]
(assert (and (< i1@124@06 V@27@06) (<= 0 i1@124@06)))
; [eval] alen(opt_get1(aloc(opt_get1(source), i1).option$array$)) == V
; [eval] alen(opt_get1(aloc(opt_get1(source), i1).option$array$))
; [eval] opt_get1(aloc(opt_get1(source), i1).option$array$)
; [eval] aloc(opt_get1(source), i1)
; [eval] opt_get1(source)
(push) ; 12
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 12
; Joined path conditions
(push) ; 12
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 13
(assert (not (< i1@124@06 (alen<Int> (opt_get1 $Snap.unit G@24@06)))))
(check-sat)
; unsat
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               9050
;  :arith-add-rows          5074
;  :arith-assert-diseq      545
;  :arith-assert-lower      2594
;  :arith-assert-upper      1719
;  :arith-bound-prop        727
;  :arith-conflicts         199
;  :arith-eq-adapter        1796
;  :arith-fixed-eqs         899
;  :arith-offset-eqs        789
;  :arith-pivots            1640
;  :conflicts               442
;  :datatype-accessor-ax    56
;  :datatype-constructor-ax 247
;  :datatype-occurs-check   155
;  :datatype-splits         118
;  :decisions               949
;  :del-clause              11726
;  :final-checks            99
;  :interface-eqs           6
;  :max-generation          8
;  :max-memory              6.73
;  :memory                  6.69
;  :minimized-lits          55
;  :mk-bool-var             17432
;  :mk-clause               11728
;  :num-allocs              262964
;  :num-checks              165
;  :propagations            5358
;  :quant-instantiations    4512
;  :rlimit-count            547426)
(assert (< i1@124@06 (alen<Int> (opt_get1 $Snap.unit G@24@06))))
(pop) ; 12
; Joined path conditions
(assert (< i1@124@06 (alen<Int> (opt_get1 $Snap.unit G@24@06))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@122@06  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@124@06)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@124@06)))
(push) ; 12
(assert (not (<
  $Perm.No
  (+
    (+
      (ite
        (and
          (<
            (inv@121@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@124@06))
            V@27@06)
          (<=
            0
            (inv@121@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@124@06))))
        $k@120@06
        $Perm.No)
      (-
        (-
          (ite
            (and
              (<
                (inv@71@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@124@06))
                V@27@06)
              (<=
                0
                (inv@71@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@124@06))))
            $Perm.Write
            $Perm.No)
          (pTaken@87@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@124@06)))
        (pTaken@98@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@124@06))))
    (-
      (-
        (ite
          (and
            (<
              (inv@33@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@124@06))
              V@27@06)
            (<=
              0
              (inv@33@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@124@06))))
          $k@32@06
          $Perm.No)
        (pTaken@88@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@124@06)))
      (pTaken@97@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@124@06)))))))
(check-sat)
; unsat
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               9321
;  :arith-add-rows          5402
;  :arith-assert-diseq      568
;  :arith-assert-lower      2672
;  :arith-assert-upper      1770
;  :arith-bound-prop        776
;  :arith-conflicts         207
;  :arith-eq-adapter        1865
;  :arith-fixed-eqs         927
;  :arith-offset-eqs        817
;  :arith-pivots            1690
;  :conflicts               461
;  :datatype-accessor-ax    56
;  :datatype-constructor-ax 249
;  :datatype-occurs-check   155
;  :datatype-splits         118
;  :decisions               990
;  :del-clause              12203
;  :final-checks            99
;  :interface-eqs           6
;  :max-generation          8
;  :max-memory              6.73
;  :memory                  6.70
;  :minimized-lits          55
;  :mk-bool-var             18151
;  :mk-clause               12307
;  :num-allocs              265863
;  :num-checks              166
;  :propagations            5555
;  :quant-instantiations    4662
;  :rlimit-count            563090
;  :time                    0.01)
(push) ; 12
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 13
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@122@06  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@124@06))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               9321
;  :arith-add-rows          5402
;  :arith-assert-diseq      568
;  :arith-assert-lower      2672
;  :arith-assert-upper      1770
;  :arith-bound-prop        776
;  :arith-conflicts         207
;  :arith-eq-adapter        1865
;  :arith-fixed-eqs         927
;  :arith-offset-eqs        817
;  :arith-pivots            1690
;  :conflicts               462
;  :datatype-accessor-ax    56
;  :datatype-constructor-ax 249
;  :datatype-occurs-check   155
;  :datatype-splits         118
;  :decisions               990
;  :del-clause              12203
;  :final-checks            99
;  :interface-eqs           6
;  :max-generation          8
;  :max-memory              6.73
;  :memory                  6.70
;  :minimized-lits          55
;  :mk-bool-var             18151
;  :mk-clause               12307
;  :num-allocs              265952
;  :num-checks              167
;  :propagations            5555
;  :quant-instantiations    4662
;  :rlimit-count            563185)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@122@06  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@124@06))
    (as None<option<array>>  option<array>))))
(pop) ; 12
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@122@06  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@124@06))
    (as None<option<array>>  option<array>))))
(pop) ; 11
(push) ; 11
; [else-branch: 106 | !(i1@124@06 < V@27@06 && 0 <= i1@124@06)]
(assert (not (and (< i1@124@06 V@27@06) (<= 0 i1@124@06))))
(pop) ; 11
(pop) ; 10
; Joined path conditions
(assert (implies
  (and (< i1@124@06 V@27@06) (<= 0 i1@124@06))
  (and
    (< i1@124@06 V@27@06)
    (<= 0 i1@124@06)
    (< i1@124@06 (alen<Int> (opt_get1 $Snap.unit G@24@06)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@122@06  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@124@06)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@124@06))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@122@06  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@124@06))
        (as None<option<array>>  option<array>))))))
; Joined path conditions
(pop) ; 9
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@124@06 Int)) (!
  (implies
    (and (< i1@124@06 V@27@06) (<= 0 i1@124@06))
    (and
      (< i1@124@06 V@27@06)
      (<= 0 i1@124@06)
      (< i1@124@06 (alen<Int> (opt_get1 $Snap.unit G@24@06)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@122@06  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@124@06)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@124@06))
      (not
        (=
          ($FVF.lookup_option$array$ (as sm@122@06  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@124@06))
          (as None<option<array>>  option<array>)))))
  :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@122@06  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@124@06)))))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 8
(pop) ; 7
; Joined path conditions
(assert (implies
  (= exc@116@06 $Ref.null)
  (forall ((i1@124@06 Int)) (!
    (implies
      (and (< i1@124@06 V@27@06) (<= 0 i1@124@06))
      (and
        (< i1@124@06 V@27@06)
        (<= 0 i1@124@06)
        (< i1@124@06 (alen<Int> (opt_get1 $Snap.unit G@24@06)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@122@06  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@124@06)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@124@06))
        (not
          (=
            ($FVF.lookup_option$array$ (as sm@122@06  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@124@06))
            (as None<option<array>>  option<array>)))))
    :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@122@06  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@124@06)))))
    :qid |prog.l<no position>-aux|))))
(assert (implies
  (= exc@116@06 $Ref.null)
  (forall ((i1@124@06 Int)) (!
    (implies
      (and (< i1@124@06 V@27@06) (<= 0 i1@124@06))
      (=
        (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@122@06  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@124@06))))
        V@27@06))
    :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@122@06  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@124@06)))))
    :qid |prog.l<no position>|))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@118@06))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@118@06)))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@118@06))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@118@06)))))))
  $Snap.unit))
; [eval] exc == null ==> (forall i1: Int :: { aloc(opt_get1(source), i1) } (forall i2: Int :: { aloc(opt_get1(source), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(source), i1).option$array$ == aloc(opt_get1(source), i2).option$array$ ==> i1 == i2))
; [eval] exc == null
(push) ; 7
(set-option :timeout 10)
(push) ; 8
(assert (not (not (= exc@116@06 $Ref.null))))
(check-sat)
; unknown
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               9358
;  :arith-add-rows          5423
;  :arith-assert-diseq      568
;  :arith-assert-lower      2672
;  :arith-assert-upper      1770
;  :arith-bound-prop        776
;  :arith-conflicts         207
;  :arith-eq-adapter        1865
;  :arith-fixed-eqs         927
;  :arith-offset-eqs        817
;  :arith-pivots            1704
;  :conflicts               462
;  :datatype-accessor-ax    57
;  :datatype-constructor-ax 255
;  :datatype-occurs-check   159
;  :datatype-splits         122
;  :decisions               996
;  :del-clause              12305
;  :final-checks            101
;  :interface-eqs           6
;  :max-generation          8
;  :max-memory              6.73
;  :memory                  6.70
;  :minimized-lits          55
;  :mk-bool-var             18159
;  :mk-clause               12307
;  :num-allocs              267037
;  :num-checks              168
;  :propagations            5555
;  :quant-instantiations    4662
;  :rlimit-count            565265)
; [then-branch: 107 | exc@116@06 == Null | live]
; [else-branch: 107 | exc@116@06 != Null | dead]
(push) ; 8
; [then-branch: 107 | exc@116@06 == Null]
; [eval] (forall i1: Int :: { aloc(opt_get1(source), i1) } (forall i2: Int :: { aloc(opt_get1(source), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(source), i1).option$array$ == aloc(opt_get1(source), i2).option$array$ ==> i1 == i2))
(declare-const i1@125@06 Int)
(push) ; 9
; [eval] (forall i2: Int :: { aloc(opt_get1(source), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(source), i1).option$array$ == aloc(opt_get1(source), i2).option$array$ ==> i1 == i2)
(declare-const i2@126@06 Int)
(push) ; 10
; [eval] 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(source), i1).option$array$ == aloc(opt_get1(source), i2).option$array$ ==> i1 == i2
; [eval] 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(source), i1).option$array$ == aloc(opt_get1(source), i2).option$array$
; [eval] 0 <= i1
(push) ; 11
; [then-branch: 108 | 0 <= i1@125@06 | live]
; [else-branch: 108 | !(0 <= i1@125@06) | live]
(push) ; 12
; [then-branch: 108 | 0 <= i1@125@06]
(assert (<= 0 i1@125@06))
; [eval] i1 < V
(push) ; 13
; [then-branch: 109 | i1@125@06 < V@27@06 | live]
; [else-branch: 109 | !(i1@125@06 < V@27@06) | live]
(push) ; 14
; [then-branch: 109 | i1@125@06 < V@27@06]
(assert (< i1@125@06 V@27@06))
; [eval] 0 <= i2
(push) ; 15
; [then-branch: 110 | 0 <= i2@126@06 | live]
; [else-branch: 110 | !(0 <= i2@126@06) | live]
(push) ; 16
; [then-branch: 110 | 0 <= i2@126@06]
(assert (<= 0 i2@126@06))
; [eval] i2 < V
(push) ; 17
; [then-branch: 111 | i2@126@06 < V@27@06 | live]
; [else-branch: 111 | !(i2@126@06 < V@27@06) | live]
(push) ; 18
; [then-branch: 111 | i2@126@06 < V@27@06]
(assert (< i2@126@06 V@27@06))
; [eval] aloc(opt_get1(source), i1).option$array$ == aloc(opt_get1(source), i2).option$array$
; [eval] aloc(opt_get1(source), i1)
; [eval] opt_get1(source)
(push) ; 19
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 19
; Joined path conditions
(push) ; 19
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 20
(assert (not (< i1@125@06 (alen<Int> (opt_get1 $Snap.unit G@24@06)))))
(check-sat)
; unsat
(pop) ; 20
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               9358
;  :arith-add-rows          5425
;  :arith-assert-diseq      568
;  :arith-assert-lower      2676
;  :arith-assert-upper      1770
;  :arith-bound-prop        776
;  :arith-conflicts         207
;  :arith-eq-adapter        1865
;  :arith-fixed-eqs         927
;  :arith-offset-eqs        817
;  :arith-pivots            1704
;  :conflicts               462
;  :datatype-accessor-ax    57
;  :datatype-constructor-ax 255
;  :datatype-occurs-check   159
;  :datatype-splits         122
;  :decisions               996
;  :del-clause              12305
;  :final-checks            101
;  :interface-eqs           6
;  :max-generation          8
;  :max-memory              6.73
;  :memory                  6.70
;  :minimized-lits          55
;  :mk-bool-var             18163
;  :mk-clause               12307
;  :num-allocs              267323
;  :num-checks              169
;  :propagations            5555
;  :quant-instantiations    4662
;  :rlimit-count            565605)
(assert (< i1@125@06 (alen<Int> (opt_get1 $Snap.unit G@24@06))))
(pop) ; 19
; Joined path conditions
(assert (< i1@125@06 (alen<Int> (opt_get1 $Snap.unit G@24@06))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@122@06  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@125@06)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@125@06)))
(push) ; 19
(assert (not (<
  $Perm.No
  (+
    (+
      (ite
        (and
          (<
            (inv@121@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@125@06))
            V@27@06)
          (<=
            0
            (inv@121@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@125@06))))
        $k@120@06
        $Perm.No)
      (-
        (-
          (ite
            (and
              (<
                (inv@71@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@125@06))
                V@27@06)
              (<=
                0
                (inv@71@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@125@06))))
            $Perm.Write
            $Perm.No)
          (pTaken@87@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@125@06)))
        (pTaken@98@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@125@06))))
    (-
      (-
        (ite
          (and
            (<
              (inv@33@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@125@06))
              V@27@06)
            (<=
              0
              (inv@33@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@125@06))))
          $k@32@06
          $Perm.No)
        (pTaken@88@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@125@06)))
      (pTaken@97@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@125@06)))))))
(check-sat)
; unsat
(pop) ; 19
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               9918
;  :arith-add-rows          5998
;  :arith-assert-diseq      641
;  :arith-assert-lower      2861
;  :arith-assert-upper      1902
;  :arith-bound-prop        839
;  :arith-conflicts         219
;  :arith-eq-adapter        2021
;  :arith-fixed-eqs         986
;  :arith-offset-eqs        907
;  :arith-pivots            1798
;  :conflicts               486
;  :datatype-accessor-ax    57
;  :datatype-constructor-ax 257
;  :datatype-occurs-check   159
;  :datatype-splits         122
;  :decisions               1048
;  :del-clause              12972
;  :final-checks            101
;  :interface-eqs           6
;  :max-generation          8
;  :max-memory              6.74
;  :memory                  6.73
;  :minimized-lits          55
;  :mk-bool-var             19127
;  :mk-clause               13076
;  :num-allocs              271037
;  :num-checks              170
;  :propagations            5981
;  :quant-instantiations    4843
;  :rlimit-count            588755
;  :time                    0.01)
; [eval] aloc(opt_get1(source), i2)
; [eval] opt_get1(source)
(push) ; 19
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 19
; Joined path conditions
(push) ; 19
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 20
(assert (not (< i2@126@06 (alen<Int> (opt_get1 $Snap.unit G@24@06)))))
(check-sat)
; unsat
(pop) ; 20
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               9918
;  :arith-add-rows          5998
;  :arith-assert-diseq      641
;  :arith-assert-lower      2861
;  :arith-assert-upper      1902
;  :arith-bound-prop        839
;  :arith-conflicts         219
;  :arith-eq-adapter        2021
;  :arith-fixed-eqs         986
;  :arith-offset-eqs        907
;  :arith-pivots            1798
;  :conflicts               486
;  :datatype-accessor-ax    57
;  :datatype-constructor-ax 257
;  :datatype-occurs-check   159
;  :datatype-splits         122
;  :decisions               1048
;  :del-clause              12972
;  :final-checks            101
;  :interface-eqs           6
;  :max-generation          8
;  :max-memory              6.74
;  :memory                  6.73
;  :minimized-lits          55
;  :mk-bool-var             19127
;  :mk-clause               13076
;  :num-allocs              271063
;  :num-checks              171
;  :propagations            5981
;  :quant-instantiations    4843
;  :rlimit-count            588785)
(assert (< i2@126@06 (alen<Int> (opt_get1 $Snap.unit G@24@06))))
(pop) ; 19
; Joined path conditions
(assert (< i2@126@06 (alen<Int> (opt_get1 $Snap.unit G@24@06))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@122@06  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@24@06) i2@126@06)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@24@06) i2@126@06)))
(push) ; 19
(assert (not (<
  $Perm.No
  (+
    (+
      (ite
        (and
          (<
            (inv@121@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i2@126@06))
            V@27@06)
          (<=
            0
            (inv@121@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i2@126@06))))
        $k@120@06
        $Perm.No)
      (-
        (-
          (ite
            (and
              (<
                (inv@71@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i2@126@06))
                V@27@06)
              (<=
                0
                (inv@71@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i2@126@06))))
            $Perm.Write
            $Perm.No)
          (pTaken@87@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i2@126@06)))
        (pTaken@98@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i2@126@06))))
    (-
      (-
        (ite
          (and
            (<
              (inv@33@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i2@126@06))
              V@27@06)
            (<=
              0
              (inv@33@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i2@126@06))))
          $k@32@06
          $Perm.No)
        (pTaken@88@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i2@126@06)))
      (pTaken@97@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i2@126@06)))))))
(check-sat)
; unsat
(pop) ; 19
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               10833
;  :arith-add-rows          7201
;  :arith-assert-diseq      746
;  :arith-assert-lower      3164
;  :arith-assert-upper      2073
;  :arith-bound-prop        972
;  :arith-conflicts         239
;  :arith-eq-adapter        2247
;  :arith-fixed-eqs         1071
;  :arith-offset-eqs        1044
;  :arith-pivots            1952
;  :conflicts               522
;  :datatype-accessor-ax    57
;  :datatype-constructor-ax 259
;  :datatype-occurs-check   159
;  :datatype-splits         122
;  :decisions               1131
;  :del-clause              14399
;  :final-checks            101
;  :interface-eqs           6
;  :max-generation          8
;  :max-memory              7.13
;  :memory                  7.10
;  :minimized-lits          58
;  :mk-bool-var             20815
;  :mk-clause               14617
;  :num-allocs              277977
;  :num-checks              172
;  :propagations            6755
;  :quant-instantiations    5220
;  :rlimit-count            639734
;  :time                    0.01)
(pop) ; 18
(push) ; 18
; [else-branch: 111 | !(i2@126@06 < V@27@06)]
(assert (not (< i2@126@06 V@27@06)))
(pop) ; 18
(pop) ; 17
; Joined path conditions
(assert (implies
  (< i2@126@06 V@27@06)
  (and
    (< i2@126@06 V@27@06)
    (< i1@125@06 (alen<Int> (opt_get1 $Snap.unit G@24@06)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@122@06  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@125@06)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@125@06))
    (< i2@126@06 (alen<Int> (opt_get1 $Snap.unit G@24@06)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@122@06  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@24@06) i2@126@06)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@24@06) i2@126@06)))))
; Joined path conditions
(pop) ; 16
(push) ; 16
; [else-branch: 110 | !(0 <= i2@126@06)]
(assert (not (<= 0 i2@126@06)))
(pop) ; 16
(pop) ; 15
; Joined path conditions
(assert (implies
  (<= 0 i2@126@06)
  (and
    (<= 0 i2@126@06)
    (implies
      (< i2@126@06 V@27@06)
      (and
        (< i2@126@06 V@27@06)
        (< i1@125@06 (alen<Int> (opt_get1 $Snap.unit G@24@06)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@122@06  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@125@06)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@125@06))
        (< i2@126@06 (alen<Int> (opt_get1 $Snap.unit G@24@06)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@122@06  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@24@06) i2@126@06)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@24@06) i2@126@06)))))))
; Joined path conditions
(pop) ; 14
(push) ; 14
; [else-branch: 109 | !(i1@125@06 < V@27@06)]
(assert (not (< i1@125@06 V@27@06)))
(pop) ; 14
(pop) ; 13
; Joined path conditions
(assert (implies
  (< i1@125@06 V@27@06)
  (and
    (< i1@125@06 V@27@06)
    (implies
      (<= 0 i2@126@06)
      (and
        (<= 0 i2@126@06)
        (implies
          (< i2@126@06 V@27@06)
          (and
            (< i2@126@06 V@27@06)
            (< i1@125@06 (alen<Int> (opt_get1 $Snap.unit G@24@06)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@122@06  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@125@06)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@125@06))
            (< i2@126@06 (alen<Int> (opt_get1 $Snap.unit G@24@06)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@122@06  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@24@06) i2@126@06)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@24@06) i2@126@06)))))))))
; Joined path conditions
(pop) ; 12
(push) ; 12
; [else-branch: 108 | !(0 <= i1@125@06)]
(assert (not (<= 0 i1@125@06)))
(pop) ; 12
(pop) ; 11
; Joined path conditions
(assert (implies
  (<= 0 i1@125@06)
  (and
    (<= 0 i1@125@06)
    (implies
      (< i1@125@06 V@27@06)
      (and
        (< i1@125@06 V@27@06)
        (implies
          (<= 0 i2@126@06)
          (and
            (<= 0 i2@126@06)
            (implies
              (< i2@126@06 V@27@06)
              (and
                (< i2@126@06 V@27@06)
                (< i1@125@06 (alen<Int> (opt_get1 $Snap.unit G@24@06)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@122@06  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@125@06)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@125@06))
                (< i2@126@06 (alen<Int> (opt_get1 $Snap.unit G@24@06)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@122@06  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@24@06) i2@126@06)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@24@06) i2@126@06)))))))))))
; Joined path conditions
(push) ; 11
; [then-branch: 112 | Lookup(option$array$,sm@122@06,aloc((_, _), opt_get1(_, G@24@06), i1@125@06)) == Lookup(option$array$,sm@122@06,aloc((_, _), opt_get1(_, G@24@06), i2@126@06)) && i2@126@06 < V@27@06 && 0 <= i2@126@06 && i1@125@06 < V@27@06 && 0 <= i1@125@06 | live]
; [else-branch: 112 | !(Lookup(option$array$,sm@122@06,aloc((_, _), opt_get1(_, G@24@06), i1@125@06)) == Lookup(option$array$,sm@122@06,aloc((_, _), opt_get1(_, G@24@06), i2@126@06)) && i2@126@06 < V@27@06 && 0 <= i2@126@06 && i1@125@06 < V@27@06 && 0 <= i1@125@06) | live]
(push) ; 12
; [then-branch: 112 | Lookup(option$array$,sm@122@06,aloc((_, _), opt_get1(_, G@24@06), i1@125@06)) == Lookup(option$array$,sm@122@06,aloc((_, _), opt_get1(_, G@24@06), i2@126@06)) && i2@126@06 < V@27@06 && 0 <= i2@126@06 && i1@125@06 < V@27@06 && 0 <= i1@125@06]
(assert (and
  (and
    (and
      (and
        (=
          ($FVF.lookup_option$array$ (as sm@122@06  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@125@06))
          ($FVF.lookup_option$array$ (as sm@122@06  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@24@06) i2@126@06)))
        (< i2@126@06 V@27@06))
      (<= 0 i2@126@06))
    (< i1@125@06 V@27@06))
  (<= 0 i1@125@06)))
; [eval] i1 == i2
(pop) ; 12
(push) ; 12
; [else-branch: 112 | !(Lookup(option$array$,sm@122@06,aloc((_, _), opt_get1(_, G@24@06), i1@125@06)) == Lookup(option$array$,sm@122@06,aloc((_, _), opt_get1(_, G@24@06), i2@126@06)) && i2@126@06 < V@27@06 && 0 <= i2@126@06 && i1@125@06 < V@27@06 && 0 <= i1@125@06)]
(assert (not
  (and
    (and
      (and
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@122@06  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@125@06))
            ($FVF.lookup_option$array$ (as sm@122@06  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@24@06) i2@126@06)))
          (< i2@126@06 V@27@06))
        (<= 0 i2@126@06))
      (< i1@125@06 V@27@06))
    (<= 0 i1@125@06))))
(pop) ; 12
(pop) ; 11
; Joined path conditions
(assert (implies
  (and
    (and
      (and
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@122@06  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@125@06))
            ($FVF.lookup_option$array$ (as sm@122@06  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@24@06) i2@126@06)))
          (< i2@126@06 V@27@06))
        (<= 0 i2@126@06))
      (< i1@125@06 V@27@06))
    (<= 0 i1@125@06))
  (and
    (=
      ($FVF.lookup_option$array$ (as sm@122@06  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@125@06))
      ($FVF.lookup_option$array$ (as sm@122@06  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@24@06) i2@126@06)))
    (< i2@126@06 V@27@06)
    (<= 0 i2@126@06)
    (< i1@125@06 V@27@06)
    (<= 0 i1@125@06))))
; Joined path conditions
(pop) ; 10
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i2@126@06 Int)) (!
  (and
    (implies
      (<= 0 i1@125@06)
      (and
        (<= 0 i1@125@06)
        (implies
          (< i1@125@06 V@27@06)
          (and
            (< i1@125@06 V@27@06)
            (implies
              (<= 0 i2@126@06)
              (and
                (<= 0 i2@126@06)
                (implies
                  (< i2@126@06 V@27@06)
                  (and
                    (< i2@126@06 V@27@06)
                    (< i1@125@06 (alen<Int> (opt_get1 $Snap.unit G@24@06)))
                    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@122@06  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@125@06)) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@125@06))
                    (< i2@126@06 (alen<Int> (opt_get1 $Snap.unit G@24@06)))
                    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@122@06  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit G@24@06) i2@126@06)) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit G@24@06) i2@126@06))))))))))
    (implies
      (and
        (and
          (and
            (and
              (=
                ($FVF.lookup_option$array$ (as sm@122@06  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@125@06))
                ($FVF.lookup_option$array$ (as sm@122@06  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@24@06) i2@126@06)))
              (< i2@126@06 V@27@06))
            (<= 0 i2@126@06))
          (< i1@125@06 V@27@06))
        (<= 0 i1@125@06))
      (and
        (=
          ($FVF.lookup_option$array$ (as sm@122@06  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@125@06))
          ($FVF.lookup_option$array$ (as sm@122@06  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@24@06) i2@126@06)))
        (< i2@126@06 V@27@06)
        (<= 0 i2@126@06)
        (< i1@125@06 V@27@06)
        (<= 0 i1@125@06))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i2@126@06))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 9
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@125@06 Int)) (!
  (forall ((i2@126@06 Int)) (!
    (and
      (implies
        (<= 0 i1@125@06)
        (and
          (<= 0 i1@125@06)
          (implies
            (< i1@125@06 V@27@06)
            (and
              (< i1@125@06 V@27@06)
              (implies
                (<= 0 i2@126@06)
                (and
                  (<= 0 i2@126@06)
                  (implies
                    (< i2@126@06 V@27@06)
                    (and
                      (< i2@126@06 V@27@06)
                      (< i1@125@06 (alen<Int> (opt_get1 $Snap.unit G@24@06)))
                      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@122@06  $FVF<option<array>>) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@125@06)) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@125@06))
                      (< i2@126@06 (alen<Int> (opt_get1 $Snap.unit G@24@06)))
                      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@122@06  $FVF<option<array>>) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit G@24@06) i2@126@06)) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit G@24@06) i2@126@06))))))))))
      (implies
        (and
          (and
            (and
              (and
                (=
                  ($FVF.lookup_option$array$ (as sm@122@06  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@125@06))
                  ($FVF.lookup_option$array$ (as sm@122@06  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit G@24@06) i2@126@06)))
                (< i2@126@06 V@27@06))
              (<= 0 i2@126@06))
            (< i1@125@06 V@27@06))
          (<= 0 i1@125@06))
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@122@06  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@125@06))
            ($FVF.lookup_option$array$ (as sm@122@06  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@24@06) i2@126@06)))
          (< i2@126@06 V@27@06)
          (<= 0 i2@126@06)
          (< i1@125@06 V@27@06)
          (<= 0 i1@125@06))))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i2@126@06))
    :qid |prog.l<no position>-aux|))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@125@06))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 8
(pop) ; 7
; Joined path conditions
(assert (implies
  (= exc@116@06 $Ref.null)
  (forall ((i1@125@06 Int)) (!
    (forall ((i2@126@06 Int)) (!
      (and
        (implies
          (<= 0 i1@125@06)
          (and
            (<= 0 i1@125@06)
            (implies
              (< i1@125@06 V@27@06)
              (and
                (< i1@125@06 V@27@06)
                (implies
                  (<= 0 i2@126@06)
                  (and
                    (<= 0 i2@126@06)
                    (implies
                      (< i2@126@06 V@27@06)
                      (and
                        (< i2@126@06 V@27@06)
                        (< i1@125@06 (alen<Int> (opt_get1 $Snap.unit G@24@06)))
                        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@122@06  $FVF<option<array>>) (aloc ($Snap.combine
                          $Snap.unit
                          $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@125@06)) (aloc ($Snap.combine
                          $Snap.unit
                          $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@125@06))
                        (< i2@126@06 (alen<Int> (opt_get1 $Snap.unit G@24@06)))
                        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@122@06  $FVF<option<array>>) (aloc ($Snap.combine
                          $Snap.unit
                          $Snap.unit) (opt_get1 $Snap.unit G@24@06) i2@126@06)) (aloc ($Snap.combine
                          $Snap.unit
                          $Snap.unit) (opt_get1 $Snap.unit G@24@06) i2@126@06))))))))))
        (implies
          (and
            (and
              (and
                (and
                  (=
                    ($FVF.lookup_option$array$ (as sm@122@06  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@125@06))
                    ($FVF.lookup_option$array$ (as sm@122@06  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit G@24@06) i2@126@06)))
                  (< i2@126@06 V@27@06))
                (<= 0 i2@126@06))
              (< i1@125@06 V@27@06))
            (<= 0 i1@125@06))
          (and
            (=
              ($FVF.lookup_option$array$ (as sm@122@06  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@125@06))
              ($FVF.lookup_option$array$ (as sm@122@06  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit G@24@06) i2@126@06)))
            (< i2@126@06 V@27@06)
            (<= 0 i2@126@06)
            (< i1@125@06 V@27@06)
            (<= 0 i1@125@06))))
      :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i2@126@06))
      :qid |prog.l<no position>-aux|))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@125@06))
    :qid |prog.l<no position>-aux|))))
(assert (implies
  (= exc@116@06 $Ref.null)
  (forall ((i1@125@06 Int)) (!
    (forall ((i2@126@06 Int)) (!
      (implies
        (and
          (and
            (and
              (and
                (=
                  ($FVF.lookup_option$array$ (as sm@122@06  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@125@06))
                  ($FVF.lookup_option$array$ (as sm@122@06  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit G@24@06) i2@126@06)))
                (< i2@126@06 V@27@06))
              (<= 0 i2@126@06))
            (< i1@125@06 V@27@06))
          (<= 0 i1@125@06))
        (= i1@125@06 i2@126@06))
      :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i2@126@06))
      :qid |prog.l<no position>|))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@125@06))
    :qid |prog.l<no position>|))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@118@06)))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@118@06))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@118@06)))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@118@06))))))))
  $Snap.unit))
; [eval] exc == null ==> target != (None(): option[array])
; [eval] exc == null
(push) ; 7
(set-option :timeout 10)
(push) ; 8
(assert (not (not (= exc@116@06 $Ref.null))))
(check-sat)
; unknown
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               10871
;  :arith-add-rows          7235
;  :arith-assert-diseq      746
;  :arith-assert-lower      3164
;  :arith-assert-upper      2073
;  :arith-bound-prop        972
;  :arith-conflicts         239
;  :arith-eq-adapter        2247
;  :arith-fixed-eqs         1071
;  :arith-offset-eqs        1044
;  :arith-pivots            1972
;  :conflicts               522
;  :datatype-accessor-ax    58
;  :datatype-constructor-ax 265
;  :datatype-occurs-check   163
;  :datatype-splits         126
;  :decisions               1137
;  :del-clause              14639
;  :final-checks            103
;  :interface-eqs           6
;  :max-generation          8
;  :max-memory              7.13
;  :memory                  7.09
;  :minimized-lits          58
;  :mk-bool-var             20836
;  :mk-clause               14641
;  :num-allocs              279614
;  :num-checks              173
;  :propagations            6755
;  :quant-instantiations    5220
;  :rlimit-count            643497)
; [then-branch: 113 | exc@116@06 == Null | live]
; [else-branch: 113 | exc@116@06 != Null | dead]
(push) ; 8
; [then-branch: 113 | exc@116@06 == Null]
; [eval] target != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 8
(pop) ; 7
; Joined path conditions
(assert (implies
  (= exc@116@06 $Ref.null)
  (not (= res@68@06 (as None<option<array>>  option<array>)))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@118@06))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@118@06)))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@118@06))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@118@06)))))))))
  $Snap.unit))
; [eval] exc == null ==> alen(opt_get1(target)) == V
; [eval] exc == null
(push) ; 7
(push) ; 8
(assert (not (not (= exc@116@06 $Ref.null))))
(check-sat)
; unknown
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               10910
;  :arith-add-rows          7235
;  :arith-assert-diseq      746
;  :arith-assert-lower      3164
;  :arith-assert-upper      2073
;  :arith-bound-prop        972
;  :arith-conflicts         239
;  :arith-eq-adapter        2247
;  :arith-fixed-eqs         1071
;  :arith-offset-eqs        1044
;  :arith-pivots            1972
;  :conflicts               522
;  :datatype-accessor-ax    59
;  :datatype-constructor-ax 271
;  :datatype-occurs-check   167
;  :datatype-splits         130
;  :decisions               1143
;  :del-clause              14639
;  :final-checks            105
;  :interface-eqs           6
;  :max-generation          8
;  :max-memory              7.13
;  :memory                  7.09
;  :minimized-lits          58
;  :mk-bool-var             20842
;  :mk-clause               14641
;  :num-allocs              280311
;  :num-checks              174
;  :propagations            6755
;  :quant-instantiations    5220
;  :rlimit-count            644325)
; [then-branch: 114 | exc@116@06 == Null | live]
; [else-branch: 114 | exc@116@06 != Null | dead]
(push) ; 8
; [then-branch: 114 | exc@116@06 == Null]
; [eval] alen(opt_get1(target)) == V
; [eval] alen(opt_get1(target))
; [eval] opt_get1(target)
(push) ; 9
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 9
; Joined path conditions
(pop) ; 8
(pop) ; 7
; Joined path conditions
(assert (implies
  (= exc@116@06 $Ref.null)
  (= (alen<Int> (opt_get1 $Snap.unit res@68@06)) V@27@06)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@118@06)))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@118@06))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@118@06)))))))))))))
; [eval] exc == null
(push) ; 7
(assert (not (not (= exc@116@06 $Ref.null))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               10951
;  :arith-add-rows          7235
;  :arith-assert-diseq      746
;  :arith-assert-lower      3164
;  :arith-assert-upper      2073
;  :arith-bound-prop        972
;  :arith-conflicts         239
;  :arith-eq-adapter        2247
;  :arith-fixed-eqs         1071
;  :arith-offset-eqs        1044
;  :arith-pivots            1972
;  :conflicts               522
;  :datatype-accessor-ax    60
;  :datatype-constructor-ax 278
;  :datatype-occurs-check   171
;  :datatype-splits         135
;  :decisions               1150
;  :del-clause              14639
;  :final-checks            107
;  :interface-eqs           6
;  :max-generation          8
;  :max-memory              7.13
;  :memory                  7.09
;  :minimized-lits          58
;  :mk-bool-var             20848
;  :mk-clause               14641
;  :num-allocs              281005
;  :num-checks              175
;  :propagations            6755
;  :quant-instantiations    5220
;  :rlimit-count            645145)
; [then-branch: 115 | exc@116@06 == Null | live]
; [else-branch: 115 | exc@116@06 != Null | dead]
(push) ; 7
; [then-branch: 115 | exc@116@06 == Null]
(declare-const i1@127@06 Int)
(push) ; 8
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 9
; [then-branch: 116 | 0 <= i1@127@06 | live]
; [else-branch: 116 | !(0 <= i1@127@06) | live]
(push) ; 10
; [then-branch: 116 | 0 <= i1@127@06]
(assert (<= 0 i1@127@06))
; [eval] i1 < V
(pop) ; 10
(push) ; 10
; [else-branch: 116 | !(0 <= i1@127@06)]
(assert (not (<= 0 i1@127@06)))
(pop) ; 10
(pop) ; 9
; Joined path conditions
; Joined path conditions
(assert (and (< i1@127@06 V@27@06) (<= 0 i1@127@06)))
; [eval] aloc(opt_get1(target), i1)
; [eval] opt_get1(target)
(push) ; 9
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 9
; Joined path conditions
(push) ; 9
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 10
(assert (not (< i1@127@06 (alen<Int> (opt_get1 $Snap.unit res@68@06)))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               10951
;  :arith-add-rows          7236
;  :arith-assert-diseq      746
;  :arith-assert-lower      3166
;  :arith-assert-upper      2073
;  :arith-bound-prop        972
;  :arith-conflicts         239
;  :arith-eq-adapter        2247
;  :arith-fixed-eqs         1071
;  :arith-offset-eqs        1044
;  :arith-pivots            1972
;  :conflicts               522
;  :datatype-accessor-ax    60
;  :datatype-constructor-ax 278
;  :datatype-occurs-check   171
;  :datatype-splits         135
;  :decisions               1150
;  :del-clause              14639
;  :final-checks            107
;  :interface-eqs           6
;  :max-generation          8
;  :max-memory              7.13
;  :memory                  7.10
;  :minimized-lits          58
;  :mk-bool-var             20850
;  :mk-clause               14641
;  :num-allocs              281110
;  :num-checks              176
;  :propagations            6755
;  :quant-instantiations    5220
;  :rlimit-count            645329)
(assert (< i1@127@06 (alen<Int> (opt_get1 $Snap.unit res@68@06))))
(pop) ; 9
; Joined path conditions
(assert (< i1@127@06 (alen<Int> (opt_get1 $Snap.unit res@68@06))))
(declare-const $k@128@06 $Perm)
(assert ($Perm.isReadVar $k@128@06 $Perm.Write))
(pop) ; 8
(declare-fun inv@129@06 ($Ref) Int)
; Nested auxiliary terms: globals
(assert ($Perm.isReadVar $k@128@06 $Perm.Write))
; Nested auxiliary terms: non-globals
(assert (forall ((i1@127@06 Int)) (!
  (< i1@127@06 (alen<Int> (opt_get1 $Snap.unit res@68@06)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@127@06))
  :qid |option$array$-aux|)))
(push) ; 8
(assert (not (forall ((i1@127@06 Int)) (!
  (implies
    (and (< i1@127@06 V@27@06) (<= 0 i1@127@06))
    (or (= $k@128@06 $Perm.No) (< $Perm.No $k@128@06)))
  
  ))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               10951
;  :arith-add-rows          7237
;  :arith-assert-diseq      747
;  :arith-assert-lower      3168
;  :arith-assert-upper      2074
;  :arith-bound-prop        972
;  :arith-conflicts         239
;  :arith-eq-adapter        2248
;  :arith-fixed-eqs         1071
;  :arith-offset-eqs        1044
;  :arith-pivots            1972
;  :conflicts               523
;  :datatype-accessor-ax    60
;  :datatype-constructor-ax 278
;  :datatype-occurs-check   171
;  :datatype-splits         135
;  :decisions               1150
;  :del-clause              14639
;  :final-checks            107
;  :interface-eqs           6
;  :max-generation          8
;  :max-memory              7.13
;  :memory                  7.10
;  :minimized-lits          58
;  :mk-bool-var             20857
;  :mk-clause               14643
;  :num-allocs              281580
;  :num-checks              177
;  :propagations            6756
;  :quant-instantiations    5220
;  :rlimit-count            645900)
; Check receiver injectivity
(push) ; 8
(assert (not (forall ((i11@127@06 Int) (i12@127@06 Int)) (!
  (implies
    (and
      (and (and (< i11@127@06 V@27@06) (<= 0 i11@127@06)) (< $Perm.No $k@128@06))
      (and (and (< i12@127@06 V@27@06) (<= 0 i12@127@06)) (< $Perm.No $k@128@06))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@68@06) i11@127@06)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@68@06) i12@127@06)))
    (= i11@127@06 i12@127@06))
  
  :qid |option$array$-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               10957
;  :arith-add-rows          7241
;  :arith-assert-diseq      748
;  :arith-assert-lower      3172
;  :arith-assert-upper      2074
;  :arith-bound-prop        972
;  :arith-conflicts         239
;  :arith-eq-adapter        2249
;  :arith-fixed-eqs         1071
;  :arith-offset-eqs        1044
;  :arith-pivots            1972
;  :conflicts               524
;  :datatype-accessor-ax    60
;  :datatype-constructor-ax 278
;  :datatype-occurs-check   171
;  :datatype-splits         135
;  :decisions               1150
;  :del-clause              14645
;  :final-checks            107
;  :interface-eqs           6
;  :max-generation          8
;  :max-memory              7.13
;  :memory                  7.10
;  :minimized-lits          58
;  :mk-bool-var             20873
;  :mk-clause               14649
;  :num-allocs              281934
;  :num-checks              178
;  :propagations            6756
;  :quant-instantiations    5230
;  :rlimit-count            646573)
; Definitional axioms for inverse functions
(assert (forall ((i1@127@06 Int)) (!
  (implies
    (and (and (< i1@127@06 V@27@06) (<= 0 i1@127@06)) (< $Perm.No $k@128@06))
    (=
      (inv@129@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@127@06))
      i1@127@06))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@127@06))
  )))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and (< (inv@129@06 r) V@27@06) (<= 0 (inv@129@06 r)))
      (< $Perm.No $k@128@06))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@68@06) (inv@129@06 r))
      r))
  :pattern ((inv@129@06 r))
  :qid |option$array$-fctOfInv|)))
; Permissions are non-negative
(assert (forall ((i1@127@06 Int)) (!
  (<= $Perm.No $k@128@06)
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@127@06))
  :qid |option$array$-permAtLeastZero|)))
; Field permissions are at most one
(assert (forall ((i1@127@06 Int)) (!
  (<= $k@128@06 $Perm.Write)
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@127@06))
  :qid |option$array$-permAtMostOne|)))
; Permission implies non-null receiver
(assert (forall ((i1@127@06 Int)) (!
  (implies
    (and (and (< i1@127@06 V@27@06) (<= 0 i1@127@06)) (< $Perm.No $k@128@06))
    (not
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@127@06)
        $Ref.null)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@127@06))
  :qid |option$array$-permImpliesNonNull|)))
(declare-const sm@130@06 $FVF<option<array>>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@129@06 r) V@27@06) (<= 0 (inv@129@06 r)))
      (< $Perm.No $k@128@06)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@118@06))))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@118@06))))))))))) r))
  :qid |qp.fvfValDef31|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@121@06 r) V@27@06) (<= 0 (inv@121@06 r)))
      (< $Perm.No $k@120@06)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@118@06))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@118@06))))) r))
  :qid |qp.fvfValDef32|)))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (-
          (ite
            (and (< (inv@71@06 r) V@27@06) (<= 0 (inv@71@06 r)))
            $Perm.Write
            $Perm.No)
          (pTaken@87@06 r))
        (pTaken@98@06 r)))
    (=
      ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@69@06))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@69@06))))) r))
  :qid |qp.fvfValDef33|)))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (-
          (ite
            (and (< (inv@33@06 r) V@27@06) (<= 0 (inv@33@06 r)))
            $k@32@06
            $Perm.No)
          (pTaken@88@06 r))
        (pTaken@97@06 r)))
    (=
      ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@30@06))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@30@06))))) r))
  :qid |qp.fvfValDef34|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@118@06))))))))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@118@06))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@69@06))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@30@06))))) r) r))
  :pattern (($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef35|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@129@06 r) V@27@06) (<= 0 (inv@129@06 r)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) r) r))
  :pattern ((inv@129@06 r))
  )))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@118@06))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@118@06)))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@118@06))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@118@06)))))))))))
  $Snap.unit))
; [eval] exc == null ==> (forall i1: Int :: { aloc(opt_get1(target), i1) } 0 <= i1 && i1 < V ==> aloc(opt_get1(target), i1).option$array$ != (None(): option[array]))
; [eval] exc == null
(push) ; 8
(set-option :timeout 10)
(push) ; 9
(assert (not (not (= exc@116@06 $Ref.null))))
(check-sat)
; unknown
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               11001
;  :arith-add-rows          7241
;  :arith-assert-diseq      748
;  :arith-assert-lower      3172
;  :arith-assert-upper      2075
;  :arith-bound-prop        972
;  :arith-conflicts         239
;  :arith-eq-adapter        2249
;  :arith-fixed-eqs         1071
;  :arith-offset-eqs        1044
;  :arith-pivots            1972
;  :conflicts               524
;  :datatype-accessor-ax    61
;  :datatype-constructor-ax 285
;  :datatype-occurs-check   177
;  :datatype-splits         140
;  :decisions               1157
;  :del-clause              14645
;  :final-checks            109
;  :interface-eqs           6
;  :max-generation          8
;  :max-memory              7.13
;  :memory                  7.10
;  :minimized-lits          58
;  :mk-bool-var             20890
;  :mk-clause               14649
;  :num-allocs              284576
;  :num-checks              179
;  :propagations            6756
;  :quant-instantiations    5230
;  :rlimit-count            653409)
; [then-branch: 117 | exc@116@06 == Null | live]
; [else-branch: 117 | exc@116@06 != Null | dead]
(push) ; 9
; [then-branch: 117 | exc@116@06 == Null]
; [eval] (forall i1: Int :: { aloc(opt_get1(target), i1) } 0 <= i1 && i1 < V ==> aloc(opt_get1(target), i1).option$array$ != (None(): option[array]))
(declare-const i1@131@06 Int)
(push) ; 10
; [eval] 0 <= i1 && i1 < V ==> aloc(opt_get1(target), i1).option$array$ != (None(): option[array])
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 11
; [then-branch: 118 | 0 <= i1@131@06 | live]
; [else-branch: 118 | !(0 <= i1@131@06) | live]
(push) ; 12
; [then-branch: 118 | 0 <= i1@131@06]
(assert (<= 0 i1@131@06))
; [eval] i1 < V
(pop) ; 12
(push) ; 12
; [else-branch: 118 | !(0 <= i1@131@06)]
(assert (not (<= 0 i1@131@06)))
(pop) ; 12
(pop) ; 11
; Joined path conditions
; Joined path conditions
(push) ; 11
; [then-branch: 119 | i1@131@06 < V@27@06 && 0 <= i1@131@06 | live]
; [else-branch: 119 | !(i1@131@06 < V@27@06 && 0 <= i1@131@06) | live]
(push) ; 12
; [then-branch: 119 | i1@131@06 < V@27@06 && 0 <= i1@131@06]
(assert (and (< i1@131@06 V@27@06) (<= 0 i1@131@06)))
; [eval] aloc(opt_get1(target), i1).option$array$ != (None(): option[array])
; [eval] aloc(opt_get1(target), i1)
; [eval] opt_get1(target)
(push) ; 13
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 13
; Joined path conditions
(push) ; 13
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 14
(assert (not (< i1@131@06 (alen<Int> (opt_get1 $Snap.unit res@68@06)))))
(check-sat)
; unsat
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               11001
;  :arith-add-rows          7242
;  :arith-assert-diseq      748
;  :arith-assert-lower      3174
;  :arith-assert-upper      2075
;  :arith-bound-prop        972
;  :arith-conflicts         239
;  :arith-eq-adapter        2249
;  :arith-fixed-eqs         1071
;  :arith-offset-eqs        1044
;  :arith-pivots            1972
;  :conflicts               524
;  :datatype-accessor-ax    61
;  :datatype-constructor-ax 285
;  :datatype-occurs-check   177
;  :datatype-splits         140
;  :decisions               1157
;  :del-clause              14645
;  :final-checks            109
;  :interface-eqs           6
;  :max-generation          8
;  :max-memory              7.13
;  :memory                  7.10
;  :minimized-lits          58
;  :mk-bool-var             20892
;  :mk-clause               14649
;  :num-allocs              284679
;  :num-checks              180
;  :propagations            6756
;  :quant-instantiations    5230
;  :rlimit-count            653605)
(assert (< i1@131@06 (alen<Int> (opt_get1 $Snap.unit res@68@06))))
(pop) ; 13
; Joined path conditions
(assert (< i1@131@06 (alen<Int> (opt_get1 $Snap.unit res@68@06))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@131@06)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@131@06)))
(push) ; 13
(assert (not (<
  $Perm.No
  (+
    (+
      (+
        (ite
          (and
            (<
              (inv@129@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@131@06))
              V@27@06)
            (<=
              0
              (inv@129@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@131@06))))
          $k@128@06
          $Perm.No)
        (ite
          (and
            (<
              (inv@121@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@131@06))
              V@27@06)
            (<=
              0
              (inv@121@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@131@06))))
          $k@120@06
          $Perm.No))
      (-
        (-
          (ite
            (and
              (<
                (inv@71@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@131@06))
                V@27@06)
              (<=
                0
                (inv@71@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@131@06))))
            $Perm.Write
            $Perm.No)
          (pTaken@87@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@131@06)))
        (pTaken@98@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@131@06))))
    (-
      (-
        (ite
          (and
            (<
              (inv@33@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@131@06))
              V@27@06)
            (<=
              0
              (inv@33@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@131@06))))
          $k@32@06
          $Perm.No)
        (pTaken@88@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@131@06)))
      (pTaken@97@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@131@06)))))))
(check-sat)
; unsat
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               11288
;  :arith-add-rows          7505
;  :arith-assert-diseq      776
;  :arith-assert-lower      3286
;  :arith-assert-upper      2136
;  :arith-bound-prop        1015
;  :arith-conflicts         246
;  :arith-eq-adapter        2317
;  :arith-fixed-eqs         1104
;  :arith-offset-eqs        1096
;  :arith-pivots            2027
;  :conflicts               544
;  :datatype-accessor-ax    61
;  :datatype-constructor-ax 287
;  :datatype-occurs-check   177
;  :datatype-splits         140
;  :decisions               1222
;  :del-clause              15214
;  :final-checks            109
;  :interface-eqs           6
;  :max-generation          8
;  :max-memory              7.15
;  :memory                  7.13
;  :minimized-lits          59
;  :mk-bool-var             21824
;  :mk-clause               15350
;  :num-allocs              287891
;  :num-checks              181
;  :propagations            7015
;  :quant-instantiations    5356
;  :rlimit-count            668889
;  :time                    0.00)
; [eval] (None(): option[array])
(pop) ; 12
(push) ; 12
; [else-branch: 119 | !(i1@131@06 < V@27@06 && 0 <= i1@131@06)]
(assert (not (and (< i1@131@06 V@27@06) (<= 0 i1@131@06))))
(pop) ; 12
(pop) ; 11
; Joined path conditions
(assert (implies
  (and (< i1@131@06 V@27@06) (<= 0 i1@131@06))
  (and
    (< i1@131@06 V@27@06)
    (<= 0 i1@131@06)
    (< i1@131@06 (alen<Int> (opt_get1 $Snap.unit res@68@06)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@131@06)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@131@06)))))
; Joined path conditions
(pop) ; 10
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@131@06 Int)) (!
  (implies
    (and (< i1@131@06 V@27@06) (<= 0 i1@131@06))
    (and
      (< i1@131@06 V@27@06)
      (<= 0 i1@131@06)
      (< i1@131@06 (alen<Int> (opt_get1 $Snap.unit res@68@06)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@131@06)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@131@06))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@131@06))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 9
(pop) ; 8
; Joined path conditions
(assert (implies
  (= exc@116@06 $Ref.null)
  (forall ((i1@131@06 Int)) (!
    (implies
      (and (< i1@131@06 V@27@06) (<= 0 i1@131@06))
      (and
        (< i1@131@06 V@27@06)
        (<= 0 i1@131@06)
        (< i1@131@06 (alen<Int> (opt_get1 $Snap.unit res@68@06)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@131@06)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@131@06))))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@131@06))
    :qid |prog.l<no position>-aux|))))
(assert (implies
  (= exc@116@06 $Ref.null)
  (forall ((i1@131@06 Int)) (!
    (implies
      (and (< i1@131@06 V@27@06) (<= 0 i1@131@06))
      (not
        (=
          ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@131@06))
          (as None<option<array>>  option<array>))))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@131@06))
    :qid |prog.l<no position>|))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@118@06)))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@118@06))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@118@06)))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@118@06))))))))))))
  $Snap.unit))
; [eval] exc == null ==> (forall i1: Int :: { alen(opt_get1(aloc(opt_get1(target), i1).option$array$)) } 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(target), i1).option$array$)) == V)
; [eval] exc == null
(push) ; 8
(set-option :timeout 10)
(push) ; 9
(assert (not (not (= exc@116@06 $Ref.null))))
(check-sat)
; unknown
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               11332
;  :arith-add-rows          7527
;  :arith-assert-diseq      776
;  :arith-assert-lower      3286
;  :arith-assert-upper      2136
;  :arith-bound-prop        1015
;  :arith-conflicts         246
;  :arith-eq-adapter        2317
;  :arith-fixed-eqs         1104
;  :arith-offset-eqs        1096
;  :arith-pivots            2039
;  :conflicts               544
;  :datatype-accessor-ax    62
;  :datatype-constructor-ax 294
;  :datatype-occurs-check   183
;  :datatype-splits         145
;  :decisions               1229
;  :del-clause              15346
;  :final-checks            111
;  :interface-eqs           6
;  :max-generation          8
;  :max-memory              7.15
;  :memory                  7.12
;  :minimized-lits          59
;  :mk-bool-var             21833
;  :mk-clause               15350
;  :num-allocs              288969
;  :num-checks              182
;  :propagations            7015
;  :quant-instantiations    5356
;  :rlimit-count            670991)
; [then-branch: 120 | exc@116@06 == Null | live]
; [else-branch: 120 | exc@116@06 != Null | dead]
(push) ; 9
; [then-branch: 120 | exc@116@06 == Null]
; [eval] (forall i1: Int :: { alen(opt_get1(aloc(opt_get1(target), i1).option$array$)) } 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(target), i1).option$array$)) == V)
(declare-const i1@132@06 Int)
(push) ; 10
; [eval] 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(target), i1).option$array$)) == V
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 11
; [then-branch: 121 | 0 <= i1@132@06 | live]
; [else-branch: 121 | !(0 <= i1@132@06) | live]
(push) ; 12
; [then-branch: 121 | 0 <= i1@132@06]
(assert (<= 0 i1@132@06))
; [eval] i1 < V
(pop) ; 12
(push) ; 12
; [else-branch: 121 | !(0 <= i1@132@06)]
(assert (not (<= 0 i1@132@06)))
(pop) ; 12
(pop) ; 11
; Joined path conditions
; Joined path conditions
(push) ; 11
; [then-branch: 122 | i1@132@06 < V@27@06 && 0 <= i1@132@06 | live]
; [else-branch: 122 | !(i1@132@06 < V@27@06 && 0 <= i1@132@06) | live]
(push) ; 12
; [then-branch: 122 | i1@132@06 < V@27@06 && 0 <= i1@132@06]
(assert (and (< i1@132@06 V@27@06) (<= 0 i1@132@06)))
; [eval] alen(opt_get1(aloc(opt_get1(target), i1).option$array$)) == V
; [eval] alen(opt_get1(aloc(opt_get1(target), i1).option$array$))
; [eval] opt_get1(aloc(opt_get1(target), i1).option$array$)
; [eval] aloc(opt_get1(target), i1)
; [eval] opt_get1(target)
(push) ; 13
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 13
; Joined path conditions
(push) ; 13
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 14
(assert (not (< i1@132@06 (alen<Int> (opt_get1 $Snap.unit res@68@06)))))
(check-sat)
; unsat
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               11332
;  :arith-add-rows          7528
;  :arith-assert-diseq      776
;  :arith-assert-lower      3288
;  :arith-assert-upper      2136
;  :arith-bound-prop        1015
;  :arith-conflicts         246
;  :arith-eq-adapter        2317
;  :arith-fixed-eqs         1104
;  :arith-offset-eqs        1096
;  :arith-pivots            2039
;  :conflicts               544
;  :datatype-accessor-ax    62
;  :datatype-constructor-ax 294
;  :datatype-occurs-check   183
;  :datatype-splits         145
;  :decisions               1229
;  :del-clause              15346
;  :final-checks            111
;  :interface-eqs           6
;  :max-generation          8
;  :max-memory              7.15
;  :memory                  7.12
;  :minimized-lits          59
;  :mk-bool-var             21835
;  :mk-clause               15350
;  :num-allocs              289072
;  :num-checks              183
;  :propagations            7015
;  :quant-instantiations    5356
;  :rlimit-count            671185)
(assert (< i1@132@06 (alen<Int> (opt_get1 $Snap.unit res@68@06))))
(pop) ; 13
; Joined path conditions
(assert (< i1@132@06 (alen<Int> (opt_get1 $Snap.unit res@68@06))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@132@06)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@132@06)))
(push) ; 13
(assert (not (<
  $Perm.No
  (+
    (+
      (+
        (ite
          (and
            (<
              (inv@129@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@132@06))
              V@27@06)
            (<=
              0
              (inv@129@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@132@06))))
          $k@128@06
          $Perm.No)
        (ite
          (and
            (<
              (inv@121@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@132@06))
              V@27@06)
            (<=
              0
              (inv@121@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@132@06))))
          $k@120@06
          $Perm.No))
      (-
        (-
          (ite
            (and
              (<
                (inv@71@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@132@06))
                V@27@06)
              (<=
                0
                (inv@71@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@132@06))))
            $Perm.Write
            $Perm.No)
          (pTaken@87@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@132@06)))
        (pTaken@98@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@132@06))))
    (-
      (-
        (ite
          (and
            (<
              (inv@33@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@132@06))
              V@27@06)
            (<=
              0
              (inv@33@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@132@06))))
          $k@32@06
          $Perm.No)
        (pTaken@88@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@132@06)))
      (pTaken@97@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@132@06)))))))
(check-sat)
; unsat
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               11459
;  :arith-add-rows          7736
;  :arith-assert-diseq      783
;  :arith-assert-lower      3334
;  :arith-assert-upper      2165
;  :arith-bound-prop        1039
;  :arith-conflicts         251
;  :arith-eq-adapter        2350
;  :arith-fixed-eqs         1120
;  :arith-offset-eqs        1113
;  :arith-pivots            2081
;  :conflicts               558
;  :datatype-accessor-ax    62
;  :datatype-constructor-ax 296
;  :datatype-occurs-check   183
;  :datatype-splits         145
;  :decisions               1246
;  :del-clause              15471
;  :final-checks            111
;  :interface-eqs           6
;  :max-generation          8
;  :max-memory              7.15
;  :memory                  7.12
;  :minimized-lits          59
;  :mk-bool-var             22234
;  :mk-clause               15606
;  :num-allocs              290995
;  :num-checks              184
;  :propagations            7094
;  :quant-instantiations    5420
;  :rlimit-count            681053
;  :time                    0.00)
(push) ; 13
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 14
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@132@06))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               11459
;  :arith-add-rows          7736
;  :arith-assert-diseq      783
;  :arith-assert-lower      3334
;  :arith-assert-upper      2165
;  :arith-bound-prop        1039
;  :arith-conflicts         251
;  :arith-eq-adapter        2350
;  :arith-fixed-eqs         1120
;  :arith-offset-eqs        1113
;  :arith-pivots            2081
;  :conflicts               559
;  :datatype-accessor-ax    62
;  :datatype-constructor-ax 296
;  :datatype-occurs-check   183
;  :datatype-splits         145
;  :decisions               1246
;  :del-clause              15471
;  :final-checks            111
;  :interface-eqs           6
;  :max-generation          8
;  :max-memory              7.15
;  :memory                  7.12
;  :minimized-lits          59
;  :mk-bool-var             22234
;  :mk-clause               15606
;  :num-allocs              291084
;  :num-checks              185
;  :propagations            7094
;  :quant-instantiations    5420
;  :rlimit-count            681148)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@132@06))
    (as None<option<array>>  option<array>))))
(pop) ; 13
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@132@06))
    (as None<option<array>>  option<array>))))
(pop) ; 12
(push) ; 12
; [else-branch: 122 | !(i1@132@06 < V@27@06 && 0 <= i1@132@06)]
(assert (not (and (< i1@132@06 V@27@06) (<= 0 i1@132@06))))
(pop) ; 12
(pop) ; 11
; Joined path conditions
(assert (implies
  (and (< i1@132@06 V@27@06) (<= 0 i1@132@06))
  (and
    (< i1@132@06 V@27@06)
    (<= 0 i1@132@06)
    (< i1@132@06 (alen<Int> (opt_get1 $Snap.unit res@68@06)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@132@06)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@132@06))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@132@06))
        (as None<option<array>>  option<array>))))))
; Joined path conditions
(pop) ; 10
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@132@06 Int)) (!
  (implies
    (and (< i1@132@06 V@27@06) (<= 0 i1@132@06))
    (and
      (< i1@132@06 V@27@06)
      (<= 0 i1@132@06)
      (< i1@132@06 (alen<Int> (opt_get1 $Snap.unit res@68@06)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@132@06)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@132@06))
      (not
        (=
          ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@132@06))
          (as None<option<array>>  option<array>)))))
  :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@132@06)))))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 9
(pop) ; 8
; Joined path conditions
(assert (implies
  (= exc@116@06 $Ref.null)
  (forall ((i1@132@06 Int)) (!
    (implies
      (and (< i1@132@06 V@27@06) (<= 0 i1@132@06))
      (and
        (< i1@132@06 V@27@06)
        (<= 0 i1@132@06)
        (< i1@132@06 (alen<Int> (opt_get1 $Snap.unit res@68@06)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@132@06)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@132@06))
        (not
          (=
            ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@132@06))
            (as None<option<array>>  option<array>)))))
    :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@132@06)))))
    :qid |prog.l<no position>-aux|))))
(assert (implies
  (= exc@116@06 $Ref.null)
  (forall ((i1@132@06 Int)) (!
    (implies
      (and (< i1@132@06 V@27@06) (<= 0 i1@132@06))
      (=
        (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@132@06))))
        V@27@06))
    :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@132@06)))))
    :qid |prog.l<no position>|))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@118@06))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@118@06)))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@118@06))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@118@06)))))))))))))
  $Snap.unit))
; [eval] exc == null ==> (forall i1: Int :: { aloc(opt_get1(target), i1) } (forall i2: Int :: { aloc(opt_get1(target), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(target), i1).option$array$ == aloc(opt_get1(target), i2).option$array$ ==> i1 == i2))
; [eval] exc == null
(push) ; 8
(set-option :timeout 10)
(push) ; 9
(assert (not (not (= exc@116@06 $Ref.null))))
(check-sat)
; unknown
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               11503
;  :arith-add-rows          7745
;  :arith-assert-diseq      783
;  :arith-assert-lower      3334
;  :arith-assert-upper      2165
;  :arith-bound-prop        1039
;  :arith-conflicts         251
;  :arith-eq-adapter        2350
;  :arith-fixed-eqs         1120
;  :arith-offset-eqs        1113
;  :arith-pivots            2088
;  :conflicts               559
;  :datatype-accessor-ax    63
;  :datatype-constructor-ax 303
;  :datatype-occurs-check   189
;  :datatype-splits         150
;  :decisions               1253
;  :del-clause              15602
;  :final-checks            113
;  :interface-eqs           6
;  :max-generation          8
;  :max-memory              7.15
;  :memory                  7.12
;  :minimized-lits          59
;  :mk-bool-var             22243
;  :mk-clause               15606
;  :num-allocs              292184
;  :num-checks              186
;  :propagations            7094
;  :quant-instantiations    5420
;  :rlimit-count            683108)
; [then-branch: 123 | exc@116@06 == Null | live]
; [else-branch: 123 | exc@116@06 != Null | dead]
(push) ; 9
; [then-branch: 123 | exc@116@06 == Null]
; [eval] (forall i1: Int :: { aloc(opt_get1(target), i1) } (forall i2: Int :: { aloc(opt_get1(target), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(target), i1).option$array$ == aloc(opt_get1(target), i2).option$array$ ==> i1 == i2))
(declare-const i1@133@06 Int)
(push) ; 10
; [eval] (forall i2: Int :: { aloc(opt_get1(target), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(target), i1).option$array$ == aloc(opt_get1(target), i2).option$array$ ==> i1 == i2)
(declare-const i2@134@06 Int)
(push) ; 11
; [eval] 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(target), i1).option$array$ == aloc(opt_get1(target), i2).option$array$ ==> i1 == i2
; [eval] 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(target), i1).option$array$ == aloc(opt_get1(target), i2).option$array$
; [eval] 0 <= i1
(push) ; 12
; [then-branch: 124 | 0 <= i1@133@06 | live]
; [else-branch: 124 | !(0 <= i1@133@06) | live]
(push) ; 13
; [then-branch: 124 | 0 <= i1@133@06]
(assert (<= 0 i1@133@06))
; [eval] i1 < V
(push) ; 14
; [then-branch: 125 | i1@133@06 < V@27@06 | live]
; [else-branch: 125 | !(i1@133@06 < V@27@06) | live]
(push) ; 15
; [then-branch: 125 | i1@133@06 < V@27@06]
(assert (< i1@133@06 V@27@06))
; [eval] 0 <= i2
(push) ; 16
; [then-branch: 126 | 0 <= i2@134@06 | live]
; [else-branch: 126 | !(0 <= i2@134@06) | live]
(push) ; 17
; [then-branch: 126 | 0 <= i2@134@06]
(assert (<= 0 i2@134@06))
; [eval] i2 < V
(push) ; 18
; [then-branch: 127 | i2@134@06 < V@27@06 | live]
; [else-branch: 127 | !(i2@134@06 < V@27@06) | live]
(push) ; 19
; [then-branch: 127 | i2@134@06 < V@27@06]
(assert (< i2@134@06 V@27@06))
; [eval] aloc(opt_get1(target), i1).option$array$ == aloc(opt_get1(target), i2).option$array$
; [eval] aloc(opt_get1(target), i1)
; [eval] opt_get1(target)
(push) ; 20
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 20
; Joined path conditions
(push) ; 20
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 21
(assert (not (< i1@133@06 (alen<Int> (opt_get1 $Snap.unit res@68@06)))))
(check-sat)
; unsat
(pop) ; 21
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               11503
;  :arith-add-rows          7747
;  :arith-assert-diseq      783
;  :arith-assert-lower      3338
;  :arith-assert-upper      2165
;  :arith-bound-prop        1039
;  :arith-conflicts         251
;  :arith-eq-adapter        2350
;  :arith-fixed-eqs         1120
;  :arith-offset-eqs        1113
;  :arith-pivots            2088
;  :conflicts               559
;  :datatype-accessor-ax    63
;  :datatype-constructor-ax 303
;  :datatype-occurs-check   189
;  :datatype-splits         150
;  :decisions               1253
;  :del-clause              15602
;  :final-checks            113
;  :interface-eqs           6
;  :max-generation          8
;  :max-memory              7.15
;  :memory                  7.12
;  :minimized-lits          59
;  :mk-bool-var             22247
;  :mk-clause               15606
;  :num-allocs              292464
;  :num-checks              187
;  :propagations            7094
;  :quant-instantiations    5420
;  :rlimit-count            683448)
(assert (< i1@133@06 (alen<Int> (opt_get1 $Snap.unit res@68@06))))
(pop) ; 20
; Joined path conditions
(assert (< i1@133@06 (alen<Int> (opt_get1 $Snap.unit res@68@06))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@133@06)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@133@06)))
(push) ; 20
(assert (not (<
  $Perm.No
  (+
    (+
      (+
        (ite
          (and
            (<
              (inv@129@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@133@06))
              V@27@06)
            (<=
              0
              (inv@129@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@133@06))))
          $k@128@06
          $Perm.No)
        (ite
          (and
            (<
              (inv@121@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@133@06))
              V@27@06)
            (<=
              0
              (inv@121@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@133@06))))
          $k@120@06
          $Perm.No))
      (-
        (-
          (ite
            (and
              (<
                (inv@71@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@133@06))
                V@27@06)
              (<=
                0
                (inv@71@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@133@06))))
            $Perm.Write
            $Perm.No)
          (pTaken@87@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@133@06)))
        (pTaken@98@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@133@06))))
    (-
      (-
        (ite
          (and
            (<
              (inv@33@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@133@06))
              V@27@06)
            (<=
              0
              (inv@33@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@133@06))))
          $k@32@06
          $Perm.No)
        (pTaken@88@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@133@06)))
      (pTaken@97@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@133@06)))))))
(check-sat)
; unsat
(pop) ; 20
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               11705
;  :arith-add-rows          7923
;  :arith-assert-diseq      803
;  :arith-assert-lower      3422
;  :arith-assert-upper      2209
;  :arith-bound-prop        1075
;  :arith-conflicts         258
;  :arith-eq-adapter        2403
;  :arith-fixed-eqs         1139
;  :arith-offset-eqs        1147
;  :arith-pivots            2122
;  :conflicts               575
;  :datatype-accessor-ax    63
;  :datatype-constructor-ax 305
;  :datatype-occurs-check   189
;  :datatype-splits         150
;  :decisions               1296
;  :del-clause              15983
;  :final-checks            113
;  :interface-eqs           6
;  :max-generation          8
;  :max-memory              7.15
;  :memory                  7.13
;  :minimized-lits          59
;  :mk-bool-var             22916
;  :mk-clause               16119
;  :num-allocs              294776
;  :num-checks              188
;  :propagations            7260
;  :quant-instantiations    5521
;  :rlimit-count            694625
;  :time                    0.00)
; [eval] aloc(opt_get1(target), i2)
; [eval] opt_get1(target)
(push) ; 20
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 20
; Joined path conditions
(push) ; 20
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 21
(assert (not (< i2@134@06 (alen<Int> (opt_get1 $Snap.unit res@68@06)))))
(check-sat)
; unsat
(pop) ; 21
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               11705
;  :arith-add-rows          7923
;  :arith-assert-diseq      803
;  :arith-assert-lower      3422
;  :arith-assert-upper      2209
;  :arith-bound-prop        1075
;  :arith-conflicts         258
;  :arith-eq-adapter        2403
;  :arith-fixed-eqs         1139
;  :arith-offset-eqs        1147
;  :arith-pivots            2122
;  :conflicts               575
;  :datatype-accessor-ax    63
;  :datatype-constructor-ax 305
;  :datatype-occurs-check   189
;  :datatype-splits         150
;  :decisions               1296
;  :del-clause              15983
;  :final-checks            113
;  :interface-eqs           6
;  :max-generation          8
;  :max-memory              7.15
;  :memory                  7.13
;  :minimized-lits          59
;  :mk-bool-var             22916
;  :mk-clause               16119
;  :num-allocs              294802
;  :num-checks              189
;  :propagations            7260
;  :quant-instantiations    5521
;  :rlimit-count            694655)
(assert (< i2@134@06 (alen<Int> (opt_get1 $Snap.unit res@68@06))))
(pop) ; 20
; Joined path conditions
(assert (< i2@134@06 (alen<Int> (opt_get1 $Snap.unit res@68@06))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit res@68@06) i2@134@06)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit res@68@06) i2@134@06)))
(push) ; 20
(assert (not (<
  $Perm.No
  (+
    (+
      (+
        (ite
          (and
            (<
              (inv@129@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@68@06) i2@134@06))
              V@27@06)
            (<=
              0
              (inv@129@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@68@06) i2@134@06))))
          $k@128@06
          $Perm.No)
        (ite
          (and
            (<
              (inv@121@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@68@06) i2@134@06))
              V@27@06)
            (<=
              0
              (inv@121@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@68@06) i2@134@06))))
          $k@120@06
          $Perm.No))
      (-
        (-
          (ite
            (and
              (<
                (inv@71@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@68@06) i2@134@06))
                V@27@06)
              (<=
                0
                (inv@71@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@68@06) i2@134@06))))
            $Perm.Write
            $Perm.No)
          (pTaken@87@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@68@06) i2@134@06)))
        (pTaken@98@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@68@06) i2@134@06))))
    (-
      (-
        (ite
          (and
            (<
              (inv@33@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@68@06) i2@134@06))
              V@27@06)
            (<=
              0
              (inv@33@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@68@06) i2@134@06))))
          $k@32@06
          $Perm.No)
        (pTaken@88@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@68@06) i2@134@06)))
      (pTaken@97@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@68@06) i2@134@06)))))))
(check-sat)
; unsat
(pop) ; 20
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               12177
;  :arith-add-rows          8355
;  :arith-assert-diseq      851
;  :arith-assert-lower      3607
;  :arith-assert-upper      2308
;  :arith-bound-prop        1150
;  :arith-conflicts         268
;  :arith-eq-adapter        2510
;  :arith-fixed-eqs         1181
;  :arith-offset-eqs        1239
;  :arith-pivots            2188
;  :conflicts               605
;  :datatype-accessor-ax    63
;  :datatype-constructor-ax 307
;  :datatype-occurs-check   189
;  :datatype-splits         150
;  :decisions               1374
;  :del-clause              16693
;  :final-checks            113
;  :interface-eqs           6
;  :max-generation          8
;  :max-memory              7.20
;  :memory                  7.19
;  :minimized-lits          59
;  :mk-bool-var             24163
;  :mk-clause               16934
;  :num-allocs              299708
;  :num-checks              190
;  :propagations            7611
;  :quant-instantiations    5692
;  :rlimit-count            716837
;  :time                    0.01)
(pop) ; 19
(push) ; 19
; [else-branch: 127 | !(i2@134@06 < V@27@06)]
(assert (not (< i2@134@06 V@27@06)))
(pop) ; 19
(pop) ; 18
; Joined path conditions
(assert (implies
  (< i2@134@06 V@27@06)
  (and
    (< i2@134@06 V@27@06)
    (< i1@133@06 (alen<Int> (opt_get1 $Snap.unit res@68@06)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@133@06)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@133@06))
    (< i2@134@06 (alen<Int> (opt_get1 $Snap.unit res@68@06)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@68@06) i2@134@06)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@68@06) i2@134@06)))))
; Joined path conditions
(pop) ; 17
(push) ; 17
; [else-branch: 126 | !(0 <= i2@134@06)]
(assert (not (<= 0 i2@134@06)))
(pop) ; 17
(pop) ; 16
; Joined path conditions
(assert (implies
  (<= 0 i2@134@06)
  (and
    (<= 0 i2@134@06)
    (implies
      (< i2@134@06 V@27@06)
      (and
        (< i2@134@06 V@27@06)
        (< i1@133@06 (alen<Int> (opt_get1 $Snap.unit res@68@06)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@133@06)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@133@06))
        (< i2@134@06 (alen<Int> (opt_get1 $Snap.unit res@68@06)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@68@06) i2@134@06)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@68@06) i2@134@06)))))))
; Joined path conditions
(pop) ; 15
(push) ; 15
; [else-branch: 125 | !(i1@133@06 < V@27@06)]
(assert (not (< i1@133@06 V@27@06)))
(pop) ; 15
(pop) ; 14
; Joined path conditions
(assert (implies
  (< i1@133@06 V@27@06)
  (and
    (< i1@133@06 V@27@06)
    (implies
      (<= 0 i2@134@06)
      (and
        (<= 0 i2@134@06)
        (implies
          (< i2@134@06 V@27@06)
          (and
            (< i2@134@06 V@27@06)
            (< i1@133@06 (alen<Int> (opt_get1 $Snap.unit res@68@06)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@133@06)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@133@06))
            (< i2@134@06 (alen<Int> (opt_get1 $Snap.unit res@68@06)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit res@68@06) i2@134@06)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit res@68@06) i2@134@06)))))))))
; Joined path conditions
(pop) ; 13
(push) ; 13
; [else-branch: 124 | !(0 <= i1@133@06)]
(assert (not (<= 0 i1@133@06)))
(pop) ; 13
(pop) ; 12
; Joined path conditions
(assert (implies
  (<= 0 i1@133@06)
  (and
    (<= 0 i1@133@06)
    (implies
      (< i1@133@06 V@27@06)
      (and
        (< i1@133@06 V@27@06)
        (implies
          (<= 0 i2@134@06)
          (and
            (<= 0 i2@134@06)
            (implies
              (< i2@134@06 V@27@06)
              (and
                (< i2@134@06 V@27@06)
                (< i1@133@06 (alen<Int> (opt_get1 $Snap.unit res@68@06)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@133@06)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@133@06))
                (< i2@134@06 (alen<Int> (opt_get1 $Snap.unit res@68@06)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit res@68@06) i2@134@06)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit res@68@06) i2@134@06)))))))))))
; Joined path conditions
(push) ; 12
; [then-branch: 128 | Lookup(option$array$,sm@130@06,aloc((_, _), opt_get1(_, res@68@06), i1@133@06)) == Lookup(option$array$,sm@130@06,aloc((_, _), opt_get1(_, res@68@06), i2@134@06)) && i2@134@06 < V@27@06 && 0 <= i2@134@06 && i1@133@06 < V@27@06 && 0 <= i1@133@06 | live]
; [else-branch: 128 | !(Lookup(option$array$,sm@130@06,aloc((_, _), opt_get1(_, res@68@06), i1@133@06)) == Lookup(option$array$,sm@130@06,aloc((_, _), opt_get1(_, res@68@06), i2@134@06)) && i2@134@06 < V@27@06 && 0 <= i2@134@06 && i1@133@06 < V@27@06 && 0 <= i1@133@06) | live]
(push) ; 13
; [then-branch: 128 | Lookup(option$array$,sm@130@06,aloc((_, _), opt_get1(_, res@68@06), i1@133@06)) == Lookup(option$array$,sm@130@06,aloc((_, _), opt_get1(_, res@68@06), i2@134@06)) && i2@134@06 < V@27@06 && 0 <= i2@134@06 && i1@133@06 < V@27@06 && 0 <= i1@133@06]
(assert (and
  (and
    (and
      (and
        (=
          ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@133@06))
          ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit res@68@06) i2@134@06)))
        (< i2@134@06 V@27@06))
      (<= 0 i2@134@06))
    (< i1@133@06 V@27@06))
  (<= 0 i1@133@06)))
; [eval] i1 == i2
(pop) ; 13
(push) ; 13
; [else-branch: 128 | !(Lookup(option$array$,sm@130@06,aloc((_, _), opt_get1(_, res@68@06), i1@133@06)) == Lookup(option$array$,sm@130@06,aloc((_, _), opt_get1(_, res@68@06), i2@134@06)) && i2@134@06 < V@27@06 && 0 <= i2@134@06 && i1@133@06 < V@27@06 && 0 <= i1@133@06)]
(assert (not
  (and
    (and
      (and
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@133@06))
            ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit res@68@06) i2@134@06)))
          (< i2@134@06 V@27@06))
        (<= 0 i2@134@06))
      (< i1@133@06 V@27@06))
    (<= 0 i1@133@06))))
(pop) ; 13
(pop) ; 12
; Joined path conditions
(assert (implies
  (and
    (and
      (and
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@133@06))
            ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit res@68@06) i2@134@06)))
          (< i2@134@06 V@27@06))
        (<= 0 i2@134@06))
      (< i1@133@06 V@27@06))
    (<= 0 i1@133@06))
  (and
    (=
      ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@133@06))
      ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit res@68@06) i2@134@06)))
    (< i2@134@06 V@27@06)
    (<= 0 i2@134@06)
    (< i1@133@06 V@27@06)
    (<= 0 i1@133@06))))
; Joined path conditions
(pop) ; 11
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i2@134@06 Int)) (!
  (and
    (implies
      (<= 0 i1@133@06)
      (and
        (<= 0 i1@133@06)
        (implies
          (< i1@133@06 V@27@06)
          (and
            (< i1@133@06 V@27@06)
            (implies
              (<= 0 i2@134@06)
              (and
                (<= 0 i2@134@06)
                (implies
                  (< i2@134@06 V@27@06)
                  (and
                    (< i2@134@06 V@27@06)
                    (< i1@133@06 (alen<Int> (opt_get1 $Snap.unit res@68@06)))
                    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@133@06)) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@133@06))
                    (< i2@134@06 (alen<Int> (opt_get1 $Snap.unit res@68@06)))
                    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit res@68@06) i2@134@06)) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit res@68@06) i2@134@06))))))))))
    (implies
      (and
        (and
          (and
            (and
              (=
                ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@133@06))
                ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit res@68@06) i2@134@06)))
              (< i2@134@06 V@27@06))
            (<= 0 i2@134@06))
          (< i1@133@06 V@27@06))
        (<= 0 i1@133@06))
      (and
        (=
          ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@133@06))
          ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit res@68@06) i2@134@06)))
        (< i2@134@06 V@27@06)
        (<= 0 i2@134@06)
        (< i1@133@06 V@27@06)
        (<= 0 i1@133@06))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@68@06) i2@134@06))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 10
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@133@06 Int)) (!
  (forall ((i2@134@06 Int)) (!
    (and
      (implies
        (<= 0 i1@133@06)
        (and
          (<= 0 i1@133@06)
          (implies
            (< i1@133@06 V@27@06)
            (and
              (< i1@133@06 V@27@06)
              (implies
                (<= 0 i2@134@06)
                (and
                  (<= 0 i2@134@06)
                  (implies
                    (< i2@134@06 V@27@06)
                    (and
                      (< i2@134@06 V@27@06)
                      (< i1@133@06 (alen<Int> (opt_get1 $Snap.unit res@68@06)))
                      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@133@06)) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@133@06))
                      (< i2@134@06 (alen<Int> (opt_get1 $Snap.unit res@68@06)))
                      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit res@68@06) i2@134@06)) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit res@68@06) i2@134@06))))))))))
      (implies
        (and
          (and
            (and
              (and
                (=
                  ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@133@06))
                  ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit res@68@06) i2@134@06)))
                (< i2@134@06 V@27@06))
              (<= 0 i2@134@06))
            (< i1@133@06 V@27@06))
          (<= 0 i1@133@06))
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@133@06))
            ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit res@68@06) i2@134@06)))
          (< i2@134@06 V@27@06)
          (<= 0 i2@134@06)
          (< i1@133@06 V@27@06)
          (<= 0 i1@133@06))))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@68@06) i2@134@06))
    :qid |prog.l<no position>-aux|))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@133@06))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 9
(pop) ; 8
; Joined path conditions
(assert (implies
  (= exc@116@06 $Ref.null)
  (forall ((i1@133@06 Int)) (!
    (forall ((i2@134@06 Int)) (!
      (and
        (implies
          (<= 0 i1@133@06)
          (and
            (<= 0 i1@133@06)
            (implies
              (< i1@133@06 V@27@06)
              (and
                (< i1@133@06 V@27@06)
                (implies
                  (<= 0 i2@134@06)
                  (and
                    (<= 0 i2@134@06)
                    (implies
                      (< i2@134@06 V@27@06)
                      (and
                        (< i2@134@06 V@27@06)
                        (< i1@133@06 (alen<Int> (opt_get1 $Snap.unit res@68@06)))
                        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
                          $Snap.unit
                          $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@133@06)) (aloc ($Snap.combine
                          $Snap.unit
                          $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@133@06))
                        (< i2@134@06 (alen<Int> (opt_get1 $Snap.unit res@68@06)))
                        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
                          $Snap.unit
                          $Snap.unit) (opt_get1 $Snap.unit res@68@06) i2@134@06)) (aloc ($Snap.combine
                          $Snap.unit
                          $Snap.unit) (opt_get1 $Snap.unit res@68@06) i2@134@06))))))))))
        (implies
          (and
            (and
              (and
                (and
                  (=
                    ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@133@06))
                    ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit res@68@06) i2@134@06)))
                  (< i2@134@06 V@27@06))
                (<= 0 i2@134@06))
              (< i1@133@06 V@27@06))
            (<= 0 i1@133@06))
          (and
            (=
              ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@133@06))
              ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit res@68@06) i2@134@06)))
            (< i2@134@06 V@27@06)
            (<= 0 i2@134@06)
            (< i1@133@06 V@27@06)
            (<= 0 i1@133@06))))
      :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@68@06) i2@134@06))
      :qid |prog.l<no position>-aux|))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@133@06))
    :qid |prog.l<no position>-aux|))))
(assert (implies
  (= exc@116@06 $Ref.null)
  (forall ((i1@133@06 Int)) (!
    (forall ((i2@134@06 Int)) (!
      (implies
        (and
          (and
            (and
              (and
                (=
                  ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@133@06))
                  ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit res@68@06) i2@134@06)))
                (< i2@134@06 V@27@06))
              (<= 0 i2@134@06))
            (< i1@133@06 V@27@06))
          (<= 0 i1@133@06))
        (= i1@133@06 i2@134@06))
      :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@68@06) i2@134@06))
      :qid |prog.l<no position>|))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@133@06))
    :qid |prog.l<no position>|))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@118@06)))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@118@06))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@118@06)))))))))))))))))
; [eval] exc == null
(set-option :timeout 10)
(push) ; 8
(assert (not (not (= exc@116@06 $Ref.null))))
(check-sat)
; unknown
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               12222
;  :arith-add-rows          8389
;  :arith-assert-diseq      851
;  :arith-assert-lower      3607
;  :arith-assert-upper      2308
;  :arith-bound-prop        1150
;  :arith-conflicts         268
;  :arith-eq-adapter        2510
;  :arith-fixed-eqs         1181
;  :arith-offset-eqs        1239
;  :arith-pivots            2209
;  :conflicts               605
;  :datatype-accessor-ax    64
;  :datatype-constructor-ax 315
;  :datatype-occurs-check   195
;  :datatype-splits         156
;  :decisions               1382
;  :del-clause              16954
;  :final-checks            115
;  :interface-eqs           6
;  :max-generation          8
;  :max-memory              7.20
;  :memory                  7.16
;  :minimized-lits          59
;  :mk-bool-var             24185
;  :mk-clause               16958
;  :num-allocs              301300
;  :num-checks              191
;  :propagations            7611
;  :quant-instantiations    5692
;  :rlimit-count            720538)
; [then-branch: 129 | exc@116@06 == Null | live]
; [else-branch: 129 | exc@116@06 != Null | dead]
(push) ; 8
; [then-branch: 129 | exc@116@06 == Null]
(declare-const i1@135@06 Int)
(declare-const j1@136@06 Int)
(push) ; 9
; [eval] 0 <= i1 && i1 < V && (0 <= j1 && j1 < V)
; [eval] 0 <= i1
(push) ; 10
; [then-branch: 130 | 0 <= i1@135@06 | live]
; [else-branch: 130 | !(0 <= i1@135@06) | live]
(push) ; 11
; [then-branch: 130 | 0 <= i1@135@06]
(assert (<= 0 i1@135@06))
; [eval] i1 < V
(push) ; 12
; [then-branch: 131 | i1@135@06 < V@27@06 | live]
; [else-branch: 131 | !(i1@135@06 < V@27@06) | live]
(push) ; 13
; [then-branch: 131 | i1@135@06 < V@27@06]
(assert (< i1@135@06 V@27@06))
; [eval] 0 <= j1
(push) ; 14
; [then-branch: 132 | 0 <= j1@136@06 | live]
; [else-branch: 132 | !(0 <= j1@136@06) | live]
(push) ; 15
; [then-branch: 132 | 0 <= j1@136@06]
(assert (<= 0 j1@136@06))
; [eval] j1 < V
(pop) ; 15
(push) ; 15
; [else-branch: 132 | !(0 <= j1@136@06)]
(assert (not (<= 0 j1@136@06)))
(pop) ; 15
(pop) ; 14
; Joined path conditions
; Joined path conditions
(pop) ; 13
(push) ; 13
; [else-branch: 131 | !(i1@135@06 < V@27@06)]
(assert (not (< i1@135@06 V@27@06)))
(pop) ; 13
(pop) ; 12
; Joined path conditions
; Joined path conditions
(pop) ; 11
(push) ; 11
; [else-branch: 130 | !(0 <= i1@135@06)]
(assert (not (<= 0 i1@135@06)))
(pop) ; 11
(pop) ; 10
; Joined path conditions
; Joined path conditions
(assert (and
  (and (and (< j1@136@06 V@27@06) (<= 0 j1@136@06)) (< i1@135@06 V@27@06))
  (<= 0 i1@135@06)))
; [eval] aloc(opt_get1(aloc(opt_get1(source), i1).option$array$), j1)
; [eval] opt_get1(aloc(opt_get1(source), i1).option$array$)
; [eval] aloc(opt_get1(source), i1)
; [eval] opt_get1(source)
(push) ; 10
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 10
; Joined path conditions
(push) ; 10
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 11
(assert (not (< i1@135@06 (alen<Int> (opt_get1 $Snap.unit G@24@06)))))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               12222
;  :arith-add-rows          8392
;  :arith-assert-diseq      851
;  :arith-assert-lower      3613
;  :arith-assert-upper      2308
;  :arith-bound-prop        1150
;  :arith-conflicts         268
;  :arith-eq-adapter        2510
;  :arith-fixed-eqs         1181
;  :arith-offset-eqs        1239
;  :arith-pivots            2209
;  :conflicts               605
;  :datatype-accessor-ax    64
;  :datatype-constructor-ax 315
;  :datatype-occurs-check   195
;  :datatype-splits         156
;  :decisions               1382
;  :del-clause              16954
;  :final-checks            115
;  :interface-eqs           6
;  :max-generation          8
;  :max-memory              7.20
;  :memory                  7.16
;  :minimized-lits          59
;  :mk-bool-var             24191
;  :mk-clause               16958
;  :num-allocs              301573
;  :num-checks              192
;  :propagations            7611
;  :quant-instantiations    5692
;  :rlimit-count            721013)
(assert (< i1@135@06 (alen<Int> (opt_get1 $Snap.unit G@24@06))))
(pop) ; 10
; Joined path conditions
(assert (< i1@135@06 (alen<Int> (opt_get1 $Snap.unit G@24@06))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@135@06)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@135@06)))
(push) ; 10
(assert (not (<
  $Perm.No
  (+
    (+
      (+
        (ite
          (and
            (<
              (inv@129@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@135@06))
              V@27@06)
            (<=
              0
              (inv@129@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@135@06))))
          $k@128@06
          $Perm.No)
        (ite
          (and
            (<
              (inv@121@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@135@06))
              V@27@06)
            (<=
              0
              (inv@121@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@135@06))))
          $k@120@06
          $Perm.No))
      (-
        (-
          (ite
            (and
              (<
                (inv@71@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@135@06))
                V@27@06)
              (<=
                0
                (inv@71@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@135@06))))
            $Perm.Write
            $Perm.No)
          (pTaken@87@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@135@06)))
        (pTaken@98@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@135@06))))
    (-
      (-
        (ite
          (and
            (<
              (inv@33@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@135@06))
              V@27@06)
            (<=
              0
              (inv@33@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@135@06))))
          $k@32@06
          $Perm.No)
        (pTaken@88@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@135@06)))
      (pTaken@97@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@135@06)))))))
(check-sat)
; unsat
(pop) ; 10
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               12618
;  :arith-add-rows          8876
;  :arith-assert-diseq      889
;  :arith-assert-lower      3757
;  :arith-assert-upper      2383
;  :arith-bound-prop        1206
;  :arith-conflicts         279
;  :arith-eq-adapter        2615
;  :arith-fixed-eqs         1224
;  :arith-offset-eqs        1287
;  :arith-pivots            2292
;  :conflicts               624
;  :datatype-accessor-ax    64
;  :datatype-constructor-ax 317
;  :datatype-occurs-check   195
;  :datatype-splits         156
;  :decisions               1464
;  :del-clause              17866
;  :final-checks            115
;  :interface-eqs           6
;  :max-generation          8
;  :max-memory              7.20
;  :memory                  7.17
;  :minimized-lits          61
;  :mk-bool-var             25426
;  :mk-clause               18004
;  :num-allocs              305626
;  :num-checks              193
;  :propagations            7973
;  :quant-instantiations    5968
;  :rlimit-count            746293
;  :time                    0.01)
(push) ; 10
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 11
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@135@06))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               12646
;  :arith-add-rows          8883
;  :arith-assert-diseq      889
;  :arith-assert-lower      3758
;  :arith-assert-upper      2385
;  :arith-bound-prop        1209
;  :arith-conflicts         280
;  :arith-eq-adapter        2616
;  :arith-fixed-eqs         1224
;  :arith-offset-eqs        1294
;  :arith-pivots            2293
;  :conflicts               629
;  :datatype-accessor-ax    64
;  :datatype-constructor-ax 319
;  :datatype-occurs-check   195
;  :datatype-splits         156
;  :decisions               1468
;  :del-clause              17873
;  :final-checks            115
;  :interface-eqs           6
;  :max-generation          8
;  :max-memory              7.20
;  :memory                  7.17
;  :minimized-lits          61
;  :mk-bool-var             25432
;  :mk-clause               18011
;  :num-allocs              305735
;  :num-checks              194
;  :propagations            7994
;  :quant-instantiations    5969
;  :rlimit-count            746699)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@135@06))
    (as None<option<array>>  option<array>))))
(pop) ; 10
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@135@06))
    (as None<option<array>>  option<array>))))
(push) ; 10
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 11
(assert (not (<
  j1@136@06
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@135@06)))))))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               12743
;  :arith-add-rows          8910
;  :arith-assert-diseq      889
;  :arith-assert-lower      3766
;  :arith-assert-upper      2390
;  :arith-bound-prop        1213
;  :arith-conflicts         282
;  :arith-eq-adapter        2621
;  :arith-fixed-eqs         1225
;  :arith-offset-eqs        1305
;  :arith-pivots            2299
;  :conflicts               637
;  :datatype-accessor-ax    64
;  :datatype-constructor-ax 321
;  :datatype-occurs-check   195
;  :datatype-splits         156
;  :decisions               1475
;  :del-clause              17884
;  :final-checks            115
;  :interface-eqs           6
;  :max-generation          8
;  :max-memory              7.20
;  :memory                  7.17
;  :minimized-lits          61
;  :mk-bool-var             25472
;  :mk-clause               18022
;  :num-allocs              306040
;  :num-checks              195
;  :propagations            8036
;  :quant-instantiations    5988
;  :rlimit-count            747991)
(assert (<
  j1@136@06
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@135@06))))))
(pop) ; 10
; Joined path conditions
(assert (<
  j1@136@06
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@135@06))))))
(pop) ; 9
(declare-fun inv@137@06 ($Ref) Int)
(declare-fun inv@138@06 ($Ref) Int)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(assert (forall ((i1@135@06 Int) (j1@136@06 Int)) (!
  (and
    (< i1@135@06 (alen<Int> (opt_get1 $Snap.unit G@24@06)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@135@06)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@135@06))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@135@06))
        (as None<option<array>>  option<array>)))
    (<
      j1@136@06
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@135@06))))))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@135@06))) j1@136@06))
  :qid |int-aux|)))
; Check receiver injectivity
(push) ; 9
(assert (not (forall ((i11@135@06 Int) (j11@136@06 Int) (i12@135@06 Int) (j12@136@06 Int)) (!
  (implies
    (and
      (and
        (and
          (and (< j11@136@06 V@27@06) (<= 0 j11@136@06))
          (< i11@135@06 V@27@06))
        (<= 0 i11@135@06))
      (and
        (and
          (and (< j12@136@06 V@27@06) (<= 0 j12@136@06))
          (< i12@135@06 V@27@06))
        (<= 0 i12@135@06))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@24@06) i11@135@06))) j11@136@06)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@24@06) i12@135@06))) j12@136@06)))
    (and (= i11@135@06 i12@135@06) (= j11@136@06 j12@136@06)))
  
  :qid |int-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               12919
;  :arith-add-rows          9063
;  :arith-assert-diseq      891
;  :arith-assert-lower      3798
;  :arith-assert-upper      2411
;  :arith-bound-prop        1230
;  :arith-conflicts         284
;  :arith-eq-adapter        2640
;  :arith-fixed-eqs         1240
;  :arith-offset-eqs        1323
;  :arith-pivots            2356
;  :conflicts               648
;  :datatype-accessor-ax    64
;  :datatype-constructor-ax 323
;  :datatype-occurs-check   195
;  :datatype-splits         156
;  :decisions               1485
;  :del-clause              18323
;  :final-checks            115
;  :interface-eqs           6
;  :max-generation          8
;  :max-memory              7.21
;  :memory                  7.17
;  :minimized-lits          61
;  :mk-bool-var             26012
;  :mk-clause               18327
;  :num-allocs              308771
;  :num-checks              196
;  :propagations            8113
;  :quant-instantiations    6143
;  :rlimit-count            760056
;  :time                    0.00)
; Definitional axioms for inverse functions
(assert (forall ((i1@135@06 Int) (j1@136@06 Int)) (!
  (implies
    (and
      (and (and (< j1@136@06 V@27@06) (<= 0 j1@136@06)) (< i1@135@06 V@27@06))
      (<= 0 i1@135@06))
    (and
      (=
        (inv@137@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@135@06))) j1@136@06))
        i1@135@06)
      (=
        (inv@138@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@135@06))) j1@136@06))
        j1@136@06)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@135@06))) j1@136@06))
  )))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@138@06 r) V@27@06) (<= 0 (inv@138@06 r)))
        (< (inv@137@06 r) V@27@06))
      (<= 0 (inv@137@06 r)))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@24@06) (inv@137@06 r)))) (inv@138@06 r))
      r))
  :pattern ((inv@137@06 r))
  :pattern ((inv@138@06 r))
  :qid |int-fctOfInv|)))
; Permissions are non-negative
; Field permissions are at most one
; Permission implies non-null receiver
(assert (forall ((i1@135@06 Int) (j1@136@06 Int)) (!
  (implies
    (and
      (and (and (< j1@136@06 V@27@06) (<= 0 j1@136@06)) (< i1@135@06 V@27@06))
      (<= 0 i1@135@06))
    (not
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@135@06))) j1@136@06)
        $Ref.null)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@135@06))) j1@136@06))
  :qid |int-permImpliesNonNull|)))
(declare-const sm@139@06 $FVF<Int>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@138@06 r) V@27@06) (<= 0 (inv@138@06 r)))
        (< (inv@137@06 r) V@27@06))
      (<= 0 (inv@137@06 r)))
    (=
      ($FVF.lookup_int (as sm@139@06  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@118@06))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@139@06  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@118@06))))))))))))))) r))
  :qid |qp.fvfValDef36|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@118@06))))))))))))))) r) r)
  :pattern (($FVF.lookup_int (as sm@139@06  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef37|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@138@06 r) V@27@06) (<= 0 (inv@138@06 r)))
        (< (inv@137@06 r) V@27@06))
      (<= 0 (inv@137@06 r)))
    ($FVF.loc_int ($FVF.lookup_int (as sm@139@06  $FVF<Int>) r) r))
  :pattern ((inv@137@06 r) (inv@138@06 r))
  )))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@118@06))))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@118@06)))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@118@06))))))))))))))))))
; [eval] exc == null
(set-option :timeout 10)
(push) ; 9
(assert (not (not (= exc@116@06 $Ref.null))))
(check-sat)
; unknown
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               12967
;  :arith-add-rows          9063
;  :arith-assert-diseq      891
;  :arith-assert-lower      3798
;  :arith-assert-upper      2411
;  :arith-bound-prop        1230
;  :arith-conflicts         284
;  :arith-eq-adapter        2640
;  :arith-fixed-eqs         1240
;  :arith-offset-eqs        1323
;  :arith-pivots            2356
;  :conflicts               648
;  :datatype-accessor-ax    65
;  :datatype-constructor-ax 332
;  :datatype-occurs-check   201
;  :datatype-splits         163
;  :decisions               1494
;  :del-clause              18323
;  :final-checks            117
;  :interface-eqs           6
;  :max-generation          8
;  :max-memory              7.21
;  :memory                  7.17
;  :minimized-lits          61
;  :mk-bool-var             26026
;  :mk-clause               18327
;  :num-allocs              310380
;  :num-checks              197
;  :propagations            8113
;  :quant-instantiations    6143
;  :rlimit-count            763675)
; [then-branch: 133 | exc@116@06 == Null | live]
; [else-branch: 133 | exc@116@06 != Null | dead]
(push) ; 9
; [then-branch: 133 | exc@116@06 == Null]
(declare-const i1@140@06 Int)
(declare-const j1@141@06 Int)
(push) ; 10
; [eval] 0 <= i1 && i1 < V && (0 <= j1 && j1 < V)
; [eval] 0 <= i1
(push) ; 11
; [then-branch: 134 | 0 <= i1@140@06 | live]
; [else-branch: 134 | !(0 <= i1@140@06) | live]
(push) ; 12
; [then-branch: 134 | 0 <= i1@140@06]
(assert (<= 0 i1@140@06))
; [eval] i1 < V
(push) ; 13
; [then-branch: 135 | i1@140@06 < V@27@06 | live]
; [else-branch: 135 | !(i1@140@06 < V@27@06) | live]
(push) ; 14
; [then-branch: 135 | i1@140@06 < V@27@06]
(assert (< i1@140@06 V@27@06))
; [eval] 0 <= j1
(push) ; 15
; [then-branch: 136 | 0 <= j1@141@06 | live]
; [else-branch: 136 | !(0 <= j1@141@06) | live]
(push) ; 16
; [then-branch: 136 | 0 <= j1@141@06]
(assert (<= 0 j1@141@06))
; [eval] j1 < V
(pop) ; 16
(push) ; 16
; [else-branch: 136 | !(0 <= j1@141@06)]
(assert (not (<= 0 j1@141@06)))
(pop) ; 16
(pop) ; 15
; Joined path conditions
; Joined path conditions
(pop) ; 14
(push) ; 14
; [else-branch: 135 | !(i1@140@06 < V@27@06)]
(assert (not (< i1@140@06 V@27@06)))
(pop) ; 14
(pop) ; 13
; Joined path conditions
; Joined path conditions
(pop) ; 12
(push) ; 12
; [else-branch: 134 | !(0 <= i1@140@06)]
(assert (not (<= 0 i1@140@06)))
(pop) ; 12
(pop) ; 11
; Joined path conditions
; Joined path conditions
(assert (and
  (and (and (< j1@141@06 V@27@06) (<= 0 j1@141@06)) (< i1@140@06 V@27@06))
  (<= 0 i1@140@06)))
; [eval] aloc(opt_get1(aloc(opt_get1(target), i1).option$array$), j1)
; [eval] opt_get1(aloc(opt_get1(target), i1).option$array$)
; [eval] aloc(opt_get1(target), i1)
; [eval] opt_get1(target)
(push) ; 11
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 11
; Joined path conditions
(push) ; 11
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 12
(assert (not (< i1@140@06 (alen<Int> (opt_get1 $Snap.unit res@68@06)))))
(check-sat)
; unsat
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               12967
;  :arith-add-rows          9066
;  :arith-assert-diseq      891
;  :arith-assert-lower      3804
;  :arith-assert-upper      2411
;  :arith-bound-prop        1230
;  :arith-conflicts         284
;  :arith-eq-adapter        2640
;  :arith-fixed-eqs         1240
;  :arith-offset-eqs        1323
;  :arith-pivots            2356
;  :conflicts               648
;  :datatype-accessor-ax    65
;  :datatype-constructor-ax 332
;  :datatype-occurs-check   201
;  :datatype-splits         163
;  :decisions               1494
;  :del-clause              18323
;  :final-checks            117
;  :interface-eqs           6
;  :max-generation          8
;  :max-memory              7.21
;  :memory                  7.17
;  :minimized-lits          61
;  :mk-bool-var             26032
;  :mk-clause               18327
;  :num-allocs              310653
;  :num-checks              198
;  :propagations            8113
;  :quant-instantiations    6143
;  :rlimit-count            764150)
(assert (< i1@140@06 (alen<Int> (opt_get1 $Snap.unit res@68@06))))
(pop) ; 11
; Joined path conditions
(assert (< i1@140@06 (alen<Int> (opt_get1 $Snap.unit res@68@06))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@140@06)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@140@06)))
(push) ; 11
(assert (not (<
  $Perm.No
  (+
    (+
      (+
        (ite
          (and
            (<
              (inv@129@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@140@06))
              V@27@06)
            (<=
              0
              (inv@129@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@140@06))))
          $k@128@06
          $Perm.No)
        (ite
          (and
            (<
              (inv@121@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@140@06))
              V@27@06)
            (<=
              0
              (inv@121@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@140@06))))
          $k@120@06
          $Perm.No))
      (-
        (-
          (ite
            (and
              (<
                (inv@71@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@140@06))
                V@27@06)
              (<=
                0
                (inv@71@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@140@06))))
            $Perm.Write
            $Perm.No)
          (pTaken@87@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@140@06)))
        (pTaken@98@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@140@06))))
    (-
      (-
        (ite
          (and
            (<
              (inv@33@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@140@06))
              V@27@06)
            (<=
              0
              (inv@33@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@140@06))))
          $k@32@06
          $Perm.No)
        (pTaken@88@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@140@06)))
      (pTaken@97@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@140@06)))))))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               13170
;  :arith-add-rows          9271
;  :arith-assert-diseq      911
;  :arith-assert-lower      3869
;  :arith-assert-upper      2448
;  :arith-bound-prop        1270
;  :arith-conflicts         291
;  :arith-eq-adapter        2679
;  :arith-fixed-eqs         1266
;  :arith-offset-eqs        1366
;  :arith-pivots            2394
;  :conflicts               661
;  :datatype-accessor-ax    65
;  :datatype-constructor-ax 334
;  :datatype-occurs-check   201
;  :datatype-splits         163
;  :decisions               1506
;  :del-clause              18456
;  :final-checks            117
;  :interface-eqs           6
;  :max-generation          8
;  :max-memory              7.43
;  :memory                  7.34
;  :minimized-lits          61
;  :mk-bool-var             26413
;  :mk-clause               18591
;  :num-allocs              312612
;  :num-checks              199
;  :propagations            8214
;  :quant-instantiations    6214
;  :rlimit-count            774308
;  :time                    0.00)
(push) ; 11
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 12
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@140@06))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               13170
;  :arith-add-rows          9271
;  :arith-assert-diseq      911
;  :arith-assert-lower      3869
;  :arith-assert-upper      2448
;  :arith-bound-prop        1270
;  :arith-conflicts         291
;  :arith-eq-adapter        2679
;  :arith-fixed-eqs         1266
;  :arith-offset-eqs        1366
;  :arith-pivots            2394
;  :conflicts               662
;  :datatype-accessor-ax    65
;  :datatype-constructor-ax 334
;  :datatype-occurs-check   201
;  :datatype-splits         163
;  :decisions               1506
;  :del-clause              18456
;  :final-checks            117
;  :interface-eqs           6
;  :max-generation          8
;  :max-memory              7.43
;  :memory                  7.34
;  :minimized-lits          61
;  :mk-bool-var             26413
;  :mk-clause               18591
;  :num-allocs              312701
;  :num-checks              200
;  :propagations            8214
;  :quant-instantiations    6214
;  :rlimit-count            774403)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@140@06))
    (as None<option<array>>  option<array>))))
(pop) ; 11
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@140@06))
    (as None<option<array>>  option<array>))))
(push) ; 11
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 12
(assert (not (<
  j1@141@06
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@140@06)))))))
(check-sat)
; unsat
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               13176
;  :arith-add-rows          9277
;  :arith-assert-diseq      911
;  :arith-assert-lower      3871
;  :arith-assert-upper      2450
;  :arith-bound-prop        1270
;  :arith-conflicts         292
;  :arith-eq-adapter        2680
;  :arith-fixed-eqs         1267
;  :arith-offset-eqs        1366
;  :arith-pivots            2398
;  :conflicts               663
;  :datatype-accessor-ax    65
;  :datatype-constructor-ax 334
;  :datatype-occurs-check   201
;  :datatype-splits         163
;  :decisions               1506
;  :del-clause              18460
;  :final-checks            117
;  :interface-eqs           6
;  :max-generation          8
;  :max-memory              7.43
;  :memory                  7.34
;  :minimized-lits          61
;  :mk-bool-var             26424
;  :mk-clause               18595
;  :num-allocs              312891
;  :num-checks              201
;  :propagations            8216
;  :quant-instantiations    6221
;  :rlimit-count            774921)
(assert (<
  j1@141@06
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@140@06))))))
(pop) ; 11
; Joined path conditions
(assert (<
  j1@141@06
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@140@06))))))
(pop) ; 10
(declare-fun inv@142@06 ($Ref) Int)
(declare-fun inv@143@06 ($Ref) Int)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(assert (forall ((i1@140@06 Int) (j1@141@06 Int)) (!
  (and
    (< i1@140@06 (alen<Int> (opt_get1 $Snap.unit res@68@06)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@140@06)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@140@06))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@140@06))
        (as None<option<array>>  option<array>)))
    (<
      j1@141@06
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@140@06))))))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@140@06))) j1@141@06))
  :qid |int-aux|)))
; Check receiver injectivity
(push) ; 10
(assert (not (forall ((i11@140@06 Int) (j11@141@06 Int) (i12@140@06 Int) (j12@141@06 Int)) (!
  (implies
    (and
      (and
        (and
          (and (< j11@141@06 V@27@06) (<= 0 j11@141@06))
          (< i11@140@06 V@27@06))
        (<= 0 i11@140@06))
      (and
        (and
          (and (< j12@141@06 V@27@06) (<= 0 j12@141@06))
          (< i12@140@06 V@27@06))
        (<= 0 i12@140@06))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@68@06) i11@140@06))) j11@141@06)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@68@06) i12@140@06))) j12@141@06)))
    (and (= i11@140@06 i12@140@06) (= j11@141@06 j12@141@06)))
  
  :qid |int-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               13226
;  :arith-add-rows          9324
;  :arith-assert-diseq      911
;  :arith-assert-lower      3885
;  :arith-assert-upper      2456
;  :arith-bound-prop        1274
;  :arith-conflicts         292
;  :arith-eq-adapter        2694
;  :arith-fixed-eqs         1271
;  :arith-offset-eqs        1366
;  :arith-pivots            2420
;  :conflicts               664
;  :datatype-accessor-ax    65
;  :datatype-constructor-ax 334
;  :datatype-occurs-check   201
;  :datatype-splits         163
;  :decisions               1506
;  :del-clause              18856
;  :final-checks            117
;  :interface-eqs           6
;  :max-generation          8
;  :max-memory              7.43
;  :memory                  7.35
;  :minimized-lits          61
;  :mk-bool-var             26822
;  :mk-clause               18860
;  :num-allocs              314993
;  :num-checks              202
;  :propagations            8254
;  :quant-instantiations    6358
;  :rlimit-count            783808
;  :time                    0.00)
; Definitional axioms for inverse functions
(assert (forall ((i1@140@06 Int) (j1@141@06 Int)) (!
  (implies
    (and
      (and (and (< j1@141@06 V@27@06) (<= 0 j1@141@06)) (< i1@140@06 V@27@06))
      (<= 0 i1@140@06))
    (and
      (=
        (inv@142@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@140@06))) j1@141@06))
        i1@140@06)
      (=
        (inv@143@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@140@06))) j1@141@06))
        j1@141@06)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@140@06))) j1@141@06))
  )))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@143@06 r) V@27@06) (<= 0 (inv@143@06 r)))
        (< (inv@142@06 r) V@27@06))
      (<= 0 (inv@142@06 r)))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit res@68@06) (inv@142@06 r)))) (inv@143@06 r))
      r))
  :pattern ((inv@142@06 r))
  :pattern ((inv@143@06 r))
  :qid |int-fctOfInv|)))
; Permissions are non-negative
; Field permissions are at most one
; Permission implies non-null receiver
(assert (forall ((i1@140@06 Int) (j1@141@06 Int)) (!
  (implies
    (and
      (and (and (< j1@141@06 V@27@06) (<= 0 j1@141@06)) (< i1@140@06 V@27@06))
      (<= 0 i1@140@06))
    (not
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@140@06))) j1@141@06)
        $Ref.null)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit res@68@06) i1@140@06))) j1@141@06))
  :qid |int-permImpliesNonNull|)))
(declare-const sm@144@06 $FVF<Int>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@143@06 r) V@27@06) (<= 0 (inv@143@06 r)))
        (< (inv@142@06 r) V@27@06))
      (<= 0 (inv@142@06 r)))
    (=
      ($FVF.lookup_int (as sm@144@06  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@118@06)))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@144@06  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@118@06)))))))))))))))) r))
  :qid |qp.fvfValDef38|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@138@06 r) V@27@06) (<= 0 (inv@138@06 r)))
        (< (inv@137@06 r) V@27@06))
      (<= 0 (inv@137@06 r)))
    (=
      ($FVF.lookup_int (as sm@144@06  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@118@06))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@144@06  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@118@06))))))))))))))) r))
  :qid |qp.fvfValDef39|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@118@06)))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@118@06))))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@144@06  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef40|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@143@06 r) V@27@06) (<= 0 (inv@143@06 r)))
        (< (inv@142@06 r) V@27@06))
      (<= 0 (inv@142@06 r)))
    ($FVF.loc_int ($FVF.lookup_int (as sm@144@06  $FVF<Int>) r) r))
  :pattern ((inv@142@06 r) (inv@143@06 r))
  )))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@118@06)))))))))))))))
  $Snap.unit))
; [eval] exc == null ==> (forall unknown: Int :: { opt_get1(aloc(opt_get1(target), unknown).option$array$) } { opt_get1(aloc(opt_get1(source), unknown).option$array$) } 0 <= unknown && unknown < V ==> (forall unknown1: Int :: { aloc(opt_get1(aloc(opt_get1(target), unknown).option$array$), unknown1) } { aloc(opt_get1(aloc(opt_get1(source), unknown).option$array$), unknown1) } 0 <= unknown1 && unknown1 < V ==> aloc(opt_get1(aloc(opt_get1(target), unknown).option$array$), unknown1).int == aloc(opt_get1(aloc(opt_get1(source), unknown).option$array$), unknown1).int))
; [eval] exc == null
(push) ; 10
(set-option :timeout 10)
(push) ; 11
(assert (not (not (= exc@116@06 $Ref.null))))
(check-sat)
; unknown
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               13269
;  :arith-add-rows          9324
;  :arith-assert-diseq      911
;  :arith-assert-lower      3885
;  :arith-assert-upper      2456
;  :arith-bound-prop        1274
;  :arith-conflicts         292
;  :arith-eq-adapter        2694
;  :arith-fixed-eqs         1271
;  :arith-offset-eqs        1366
;  :arith-pivots            2420
;  :conflicts               664
;  :datatype-accessor-ax    65
;  :datatype-constructor-ax 342
;  :datatype-occurs-check   207
;  :datatype-splits         169
;  :decisions               1514
;  :del-clause              18856
;  :final-checks            119
;  :interface-eqs           6
;  :max-generation          8
;  :max-memory              7.43
;  :memory                  7.36
;  :minimized-lits          61
;  :mk-bool-var             26836
;  :mk-clause               18860
;  :num-allocs              316758
;  :num-checks              203
;  :propagations            8254
;  :quant-instantiations    6358
;  :rlimit-count            788183)
; [then-branch: 137 | exc@116@06 == Null | live]
; [else-branch: 137 | exc@116@06 != Null | dead]
(push) ; 11
; [then-branch: 137 | exc@116@06 == Null]
; [eval] (forall unknown: Int :: { opt_get1(aloc(opt_get1(target), unknown).option$array$) } { opt_get1(aloc(opt_get1(source), unknown).option$array$) } 0 <= unknown && unknown < V ==> (forall unknown1: Int :: { aloc(opt_get1(aloc(opt_get1(target), unknown).option$array$), unknown1) } { aloc(opt_get1(aloc(opt_get1(source), unknown).option$array$), unknown1) } 0 <= unknown1 && unknown1 < V ==> aloc(opt_get1(aloc(opt_get1(target), unknown).option$array$), unknown1).int == aloc(opt_get1(aloc(opt_get1(source), unknown).option$array$), unknown1).int))
(declare-const unknown@145@06 Int)
(push) ; 12
; [eval] 0 <= unknown && unknown < V ==> (forall unknown1: Int :: { aloc(opt_get1(aloc(opt_get1(target), unknown).option$array$), unknown1) } { aloc(opt_get1(aloc(opt_get1(source), unknown).option$array$), unknown1) } 0 <= unknown1 && unknown1 < V ==> aloc(opt_get1(aloc(opt_get1(target), unknown).option$array$), unknown1).int == aloc(opt_get1(aloc(opt_get1(source), unknown).option$array$), unknown1).int)
; [eval] 0 <= unknown && unknown < V
; [eval] 0 <= unknown
(push) ; 13
; [then-branch: 138 | 0 <= unknown@145@06 | live]
; [else-branch: 138 | !(0 <= unknown@145@06) | live]
(push) ; 14
; [then-branch: 138 | 0 <= unknown@145@06]
(assert (<= 0 unknown@145@06))
; [eval] unknown < V
(pop) ; 14
(push) ; 14
; [else-branch: 138 | !(0 <= unknown@145@06)]
(assert (not (<= 0 unknown@145@06)))
(pop) ; 14
(pop) ; 13
; Joined path conditions
; Joined path conditions
(push) ; 13
; [then-branch: 139 | unknown@145@06 < V@27@06 && 0 <= unknown@145@06 | live]
; [else-branch: 139 | !(unknown@145@06 < V@27@06 && 0 <= unknown@145@06) | live]
(push) ; 14
; [then-branch: 139 | unknown@145@06 < V@27@06 && 0 <= unknown@145@06]
(assert (and (< unknown@145@06 V@27@06) (<= 0 unknown@145@06)))
; [eval] (forall unknown1: Int :: { aloc(opt_get1(aloc(opt_get1(target), unknown).option$array$), unknown1) } { aloc(opt_get1(aloc(opt_get1(source), unknown).option$array$), unknown1) } 0 <= unknown1 && unknown1 < V ==> aloc(opt_get1(aloc(opt_get1(target), unknown).option$array$), unknown1).int == aloc(opt_get1(aloc(opt_get1(source), unknown).option$array$), unknown1).int)
(declare-const unknown1@146@06 Int)
(push) ; 15
; [eval] 0 <= unknown1 && unknown1 < V ==> aloc(opt_get1(aloc(opt_get1(target), unknown).option$array$), unknown1).int == aloc(opt_get1(aloc(opt_get1(source), unknown).option$array$), unknown1).int
; [eval] 0 <= unknown1 && unknown1 < V
; [eval] 0 <= unknown1
(push) ; 16
; [then-branch: 140 | 0 <= unknown1@146@06 | live]
; [else-branch: 140 | !(0 <= unknown1@146@06) | live]
(push) ; 17
; [then-branch: 140 | 0 <= unknown1@146@06]
(assert (<= 0 unknown1@146@06))
; [eval] unknown1 < V
(pop) ; 17
(push) ; 17
; [else-branch: 140 | !(0 <= unknown1@146@06)]
(assert (not (<= 0 unknown1@146@06)))
(pop) ; 17
(pop) ; 16
; Joined path conditions
; Joined path conditions
(push) ; 16
; [then-branch: 141 | unknown1@146@06 < V@27@06 && 0 <= unknown1@146@06 | live]
; [else-branch: 141 | !(unknown1@146@06 < V@27@06 && 0 <= unknown1@146@06) | live]
(push) ; 17
; [then-branch: 141 | unknown1@146@06 < V@27@06 && 0 <= unknown1@146@06]
(assert (and (< unknown1@146@06 V@27@06) (<= 0 unknown1@146@06)))
; [eval] aloc(opt_get1(aloc(opt_get1(target), unknown).option$array$), unknown1).int == aloc(opt_get1(aloc(opt_get1(source), unknown).option$array$), unknown1).int
; [eval] aloc(opt_get1(aloc(opt_get1(target), unknown).option$array$), unknown1)
; [eval] opt_get1(aloc(opt_get1(target), unknown).option$array$)
; [eval] aloc(opt_get1(target), unknown)
; [eval] opt_get1(target)
(push) ; 18
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 18
; Joined path conditions
(push) ; 18
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 19
(assert (not (< unknown@145@06 (alen<Int> (opt_get1 $Snap.unit res@68@06)))))
(check-sat)
; unsat
(pop) ; 19
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               13269
;  :arith-add-rows          9326
;  :arith-assert-diseq      911
;  :arith-assert-lower      3889
;  :arith-assert-upper      2456
;  :arith-bound-prop        1274
;  :arith-conflicts         292
;  :arith-eq-adapter        2694
;  :arith-fixed-eqs         1271
;  :arith-offset-eqs        1366
;  :arith-pivots            2420
;  :conflicts               664
;  :datatype-accessor-ax    65
;  :datatype-constructor-ax 342
;  :datatype-occurs-check   207
;  :datatype-splits         169
;  :decisions               1514
;  :del-clause              18856
;  :final-checks            119
;  :interface-eqs           6
;  :max-generation          8
;  :max-memory              7.43
;  :memory                  7.36
;  :minimized-lits          61
;  :mk-bool-var             26840
;  :mk-clause               18860
;  :num-allocs              316942
;  :num-checks              204
;  :propagations            8254
;  :quant-instantiations    6358
;  :rlimit-count            788540)
(assert (< unknown@145@06 (alen<Int> (opt_get1 $Snap.unit res@68@06))))
(pop) ; 18
; Joined path conditions
(assert (< unknown@145@06 (alen<Int> (opt_get1 $Snap.unit res@68@06))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit res@68@06) unknown@145@06)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit res@68@06) unknown@145@06)))
(push) ; 18
(assert (not (<
  $Perm.No
  (+
    (+
      (+
        (ite
          (and
            (<
              (inv@129@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@68@06) unknown@145@06))
              V@27@06)
            (<=
              0
              (inv@129@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@68@06) unknown@145@06))))
          $k@128@06
          $Perm.No)
        (ite
          (and
            (<
              (inv@121@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@68@06) unknown@145@06))
              V@27@06)
            (<=
              0
              (inv@121@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@68@06) unknown@145@06))))
          $k@120@06
          $Perm.No))
      (-
        (-
          (ite
            (and
              (<
                (inv@71@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@68@06) unknown@145@06))
                V@27@06)
              (<=
                0
                (inv@71@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@68@06) unknown@145@06))))
            $Perm.Write
            $Perm.No)
          (pTaken@87@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@68@06) unknown@145@06)))
        (pTaken@98@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@68@06) unknown@145@06))))
    (-
      (-
        (ite
          (and
            (<
              (inv@33@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@68@06) unknown@145@06))
              V@27@06)
            (<=
              0
              (inv@33@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@68@06) unknown@145@06))))
          $k@32@06
          $Perm.No)
        (pTaken@88@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@68@06) unknown@145@06)))
      (pTaken@97@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@68@06) unknown@145@06)))))))
(check-sat)
; unsat
(pop) ; 18
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               13505
;  :arith-add-rows          9542
;  :arith-assert-diseq      934
;  :arith-assert-lower      3982
;  :arith-assert-upper      2508
;  :arith-bound-prop        1315
;  :arith-conflicts         297
;  :arith-eq-adapter        2746
;  :arith-fixed-eqs         1296
;  :arith-offset-eqs        1420
;  :arith-pivots            2458
;  :conflicts               680
;  :datatype-accessor-ax    65
;  :datatype-constructor-ax 344
;  :datatype-occurs-check   207
;  :datatype-splits         169
;  :decisions               1548
;  :del-clause              19145
;  :final-checks            119
;  :interface-eqs           6
;  :max-generation          8
;  :max-memory              7.43
;  :memory                  7.38
;  :minimized-lits          62
;  :mk-bool-var             27395
;  :mk-clause               19280
;  :num-allocs              319212
;  :num-checks              205
;  :propagations            8435
;  :quant-instantiations    6443
;  :rlimit-count            799864
;  :time                    0.00)
(push) ; 18
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 19
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@68@06) unknown@145@06))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 19
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               13505
;  :arith-add-rows          9542
;  :arith-assert-diseq      934
;  :arith-assert-lower      3982
;  :arith-assert-upper      2508
;  :arith-bound-prop        1315
;  :arith-conflicts         297
;  :arith-eq-adapter        2746
;  :arith-fixed-eqs         1296
;  :arith-offset-eqs        1420
;  :arith-pivots            2458
;  :conflicts               681
;  :datatype-accessor-ax    65
;  :datatype-constructor-ax 344
;  :datatype-occurs-check   207
;  :datatype-splits         169
;  :decisions               1548
;  :del-clause              19145
;  :final-checks            119
;  :interface-eqs           6
;  :max-generation          8
;  :max-memory              7.43
;  :memory                  7.38
;  :minimized-lits          62
;  :mk-bool-var             27395
;  :mk-clause               19280
;  :num-allocs              319301
;  :num-checks              206
;  :propagations            8435
;  :quant-instantiations    6443
;  :rlimit-count            799959)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@68@06) unknown@145@06))
    (as None<option<array>>  option<array>))))
(pop) ; 18
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@68@06) unknown@145@06))
    (as None<option<array>>  option<array>))))
(push) ; 18
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 19
(assert (not (<
  unknown1@146@06
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit res@68@06) unknown@145@06)))))))
(check-sat)
; unsat
(pop) ; 19
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               13511
;  :arith-add-rows          9548
;  :arith-assert-diseq      934
;  :arith-assert-lower      3984
;  :arith-assert-upper      2510
;  :arith-bound-prop        1315
;  :arith-conflicts         298
;  :arith-eq-adapter        2747
;  :arith-fixed-eqs         1297
;  :arith-offset-eqs        1420
;  :arith-pivots            2462
;  :conflicts               682
;  :datatype-accessor-ax    65
;  :datatype-constructor-ax 344
;  :datatype-occurs-check   207
;  :datatype-splits         169
;  :decisions               1548
;  :del-clause              19149
;  :final-checks            119
;  :interface-eqs           6
;  :max-generation          8
;  :max-memory              7.43
;  :memory                  7.38
;  :minimized-lits          62
;  :mk-bool-var             27406
;  :mk-clause               19284
;  :num-allocs              319491
;  :num-checks              207
;  :propagations            8437
;  :quant-instantiations    6450
;  :rlimit-count            800477)
(assert (<
  unknown1@146@06
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit res@68@06) unknown@145@06))))))
(pop) ; 18
; Joined path conditions
(assert (<
  unknown1@146@06
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit res@68@06) unknown@145@06))))))
(assert ($FVF.loc_int ($FVF.lookup_int (as sm@144@06  $FVF<Int>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit res@68@06) unknown@145@06))) unknown1@146@06)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit res@68@06) unknown@145@06))) unknown1@146@06)))
(push) ; 18
(assert (not (<
  $Perm.No
  (+
    (ite
      (and
        (and
          (and
            (<
              (inv@143@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit res@68@06) unknown@145@06))) unknown1@146@06))
              V@27@06)
            (<=
              0
              (inv@143@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit res@68@06) unknown@145@06))) unknown1@146@06))))
          (<
            (inv@142@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit res@68@06) unknown@145@06))) unknown1@146@06))
            V@27@06))
        (<=
          0
          (inv@142@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit res@68@06) unknown@145@06))) unknown1@146@06))))
      $Perm.Write
      $Perm.No)
    (ite
      (and
        (and
          (and
            (<
              (inv@138@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit res@68@06) unknown@145@06))) unknown1@146@06))
              V@27@06)
            (<=
              0
              (inv@138@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit res@68@06) unknown@145@06))) unknown1@146@06))))
          (<
            (inv@137@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit res@68@06) unknown@145@06))) unknown1@146@06))
            V@27@06))
        (<=
          0
          (inv@137@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit res@68@06) unknown@145@06))) unknown1@146@06))))
      $Perm.Write
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 18
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               13799
;  :arith-add-rows          9747
;  :arith-assert-diseq      947
;  :arith-assert-lower      4059
;  :arith-assert-upper      2572
;  :arith-bound-prop        1343
;  :arith-conflicts         305
;  :arith-eq-adapter        2803
;  :arith-fixed-eqs         1322
;  :arith-offset-eqs        1466
;  :arith-pivots            2500
;  :conflicts               705
;  :datatype-accessor-ax    65
;  :datatype-constructor-ax 346
;  :datatype-occurs-check   207
;  :datatype-splits         169
;  :decisions               1592
;  :del-clause              19596
;  :final-checks            119
;  :interface-eqs           6
;  :max-generation          8
;  :max-memory              7.43
;  :memory                  7.41
;  :minimized-lits          62
;  :mk-bool-var             28158
;  :mk-clause               19759
;  :num-allocs              322365
;  :num-checks              208
;  :propagations            8625
;  :quant-instantiations    6582
;  :rlimit-count            812241
;  :time                    0.01)
; [eval] aloc(opt_get1(aloc(opt_get1(source), unknown).option$array$), unknown1)
; [eval] opt_get1(aloc(opt_get1(source), unknown).option$array$)
; [eval] aloc(opt_get1(source), unknown)
; [eval] opt_get1(source)
(push) ; 18
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 18
; Joined path conditions
(push) ; 18
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 19
(assert (not (< unknown@145@06 (alen<Int> (opt_get1 $Snap.unit G@24@06)))))
(check-sat)
; unsat
(pop) ; 19
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               13799
;  :arith-add-rows          9747
;  :arith-assert-diseq      947
;  :arith-assert-lower      4059
;  :arith-assert-upper      2572
;  :arith-bound-prop        1343
;  :arith-conflicts         305
;  :arith-eq-adapter        2803
;  :arith-fixed-eqs         1322
;  :arith-offset-eqs        1466
;  :arith-pivots            2500
;  :conflicts               705
;  :datatype-accessor-ax    65
;  :datatype-constructor-ax 346
;  :datatype-occurs-check   207
;  :datatype-splits         169
;  :decisions               1592
;  :del-clause              19596
;  :final-checks            119
;  :interface-eqs           6
;  :max-generation          8
;  :max-memory              7.43
;  :memory                  7.41
;  :minimized-lits          62
;  :mk-bool-var             28158
;  :mk-clause               19759
;  :num-allocs              322391
;  :num-checks              209
;  :propagations            8625
;  :quant-instantiations    6582
;  :rlimit-count            812271)
(assert (< unknown@145@06 (alen<Int> (opt_get1 $Snap.unit G@24@06))))
(pop) ; 18
; Joined path conditions
(assert (< unknown@145@06 (alen<Int> (opt_get1 $Snap.unit G@24@06))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@24@06) unknown@145@06)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@24@06) unknown@145@06)))
(push) ; 18
(assert (not (<
  $Perm.No
  (+
    (+
      (+
        (ite
          (and
            (<
              (inv@129@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) unknown@145@06))
              V@27@06)
            (<=
              0
              (inv@129@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) unknown@145@06))))
          $k@128@06
          $Perm.No)
        (ite
          (and
            (<
              (inv@121@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) unknown@145@06))
              V@27@06)
            (<=
              0
              (inv@121@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) unknown@145@06))))
          $k@120@06
          $Perm.No))
      (-
        (-
          (ite
            (and
              (<
                (inv@71@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) unknown@145@06))
                V@27@06)
              (<=
                0
                (inv@71@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) unknown@145@06))))
            $Perm.Write
            $Perm.No)
          (pTaken@87@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) unknown@145@06)))
        (pTaken@98@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) unknown@145@06))))
    (-
      (-
        (ite
          (and
            (<
              (inv@33@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) unknown@145@06))
              V@27@06)
            (<=
              0
              (inv@33@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) unknown@145@06))))
          $k@32@06
          $Perm.No)
        (pTaken@88@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) unknown@145@06)))
      (pTaken@97@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) unknown@145@06)))))))
(check-sat)
; unsat
(pop) ; 18
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               14562
;  :arith-add-rows          10448
;  :arith-assert-diseq      1003
;  :arith-assert-lower      4270
;  :arith-assert-upper      2715
;  :arith-bound-prop        1439
;  :arith-conflicts         317
;  :arith-eq-adapter        2978
;  :arith-fixed-eqs         1391
;  :arith-offset-eqs        1575
;  :arith-pivots            2594
;  :conflicts               736
;  :datatype-accessor-ax    65
;  :datatype-constructor-ax 348
;  :datatype-occurs-check   207
;  :datatype-splits         169
;  :decisions               1688
;  :del-clause              20982
;  :final-checks            119
;  :interface-eqs           6
;  :max-generation          8
;  :max-memory              7.64
;  :memory                  7.62
;  :minimized-lits          63
;  :mk-bool-var             29957
;  :mk-clause               21228
;  :num-allocs              328587
;  :num-checks              210
;  :propagations            9255
;  :quant-instantiations    6923
;  :rlimit-count            846864
;  :time                    0.01)
(push) ; 18
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 19
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@24@06) unknown@145@06))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 19
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               14806
;  :arith-add-rows          10578
;  :arith-assert-diseq      1012
;  :arith-assert-lower      4328
;  :arith-assert-upper      2764
;  :arith-bound-prop        1468
;  :arith-conflicts         322
;  :arith-eq-adapter        3019
;  :arith-fixed-eqs         1410
;  :arith-offset-eqs        1612
;  :arith-pivots            2612
;  :conflicts               754
;  :datatype-accessor-ax    65
;  :datatype-constructor-ax 350
;  :datatype-occurs-check   207
;  :datatype-splits         169
;  :decisions               1727
;  :del-clause              21374
;  :final-checks            119
;  :interface-eqs           6
;  :max-generation          8
;  :max-memory              7.64
;  :memory                  7.62
;  :minimized-lits          63
;  :mk-bool-var             30425
;  :mk-clause               21620
;  :num-allocs              330131
;  :num-checks              211
;  :propagations            9456
;  :quant-instantiations    7021
;  :rlimit-count            855618
;  :time                    0.00)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@24@06) unknown@145@06))
    (as None<option<array>>  option<array>))))
(pop) ; 18
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@24@06) unknown@145@06))
    (as None<option<array>>  option<array>))))
(push) ; 18
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 19
(assert (not (<
  unknown1@146@06
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@24@06) unknown@145@06)))))))
(check-sat)
; unsat
(pop) ; 19
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               15092
;  :arith-add-rows          10757
;  :arith-assert-diseq      1022
;  :arith-assert-lower      4390
;  :arith-assert-upper      2816
;  :arith-bound-prop        1498
;  :arith-conflicts         328
;  :arith-eq-adapter        3063
;  :arith-fixed-eqs         1430
;  :arith-offset-eqs        1649
;  :arith-pivots            2639
;  :conflicts               773
;  :datatype-accessor-ax    65
;  :datatype-constructor-ax 352
;  :datatype-occurs-check   207
;  :datatype-splits         169
;  :decisions               1770
;  :del-clause              21770
;  :final-checks            119
;  :interface-eqs           6
;  :max-generation          8
;  :max-memory              7.64
;  :memory                  7.62
;  :minimized-lits          63
;  :mk-bool-var             30931
;  :mk-clause               22016
;  :num-allocs              331882
;  :num-checks              212
;  :propagations            9663
;  :quant-instantiations    7136
;  :rlimit-count            865484
;  :time                    0.00)
(assert (<
  unknown1@146@06
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@24@06) unknown@145@06))))))
(pop) ; 18
; Joined path conditions
(assert (<
  unknown1@146@06
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@24@06) unknown@145@06))))))
(assert ($FVF.loc_int ($FVF.lookup_int (as sm@144@06  $FVF<Int>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@24@06) unknown@145@06))) unknown1@146@06)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@24@06) unknown@145@06))) unknown1@146@06)))
(push) ; 18
(assert (not (<
  $Perm.No
  (+
    (ite
      (and
        (and
          (and
            (<
              (inv@143@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit G@24@06) unknown@145@06))) unknown1@146@06))
              V@27@06)
            (<=
              0
              (inv@143@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit G@24@06) unknown@145@06))) unknown1@146@06))))
          (<
            (inv@142@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@24@06) unknown@145@06))) unknown1@146@06))
            V@27@06))
        (<=
          0
          (inv@142@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@24@06) unknown@145@06))) unknown1@146@06))))
      $Perm.Write
      $Perm.No)
    (ite
      (and
        (and
          (and
            (<
              (inv@138@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit G@24@06) unknown@145@06))) unknown1@146@06))
              V@27@06)
            (<=
              0
              (inv@138@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit G@24@06) unknown@145@06))) unknown1@146@06))))
          (<
            (inv@137@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@24@06) unknown@145@06))) unknown1@146@06))
            V@27@06))
        (<=
          0
          (inv@137@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@24@06) unknown@145@06))) unknown1@146@06))))
      $Perm.Write
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 18
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               15653
;  :arith-add-rows          11246
;  :arith-assert-diseq      1049
;  :arith-assert-lower      4527
;  :arith-assert-upper      2924
;  :arith-bound-prop        1559
;  :arith-conflicts         337
;  :arith-eq-adapter        3168
;  :arith-fixed-eqs         1479
;  :arith-offset-eqs        1725
;  :arith-pivots            2711
;  :conflicts               801
;  :datatype-accessor-ax    65
;  :datatype-constructor-ax 354
;  :datatype-occurs-check   207
;  :datatype-splits         169
;  :decisions               1832
;  :del-clause              22444
;  :final-checks            119
;  :interface-eqs           6
;  :max-generation          8
;  :max-memory              7.70
;  :memory                  7.68
;  :minimized-lits          63
;  :mk-bool-var             32077
;  :mk-clause               22706
;  :num-allocs              336024
;  :num-checks              213
;  :propagations            10002
;  :quant-instantiations    7317
;  :rlimit-count            882685
;  :time                    0.01)
(pop) ; 17
(push) ; 17
; [else-branch: 141 | !(unknown1@146@06 < V@27@06 && 0 <= unknown1@146@06)]
(assert (not (and (< unknown1@146@06 V@27@06) (<= 0 unknown1@146@06))))
(pop) ; 17
(pop) ; 16
; Joined path conditions
(assert (implies
  (and (< unknown1@146@06 V@27@06) (<= 0 unknown1@146@06))
  (and
    (< unknown1@146@06 V@27@06)
    (<= 0 unknown1@146@06)
    (< unknown@145@06 (alen<Int> (opt_get1 $Snap.unit res@68@06)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@68@06) unknown@145@06)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@68@06) unknown@145@06))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@68@06) unknown@145@06))
        (as None<option<array>>  option<array>)))
    (<
      unknown1@146@06
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit res@68@06) unknown@145@06)))))
    ($FVF.loc_int ($FVF.lookup_int (as sm@144@06  $FVF<Int>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@68@06) unknown@145@06))) unknown1@146@06)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@68@06) unknown@145@06))) unknown1@146@06))
    (< unknown@145@06 (alen<Int> (opt_get1 $Snap.unit G@24@06)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@24@06) unknown@145@06)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@24@06) unknown@145@06))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@24@06) unknown@145@06))
        (as None<option<array>>  option<array>)))
    (<
      unknown1@146@06
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@24@06) unknown@145@06)))))
    ($FVF.loc_int ($FVF.lookup_int (as sm@144@06  $FVF<Int>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@24@06) unknown@145@06))) unknown1@146@06)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@24@06) unknown@145@06))) unknown1@146@06)))))
; Joined path conditions
(pop) ; 15
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((unknown1@146@06 Int)) (!
  (implies
    (and (< unknown1@146@06 V@27@06) (<= 0 unknown1@146@06))
    (and
      (< unknown1@146@06 V@27@06)
      (<= 0 unknown1@146@06)
      (< unknown@145@06 (alen<Int> (opt_get1 $Snap.unit res@68@06)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit res@68@06) unknown@145@06)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit res@68@06) unknown@145@06))
      (not
        (=
          ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit res@68@06) unknown@145@06))
          (as None<option<array>>  option<array>)))
      (<
        unknown1@146@06
        (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@68@06) unknown@145@06)))))
      ($FVF.loc_int ($FVF.lookup_int (as sm@144@06  $FVF<Int>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit res@68@06) unknown@145@06))) unknown1@146@06)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit res@68@06) unknown@145@06))) unknown1@146@06))
      (< unknown@145@06 (alen<Int> (opt_get1 $Snap.unit G@24@06)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@24@06) unknown@145@06)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@24@06) unknown@145@06))
      (not
        (=
          ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@24@06) unknown@145@06))
          (as None<option<array>>  option<array>)))
      (<
        unknown1@146@06
        (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@24@06) unknown@145@06)))))
      ($FVF.loc_int ($FVF.lookup_int (as sm@144@06  $FVF<Int>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@24@06) unknown@145@06))) unknown1@146@06)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@24@06) unknown@145@06))) unknown1@146@06))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit res@68@06) unknown@145@06))) unknown1@146@06))
  :qid |prog.l<no position>-aux|)))
(assert (forall ((unknown1@146@06 Int)) (!
  (implies
    (and (< unknown1@146@06 V@27@06) (<= 0 unknown1@146@06))
    (and
      (< unknown1@146@06 V@27@06)
      (<= 0 unknown1@146@06)
      (< unknown@145@06 (alen<Int> (opt_get1 $Snap.unit res@68@06)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit res@68@06) unknown@145@06)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit res@68@06) unknown@145@06))
      (not
        (=
          ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit res@68@06) unknown@145@06))
          (as None<option<array>>  option<array>)))
      (<
        unknown1@146@06
        (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@68@06) unknown@145@06)))))
      ($FVF.loc_int ($FVF.lookup_int (as sm@144@06  $FVF<Int>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit res@68@06) unknown@145@06))) unknown1@146@06)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit res@68@06) unknown@145@06))) unknown1@146@06))
      (< unknown@145@06 (alen<Int> (opt_get1 $Snap.unit G@24@06)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@24@06) unknown@145@06)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@24@06) unknown@145@06))
      (not
        (=
          ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@24@06) unknown@145@06))
          (as None<option<array>>  option<array>)))
      (<
        unknown1@146@06
        (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@24@06) unknown@145@06)))))
      ($FVF.loc_int ($FVF.lookup_int (as sm@144@06  $FVF<Int>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@24@06) unknown@145@06))) unknown1@146@06)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@24@06) unknown@145@06))) unknown1@146@06))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@24@06) unknown@145@06))) unknown1@146@06))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 14
(push) ; 14
; [else-branch: 139 | !(unknown@145@06 < V@27@06 && 0 <= unknown@145@06)]
(assert (not (and (< unknown@145@06 V@27@06) (<= 0 unknown@145@06))))
(pop) ; 14
(pop) ; 13
; Joined path conditions
(assert (implies
  (and (< unknown@145@06 V@27@06) (<= 0 unknown@145@06))
  (and
    (< unknown@145@06 V@27@06)
    (<= 0 unknown@145@06)
    (forall ((unknown1@146@06 Int)) (!
      (implies
        (and (< unknown1@146@06 V@27@06) (<= 0 unknown1@146@06))
        (and
          (< unknown1@146@06 V@27@06)
          (<= 0 unknown1@146@06)
          (< unknown@145@06 (alen<Int> (opt_get1 $Snap.unit res@68@06)))
          ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit res@68@06) unknown@145@06)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit res@68@06) unknown@145@06))
          (not
            (=
              ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit res@68@06) unknown@145@06))
              (as None<option<array>>  option<array>)))
          (<
            unknown1@146@06
            (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit res@68@06) unknown@145@06)))))
          ($FVF.loc_int ($FVF.lookup_int (as sm@144@06  $FVF<Int>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit res@68@06) unknown@145@06))) unknown1@146@06)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit res@68@06) unknown@145@06))) unknown1@146@06))
          (< unknown@145@06 (alen<Int> (opt_get1 $Snap.unit G@24@06)))
          ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@24@06) unknown@145@06)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@24@06) unknown@145@06))
          (not
            (=
              ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit G@24@06) unknown@145@06))
              (as None<option<array>>  option<array>)))
          (<
            unknown1@146@06
            (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@24@06) unknown@145@06)))))
          ($FVF.loc_int ($FVF.lookup_int (as sm@144@06  $FVF<Int>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@24@06) unknown@145@06))) unknown1@146@06)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@24@06) unknown@145@06))) unknown1@146@06))))
      :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit res@68@06) unknown@145@06))) unknown1@146@06))
      :qid |prog.l<no position>-aux|))
    (forall ((unknown1@146@06 Int)) (!
      (implies
        (and (< unknown1@146@06 V@27@06) (<= 0 unknown1@146@06))
        (and
          (< unknown1@146@06 V@27@06)
          (<= 0 unknown1@146@06)
          (< unknown@145@06 (alen<Int> (opt_get1 $Snap.unit res@68@06)))
          ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit res@68@06) unknown@145@06)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit res@68@06) unknown@145@06))
          (not
            (=
              ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit res@68@06) unknown@145@06))
              (as None<option<array>>  option<array>)))
          (<
            unknown1@146@06
            (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit res@68@06) unknown@145@06)))))
          ($FVF.loc_int ($FVF.lookup_int (as sm@144@06  $FVF<Int>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit res@68@06) unknown@145@06))) unknown1@146@06)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit res@68@06) unknown@145@06))) unknown1@146@06))
          (< unknown@145@06 (alen<Int> (opt_get1 $Snap.unit G@24@06)))
          ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@24@06) unknown@145@06)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@24@06) unknown@145@06))
          (not
            (=
              ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit G@24@06) unknown@145@06))
              (as None<option<array>>  option<array>)))
          (<
            unknown1@146@06
            (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@24@06) unknown@145@06)))))
          ($FVF.loc_int ($FVF.lookup_int (as sm@144@06  $FVF<Int>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@24@06) unknown@145@06))) unknown1@146@06)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@24@06) unknown@145@06))) unknown1@146@06))))
      :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@24@06) unknown@145@06))) unknown1@146@06))
      :qid |prog.l<no position>-aux|)))))
; Joined path conditions
(pop) ; 12
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((unknown@145@06 Int)) (!
  (implies
    (and (< unknown@145@06 V@27@06) (<= 0 unknown@145@06))
    (and
      (< unknown@145@06 V@27@06)
      (<= 0 unknown@145@06)
      (forall ((unknown1@146@06 Int)) (!
        (implies
          (and (< unknown1@146@06 V@27@06) (<= 0 unknown1@146@06))
          (and
            (< unknown1@146@06 V@27@06)
            (<= 0 unknown1@146@06)
            (< unknown@145@06 (alen<Int> (opt_get1 $Snap.unit res@68@06)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit res@68@06) unknown@145@06)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit res@68@06) unknown@145@06))
            (not
              (=
                ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit res@68@06) unknown@145@06))
                (as None<option<array>>  option<array>)))
            (<
              unknown1@146@06
              (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit res@68@06) unknown@145@06)))))
            ($FVF.loc_int ($FVF.lookup_int (as sm@144@06  $FVF<Int>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit res@68@06) unknown@145@06))) unknown1@146@06)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit res@68@06) unknown@145@06))) unknown1@146@06))
            (< unknown@145@06 (alen<Int> (opt_get1 $Snap.unit G@24@06)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@24@06) unknown@145@06)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@24@06) unknown@145@06))
            (not
              (=
                ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@24@06) unknown@145@06))
                (as None<option<array>>  option<array>)))
            (<
              unknown1@146@06
              (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit G@24@06) unknown@145@06)))))
            ($FVF.loc_int ($FVF.lookup_int (as sm@144@06  $FVF<Int>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@24@06) unknown@145@06))) unknown1@146@06)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@24@06) unknown@145@06))) unknown1@146@06))))
        :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@68@06) unknown@145@06))) unknown1@146@06))
        :qid |prog.l<no position>-aux|))
      (forall ((unknown1@146@06 Int)) (!
        (implies
          (and (< unknown1@146@06 V@27@06) (<= 0 unknown1@146@06))
          (and
            (< unknown1@146@06 V@27@06)
            (<= 0 unknown1@146@06)
            (< unknown@145@06 (alen<Int> (opt_get1 $Snap.unit res@68@06)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit res@68@06) unknown@145@06)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit res@68@06) unknown@145@06))
            (not
              (=
                ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit res@68@06) unknown@145@06))
                (as None<option<array>>  option<array>)))
            (<
              unknown1@146@06
              (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit res@68@06) unknown@145@06)))))
            ($FVF.loc_int ($FVF.lookup_int (as sm@144@06  $FVF<Int>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit res@68@06) unknown@145@06))) unknown1@146@06)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit res@68@06) unknown@145@06))) unknown1@146@06))
            (< unknown@145@06 (alen<Int> (opt_get1 $Snap.unit G@24@06)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@24@06) unknown@145@06)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@24@06) unknown@145@06))
            (not
              (=
                ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@24@06) unknown@145@06))
                (as None<option<array>>  option<array>)))
            (<
              unknown1@146@06
              (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit G@24@06) unknown@145@06)))))
            ($FVF.loc_int ($FVF.lookup_int (as sm@144@06  $FVF<Int>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@24@06) unknown@145@06))) unknown1@146@06)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@24@06) unknown@145@06))) unknown1@146@06))))
        :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@24@06) unknown@145@06))) unknown1@146@06))
        :qid |prog.l<no position>-aux|))))
  :pattern ((opt_get1%limited $Snap.unit ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit res@68@06) unknown@145@06))))
  :qid |prog.l<no position>-aux|)))
(assert (forall ((unknown@145@06 Int)) (!
  (implies
    (and (< unknown@145@06 V@27@06) (<= 0 unknown@145@06))
    (and
      (< unknown@145@06 V@27@06)
      (<= 0 unknown@145@06)
      (forall ((unknown1@146@06 Int)) (!
        (implies
          (and (< unknown1@146@06 V@27@06) (<= 0 unknown1@146@06))
          (and
            (< unknown1@146@06 V@27@06)
            (<= 0 unknown1@146@06)
            (< unknown@145@06 (alen<Int> (opt_get1 $Snap.unit res@68@06)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit res@68@06) unknown@145@06)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit res@68@06) unknown@145@06))
            (not
              (=
                ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit res@68@06) unknown@145@06))
                (as None<option<array>>  option<array>)))
            (<
              unknown1@146@06
              (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit res@68@06) unknown@145@06)))))
            ($FVF.loc_int ($FVF.lookup_int (as sm@144@06  $FVF<Int>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit res@68@06) unknown@145@06))) unknown1@146@06)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit res@68@06) unknown@145@06))) unknown1@146@06))
            (< unknown@145@06 (alen<Int> (opt_get1 $Snap.unit G@24@06)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@24@06) unknown@145@06)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@24@06) unknown@145@06))
            (not
              (=
                ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@24@06) unknown@145@06))
                (as None<option<array>>  option<array>)))
            (<
              unknown1@146@06
              (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit G@24@06) unknown@145@06)))))
            ($FVF.loc_int ($FVF.lookup_int (as sm@144@06  $FVF<Int>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@24@06) unknown@145@06))) unknown1@146@06)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@24@06) unknown@145@06))) unknown1@146@06))))
        :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@68@06) unknown@145@06))) unknown1@146@06))
        :qid |prog.l<no position>-aux|))
      (forall ((unknown1@146@06 Int)) (!
        (implies
          (and (< unknown1@146@06 V@27@06) (<= 0 unknown1@146@06))
          (and
            (< unknown1@146@06 V@27@06)
            (<= 0 unknown1@146@06)
            (< unknown@145@06 (alen<Int> (opt_get1 $Snap.unit res@68@06)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit res@68@06) unknown@145@06)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit res@68@06) unknown@145@06))
            (not
              (=
                ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit res@68@06) unknown@145@06))
                (as None<option<array>>  option<array>)))
            (<
              unknown1@146@06
              (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit res@68@06) unknown@145@06)))))
            ($FVF.loc_int ($FVF.lookup_int (as sm@144@06  $FVF<Int>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit res@68@06) unknown@145@06))) unknown1@146@06)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit res@68@06) unknown@145@06))) unknown1@146@06))
            (< unknown@145@06 (alen<Int> (opt_get1 $Snap.unit G@24@06)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@24@06) unknown@145@06)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@24@06) unknown@145@06))
            (not
              (=
                ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@24@06) unknown@145@06))
                (as None<option<array>>  option<array>)))
            (<
              unknown1@146@06
              (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit G@24@06) unknown@145@06)))))
            ($FVF.loc_int ($FVF.lookup_int (as sm@144@06  $FVF<Int>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@24@06) unknown@145@06))) unknown1@146@06)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@24@06) unknown@145@06))) unknown1@146@06))))
        :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@24@06) unknown@145@06))) unknown1@146@06))
        :qid |prog.l<no position>-aux|))))
  :pattern ((opt_get1%limited $Snap.unit ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@24@06) unknown@145@06))))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 11
(pop) ; 10
; Joined path conditions
(assert (implies
  (= exc@116@06 $Ref.null)
  (and
    (forall ((unknown@145@06 Int)) (!
      (implies
        (and (< unknown@145@06 V@27@06) (<= 0 unknown@145@06))
        (and
          (< unknown@145@06 V@27@06)
          (<= 0 unknown@145@06)
          (forall ((unknown1@146@06 Int)) (!
            (implies
              (and (< unknown1@146@06 V@27@06) (<= 0 unknown1@146@06))
              (and
                (< unknown1@146@06 V@27@06)
                (<= 0 unknown1@146@06)
                (< unknown@145@06 (alen<Int> (opt_get1 $Snap.unit res@68@06)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit res@68@06) unknown@145@06)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit res@68@06) unknown@145@06))
                (not
                  (=
                    ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit res@68@06) unknown@145@06))
                    (as None<option<array>>  option<array>)))
                (<
                  unknown1@146@06
                  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit res@68@06) unknown@145@06)))))
                ($FVF.loc_int ($FVF.lookup_int (as sm@144@06  $FVF<Int>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit res@68@06) unknown@145@06))) unknown1@146@06)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit res@68@06) unknown@145@06))) unknown1@146@06))
                (< unknown@145@06 (alen<Int> (opt_get1 $Snap.unit G@24@06)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@24@06) unknown@145@06)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@24@06) unknown@145@06))
                (not
                  (=
                    ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit G@24@06) unknown@145@06))
                    (as None<option<array>>  option<array>)))
                (<
                  unknown1@146@06
                  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit G@24@06) unknown@145@06)))))
                ($FVF.loc_int ($FVF.lookup_int (as sm@144@06  $FVF<Int>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@24@06) unknown@145@06))) unknown1@146@06)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@24@06) unknown@145@06))) unknown1@146@06))))
            :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit res@68@06) unknown@145@06))) unknown1@146@06))
            :qid |prog.l<no position>-aux|))
          (forall ((unknown1@146@06 Int)) (!
            (implies
              (and (< unknown1@146@06 V@27@06) (<= 0 unknown1@146@06))
              (and
                (< unknown1@146@06 V@27@06)
                (<= 0 unknown1@146@06)
                (< unknown@145@06 (alen<Int> (opt_get1 $Snap.unit res@68@06)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit res@68@06) unknown@145@06)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit res@68@06) unknown@145@06))
                (not
                  (=
                    ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit res@68@06) unknown@145@06))
                    (as None<option<array>>  option<array>)))
                (<
                  unknown1@146@06
                  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit res@68@06) unknown@145@06)))))
                ($FVF.loc_int ($FVF.lookup_int (as sm@144@06  $FVF<Int>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit res@68@06) unknown@145@06))) unknown1@146@06)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit res@68@06) unknown@145@06))) unknown1@146@06))
                (< unknown@145@06 (alen<Int> (opt_get1 $Snap.unit G@24@06)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@24@06) unknown@145@06)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@24@06) unknown@145@06))
                (not
                  (=
                    ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit G@24@06) unknown@145@06))
                    (as None<option<array>>  option<array>)))
                (<
                  unknown1@146@06
                  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit G@24@06) unknown@145@06)))))
                ($FVF.loc_int ($FVF.lookup_int (as sm@144@06  $FVF<Int>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@24@06) unknown@145@06))) unknown1@146@06)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@24@06) unknown@145@06))) unknown1@146@06))))
            :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@24@06) unknown@145@06))) unknown1@146@06))
            :qid |prog.l<no position>-aux|))))
      :pattern ((opt_get1%limited $Snap.unit ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit res@68@06) unknown@145@06))))
      :qid |prog.l<no position>-aux|))
    (forall ((unknown@145@06 Int)) (!
      (implies
        (and (< unknown@145@06 V@27@06) (<= 0 unknown@145@06))
        (and
          (< unknown@145@06 V@27@06)
          (<= 0 unknown@145@06)
          (forall ((unknown1@146@06 Int)) (!
            (implies
              (and (< unknown1@146@06 V@27@06) (<= 0 unknown1@146@06))
              (and
                (< unknown1@146@06 V@27@06)
                (<= 0 unknown1@146@06)
                (< unknown@145@06 (alen<Int> (opt_get1 $Snap.unit res@68@06)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit res@68@06) unknown@145@06)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit res@68@06) unknown@145@06))
                (not
                  (=
                    ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit res@68@06) unknown@145@06))
                    (as None<option<array>>  option<array>)))
                (<
                  unknown1@146@06
                  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit res@68@06) unknown@145@06)))))
                ($FVF.loc_int ($FVF.lookup_int (as sm@144@06  $FVF<Int>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit res@68@06) unknown@145@06))) unknown1@146@06)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit res@68@06) unknown@145@06))) unknown1@146@06))
                (< unknown@145@06 (alen<Int> (opt_get1 $Snap.unit G@24@06)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@24@06) unknown@145@06)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@24@06) unknown@145@06))
                (not
                  (=
                    ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit G@24@06) unknown@145@06))
                    (as None<option<array>>  option<array>)))
                (<
                  unknown1@146@06
                  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit G@24@06) unknown@145@06)))))
                ($FVF.loc_int ($FVF.lookup_int (as sm@144@06  $FVF<Int>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@24@06) unknown@145@06))) unknown1@146@06)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@24@06) unknown@145@06))) unknown1@146@06))))
            :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit res@68@06) unknown@145@06))) unknown1@146@06))
            :qid |prog.l<no position>-aux|))
          (forall ((unknown1@146@06 Int)) (!
            (implies
              (and (< unknown1@146@06 V@27@06) (<= 0 unknown1@146@06))
              (and
                (< unknown1@146@06 V@27@06)
                (<= 0 unknown1@146@06)
                (< unknown@145@06 (alen<Int> (opt_get1 $Snap.unit res@68@06)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit res@68@06) unknown@145@06)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit res@68@06) unknown@145@06))
                (not
                  (=
                    ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit res@68@06) unknown@145@06))
                    (as None<option<array>>  option<array>)))
                (<
                  unknown1@146@06
                  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit res@68@06) unknown@145@06)))))
                ($FVF.loc_int ($FVF.lookup_int (as sm@144@06  $FVF<Int>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit res@68@06) unknown@145@06))) unknown1@146@06)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit res@68@06) unknown@145@06))) unknown1@146@06))
                (< unknown@145@06 (alen<Int> (opt_get1 $Snap.unit G@24@06)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@24@06) unknown@145@06)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@24@06) unknown@145@06))
                (not
                  (=
                    ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit G@24@06) unknown@145@06))
                    (as None<option<array>>  option<array>)))
                (<
                  unknown1@146@06
                  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit G@24@06) unknown@145@06)))))
                ($FVF.loc_int ($FVF.lookup_int (as sm@144@06  $FVF<Int>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@24@06) unknown@145@06))) unknown1@146@06)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@24@06) unknown@145@06))) unknown1@146@06))))
            :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@24@06) unknown@145@06))) unknown1@146@06))
            :qid |prog.l<no position>-aux|))))
      :pattern ((opt_get1%limited $Snap.unit ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@24@06) unknown@145@06))))
      :qid |prog.l<no position>-aux|)))))
(assert (implies
  (= exc@116@06 $Ref.null)
  (forall ((unknown@145@06 Int)) (!
    (implies
      (and (< unknown@145@06 V@27@06) (<= 0 unknown@145@06))
      (forall ((unknown1@146@06 Int)) (!
        (implies
          (and (< unknown1@146@06 V@27@06) (<= 0 unknown1@146@06))
          (=
            ($FVF.lookup_int (as sm@144@06  $FVF<Int>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit res@68@06) unknown@145@06))) unknown1@146@06))
            ($FVF.lookup_int (as sm@144@06  $FVF<Int>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@24@06) unknown@145@06))) unknown1@146@06))))
        :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@68@06) unknown@145@06))) unknown1@146@06))
        :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@24@06) unknown@145@06))) unknown1@146@06))
        :qid |prog.l<no position>|)))
    :pattern ((opt_get1%limited $Snap.unit ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@68@06) unknown@145@06))))
    :pattern ((opt_get1%limited $Snap.unit ($FVF.lookup_option$array$ (as sm@130@06  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@24@06) unknown@145@06))))
    :qid |prog.l<no position>|))))
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
; [eval] exc != null
; [then-branch: 142 | exc@116@06 != Null | dead]
; [else-branch: 142 | exc@116@06 == Null | live]
(push) ; 10
; [else-branch: 142 | exc@116@06 == Null]
(pop) ; 10
; [eval] !(exc != null)
; [eval] exc != null
(set-option :timeout 10)
(push) ; 10
(assert (not (not (= exc@116@06 $Ref.null))))
(check-sat)
; unknown
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               15737
;  :arith-add-rows          11283
;  :arith-assert-diseq      1049
;  :arith-assert-lower      4527
;  :arith-assert-upper      2924
;  :arith-bound-prop        1559
;  :arith-conflicts         337
;  :arith-eq-adapter        3168
;  :arith-fixed-eqs         1479
;  :arith-offset-eqs        1725
;  :arith-pivots            2740
;  :conflicts               801
;  :datatype-accessor-ax    65
;  :datatype-constructor-ax 370
;  :datatype-occurs-check   219
;  :datatype-splits         181
;  :decisions               1848
;  :del-clause              22702
;  :final-checks            123
;  :interface-eqs           6
;  :max-generation          8
;  :max-memory              7.70
;  :memory                  7.65
;  :minimized-lits          63
;  :mk-bool-var             32092
;  :mk-clause               22706
;  :num-allocs              339230
;  :num-checks              215
;  :propagations            10002
;  :quant-instantiations    7317
;  :rlimit-count            890434)
; [then-branch: 143 | exc@116@06 == Null | live]
; [else-branch: 143 | exc@116@06 != Null | dead]
(push) ; 10
; [then-branch: 143 | exc@116@06 == Null]
; [exec]
; evaluationDummy := res2
; [exec]
; exc, res3 := make_array1(tid, V)
(declare-const exc@147@06 $Ref)
(declare-const res@148@06 option<array>)
(declare-const $t@149@06 $Snap)
(assert (= $t@149@06 ($Snap.combine ($Snap.first $t@149@06) ($Snap.second $t@149@06))))
(assert (= ($Snap.first $t@149@06) $Snap.unit))
; [eval] exc == null
(assert (= exc@147@06 $Ref.null))
(assert (=
  ($Snap.second $t@149@06)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@149@06))
    ($Snap.second ($Snap.second $t@149@06)))))
(assert (= ($Snap.first ($Snap.second $t@149@06)) $Snap.unit))
; [eval] exc == null ==> res != (None(): option[array])
; [eval] exc == null
(push) ; 11
(push) ; 12
(assert (not (not (= exc@147@06 $Ref.null))))
(check-sat)
; unknown
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               15796
;  :arith-add-rows          11283
;  :arith-assert-diseq      1049
;  :arith-assert-lower      4527
;  :arith-assert-upper      2924
;  :arith-bound-prop        1559
;  :arith-conflicts         337
;  :arith-eq-adapter        3168
;  :arith-fixed-eqs         1479
;  :arith-offset-eqs        1725
;  :arith-pivots            2740
;  :conflicts               801
;  :datatype-accessor-ax    67
;  :datatype-constructor-ax 379
;  :datatype-occurs-check   226
;  :datatype-splits         188
;  :decisions               1857
;  :del-clause              22702
;  :final-checks            125
;  :interface-eqs           6
;  :max-generation          8
;  :max-memory              7.70
;  :memory                  7.65
;  :minimized-lits          63
;  :mk-bool-var             32104
;  :mk-clause               22706
;  :num-allocs              340004
;  :num-checks              216
;  :propagations            10002
;  :quant-instantiations    7317
;  :rlimit-count            891426)
; [then-branch: 144 | exc@147@06 == Null | live]
; [else-branch: 144 | exc@147@06 != Null | dead]
(push) ; 12
; [then-branch: 144 | exc@147@06 == Null]
; [eval] res != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 12
(pop) ; 11
; Joined path conditions
(assert (implies
  (= exc@147@06 $Ref.null)
  (not (= res@148@06 (as None<option<array>>  option<array>)))))
(assert (=
  ($Snap.second ($Snap.second $t@149@06))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second $t@149@06)))
    ($Snap.second ($Snap.second ($Snap.second $t@149@06))))))
(assert (= ($Snap.first ($Snap.second ($Snap.second $t@149@06))) $Snap.unit))
; [eval] exc == null ==> alen(opt_get1(res)) == dim0
; [eval] exc == null
(push) ; 11
(push) ; 12
(assert (not (not (= exc@147@06 $Ref.null))))
(check-sat)
; unknown
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               15849
;  :arith-add-rows          11283
;  :arith-assert-diseq      1049
;  :arith-assert-lower      4527
;  :arith-assert-upper      2924
;  :arith-bound-prop        1559
;  :arith-conflicts         337
;  :arith-eq-adapter        3168
;  :arith-fixed-eqs         1479
;  :arith-offset-eqs        1725
;  :arith-pivots            2740
;  :conflicts               801
;  :datatype-accessor-ax    68
;  :datatype-constructor-ax 388
;  :datatype-occurs-check   233
;  :datatype-splits         195
;  :decisions               1866
;  :del-clause              22702
;  :final-checks            127
;  :interface-eqs           6
;  :max-generation          8
;  :max-memory              7.70
;  :memory                  7.65
;  :minimized-lits          63
;  :mk-bool-var             32114
;  :mk-clause               22706
;  :num-allocs              340742
;  :num-checks              217
;  :propagations            10002
;  :quant-instantiations    7317
;  :rlimit-count            892344)
; [then-branch: 145 | exc@147@06 == Null | live]
; [else-branch: 145 | exc@147@06 != Null | dead]
(push) ; 12
; [then-branch: 145 | exc@147@06 == Null]
; [eval] alen(opt_get1(res)) == dim0
; [eval] alen(opt_get1(res))
; [eval] opt_get1(res)
(push) ; 13
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(set-option :timeout 0)
(push) ; 14
(assert (not (not (= res@148@06 (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               15849
;  :arith-add-rows          11283
;  :arith-assert-diseq      1049
;  :arith-assert-lower      4527
;  :arith-assert-upper      2924
;  :arith-bound-prop        1559
;  :arith-conflicts         337
;  :arith-eq-adapter        3168
;  :arith-fixed-eqs         1479
;  :arith-offset-eqs        1725
;  :arith-pivots            2740
;  :conflicts               801
;  :datatype-accessor-ax    68
;  :datatype-constructor-ax 388
;  :datatype-occurs-check   233
;  :datatype-splits         195
;  :decisions               1866
;  :del-clause              22702
;  :final-checks            127
;  :interface-eqs           6
;  :max-generation          8
;  :max-memory              7.70
;  :memory                  7.65
;  :minimized-lits          63
;  :mk-bool-var             32114
;  :mk-clause               22706
;  :num-allocs              340766
;  :num-checks              218
;  :propagations            10002
;  :quant-instantiations    7317
;  :rlimit-count            892365)
(assert (not (= res@148@06 (as None<option<array>>  option<array>))))
(pop) ; 13
; Joined path conditions
(assert (not (= res@148@06 (as None<option<array>>  option<array>))))
(pop) ; 12
(pop) ; 11
; Joined path conditions
(assert (implies
  (= exc@147@06 $Ref.null)
  (= (alen<Int> (opt_get1 $Snap.unit res@148@06)) V@27@06)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second $t@149@06)))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@149@06))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@149@06)))))))
; [eval] exc == null
(set-option :timeout 10)
(push) ; 11
(assert (not (not (= exc@147@06 $Ref.null))))
(check-sat)
; unknown
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               15910
;  :arith-add-rows          11284
;  :arith-assert-diseq      1049
;  :arith-assert-lower      4529
;  :arith-assert-upper      2925
;  :arith-bound-prop        1559
;  :arith-conflicts         337
;  :arith-eq-adapter        3169
;  :arith-fixed-eqs         1480
;  :arith-offset-eqs        1725
;  :arith-pivots            2741
;  :conflicts               801
;  :datatype-accessor-ax    69
;  :datatype-constructor-ax 398
;  :datatype-occurs-check   240
;  :datatype-splits         203
;  :decisions               1876
;  :del-clause              22702
;  :final-checks            129
;  :interface-eqs           6
;  :max-generation          8
;  :max-memory              7.70
;  :memory                  7.65
;  :minimized-lits          63
;  :mk-bool-var             32132
;  :mk-clause               22706
;  :num-allocs              341560
;  :num-checks              219
;  :propagations            10002
;  :quant-instantiations    7322
;  :rlimit-count            893397)
; [then-branch: 146 | exc@147@06 == Null | live]
; [else-branch: 146 | exc@147@06 != Null | dead]
(push) ; 11
; [then-branch: 146 | exc@147@06 == Null]
(declare-const i0@150@06 Int)
(push) ; 12
; [eval] 0 <= i0 && i0 < dim0
; [eval] 0 <= i0
(push) ; 13
; [then-branch: 147 | 0 <= i0@150@06 | live]
; [else-branch: 147 | !(0 <= i0@150@06) | live]
(push) ; 14
; [then-branch: 147 | 0 <= i0@150@06]
(assert (<= 0 i0@150@06))
; [eval] i0 < dim0
(pop) ; 14
(push) ; 14
; [else-branch: 147 | !(0 <= i0@150@06)]
(assert (not (<= 0 i0@150@06)))
(pop) ; 14
(pop) ; 13
; Joined path conditions
; Joined path conditions
(assert (and (< i0@150@06 V@27@06) (<= 0 i0@150@06)))
; [eval] aloc(opt_get1(res), i0)
; [eval] opt_get1(res)
(push) ; 13
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(set-option :timeout 0)
(push) ; 14
(assert (not (not (= res@148@06 (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               15910
;  :arith-add-rows          11285
;  :arith-assert-diseq      1049
;  :arith-assert-lower      4531
;  :arith-assert-upper      2925
;  :arith-bound-prop        1559
;  :arith-conflicts         337
;  :arith-eq-adapter        3169
;  :arith-fixed-eqs         1480
;  :arith-offset-eqs        1725
;  :arith-pivots            2741
;  :conflicts               801
;  :datatype-accessor-ax    69
;  :datatype-constructor-ax 398
;  :datatype-occurs-check   240
;  :datatype-splits         203
;  :decisions               1876
;  :del-clause              22702
;  :final-checks            129
;  :interface-eqs           6
;  :max-generation          8
;  :max-memory              7.70
;  :memory                  7.65
;  :minimized-lits          63
;  :mk-bool-var             32134
;  :mk-clause               22706
;  :num-allocs              341659
;  :num-checks              220
;  :propagations            10002
;  :quant-instantiations    7322
;  :rlimit-count            893567)
(assert (not (= res@148@06 (as None<option<array>>  option<array>))))
(pop) ; 13
; Joined path conditions
(assert (not (= res@148@06 (as None<option<array>>  option<array>))))
(push) ; 13
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 14
(assert (not (< i0@150@06 (alen<Int> (opt_get1 $Snap.unit res@148@06)))))
(check-sat)
; unsat
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               15910
;  :arith-add-rows          11285
;  :arith-assert-diseq      1049
;  :arith-assert-lower      4531
;  :arith-assert-upper      2925
;  :arith-bound-prop        1559
;  :arith-conflicts         337
;  :arith-eq-adapter        3169
;  :arith-fixed-eqs         1480
;  :arith-offset-eqs        1725
;  :arith-pivots            2741
;  :conflicts               801
;  :datatype-accessor-ax    69
;  :datatype-constructor-ax 398
;  :datatype-occurs-check   240
;  :datatype-splits         203
;  :decisions               1876
;  :del-clause              22702
;  :final-checks            129
;  :interface-eqs           6
;  :max-generation          8
;  :max-memory              7.70
;  :memory                  7.65
;  :minimized-lits          63
;  :mk-bool-var             32134
;  :mk-clause               22706
;  :num-allocs              341679
;  :num-checks              221
;  :propagations            10002
;  :quant-instantiations    7322
;  :rlimit-count            893598)
(assert (< i0@150@06 (alen<Int> (opt_get1 $Snap.unit res@148@06))))
(pop) ; 13
; Joined path conditions
(assert (< i0@150@06 (alen<Int> (opt_get1 $Snap.unit res@148@06))))
; Definitional axioms for snapshot map values
; [eval] aloc(opt_get1(res), i0)
; [eval] opt_get1(res)
(push) ; 13
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 13
; Joined path conditions
(push) ; 13
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(pop) ; 13
; Joined path conditions
(pop) ; 12
(declare-fun inv@151@06 ($Ref) Int)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(assert (forall ((i0@150@06 Int)) (!
  (and
    (not (= res@148@06 (as None<option<array>>  option<array>)))
    (< i0@150@06 (alen<Int> (opt_get1 $Snap.unit res@148@06))))
  :pattern (($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@149@06))))) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit res@148@06) i0@150@06)) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit res@148@06) i0@150@06)))
  :qid |int-aux|)))
; Check receiver injectivity
(push) ; 12
(assert (not (forall ((i01@150@06 Int) (i02@150@06 Int)) (!
  (implies
    (and
      (and (< i01@150@06 V@27@06) (<= 0 i01@150@06))
      (and (< i02@150@06 V@27@06) (<= 0 i02@150@06))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@148@06) i01@150@06)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@148@06) i02@150@06)))
    (= i01@150@06 i02@150@06))
  
  :qid |int-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               15943
;  :arith-add-rows          11297
;  :arith-assert-diseq      1053
;  :arith-assert-lower      4539
;  :arith-assert-upper      2926
;  :arith-bound-prop        1559
;  :arith-conflicts         339
;  :arith-eq-adapter        3170
;  :arith-fixed-eqs         1480
;  :arith-offset-eqs        1725
;  :arith-pivots            2745
;  :conflicts               806
;  :datatype-accessor-ax    69
;  :datatype-constructor-ax 400
;  :datatype-occurs-check   240
;  :datatype-splits         203
;  :decisions               1880
;  :del-clause              22719
;  :final-checks            129
;  :interface-eqs           6
;  :max-generation          8
;  :max-memory              7.70
;  :memory                  7.64
;  :minimized-lits          63
;  :mk-bool-var             32161
;  :mk-clause               22723
;  :num-allocs              342239
;  :num-checks              222
;  :propagations            10022
;  :quant-instantiations    7331
;  :rlimit-count            894949)
; Definitional axioms for inverse functions
(assert (forall ((i0@150@06 Int)) (!
  (implies
    (and (< i0@150@06 V@27@06) (<= 0 i0@150@06))
    (=
      (inv@151@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@148@06) i0@150@06))
      i0@150@06))
  :pattern (($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@149@06))))) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit res@148@06) i0@150@06)) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit res@148@06) i0@150@06)))
  )))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@151@06 r) V@27@06) (<= 0 (inv@151@06 r)))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@148@06) (inv@151@06 r))
      r))
  :pattern ((inv@151@06 r))
  :qid |int-fctOfInv|)))
; Permissions are non-negative
; Field permissions are at most one
; Permission implies non-null receiver
(assert (forall ((i0@150@06 Int)) (!
  (implies
    (and (< i0@150@06 V@27@06) (<= 0 i0@150@06))
    (not
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@148@06) i0@150@06)
        $Ref.null)))
  :pattern (($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@149@06))))) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit res@148@06) i0@150@06)) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit res@148@06) i0@150@06)))
  :qid |int-permImpliesNonNull|)))
(declare-const sm@152@06 $FVF<Int>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@151@06 r) V@27@06) (<= 0 (inv@151@06 r)))
    (=
      ($FVF.lookup_int (as sm@152@06  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@149@06))))) r)))
  :pattern (($FVF.lookup_int (as sm@152@06  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@149@06))))) r))
  :qid |qp.fvfValDef41|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@143@06 r) V@27@06) (<= 0 (inv@143@06 r)))
        (< (inv@142@06 r) V@27@06))
      (<= 0 (inv@142@06 r)))
    (=
      ($FVF.lookup_int (as sm@152@06  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@118@06)))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@152@06  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@118@06)))))))))))))))) r))
  :qid |qp.fvfValDef42|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@138@06 r) V@27@06) (<= 0 (inv@138@06 r)))
        (< (inv@137@06 r) V@27@06))
      (<= 0 (inv@137@06 r)))
    (=
      ($FVF.lookup_int (as sm@152@06  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@118@06))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@152@06  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@118@06))))))))))))))) r))
  :qid |qp.fvfValDef43|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@149@06))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@118@06)))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@118@06))))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@152@06  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef44|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@151@06 r) V@27@06) (<= 0 (inv@151@06 r)))
    ($FVF.loc_int ($FVF.lookup_int (as sm@152@06  $FVF<Int>) r) r))
  :pattern ((inv@151@06 r))
  )))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@149@06))))
  $Snap.unit))
; [eval] exc == null ==> (forall i0: Int :: { aloc(opt_get1(res), i0).int } 0 <= i0 && i0 < dim0 ==> aloc(opt_get1(res), i0).int == 0)
; [eval] exc == null
(push) ; 12
(set-option :timeout 10)
(push) ; 13
(assert (not (not (= exc@147@06 $Ref.null))))
(check-sat)
; unknown
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               15993
;  :arith-add-rows          11297
;  :arith-assert-diseq      1053
;  :arith-assert-lower      4539
;  :arith-assert-upper      2926
;  :arith-bound-prop        1559
;  :arith-conflicts         339
;  :arith-eq-adapter        3170
;  :arith-fixed-eqs         1480
;  :arith-offset-eqs        1725
;  :arith-pivots            2745
;  :conflicts               806
;  :datatype-accessor-ax    69
;  :datatype-constructor-ax 409
;  :datatype-occurs-check   247
;  :datatype-splits         210
;  :decisions               1889
;  :del-clause              22719
;  :final-checks            131
;  :interface-eqs           6
;  :max-generation          8
;  :max-memory              7.70
;  :memory                  7.65
;  :minimized-lits          63
;  :mk-bool-var             32177
;  :mk-clause               22723
;  :num-allocs              344122
;  :num-checks              223
;  :propagations            10022
;  :quant-instantiations    7331
;  :rlimit-count            899352)
; [then-branch: 148 | exc@147@06 == Null | live]
; [else-branch: 148 | exc@147@06 != Null | dead]
(push) ; 13
; [then-branch: 148 | exc@147@06 == Null]
; [eval] (forall i0: Int :: { aloc(opt_get1(res), i0).int } 0 <= i0 && i0 < dim0 ==> aloc(opt_get1(res), i0).int == 0)
(declare-const i0@153@06 Int)
(push) ; 14
; [eval] 0 <= i0 && i0 < dim0 ==> aloc(opt_get1(res), i0).int == 0
; [eval] 0 <= i0 && i0 < dim0
; [eval] 0 <= i0
(push) ; 15
; [then-branch: 149 | 0 <= i0@153@06 | live]
; [else-branch: 149 | !(0 <= i0@153@06) | live]
(push) ; 16
; [then-branch: 149 | 0 <= i0@153@06]
(assert (<= 0 i0@153@06))
; [eval] i0 < dim0
(pop) ; 16
(push) ; 16
; [else-branch: 149 | !(0 <= i0@153@06)]
(assert (not (<= 0 i0@153@06)))
(pop) ; 16
(pop) ; 15
; Joined path conditions
; Joined path conditions
(push) ; 15
; [then-branch: 150 | i0@153@06 < V@27@06 && 0 <= i0@153@06 | live]
; [else-branch: 150 | !(i0@153@06 < V@27@06 && 0 <= i0@153@06) | live]
(push) ; 16
; [then-branch: 150 | i0@153@06 < V@27@06 && 0 <= i0@153@06]
(assert (and (< i0@153@06 V@27@06) (<= 0 i0@153@06)))
; [eval] aloc(opt_get1(res), i0).int == 0
; [eval] aloc(opt_get1(res), i0)
; [eval] opt_get1(res)
(push) ; 17
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(set-option :timeout 0)
(push) ; 18
(assert (not (not (= res@148@06 (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 18
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               15993
;  :arith-add-rows          11298
;  :arith-assert-diseq      1053
;  :arith-assert-lower      4541
;  :arith-assert-upper      2926
;  :arith-bound-prop        1559
;  :arith-conflicts         339
;  :arith-eq-adapter        3170
;  :arith-fixed-eqs         1480
;  :arith-offset-eqs        1725
;  :arith-pivots            2745
;  :conflicts               806
;  :datatype-accessor-ax    69
;  :datatype-constructor-ax 409
;  :datatype-occurs-check   247
;  :datatype-splits         210
;  :decisions               1889
;  :del-clause              22719
;  :final-checks            131
;  :interface-eqs           6
;  :max-generation          8
;  :max-memory              7.70
;  :memory                  7.65
;  :minimized-lits          63
;  :mk-bool-var             32179
;  :mk-clause               22723
;  :num-allocs              344221
;  :num-checks              224
;  :propagations            10022
;  :quant-instantiations    7331
;  :rlimit-count            899534)
(assert (not (= res@148@06 (as None<option<array>>  option<array>))))
(pop) ; 17
; Joined path conditions
(assert (not (= res@148@06 (as None<option<array>>  option<array>))))
(push) ; 17
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 18
(assert (not (< i0@153@06 (alen<Int> (opt_get1 $Snap.unit res@148@06)))))
(check-sat)
; unsat
(pop) ; 18
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               15993
;  :arith-add-rows          11298
;  :arith-assert-diseq      1053
;  :arith-assert-lower      4541
;  :arith-assert-upper      2926
;  :arith-bound-prop        1559
;  :arith-conflicts         339
;  :arith-eq-adapter        3170
;  :arith-fixed-eqs         1480
;  :arith-offset-eqs        1725
;  :arith-pivots            2745
;  :conflicts               806
;  :datatype-accessor-ax    69
;  :datatype-constructor-ax 409
;  :datatype-occurs-check   247
;  :datatype-splits         210
;  :decisions               1889
;  :del-clause              22719
;  :final-checks            131
;  :interface-eqs           6
;  :max-generation          8
;  :max-memory              7.70
;  :memory                  7.65
;  :minimized-lits          63
;  :mk-bool-var             32179
;  :mk-clause               22723
;  :num-allocs              344241
;  :num-checks              225
;  :propagations            10022
;  :quant-instantiations    7331
;  :rlimit-count            899565)
(assert (< i0@153@06 (alen<Int> (opt_get1 $Snap.unit res@148@06))))
(pop) ; 17
; Joined path conditions
(assert (< i0@153@06 (alen<Int> (opt_get1 $Snap.unit res@148@06))))
(assert ($FVF.loc_int ($FVF.lookup_int (as sm@152@06  $FVF<Int>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit res@148@06) i0@153@06)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit res@148@06) i0@153@06)))
(push) ; 17
(assert (not (<
  $Perm.No
  (+
    (+
      (ite
        (and
          (<
            (inv@151@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@148@06) i0@153@06))
            V@27@06)
          (<=
            0
            (inv@151@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@148@06) i0@153@06))))
        $Perm.Write
        $Perm.No)
      (ite
        (and
          (and
            (and
              (<
                (inv@143@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@148@06) i0@153@06))
                V@27@06)
              (<=
                0
                (inv@143@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@148@06) i0@153@06))))
            (<
              (inv@142@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@148@06) i0@153@06))
              V@27@06))
          (<=
            0
            (inv@142@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@148@06) i0@153@06))))
        $Perm.Write
        $Perm.No))
    (ite
      (and
        (and
          (and
            (<
              (inv@138@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@148@06) i0@153@06))
              V@27@06)
            (<=
              0
              (inv@138@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@148@06) i0@153@06))))
          (<
            (inv@137@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@148@06) i0@153@06))
            V@27@06))
        (<=
          0
          (inv@137@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@148@06) i0@153@06))))
      $Perm.Write
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               16051
;  :arith-add-rows          11308
;  :arith-assert-diseq      1053
;  :arith-assert-lower      4551
;  :arith-assert-upper      2936
;  :arith-bound-prop        1563
;  :arith-conflicts         341
;  :arith-eq-adapter        3181
;  :arith-fixed-eqs         1481
;  :arith-offset-eqs        1727
;  :arith-pivots            2751
;  :conflicts               815
;  :datatype-accessor-ax    69
;  :datatype-constructor-ax 411
;  :datatype-occurs-check   247
;  :datatype-splits         210
;  :decisions               1897
;  :del-clause              22751
;  :final-checks            131
;  :interface-eqs           6
;  :max-generation          8
;  :max-memory              7.70
;  :memory                  7.65
;  :minimized-lits          63
;  :mk-bool-var             32288
;  :mk-clause               22798
;  :num-allocs              344868
;  :num-checks              226
;  :propagations            10076
;  :quant-instantiations    7357
;  :rlimit-count            901804)
(pop) ; 16
(push) ; 16
; [else-branch: 150 | !(i0@153@06 < V@27@06 && 0 <= i0@153@06)]
(assert (not (and (< i0@153@06 V@27@06) (<= 0 i0@153@06))))
(pop) ; 16
(pop) ; 15
; Joined path conditions
(assert (implies
  (and (< i0@153@06 V@27@06) (<= 0 i0@153@06))
  (and
    (< i0@153@06 V@27@06)
    (<= 0 i0@153@06)
    (not (= res@148@06 (as None<option<array>>  option<array>)))
    (< i0@153@06 (alen<Int> (opt_get1 $Snap.unit res@148@06)))
    ($FVF.loc_int ($FVF.lookup_int (as sm@152@06  $FVF<Int>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@148@06) i0@153@06)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@148@06) i0@153@06)))))
; Joined path conditions
; Definitional axioms for snapshot map values
(pop) ; 14
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i0@153@06 Int)) (!
  (implies
    (and (< i0@153@06 V@27@06) (<= 0 i0@153@06))
    (and
      (< i0@153@06 V@27@06)
      (<= 0 i0@153@06)
      (not (= res@148@06 (as None<option<array>>  option<array>)))
      (< i0@153@06 (alen<Int> (opt_get1 $Snap.unit res@148@06)))
      ($FVF.loc_int ($FVF.lookup_int (as sm@152@06  $FVF<Int>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit res@148@06) i0@153@06)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit res@148@06) i0@153@06))))
  :pattern (($FVF.loc_int ($FVF.lookup_int (as sm@152@06  $FVF<Int>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit res@148@06) i0@153@06)) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit res@148@06) i0@153@06)))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 13
(pop) ; 12
; Joined path conditions
(assert (implies
  (= exc@147@06 $Ref.null)
  (forall ((i0@153@06 Int)) (!
    (implies
      (and (< i0@153@06 V@27@06) (<= 0 i0@153@06))
      (and
        (< i0@153@06 V@27@06)
        (<= 0 i0@153@06)
        (not (= res@148@06 (as None<option<array>>  option<array>)))
        (< i0@153@06 (alen<Int> (opt_get1 $Snap.unit res@148@06)))
        ($FVF.loc_int ($FVF.lookup_int (as sm@152@06  $FVF<Int>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@148@06) i0@153@06)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@148@06) i0@153@06))))
    :pattern (($FVF.loc_int ($FVF.lookup_int (as sm@152@06  $FVF<Int>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@148@06) i0@153@06)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@148@06) i0@153@06)))
    :qid |prog.l<no position>-aux|))))
(assert (implies
  (= exc@147@06 $Ref.null)
  (forall ((i0@153@06 Int)) (!
    (implies
      (and (< i0@153@06 V@27@06) (<= 0 i0@153@06))
      (=
        ($FVF.lookup_int (as sm@152@06  $FVF<Int>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@148@06) i0@153@06))
        0))
    :pattern (($FVF.loc_int ($FVF.lookup_int (as sm@152@06  $FVF<Int>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@148@06) i0@153@06)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@148@06) i0@153@06)))
    :qid |prog.l<no position>|))))
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
; [eval] exc != null
; [then-branch: 151 | exc@147@06 != Null | dead]
; [else-branch: 151 | exc@147@06 == Null | live]
(push) ; 12
; [else-branch: 151 | exc@147@06 == Null]
(pop) ; 12
; [eval] !(exc != null)
; [eval] exc != null
(set-option :timeout 10)
(push) ; 12
(assert (not (not (= exc@147@06 $Ref.null))))
(check-sat)
; unknown
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               16149
;  :arith-add-rows          11310
;  :arith-assert-diseq      1053
;  :arith-assert-lower      4551
;  :arith-assert-upper      2936
;  :arith-bound-prop        1563
;  :arith-conflicts         341
;  :arith-eq-adapter        3181
;  :arith-fixed-eqs         1481
;  :arith-offset-eqs        1727
;  :arith-pivots            2754
;  :conflicts               815
;  :datatype-accessor-ax    69
;  :datatype-constructor-ax 429
;  :datatype-occurs-check   261
;  :datatype-splits         224
;  :decisions               1915
;  :del-clause              22794
;  :final-checks            135
;  :interface-eqs           6
;  :max-generation          8
;  :max-memory              7.70
;  :memory                  7.65
;  :minimized-lits          63
;  :mk-bool-var             32304
;  :mk-clause               22798
;  :num-allocs              346566
;  :num-checks              228
;  :propagations            10076
;  :quant-instantiations    7357
;  :rlimit-count            903969)
; [then-branch: 152 | exc@147@06 == Null | live]
; [else-branch: 152 | exc@147@06 != Null | dead]
(push) ; 12
; [then-branch: 152 | exc@147@06 == Null]
; [exec]
; p := res3
; [exec]
; exc, res4 := initializeWithZeros(this, tid, p, V)
; [eval] this != null
; [eval] p != (None(): option[array])
; [eval] (None(): option[array])
(set-option :timeout 0)
(push) ; 13
(assert (not (not (= res@148@06 (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               16149
;  :arith-add-rows          11310
;  :arith-assert-diseq      1053
;  :arith-assert-lower      4551
;  :arith-assert-upper      2936
;  :arith-bound-prop        1563
;  :arith-conflicts         341
;  :arith-eq-adapter        3181
;  :arith-fixed-eqs         1481
;  :arith-offset-eqs        1727
;  :arith-pivots            2754
;  :conflicts               815
;  :datatype-accessor-ax    69
;  :datatype-constructor-ax 429
;  :datatype-occurs-check   261
;  :datatype-splits         224
;  :decisions               1915
;  :del-clause              22794
;  :final-checks            135
;  :interface-eqs           6
;  :max-generation          8
;  :max-memory              7.70
;  :memory                  7.65
;  :minimized-lits          63
;  :mk-bool-var             32304
;  :mk-clause               22798
;  :num-allocs              346590
;  :num-checks              229
;  :propagations            10076
;  :quant-instantiations    7357
;  :rlimit-count            903985)
(assert (not (= res@148@06 (as None<option<array>>  option<array>))))
; [eval] alen(opt_get1(p)) == V
; [eval] alen(opt_get1(p))
; [eval] opt_get1(p)
(push) ; 13
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 13
; Joined path conditions
(push) ; 13
(assert (not (= (alen<Int> (opt_get1 $Snap.unit res@148@06)) V@27@06)))
(check-sat)
; unsat
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               16149
;  :arith-add-rows          11310
;  :arith-assert-diseq      1053
;  :arith-assert-lower      4551
;  :arith-assert-upper      2936
;  :arith-bound-prop        1563
;  :arith-conflicts         341
;  :arith-eq-adapter        3181
;  :arith-fixed-eqs         1481
;  :arith-offset-eqs        1727
;  :arith-pivots            2754
;  :conflicts               815
;  :datatype-accessor-ax    69
;  :datatype-constructor-ax 429
;  :datatype-occurs-check   261
;  :datatype-splits         224
;  :decisions               1915
;  :del-clause              22794
;  :final-checks            135
;  :interface-eqs           6
;  :max-generation          8
;  :max-memory              7.70
;  :memory                  7.65
;  :minimized-lits          63
;  :mk-bool-var             32304
;  :mk-clause               22798
;  :num-allocs              346606
;  :num-checks              230
;  :propagations            10076
;  :quant-instantiations    7357
;  :rlimit-count            904004)
(assert (= (alen<Int> (opt_get1 $Snap.unit res@148@06)) V@27@06))
(declare-const k@154@06 Int)
(push) ; 13
; [eval] 0 <= k && k < V
; [eval] 0 <= k
(push) ; 14
; [then-branch: 153 | 0 <= k@154@06 | live]
; [else-branch: 153 | !(0 <= k@154@06) | live]
(push) ; 15
; [then-branch: 153 | 0 <= k@154@06]
(assert (<= 0 k@154@06))
; [eval] k < V
(pop) ; 15
(push) ; 15
; [else-branch: 153 | !(0 <= k@154@06)]
(assert (not (<= 0 k@154@06)))
(pop) ; 15
(pop) ; 14
; Joined path conditions
; Joined path conditions
(assert (and (< k@154@06 V@27@06) (<= 0 k@154@06)))
; [eval] aloc(opt_get1(p), k)
; [eval] opt_get1(p)
(push) ; 14
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 14
; Joined path conditions
(push) ; 14
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 15
(assert (not (< k@154@06 (alen<Int> (opt_get1 $Snap.unit res@148@06)))))
(check-sat)
; unsat
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               16149
;  :arith-add-rows          11311
;  :arith-assert-diseq      1053
;  :arith-assert-lower      4553
;  :arith-assert-upper      2936
;  :arith-bound-prop        1563
;  :arith-conflicts         341
;  :arith-eq-adapter        3181
;  :arith-fixed-eqs         1481
;  :arith-offset-eqs        1727
;  :arith-pivots            2754
;  :conflicts               815
;  :datatype-accessor-ax    69
;  :datatype-constructor-ax 429
;  :datatype-occurs-check   261
;  :datatype-splits         224
;  :decisions               1915
;  :del-clause              22794
;  :final-checks            135
;  :interface-eqs           6
;  :max-generation          8
;  :max-memory              7.70
;  :memory                  7.65
;  :minimized-lits          63
;  :mk-bool-var             32306
;  :mk-clause               22798
;  :num-allocs              346703
;  :num-checks              231
;  :propagations            10076
;  :quant-instantiations    7357
;  :rlimit-count            904188)
(assert (< k@154@06 (alen<Int> (opt_get1 $Snap.unit res@148@06))))
(pop) ; 14
; Joined path conditions
(assert (< k@154@06 (alen<Int> (opt_get1 $Snap.unit res@148@06))))
(pop) ; 13
(declare-fun inv@155@06 ($Ref) Int)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(assert (forall ((k@154@06 Int)) (!
  (< k@154@06 (alen<Int> (opt_get1 $Snap.unit res@148@06)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@148@06) k@154@06))
  :qid |int-aux|)))
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 13
(assert (not (forall ((k1@154@06 Int) (k2@154@06 Int)) (!
  (implies
    (and
      (and
        (and (< k1@154@06 V@27@06) (<= 0 k1@154@06))
        ($FVF.loc_int ($FVF.lookup_int (as sm@152@06  $FVF<Int>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@148@06) k1@154@06)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@148@06) k1@154@06)))
      (and
        (and (< k2@154@06 V@27@06) (<= 0 k2@154@06))
        ($FVF.loc_int ($FVF.lookup_int (as sm@152@06  $FVF<Int>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@148@06) k2@154@06)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@148@06) k2@154@06)))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@148@06) k1@154@06)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@148@06) k2@154@06)))
    (= k1@154@06 k2@154@06))
  
  :qid |int-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               16165
;  :arith-add-rows          11320
;  :arith-assert-diseq      1054
;  :arith-assert-lower      4557
;  :arith-assert-upper      2936
;  :arith-bound-prop        1563
;  :arith-conflicts         341
;  :arith-eq-adapter        3183
;  :arith-fixed-eqs         1481
;  :arith-offset-eqs        1727
;  :arith-pivots            2754
;  :conflicts               816
;  :datatype-accessor-ax    69
;  :datatype-constructor-ax 429
;  :datatype-occurs-check   261
;  :datatype-splits         224
;  :decisions               1915
;  :del-clause              22822
;  :final-checks            135
;  :interface-eqs           6
;  :max-generation          8
;  :max-memory              8.28
;  :memory                  7.96
;  :minimized-lits          63
;  :mk-bool-var             32363
;  :mk-clause               22826
;  :num-allocs              347355
;  :num-checks              232
;  :propagations            10081
;  :quant-instantiations    7386
;  :rlimit-count            905807
;  :time                    0.00)
; Definitional axioms for inverse functions
(assert (forall ((k@154@06 Int)) (!
  (implies
    (and (< k@154@06 V@27@06) (<= 0 k@154@06))
    (=
      (inv@155@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@148@06) k@154@06))
      k@154@06))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@148@06) k@154@06))
  :qid |int-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@155@06 r) V@27@06) (<= 0 (inv@155@06 r)))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@148@06) (inv@155@06 r))
      r))
  :pattern ((inv@155@06 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@155@06 r) V@27@06) (<= 0 (inv@155@06 r)))
    ($FVF.loc_int ($FVF.lookup_int (as sm@152@06  $FVF<Int>) r) r))
  :pattern ((inv@155@06 r))
  )))
; Precomputing data for removing quantified permissions
(define-fun pTaken@156@06 ((r $Ref)) $Perm
  (ite
    (and (< (inv@155@06 r) V@27@06) (<= 0 (inv@155@06 r)))
    ($Perm.min
      (ite
        (and (< (inv@151@06 r) V@27@06) (<= 0 (inv@151@06 r)))
        $Perm.Write
        $Perm.No)
      $Perm.Write)
    $Perm.No))
(define-fun pTaken@157@06 ((r $Ref)) $Perm
  (ite
    (and (< (inv@155@06 r) V@27@06) (<= 0 (inv@155@06 r)))
    ($Perm.min
      (ite
        (and
          (and
            (and (< (inv@143@06 r) V@27@06) (<= 0 (inv@143@06 r)))
            (< (inv@142@06 r) V@27@06))
          (<= 0 (inv@142@06 r)))
        $Perm.Write
        $Perm.No)
      (- $Perm.Write (pTaken@156@06 r)))
    $Perm.No))
(define-fun pTaken@158@06 ((r $Ref)) $Perm
  (ite
    (and (< (inv@155@06 r) V@27@06) (<= 0 (inv@155@06 r)))
    ($Perm.min
      (ite
        (and
          (and
            (and (< (inv@138@06 r) V@27@06) (<= 0 (inv@138@06 r)))
            (< (inv@137@06 r) V@27@06))
          (<= 0 (inv@137@06 r)))
        $Perm.Write
        $Perm.No)
      (- (- $Perm.Write (pTaken@156@06 r)) (pTaken@157@06 r)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 500)
(push) ; 13
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and (< (inv@151@06 r) V@27@06) (<= 0 (inv@151@06 r)))
        $Perm.Write
        $Perm.No)
      (pTaken@156@06 r))
    $Perm.No)
  
  ))))
(check-sat)
; unsat
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               16292
;  :arith-add-rows          11345
;  :arith-assert-diseq      1062
;  :arith-assert-lower      4580
;  :arith-assert-upper      2946
;  :arith-bound-prop        1565
;  :arith-conflicts         344
;  :arith-eq-adapter        3200
;  :arith-fixed-eqs         1484
;  :arith-offset-eqs        1727
;  :arith-pivots            2765
;  :conflicts               824
;  :datatype-accessor-ax    69
;  :datatype-constructor-ax 440
;  :datatype-occurs-check   268
;  :datatype-splits         231
;  :decisions               1931
;  :del-clause              22953
;  :final-checks            137
;  :interface-eqs           6
;  :max-generation          8
;  :max-memory              8.28
;  :memory                  7.96
;  :minimized-lits          63
;  :mk-bool-var             32578
;  :mk-clause               22957
;  :num-allocs              349577
;  :num-checks              234
;  :propagations            10128
;  :quant-instantiations    7455
;  :rlimit-count            910108
;  :time                    0.00)
; Intermediate check if already taken enough permissions
(push) ; 13
(assert (not (forall ((r $Ref)) (!
  (implies
    (and (< (inv@155@06 r) V@27@06) (<= 0 (inv@155@06 r)))
    (= (- $Perm.Write (pTaken@156@06 r)) $Perm.No))
  
  ))))
(check-sat)
; unsat
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               16314
;  :arith-add-rows          11358
;  :arith-assert-diseq      1064
;  :arith-assert-lower      4584
;  :arith-assert-upper      2951
;  :arith-bound-prop        1566
;  :arith-conflicts         345
;  :arith-eq-adapter        3203
;  :arith-fixed-eqs         1485
;  :arith-offset-eqs        1727
;  :arith-pivots            2769
;  :conflicts               825
;  :datatype-accessor-ax    69
;  :datatype-constructor-ax 440
;  :datatype-occurs-check   268
;  :datatype-splits         231
;  :decisions               1931
;  :del-clause              23004
;  :final-checks            137
;  :interface-eqs           6
;  :max-generation          8
;  :max-memory              8.28
;  :memory                  7.96
;  :minimized-lits          63
;  :mk-bool-var             32663
;  :mk-clause               23008
;  :num-allocs              350088
;  :num-checks              235
;  :propagations            10137
;  :quant-instantiations    7483
;  :rlimit-count            911829)
; Final check if taken enough permissions
; Done removing quantified permissions
; Definitional axioms for snapshot map values
(declare-const exc@159@06 $Ref)
(declare-const res@160@06 void)
(declare-const $t@161@06 $Snap)
(assert (= $t@161@06 ($Snap.combine ($Snap.first $t@161@06) ($Snap.second $t@161@06))))
(assert (= ($Snap.first $t@161@06) $Snap.unit))
; [eval] exc == null
(assert (= exc@159@06 $Ref.null))
(assert (=
  ($Snap.second $t@161@06)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@161@06))
    ($Snap.second ($Snap.second $t@161@06)))))
(assert (= ($Snap.first ($Snap.second $t@161@06)) $Snap.unit))
; [eval] exc == null ==> p != (None(): option[array])
; [eval] exc == null
(push) ; 13
(set-option :timeout 10)
(push) ; 14
(assert (not (not (= exc@159@06 $Ref.null))))
(check-sat)
; unknown
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               16380
;  :arith-add-rows          11358
;  :arith-assert-diseq      1064
;  :arith-assert-lower      4584
;  :arith-assert-upper      2951
;  :arith-bound-prop        1566
;  :arith-conflicts         345
;  :arith-eq-adapter        3203
;  :arith-fixed-eqs         1485
;  :arith-offset-eqs        1727
;  :arith-pivots            2769
;  :conflicts               825
;  :datatype-accessor-ax    71
;  :datatype-constructor-ax 450
;  :datatype-occurs-check   276
;  :datatype-splits         239
;  :decisions               1941
;  :del-clause              23004
;  :final-checks            139
;  :interface-eqs           6
;  :max-generation          8
;  :max-memory              8.28
;  :memory                  7.97
;  :minimized-lits          63
;  :mk-bool-var             32676
;  :mk-clause               23008
;  :num-allocs              350911
;  :num-checks              236
;  :propagations            10137
;  :quant-instantiations    7483
;  :rlimit-count            912859)
; [then-branch: 154 | exc@159@06 == Null | live]
; [else-branch: 154 | exc@159@06 != Null | dead]
(push) ; 14
; [then-branch: 154 | exc@159@06 == Null]
; [eval] p != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 14
(pop) ; 13
; Joined path conditions
(assert (implies
  (= exc@159@06 $Ref.null)
  (not (= res@148@06 (as None<option<array>>  option<array>)))))
(assert (=
  ($Snap.second ($Snap.second $t@161@06))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second $t@161@06)))
    ($Snap.second ($Snap.second ($Snap.second $t@161@06))))))
(assert (= ($Snap.first ($Snap.second ($Snap.second $t@161@06))) $Snap.unit))
; [eval] exc == null ==> alen(opt_get1(p)) == V
; [eval] exc == null
(push) ; 13
(push) ; 14
(assert (not (not (= exc@159@06 $Ref.null))))
(check-sat)
; unknown
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               16440
;  :arith-add-rows          11358
;  :arith-assert-diseq      1064
;  :arith-assert-lower      4584
;  :arith-assert-upper      2951
;  :arith-bound-prop        1566
;  :arith-conflicts         345
;  :arith-eq-adapter        3203
;  :arith-fixed-eqs         1485
;  :arith-offset-eqs        1727
;  :arith-pivots            2769
;  :conflicts               825
;  :datatype-accessor-ax    72
;  :datatype-constructor-ax 460
;  :datatype-occurs-check   284
;  :datatype-splits         247
;  :decisions               1951
;  :del-clause              23004
;  :final-checks            141
;  :interface-eqs           6
;  :max-generation          8
;  :max-memory              8.28
;  :memory                  7.97
;  :minimized-lits          63
;  :mk-bool-var             32686
;  :mk-clause               23008
;  :num-allocs              351678
;  :num-checks              237
;  :propagations            10137
;  :quant-instantiations    7483
;  :rlimit-count            913769)
; [then-branch: 155 | exc@159@06 == Null | live]
; [else-branch: 155 | exc@159@06 != Null | dead]
(push) ; 14
; [then-branch: 155 | exc@159@06 == Null]
; [eval] alen(opt_get1(p)) == V
; [eval] alen(opt_get1(p))
; [eval] opt_get1(p)
(push) ; 15
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 15
; Joined path conditions
(pop) ; 14
(pop) ; 13
; Joined path conditions
(assert (implies
  (= exc@159@06 $Ref.null)
  (= (alen<Int> (opt_get1 $Snap.unit res@148@06)) V@27@06)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second $t@161@06)))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@161@06))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@161@06)))))))
; [eval] exc == null
(push) ; 13
(assert (not (not (= exc@159@06 $Ref.null))))
(check-sat)
; unknown
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               16502
;  :arith-add-rows          11358
;  :arith-assert-diseq      1064
;  :arith-assert-lower      4584
;  :arith-assert-upper      2951
;  :arith-bound-prop        1566
;  :arith-conflicts         345
;  :arith-eq-adapter        3203
;  :arith-fixed-eqs         1485
;  :arith-offset-eqs        1727
;  :arith-pivots            2769
;  :conflicts               825
;  :datatype-accessor-ax    73
;  :datatype-constructor-ax 471
;  :datatype-occurs-check   292
;  :datatype-splits         256
;  :decisions               1962
;  :del-clause              23004
;  :final-checks            143
;  :interface-eqs           6
;  :max-generation          8
;  :max-memory              8.28
;  :memory                  7.97
;  :minimized-lits          63
;  :mk-bool-var             32696
;  :mk-clause               23008
;  :num-allocs              352437
;  :num-checks              238
;  :propagations            10137
;  :quant-instantiations    7483
;  :rlimit-count            914671)
; [then-branch: 156 | exc@159@06 == Null | live]
; [else-branch: 156 | exc@159@06 != Null | dead]
(push) ; 13
; [then-branch: 156 | exc@159@06 == Null]
(declare-const k@162@06 Int)
(push) ; 14
; [eval] 0 <= k && k < V
; [eval] 0 <= k
(push) ; 15
; [then-branch: 157 | 0 <= k@162@06 | live]
; [else-branch: 157 | !(0 <= k@162@06) | live]
(push) ; 16
; [then-branch: 157 | 0 <= k@162@06]
(assert (<= 0 k@162@06))
; [eval] k < V
(pop) ; 16
(push) ; 16
; [else-branch: 157 | !(0 <= k@162@06)]
(assert (not (<= 0 k@162@06)))
(pop) ; 16
(pop) ; 15
; Joined path conditions
; Joined path conditions
(assert (and (< k@162@06 V@27@06) (<= 0 k@162@06)))
; [eval] aloc(opt_get1(p), k)
; [eval] opt_get1(p)
(push) ; 15
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 15
; Joined path conditions
(push) ; 15
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 16
(assert (not (< k@162@06 (alen<Int> (opt_get1 $Snap.unit res@148@06)))))
(check-sat)
; unsat
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               16502
;  :arith-add-rows          11359
;  :arith-assert-diseq      1064
;  :arith-assert-lower      4586
;  :arith-assert-upper      2951
;  :arith-bound-prop        1566
;  :arith-conflicts         345
;  :arith-eq-adapter        3203
;  :arith-fixed-eqs         1485
;  :arith-offset-eqs        1727
;  :arith-pivots            2769
;  :conflicts               825
;  :datatype-accessor-ax    73
;  :datatype-constructor-ax 471
;  :datatype-occurs-check   292
;  :datatype-splits         256
;  :decisions               1962
;  :del-clause              23004
;  :final-checks            143
;  :interface-eqs           6
;  :max-generation          8
;  :max-memory              8.28
;  :memory                  7.97
;  :minimized-lits          63
;  :mk-bool-var             32698
;  :mk-clause               23008
;  :num-allocs              352540
;  :num-checks              239
;  :propagations            10137
;  :quant-instantiations    7483
;  :rlimit-count            914857)
(assert (< k@162@06 (alen<Int> (opt_get1 $Snap.unit res@148@06))))
(pop) ; 15
; Joined path conditions
(assert (< k@162@06 (alen<Int> (opt_get1 $Snap.unit res@148@06))))
(pop) ; 14
(declare-fun inv@163@06 ($Ref) Int)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(assert (forall ((k@162@06 Int)) (!
  (< k@162@06 (alen<Int> (opt_get1 $Snap.unit res@148@06)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@148@06) k@162@06))
  :qid |int-aux|)))
; Check receiver injectivity
(push) ; 14
(assert (not (forall ((k1@162@06 Int) (k2@162@06 Int)) (!
  (implies
    (and
      (and (< k1@162@06 V@27@06) (<= 0 k1@162@06))
      (and (< k2@162@06 V@27@06) (<= 0 k2@162@06))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@148@06) k1@162@06)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@148@06) k2@162@06)))
    (= k1@162@06 k2@162@06))
  
  :qid |int-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               16508
;  :arith-add-rows          11363
;  :arith-assert-diseq      1065
;  :arith-assert-lower      4590
;  :arith-assert-upper      2951
;  :arith-bound-prop        1566
;  :arith-conflicts         345
;  :arith-eq-adapter        3204
;  :arith-fixed-eqs         1485
;  :arith-offset-eqs        1727
;  :arith-pivots            2769
;  :conflicts               826
;  :datatype-accessor-ax    73
;  :datatype-constructor-ax 471
;  :datatype-occurs-check   292
;  :datatype-splits         256
;  :decisions               1962
;  :del-clause              23010
;  :final-checks            143
;  :interface-eqs           6
;  :max-generation          8
;  :max-memory              8.28
;  :memory                  7.97
;  :minimized-lits          63
;  :mk-bool-var             32715
;  :mk-clause               23014
;  :num-allocs              353030
;  :num-checks              240
;  :propagations            10137
;  :quant-instantiations    7493
;  :rlimit-count            915680)
; Definitional axioms for inverse functions
(assert (forall ((k@162@06 Int)) (!
  (implies
    (and (< k@162@06 V@27@06) (<= 0 k@162@06))
    (=
      (inv@163@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@148@06) k@162@06))
      k@162@06))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@148@06) k@162@06))
  )))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@163@06 r) V@27@06) (<= 0 (inv@163@06 r)))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@148@06) (inv@163@06 r))
      r))
  :pattern ((inv@163@06 r))
  :qid |int-fctOfInv|)))
; Permissions are non-negative
; Field permissions are at most one
; Permission implies non-null receiver
(assert (forall ((k@162@06 Int)) (!
  (implies
    (and (< k@162@06 V@27@06) (<= 0 k@162@06))
    (not
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@148@06) k@162@06)
        $Ref.null)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@148@06) k@162@06))
  :qid |int-permImpliesNonNull|)))
(declare-const sm@164@06 $FVF<Int>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@163@06 r) V@27@06) (<= 0 (inv@163@06 r)))
    (=
      ($FVF.lookup_int (as sm@164@06  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@161@06))))) r)))
  :pattern (($FVF.lookup_int (as sm@164@06  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@161@06))))) r))
  :qid |qp.fvfValDef45|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@138@06 r) V@27@06) (<= 0 (inv@138@06 r)))
        (< (inv@137@06 r) V@27@06))
      (<= 0 (inv@137@06 r)))
    (=
      ($FVF.lookup_int (as sm@164@06  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@118@06))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@164@06  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@118@06))))))))))))))) r))
  :qid |qp.fvfValDef46|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@143@06 r) V@27@06) (<= 0 (inv@143@06 r)))
        (< (inv@142@06 r) V@27@06))
      (<= 0 (inv@142@06 r)))
    (=
      ($FVF.lookup_int (as sm@164@06  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@118@06)))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@164@06  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@118@06)))))))))))))))) r))
  :qid |qp.fvfValDef47|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@161@06))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@118@06))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@118@06)))))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@164@06  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef48|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@163@06 r) V@27@06) (<= 0 (inv@163@06 r)))
    ($FVF.loc_int ($FVF.lookup_int (as sm@164@06  $FVF<Int>) r) r))
  :pattern ((inv@163@06 r))
  )))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@161@06))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@161@06)))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@161@06))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@161@06)))))
  $Snap.unit))
; [eval] exc == null ==> valid_graph_vertices(this, p, V)
; [eval] exc == null
(push) ; 14
(set-option :timeout 10)
(push) ; 15
(assert (not (not (= exc@159@06 $Ref.null))))
(check-sat)
; unknown
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               16573
;  :arith-add-rows          11363
;  :arith-assert-diseq      1065
;  :arith-assert-lower      4590
;  :arith-assert-upper      2951
;  :arith-bound-prop        1566
;  :arith-conflicts         345
;  :arith-eq-adapter        3204
;  :arith-fixed-eqs         1485
;  :arith-offset-eqs        1727
;  :arith-pivots            2769
;  :conflicts               826
;  :datatype-accessor-ax    74
;  :datatype-constructor-ax 482
;  :datatype-occurs-check   300
;  :datatype-splits         265
;  :decisions               1973
;  :del-clause              23010
;  :final-checks            145
;  :interface-eqs           6
;  :max-generation          8
;  :max-memory              8.28
;  :memory                  7.98
;  :minimized-lits          63
;  :mk-bool-var             32734
;  :mk-clause               23014
;  :num-allocs              355039
;  :num-checks              241
;  :propagations            10137
;  :quant-instantiations    7493
;  :rlimit-count            920352)
; [then-branch: 158 | exc@159@06 == Null | live]
; [else-branch: 158 | exc@159@06 != Null | dead]
(push) ; 15
; [then-branch: 158 | exc@159@06 == Null]
; [eval] valid_graph_vertices(this, p, V)
(push) ; 16
; [eval] this != null
; [eval] p != (None(): option[array])
; [eval] (None(): option[array])
; [eval] alen(opt_get1(p)) == V
; [eval] alen(opt_get1(p))
; [eval] opt_get1(p)
(push) ; 17
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 17
; Joined path conditions
(declare-const i1@165@06 Int)
(push) ; 17
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 18
; [then-branch: 159 | 0 <= i1@165@06 | live]
; [else-branch: 159 | !(0 <= i1@165@06) | live]
(push) ; 19
; [then-branch: 159 | 0 <= i1@165@06]
(assert (<= 0 i1@165@06))
; [eval] i1 < V
(pop) ; 19
(push) ; 19
; [else-branch: 159 | !(0 <= i1@165@06)]
(assert (not (<= 0 i1@165@06)))
(pop) ; 19
(pop) ; 18
; Joined path conditions
; Joined path conditions
(assert (and (< i1@165@06 V@27@06) (<= 0 i1@165@06)))
(declare-const $k@166@06 $Perm)
(assert ($Perm.isReadVar $k@166@06 $Perm.Write))
; [eval] aloc(opt_get1(p), i1)
; [eval] opt_get1(p)
(push) ; 18
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 18
; Joined path conditions
(push) ; 18
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 19
(assert (not (< i1@165@06 (alen<Int> (opt_get1 $Snap.unit res@148@06)))))
(check-sat)
; unsat
(pop) ; 19
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               16573
;  :arith-add-rows          11364
;  :arith-assert-diseq      1066
;  :arith-assert-lower      4594
;  :arith-assert-upper      2952
;  :arith-bound-prop        1566
;  :arith-conflicts         345
;  :arith-eq-adapter        3205
;  :arith-fixed-eqs         1485
;  :arith-offset-eqs        1727
;  :arith-pivots            2769
;  :conflicts               826
;  :datatype-accessor-ax    74
;  :datatype-constructor-ax 482
;  :datatype-occurs-check   300
;  :datatype-splits         265
;  :decisions               1973
;  :del-clause              23010
;  :final-checks            145
;  :interface-eqs           6
;  :max-generation          8
;  :max-memory              8.28
;  :memory                  7.98
;  :minimized-lits          63
;  :mk-bool-var             32740
;  :mk-clause               23016
;  :num-allocs              355209
;  :num-checks              242
;  :propagations            10138
;  :quant-instantiations    7493
;  :rlimit-count            920688)
(assert (< i1@165@06 (alen<Int> (opt_get1 $Snap.unit res@148@06))))
(pop) ; 18
; Joined path conditions
(assert (< i1@165@06 (alen<Int> (opt_get1 $Snap.unit res@148@06))))
(pop) ; 17
(declare-fun inv@167@06 ($Ref) Int)
; Nested auxiliary terms: globals
(assert ($Perm.isReadVar $k@166@06 $Perm.Write))
; Nested auxiliary terms: non-globals
(assert (forall ((i1@165@06 Int)) (!
  (< i1@165@06 (alen<Int> (opt_get1 $Snap.unit res@148@06)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@148@06) i1@165@06))
  :qid |int-aux|)))
(push) ; 17
(assert (not (forall ((i1@165@06 Int)) (!
  (implies
    (and (< i1@165@06 V@27@06) (<= 0 i1@165@06))
    (or (= $k@166@06 $Perm.No) (< $Perm.No $k@166@06)))
  
  ))))
(check-sat)
; unsat
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               16573
;  :arith-add-rows          11365
;  :arith-assert-diseq      1067
;  :arith-assert-lower      4596
;  :arith-assert-upper      2953
;  :arith-bound-prop        1566
;  :arith-conflicts         345
;  :arith-eq-adapter        3206
;  :arith-fixed-eqs         1485
;  :arith-offset-eqs        1727
;  :arith-pivots            2769
;  :conflicts               827
;  :datatype-accessor-ax    74
;  :datatype-constructor-ax 482
;  :datatype-occurs-check   300
;  :datatype-splits         265
;  :decisions               1973
;  :del-clause              23012
;  :final-checks            145
;  :interface-eqs           6
;  :max-generation          8
;  :max-memory              8.28
;  :memory                  7.98
;  :minimized-lits          63
;  :mk-bool-var             32747
;  :mk-clause               23018
;  :num-allocs              355637
;  :num-checks              243
;  :propagations            10139
;  :quant-instantiations    7493
;  :rlimit-count            921234)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 17
(assert (not (forall ((i11@165@06 Int) (i12@165@06 Int)) (!
  (implies
    (and
      (and
        (and
          (and (< i11@165@06 V@27@06) (<= 0 i11@165@06))
          ($FVF.loc_int ($FVF.lookup_int (as sm@164@06  $FVF<Int>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit res@148@06) i11@165@06)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit res@148@06) i11@165@06)))
        (< $Perm.No $k@166@06))
      (and
        (and
          (and (< i12@165@06 V@27@06) (<= 0 i12@165@06))
          ($FVF.loc_int ($FVF.lookup_int (as sm@164@06  $FVF<Int>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit res@148@06) i12@165@06)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit res@148@06) i12@165@06)))
        (< $Perm.No $k@166@06))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@148@06) i11@165@06)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@148@06) i12@165@06)))
    (= i11@165@06 i12@165@06))
  
  :qid |int-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               16583
;  :arith-add-rows          11374
;  :arith-assert-diseq      1068
;  :arith-assert-lower      4600
;  :arith-assert-upper      2953
;  :arith-bound-prop        1566
;  :arith-conflicts         345
;  :arith-eq-adapter        3207
;  :arith-fixed-eqs         1485
;  :arith-offset-eqs        1727
;  :arith-pivots            2769
;  :conflicts               828
;  :datatype-accessor-ax    74
;  :datatype-constructor-ax 482
;  :datatype-occurs-check   300
;  :datatype-splits         265
;  :decisions               1973
;  :del-clause              23025
;  :final-checks            145
;  :interface-eqs           6
;  :max-generation          8
;  :max-memory              8.28
;  :memory                  7.97
;  :minimized-lits          63
;  :mk-bool-var             32785
;  :mk-clause               23031
;  :num-allocs              356079
;  :num-checks              244
;  :propagations            10142
;  :quant-instantiations    7512
;  :rlimit-count            922343)
; Definitional axioms for inverse functions
(assert (forall ((i1@165@06 Int)) (!
  (implies
    (and (and (< i1@165@06 V@27@06) (<= 0 i1@165@06)) (< $Perm.No $k@166@06))
    (=
      (inv@167@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@148@06) i1@165@06))
      i1@165@06))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@148@06) i1@165@06))
  :qid |int-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and (< (inv@167@06 r) V@27@06) (<= 0 (inv@167@06 r)))
      (< $Perm.No $k@166@06))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@148@06) (inv@167@06 r))
      r))
  :pattern ((inv@167@06 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@167@06 r) V@27@06) (<= 0 (inv@167@06 r)))
    ($FVF.loc_int ($FVF.lookup_int (as sm@164@06  $FVF<Int>) r) r))
  :pattern ((inv@167@06 r))
  )))
; Precomputing data for removing quantified permissions
(define-fun pTaken@168@06 ((r $Ref)) $Perm
  (ite
    (and (< (inv@167@06 r) V@27@06) (<= 0 (inv@167@06 r)))
    ($Perm.min
      (ite
        (and (< (inv@163@06 r) V@27@06) (<= 0 (inv@163@06 r)))
        $Perm.Write
        $Perm.No)
      $k@166@06)
    $Perm.No))
(define-fun pTaken@169@06 ((r $Ref)) $Perm
  (ite
    (and (< (inv@167@06 r) V@27@06) (<= 0 (inv@167@06 r)))
    ($Perm.min
      (ite
        (and
          (and
            (and (< (inv@138@06 r) V@27@06) (<= 0 (inv@138@06 r)))
            (< (inv@137@06 r) V@27@06))
          (<= 0 (inv@137@06 r)))
        $Perm.Write
        $Perm.No)
      (- $k@166@06 (pTaken@168@06 r)))
    $Perm.No))
(define-fun pTaken@170@06 ((r $Ref)) $Perm
  (ite
    (and (< (inv@167@06 r) V@27@06) (<= 0 (inv@167@06 r)))
    ($Perm.min
      (ite
        (and
          (and
            (and (< (inv@143@06 r) V@27@06) (<= 0 (inv@143@06 r)))
            (< (inv@142@06 r) V@27@06))
          (<= 0 (inv@142@06 r)))
        $Perm.Write
        $Perm.No)
      (- (- $k@166@06 (pTaken@168@06 r)) (pTaken@169@06 r)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Constrain original permissions $k@166@06
(assert (forall ((r $Ref)) (!
  (implies
    (not
      (=
        (ite
          (and (< (inv@163@06 r) V@27@06) (<= 0 (inv@163@06 r)))
          $Perm.Write
          $Perm.No)
        $Perm.No))
    (ite
      (and (< (inv@163@06 r) V@27@06) (<= 0 (inv@163@06 r)))
      (<
        (ite
          (and (< (inv@167@06 r) V@27@06) (<= 0 (inv@167@06 r)))
          $k@166@06
          $Perm.No)
        $Perm.Write)
      (<
        (ite
          (and (< (inv@167@06 r) V@27@06) (<= 0 (inv@167@06 r)))
          $k@166@06
          $Perm.No)
        $Perm.No)))
  :pattern ((inv@163@06 r))
  :pattern ((inv@167@06 r))
  :qid |qp.srp49|)))
; Intermediate check if already taken enough permissions
(set-option :timeout 500)
(push) ; 17
(assert (not (forall ((r $Ref)) (!
  (implies
    (and (< (inv@167@06 r) V@27@06) (<= 0 (inv@167@06 r)))
    (= (- $k@166@06 (pTaken@168@06 r)) $Perm.No))
  
  ))))
(check-sat)
; unsat
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               16704
;  :arith-add-rows          11403
;  :arith-assert-diseq      1072
;  :arith-assert-lower      4614
;  :arith-assert-upper      2961
;  :arith-bound-prop        1571
;  :arith-conflicts         347
;  :arith-eq-adapter        3221
;  :arith-fixed-eqs         1488
;  :arith-offset-eqs        1731
;  :arith-pivots            2781
;  :conflicts               835
;  :datatype-accessor-ax    74
;  :datatype-constructor-ax 495
;  :datatype-occurs-check   308
;  :datatype-splits         274
;  :decisions               1990
;  :del-clause              23113
;  :final-checks            147
;  :interface-eqs           6
;  :max-generation          8
;  :max-memory              8.28
;  :memory                  7.98
;  :minimized-lits          63
;  :mk-bool-var             32925
;  :mk-clause               23117
;  :num-allocs              358377
;  :num-checks              246
;  :propagations            10185
;  :quant-instantiations    7551
;  :rlimit-count            927170
;  :time                    0.00)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@171@06 $FVF<Int>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (iff
    (Set_in r ($FVF.domain_int (as sm@171@06  $FVF<Int>)))
    (and
      (and (< (inv@167@06 r) V@27@06) (<= 0 (inv@167@06 r)))
      (< $Perm.No $k@166@06)))
  :pattern ((Set_in r ($FVF.domain_int (as sm@171@06  $FVF<Int>))))
  :qid |qp.fvfDomDef54|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@167@06 r) V@27@06) (<= 0 (inv@167@06 r)))
        (< $Perm.No $k@166@06))
      (and (< (inv@163@06 r) V@27@06) (<= 0 (inv@163@06 r))))
    (=
      ($FVF.lookup_int (as sm@171@06  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@161@06))))) r)))
  :pattern (($FVF.lookup_int (as sm@171@06  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@161@06))))) r))
  :qid |qp.fvfValDef50|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@167@06 r) V@27@06) (<= 0 (inv@167@06 r)))
        (< $Perm.No $k@166@06))
      (and
        (and
          (and (< (inv@138@06 r) V@27@06) (<= 0 (inv@138@06 r)))
          (< (inv@137@06 r) V@27@06))
        (<= 0 (inv@137@06 r))))
    (=
      ($FVF.lookup_int (as sm@171@06  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@118@06))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@171@06  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@118@06))))))))))))))) r))
  :qid |qp.fvfValDef51|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@167@06 r) V@27@06) (<= 0 (inv@167@06 r)))
        (< $Perm.No $k@166@06))
      (and
        (and
          (and (< (inv@143@06 r) V@27@06) (<= 0 (inv@143@06 r)))
          (< (inv@142@06 r) V@27@06))
        (<= 0 (inv@142@06 r))))
    (=
      ($FVF.lookup_int (as sm@171@06  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@118@06)))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@171@06  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@118@06)))))))))))))))) r))
  :qid |qp.fvfValDef52|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@161@06))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@118@06))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@118@06)))))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@171@06  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef53|)))
(pop) ; 16
; Joined path conditions
(assert ($Perm.isReadVar $k@166@06 $Perm.Write))
(assert (forall ((i1@165@06 Int)) (!
  (implies
    (and (and (< i1@165@06 V@27@06) (<= 0 i1@165@06)) (< $Perm.No $k@166@06))
    (=
      (inv@167@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@148@06) i1@165@06))
      i1@165@06))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@148@06) i1@165@06))
  :qid |int-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and (< (inv@167@06 r) V@27@06) (<= 0 (inv@167@06 r)))
      (< $Perm.No $k@166@06))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@148@06) (inv@167@06 r))
      r))
  :pattern ((inv@167@06 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (iff
    (Set_in r ($FVF.domain_int (as sm@171@06  $FVF<Int>)))
    (and
      (and (< (inv@167@06 r) V@27@06) (<= 0 (inv@167@06 r)))
      (< $Perm.No $k@166@06)))
  :pattern ((Set_in r ($FVF.domain_int (as sm@171@06  $FVF<Int>))))
  :qid |qp.fvfDomDef54|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@167@06 r) V@27@06) (<= 0 (inv@167@06 r)))
        (< $Perm.No $k@166@06))
      (and (< (inv@163@06 r) V@27@06) (<= 0 (inv@163@06 r))))
    (=
      ($FVF.lookup_int (as sm@171@06  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@161@06))))) r)))
  :pattern (($FVF.lookup_int (as sm@171@06  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@161@06))))) r))
  :qid |qp.fvfValDef50|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@167@06 r) V@27@06) (<= 0 (inv@167@06 r)))
        (< $Perm.No $k@166@06))
      (and
        (and
          (and (< (inv@138@06 r) V@27@06) (<= 0 (inv@138@06 r)))
          (< (inv@137@06 r) V@27@06))
        (<= 0 (inv@137@06 r))))
    (=
      ($FVF.lookup_int (as sm@171@06  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@118@06))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@171@06  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@118@06))))))))))))))) r))
  :qid |qp.fvfValDef51|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@167@06 r) V@27@06) (<= 0 (inv@167@06 r)))
        (< $Perm.No $k@166@06))
      (and
        (and
          (and (< (inv@143@06 r) V@27@06) (<= 0 (inv@143@06 r)))
          (< (inv@142@06 r) V@27@06))
        (<= 0 (inv@142@06 r))))
    (=
      ($FVF.lookup_int (as sm@171@06  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@118@06)))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@171@06  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@118@06)))))))))))))))) r))
  :qid |qp.fvfValDef52|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@161@06))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@118@06))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@118@06)))))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@171@06  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef53|)))
(assert (and
  (forall ((i1@165@06 Int)) (!
    (< i1@165@06 (alen<Int> (opt_get1 $Snap.unit res@148@06)))
    :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@148@06) i1@165@06))
    :qid |int-aux|))
  (forall ((r $Ref)) (!
    (implies
      (and (< (inv@167@06 r) V@27@06) (<= 0 (inv@167@06 r)))
      ($FVF.loc_int ($FVF.lookup_int (as sm@164@06  $FVF<Int>) r) r))
    :pattern ((inv@167@06 r))
    ))
  (forall ((r $Ref)) (!
    (implies
      (not
        (=
          (ite
            (and (< (inv@163@06 r) V@27@06) (<= 0 (inv@163@06 r)))
            $Perm.Write
            $Perm.No)
          $Perm.No))
      (ite
        (and (< (inv@163@06 r) V@27@06) (<= 0 (inv@163@06 r)))
        (<
          (ite
            (and (< (inv@167@06 r) V@27@06) (<= 0 (inv@167@06 r)))
            $k@166@06
            $Perm.No)
          $Perm.Write)
        (<
          (ite
            (and (< (inv@167@06 r) V@27@06) (<= 0 (inv@167@06 r)))
            $k@166@06
            $Perm.No)
          $Perm.No)))
    :pattern ((inv@163@06 r))
    :pattern ((inv@167@06 r))
    :qid |qp.srp49|))))
(pop) ; 15
(pop) ; 14
; Joined path conditions
(assert ($Perm.isReadVar $k@166@06 $Perm.Write))
(assert (forall ((i1@165@06 Int)) (!
  (implies
    (and (and (< i1@165@06 V@27@06) (<= 0 i1@165@06)) (< $Perm.No $k@166@06))
    (=
      (inv@167@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@148@06) i1@165@06))
      i1@165@06))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@148@06) i1@165@06))
  :qid |int-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and (< (inv@167@06 r) V@27@06) (<= 0 (inv@167@06 r)))
      (< $Perm.No $k@166@06))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@148@06) (inv@167@06 r))
      r))
  :pattern ((inv@167@06 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (iff
    (Set_in r ($FVF.domain_int (as sm@171@06  $FVF<Int>)))
    (and
      (and (< (inv@167@06 r) V@27@06) (<= 0 (inv@167@06 r)))
      (< $Perm.No $k@166@06)))
  :pattern ((Set_in r ($FVF.domain_int (as sm@171@06  $FVF<Int>))))
  :qid |qp.fvfDomDef54|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@167@06 r) V@27@06) (<= 0 (inv@167@06 r)))
        (< $Perm.No $k@166@06))
      (and (< (inv@163@06 r) V@27@06) (<= 0 (inv@163@06 r))))
    (=
      ($FVF.lookup_int (as sm@171@06  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@161@06))))) r)))
  :pattern (($FVF.lookup_int (as sm@171@06  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@161@06))))) r))
  :qid |qp.fvfValDef50|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@167@06 r) V@27@06) (<= 0 (inv@167@06 r)))
        (< $Perm.No $k@166@06))
      (and
        (and
          (and (< (inv@138@06 r) V@27@06) (<= 0 (inv@138@06 r)))
          (< (inv@137@06 r) V@27@06))
        (<= 0 (inv@137@06 r))))
    (=
      ($FVF.lookup_int (as sm@171@06  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@118@06))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@171@06  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@118@06))))))))))))))) r))
  :qid |qp.fvfValDef51|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@167@06 r) V@27@06) (<= 0 (inv@167@06 r)))
        (< $Perm.No $k@166@06))
      (and
        (and
          (and (< (inv@143@06 r) V@27@06) (<= 0 (inv@143@06 r)))
          (< (inv@142@06 r) V@27@06))
        (<= 0 (inv@142@06 r))))
    (=
      ($FVF.lookup_int (as sm@171@06  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@118@06)))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@171@06  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@118@06)))))))))))))))) r))
  :qid |qp.fvfValDef52|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@161@06))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@118@06))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@118@06)))))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@171@06  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef53|)))
(assert (implies
  (= exc@159@06 $Ref.null)
  (and
    (forall ((i1@165@06 Int)) (!
      (< i1@165@06 (alen<Int> (opt_get1 $Snap.unit res@148@06)))
      :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@148@06) i1@165@06))
      :qid |int-aux|))
    (forall ((r $Ref)) (!
      (implies
        (and (< (inv@167@06 r) V@27@06) (<= 0 (inv@167@06 r)))
        ($FVF.loc_int ($FVF.lookup_int (as sm@164@06  $FVF<Int>) r) r))
      :pattern ((inv@167@06 r))
      ))
    (forall ((r $Ref)) (!
      (implies
        (not
          (=
            (ite
              (and (< (inv@163@06 r) V@27@06) (<= 0 (inv@163@06 r)))
              $Perm.Write
              $Perm.No)
            $Perm.No))
        (ite
          (and (< (inv@163@06 r) V@27@06) (<= 0 (inv@163@06 r)))
          (<
            (ite
              (and (< (inv@167@06 r) V@27@06) (<= 0 (inv@167@06 r)))
              $k@166@06
              $Perm.No)
            $Perm.Write)
          (<
            (ite
              (and (< (inv@167@06 r) V@27@06) (<= 0 (inv@167@06 r)))
              $k@166@06
              $Perm.No)
            $Perm.No)))
      :pattern ((inv@163@06 r))
      :pattern ((inv@167@06 r))
      :qid |qp.srp49|)))))
(assert (implies
  (= exc@159@06 $Ref.null)
  (valid_graph_vertices ($Snap.combine
    $Snap.unit
    ($Snap.combine
      $Snap.unit
      ($Snap.combine
        $Snap.unit
        ($SortWrappers.$FVF<Int>To$Snap (as sm@171@06  $FVF<Int>))))) this@22@06 res@148@06 V@27@06)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@161@06)))))
  $Snap.unit))
; [eval] exc == null ==> (forall unknown: Int :: { aloc(opt_get1(p), unknown) } 0 <= unknown && unknown < V ==> aloc(opt_get1(p), unknown).int == 0)
; [eval] exc == null
(push) ; 14
(set-option :timeout 10)
(push) ; 15
(assert (not (not (= exc@159@06 $Ref.null))))
(check-sat)
; unknown
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               16775
;  :arith-add-rows          11406
;  :arith-assert-diseq      1074
;  :arith-assert-lower      4618
;  :arith-assert-upper      2963
;  :arith-bound-prop        1571
;  :arith-conflicts         347
;  :arith-eq-adapter        3223
;  :arith-fixed-eqs         1488
;  :arith-offset-eqs        1731
;  :arith-pivots            2781
;  :conflicts               835
;  :datatype-accessor-ax    77
;  :datatype-constructor-ax 506
;  :datatype-occurs-check   320
;  :datatype-splits         283
;  :decisions               2001
;  :del-clause              23113
;  :final-checks            149
;  :interface-eqs           6
;  :max-generation          8
;  :max-memory              8.28
;  :memory                  8.00
;  :minimized-lits          63
;  :mk-bool-var             32978
;  :mk-clause               23150
;  :num-allocs              361782
;  :num-checks              247
;  :propagations            10201
;  :quant-instantiations    7555
;  :rlimit-count            934421)
; [then-branch: 160 | exc@159@06 == Null | live]
; [else-branch: 160 | exc@159@06 != Null | dead]
(push) ; 15
; [then-branch: 160 | exc@159@06 == Null]
; [eval] (forall unknown: Int :: { aloc(opt_get1(p), unknown) } 0 <= unknown && unknown < V ==> aloc(opt_get1(p), unknown).int == 0)
(declare-const unknown@172@06 Int)
(push) ; 16
; [eval] 0 <= unknown && unknown < V ==> aloc(opt_get1(p), unknown).int == 0
; [eval] 0 <= unknown && unknown < V
; [eval] 0 <= unknown
(push) ; 17
; [then-branch: 161 | 0 <= unknown@172@06 | live]
; [else-branch: 161 | !(0 <= unknown@172@06) | live]
(push) ; 18
; [then-branch: 161 | 0 <= unknown@172@06]
(assert (<= 0 unknown@172@06))
; [eval] unknown < V
(pop) ; 18
(push) ; 18
; [else-branch: 161 | !(0 <= unknown@172@06)]
(assert (not (<= 0 unknown@172@06)))
(pop) ; 18
(pop) ; 17
; Joined path conditions
; Joined path conditions
(push) ; 17
; [then-branch: 162 | unknown@172@06 < V@27@06 && 0 <= unknown@172@06 | live]
; [else-branch: 162 | !(unknown@172@06 < V@27@06 && 0 <= unknown@172@06) | live]
(push) ; 18
; [then-branch: 162 | unknown@172@06 < V@27@06 && 0 <= unknown@172@06]
(assert (and (< unknown@172@06 V@27@06) (<= 0 unknown@172@06)))
; [eval] aloc(opt_get1(p), unknown).int == 0
; [eval] aloc(opt_get1(p), unknown)
; [eval] opt_get1(p)
(push) ; 19
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 19
; Joined path conditions
(push) ; 19
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 20
(assert (not (< unknown@172@06 (alen<Int> (opt_get1 $Snap.unit res@148@06)))))
(check-sat)
; unsat
(pop) ; 20
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               16775
;  :arith-add-rows          11407
;  :arith-assert-diseq      1074
;  :arith-assert-lower      4620
;  :arith-assert-upper      2963
;  :arith-bound-prop        1571
;  :arith-conflicts         347
;  :arith-eq-adapter        3223
;  :arith-fixed-eqs         1488
;  :arith-offset-eqs        1731
;  :arith-pivots            2781
;  :conflicts               835
;  :datatype-accessor-ax    77
;  :datatype-constructor-ax 506
;  :datatype-occurs-check   320
;  :datatype-splits         283
;  :decisions               2001
;  :del-clause              23113
;  :final-checks            149
;  :interface-eqs           6
;  :max-generation          8
;  :max-memory              8.28
;  :memory                  8.00
;  :minimized-lits          63
;  :mk-bool-var             32980
;  :mk-clause               23150
;  :num-allocs              361886
;  :num-checks              248
;  :propagations            10201
;  :quant-instantiations    7555
;  :rlimit-count            934615)
(assert (< unknown@172@06 (alen<Int> (opt_get1 $Snap.unit res@148@06))))
(pop) ; 19
; Joined path conditions
(assert (< unknown@172@06 (alen<Int> (opt_get1 $Snap.unit res@148@06))))
(declare-const sm@173@06 $FVF<Int>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@163@06 r) V@27@06) (<= 0 (inv@163@06 r)))
    (=
      ($FVF.lookup_int (as sm@173@06  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@161@06))))) r)))
  :pattern (($FVF.lookup_int (as sm@173@06  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@161@06))))) r))
  :qid |qp.fvfValDef55|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@138@06 r) V@27@06) (<= 0 (inv@138@06 r)))
        (< (inv@137@06 r) V@27@06))
      (<= 0 (inv@137@06 r)))
    (=
      ($FVF.lookup_int (as sm@173@06  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@118@06))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@173@06  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@118@06))))))))))))))) r))
  :qid |qp.fvfValDef56|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@143@06 r) V@27@06) (<= 0 (inv@143@06 r)))
        (< (inv@142@06 r) V@27@06))
      (<= 0 (inv@142@06 r)))
    (=
      ($FVF.lookup_int (as sm@173@06  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@118@06)))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@173@06  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@118@06)))))))))))))))) r))
  :qid |qp.fvfValDef57|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@161@06))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@118@06))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@118@06)))))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@173@06  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef58|)))
(declare-const pm@174@06 $FPM)
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_int (as pm@174@06  $FPM) r)
    (+
      (+
        (ite
          (and (< (inv@163@06 r) V@27@06) (<= 0 (inv@163@06 r)))
          $Perm.Write
          $Perm.No)
        (ite
          (and
            (and
              (and (< (inv@138@06 r) V@27@06) (<= 0 (inv@138@06 r)))
              (< (inv@137@06 r) V@27@06))
            (<= 0 (inv@137@06 r)))
          $Perm.Write
          $Perm.No))
      (ite
        (and
          (and
            (and (< (inv@143@06 r) V@27@06) (<= 0 (inv@143@06 r)))
            (< (inv@142@06 r) V@27@06))
          (<= 0 (inv@142@06 r)))
        $Perm.Write
        $Perm.No)))
  :pattern (($FVF.perm_int (as pm@174@06  $FPM) r))
  :qid |qp.resPrmSumDef59|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int (as sm@173@06  $FVF<Int>) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@161@06))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@118@06))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@118@06)))))))))))))))) r) r))
  :pattern (($FVF.perm_int (as pm@174@06  $FPM) r))
  :qid |qp.resTrgDef60|)))
(assert ($FVF.loc_int ($FVF.lookup_int (as sm@173@06  $FVF<Int>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit res@148@06) unknown@172@06)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit res@148@06) unknown@172@06)))
(push) ; 19
(assert (not (<
  $Perm.No
  ($FVF.perm_int (as pm@174@06  $FPM) (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@148@06) unknown@172@06)))))
(check-sat)
; unsat
(pop) ; 19
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               16974
;  :arith-add-rows          11476
;  :arith-assert-diseq      1079
;  :arith-assert-lower      4657
;  :arith-assert-upper      2996
;  :arith-bound-prop        1588
;  :arith-conflicts         350
;  :arith-eq-adapter        3255
;  :arith-fixed-eqs         1503
;  :arith-offset-eqs        1731
;  :arith-pivots            2809
;  :conflicts               846
;  :datatype-accessor-ax    77
;  :datatype-constructor-ax 510
;  :datatype-occurs-check   320
;  :datatype-splits         283
;  :decisions               2016
;  :del-clause              23284
;  :final-checks            149
;  :interface-eqs           6
;  :max-generation          8
;  :max-memory              8.28
;  :memory                  8.03
;  :minimized-lits          63
;  :mk-bool-var             33383
;  :mk-clause               23417
;  :num-allocs              364464
;  :num-checks              249
;  :propagations            10317
;  :quant-instantiations    7658
;  :rlimit-count            944297
;  :time                    0.00)
(pop) ; 18
(push) ; 18
; [else-branch: 162 | !(unknown@172@06 < V@27@06 && 0 <= unknown@172@06)]
(assert (not (and (< unknown@172@06 V@27@06) (<= 0 unknown@172@06))))
(pop) ; 18
(pop) ; 17
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@163@06 r) V@27@06) (<= 0 (inv@163@06 r)))
    (=
      ($FVF.lookup_int (as sm@173@06  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@161@06))))) r)))
  :pattern (($FVF.lookup_int (as sm@173@06  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@161@06))))) r))
  :qid |qp.fvfValDef55|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@138@06 r) V@27@06) (<= 0 (inv@138@06 r)))
        (< (inv@137@06 r) V@27@06))
      (<= 0 (inv@137@06 r)))
    (=
      ($FVF.lookup_int (as sm@173@06  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@118@06))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@173@06  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@118@06))))))))))))))) r))
  :qid |qp.fvfValDef56|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@143@06 r) V@27@06) (<= 0 (inv@143@06 r)))
        (< (inv@142@06 r) V@27@06))
      (<= 0 (inv@142@06 r)))
    (=
      ($FVF.lookup_int (as sm@173@06  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@118@06)))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@173@06  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@118@06)))))))))))))))) r))
  :qid |qp.fvfValDef57|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@161@06))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@118@06))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@118@06)))))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@173@06  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef58|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_int (as pm@174@06  $FPM) r)
    (+
      (+
        (ite
          (and (< (inv@163@06 r) V@27@06) (<= 0 (inv@163@06 r)))
          $Perm.Write
          $Perm.No)
        (ite
          (and
            (and
              (and (< (inv@138@06 r) V@27@06) (<= 0 (inv@138@06 r)))
              (< (inv@137@06 r) V@27@06))
            (<= 0 (inv@137@06 r)))
          $Perm.Write
          $Perm.No))
      (ite
        (and
          (and
            (and (< (inv@143@06 r) V@27@06) (<= 0 (inv@143@06 r)))
            (< (inv@142@06 r) V@27@06))
          (<= 0 (inv@142@06 r)))
        $Perm.Write
        $Perm.No)))
  :pattern (($FVF.perm_int (as pm@174@06  $FPM) r))
  :qid |qp.resPrmSumDef59|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int (as sm@173@06  $FVF<Int>) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@161@06))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@118@06))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@118@06)))))))))))))))) r) r))
  :pattern (($FVF.perm_int (as pm@174@06  $FPM) r))
  :qid |qp.resTrgDef60|)))
(assert (implies
  (and (< unknown@172@06 V@27@06) (<= 0 unknown@172@06))
  (and
    (< unknown@172@06 V@27@06)
    (<= 0 unknown@172@06)
    (< unknown@172@06 (alen<Int> (opt_get1 $Snap.unit res@148@06)))
    ($FVF.loc_int ($FVF.lookup_int (as sm@173@06  $FVF<Int>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@148@06) unknown@172@06)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@148@06) unknown@172@06)))))
; Joined path conditions
(pop) ; 16
; Nested auxiliary terms: globals (aux)
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@163@06 r) V@27@06) (<= 0 (inv@163@06 r)))
    (=
      ($FVF.lookup_int (as sm@173@06  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@161@06))))) r)))
  :pattern (($FVF.lookup_int (as sm@173@06  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@161@06))))) r))
  :qid |qp.fvfValDef55|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@138@06 r) V@27@06) (<= 0 (inv@138@06 r)))
        (< (inv@137@06 r) V@27@06))
      (<= 0 (inv@137@06 r)))
    (=
      ($FVF.lookup_int (as sm@173@06  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@118@06))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@173@06  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@118@06))))))))))))))) r))
  :qid |qp.fvfValDef56|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@143@06 r) V@27@06) (<= 0 (inv@143@06 r)))
        (< (inv@142@06 r) V@27@06))
      (<= 0 (inv@142@06 r)))
    (=
      ($FVF.lookup_int (as sm@173@06  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@118@06)))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@173@06  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@118@06)))))))))))))))) r))
  :qid |qp.fvfValDef57|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@161@06))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@118@06))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@118@06)))))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@173@06  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef58|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_int (as pm@174@06  $FPM) r)
    (+
      (+
        (ite
          (and (< (inv@163@06 r) V@27@06) (<= 0 (inv@163@06 r)))
          $Perm.Write
          $Perm.No)
        (ite
          (and
            (and
              (and (< (inv@138@06 r) V@27@06) (<= 0 (inv@138@06 r)))
              (< (inv@137@06 r) V@27@06))
            (<= 0 (inv@137@06 r)))
          $Perm.Write
          $Perm.No))
      (ite
        (and
          (and
            (and (< (inv@143@06 r) V@27@06) (<= 0 (inv@143@06 r)))
            (< (inv@142@06 r) V@27@06))
          (<= 0 (inv@142@06 r)))
        $Perm.Write
        $Perm.No)))
  :pattern (($FVF.perm_int (as pm@174@06  $FPM) r))
  :qid |qp.resPrmSumDef59|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int (as sm@173@06  $FVF<Int>) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@161@06))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@118@06))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@118@06)))))))))))))))) r) r))
  :pattern (($FVF.perm_int (as pm@174@06  $FPM) r))
  :qid |qp.resTrgDef60|)))
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((unknown@172@06 Int)) (!
  (implies
    (and (< unknown@172@06 V@27@06) (<= 0 unknown@172@06))
    (and
      (< unknown@172@06 V@27@06)
      (<= 0 unknown@172@06)
      (< unknown@172@06 (alen<Int> (opt_get1 $Snap.unit res@148@06)))
      ($FVF.loc_int ($FVF.lookup_int (as sm@173@06  $FVF<Int>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit res@148@06) unknown@172@06)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit res@148@06) unknown@172@06))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@148@06) unknown@172@06))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 15
(pop) ; 14
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@163@06 r) V@27@06) (<= 0 (inv@163@06 r)))
    (=
      ($FVF.lookup_int (as sm@173@06  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@161@06))))) r)))
  :pattern (($FVF.lookup_int (as sm@173@06  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@161@06))))) r))
  :qid |qp.fvfValDef55|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@138@06 r) V@27@06) (<= 0 (inv@138@06 r)))
        (< (inv@137@06 r) V@27@06))
      (<= 0 (inv@137@06 r)))
    (=
      ($FVF.lookup_int (as sm@173@06  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@118@06))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@173@06  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@118@06))))))))))))))) r))
  :qid |qp.fvfValDef56|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@143@06 r) V@27@06) (<= 0 (inv@143@06 r)))
        (< (inv@142@06 r) V@27@06))
      (<= 0 (inv@142@06 r)))
    (=
      ($FVF.lookup_int (as sm@173@06  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@118@06)))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@173@06  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@118@06)))))))))))))))) r))
  :qid |qp.fvfValDef57|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@161@06))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@118@06))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@118@06)))))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@173@06  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef58|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_int (as pm@174@06  $FPM) r)
    (+
      (+
        (ite
          (and (< (inv@163@06 r) V@27@06) (<= 0 (inv@163@06 r)))
          $Perm.Write
          $Perm.No)
        (ite
          (and
            (and
              (and (< (inv@138@06 r) V@27@06) (<= 0 (inv@138@06 r)))
              (< (inv@137@06 r) V@27@06))
            (<= 0 (inv@137@06 r)))
          $Perm.Write
          $Perm.No))
      (ite
        (and
          (and
            (and (< (inv@143@06 r) V@27@06) (<= 0 (inv@143@06 r)))
            (< (inv@142@06 r) V@27@06))
          (<= 0 (inv@142@06 r)))
        $Perm.Write
        $Perm.No)))
  :pattern (($FVF.perm_int (as pm@174@06  $FPM) r))
  :qid |qp.resPrmSumDef59|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int (as sm@173@06  $FVF<Int>) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@161@06))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@118@06))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@118@06)))))))))))))))) r) r))
  :pattern (($FVF.perm_int (as pm@174@06  $FPM) r))
  :qid |qp.resTrgDef60|)))
(assert (implies
  (= exc@159@06 $Ref.null)
  (forall ((unknown@172@06 Int)) (!
    (implies
      (and (< unknown@172@06 V@27@06) (<= 0 unknown@172@06))
      (and
        (< unknown@172@06 V@27@06)
        (<= 0 unknown@172@06)
        (< unknown@172@06 (alen<Int> (opt_get1 $Snap.unit res@148@06)))
        ($FVF.loc_int ($FVF.lookup_int (as sm@173@06  $FVF<Int>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@148@06) unknown@172@06)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@148@06) unknown@172@06))))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@148@06) unknown@172@06))
    :qid |prog.l<no position>-aux|))))
(assert (implies
  (= exc@159@06 $Ref.null)
  (forall ((unknown@172@06 Int)) (!
    (implies
      (and (< unknown@172@06 V@27@06) (<= 0 unknown@172@06))
      (=
        ($FVF.lookup_int (as sm@173@06  $FVF<Int>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@148@06) unknown@172@06))
        0))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@148@06) unknown@172@06))
    :qid |prog.l<no position>|))))
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
; [eval] exc != null
; [then-branch: 163 | exc@159@06 != Null | dead]
; [else-branch: 163 | exc@159@06 == Null | live]
(push) ; 14
; [else-branch: 163 | exc@159@06 == Null]
(pop) ; 14
; [eval] !(exc != null)
; [eval] exc != null
(set-option :timeout 10)
(push) ; 14
(assert (not (not (= exc@159@06 $Ref.null))))
(check-sat)
; unknown
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               17098
;  :arith-add-rows          11486
;  :arith-assert-diseq      1079
;  :arith-assert-lower      4657
;  :arith-assert-upper      2996
;  :arith-bound-prop        1588
;  :arith-conflicts         350
;  :arith-eq-adapter        3255
;  :arith-fixed-eqs         1503
;  :arith-offset-eqs        1731
;  :arith-pivots            2818
;  :conflicts               846
;  :datatype-accessor-ax    77
;  :datatype-constructor-ax 532
;  :datatype-occurs-check   344
;  :datatype-splits         301
;  :decisions               2038
;  :del-clause              23380
;  :final-checks            153
;  :interface-eqs           6
;  :max-generation          8
;  :max-memory              8.28
;  :memory                  8.03
;  :minimized-lits          63
;  :mk-bool-var             33409
;  :mk-clause               23417
;  :num-allocs              367862
;  :num-checks              251
;  :propagations            10317
;  :quant-instantiations    7658
;  :rlimit-count            951404)
; [then-branch: 164 | exc@159@06 == Null | live]
; [else-branch: 164 | exc@159@06 != Null | dead]
(push) ; 14
; [then-branch: 164 | exc@159@06 == Null]
; [exec]
; evaluationDummy1 := res4
; [exec]
; label end
; [exec]
; res := return
; [exec]
; label bubble
; [eval] exc == null
; [eval] exc == null ==> G != (None(): option[array])
; [eval] exc == null
(push) ; 15
(push) ; 16
(assert (not (not (= exc@159@06 $Ref.null))))
(check-sat)
; unknown
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               17160
;  :arith-add-rows          11486
;  :arith-assert-diseq      1079
;  :arith-assert-lower      4657
;  :arith-assert-upper      2996
;  :arith-bound-prop        1588
;  :arith-conflicts         350
;  :arith-eq-adapter        3255
;  :arith-fixed-eqs         1503
;  :arith-offset-eqs        1731
;  :arith-pivots            2818
;  :conflicts               846
;  :datatype-accessor-ax    77
;  :datatype-constructor-ax 543
;  :datatype-occurs-check   356
;  :datatype-splits         310
;  :decisions               2049
;  :del-clause              23380
;  :final-checks            155
;  :interface-eqs           6
;  :max-generation          8
;  :max-memory              8.28
;  :memory                  8.03
;  :minimized-lits          63
;  :mk-bool-var             33418
;  :mk-clause               23417
;  :num-allocs              368580
;  :num-checks              252
;  :propagations            10317
;  :quant-instantiations    7658
;  :rlimit-count            952216)
; [then-branch: 165 | exc@159@06 == Null | live]
; [else-branch: 165 | exc@159@06 != Null | dead]
(push) ; 16
; [then-branch: 165 | exc@159@06 == Null]
; [eval] G != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 16
(pop) ; 15
; Joined path conditions
(set-option :timeout 0)
(push) ; 15
(assert (not (implies
  (= exc@159@06 $Ref.null)
  (not (= G@24@06 (as None<option<array>>  option<array>))))))
(check-sat)
; unsat
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               17160
;  :arith-add-rows          11486
;  :arith-assert-diseq      1079
;  :arith-assert-lower      4657
;  :arith-assert-upper      2996
;  :arith-bound-prop        1588
;  :arith-conflicts         350
;  :arith-eq-adapter        3255
;  :arith-fixed-eqs         1503
;  :arith-offset-eqs        1731
;  :arith-pivots            2818
;  :conflicts               846
;  :datatype-accessor-ax    77
;  :datatype-constructor-ax 543
;  :datatype-occurs-check   356
;  :datatype-splits         310
;  :decisions               2049
;  :del-clause              23380
;  :final-checks            155
;  :interface-eqs           6
;  :max-generation          8
;  :max-memory              8.28
;  :memory                  8.03
;  :minimized-lits          63
;  :mk-bool-var             33418
;  :mk-clause               23417
;  :num-allocs              368604
;  :num-checks              253
;  :propagations            10317
;  :quant-instantiations    7658
;  :rlimit-count            952236)
(assert (implies
  (= exc@159@06 $Ref.null)
  (not (= G@24@06 (as None<option<array>>  option<array>)))))
; [eval] exc == null ==> alen(opt_get1(G)) == V
; [eval] exc == null
(push) ; 15
(set-option :timeout 10)
(push) ; 16
(assert (not (not (= exc@159@06 $Ref.null))))
(check-sat)
; unknown
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               17222
;  :arith-add-rows          11486
;  :arith-assert-diseq      1079
;  :arith-assert-lower      4657
;  :arith-assert-upper      2996
;  :arith-bound-prop        1588
;  :arith-conflicts         350
;  :arith-eq-adapter        3255
;  :arith-fixed-eqs         1503
;  :arith-offset-eqs        1731
;  :arith-pivots            2818
;  :conflicts               846
;  :datatype-accessor-ax    77
;  :datatype-constructor-ax 554
;  :datatype-occurs-check   368
;  :datatype-splits         319
;  :decisions               2060
;  :del-clause              23380
;  :final-checks            157
;  :interface-eqs           6
;  :max-generation          8
;  :max-memory              8.28
;  :memory                  8.03
;  :minimized-lits          63
;  :mk-bool-var             33427
;  :mk-clause               23417
;  :num-allocs              369324
;  :num-checks              254
;  :propagations            10317
;  :quant-instantiations    7658
;  :rlimit-count            953048)
; [then-branch: 166 | exc@159@06 == Null | live]
; [else-branch: 166 | exc@159@06 != Null | dead]
(push) ; 16
; [then-branch: 166 | exc@159@06 == Null]
; [eval] alen(opt_get1(G)) == V
; [eval] alen(opt_get1(G))
; [eval] opt_get1(G)
(push) ; 17
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 17
; Joined path conditions
(pop) ; 16
(pop) ; 15
; Joined path conditions
(set-option :timeout 0)
(push) ; 15
(assert (not (implies
  (= exc@159@06 $Ref.null)
  (= (alen<Int> (opt_get1 $Snap.unit G@24@06)) V@27@06))))
(check-sat)
; unsat
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               17222
;  :arith-add-rows          11486
;  :arith-assert-diseq      1079
;  :arith-assert-lower      4657
;  :arith-assert-upper      2996
;  :arith-bound-prop        1588
;  :arith-conflicts         350
;  :arith-eq-adapter        3255
;  :arith-fixed-eqs         1503
;  :arith-offset-eqs        1731
;  :arith-pivots            2818
;  :conflicts               846
;  :datatype-accessor-ax    77
;  :datatype-constructor-ax 554
;  :datatype-occurs-check   368
;  :datatype-splits         319
;  :decisions               2060
;  :del-clause              23380
;  :final-checks            157
;  :interface-eqs           6
;  :max-generation          8
;  :max-memory              8.28
;  :memory                  8.03
;  :minimized-lits          63
;  :mk-bool-var             33427
;  :mk-clause               23417
;  :num-allocs              369342
;  :num-checks              255
;  :propagations            10317
;  :quant-instantiations    7658
;  :rlimit-count            953073)
(assert (implies
  (= exc@159@06 $Ref.null)
  (= (alen<Int> (opt_get1 $Snap.unit G@24@06)) V@27@06)))
; [eval] exc == null
(set-option :timeout 10)
(push) ; 15
(assert (not (not (= exc@159@06 $Ref.null))))
(check-sat)
; unknown
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               17284
;  :arith-add-rows          11486
;  :arith-assert-diseq      1079
;  :arith-assert-lower      4657
;  :arith-assert-upper      2996
;  :arith-bound-prop        1588
;  :arith-conflicts         350
;  :arith-eq-adapter        3255
;  :arith-fixed-eqs         1503
;  :arith-offset-eqs        1731
;  :arith-pivots            2818
;  :conflicts               846
;  :datatype-accessor-ax    77
;  :datatype-constructor-ax 565
;  :datatype-occurs-check   380
;  :datatype-splits         328
;  :decisions               2071
;  :del-clause              23380
;  :final-checks            159
;  :interface-eqs           6
;  :max-generation          8
;  :max-memory              8.28
;  :memory                  8.03
;  :minimized-lits          63
;  :mk-bool-var             33436
;  :mk-clause               23417
;  :num-allocs              370062
;  :num-checks              256
;  :propagations            10317
;  :quant-instantiations    7658
;  :rlimit-count            953880)
; [then-branch: 167 | exc@159@06 == Null | live]
; [else-branch: 167 | exc@159@06 != Null | dead]
(push) ; 15
; [then-branch: 167 | exc@159@06 == Null]
(declare-const i1@175@06 Int)
(push) ; 16
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 17
; [then-branch: 168 | 0 <= i1@175@06 | live]
; [else-branch: 168 | !(0 <= i1@175@06) | live]
(push) ; 18
; [then-branch: 168 | 0 <= i1@175@06]
(assert (<= 0 i1@175@06))
; [eval] i1 < V
(pop) ; 18
(push) ; 18
; [else-branch: 168 | !(0 <= i1@175@06)]
(assert (not (<= 0 i1@175@06)))
(pop) ; 18
(pop) ; 17
; Joined path conditions
; Joined path conditions
(assert (and (< i1@175@06 V@27@06) (<= 0 i1@175@06)))
(declare-const $k@176@06 $Perm)
(assert ($Perm.isReadVar $k@176@06 $Perm.Write))
; [eval] aloc(opt_get1(G), i1)
; [eval] opt_get1(G)
(push) ; 17
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 17
; Joined path conditions
(push) ; 17
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 18
(assert (not (< i1@175@06 (alen<Int> (opt_get1 $Snap.unit G@24@06)))))
(check-sat)
; unsat
(pop) ; 18
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               17284
;  :arith-add-rows          11487
;  :arith-assert-diseq      1080
;  :arith-assert-lower      4661
;  :arith-assert-upper      2997
;  :arith-bound-prop        1588
;  :arith-conflicts         350
;  :arith-eq-adapter        3256
;  :arith-fixed-eqs         1503
;  :arith-offset-eqs        1731
;  :arith-pivots            2818
;  :conflicts               846
;  :datatype-accessor-ax    77
;  :datatype-constructor-ax 565
;  :datatype-occurs-check   380
;  :datatype-splits         328
;  :decisions               2071
;  :del-clause              23380
;  :final-checks            159
;  :interface-eqs           6
;  :max-generation          8
;  :max-memory              8.28
;  :memory                  8.03
;  :minimized-lits          63
;  :mk-bool-var             33442
;  :mk-clause               23419
;  :num-allocs              370226
;  :num-checks              257
;  :propagations            10318
;  :quant-instantiations    7658
;  :rlimit-count            954206)
(assert (< i1@175@06 (alen<Int> (opt_get1 $Snap.unit G@24@06))))
(pop) ; 17
; Joined path conditions
(assert (< i1@175@06 (alen<Int> (opt_get1 $Snap.unit G@24@06))))
(pop) ; 16
(declare-fun inv@177@06 ($Ref) Int)
; Nested auxiliary terms: globals
(assert ($Perm.isReadVar $k@176@06 $Perm.Write))
; Nested auxiliary terms: non-globals
(assert (forall ((i1@175@06 Int)) (!
  (< i1@175@06 (alen<Int> (opt_get1 $Snap.unit G@24@06)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@175@06))
  :qid |option$array$-aux|)))
(push) ; 16
(assert (not (forall ((i1@175@06 Int)) (!
  (implies
    (and (< i1@175@06 V@27@06) (<= 0 i1@175@06))
    (or (= $k@176@06 $Perm.No) (< $Perm.No $k@176@06)))
  
  ))))
(check-sat)
; unsat
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               17284
;  :arith-add-rows          11488
;  :arith-assert-diseq      1081
;  :arith-assert-lower      4663
;  :arith-assert-upper      2998
;  :arith-bound-prop        1588
;  :arith-conflicts         350
;  :arith-eq-adapter        3257
;  :arith-fixed-eqs         1503
;  :arith-offset-eqs        1731
;  :arith-pivots            2818
;  :conflicts               847
;  :datatype-accessor-ax    77
;  :datatype-constructor-ax 565
;  :datatype-occurs-check   380
;  :datatype-splits         328
;  :decisions               2071
;  :del-clause              23382
;  :final-checks            159
;  :interface-eqs           6
;  :max-generation          8
;  :max-memory              8.28
;  :memory                  8.03
;  :minimized-lits          63
;  :mk-bool-var             33449
;  :mk-clause               23421
;  :num-allocs              370656
;  :num-checks              258
;  :propagations            10319
;  :quant-instantiations    7658
;  :rlimit-count            954753)
(declare-const sm@178@06 $FVF<option<array>>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (-
          (ite
            (and (< (inv@33@06 r) V@27@06) (<= 0 (inv@33@06 r)))
            $k@32@06
            $Perm.No)
          (pTaken@88@06 r))
        (pTaken@97@06 r)))
    (=
      ($FVF.lookup_option$array$ (as sm@178@06  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@30@06))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@178@06  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@30@06))))) r))
  :qid |qp.fvfValDef61|)))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (-
          (ite
            (and (< (inv@71@06 r) V@27@06) (<= 0 (inv@71@06 r)))
            $Perm.Write
            $Perm.No)
          (pTaken@87@06 r))
        (pTaken@98@06 r)))
    (=
      ($FVF.lookup_option$array$ (as sm@178@06  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@69@06))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@178@06  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@69@06))))) r))
  :qid |qp.fvfValDef62|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@121@06 r) V@27@06) (<= 0 (inv@121@06 r)))
      (< $Perm.No $k@120@06)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@178@06  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@118@06))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@178@06  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@118@06))))) r))
  :qid |qp.fvfValDef63|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@129@06 r) V@27@06) (<= 0 (inv@129@06 r)))
      (< $Perm.No $k@128@06)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@178@06  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@118@06))))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@178@06  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@118@06))))))))))) r))
  :qid |qp.fvfValDef64|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@30@06))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@69@06))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@118@06))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@118@06))))))))))) r) r))
  :pattern (($FVF.lookup_option$array$ (as sm@178@06  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef65|)))
; Check receiver injectivity
(push) ; 16
(assert (not (forall ((i11@175@06 Int) (i12@175@06 Int)) (!
  (implies
    (and
      (and
        (and
          (and (< i11@175@06 V@27@06) (<= 0 i11@175@06))
          ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@178@06  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@24@06) i11@175@06)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@24@06) i11@175@06)))
        (< $Perm.No $k@176@06))
      (and
        (and
          (and (< i12@175@06 V@27@06) (<= 0 i12@175@06))
          ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@178@06  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@24@06) i12@175@06)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@24@06) i12@175@06)))
        (< $Perm.No $k@176@06))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i11@175@06)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i12@175@06)))
    (= i11@175@06 i12@175@06))
  
  :qid |option$array$-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               17297
;  :arith-add-rows          11498
;  :arith-assert-diseq      1082
;  :arith-assert-lower      4667
;  :arith-assert-upper      2998
;  :arith-bound-prop        1588
;  :arith-conflicts         350
;  :arith-eq-adapter        3258
;  :arith-fixed-eqs         1503
;  :arith-offset-eqs        1731
;  :arith-pivots            2818
;  :conflicts               848
;  :datatype-accessor-ax    77
;  :datatype-constructor-ax 565
;  :datatype-occurs-check   380
;  :datatype-splits         328
;  :decisions               2071
;  :del-clause              23429
;  :final-checks            159
;  :interface-eqs           6
;  :max-generation          8
;  :max-memory              8.28
;  :memory                  8.02
;  :minimized-lits          63
;  :mk-bool-var             33528
;  :mk-clause               23468
;  :num-allocs              372501
;  :num-checks              259
;  :propagations            10323
;  :quant-instantiations    7682
;  :rlimit-count            960400)
; Definitional axioms for inverse functions
(assert (forall ((i1@175@06 Int)) (!
  (implies
    (and (and (< i1@175@06 V@27@06) (<= 0 i1@175@06)) (< $Perm.No $k@176@06))
    (=
      (inv@177@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@175@06))
      i1@175@06))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@175@06))
  :qid |option$array$-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and (< (inv@177@06 r) V@27@06) (<= 0 (inv@177@06 r)))
      (< $Perm.No $k@176@06))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) (inv@177@06 r))
      r))
  :pattern ((inv@177@06 r))
  :qid |option$array$-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@177@06 r) V@27@06) (<= 0 (inv@177@06 r)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@178@06  $FVF<option<array>>) r) r))
  :pattern ((inv@177@06 r))
  )))
; Precomputing data for removing quantified permissions
(define-fun pTaken@179@06 ((r $Ref)) $Perm
  (ite
    (and (< (inv@177@06 r) V@27@06) (<= 0 (inv@177@06 r)))
    ($Perm.min
      (-
        (-
          (ite
            (and (< (inv@33@06 r) V@27@06) (<= 0 (inv@33@06 r)))
            $k@32@06
            $Perm.No)
          (pTaken@88@06 r))
        (pTaken@97@06 r))
      $k@176@06)
    $Perm.No))
(define-fun pTaken@180@06 ((r $Ref)) $Perm
  (ite
    (and (< (inv@177@06 r) V@27@06) (<= 0 (inv@177@06 r)))
    ($Perm.min
      (-
        (-
          (ite
            (and (< (inv@71@06 r) V@27@06) (<= 0 (inv@71@06 r)))
            $Perm.Write
            $Perm.No)
          (pTaken@87@06 r))
        (pTaken@98@06 r))
      (- $k@176@06 (pTaken@179@06 r)))
    $Perm.No))
(define-fun pTaken@181@06 ((r $Ref)) $Perm
  (ite
    (and (< (inv@177@06 r) V@27@06) (<= 0 (inv@177@06 r)))
    ($Perm.min
      (ite
        (and (< (inv@121@06 r) V@27@06) (<= 0 (inv@121@06 r)))
        $k@120@06
        $Perm.No)
      (- (- $k@176@06 (pTaken@179@06 r)) (pTaken@180@06 r)))
    $Perm.No))
(define-fun pTaken@182@06 ((r $Ref)) $Perm
  (ite
    (and (< (inv@177@06 r) V@27@06) (<= 0 (inv@177@06 r)))
    ($Perm.min
      (ite
        (and (< (inv@129@06 r) V@27@06) (<= 0 (inv@129@06 r)))
        $k@128@06
        $Perm.No)
      (- (- (- $k@176@06 (pTaken@179@06 r)) (pTaken@180@06 r)) (pTaken@181@06 r)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Constrain original permissions $k@176@06
(assert (forall ((r $Ref)) (!
  (implies
    (not
      (=
        (-
          (-
            (ite
              (and (< (inv@33@06 r) V@27@06) (<= 0 (inv@33@06 r)))
              $k@32@06
              $Perm.No)
            (pTaken@88@06 r))
          (pTaken@97@06 r))
        $Perm.No))
    (<
      (ite
        (and (< (inv@177@06 r) V@27@06) (<= 0 (inv@177@06 r)))
        $k@176@06
        $Perm.No)
      (-
        (-
          (ite
            (and (< (inv@33@06 r) V@27@06) (<= 0 (inv@33@06 r)))
            $k@32@06
            $Perm.No)
          (pTaken@88@06 r))
        (pTaken@97@06 r))))
  :pattern ((inv@33@06 r))
  :pattern ((inv@177@06 r))
  :qid |qp.srp66|)))
; Intermediate check if already taken enough permissions
(set-option :timeout 500)
(push) ; 16
(assert (not (forall ((r $Ref)) (!
  (implies
    (and (< (inv@177@06 r) V@27@06) (<= 0 (inv@177@06 r)))
    (= (- $k@176@06 (pTaken@179@06 r)) $Perm.No))
  
  ))))
(check-sat)
; unsat
(pop) ; 16
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               18193
;  :arith-add-rows          12134
;  :arith-assert-diseq      1153
;  :arith-assert-lower      4863
;  :arith-assert-upper      3144
;  :arith-bound-prop        1665
;  :arith-conflicts         363
;  :arith-eq-adapter        3410
;  :arith-fixed-eqs         1567
;  :arith-offset-eqs        1854
;  :arith-pivots            2930
;  :conflicts               874
;  :datatype-accessor-ax    77
;  :datatype-constructor-ax 578
;  :datatype-occurs-check   392
;  :datatype-splits         337
;  :decisions               2164
;  :del-clause              24547
;  :final-checks            161
;  :interface-eqs           6
;  :max-generation          8
;  :max-memory              8.28
;  :memory                  8.16
;  :minimized-lits          70
;  :mk-bool-var             34781
;  :mk-clause               24586
;  :num-allocs              380080
;  :num-checks              261
;  :propagations            10930
;  :quant-instantiations    7966
;  :rlimit-count            1002339
;  :time                    0.01)
; Final check if taken enough permissions
; Done removing quantified permissions
; Definitional axioms for snapshot map values
; [eval] exc == null ==> (forall i1: Int :: { aloc(opt_get1(G), i1) } 0 <= i1 && i1 < V ==> aloc(opt_get1(G), i1).option$array$ != (None(): option[array]))
; [eval] exc == null
(push) ; 16
(set-option :timeout 10)
(push) ; 17
(assert (not (not (= exc@159@06 $Ref.null))))
(check-sat)
; unknown
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               18255
;  :arith-add-rows          12134
;  :arith-assert-diseq      1153
;  :arith-assert-lower      4863
;  :arith-assert-upper      3144
;  :arith-bound-prop        1665
;  :arith-conflicts         363
;  :arith-eq-adapter        3410
;  :arith-fixed-eqs         1567
;  :arith-offset-eqs        1854
;  :arith-pivots            2930
;  :conflicts               874
;  :datatype-accessor-ax    77
;  :datatype-constructor-ax 589
;  :datatype-occurs-check   404
;  :datatype-splits         346
;  :decisions               2175
;  :del-clause              24547
;  :final-checks            163
;  :interface-eqs           6
;  :max-generation          8
;  :max-memory              8.28
;  :memory                  8.17
;  :minimized-lits          70
;  :mk-bool-var             34790
;  :mk-clause               24586
;  :num-allocs              380813
;  :num-checks              262
;  :propagations            10930
;  :quant-instantiations    7966
;  :rlimit-count            1003159)
; [then-branch: 169 | exc@159@06 == Null | live]
; [else-branch: 169 | exc@159@06 != Null | dead]
(push) ; 17
; [then-branch: 169 | exc@159@06 == Null]
; [eval] (forall i1: Int :: { aloc(opt_get1(G), i1) } 0 <= i1 && i1 < V ==> aloc(opt_get1(G), i1).option$array$ != (None(): option[array]))
(declare-const i1@183@06 Int)
(push) ; 18
; [eval] 0 <= i1 && i1 < V ==> aloc(opt_get1(G), i1).option$array$ != (None(): option[array])
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 19
; [then-branch: 170 | 0 <= i1@183@06 | live]
; [else-branch: 170 | !(0 <= i1@183@06) | live]
(push) ; 20
; [then-branch: 170 | 0 <= i1@183@06]
(assert (<= 0 i1@183@06))
; [eval] i1 < V
(pop) ; 20
(push) ; 20
; [else-branch: 170 | !(0 <= i1@183@06)]
(assert (not (<= 0 i1@183@06)))
(pop) ; 20
(pop) ; 19
; Joined path conditions
; Joined path conditions
(push) ; 19
; [then-branch: 171 | i1@183@06 < V@27@06 && 0 <= i1@183@06 | live]
; [else-branch: 171 | !(i1@183@06 < V@27@06 && 0 <= i1@183@06) | live]
(push) ; 20
; [then-branch: 171 | i1@183@06 < V@27@06 && 0 <= i1@183@06]
(assert (and (< i1@183@06 V@27@06) (<= 0 i1@183@06)))
; [eval] aloc(opt_get1(G), i1).option$array$ != (None(): option[array])
; [eval] aloc(opt_get1(G), i1)
; [eval] opt_get1(G)
(push) ; 21
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 21
; Joined path conditions
(push) ; 21
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 22
(assert (not (< i1@183@06 (alen<Int> (opt_get1 $Snap.unit G@24@06)))))
(check-sat)
; unsat
(pop) ; 22
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               18255
;  :arith-add-rows          12135
;  :arith-assert-diseq      1153
;  :arith-assert-lower      4865
;  :arith-assert-upper      3144
;  :arith-bound-prop        1665
;  :arith-conflicts         363
;  :arith-eq-adapter        3410
;  :arith-fixed-eqs         1567
;  :arith-offset-eqs        1854
;  :arith-pivots            2930
;  :conflicts               874
;  :datatype-accessor-ax    77
;  :datatype-constructor-ax 589
;  :datatype-occurs-check   404
;  :datatype-splits         346
;  :decisions               2175
;  :del-clause              24547
;  :final-checks            163
;  :interface-eqs           6
;  :max-generation          8
;  :max-memory              8.28
;  :memory                  8.17
;  :minimized-lits          70
;  :mk-bool-var             34792
;  :mk-clause               24586
;  :num-allocs              380916
;  :num-checks              263
;  :propagations            10930
;  :quant-instantiations    7966
;  :rlimit-count            1003355)
(assert (< i1@183@06 (alen<Int> (opt_get1 $Snap.unit G@24@06))))
(pop) ; 21
; Joined path conditions
(assert (< i1@183@06 (alen<Int> (opt_get1 $Snap.unit G@24@06))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@178@06  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@183@06)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@183@06)))
(push) ; 21
(assert (not (<
  $Perm.No
  (+
    (+
      (+
        (-
          (-
            (ite
              (and
                (<
                  (inv@33@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@183@06))
                  V@27@06)
                (<=
                  0
                  (inv@33@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@183@06))))
              $k@32@06
              $Perm.No)
            (pTaken@88@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@183@06)))
          (pTaken@97@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@183@06)))
        (-
          (-
            (ite
              (and
                (<
                  (inv@71@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@183@06))
                  V@27@06)
                (<=
                  0
                  (inv@71@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@183@06))))
              $Perm.Write
              $Perm.No)
            (pTaken@87@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@183@06)))
          (pTaken@98@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@183@06))))
      (ite
        (and
          (<
            (inv@121@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@183@06))
            V@27@06)
          (<=
            0
            (inv@121@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@183@06))))
        $k@120@06
        $Perm.No))
    (ite
      (and
        (<
          (inv@129@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@183@06))
          V@27@06)
        (<=
          0
          (inv@129@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@183@06))))
      $k@128@06
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 21
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               19741
;  :arith-add-rows          13730
;  :arith-assert-diseq      1282
;  :arith-assert-lower      5366
;  :arith-assert-upper      3461
;  :arith-bound-prop        1799
;  :arith-conflicts         390
;  :arith-eq-adapter        3744
;  :arith-fixed-eqs         1723
;  :arith-offset-eqs        2111
;  :arith-pivots            3138
;  :conflicts               920
;  :datatype-accessor-ax    77
;  :datatype-constructor-ax 591
;  :datatype-occurs-check   404
;  :datatype-splits         346
;  :decisions               2278
;  :del-clause              25915
;  :final-checks            163
;  :interface-eqs           6
;  :max-generation          8
;  :max-memory              8.28
;  :memory                  8.25
;  :minimized-lits          88
;  :mk-bool-var             36648
;  :mk-clause               26138
;  :num-allocs              388743
;  :num-checks              264
;  :propagations            12121
;  :quant-instantiations    8387
;  :rlimit-count            1073190
;  :time                    0.01)
; [eval] (None(): option[array])
(pop) ; 20
(push) ; 20
; [else-branch: 171 | !(i1@183@06 < V@27@06 && 0 <= i1@183@06)]
(assert (not (and (< i1@183@06 V@27@06) (<= 0 i1@183@06))))
(pop) ; 20
(pop) ; 19
; Joined path conditions
(assert (implies
  (and (< i1@183@06 V@27@06) (<= 0 i1@183@06))
  (and
    (< i1@183@06 V@27@06)
    (<= 0 i1@183@06)
    (< i1@183@06 (alen<Int> (opt_get1 $Snap.unit G@24@06)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@178@06  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@183@06)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@183@06)))))
; Joined path conditions
(pop) ; 18
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@183@06 Int)) (!
  (implies
    (and (< i1@183@06 V@27@06) (<= 0 i1@183@06))
    (and
      (< i1@183@06 V@27@06)
      (<= 0 i1@183@06)
      (< i1@183@06 (alen<Int> (opt_get1 $Snap.unit G@24@06)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@178@06  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@183@06)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@183@06))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@183@06))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 17
(pop) ; 16
; Joined path conditions
(assert (implies
  (= exc@159@06 $Ref.null)
  (forall ((i1@183@06 Int)) (!
    (implies
      (and (< i1@183@06 V@27@06) (<= 0 i1@183@06))
      (and
        (< i1@183@06 V@27@06)
        (<= 0 i1@183@06)
        (< i1@183@06 (alen<Int> (opt_get1 $Snap.unit G@24@06)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@178@06  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@183@06)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@183@06))))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@183@06))
    :qid |prog.l<no position>-aux|))))
(push) ; 16
(assert (not (implies
  (= exc@159@06 $Ref.null)
  (forall ((i1@183@06 Int)) (!
    (implies
      (and (< i1@183@06 V@27@06) (<= 0 i1@183@06))
      (not
        (=
          ($FVF.lookup_option$array$ (as sm@178@06  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@183@06))
          (as None<option<array>>  option<array>))))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@183@06))
    :qid |prog.l<no position>|)))))
(check-sat)
; unsat
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               19807
;  :arith-add-rows          13809
;  :arith-assert-diseq      1282
;  :arith-assert-lower      5377
;  :arith-assert-upper      3472
;  :arith-bound-prop        1816
;  :arith-conflicts         391
;  :arith-eq-adapter        3756
;  :arith-fixed-eqs         1731
;  :arith-offset-eqs        2126
;  :arith-pivots            3179
;  :conflicts               925
;  :datatype-accessor-ax    77
;  :datatype-constructor-ax 593
;  :datatype-occurs-check   404
;  :datatype-splits         346
;  :decisions               2282
;  :del-clause              26315
;  :final-checks            163
;  :interface-eqs           6
;  :max-generation          8
;  :max-memory              8.28
;  :memory                  8.22
;  :minimized-lits          88
;  :mk-bool-var             36927
;  :mk-clause               26354
;  :num-allocs              390361
;  :num-checks              265
;  :propagations            12138
;  :quant-instantiations    8459
;  :rlimit-count            1079733
;  :time                    0.00)
(assert (implies
  (= exc@159@06 $Ref.null)
  (forall ((i1@183@06 Int)) (!
    (implies
      (and (< i1@183@06 V@27@06) (<= 0 i1@183@06))
      (not
        (=
          ($FVF.lookup_option$array$ (as sm@178@06  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@183@06))
          (as None<option<array>>  option<array>))))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@183@06))
    :qid |prog.l<no position>|))))
; [eval] exc == null ==> (forall i1: Int :: { alen(opt_get1(aloc(opt_get1(G), i1).option$array$)) } 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(G), i1).option$array$)) == V)
; [eval] exc == null
(push) ; 16
(set-option :timeout 10)
(push) ; 17
(assert (not (not (= exc@159@06 $Ref.null))))
(check-sat)
; unknown
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               19869
;  :arith-add-rows          13809
;  :arith-assert-diseq      1282
;  :arith-assert-lower      5377
;  :arith-assert-upper      3472
;  :arith-bound-prop        1816
;  :arith-conflicts         391
;  :arith-eq-adapter        3756
;  :arith-fixed-eqs         1731
;  :arith-offset-eqs        2126
;  :arith-pivots            3179
;  :conflicts               925
;  :datatype-accessor-ax    77
;  :datatype-constructor-ax 604
;  :datatype-occurs-check   416
;  :datatype-splits         355
;  :decisions               2293
;  :del-clause              26315
;  :final-checks            165
;  :interface-eqs           6
;  :max-generation          8
;  :max-memory              8.28
;  :memory                  8.22
;  :minimized-lits          88
;  :mk-bool-var             36937
;  :mk-clause               26354
;  :num-allocs              391280
;  :num-checks              266
;  :propagations            12138
;  :quant-instantiations    8459
;  :rlimit-count            1080868)
; [then-branch: 172 | exc@159@06 == Null | live]
; [else-branch: 172 | exc@159@06 != Null | dead]
(push) ; 17
; [then-branch: 172 | exc@159@06 == Null]
; [eval] (forall i1: Int :: { alen(opt_get1(aloc(opt_get1(G), i1).option$array$)) } 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(G), i1).option$array$)) == V)
(declare-const i1@184@06 Int)
(push) ; 18
; [eval] 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(G), i1).option$array$)) == V
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 19
; [then-branch: 173 | 0 <= i1@184@06 | live]
; [else-branch: 173 | !(0 <= i1@184@06) | live]
(push) ; 20
; [then-branch: 173 | 0 <= i1@184@06]
(assert (<= 0 i1@184@06))
; [eval] i1 < V
(pop) ; 20
(push) ; 20
; [else-branch: 173 | !(0 <= i1@184@06)]
(assert (not (<= 0 i1@184@06)))
(pop) ; 20
(pop) ; 19
; Joined path conditions
; Joined path conditions
(push) ; 19
; [then-branch: 174 | i1@184@06 < V@27@06 && 0 <= i1@184@06 | live]
; [else-branch: 174 | !(i1@184@06 < V@27@06 && 0 <= i1@184@06) | live]
(push) ; 20
; [then-branch: 174 | i1@184@06 < V@27@06 && 0 <= i1@184@06]
(assert (and (< i1@184@06 V@27@06) (<= 0 i1@184@06)))
; [eval] alen(opt_get1(aloc(opt_get1(G), i1).option$array$)) == V
; [eval] alen(opt_get1(aloc(opt_get1(G), i1).option$array$))
; [eval] opt_get1(aloc(opt_get1(G), i1).option$array$)
; [eval] aloc(opt_get1(G), i1)
; [eval] opt_get1(G)
(push) ; 21
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 21
; Joined path conditions
(push) ; 21
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 22
(assert (not (< i1@184@06 (alen<Int> (opt_get1 $Snap.unit G@24@06)))))
(check-sat)
; unsat
(pop) ; 22
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               19869
;  :arith-add-rows          13810
;  :arith-assert-diseq      1282
;  :arith-assert-lower      5379
;  :arith-assert-upper      3472
;  :arith-bound-prop        1816
;  :arith-conflicts         391
;  :arith-eq-adapter        3756
;  :arith-fixed-eqs         1731
;  :arith-offset-eqs        2126
;  :arith-pivots            3179
;  :conflicts               925
;  :datatype-accessor-ax    77
;  :datatype-constructor-ax 604
;  :datatype-occurs-check   416
;  :datatype-splits         355
;  :decisions               2293
;  :del-clause              26315
;  :final-checks            165
;  :interface-eqs           6
;  :max-generation          8
;  :max-memory              8.28
;  :memory                  8.22
;  :minimized-lits          88
;  :mk-bool-var             36939
;  :mk-clause               26354
;  :num-allocs              391383
;  :num-checks              267
;  :propagations            12138
;  :quant-instantiations    8459
;  :rlimit-count            1081062)
(assert (< i1@184@06 (alen<Int> (opt_get1 $Snap.unit G@24@06))))
(pop) ; 21
; Joined path conditions
(assert (< i1@184@06 (alen<Int> (opt_get1 $Snap.unit G@24@06))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@178@06  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@184@06)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@184@06)))
(push) ; 21
(assert (not (<
  $Perm.No
  (+
    (+
      (+
        (-
          (-
            (ite
              (and
                (<
                  (inv@33@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@184@06))
                  V@27@06)
                (<=
                  0
                  (inv@33@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@184@06))))
              $k@32@06
              $Perm.No)
            (pTaken@88@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@184@06)))
          (pTaken@97@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@184@06)))
        (-
          (-
            (ite
              (and
                (<
                  (inv@71@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@184@06))
                  V@27@06)
                (<=
                  0
                  (inv@71@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@184@06))))
              $Perm.Write
              $Perm.No)
            (pTaken@87@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@184@06)))
          (pTaken@98@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@184@06))))
      (ite
        (and
          (<
            (inv@121@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@184@06))
            V@27@06)
          (<=
            0
            (inv@121@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@184@06))))
        $k@120@06
        $Perm.No))
    (ite
      (and
        (<
          (inv@129@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@184@06))
          V@27@06)
        (<=
          0
          (inv@129@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@184@06))))
      $k@128@06
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 21
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               20673
;  :arith-add-rows          14521
;  :arith-assert-diseq      1351
;  :arith-assert-lower      5660
;  :arith-assert-upper      3632
;  :arith-bound-prop        1922
;  :arith-conflicts         406
;  :arith-eq-adapter        3928
;  :arith-fixed-eqs         1820
;  :arith-offset-eqs        2232
;  :arith-pivots            3300
;  :conflicts               955
;  :datatype-accessor-ax    77
;  :datatype-constructor-ax 606
;  :datatype-occurs-check   416
;  :datatype-splits         355
;  :decisions               2352
;  :del-clause              27077
;  :final-checks            165
;  :interface-eqs           6
;  :max-generation          8
;  :max-memory              8.29
;  :memory                  8.27
;  :minimized-lits          95
;  :mk-bool-var             38179
;  :mk-clause               27300
;  :num-allocs              396996
;  :num-checks              268
;  :propagations            12740
;  :quant-instantiations    8736
;  :rlimit-count            1116522
;  :time                    0.01)
(push) ; 21
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 22
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@178@06  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@184@06))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 22
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               20673
;  :arith-add-rows          14521
;  :arith-assert-diseq      1351
;  :arith-assert-lower      5660
;  :arith-assert-upper      3632
;  :arith-bound-prop        1922
;  :arith-conflicts         406
;  :arith-eq-adapter        3928
;  :arith-fixed-eqs         1820
;  :arith-offset-eqs        2232
;  :arith-pivots            3300
;  :conflicts               956
;  :datatype-accessor-ax    77
;  :datatype-constructor-ax 606
;  :datatype-occurs-check   416
;  :datatype-splits         355
;  :decisions               2352
;  :del-clause              27077
;  :final-checks            165
;  :interface-eqs           6
;  :max-generation          8
;  :max-memory              8.29
;  :memory                  8.27
;  :minimized-lits          95
;  :mk-bool-var             38179
;  :mk-clause               27300
;  :num-allocs              397086
;  :num-checks              269
;  :propagations            12740
;  :quant-instantiations    8736
;  :rlimit-count            1116617)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@178@06  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@184@06))
    (as None<option<array>>  option<array>))))
(pop) ; 21
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@178@06  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@184@06))
    (as None<option<array>>  option<array>))))
(pop) ; 20
(push) ; 20
; [else-branch: 174 | !(i1@184@06 < V@27@06 && 0 <= i1@184@06)]
(assert (not (and (< i1@184@06 V@27@06) (<= 0 i1@184@06))))
(pop) ; 20
(pop) ; 19
; Joined path conditions
(assert (implies
  (and (< i1@184@06 V@27@06) (<= 0 i1@184@06))
  (and
    (< i1@184@06 V@27@06)
    (<= 0 i1@184@06)
    (< i1@184@06 (alen<Int> (opt_get1 $Snap.unit G@24@06)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@178@06  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@184@06)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@184@06))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@178@06  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@184@06))
        (as None<option<array>>  option<array>))))))
; Joined path conditions
(pop) ; 18
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@184@06 Int)) (!
  (implies
    (and (< i1@184@06 V@27@06) (<= 0 i1@184@06))
    (and
      (< i1@184@06 V@27@06)
      (<= 0 i1@184@06)
      (< i1@184@06 (alen<Int> (opt_get1 $Snap.unit G@24@06)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@178@06  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@184@06)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@184@06))
      (not
        (=
          ($FVF.lookup_option$array$ (as sm@178@06  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@184@06))
          (as None<option<array>>  option<array>)))))
  :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@178@06  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@184@06)))))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 17
(pop) ; 16
; Joined path conditions
(assert (implies
  (= exc@159@06 $Ref.null)
  (forall ((i1@184@06 Int)) (!
    (implies
      (and (< i1@184@06 V@27@06) (<= 0 i1@184@06))
      (and
        (< i1@184@06 V@27@06)
        (<= 0 i1@184@06)
        (< i1@184@06 (alen<Int> (opt_get1 $Snap.unit G@24@06)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@178@06  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@184@06)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@184@06))
        (not
          (=
            ($FVF.lookup_option$array$ (as sm@178@06  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@184@06))
            (as None<option<array>>  option<array>)))))
    :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@178@06  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@184@06)))))
    :qid |prog.l<no position>-aux|))))
(push) ; 16
(assert (not (implies
  (= exc@159@06 $Ref.null)
  (forall ((i1@184@06 Int)) (!
    (implies
      (and (< i1@184@06 V@27@06) (<= 0 i1@184@06))
      (=
        (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@178@06  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@184@06))))
        V@27@06))
    :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@178@06  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@184@06)))))
    :qid |prog.l<no position>|)))))
(check-sat)
; unsat
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               20782
;  :arith-add-rows          14618
;  :arith-assert-diseq      1353
;  :arith-assert-lower      5675
;  :arith-assert-upper      3643
;  :arith-bound-prop        1939
;  :arith-conflicts         407
;  :arith-eq-adapter        3941
;  :arith-fixed-eqs         1828
;  :arith-offset-eqs        2247
;  :arith-pivots            3349
;  :conflicts               963
;  :datatype-accessor-ax    77
;  :datatype-constructor-ax 608
;  :datatype-occurs-check   416
;  :datatype-splits         355
;  :decisions               2361
;  :del-clause              27489
;  :final-checks            165
;  :interface-eqs           6
;  :max-generation          8
;  :max-memory              8.29
;  :memory                  8.24
;  :minimized-lits          95
;  :mk-bool-var             38476
;  :mk-clause               27528
;  :num-allocs              398894
;  :num-checks              270
;  :propagations            12788
;  :quant-instantiations    8818
;  :rlimit-count            1124420
;  :time                    0.00)
(assert (implies
  (= exc@159@06 $Ref.null)
  (forall ((i1@184@06 Int)) (!
    (implies
      (and (< i1@184@06 V@27@06) (<= 0 i1@184@06))
      (=
        (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@178@06  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@184@06))))
        V@27@06))
    :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@178@06  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@184@06)))))
    :qid |prog.l<no position>|))))
; [eval] exc == null ==> (forall i1: Int :: { aloc(opt_get1(G), i1) } (forall i2: Int :: { aloc(opt_get1(G), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(G), i1).option$array$ == aloc(opt_get1(G), i2).option$array$ ==> i1 == i2))
; [eval] exc == null
(push) ; 16
(set-option :timeout 10)
(push) ; 17
(assert (not (not (= exc@159@06 $Ref.null))))
(check-sat)
; unknown
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               20844
;  :arith-add-rows          14618
;  :arith-assert-diseq      1353
;  :arith-assert-lower      5675
;  :arith-assert-upper      3643
;  :arith-bound-prop        1939
;  :arith-conflicts         407
;  :arith-eq-adapter        3941
;  :arith-fixed-eqs         1828
;  :arith-offset-eqs        2247
;  :arith-pivots            3349
;  :conflicts               963
;  :datatype-accessor-ax    77
;  :datatype-constructor-ax 619
;  :datatype-occurs-check   428
;  :datatype-splits         364
;  :decisions               2372
;  :del-clause              27489
;  :final-checks            167
;  :interface-eqs           6
;  :max-generation          8
;  :max-memory              8.29
;  :memory                  8.25
;  :minimized-lits          95
;  :mk-bool-var             38486
;  :mk-clause               27528
;  :num-allocs              399824
;  :num-checks              271
;  :propagations            12788
;  :quant-instantiations    8818
;  :rlimit-count            1125557)
; [then-branch: 175 | exc@159@06 == Null | live]
; [else-branch: 175 | exc@159@06 != Null | dead]
(push) ; 17
; [then-branch: 175 | exc@159@06 == Null]
; [eval] (forall i1: Int :: { aloc(opt_get1(G), i1) } (forall i2: Int :: { aloc(opt_get1(G), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(G), i1).option$array$ == aloc(opt_get1(G), i2).option$array$ ==> i1 == i2))
(declare-const i1@185@06 Int)
(push) ; 18
; [eval] (forall i2: Int :: { aloc(opt_get1(G), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(G), i1).option$array$ == aloc(opt_get1(G), i2).option$array$ ==> i1 == i2)
(declare-const i2@186@06 Int)
(push) ; 19
; [eval] 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(G), i1).option$array$ == aloc(opt_get1(G), i2).option$array$ ==> i1 == i2
; [eval] 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(G), i1).option$array$ == aloc(opt_get1(G), i2).option$array$
; [eval] 0 <= i1
(push) ; 20
; [then-branch: 176 | 0 <= i1@185@06 | live]
; [else-branch: 176 | !(0 <= i1@185@06) | live]
(push) ; 21
; [then-branch: 176 | 0 <= i1@185@06]
(assert (<= 0 i1@185@06))
; [eval] i1 < V
(push) ; 22
; [then-branch: 177 | i1@185@06 < V@27@06 | live]
; [else-branch: 177 | !(i1@185@06 < V@27@06) | live]
(push) ; 23
; [then-branch: 177 | i1@185@06 < V@27@06]
(assert (< i1@185@06 V@27@06))
; [eval] 0 <= i2
(push) ; 24
; [then-branch: 178 | 0 <= i2@186@06 | live]
; [else-branch: 178 | !(0 <= i2@186@06) | live]
(push) ; 25
; [then-branch: 178 | 0 <= i2@186@06]
(assert (<= 0 i2@186@06))
; [eval] i2 < V
(push) ; 26
; [then-branch: 179 | i2@186@06 < V@27@06 | live]
; [else-branch: 179 | !(i2@186@06 < V@27@06) | live]
(push) ; 27
; [then-branch: 179 | i2@186@06 < V@27@06]
(assert (< i2@186@06 V@27@06))
; [eval] aloc(opt_get1(G), i1).option$array$ == aloc(opt_get1(G), i2).option$array$
; [eval] aloc(opt_get1(G), i1)
; [eval] opt_get1(G)
(push) ; 28
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 28
; Joined path conditions
(push) ; 28
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 29
(assert (not (< i1@185@06 (alen<Int> (opt_get1 $Snap.unit G@24@06)))))
(check-sat)
; unsat
(pop) ; 29
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               20844
;  :arith-add-rows          14620
;  :arith-assert-diseq      1353
;  :arith-assert-lower      5679
;  :arith-assert-upper      3643
;  :arith-bound-prop        1939
;  :arith-conflicts         407
;  :arith-eq-adapter        3941
;  :arith-fixed-eqs         1828
;  :arith-offset-eqs        2247
;  :arith-pivots            3349
;  :conflicts               963
;  :datatype-accessor-ax    77
;  :datatype-constructor-ax 619
;  :datatype-occurs-check   428
;  :datatype-splits         364
;  :decisions               2372
;  :del-clause              27489
;  :final-checks            167
;  :interface-eqs           6
;  :max-generation          8
;  :max-memory              8.29
;  :memory                  8.25
;  :minimized-lits          95
;  :mk-bool-var             38490
;  :mk-clause               27528
;  :num-allocs              400112
;  :num-checks              272
;  :propagations            12788
;  :quant-instantiations    8818
;  :rlimit-count            1125897)
(assert (< i1@185@06 (alen<Int> (opt_get1 $Snap.unit G@24@06))))
(pop) ; 28
; Joined path conditions
(assert (< i1@185@06 (alen<Int> (opt_get1 $Snap.unit G@24@06))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@178@06  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@185@06)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@185@06)))
(push) ; 28
(assert (not (<
  $Perm.No
  (+
    (+
      (+
        (-
          (-
            (ite
              (and
                (<
                  (inv@33@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@185@06))
                  V@27@06)
                (<=
                  0
                  (inv@33@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@185@06))))
              $k@32@06
              $Perm.No)
            (pTaken@88@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@185@06)))
          (pTaken@97@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@185@06)))
        (-
          (-
            (ite
              (and
                (<
                  (inv@71@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@185@06))
                  V@27@06)
                (<=
                  0
                  (inv@71@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@185@06))))
              $Perm.Write
              $Perm.No)
            (pTaken@87@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@185@06)))
          (pTaken@98@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@185@06))))
      (ite
        (and
          (<
            (inv@121@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@185@06))
            V@27@06)
          (<=
            0
            (inv@121@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@185@06))))
        $k@120@06
        $Perm.No))
    (ite
      (and
        (<
          (inv@129@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@185@06))
          V@27@06)
        (<=
          0
          (inv@129@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@185@06))))
      $k@128@06
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 28
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               22189
;  :arith-add-rows          15856
;  :arith-assert-diseq      1476
;  :arith-assert-lower      6145
;  :arith-assert-upper      3912
;  :arith-bound-prop        2064
;  :arith-conflicts         426
;  :arith-eq-adapter        4253
;  :arith-fixed-eqs         1972
;  :arith-offset-eqs        2409
;  :arith-pivots            3510
;  :conflicts               1006
;  :datatype-accessor-ax    77
;  :datatype-constructor-ax 621
;  :datatype-occurs-check   428
;  :datatype-splits         364
;  :decisions               2449
;  :del-clause              28799
;  :final-checks            167
;  :interface-eqs           6
;  :max-generation          8
;  :max-memory              8.36
;  :memory                  8.34
;  :minimized-lits          108
;  :mk-bool-var             40325
;  :mk-clause               29022
;  :num-allocs              408430
;  :num-checks              273
;  :propagations            13885
;  :quant-instantiations    9324
;  :rlimit-count            1186495
;  :time                    0.01)
; [eval] aloc(opt_get1(G), i2)
; [eval] opt_get1(G)
(push) ; 28
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 28
; Joined path conditions
(push) ; 28
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 29
(assert (not (< i2@186@06 (alen<Int> (opt_get1 $Snap.unit G@24@06)))))
(check-sat)
; unsat
(pop) ; 29
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               22189
;  :arith-add-rows          15856
;  :arith-assert-diseq      1476
;  :arith-assert-lower      6145
;  :arith-assert-upper      3912
;  :arith-bound-prop        2064
;  :arith-conflicts         426
;  :arith-eq-adapter        4253
;  :arith-fixed-eqs         1972
;  :arith-offset-eqs        2409
;  :arith-pivots            3510
;  :conflicts               1006
;  :datatype-accessor-ax    77
;  :datatype-constructor-ax 621
;  :datatype-occurs-check   428
;  :datatype-splits         364
;  :decisions               2449
;  :del-clause              28799
;  :final-checks            167
;  :interface-eqs           6
;  :max-generation          8
;  :max-memory              8.36
;  :memory                  8.34
;  :minimized-lits          108
;  :mk-bool-var             40325
;  :mk-clause               29022
;  :num-allocs              408456
;  :num-checks              274
;  :propagations            13885
;  :quant-instantiations    9324
;  :rlimit-count            1186525)
(assert (< i2@186@06 (alen<Int> (opt_get1 $Snap.unit G@24@06))))
(pop) ; 28
; Joined path conditions
(assert (< i2@186@06 (alen<Int> (opt_get1 $Snap.unit G@24@06))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@178@06  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@24@06) i2@186@06)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@24@06) i2@186@06)))
(push) ; 28
(assert (not (<
  $Perm.No
  (+
    (+
      (+
        (-
          (-
            (ite
              (and
                (<
                  (inv@33@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i2@186@06))
                  V@27@06)
                (<=
                  0
                  (inv@33@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i2@186@06))))
              $k@32@06
              $Perm.No)
            (pTaken@88@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i2@186@06)))
          (pTaken@97@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i2@186@06)))
        (-
          (-
            (ite
              (and
                (<
                  (inv@71@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i2@186@06))
                  V@27@06)
                (<=
                  0
                  (inv@71@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i2@186@06))))
              $Perm.Write
              $Perm.No)
            (pTaken@87@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i2@186@06)))
          (pTaken@98@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i2@186@06))))
      (ite
        (and
          (<
            (inv@121@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i2@186@06))
            V@27@06)
          (<=
            0
            (inv@121@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i2@186@06))))
        $k@120@06
        $Perm.No))
    (ite
      (and
        (<
          (inv@129@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i2@186@06))
          V@27@06)
        (<=
          0
          (inv@129@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i2@186@06))))
      $k@128@06
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 28
; 0.03s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               25333
;  :arith-add-rows          18117
;  :arith-assert-diseq      1705
;  :arith-assert-lower      7175
;  :arith-assert-upper      4519
;  :arith-bound-prop        2307
;  :arith-conflicts         457
;  :arith-eq-adapter        4875
;  :arith-fixed-eqs         2338
;  :arith-offset-eqs        2774
;  :arith-pivots            3776
;  :conflicts               1062
;  :datatype-accessor-ax    77
;  :datatype-constructor-ax 623
;  :datatype-occurs-check   428
;  :datatype-splits         364
;  :decisions               2777
;  :del-clause              33209
;  :final-checks            167
;  :interface-eqs           6
;  :max-generation          8
;  :max-memory              10.04
;  :memory                  9.43
;  :minimized-lits          122
;  :mk-bool-var             44928
;  :mk-clause               33619
;  :num-allocs              424882
;  :num-checks              275
;  :propagations            16699
;  :quant-instantiations    10691
;  :rlimit-count            1318370
;  :time                    0.03)
(pop) ; 27
(push) ; 27
; [else-branch: 179 | !(i2@186@06 < V@27@06)]
(assert (not (< i2@186@06 V@27@06)))
(pop) ; 27
(pop) ; 26
; Joined path conditions
(assert (implies
  (< i2@186@06 V@27@06)
  (and
    (< i2@186@06 V@27@06)
    (< i1@185@06 (alen<Int> (opt_get1 $Snap.unit G@24@06)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@178@06  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@185@06)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@185@06))
    (< i2@186@06 (alen<Int> (opt_get1 $Snap.unit G@24@06)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@178@06  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@24@06) i2@186@06)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@24@06) i2@186@06)))))
; Joined path conditions
(pop) ; 25
(push) ; 25
; [else-branch: 178 | !(0 <= i2@186@06)]
(assert (not (<= 0 i2@186@06)))
(pop) ; 25
(pop) ; 24
; Joined path conditions
(assert (implies
  (<= 0 i2@186@06)
  (and
    (<= 0 i2@186@06)
    (implies
      (< i2@186@06 V@27@06)
      (and
        (< i2@186@06 V@27@06)
        (< i1@185@06 (alen<Int> (opt_get1 $Snap.unit G@24@06)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@178@06  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@185@06)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@185@06))
        (< i2@186@06 (alen<Int> (opt_get1 $Snap.unit G@24@06)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@178@06  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@24@06) i2@186@06)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@24@06) i2@186@06)))))))
; Joined path conditions
(pop) ; 23
(push) ; 23
; [else-branch: 177 | !(i1@185@06 < V@27@06)]
(assert (not (< i1@185@06 V@27@06)))
(pop) ; 23
(pop) ; 22
; Joined path conditions
(assert (implies
  (< i1@185@06 V@27@06)
  (and
    (< i1@185@06 V@27@06)
    (implies
      (<= 0 i2@186@06)
      (and
        (<= 0 i2@186@06)
        (implies
          (< i2@186@06 V@27@06)
          (and
            (< i2@186@06 V@27@06)
            (< i1@185@06 (alen<Int> (opt_get1 $Snap.unit G@24@06)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@178@06  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@185@06)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@185@06))
            (< i2@186@06 (alen<Int> (opt_get1 $Snap.unit G@24@06)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@178@06  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@24@06) i2@186@06)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@24@06) i2@186@06)))))))))
; Joined path conditions
(pop) ; 21
(push) ; 21
; [else-branch: 176 | !(0 <= i1@185@06)]
(assert (not (<= 0 i1@185@06)))
(pop) ; 21
(pop) ; 20
; Joined path conditions
(assert (implies
  (<= 0 i1@185@06)
  (and
    (<= 0 i1@185@06)
    (implies
      (< i1@185@06 V@27@06)
      (and
        (< i1@185@06 V@27@06)
        (implies
          (<= 0 i2@186@06)
          (and
            (<= 0 i2@186@06)
            (implies
              (< i2@186@06 V@27@06)
              (and
                (< i2@186@06 V@27@06)
                (< i1@185@06 (alen<Int> (opt_get1 $Snap.unit G@24@06)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@178@06  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@185@06)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@185@06))
                (< i2@186@06 (alen<Int> (opt_get1 $Snap.unit G@24@06)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@178@06  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@24@06) i2@186@06)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@24@06) i2@186@06)))))))))))
; Joined path conditions
(push) ; 20
; [then-branch: 180 | Lookup(option$array$,sm@178@06,aloc((_, _), opt_get1(_, G@24@06), i1@185@06)) == Lookup(option$array$,sm@178@06,aloc((_, _), opt_get1(_, G@24@06), i2@186@06)) && i2@186@06 < V@27@06 && 0 <= i2@186@06 && i1@185@06 < V@27@06 && 0 <= i1@185@06 | live]
; [else-branch: 180 | !(Lookup(option$array$,sm@178@06,aloc((_, _), opt_get1(_, G@24@06), i1@185@06)) == Lookup(option$array$,sm@178@06,aloc((_, _), opt_get1(_, G@24@06), i2@186@06)) && i2@186@06 < V@27@06 && 0 <= i2@186@06 && i1@185@06 < V@27@06 && 0 <= i1@185@06) | live]
(push) ; 21
; [then-branch: 180 | Lookup(option$array$,sm@178@06,aloc((_, _), opt_get1(_, G@24@06), i1@185@06)) == Lookup(option$array$,sm@178@06,aloc((_, _), opt_get1(_, G@24@06), i2@186@06)) && i2@186@06 < V@27@06 && 0 <= i2@186@06 && i1@185@06 < V@27@06 && 0 <= i1@185@06]
(assert (and
  (and
    (and
      (and
        (=
          ($FVF.lookup_option$array$ (as sm@178@06  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@185@06))
          ($FVF.lookup_option$array$ (as sm@178@06  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@24@06) i2@186@06)))
        (< i2@186@06 V@27@06))
      (<= 0 i2@186@06))
    (< i1@185@06 V@27@06))
  (<= 0 i1@185@06)))
; [eval] i1 == i2
(pop) ; 21
(push) ; 21
; [else-branch: 180 | !(Lookup(option$array$,sm@178@06,aloc((_, _), opt_get1(_, G@24@06), i1@185@06)) == Lookup(option$array$,sm@178@06,aloc((_, _), opt_get1(_, G@24@06), i2@186@06)) && i2@186@06 < V@27@06 && 0 <= i2@186@06 && i1@185@06 < V@27@06 && 0 <= i1@185@06)]
(assert (not
  (and
    (and
      (and
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@178@06  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@185@06))
            ($FVF.lookup_option$array$ (as sm@178@06  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@24@06) i2@186@06)))
          (< i2@186@06 V@27@06))
        (<= 0 i2@186@06))
      (< i1@185@06 V@27@06))
    (<= 0 i1@185@06))))
(pop) ; 21
(pop) ; 20
; Joined path conditions
(assert (implies
  (and
    (and
      (and
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@178@06  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@185@06))
            ($FVF.lookup_option$array$ (as sm@178@06  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@24@06) i2@186@06)))
          (< i2@186@06 V@27@06))
        (<= 0 i2@186@06))
      (< i1@185@06 V@27@06))
    (<= 0 i1@185@06))
  (and
    (=
      ($FVF.lookup_option$array$ (as sm@178@06  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@185@06))
      ($FVF.lookup_option$array$ (as sm@178@06  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@24@06) i2@186@06)))
    (< i2@186@06 V@27@06)
    (<= 0 i2@186@06)
    (< i1@185@06 V@27@06)
    (<= 0 i1@185@06))))
; Joined path conditions
(pop) ; 19
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i2@186@06 Int)) (!
  (and
    (implies
      (<= 0 i1@185@06)
      (and
        (<= 0 i1@185@06)
        (implies
          (< i1@185@06 V@27@06)
          (and
            (< i1@185@06 V@27@06)
            (implies
              (<= 0 i2@186@06)
              (and
                (<= 0 i2@186@06)
                (implies
                  (< i2@186@06 V@27@06)
                  (and
                    (< i2@186@06 V@27@06)
                    (< i1@185@06 (alen<Int> (opt_get1 $Snap.unit G@24@06)))
                    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@178@06  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@185@06)) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@185@06))
                    (< i2@186@06 (alen<Int> (opt_get1 $Snap.unit G@24@06)))
                    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@178@06  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit G@24@06) i2@186@06)) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit G@24@06) i2@186@06))))))))))
    (implies
      (and
        (and
          (and
            (and
              (=
                ($FVF.lookup_option$array$ (as sm@178@06  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@185@06))
                ($FVF.lookup_option$array$ (as sm@178@06  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@24@06) i2@186@06)))
              (< i2@186@06 V@27@06))
            (<= 0 i2@186@06))
          (< i1@185@06 V@27@06))
        (<= 0 i1@185@06))
      (and
        (=
          ($FVF.lookup_option$array$ (as sm@178@06  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@185@06))
          ($FVF.lookup_option$array$ (as sm@178@06  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@24@06) i2@186@06)))
        (< i2@186@06 V@27@06)
        (<= 0 i2@186@06)
        (< i1@185@06 V@27@06)
        (<= 0 i1@185@06))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i2@186@06))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 18
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@185@06 Int)) (!
  (forall ((i2@186@06 Int)) (!
    (and
      (implies
        (<= 0 i1@185@06)
        (and
          (<= 0 i1@185@06)
          (implies
            (< i1@185@06 V@27@06)
            (and
              (< i1@185@06 V@27@06)
              (implies
                (<= 0 i2@186@06)
                (and
                  (<= 0 i2@186@06)
                  (implies
                    (< i2@186@06 V@27@06)
                    (and
                      (< i2@186@06 V@27@06)
                      (< i1@185@06 (alen<Int> (opt_get1 $Snap.unit G@24@06)))
                      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@178@06  $FVF<option<array>>) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@185@06)) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@185@06))
                      (< i2@186@06 (alen<Int> (opt_get1 $Snap.unit G@24@06)))
                      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@178@06  $FVF<option<array>>) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit G@24@06) i2@186@06)) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit G@24@06) i2@186@06))))))))))
      (implies
        (and
          (and
            (and
              (and
                (=
                  ($FVF.lookup_option$array$ (as sm@178@06  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@185@06))
                  ($FVF.lookup_option$array$ (as sm@178@06  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit G@24@06) i2@186@06)))
                (< i2@186@06 V@27@06))
              (<= 0 i2@186@06))
            (< i1@185@06 V@27@06))
          (<= 0 i1@185@06))
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@178@06  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@185@06))
            ($FVF.lookup_option$array$ (as sm@178@06  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@24@06) i2@186@06)))
          (< i2@186@06 V@27@06)
          (<= 0 i2@186@06)
          (< i1@185@06 V@27@06)
          (<= 0 i1@185@06))))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i2@186@06))
    :qid |prog.l<no position>-aux|))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@185@06))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 17
(pop) ; 16
; Joined path conditions
(assert (implies
  (= exc@159@06 $Ref.null)
  (forall ((i1@185@06 Int)) (!
    (forall ((i2@186@06 Int)) (!
      (and
        (implies
          (<= 0 i1@185@06)
          (and
            (<= 0 i1@185@06)
            (implies
              (< i1@185@06 V@27@06)
              (and
                (< i1@185@06 V@27@06)
                (implies
                  (<= 0 i2@186@06)
                  (and
                    (<= 0 i2@186@06)
                    (implies
                      (< i2@186@06 V@27@06)
                      (and
                        (< i2@186@06 V@27@06)
                        (< i1@185@06 (alen<Int> (opt_get1 $Snap.unit G@24@06)))
                        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@178@06  $FVF<option<array>>) (aloc ($Snap.combine
                          $Snap.unit
                          $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@185@06)) (aloc ($Snap.combine
                          $Snap.unit
                          $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@185@06))
                        (< i2@186@06 (alen<Int> (opt_get1 $Snap.unit G@24@06)))
                        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@178@06  $FVF<option<array>>) (aloc ($Snap.combine
                          $Snap.unit
                          $Snap.unit) (opt_get1 $Snap.unit G@24@06) i2@186@06)) (aloc ($Snap.combine
                          $Snap.unit
                          $Snap.unit) (opt_get1 $Snap.unit G@24@06) i2@186@06))))))))))
        (implies
          (and
            (and
              (and
                (and
                  (=
                    ($FVF.lookup_option$array$ (as sm@178@06  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@185@06))
                    ($FVF.lookup_option$array$ (as sm@178@06  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit G@24@06) i2@186@06)))
                  (< i2@186@06 V@27@06))
                (<= 0 i2@186@06))
              (< i1@185@06 V@27@06))
            (<= 0 i1@185@06))
          (and
            (=
              ($FVF.lookup_option$array$ (as sm@178@06  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@185@06))
              ($FVF.lookup_option$array$ (as sm@178@06  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit G@24@06) i2@186@06)))
            (< i2@186@06 V@27@06)
            (<= 0 i2@186@06)
            (< i1@185@06 V@27@06)
            (<= 0 i1@185@06))))
      :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i2@186@06))
      :qid |prog.l<no position>-aux|))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@185@06))
    :qid |prog.l<no position>-aux|))))
(push) ; 16
(assert (not (implies
  (= exc@159@06 $Ref.null)
  (forall ((i1@185@06 Int)) (!
    (forall ((i2@186@06 Int)) (!
      (implies
        (and
          (and
            (and
              (and
                (=
                  ($FVF.lookup_option$array$ (as sm@178@06  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@185@06))
                  ($FVF.lookup_option$array$ (as sm@178@06  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit G@24@06) i2@186@06)))
                (< i2@186@06 V@27@06))
              (<= 0 i2@186@06))
            (< i1@185@06 V@27@06))
          (<= 0 i1@185@06))
        (= i1@185@06 i2@186@06))
      :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i2@186@06))
      :qid |prog.l<no position>|))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@185@06))
    :qid |prog.l<no position>|)))))
(check-sat)
; unsat
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               25506
;  :arith-add-rows          18324
;  :arith-assert-diseq      1707
;  :arith-assert-lower      7200
;  :arith-assert-upper      4548
;  :arith-bound-prop        2341
;  :arith-conflicts         460
;  :arith-eq-adapter        4900
;  :arith-fixed-eqs         2355
;  :arith-offset-eqs        2805
;  :arith-pivots            3858
;  :conflicts               1069
;  :datatype-accessor-ax    77
;  :datatype-constructor-ax 625
;  :datatype-occurs-check   428
;  :datatype-splits         364
;  :decisions               2788
;  :del-clause              33994
;  :final-checks            167
;  :interface-eqs           6
;  :max-generation          8
;  :max-memory              10.04
;  :memory                  9.36
;  :minimized-lits          122
;  :mk-bool-var             45513
;  :mk-clause               34033
;  :num-allocs              428290
;  :num-checks              276
;  :propagations            16787
;  :quant-instantiations    10837
;  :rlimit-count            1334001
;  :time                    0.00)
(assert (implies
  (= exc@159@06 $Ref.null)
  (forall ((i1@185@06 Int)) (!
    (forall ((i2@186@06 Int)) (!
      (implies
        (and
          (and
            (and
              (and
                (=
                  ($FVF.lookup_option$array$ (as sm@178@06  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@185@06))
                  ($FVF.lookup_option$array$ (as sm@178@06  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit G@24@06) i2@186@06)))
                (< i2@186@06 V@27@06))
              (<= 0 i2@186@06))
            (< i1@185@06 V@27@06))
          (<= 0 i1@185@06))
        (= i1@185@06 i2@186@06))
      :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i2@186@06))
      :qid |prog.l<no position>|))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@185@06))
    :qid |prog.l<no position>|))))
; [eval] exc == null ==> 0 <= s
; [eval] exc == null
(push) ; 16
(set-option :timeout 10)
(push) ; 17
(assert (not (not (= exc@159@06 $Ref.null))))
(check-sat)
; unknown
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               25568
;  :arith-add-rows          18324
;  :arith-assert-diseq      1707
;  :arith-assert-lower      7200
;  :arith-assert-upper      4548
;  :arith-bound-prop        2341
;  :arith-conflicts         460
;  :arith-eq-adapter        4900
;  :arith-fixed-eqs         2355
;  :arith-offset-eqs        2805
;  :arith-pivots            3858
;  :conflicts               1069
;  :datatype-accessor-ax    77
;  :datatype-constructor-ax 636
;  :datatype-occurs-check   440
;  :datatype-splits         373
;  :decisions               2799
;  :del-clause              33994
;  :final-checks            169
;  :interface-eqs           6
;  :max-generation          8
;  :max-memory              10.04
;  :memory                  9.37
;  :minimized-lits          122
;  :mk-bool-var             45523
;  :mk-clause               34033
;  :num-allocs              429346
;  :num-checks              277
;  :propagations            16787
;  :quant-instantiations    10837
;  :rlimit-count            1335360)
; [then-branch: 181 | exc@159@06 == Null | live]
; [else-branch: 181 | exc@159@06 != Null | dead]
(push) ; 17
; [then-branch: 181 | exc@159@06 == Null]
; [eval] 0 <= s
(pop) ; 17
(pop) ; 16
; Joined path conditions
(set-option :timeout 0)
(push) ; 16
(assert (not (implies (= exc@159@06 $Ref.null) (<= 0 s@25@06))))
(check-sat)
; unsat
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               25568
;  :arith-add-rows          18324
;  :arith-assert-diseq      1707
;  :arith-assert-lower      7200
;  :arith-assert-upper      4548
;  :arith-bound-prop        2341
;  :arith-conflicts         460
;  :arith-eq-adapter        4900
;  :arith-fixed-eqs         2355
;  :arith-offset-eqs        2805
;  :arith-pivots            3858
;  :conflicts               1069
;  :datatype-accessor-ax    77
;  :datatype-constructor-ax 636
;  :datatype-occurs-check   440
;  :datatype-splits         373
;  :decisions               2799
;  :del-clause              33994
;  :final-checks            169
;  :interface-eqs           6
;  :max-generation          8
;  :max-memory              10.04
;  :memory                  9.37
;  :minimized-lits          122
;  :mk-bool-var             45523
;  :mk-clause               34033
;  :num-allocs              429374
;  :num-checks              278
;  :propagations            16787
;  :quant-instantiations    10837
;  :rlimit-count            1335386)
(assert (implies (= exc@159@06 $Ref.null) (<= 0 s@25@06)))
; [eval] exc == null ==> s < V
; [eval] exc == null
(push) ; 16
(set-option :timeout 10)
(push) ; 17
(assert (not (not (= exc@159@06 $Ref.null))))
(check-sat)
; unknown
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               25630
;  :arith-add-rows          18324
;  :arith-assert-diseq      1707
;  :arith-assert-lower      7200
;  :arith-assert-upper      4548
;  :arith-bound-prop        2341
;  :arith-conflicts         460
;  :arith-eq-adapter        4900
;  :arith-fixed-eqs         2355
;  :arith-offset-eqs        2805
;  :arith-pivots            3858
;  :conflicts               1069
;  :datatype-accessor-ax    77
;  :datatype-constructor-ax 647
;  :datatype-occurs-check   452
;  :datatype-splits         382
;  :decisions               2810
;  :del-clause              33994
;  :final-checks            171
;  :interface-eqs           6
;  :max-generation          8
;  :max-memory              10.04
;  :memory                  9.37
;  :minimized-lits          122
;  :mk-bool-var             45532
;  :mk-clause               34033
;  :num-allocs              430146
;  :num-checks              279
;  :propagations            16787
;  :quant-instantiations    10837
;  :rlimit-count            1336233)
; [then-branch: 182 | exc@159@06 == Null | live]
; [else-branch: 182 | exc@159@06 != Null | dead]
(push) ; 17
; [then-branch: 182 | exc@159@06 == Null]
; [eval] s < V
(pop) ; 17
(pop) ; 16
; Joined path conditions
(set-option :timeout 0)
(push) ; 16
(assert (not (implies (= exc@159@06 $Ref.null) (< s@25@06 V@27@06))))
(check-sat)
; unsat
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               25630
;  :arith-add-rows          18324
;  :arith-assert-diseq      1707
;  :arith-assert-lower      7200
;  :arith-assert-upper      4548
;  :arith-bound-prop        2341
;  :arith-conflicts         460
;  :arith-eq-adapter        4900
;  :arith-fixed-eqs         2355
;  :arith-offset-eqs        2805
;  :arith-pivots            3858
;  :conflicts               1069
;  :datatype-accessor-ax    77
;  :datatype-constructor-ax 647
;  :datatype-occurs-check   452
;  :datatype-splits         382
;  :decisions               2810
;  :del-clause              33994
;  :final-checks            171
;  :interface-eqs           6
;  :max-generation          8
;  :max-memory              10.04
;  :memory                  9.37
;  :minimized-lits          122
;  :mk-bool-var             45532
;  :mk-clause               34033
;  :num-allocs              430174
;  :num-checks              280
;  :propagations            16787
;  :quant-instantiations    10837
;  :rlimit-count            1336262)
(assert (implies (= exc@159@06 $Ref.null) (< s@25@06 V@27@06)))
; [eval] exc == null ==> 0 <= t
; [eval] exc == null
(push) ; 16
(set-option :timeout 10)
(push) ; 17
(assert (not (not (= exc@159@06 $Ref.null))))
(check-sat)
; unknown
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               25692
;  :arith-add-rows          18324
;  :arith-assert-diseq      1707
;  :arith-assert-lower      7200
;  :arith-assert-upper      4548
;  :arith-bound-prop        2341
;  :arith-conflicts         460
;  :arith-eq-adapter        4900
;  :arith-fixed-eqs         2355
;  :arith-offset-eqs        2805
;  :arith-pivots            3858
;  :conflicts               1069
;  :datatype-accessor-ax    77
;  :datatype-constructor-ax 658
;  :datatype-occurs-check   464
;  :datatype-splits         391
;  :decisions               2821
;  :del-clause              33994
;  :final-checks            173
;  :interface-eqs           6
;  :max-generation          8
;  :max-memory              10.04
;  :memory                  9.37
;  :minimized-lits          122
;  :mk-bool-var             45541
;  :mk-clause               34033
;  :num-allocs              430946
;  :num-checks              281
;  :propagations            16787
;  :quant-instantiations    10837
;  :rlimit-count            1337114)
; [then-branch: 183 | exc@159@06 == Null | live]
; [else-branch: 183 | exc@159@06 != Null | dead]
(push) ; 17
; [then-branch: 183 | exc@159@06 == Null]
; [eval] 0 <= t
(pop) ; 17
(pop) ; 16
; Joined path conditions
(set-option :timeout 0)
(push) ; 16
(assert (not (implies (= exc@159@06 $Ref.null) (<= 0 t@26@06))))
(check-sat)
; unsat
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               25692
;  :arith-add-rows          18324
;  :arith-assert-diseq      1707
;  :arith-assert-lower      7200
;  :arith-assert-upper      4548
;  :arith-bound-prop        2341
;  :arith-conflicts         460
;  :arith-eq-adapter        4900
;  :arith-fixed-eqs         2355
;  :arith-offset-eqs        2805
;  :arith-pivots            3858
;  :conflicts               1069
;  :datatype-accessor-ax    77
;  :datatype-constructor-ax 658
;  :datatype-occurs-check   464
;  :datatype-splits         391
;  :decisions               2821
;  :del-clause              33994
;  :final-checks            173
;  :interface-eqs           6
;  :max-generation          8
;  :max-memory              10.04
;  :memory                  9.37
;  :minimized-lits          122
;  :mk-bool-var             45541
;  :mk-clause               34033
;  :num-allocs              430974
;  :num-checks              282
;  :propagations            16787
;  :quant-instantiations    10837
;  :rlimit-count            1337140)
(assert (implies (= exc@159@06 $Ref.null) (<= 0 t@26@06)))
; [eval] exc == null ==> t < V
; [eval] exc == null
(push) ; 16
(set-option :timeout 10)
(push) ; 17
(assert (not (not (= exc@159@06 $Ref.null))))
(check-sat)
; unknown
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               25754
;  :arith-add-rows          18324
;  :arith-assert-diseq      1707
;  :arith-assert-lower      7200
;  :arith-assert-upper      4548
;  :arith-bound-prop        2341
;  :arith-conflicts         460
;  :arith-eq-adapter        4900
;  :arith-fixed-eqs         2355
;  :arith-offset-eqs        2805
;  :arith-pivots            3858
;  :conflicts               1069
;  :datatype-accessor-ax    77
;  :datatype-constructor-ax 669
;  :datatype-occurs-check   476
;  :datatype-splits         400
;  :decisions               2832
;  :del-clause              33994
;  :final-checks            175
;  :interface-eqs           6
;  :max-generation          8
;  :max-memory              10.04
;  :memory                  9.37
;  :minimized-lits          122
;  :mk-bool-var             45550
;  :mk-clause               34033
;  :num-allocs              431746
;  :num-checks              283
;  :propagations            16787
;  :quant-instantiations    10837
;  :rlimit-count            1337987)
; [then-branch: 184 | exc@159@06 == Null | live]
; [else-branch: 184 | exc@159@06 != Null | dead]
(push) ; 17
; [then-branch: 184 | exc@159@06 == Null]
; [eval] t < V
(pop) ; 17
(pop) ; 16
; Joined path conditions
(set-option :timeout 0)
(push) ; 16
(assert (not (implies (= exc@159@06 $Ref.null) (< t@26@06 V@27@06))))
(check-sat)
; unsat
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               25754
;  :arith-add-rows          18324
;  :arith-assert-diseq      1707
;  :arith-assert-lower      7200
;  :arith-assert-upper      4548
;  :arith-bound-prop        2341
;  :arith-conflicts         460
;  :arith-eq-adapter        4900
;  :arith-fixed-eqs         2355
;  :arith-offset-eqs        2805
;  :arith-pivots            3858
;  :conflicts               1069
;  :datatype-accessor-ax    77
;  :datatype-constructor-ax 669
;  :datatype-occurs-check   476
;  :datatype-splits         400
;  :decisions               2832
;  :del-clause              33994
;  :final-checks            175
;  :interface-eqs           6
;  :max-generation          8
;  :max-memory              10.04
;  :memory                  9.37
;  :minimized-lits          122
;  :mk-bool-var             45550
;  :mk-clause               34033
;  :num-allocs              431774
;  :num-checks              284
;  :propagations            16787
;  :quant-instantiations    10837
;  :rlimit-count            1338016)
(assert (implies (= exc@159@06 $Ref.null) (< t@26@06 V@27@06)))
; [eval] exc == null
(set-option :timeout 10)
(push) ; 16
(assert (not (not (= exc@159@06 $Ref.null))))
(check-sat)
; unknown
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               25816
;  :arith-add-rows          18324
;  :arith-assert-diseq      1707
;  :arith-assert-lower      7200
;  :arith-assert-upper      4548
;  :arith-bound-prop        2341
;  :arith-conflicts         460
;  :arith-eq-adapter        4900
;  :arith-fixed-eqs         2355
;  :arith-offset-eqs        2805
;  :arith-pivots            3858
;  :conflicts               1069
;  :datatype-accessor-ax    77
;  :datatype-constructor-ax 680
;  :datatype-occurs-check   488
;  :datatype-splits         409
;  :decisions               2843
;  :del-clause              33994
;  :final-checks            177
;  :interface-eqs           6
;  :max-generation          8
;  :max-memory              10.04
;  :memory                  9.37
;  :minimized-lits          122
;  :mk-bool-var             45559
;  :mk-clause               34033
;  :num-allocs              432546
;  :num-checks              285
;  :propagations            16787
;  :quant-instantiations    10837
;  :rlimit-count            1338863)
; [then-branch: 185 | exc@159@06 == Null | live]
; [else-branch: 185 | exc@159@06 != Null | dead]
(push) ; 16
; [then-branch: 185 | exc@159@06 == Null]
(declare-const i1@187@06 Int)
(declare-const j1@188@06 Int)
(push) ; 17
; [eval] 0 <= i1 && i1 < V && (0 <= j1 && j1 < V)
; [eval] 0 <= i1
(push) ; 18
; [then-branch: 186 | 0 <= i1@187@06 | live]
; [else-branch: 186 | !(0 <= i1@187@06) | live]
(push) ; 19
; [then-branch: 186 | 0 <= i1@187@06]
(assert (<= 0 i1@187@06))
; [eval] i1 < V
(push) ; 20
; [then-branch: 187 | i1@187@06 < V@27@06 | live]
; [else-branch: 187 | !(i1@187@06 < V@27@06) | live]
(push) ; 21
; [then-branch: 187 | i1@187@06 < V@27@06]
(assert (< i1@187@06 V@27@06))
; [eval] 0 <= j1
(push) ; 22
; [then-branch: 188 | 0 <= j1@188@06 | live]
; [else-branch: 188 | !(0 <= j1@188@06) | live]
(push) ; 23
; [then-branch: 188 | 0 <= j1@188@06]
(assert (<= 0 j1@188@06))
; [eval] j1 < V
(pop) ; 23
(push) ; 23
; [else-branch: 188 | !(0 <= j1@188@06)]
(assert (not (<= 0 j1@188@06)))
(pop) ; 23
(pop) ; 22
; Joined path conditions
; Joined path conditions
(pop) ; 21
(push) ; 21
; [else-branch: 187 | !(i1@187@06 < V@27@06)]
(assert (not (< i1@187@06 V@27@06)))
(pop) ; 21
(pop) ; 20
; Joined path conditions
; Joined path conditions
(pop) ; 19
(push) ; 19
; [else-branch: 186 | !(0 <= i1@187@06)]
(assert (not (<= 0 i1@187@06)))
(pop) ; 19
(pop) ; 18
; Joined path conditions
; Joined path conditions
(assert (and
  (and (and (< j1@188@06 V@27@06) (<= 0 j1@188@06)) (< i1@187@06 V@27@06))
  (<= 0 i1@187@06)))
; [eval] aloc(opt_get1(aloc(opt_get1(G), i1).option$array$), j1)
; [eval] opt_get1(aloc(opt_get1(G), i1).option$array$)
; [eval] aloc(opt_get1(G), i1)
; [eval] opt_get1(G)
(push) ; 18
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 18
; Joined path conditions
(push) ; 18
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 19
(assert (not (< i1@187@06 (alen<Int> (opt_get1 $Snap.unit G@24@06)))))
(check-sat)
; unsat
(pop) ; 19
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               25816
;  :arith-add-rows          18327
;  :arith-assert-diseq      1707
;  :arith-assert-lower      7206
;  :arith-assert-upper      4548
;  :arith-bound-prop        2341
;  :arith-conflicts         460
;  :arith-eq-adapter        4900
;  :arith-fixed-eqs         2355
;  :arith-offset-eqs        2805
;  :arith-pivots            3858
;  :conflicts               1069
;  :datatype-accessor-ax    77
;  :datatype-constructor-ax 680
;  :datatype-occurs-check   488
;  :datatype-splits         409
;  :decisions               2843
;  :del-clause              33994
;  :final-checks            177
;  :interface-eqs           6
;  :max-generation          8
;  :max-memory              10.04
;  :memory                  9.37
;  :minimized-lits          122
;  :mk-bool-var             45565
;  :mk-clause               34033
;  :num-allocs              432819
;  :num-checks              286
;  :propagations            16787
;  :quant-instantiations    10837
;  :rlimit-count            1339334)
(assert (< i1@187@06 (alen<Int> (opt_get1 $Snap.unit G@24@06))))
(pop) ; 18
; Joined path conditions
(assert (< i1@187@06 (alen<Int> (opt_get1 $Snap.unit G@24@06))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@178@06  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@187@06)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@187@06)))
(push) ; 18
(assert (not (<
  $Perm.No
  (+
    (+
      (+
        (-
          (-
            (ite
              (and
                (<
                  (inv@33@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@187@06))
                  V@27@06)
                (<=
                  0
                  (inv@33@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@187@06))))
              $k@32@06
              $Perm.No)
            (pTaken@88@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@187@06)))
          (pTaken@97@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@187@06)))
        (-
          (-
            (ite
              (and
                (<
                  (inv@71@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@187@06))
                  V@27@06)
                (<=
                  0
                  (inv@71@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@187@06))))
              $Perm.Write
              $Perm.No)
            (pTaken@87@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@187@06)))
          (pTaken@98@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@187@06))))
      (ite
        (and
          (<
            (inv@121@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@187@06))
            V@27@06)
          (<=
            0
            (inv@121@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@187@06))))
        $k@120@06
        $Perm.No))
    (ite
      (and
        (<
          (inv@129@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@187@06))
          V@27@06)
        (<=
          0
          (inv@129@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@187@06))))
      $k@128@06
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 18
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               26342
;  :arith-add-rows          19037
;  :arith-assert-diseq      1758
;  :arith-assert-lower      7414
;  :arith-assert-upper      4695
;  :arith-bound-prop        2415
;  :arith-conflicts         474
;  :arith-eq-adapter        5033
;  :arith-fixed-eqs         2425
;  :arith-offset-eqs        2884
;  :arith-pivots            3951
;  :conflicts               1092
;  :datatype-accessor-ax    77
;  :datatype-constructor-ax 682
;  :datatype-occurs-check   488
;  :datatype-splits         409
;  :decisions               2889
;  :del-clause              34416
;  :final-checks            177
;  :interface-eqs           6
;  :max-generation          8
;  :max-memory              10.04
;  :memory                  9.38
;  :minimized-lits          122
;  :mk-bool-var             46427
;  :mk-clause               34639
;  :num-allocs              436859
;  :num-checks              287
;  :propagations            17152
;  :quant-instantiations    11006
;  :rlimit-count            1366952
;  :time                    0.00)
(push) ; 18
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 19
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@178@06  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@187@06))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 19
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               26342
;  :arith-add-rows          19037
;  :arith-assert-diseq      1758
;  :arith-assert-lower      7414
;  :arith-assert-upper      4695
;  :arith-bound-prop        2415
;  :arith-conflicts         474
;  :arith-eq-adapter        5033
;  :arith-fixed-eqs         2425
;  :arith-offset-eqs        2884
;  :arith-pivots            3951
;  :conflicts               1093
;  :datatype-accessor-ax    77
;  :datatype-constructor-ax 682
;  :datatype-occurs-check   488
;  :datatype-splits         409
;  :decisions               2889
;  :del-clause              34416
;  :final-checks            177
;  :interface-eqs           6
;  :max-generation          8
;  :max-memory              10.04
;  :memory                  9.38
;  :minimized-lits          122
;  :mk-bool-var             46427
;  :mk-clause               34639
;  :num-allocs              436949
;  :num-checks              288
;  :propagations            17152
;  :quant-instantiations    11006
;  :rlimit-count            1367047)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@178@06  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@187@06))
    (as None<option<array>>  option<array>))))
(pop) ; 18
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@178@06  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@187@06))
    (as None<option<array>>  option<array>))))
(push) ; 18
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 19
(assert (not (<
  j1@188@06
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@178@06  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@187@06)))))))
(check-sat)
; unsat
(pop) ; 19
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               26348
;  :arith-add-rows          19043
;  :arith-assert-diseq      1758
;  :arith-assert-lower      7417
;  :arith-assert-upper      4696
;  :arith-bound-prop        2415
;  :arith-conflicts         475
;  :arith-eq-adapter        5034
;  :arith-fixed-eqs         2426
;  :arith-offset-eqs        2884
;  :arith-pivots            3955
;  :conflicts               1094
;  :datatype-accessor-ax    77
;  :datatype-constructor-ax 682
;  :datatype-occurs-check   488
;  :datatype-splits         409
;  :decisions               2889
;  :del-clause              34420
;  :final-checks            177
;  :interface-eqs           6
;  :max-generation          8
;  :max-memory              10.04
;  :memory                  9.38
;  :minimized-lits          122
;  :mk-bool-var             46438
;  :mk-clause               34643
;  :num-allocs              437142
;  :num-checks              289
;  :propagations            17154
;  :quant-instantiations    11013
;  :rlimit-count            1367556)
(assert (<
  j1@188@06
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@178@06  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@187@06))))))
(pop) ; 18
; Joined path conditions
(assert (<
  j1@188@06
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@178@06  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@187@06))))))
(pop) ; 17
(declare-fun inv@189@06 ($Ref) Int)
(declare-fun inv@190@06 ($Ref) Int)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(assert (forall ((i1@187@06 Int) (j1@188@06 Int)) (!
  (and
    (< i1@187@06 (alen<Int> (opt_get1 $Snap.unit G@24@06)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@178@06  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@187@06)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@187@06))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@178@06  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@187@06))
        (as None<option<array>>  option<array>)))
    (<
      j1@188@06
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@178@06  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@187@06))))))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@178@06  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@187@06))) j1@188@06))
  :qid |int-aux|)))
(declare-const sm@191@06 $FVF<Int>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@143@06 r) V@27@06) (<= 0 (inv@143@06 r)))
        (< (inv@142@06 r) V@27@06))
      (<= 0 (inv@142@06 r)))
    (=
      ($FVF.lookup_int (as sm@191@06  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@118@06)))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@191@06  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@118@06)))))))))))))))) r))
  :qid |qp.fvfValDef67|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@138@06 r) V@27@06) (<= 0 (inv@138@06 r)))
        (< (inv@137@06 r) V@27@06))
      (<= 0 (inv@137@06 r)))
    (=
      ($FVF.lookup_int (as sm@191@06  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@118@06))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@191@06  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@118@06))))))))))))))) r))
  :qid |qp.fvfValDef68|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@163@06 r) V@27@06) (<= 0 (inv@163@06 r)))
    (=
      ($FVF.lookup_int (as sm@191@06  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@161@06))))) r)))
  :pattern (($FVF.lookup_int (as sm@191@06  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@161@06))))) r))
  :qid |qp.fvfValDef69|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@118@06)))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@118@06))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@161@06))))) r) r))
  :pattern (($FVF.lookup_int (as sm@191@06  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef70|)))
; Check receiver injectivity
(push) ; 17
(assert (not (forall ((i11@187@06 Int) (j11@188@06 Int) (i12@187@06 Int) (j12@188@06 Int)) (!
  (implies
    (and
      (and
        (and
          (and
            (and (< j11@188@06 V@27@06) (<= 0 j11@188@06))
            (< i11@187@06 V@27@06))
          (<= 0 i11@187@06))
        ($FVF.loc_int ($FVF.lookup_int (as sm@191@06  $FVF<Int>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@178@06  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@24@06) i11@187@06))) j11@188@06)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@178@06  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@24@06) i11@187@06))) j11@188@06)))
      (and
        (and
          (and
            (and (< j12@188@06 V@27@06) (<= 0 j12@188@06))
            (< i12@187@06 V@27@06))
          (<= 0 i12@187@06))
        ($FVF.loc_int ($FVF.lookup_int (as sm@191@06  $FVF<Int>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@178@06  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@24@06) i12@187@06))) j12@188@06)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@178@06  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@24@06) i12@187@06))) j12@188@06)))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@178@06  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@24@06) i11@187@06))) j11@188@06)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@178@06  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@24@06) i12@187@06))) j12@188@06)))
    (and (= i11@187@06 i12@187@06) (= j11@188@06 j12@188@06)))
  
  :qid |int-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               26454
;  :arith-add-rows          19131
;  :arith-assert-diseq      1758
;  :arith-assert-lower      7433
;  :arith-assert-upper      4704
;  :arith-bound-prop        2421
;  :arith-conflicts         475
;  :arith-eq-adapter        5067
;  :arith-fixed-eqs         2432
;  :arith-offset-eqs        2884
;  :arith-pivots            3987
;  :conflicts               1095
;  :datatype-accessor-ax    77
;  :datatype-constructor-ax 682
;  :datatype-occurs-check   488
;  :datatype-splits         409
;  :decisions               2889
;  :del-clause              35059
;  :final-checks            177
;  :interface-eqs           6
;  :max-generation          8
;  :max-memory              10.04
;  :memory                  9.39
;  :minimized-lits          122
;  :mk-bool-var             47191
;  :mk-clause               35098
;  :num-allocs              441296
;  :num-checks              290
;  :propagations            17193
;  :quant-instantiations    11217
;  :rlimit-count            1383460
;  :time                    0.00)
; Definitional axioms for inverse functions
(assert (forall ((i1@187@06 Int) (j1@188@06 Int)) (!
  (implies
    (and
      (and (and (< j1@188@06 V@27@06) (<= 0 j1@188@06)) (< i1@187@06 V@27@06))
      (<= 0 i1@187@06))
    (and
      (=
        (inv@189@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@178@06  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@187@06))) j1@188@06))
        i1@187@06)
      (=
        (inv@190@06 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@178@06  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@187@06))) j1@188@06))
        j1@188@06)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@178@06  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@24@06) i1@187@06))) j1@188@06))
  :qid |int-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@190@06 r) V@27@06) (<= 0 (inv@190@06 r)))
        (< (inv@189@06 r) V@27@06))
      (<= 0 (inv@189@06 r)))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@178@06  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@24@06) (inv@189@06 r)))) (inv@190@06 r))
      r))
  :pattern ((inv@189@06 r))
  :pattern ((inv@190@06 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@190@06 r) V@27@06) (<= 0 (inv@190@06 r)))
        (< (inv@189@06 r) V@27@06))
      (<= 0 (inv@189@06 r)))
    ($FVF.loc_int ($FVF.lookup_int (as sm@191@06  $FVF<Int>) r) r))
  :pattern ((inv@189@06 r) (inv@190@06 r))
  )))
; Precomputing data for removing quantified permissions
(define-fun pTaken@192@06 ((r $Ref)) $Perm
  (ite
    (and
      (and
        (and (< (inv@190@06 r) V@27@06) (<= 0 (inv@190@06 r)))
        (< (inv@189@06 r) V@27@06))
      (<= 0 (inv@189@06 r)))
    ($Perm.min
      (ite
        (and
          (and
            (and (< (inv@143@06 r) V@27@06) (<= 0 (inv@143@06 r)))
            (< (inv@142@06 r) V@27@06))
          (<= 0 (inv@142@06 r)))
        $Perm.Write
        $Perm.No)
      $Perm.Write)
    $Perm.No))
(define-fun pTaken@193@06 ((r $Ref)) $Perm
  (ite
    (and
      (and
        (and (< (inv@190@06 r) V@27@06) (<= 0 (inv@190@06 r)))
        (< (inv@189@06 r) V@27@06))
      (<= 0 (inv@189@06 r)))
    ($Perm.min
      (ite
        (and
          (and
            (and (< (inv@138@06 r) V@27@06) (<= 0 (inv@138@06 r)))
            (< (inv@137@06 r) V@27@06))
          (<= 0 (inv@137@06 r)))
        $Perm.Write
        $Perm.No)
      (- $Perm.Write (pTaken@192@06 r)))
    $Perm.No))
(define-fun pTaken@194@06 ((r $Ref)) $Perm
  (ite
    (and
      (and
        (and (< (inv@190@06 r) V@27@06) (<= 0 (inv@190@06 r)))
        (< (inv@189@06 r) V@27@06))
      (<= 0 (inv@189@06 r)))
    ($Perm.min
      (ite
        (and (< (inv@163@06 r) V@27@06) (<= 0 (inv@163@06 r)))
        $Perm.Write
        $Perm.No)
      (- (- $Perm.Write (pTaken@192@06 r)) (pTaken@193@06 r)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 500)
(push) ; 17
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and
          (and
            (and (< (inv@143@06 r) V@27@06) (<= 0 (inv@143@06 r)))
            (< (inv@142@06 r) V@27@06))
          (<= 0 (inv@142@06 r)))
        $Perm.Write
        $Perm.No)
      (pTaken@192@06 r))
    $Perm.No)
  
  ))))
(check-sat)
; unknown
(pop) ; 17
; 0.07s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               32156
;  :arith-add-rows          21129
;  :arith-assert-diseq      1856
;  :arith-assert-lower      8355
;  :arith-assert-upper      5762
;  :arith-bound-prop        2612
;  :arith-conflicts         495
;  :arith-eq-adapter        5681
;  :arith-fixed-eqs         2813
;  :arith-offset-eqs        3085
;  :arith-pivots            4598
;  :conflicts               1151
;  :datatype-accessor-ax    129
;  :datatype-constructor-ax 810
;  :datatype-occurs-check   625
;  :datatype-splits         578
;  :decisions               4845
;  :del-clause              45091
;  :final-checks            196
;  :interface-eqs           6
;  :max-generation          10
;  :max-memory              11.33
;  :memory                  11.10
;  :minimized-lits          125
;  :mk-bool-var             59952
;  :mk-clause               45130
;  :num-allocs              490005
;  :num-checks              292
;  :propagations            21438
;  :quant-instantiations    16025
;  :rlimit-count            1543182
;  :time                    0.07)
; Intermediate check if already taken enough permissions
(push) ; 17
(assert (not (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@190@06 r) V@27@06) (<= 0 (inv@190@06 r)))
        (< (inv@189@06 r) V@27@06))
      (<= 0 (inv@189@06 r)))
    (= (- $Perm.Write (pTaken@192@06 r)) $Perm.No))
  
  ))))
(check-sat)
; unknown
(pop) ; 17
; 0.08s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               38936
;  :arith-add-rows          23510
;  :arith-assert-diseq      2020
;  :arith-assert-lower      9618
;  :arith-assert-upper      7004
;  :arith-bound-prop        2854
;  :arith-conflicts         518
;  :arith-eq-adapter        6429
;  :arith-fixed-eqs         3326
;  :arith-offset-eqs        3521
;  :arith-pivots            5125
;  :conflicts               1217
;  :datatype-accessor-ax    184
;  :datatype-constructor-ax 930
;  :datatype-occurs-check   750
;  :datatype-splits         735
;  :decisions               6980
;  :del-clause              58851
;  :final-checks            213
;  :interface-eqs           6
;  :max-generation          12
;  :max-memory              11.72
;  :memory                  11.40
;  :minimized-lits          128
;  :mk-bool-var             75626
;  :mk-clause               58890
;  :num-allocs              535893
;  :num-checks              293
;  :propagations            26931
;  :quant-instantiations    21331
;  :rlimit-count            1719469
;  :time                    0.08)
; Chunk depleted?
(push) ; 17
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and
          (and
            (and (< (inv@138@06 r) V@27@06) (<= 0 (inv@138@06 r)))
            (< (inv@137@06 r) V@27@06))
          (<= 0 (inv@137@06 r)))
        $Perm.Write
        $Perm.No)
      (pTaken@193@06 r))
    $Perm.No)
  
  ))))
(check-sat)
; unknown
(pop) ; 17
; 0.13s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               50653
;  :arith-add-rows          28898
;  :arith-assert-diseq      2420
;  :arith-assert-lower      12209
;  :arith-assert-upper      9248
;  :arith-bound-prop        3397
;  :arith-conflicts         560
;  :arith-eq-adapter        7864
;  :arith-fixed-eqs         4423
;  :arith-offset-eqs        4750
;  :arith-pivots            6106
;  :conflicts               1309
;  :datatype-accessor-ax    232
;  :datatype-constructor-ax 1043
;  :datatype-occurs-check   875
;  :datatype-splits         897
;  :decisions               9925
;  :del-clause              77599
;  :final-checks            230
;  :interface-eqs           6
;  :max-generation          12
;  :max-memory              13.14
;  :memory                  12.66
;  :minimized-lits          199
;  :mk-bool-var             98311
;  :mk-clause               77638
;  :num-allocs              607752
;  :num-checks              294
;  :propagations            35988
;  :quant-instantiations    28773
;  :rlimit-count            2039594
;  :time                    0.13)
; Intermediate check if already taken enough permissions
(push) ; 17
(assert (not (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@190@06 r) V@27@06) (<= 0 (inv@190@06 r)))
        (< (inv@189@06 r) V@27@06))
      (<= 0 (inv@189@06 r)))
    (= (- (- $Perm.Write (pTaken@192@06 r)) (pTaken@193@06 r)) $Perm.No))
  
  ))))
(check-sat)
; unsat
(pop) ; 17
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               51096
;  :arith-add-rows          29206
;  :arith-assert-diseq      2439
;  :arith-assert-lower      12294
;  :arith-assert-upper      9336
;  :arith-bound-prop        3430
;  :arith-conflicts         568
;  :arith-eq-adapter        7948
;  :arith-fixed-eqs         4474
;  :arith-offset-eqs        4794
;  :arith-pivots            6197
;  :conflicts               1320
;  :datatype-accessor-ax    232
;  :datatype-constructor-ax 1045
;  :datatype-occurs-check   875
;  :datatype-splits         897
;  :decisions               9937
;  :del-clause              78279
;  :final-checks            230
;  :interface-eqs           6
;  :max-generation          12
;  :max-memory              13.14
;  :memory                  12.58
;  :minimized-lits          200
;  :mk-bool-var             99324
;  :mk-clause               78318
;  :num-allocs              612486
;  :num-checks              295
;  :propagations            36210
;  :quant-instantiations    29036
;  :rlimit-count            2060408
;  :time                    0.01)
; Final check if taken enough permissions
; Done removing quantified permissions
; Definitional axioms for snapshot map values
(pop) ; 16
(pop) ; 15
(pop) ; 14
(pop) ; 13
(pop) ; 12
(pop) ; 11
(pop) ; 10
(pop) ; 9
(pop) ; 8
(pop) ; 7
(pop) ; 6
(pop) ; 5
(pop) ; 4
(pop) ; 3
(pop) ; 2
(pop) ; 1
